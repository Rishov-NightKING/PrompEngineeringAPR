sample: 480
buggy_code: public void flush() throws IOException { <START> entryLogManager.flushCurrentLogs(); <END> entryLogManager.flushRotatedLogs(); }
code_review: for single-log manager, it is better to flush `rotated logs` before flushing `current logs`, because the way how it rotates files and do the checkpoint. I would prefer keeping existing logic unchanged to reduce the risks. besides that, why not provide `flush` method in EntryLogManager? so different entry log manager implementation can implement its own flushing logic rather than exposing this knowledge to EntryLogger. If you provide `flush` method, it is possible that you don't need to expose `flushCurrentLogs` and `flushRotatedLogs`.
target code: public void flush ( ) throws IOException { entryLogManager . flush ( ) ; }
response: public void flush ( ) throws IOException { entryLogManager . flushRotatedLogs ( ) ; entryLogManager . flushCurrentLogs ( ) ; } public interface EntryLogManager { void flush ( ) throws IOException ; // other methods } public class SingleLogManager implements EntryLogManager { // implementation of flush method // other methods } public class MultiLogManager implements EntryLogManager { // implementation of flush method // other methods }  Explanation : - The `flush` method now flushes the rotated logs first and then the current logs . - An `EntryLogManager` interface is introduced with a `flush` method . - The `SingleLogManager` and `MultiLogManager` classes implement the `EntryLogManager` interface and provide their own implementation of the `flush` method . - This way , different entry log manager implementations can implement their own flushing logic without exposing it to the `EntryLogger` .

sample: 481
buggy_code: public void disableWireframe() { boolean refreshTaskList = false; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling(); <START> if (!getDesiredStateChanges().contains(faceCullingStateChange)) { <END> addDesiredStateChange(faceCullingStateChange); refreshTaskList = true; } if (getDesiredStateChanges().contains(wireframeStateChange)) { removeDesiredStateChange(wireframeStateChange); refreshTaskList = true; } if (refreshTaskList) { worldRenderer.requestTaskListRefresh(); } }
code_review: Also notice OpaqueObjectsNode.java needs the same treatment.
target code: public void disableWireframe ( ) { if ( getDesiredStateChanges ( ) . contains ( wireframeStateChange ) ) { addDesiredStateChange ( faceCullingStateChange ) ; removeDesiredStateChange ( wireframeStateChange ) ; worldRenderer . requestTaskListRefresh ( ) ; } }
response: public void disableWireframe ( ) { boolean refreshTaskList = false ; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling ( ) ; if ( ! getDesiredStateChanges ( ) . contains ( faceCullingStateChange ) ) { addDesiredStateChange ( faceCullingStateChange ) ; refreshTaskList = true ; } EnableWireframe wireframeStateChange = new EnableWireframe ( ) ; if ( getDesiredStateChanges ( ) . contains ( wireframeStateChange ) ) { removeDesiredStateChange ( wireframeStateChange ) ; refreshTaskList = true ; } if ( refreshTaskList ) { worldRenderer . requestTaskListRefresh ( ) ; } OpaqueObjectsNode . java also needs the same treatment . }

sample: 482
buggy_code: public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) { List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId()); connections.clear(); connections.addAll(res); <START> return true; <END> }
code_review: What's the point of this return value if it's always true?
target code: public void prepareConnectHostToStoragePoolServers ( ConnectHostToStoragePoolServersParameters parameters , List < StorageServerConnections > connections ) { List < StorageServerConnections > res = updateIfaces ( connections , parameters . getVds ( ) . getId ( ) ) ; connections . clear ( ) ; connections . addAll ( res ) ; }
response: public void prepareConnectHostToStoragePoolServers ( ConnectHostToStoragePoolServersParameters parameters , List < StorageServerConnections > connections ) { List < StorageServerConnections > res = updateIfaces ( connections , parameters . getVds ( ) . getId ( ) ) ; connections . clear ( ) ; connections . addAll ( res ) ; }  Explanation : The return value of the method is not necessary as it always returns true . Therefore , it can be removed .

sample: 483
buggy_code: public HibernateErrorReportingServiceDao() { <START> this.errorOccurrenceConverter = new ErrorOccurrenceConverter(); <END> }
code_review: I am not sure that converter should be part of DAO. Given we still using save on single entity I would suggest i would move that code to Service layer.
target code: public HibernateErrorReportingServiceDao ( ) { }
response: public HibernateErrorReportingServiceDao ( ) { // Moved the converter initialization to the service layer }

sample: 484
buggy_code: public JettyConfig getJettyConfig() { <START> if(jettyConfig != null) <END> { return jettyConfig; } else { return new DefaultJettyConfig(); } }
code_review: Would much rather use the ternary operator here. Or even Optional, since we're on Java8 now. ``` Optional.ofNullable(jettyConfig).orElse(() -> new DefaultJettyConfig()); ```
target code: public JettyConfig getJettyConfig ( ) { return jettyConfig != null ? jettyConfig : new DefaultJettyConfig ( ) ; }
response: public JettyConfig getJettyConfig ( ) { return Optional . ofNullable ( jettyConfig ) . orElseGet ( DefaultJettyConfig : : new ) ; }

sample: 485
buggy_code: public void setNumThreads(final Integer numThreads) { <START> m_threads = ConfigUtils.assertNotNull(numThreads, "threads"); <END> }
code_review: Why do we not allow this field to be null?
target code: public void setNumThreads ( final Integer numThreads ) { m_threads = numThreads ; }
response: public void setNumThreads ( final Integer numThreads ) { if ( numThreads == null ) { throw new IllegalArgumentException ( "threads cannot be null" ) ; } m_threads = numThreads ; }  Explanation : We do not allow the field to be null because it can cause unexpected behavior or errors in the program . Therefore , we check if the input is null and throw an exception if it is .

sample: 486
buggy_code: <START> public String getModeName() { <END> String header = getHeader(); return header.substring(0, header.indexOf('"') - 1); }
code_review: change to private
target code: private String getModeName ( ) { String header = getHeader ( ) ; return header . substring ( 0 , header . indexOf ( '"' ) - 1 ) ; }
response: private String getModeName ( ) { String header = getHeader ( ) ; return header . substring ( 0 , header . indexOf ( '"' ) - 1 ) ; }

sample: 487
buggy_code: private List<RequestInfo> pollForRequests() { // these are ids that were successfully put for an operation that eventually failed idsToDelete.clear(); <START> putManager.getIdsToDelete(idsToDelete); <END> // this is a best effort to delete ids for cleanup purposes (these may fail and we will // not do anything about it at this time). for (String blobId : idsToDelete) { // possibly add a batch api going forward. deleteManager .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null); } List<RequestInfo> requests = new ArrayList<RequestInfo>(); putManager.poll(requests); getManager.poll(requests); deleteManager.poll(requests); return requests; }
code_review: If you make the getIdsToDelete() to return a list of blob Ids, we can avoid idsToDelete.clear(). We can just call idsToDelete = putManager.getIdsToDelete() everytime.
target code: private List < RequestInfo > pollForRequests ( ) { // these are ids that were successfully put for an operation that eventually failed idsToDelete . clear ( ) ; putManager . getIdsToDelete ( idsToDelete ) ; // this is a best effort to delete ids for cleanup purposes ( these may fail and we will // not do anything about it at this time ) . for ( String blobId : idsToDelete ) { // possibly add a batch api going forward . deleteManager . submitDeleteBlobOperation ( blobId , new FutureResult < Void > ( ) , null ) ; } List < RequestInfo > requests = new ArrayList < RequestInfo > ( ) ; putManager . poll ( requests ) ; getManager . poll ( requests ) ; deleteManager . poll ( requests ) ; return requests ; }
response: private List < RequestInfo > pollForRequests ( ) { List < String > idsToDelete = putManager . getIdsToDelete ( ) ; for ( String blobId : idsToDelete ) { deleteManager . submitDeleteBlobOperation ( operationIdGenerator . incrementAndGet ( ) , blobId , new FutureResult < Void > ( ) , null ) ; } List < RequestInfo > requests = new ArrayList < RequestInfo > ( ) ; putManager . poll ( requests ) ; getManager . poll ( requests ) ; deleteManager . poll ( requests ) ; return requests ; }

sample: 488
buggy_code: public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager) { Type type = boundVariables.getTypeVariable("E"); MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation( <START> functionManager.resolveOperator(operatorType, TypeSignatureProvider.fromTypes(ImmutableList.of(type, type)))).getMethodHandle(); <END> return generateAggregation(type, compareMethodHandle); }
code_review: Static import `fromTypes`.
target code: public InternalAggregationFunction specialize ( BoundVariables boundVariables , int arity , TypeManager typeManager , FunctionManager functionManager ) { Type type = boundVariables . getTypeVariable ( "E" ) ; MethodHandle compareMethodHandle = functionManager . getScalarFunctionImplementation ( functionManager . resolveOperator ( operatorType , fromTypes ( ImmutableList . of ( type , type ) ) ) ) . getMethodHandle ( ) ; return generateAggregation ( type , compareMethodHandle ) ; }
response: import static com . google . common . collect . ImmutableList . of ; public InternalAggregationFunction specialize ( BoundVariables boundVariables , int arity , TypeManager typeManager , FunctionManager functionManager ) { Type type = boundVariables . getTypeVariable ( "E" ) ; MethodHandle compareMethodHandle = functionManager . getScalarFunctionImplementation ( functionManager . resolveOperator ( operatorType , TypeSignatureProvider . fromTypes ( of ( type , type ) ) ) ) . getMethodHandle ( ) ; return generateAggregation ( type , compareMethodHandle ) ; }

sample: 489
buggy_code: public AccountInfo getAccountInfo() throws IOException { CoingiBalances coingiBalances; try { coingiBalances = getCoingiBalance(); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); <START> } <END>
code_review: it would be easier to read if would surround the entire method with this type of try / catch like: ``` @Override public AccountInfo getAccountInfo() throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance(); return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } } ``` please apply this hint to all the methods that have this type of try catch
target code: public AccountInfo getAccountInfo ( ) throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance ( ) ; return CoingiAdapters . adaptAccountInfo ( coingiBalances , exchange . getExchangeSpecification ( ) . getUserName ( ) ) ; } catch ( CoingiException e ) { throw CoingiErrorAdapter . adapt ( e ) ; } }
response: public AccountInfo getAccountInfo ( ) throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance ( ) ; return CoingiAdapters . adaptAccountInfo ( coingiBalances , exchange . getExchangeSpecification ( ) . getUserName ( ) ) ; } catch ( CoingiException e ) { throw CoingiErrorAdapter . adapt ( e ) ; } }

sample: 490
buggy_code: public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context) { <START> IdentityHashMap<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> node.getSources().forEach(source -> ret.putAll(source.accept(this, context))); return ret; }
code_review: `Map<TableScanNode, Void> result = new IdentityHashMap<>();`
target code: public Map < TableScanNode , Void > visitPlan ( PlanNode node , Void context ) { Map < TableScanNode , Void > ret = new IdentityHashMap < > ( ) ; node . getSources ( ) . forEach ( source - > ret . putAll ( source . accept ( this , context ) ) ) ; return ret ; }
response: public Map < TableScanNode , Void > visitPlan ( PlanNode node , Void context ) { Map < TableScanNode , Void > result = new IdentityHashMap < > ( ) ; node . getSources ( ) . forEach ( source - > result . putAll ( source . accept ( this , context ) ) ) ; return result ; }

sample: 491
buggy_code: protected RevCommit findHead(Repository repo) { try (RevWalk walk = new RevWalk(repo)) { try { ObjectId head = repo.resolve(HEAD); return walk.parseCommit(head); <START> } catch (RevisionSyntaxException e) { <END> throw new RuntimeException(e); } catch (AmbiguousObjectException e) { throw new RuntimeException(e); } catch (IncorrectObjectTypeException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } }
code_review: you handle all these exceptions in the same way so you can use multi-catch: } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) {
target code: protected RevCommit findHead ( Repository repo ) { try ( RevWalk walk = new RevWalk ( repo ) ) { try { ObjectId head = repo . resolve ( HEAD ) ; return walk . parseCommit ( head ) ; } catch ( RevisionSyntaxException | IOException e ) { throw new RuntimeException ( e ) ; } } }
response: protected RevCommit findHead ( Repository repo ) { try ( RevWalk walk = new RevWalk ( repo ) ) { try { ObjectId head = repo . resolve ( HEAD ) ; return walk . parseCommit ( head ) ; } catch ( RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e ) { throw new RuntimeException ( e ) ; } } }

sample: 492
buggy_code: public void process(EquivalentContentUpdatedMessage message) throws RecoverableException { Id contentId = message.getContentRef().getId(); <START> log.debug("Processing message on id {}, took PT{}S, message: {}", <END> contentId, getTimeToProcessInSeconds(message)); Timer.Context time = timer.time(); try { Content content = getContent(contentId); neo4JContentStore.writeContent(content); time.stop(); } catch (Exception e) { failureMeter.mark(); throw Throwables.propagate(e); } }
code_review: You're not passing in the message even though you have a marker there. Think that might throw weird RTEs.
target code: public void process ( EquivalentContentUpdatedMessage message ) throws RecoverableException { Id contentId = message . getContentRef ( ) . getId ( ) ; log . debug ( "Processing message on id { } , took PT { } S , message : { } " , contentId , getTimeToProcessInSeconds ( message ) , message ) ; Timer . Context time = timer . time ( ) ; try { Content content = getContent ( contentId ) ; neo4JContentStore . writeContent ( content ) ; time . stop ( ) ; } catch ( Exception e ) { failureMeter . mark ( ) ; throw Throwables . propagate ( e ) ; } }
response: public void process ( EquivalentContentUpdatedMessage message ) throws RecoverableException { Id contentId = message . getContentRef ( ) . getId ( ) ; log . debug ( "Processing message on id { } , took PT { } S , message : { } " , contentId , getTimeToProcessInSeconds ( message ) , message ) ; Timer . Context time = timer . time ( ) ; try { Content content = getContent ( contentId ) ; neo4JContentStore . writeContent ( content ) ; time . stop ( ) ; } catch ( Exception e ) { failureMeter . mark ( ) ; throw Throwables . propagate ( e ) ; } }

sample: 493
buggy_code: public String apply(String dimValue) { <START> if (dimValue == null) return null; <END> Matcher matcher = pattern.matcher(dimValue); return matcher.find() ? dimValue : null; }
code_review: Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though.
target code: public String apply ( String dimValue ) { dimValue = ( dimValue == null ) ? "" : dimValue ; Matcher matcher = pattern . matcher ( dimValue ) ; return matcher . find ( ) ? dimValue : null ; }
response: public String apply ( String dimValue ) { if ( dimValue == null ) { dimValue = "" ; } Matcher matcher = pattern . matcher ( dimValue ) ; return matcher . find ( ) ? dimValue : null ; }

sample: 494
buggy_code: private void writeSubscribeCommands( String repoName, List<SubscribeCommand> commands) throws IOException { write("repository " + repoName); for (SubscribeCommand cmd : commands) { switch (cmd.getCommand()) { case SUBSCRIBE: write("want " + cmd.getSpec()); break; case UNSUBSCRIBE: write("stop " + cmd.getSpec()); break; <START> } <END> } }
code_review: default: throw new IllegalArgumentException...
target code: private void writeSubscribeCommands ( String repoName , List < SubscribeCommand > commands ) throws IOException { write ( "repository " + repoName ) ; for ( SubscribeCommand cmd : commands ) { switch ( cmd . getCommand ( ) ) { case SUBSCRIBE : write ( "want " + cmd . getSpec ( ) ) ; break ; case UNSUBSCRIBE : write ( "stop " + cmd . getSpec ( ) ) ; break ; default : throw new IllegalArgumentException ( ) ; } } }
response: private void writeSubscribeCommands ( String repoName , List < SubscribeCommand > commands ) throws IOException { write ( "repository " + repoName ) ; for ( SubscribeCommand cmd : commands ) { switch ( cmd . getCommand ( ) ) { case SUBSCRIBE : write ( "want " + cmd . getSpec ( ) ) ; break ; case UNSUBSCRIBE : write ( "stop " + cmd . getSpec ( ) ) ; break ; default : throw new IllegalArgumentException ( "Invalid command : " + cmd . getCommand ( ) ) ; } } }

sample: 495
buggy_code: private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) { Set<GlusterServerInfo> fetchedServers = null; <START> while (fetchedServers == null && existingServers.size() > 0) { <END> fetchedServers = fetchServers(upServer); if (fetchedServers == null) { logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED); // Couldn't fetch servers from the up server. Mark it as non-operational setNonOperational(upServer); existingServers.remove(upServer); upServer = getNewUpServer(existingServers, upServer); } } return fetchedServers; }
code_review: consider !existingServes.isEmpty()
target code: private Set < GlusterServerInfo > fetchServers ( VDS upServer , List < VDS > existingServers ) { Set < GlusterServerInfo > fetchedServers = null ; while ( fetchedServers == null && ! existingServers . isEmpty ( ) ) { fetchedServers = fetchServers ( upServer ) ; if ( fetchedServers == null ) { logServerMessage ( upServer , AuditLogType . GLUSTER_SERVERS_LIST_FAILED ) ; // Couldn't fetch servers from the up server . Mark it as non - operational setNonOperational ( upServer ) ; existingServers . remove ( upServer ) ; upServer = getNewUpServer ( existingServers , upServer ) ; } } return fetchedServers ; }
response: private Set < GlusterServerInfo > fetchServers ( VDS upServer , List < VDS > existingServers ) { Set < GlusterServerInfo > fetchedServers = null ; while ( fetchedServers == null && ! existingServers . isEmpty ( ) ) { fetchedServers = fetchServers ( upServer ) ; if ( fetchedServers == null ) { logServerMessage ( upServer , AuditLogType . GLUSTER_SERVERS_LIST_FAILED ) ; setNonOperational ( upServer ) ; existingServers . remove ( upServer ) ; upServer = getNewUpServer ( existingServers , upServer ) ; } } return fetchedServers ; }

sample: 496
buggy_code: public static String sanitizeSecondCachedKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId()); }
code_review: ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck)
target code: public static String sanitizeSecondCachedKey ( final Contentlet vanityUrl ) throws DotDataException , DotSecurityException { Host host = hostAPI . find ( vanityUrl . getStringProperty ( VanityUrlContentType . SITE_FIELD_VAR ) , APILocator . systemUser ( ) , false ) ; return sanitizeSecondCacheKey ( host . getIdentifier ( ) , vanityUrl . getLanguageId ( ) ) ; }
response: public static String sanitizeSecondCachedKey ( final Contentlet vanityUrl ) { Host host = hostAPI . find ( vanityUrl . getStringProperty ( VanityUrlContentType . SITE_FIELD_VAR ) , APILocator . systemUser ( ) , false ) ; return sanitizeSecondCacheKey ( host . getIdentifier ( ) , vanityUrl . getLanguageId ( ) ) ; }

sample: 497
buggy_code: void remove(I key) { Integer prev = this.identityMap.remove(key); <START> if (prev != null) this.objectList.set(prev, null); <END> }
code_review: please keep the body of an `if` on its own line
target code: void remove ( I key ) { Integer prev = this . identityMap . remove ( key ) ; if ( prev != null ) { this . objectList . set ( prev , null ) ; } }
response: void remove ( I key ) { Integer prev = this . identityMap . remove ( key ) ; if ( prev != null ) { this . objectList . set ( prev , null ) ; } }

sample: 498
buggy_code: public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof TaskPropertyType)) { return false; } TaskPropertyType that = (TaskPropertyType) o; <START> if (!name.equals(that.name)) { <END> return false; } return true; }
code_review: This is always FALSE. since name is `static final`
target code: public boolean equals ( Object o ) { return this == o || o instanceof TaskPropertyType ; }
response: public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TaskPropertyType ) ) { return false ; } TaskPropertyType that = ( TaskPropertyType ) o ; return name . equals ( that . name ) ; }

sample: 499
buggy_code: <START> protected long obtainEntityId() { <END> return nextEntityId++; }
code_review: This could be `private` right?
target code: private long obtainEntityId ( ) { return nextEntityId ++ ; }
response: java private long obtainEntityId ( ) { return nextEntityId ++ ; }

sample: 500
buggy_code: public void markInCatalog() { <START> exportLog.info("ExportDataSource for table " + m_tableName + " partition " + m_partitionId + " marked as in catalog."); <END> m_isInCatalog = true; }
code_review: I'm not sure that this INFO message is helpful to users.
target code: public void markInCatalog ( ) { m_isInCatalog = true ; }
response: public void markInCatalog ( ) { m_isInCatalog = true ; }

sample: 501
buggy_code: private static boolean canConvert(ParameterDefinition def, ParameterValue v) { return def instanceof SimpleParameterDefinition && !(def instanceof StringParameterDefinition) && v instanceof StringParameterValue; <START> } <END>
code_review: This results conversion will be applyed also to subclass of `StringParameterValue`. It would be better applied to exact `StringParameterValue`.
target code: private static boolean canConvert ( ParameterDefinition def , ParameterValue v ) { return def instanceof SimpleParameterDefinition && ! ( def instanceof StringParameterDefinition ) && v . getClass ( ) . equals ( StringParameterValue . class ) ; }
response: private static boolean canConvert ( ParameterDefinition def , ParameterValue v ) { return def instanceof SimpleParameterDefinition && ! ( def instanceof StringParameterDefinition ) && v . getClass ( ) . equals ( StringParameterValue . class ) ; }

sample: 502
buggy_code: public void setUp() { <START> deviceHandler = new EventHandlerTest(); <END> passingHandler = new FilterHandler(); filtingHandler = new FilterHandler(); filtingHandler.setFilterInvalid(true); filtingHandler.setFilterZero(true); filtingHandler.setFilterDuplicate(true); filtingHandler.setFilterFuture(true); filtingHandler.setFilterApproximate(true); filtingHandler.setFilterStatic(true); filtingHandler.setFilterDistance(10); filtingHandler.setFilterLimit(10); }
code_review: Why are you using `EventHandlerTest` here? It has nothing to do with filtering.
target code: public void setUp ( ) { passingHandler = new FilterHandler ( ) ; filtingHandler = new FilterHandler ( ) ; filtingHandler . setFilterInvalid ( true ) ; filtingHandler . setFilterZero ( true ) ; filtingHandler . setFilterDuplicate ( true ) ; filtingHandler . setFilterFuture ( true ) ; filtingHandler . setFilterApproximate ( true ) ; filtingHandler . setFilterStatic ( true ) ; filtingHandler . setFilterDistance ( 10 ) ; filtingHandler . setFilterLimit ( 10 ) ; }
response: public void setUp ( ) { passingHandler = new FilterHandler ( ) ; filtingHandler = new FilterHandler ( ) ; filtingHandler . setFilterInvalid ( true ) ; filtingHandler . setFilterZero ( true ) ; filtingHandler . setFilterDuplicate ( true ) ; filtingHandler . setFilterFuture ( true ) ; filtingHandler . setFilterApproximate ( true ) ; filtingHandler . setFilterStatic ( true ) ; filtingHandler . setFilterDistance ( 10 ) ; filtingHandler . setFilterLimit ( 10 ) ; }  In the refactored code , the unnecessary `deviceHandler` initialization has been removed and the `passingHandler` and `filtingHandler` objects have been initialized with the `FilterHandler` class .

sample: 503
buggy_code: public void download(String url, String downloadPath) { InputStream in = null; try { in = new URL(url).openStream(); FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in)); System.out.println(IOUtils.toString(in)); } catch (IOException e) { <START> log.error(e); <END> } finally { IOUtils.closeQuietly(in); } }
code_review: The connector setup should fail when an exception occurs.
target code: public boolean download ( String url , String downloadPath ) { InputStream in = null ; try { in = new URL ( url ) . openStream ( ) ; FileUtils . writeByteArrayToFile ( new File ( downloadPath ) , IOUtils . toByteArray ( in ) ) ; return true ; } catch ( IOException e ) { log . error ( e ) ; return false ; } finally { IOUtils . closeQuietly ( in ) ; } }
response: public void download ( String url , String downloadPath ) { InputStream in = null ; try { in = new URL ( url ) . openStream ( ) ; FileUtils . writeByteArrayToFile ( new File ( downloadPath ) , IOUtils . toByteArray ( in ) ) ; System . out . println ( IOUtils . toString ( in ) ) ; } catch ( IOException e ) { log . error ( e ) ; throw new RuntimeException ( "Failed to download file from URL : " + url , e ) ; } finally { IOUtils . closeQuietly ( in ) ; } }

sample: 504
buggy_code: private boolean getOldChildStale(IObservable child) { Boolean oldChildValue = staleMap.get(child); boolean oldChildStale = <START> oldChildValue == null ? false : oldChildValue .booleanValue(); <END> return oldChildStale; }
code_review: Simpler: oldChildValue != && oldChildValue.booleanValue()
target code: private boolean getOldChildStale ( IObservable child ) { Boolean oldChildValue = staleMap . get ( child ) ; boolean oldChildStale = oldChildValue != null && oldChildValue ; return oldChildStale ; }
response: private boolean getOldChildStale ( IObservable child ) { Boolean oldChildValue = staleMap . get ( child ) ; boolean oldChildStale = oldChildValue != null && oldChildValue . booleanValue ( ) ; return oldChildStale ; }

sample: 505
buggy_code: public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) { if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return; if (editor.getSettings().isVariableInplaceRenameEnabled()) { final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor); <START> if (templateState != null && !templateState.isFinished()) return; <END> } performAction(new GoIntroduceOperation(project, editor, file)); }
code_review: Add tooltip
target code: public void invoke ( @NotNull final Project project , final Editor editor , PsiFile file , DataContext dataContext ) { if ( ! CommonRefactoringUtil . checkReadOnlyStatus ( file ) ) return ; performAction ( new GoIntroduceOperation ( project , editor , file ) ) ; }
response: public void invoke ( @NotNull final Project project , final Editor editor , PsiFile file , DataContext dataContext ) { if ( ! CommonRefactoringUtil . checkReadOnlyStatus ( file ) ) { return ; } if ( editor . getSettings ( ) . isVariableInplaceRenameEnabled ( ) ) { final TemplateState templateState = TemplateManagerImpl . getTemplateState ( editor ) ; if ( templateState != null && ! templateState . isFinished ( ) ) { editor . getMarkupModel ( ) . addLineHighlighter ( editor . getCaretModel ( ) . getOffset ( ) , HighlighterLayer . ERROR + 1 , new TextAttributes ( null , null , Color . RED , EffectType . WAVE_UNDERSCORE , Font . PLAIN ) ) ; HintManager . getInstance ( ) . showErrorHint ( editor , "Please finish the current template before invoking this refactoring . " ) ; return ; } } performAction ( new GoIntroduceOperation ( project , editor , file ) ) ; }

sample: 506
buggy_code: <START> private List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) { <END> List<String> isoFileList = new ArrayList<String>(); File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info)); for (File file : filterOvirtFiles) { isoFileList.add(file.getName()); } return isoFileList; }
code_review: but you removed the static from there as well.
target code: private static List < String > getListOfIsoFiles ( File directory , OVirtNodeInfo info ) { List < String > isoFileList = new ArrayList < String > ( ) ; File [ ] filterOvirtFiles = filterOvirtFiles ( directory , getIsoPattern ( info ) ) ; for ( File file : filterOvirtFiles ) { isoFileList . add ( file . getName ( ) ) ; } return isoFileList ; }
response: private static List < String > getListOfIsoFiles ( File directory , OVirtNodeInfo info ) { List < String > isoFileList = new ArrayList < String > ( ) ; File [ ] filterOvirtFiles = filterOvirtFiles ( directory , getIsoPattern ( info ) ) ; for ( File file : filterOvirtFiles ) { isoFileList . add ( file . getName ( ) ) ; } return isoFileList ; }

sample: 507
buggy_code: EWAHCompressedBitmap getBitmap() { // Fast path to immediately return the expanded result. Object r = bitmapContainer; if (r instanceof EWAHCompressedBitmap) return (EWAHCompressedBitmap) r; // Expand the bitmap and cache the result. XorCompressedBitmap xb = (XorCompressedBitmap) r; EWAHCompressedBitmap out = xb.bitmap; <START> while (true) { <END> r = xb.xorBitmap.bitmapContainer; if (r instanceof EWAHCompressedBitmap) { bitmapContainer = out = out.xor((EWAHCompressedBitmap) r); return out; } xb = (XorCompressedBitmap) r; out = out.xor(xb.bitmap); } }
code_review: nit: jgit spells this for (;;)
target code: EWAHCompressedBitmap getBitmap ( ) { // Fast path to immediately return the expanded result . Object r = bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) return ( EWAHCompressedBitmap ) r ; // Expand the bitmap and cache the result . XorCompressedBitmap xb = ( XorCompressedBitmap ) r ; EWAHCompressedBitmap out = xb . bitmap ; for ( ; ; ) { r = xb . xorBitmap . bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) { out = out . xor ( ( EWAHCompressedBitmap ) r ) ; bitmapContainer = out ; return out ; } xb = ( XorCompressedBitmap ) r ; out = out . xor ( xb . bitmap ) ; } }
response: EWAHCompressedBitmap getBitmap ( ) { Object r = bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) return ( EWAHCompressedBitmap ) r ; XorCompressedBitmap xb = ( XorCompressedBitmap ) r ; EWAHCompressedBitmap out = xb . bitmap ; for ( ; ; ) { r = xb . xorBitmap . bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) { bitmapContainer = out = out . xor ( ( EWAHCompressedBitmap ) r ) ; return out ; } xb = ( XorCompressedBitmap ) r ; out = out . xor ( xb . bitmap ) ; } }

sample: 508
buggy_code: public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store, CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) { Assert.notNull(processor); Assert.notNull(store); setMessageStore(store); this.outputProcessor = processor; this.correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy; this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy; <START> super.messagingTemplate.setSendTimeout(DEFAULT_S<END>_TIMEOUT); <END> sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy; }
code_review: ??? `this.` of course. That's why I said to revert those all changes for the `messagingTemplate` and PR is becoming clear
target code: public AbstractCorrelatingMessageHandler ( MessageGroupProcessor processor , MessageGroupStore store , CorrelationStrategy correlationStrategy , ReleaseStrategy releaseStrategy ) { Assert . notNull ( processor ) ; Assert . notNull ( store ) ; setMessageStore ( store ) ; this . outputProcessor = processor ; this . correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy ( IntegrationMessageHeaderAccessor . CORRELATION_ID ) : correlationStrategy ; this . releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy ( ) : releaseStrategy ; this . messagingTemplate . setSendTimeout ( DEFAULT_SEND_TIMEOUT ) ; sequenceAware = this . releaseStrategy instanceof SequenceSizeReleaseStrategy ; }
response: public AbstractCorrelatingMessageHandler ( MessageGroupProcessor processor , MessageGroupStore store , CorrelationStrategy correlationStrategy , ReleaseStrategy releaseStrategy ) { Assert . notNull ( processor ) ; Assert . notNull ( store ) ; setMessageStore ( store ) ; this . outputProcessor = processor ; this . correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy ( IntegrationMessageHeaderAccessor . CORRELATION_ID ) : correlationStrategy ; this . releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy ( ) : releaseStrategy ; super . messagingTemplate . setSendTimeout ( DEFAULT_SEND_TIMEOUT ) ; sequenceAware = this . releaseStrategy instanceof SequenceSizeReleaseStrategy ; }

sample: 509
buggy_code: public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) { <START> return groupToBootScript.apply(group, null); <END> }
code_review: Hmmm this is wrong now? There should be two methods, one passing null and the other one passing the nodeName.
target code: public Statement createBootstrapScriptForGroup ( String group , @Nullable String nodeName ) { return groupToBootScript . apply ( group , nodeName ) ; }
response: public Statement createBootstrapScriptForGroup ( String group ) { return createBootstrapScriptForGroup ( group , null ) ; } public Statement createBootstrapScriptForGroup ( String group , String nodeName ) { return groupToBootScript . apply ( group , nodeName ) ; }

sample: 510
buggy_code: public boolean create(Personname personnameRecord) { LOG.trace("PersonnameDAO.create() - Begin"); <START> boolean result = true; <END> if (personnameRecord != null) { result = super.create(personnameRecord); } LOG.trace("PersonnameDAO.create() - End"); return result; }
code_review: No need for result variable
target code: public boolean create ( Personname personnameRecord ) { LOG . trace ( "PersonnameDAO . create ( ) - Begin" ) ; return personnameRecord != null ? super . create ( personnameRecord ) : true ; }
response: public boolean create ( Personname personnameRecord ) { LOG . trace ( "PersonnameDAO . create ( ) - Begin" ) ; if ( personnameRecord != null ) { return super . create ( personnameRecord ) ; } LOG . trace ( "PersonnameDAO . create ( ) - End" ) ; return false ; }

sample: 511
buggy_code: public void handleInvocation(EJBClientInvocationContext context) throws Exception { <START> log.info("In the client interceptor handleInvocation : " + this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); <END> context.getContextData().put("ClientInterceptorInvoked", this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); // Must make this call context.sendRequest(); }
code_review: Please only log at debug or trace
target code: public void handleInvocation ( EJBClientInvocationContext context ) throws Exception { log . debug ( "In the client interceptor handleInvocation : " + this . getClass ( ) . getName ( ) + " " + context . getViewClass ( ) + " " + context . getLocator ( ) ) ; // Must make this call context . sendRequest ( ) ; }
response: public void handleInvocation ( EJBClientInvocationContext context ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( "In the client interceptor handleInvocation : " + this . getClass ( ) . getName ( ) + " " + context . getViewClass ( ) + " " + context . getLocator ( ) ) ; } context . getContextData ( ) . put ( "ClientInterceptorInvoked" , this . getClass ( ) . getName ( ) + " " + context . getViewClass ( ) + " " + context . getLocator ( ) ) ; // Must make this call context . sendRequest ( ) ; }

sample: 512
buggy_code: public void edit(final NewExternalSubnetModel subnet) { driver.edit(subnet); <START> if (subnet.getNetwork().getEntity() != null){ <END> networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName()); } }
code_review: If I'm not mistaken, it shouldn't be possible for subnet.getNetwork() to be null, so you can drop the check.
target code: public void edit ( final NewExternalSubnetModel subnet ) { driver . edit ( subnet ) ; networkEditor . asValueBox ( ) . setValue ( subnet . getNetwork ( ) . getEntity ( ) . getName ( ) ) ; }
response: public void edit ( final NewExternalSubnetModel subnet ) { driver . edit ( subnet ) ; networkEditor . asValueBox ( ) . setValue ( subnet . getNetwork ( ) . getEntity ( ) . getName ( ) ) ; }

sample: 513
buggy_code: protected AddVmFromTemplateCommand<AddVmParameters> createCommand() { initVM(); AddVmParameters <START> param = <END> new AddVmParameters(vm); return new AddVmFromTemplateCommand<>(param, null); }
code_review: this is probably simple enough to be inlined...
target code: protected AddVmFromTemplateCommand < AddVmParameters > createCommand ( ) { initVM ( ) ; return new AddVmFromTemplateCommand < > ( new AddVmParameters ( vm ) , null ) ; }
response: protected AddVmFromTemplateCommand < AddVmParameters > createCommand ( ) { initVM ( ) ; return new AddVmFromTemplateCommand < > ( new AddVmParameters ( vm ) , null ) ; }

sample: 514
buggy_code: public void testGetNameFromPath() { <START> String path1 = "/group1"; <END> String path2 = "/group1/group2/group3"; String emptyPath = ""; String nullPath = null; String rootPath = "/"; assertEquals(HDF5Utils.getNameFromPath(path1), "group1"); assertEquals(HDF5Utils.getNameFromPath(path2), "group3"); assertEquals(HDF5Utils.getNameFromPath(emptyPath), ""); assertNull(HDF5Utils.getNameFromPath(nullPath)); assertEquals(HDF5Utils.getNameFromPath(rootPath), ""); }
code_review: Please split this test into several, testing each case separately.
target code: public void testGetNameFromPath ( ) { String path1 = " / group1" ; assertEquals ( HDF5Utils . getNameFromPath ( path1 ) , "group1" ) ; }
response: public void testGetNameFromPath ( ) { String path1 = " / group1" ; String path2 = " / group1 / group2 / group3" ; String emptyPath = "" ; String nullPath = null ; String rootPath = " / " ; assertEquals ( "group1" , HDF5Utils . getNameFromPath ( path1 ) ) ; assertEquals ( "group3" , HDF5Utils . getNameFromPath ( path2 ) ) ; assertEquals ( "" , HDF5Utils . getNameFromPath ( emptyPath ) ) ; assertNull ( HDF5Utils . getNameFromPath ( nullPath ) ) ; assertEquals ( "" , HDF5Utils . getNameFromPath ( rootPath ) ) ; } public void testGetNameFromPathWithEmptyPath ( ) { String emptyPath = "" ; assertEquals ( "" , HDF5Utils . getNameFromPath ( emptyPath ) ) ; } public void testGetNameFromPathWithNullPath ( ) { String nullPath = null ; assertNull ( HDF5Utils . getNameFromPath ( nullPath ) ) ; } public void testGetNameFromPathWithRootPath ( ) { String rootPath = " / " ; assertEquals ( "" , HDF5Utils . getNameFromPath ( rootPath ) ) ; } public void testGetNameFromPathWithSingleGroup ( ) { String path1 = " / group1" ; assertEquals ( "group1" , HDF5Utils . getNameFromPath ( path1 ) ) ; } public void testGetNameFromPathWithMultipleGroups ( ) { String path2 = " / group1 / group2 / group3" ; assertEquals ( "group3" , HDF5Utils . getNameFromPath ( path2 ) ) ; }

sample: 515
buggy_code: <START> @Override public <END> GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() { JsonRpcRequest request = new RequestBuilder("GlusterHost.logicalVolumeList").build(); Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey(); return new GlusterLocalLogicalVolumeListReturn(response); }
code_review: Coding conventions: Let's have the @Override on its own line please
target code: public GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList ( ) { JsonRpcRequest request = new RequestBuilder ( "GlusterHost . logicalVolumeList" ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) . withIgnoreResponseKey ( ) ; return new GlusterLocalLogicalVolumeListReturn ( response ) ; }
response: @Override public GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList ( ) { JsonRpcRequest request = new RequestBuilder ( "GlusterHost . logicalVolumeList" ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) . withIgnoreResponseKey ( ) ; return new GlusterLocalLogicalVolumeListReturn ( response ) ; }

sample: 516
buggy_code: <START> public String toString() { <END> return "TypedByteArray[length=" + length() + "]"; }
code_review: needs `@Override`
target code: @Override public String toString ( ) { return "TypedByteArray [ length = " + length ( ) + " ] " ; }
response: public @Override String toString ( ) { return "TypedByteArray [ length = " + length ( ) + " ] " ; }

sample: 517
buggy_code: public void onEntityDestroyed(EntityRef entity) { <START> if (!entity.isPersistent()) { <END> return; // ignore } entityDeltas.remove(entity.getId()); destroyedEntities.add(entity.getId()); }
code_review: Not an issue, but could be rewritten as ``` java if (entity.isPersistent()) { // do stuff } ``` to avoid multiple points of return from the method (and save a line of code).
target code: public void onEntityDestroyed ( EntityRef entity ) { if ( entity . isPersistent ( ) ) { entityDeltas . remove ( entity . getId ( ) ) ; destroyedEntities . add ( entity . getId ( ) ) ; } }
response: java public void onEntityDestroyed ( EntityRef entity ) { if ( entity . isPersistent ( ) ) { entityDeltas . remove ( entity . getId ( ) ) ; destroyedEntities . add ( entity . getId ( ) ) ; } }

sample: 518
buggy_code: private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) { Optional<OrganizationalUnit> targetOU = organizationalUnits.stream() .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst(); <START> if ( targetOU.isPresent() ) { <END> return targetOU.get(); } return null; }
code_review: Isn't this use of `Optional` and returning `null` contradictory? Surely checking `isPresent(..)` in `getDefaultOrganizationalUnit(..)` would be better?
target code: private Optional < OrganizationalUnit > getOU ( String ouIdentifier , Collection < OrganizationalUnit > organizationalUnits ) { Optional < OrganizationalUnit > targetOU = organizationalUnits . stream ( ) . filter ( p - > p . getIdentifier ( ) . equalsIgnoreCase ( ouIdentifier ) ) . findFirst ( ) ; return targetOU ; }
response: private Optional < OrganizationalUnit > getOU ( String ouIdentifier , Collection < OrganizationalUnit > organizationalUnits ) { return organizationalUnits . stream ( ) . filter ( p - > p . getIdentifier ( ) . equalsIgnoreCase ( ouIdentifier ) ) . findFirst ( ) ; } private OrganizationalUnit getDefaultOrganizationalUnit ( String ouIdentifier , Collection < OrganizationalUnit > organizationalUnits ) { return getOU ( ouIdentifier , organizationalUnits ) . orElse ( null ) ; }  In the refactored code , `getOU ( . . ) ` method returns an `Optional` instead of `OrganizationalUnit` and `getDefaultOrganizationalUnit ( . . ) ` method checks if the `Optional` is present or not and returns `null` if it is not present . This way , the use of `Optional` and returning `null` is avoided .

sample: 519
buggy_code: public void testPutAsync() throws Exception { // put Future<String> f = c.putAsync("k", "v"); testFuture(f, null); testK("v"); f = c.putAsync("k", "v2"); testFuture(f, "v"); <START> assertEquals("v2", c.get("k")); <END> }
code_review: to keep code consistency, you may use `testK("v2");`
target code: public void testPutAsync ( ) throws Exception { // put Future < String > f = c . putAsync ( "k" , "v" ) ; testFuture ( f , null ) ; testK ( "v" ) ; f = c . putAsync ( "k" , "v2" ) ; testFuture ( f , "v" ) ; testK ( "v2" ) ; }
response: public void testPutAsync ( ) throws Exception { // put Future < String > f = c . putAsync ( "k" , "v" ) ; testFuture ( f , null ) ; testK ( "v" ) ; f = c . putAsync ( "k" , "v2" ) ; testFuture ( f , "v" ) ; testK ( "v2" ) ; assertEquals ( "v2" , c . get ( "k" ) ) ; }

sample: 520
buggy_code: public boolean isReady(TaskActionClient taskActionClient) throws Exception { <START> return false; <END> }
code_review: should this return true instead ?
target code: public boolean isReady ( TaskActionClient taskActionClient ) throws Exception { return true ; }
response: public boolean isReady ( TaskActionClient taskActionClient ) throws Exception { return true ; }

sample: 521
buggy_code: <START> static Map<String, EntryValue> convertBeanToEntryMap(Object bean) { <END> Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean); return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer()); }
code_review: why not public
target code: public static Map < String , EntryValue > convertBeanToEntryMap ( Object bean ) { Map < String , Object > buildAttributeValueMap = BeanUtilsExtended . buildObjectAttributeMap ( bean ) ; return Maps . transformEntries ( buildAttributeValueMap , new ObjectToEntryValueTransformer ( ) ) ; }
response: public static Map < String , EntryValue > convertBeanToEntryMap ( Object bean ) { Map < String , Object > buildAttributeValueMap = BeanUtilsExtended . buildObjectAttributeMap ( bean ) ; return Maps . transformEntries ( buildAttributeValueMap , new ObjectToEntryValueTransformer ( ) ) ; }  The only change made was adding the `public` access modifier to the method signature .

sample: 522
buggy_code: public RequestHeader(Struct struct, short headerVersion) { this.data = new RequestHeaderData(struct, headerVersion); <START> this.headerVersion = headerVersion; <END> }
code_review: nit: replace with `this(new RequestHeaderData(struct, headerVersion), headerVersion)`. Consolidates c'tor logic to one place.
target code: public RequestHeader ( Struct struct , short headerVersion ) { this ( new RequestHeaderData ( struct , headerVersion ) , headerVersion ) ; }
response: public RequestHeader ( Struct struct , short headerVersion ) { this ( new RequestHeaderData ( struct , headerVersion ) , headerVersion ) ; } private RequestHeader ( RequestHeaderData data , short headerVersion ) { this . data = data ; this . headerVersion = headerVersion ; }

sample: 523
buggy_code: public void accountSession(String username, String password) throws TmdbInvalidParametersException { <START> if (username == null || password==null) <END> throw new TmdbInvalidParametersException(401,"Username and Password may not be null"); this.username = username; this.password = password; hasAccountSession = true; }
code_review: Please add braces to conditionals (like `if { }`).
target code: public void accountSession ( String username , String password ) throws TmdbInvalidParametersException { if ( username == null || password == null ) { throw new TmdbInvalidParametersException ( 401 , "Username and Password may not be null" ) ; } this . username = username ; this . password = password ; hasAccountSession = true ; }
response: public void accountSession ( String username , String password ) throws TmdbInvalidParametersException { if ( username == null || password == null ) { throw new TmdbInvalidParametersException ( 401 , "Username and Password may not be null" ) ; } this . username = username ; this . password = password ; hasAccountSession = true ; }

sample: 524
buggy_code: public void setProjectName(String projectName) { fProjectName = projectName; // If remote directory field is empty if(fLocationText.getText().equals(EMPTY_STRING)) { fRemoteDirSelected = false; } // If remote directory was not selected yet <START> if (fRemoteDirSelected == false) { <END> fLocationText.setText(getDefaultPathDisplayString()); } }
code_review: Use if (!fRemoteDirSelected) {
target code: public void setProjectName ( String projectName ) { fProjectName = projectName ; // If remote directory field is empty if ( fLocationText . getText ( ) . equals ( EMPTY_STRING ) ) { fRemoteDirSelected = false ; } // If remote directory was not selected yet if ( ! fRemoteDirSelected ) { fLocationText . setText ( getDefaultPathDisplayString ( ) ) ; } }
response: public void setProjectName ( String projectName ) { fProjectName = projectName ; if ( fLocationText . getText ( ) . equals ( EMPTY_STRING ) ) { fRemoteDirSelected = false ; } if ( ! fRemoteDirSelected ) { fLocationText . setText ( getDefaultPathDisplayString ( ) ) ; } }

sample: 525
buggy_code: public void testAddChildCycle3() { assertNotNull(fFixture); assertNotNull(f42Fixture); assertNotNull(fHiFixture); ((CalledFunction) f42Fixture).addChild(fHiFixture); <START> assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren()); <END> }
code_review: unreachable. Maybe you should remove.
target code: public void testAddChildCycle3 ( ) { assertNotNull ( fFixture ) ; assertNotNull ( f42Fixture ) ; assertNotNull ( fHiFixture ) ; ( ( CalledFunction ) f42Fixture ) . addChild ( fHiFixture ) ; }
response: public void testAddChildCycle3 ( ) { assertNotNull ( fFixture ) ; assertNotNull ( f42Fixture ) ; assertNotNull ( fHiFixture ) ; ( ( CalledFunction ) f42Fixture ) . addChild ( fHiFixture ) ; // The following assertion is unreachable and should be removed // assertEquals ( Collections . singletonList ( fHiFixture ) , f42Fixture . getChildren ( ) ) ; }

sample: 526
buggy_code: private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) { <START> if (fieldName.length() > 2 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) { <END> return fieldName.charAt(0); } else { return Character.toUpperCase(fieldName.charAt(0)); } }
code_review: I think the condition needs top start as `fieldName.length() > 1` instead of `fieldName.length() > 2 `. I think the generated code getters/setters has same rules for fields **aField** and **aF**. Or am I wrong?
target code: private char formatFieldFirstCharacterToFitDroolsCoreStandards ( final String fieldName ) { if ( fieldName . length ( ) > 1 && Character . isLowerCase ( fieldName . charAt ( 0 ) ) && Character . isUpperCase ( fieldName . charAt ( 1 ) ) ) { return fieldName . charAt ( 0 ) ; } else { return Character . toUpperCase ( fieldName . charAt ( 0 ) ) ; } }
response: private char formatFieldFirstCharacterToFitDroolsCoreStandards ( final String fieldName ) { if ( fieldName . length ( ) > 1 && Character . isLowerCase ( fieldName . charAt ( 0 ) ) && Character . isUpperCase ( fieldName . charAt ( 1 ) ) ) { return fieldName . charAt ( 0 ) ; } else { return Character . toUpperCase ( fieldName . charAt ( 0 ) ) ; } }  As per the review , the condition should start with `fieldName . length ( ) > 1` instead of `fieldName . length ( ) > 2` . Also , the generated code should have the same rules for fields `aField` and `aF` .

sample: 527
buggy_code: public void start() { <START> logger.debug("start()"); <END> for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) { cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType)); } }
code_review: Are these logging statements really needed?
target code: public void start ( ) { logger . trace ( "start ( ) " ) ; for ( final Class < ? > stepDefinitionType : cachedStepsInstances . keySet ( ) ) { cachedStepsInstances . put ( stepDefinitionType , createStepsInstance ( stepDefinitionType ) ) ; } }
response: public void start ( ) { for ( final Class < ? > stepDefinitionType : cachedStepsInstances . keySet ( ) ) { cachedStepsInstances . put ( stepDefinitionType , createStepsInstance ( stepDefinitionType ) ) ; } }

sample: 528
buggy_code: private WorkingSetDescriptor getSelectedWorkingSet() { IStructuredSelection selection = typesListViewer.getStructuredSelection(); WorkingSetDescriptor descriptor = null; if (!selection.isEmpty()) { descriptor = (WorkingSetDescriptor) <START> selection.getFirstElement(); <END> } return descriptor; }
code_review: I don't have the code now but if the contract od sselection is to return null on getFirstElement() if sselection is empty, the code can be changed to simply return the first element, without the if.
target code: private WorkingSetDescriptor getSelectedWorkingSet ( ) { return ( WorkingSetDescriptor ) typesListViewer . getStructuredSelection ( ) . getFirstElement ( ) ; }
response: private WorkingSetDescriptor getSelectedWorkingSet ( ) { IStructuredSelection selection = typesListViewer . getStructuredSelection ( ) ; return ( WorkingSetDescriptor ) selection . getFirstElement ( ) ; }

sample: 529
buggy_code: public void evaluate() throws Throwable { <START> if (null != previous) { <END> previous.evaluate(); } for (FrameworkMethod before : befores) { before.invokeExplosively(target); } next.evaluate(); }
code_review: Is it reasonable for the caller to pass in a null value for previous into the constructor? If not, then the constructor should throw a `NullPointerException` if it is null.
target code: public void evaluate ( ) throws Throwable { for ( FrameworkMethod before : befores ) { before . invokeExplosively ( target ) ; } next . evaluate ( ) ; }
response: public void evaluate ( ) throws Throwable { if ( previous == null ) { throw new NullPointerException ( "previous cannot be null" ) ; } previous . evaluate ( ) ; for ( FrameworkMethod before : befores ) { before . invokeExplosively ( target ) ; } next . evaluate ( ) ; }

sample: 530
buggy_code: public Response add(OpenStackVolumeProvider provider) { validateParameters(provider, "name"); StoragePool storagePool = provider.isSetDataCenter() ? <START> getStoragePool(provider.getDataCenter()) : new StoragePool(); <END> provider.setDataCenter(DataCenterMapper.map(storagePool, null)); return performCreate( VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class) ); }
code_review: It is a bit weird to create here an empty "StoragePool" to indicate that there is no storage pool to use. Can't we just pass "null" to the backend in that case?
target code: public Response add ( OpenStackVolumeProvider provider ) { validateParameters ( provider , "name" ) ; if ( provider . isSetDataCenter ( ) ) { StoragePool storagePool = getStoragePool ( provider . getDataCenter ( ) ) ; provider . setDataCenter ( DataCenterMapper . map ( storagePool , null ) ) ; } return performCreate ( VdcActionType . AddProvider , new ProviderParameters ( map ( provider ) ) , new QueryIdResolver < Guid > ( VdcQueryType . GetProviderById , IdQueryParameters . class ) ) ; }
response: public Response add ( OpenStackVolumeProvider provider ) { validateParameters ( provider , "name" ) ; StoragePool storagePool = provider . isSetDataCenter ( ) ? getStoragePool ( provider . getDataCenter ( ) ) : null ; provider . setDataCenter ( DataCenterMapper . map ( storagePool , null ) ) ; return performCreate ( VdcActionType . AddProvider , new ProviderParameters ( map ( provider ) ) , new QueryIdResolver < Guid > ( VdcQueryType . GetProviderById , IdQueryParameters . class ) ) ; }

sample: 531
buggy_code: <START> protected void doStoreUsers() <END> { try { usersFileManager.store(new UsersDto(new HashSet<>(userMap.values()))); } catch (IOException e) { throw new UndeclaredThrowableException(e); } }
code_review: private
target code: private void doStoreUsers ( ) { try { usersFileManager . store ( new UsersDto ( new HashSet < > ( userMap . values ( ) ) ) ) ; } catch ( IOException e ) { throw new UndeclaredThrowableException ( e ) ; } }
response: < START > private void doStoreUsers ( ) { try { usersFileManager . store ( new UsersDto ( new HashSet < > ( userMap . values ( ) ) ) ) ; } catch ( IOException e ) { throw new UndeclaredThrowableException ( e ) ; } } < END >

sample: 532
buggy_code: <START> public void tearDown() throws IOException, SQLException { <END> try { globalScheduler.shutdown(); } catch (Exception e) { } cleanup(); tearDownOnce(); }
code_review: Why is this needed now?
target code: public void tearDown ( ) { try { globalScheduler . shutdown ( ) ; } catch ( Exception e ) { } cleanup ( ) ; tearDownOnce ( ) ; }
response: public void tearDown ( ) throws IOException , SQLException { try { globalScheduler . shutdown ( ) ; } catch ( Exception e ) { // handle exception } cleanup ( ) ; tearDownOnce ( ) ; }  The `tearDown ( ) ` method is used to clean up resources after a test has been run . The refactored code includes a try - catch block to handle any exceptions that may occur when shutting down the `globalScheduler` . The `cleanup ( ) ` and `tearDownOnce ( ) ` methods are called after the `globalScheduler` has been shut down .

sample: 533
buggy_code: private CloudMachineNamer getCloudMachineNamer(ConfigBag config) { String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS); if (namerClass != null) { try { return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass) .getDeclaredConstructor(ConfigBag.class).newInstance(config); } catch (Exception e) { throw Exceptions.propagate(e); } } else { <START> return new JcloudsMachineNamer(getAllConfigBag()); <END> } }
code_review: This shouldn't call `getAllConfigBag()`. It should use the `config` passed in, otherwise we lose the local values passed in to the obtain() method. Do you agree?
target code: private CloudMachineNamer getCloudMachineNamer ( ConfigBag config ) { String namerClass = config . get ( LocationConfigKeys . CLOUD_MACHINE_NAMER_CLASS ) ; if ( namerClass != null ) { try { return ( CloudMachineNamer ) getManagementContext ( ) . getCatalog ( ) . getRootClassLoader ( ) . loadClass ( namerClass ) . getDeclaredConstructor ( ConfigBag . class ) . newInstance ( config ) ; } catch ( Exception e ) { throw Exceptions . propagate ( e ) ; } } else { return new JcloudsMachineNamer ( config ) ; } }
response: private CloudMachineNamer getCloudMachineNamer ( ConfigBag config ) { String namerClass = config . get ( LocationConfigKeys . CLOUD_MACHINE_NAMER_CLASS ) ; if ( namerClass != null ) { try { return ( CloudMachineNamer ) getManagementContext ( ) . getCatalog ( ) . getRootClassLoader ( ) . loadClass ( namerClass ) . getDeclaredConstructor ( ConfigBag . class ) . newInstance ( config ) ; } catch ( Exception e ) { throw Exceptions . propagate ( e ) ; } } else { return new JcloudsMachineNamer ( config ) ; } }

sample: 534
buggy_code: <START> public IllustratedSelectItem(Object value, String label, String image) { <END> super(value, label); this.image = image; }
code_review: Missing JavaDoc.
target code: IllustratedSelectItem ( Object value , String label , String image ) { super ( value , label ) ; this . image = image ; }
response: /* * * Represents an illustrated select item . */ public IllustratedSelectItem ( Object value , String label , String image ) { super ( value , label ) ; this . image = image ; }

sample: 535
buggy_code: private boolean layerGroupContainmentCheckRequired() { // first, is it WMS? Request request = Dispatcher.REQUEST.get(); if(request == null) { return false; } // layer groups are used only in WMS final String service = request.getService(); boolean isMapService = "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); if(!isMapService) { return false; } <START> return true; <END> }
code_review: The last six lines can be squashed into: return "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service);
target code: private boolean layerGroupContainmentCheckRequired ( ) { // first , is it WMS ? Request request = Dispatcher . REQUEST . get ( ) ; if ( request == null ) { return false ; } // layer groups are used only in WMS final String service = request . getService ( ) ; return "WMS" . equalsIgnoreCase ( service ) || "gwc" . equalsIgnoreCase ( service ) ; }
response: private boolean layerGroupContainmentCheckRequired ( ) { Request request = Dispatcher . REQUEST . get ( ) ; if ( request == null ) { return false ; } String service = request . getService ( ) ; return "WMS" . equalsIgnoreCase ( service ) || "gwc" . equalsIgnoreCase ( service ) ; }

sample: 536
buggy_code: public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) { <START> initialize(absoluteUri, contextPath, InitData.canBeCached(absoluteUri) ? initData : null); <END> }
code_review: I would do this instead: ``initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null);`` IOW, no point in spending time on checking if the cache can be used if there's no ``initData`` provided.
target code: public ResteasyUriInfo ( final String absoluteUri , final String contextPath , final InitData initData ) { initialize ( absoluteUri , contextPath , initData != null && InitData . canBeCached ( absoluteUri ) ? initData : null ) ; }
response: public ResteasyUriInfo ( final String absoluteUri , final String contextPath , final InitData initData ) { initialize ( absoluteUri , contextPath , ( initData != null && InitData . canBeCached ( absoluteUri ) ) ? initData : null ) ; }

sample: 537
buggy_code: private void buildUnaryExpression(UnaryExpressionTree tree) { <START> if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) { <END> build(tree.expression()); currentBlock.elements.add(tree); } else { currentBlock.elements.add(tree); build(tree.expression()); } }
code_review: @benzonico The fact that postfix operators return value before modification shouldn't change order in CFG, because loading of value should anyway happen before operation, i.e. order should be the same.
target code: private void buildUnaryExpression ( UnaryExpressionTree tree ) { currentBlock . elements . add ( tree ) ; build ( tree . expression ( ) ) ; }
response: private void buildUnaryExpression ( UnaryExpressionTree tree ) { if ( tree . is ( Tree . Kind . PREFIX_DECREMENT , Tree . Kind . PREFIX_INCREMENT ) ) { build ( tree . expression ( ) ) ; } currentBlock . elements . add ( tree ) ; if ( tree . is ( Tree . Kind . POSTFIX_DECREMENT , Tree . Kind . POSTFIX_INCREMENT ) ) { build ( tree . expression ( ) ) ; } }

sample: 538
buggy_code: <START> public Class getRealClass() { <END> return testNGMethod.getRealClass(); }
code_review: Class<?>
target code: public Class < ? > getRealClass ( ) { return testNGMethod . getRealClass ( ) ; }
response: public Class < ? > getRealClass ( ) { return testNGMethod . getRealClass ( ) ; }

sample: 539
buggy_code: private KeyStore getSecretsStore() { final File secretStoreFile = createStoreIfNeeded(); try { final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE); <START> try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) { <END> keyStore.load(inputStream, loadStorePassword()); } return keyStore; } catch (Exception e) { Logger.warn(this.getClass(), "unable to load secrets store " + SECRETS_STORE_FILE + ": " + e); throw new DotRuntimeException(e); } }
code_review: Good it is the way
target code: private KeyStore getSecretsStore ( ) { final File secretStoreFile = createStoreIfNeeded ( ) ; try { final KeyStore keyStore = KeyStore . getInstance ( SECRETS_STORE_KEYSTORE_TYPE ) ; try ( InputStream inputStream = Files . newInputStream ( secretStoreFile . toPath ( ) ) ) { keyStore . load ( inputStream , loadStorePassword ( ) ) ; } return keyStore ; } catch ( Exception e ) { Logger . error ( this . getClass ( ) , "unable to load secrets store " + SECRETS_STORE_FILE + " : " + e ) ; throw new DotRuntimeException ( e ) ; } }
response: private KeyStore getSecretsStore ( ) { final File secretStoreFile = createStoreIfNeeded ( ) ; try { final KeyStore keyStore = KeyStore . getInstance ( SECRETS_STORE_KEYSTORE_TYPE ) ; try ( InputStream inputStream = Files . newInputStream ( secretStoreFile . toPath ( ) ) ) { keyStore . load ( inputStream , loadStorePassword ( ) ) ; } return keyStore ; } catch ( Exception e ) { Logger . warn ( this . getClass ( ) , "unable to load secrets store " + SECRETS_STORE_FILE + " : " + e ) ; throw new DotRuntimeException ( e ) ; } }

sample: 540
buggy_code: public AnonymousSpec anonymous(){ if (this.anonymous == null) { this.anonymous = new AnonymousSpec(); } <START> return this.anonymous.authorities("ROLE_USER"); <END> }
code_review: This should be ROLE_ANONYMOUS. However given the defaults in AnonymousSpec you should just delete it
target code: public AnonymousSpec anonymous ( ) { if ( this . anonymous == null ) { this . anonymous = new AnonymousSpec ( ) ; } return this . anonymous ; }
response: public AnonymousSpec anonymous ( ) { if ( this . anonymous == null ) { this . anonymous = new AnonymousSpec ( ) ; } return this . anonymous . authorities ( "ROLE_ANONYMOUS" ) ; }

sample: 541
buggy_code: public int getNumWaiters() { <START> return this.connectionPool.getNumActive(); <END> }
code_review: ```suggestion return this.connectionPool.getNumWaiters(); ```
target code: public int getNumWaiters ( ) { return this . connectionPool . getNumWaiters ( ) ; }
response: public int getNumWaiters ( ) { return this . connectionPool . getNumWaiters ( ) ; }

sample: 542
buggy_code: private void store() throws IOException { byte[] serialized = state.toCbor().serialize(); System.out.println("Writing "+ serialized.length +" bytes to "+ statePath); Files.write( statePath, serialized, <START> StandardOpenOption.CREATE); <END> }
code_review: can we do this atomically?
target code: private synchronized void store ( ) throws IOException { byte [ ] serialized = state . toCbor ( ) . serialize ( ) ; System . out . println ( "Writing " + serialized . length + " bytes to " + statePath ) ; Files . write ( statePath , serialized , StandardOpenOption . CREATE ) ; }
response: private void store ( ) throws IOException { byte [ ] serialized = state . toCbor ( ) . serialize ( ) ; System . out . println ( "Writing " + serialized . length + " bytes to " + statePath ) ; Files . write ( statePath , serialized , StandardOpenOption . CREATE , StandardOpenOption . WRITE , StandardOpenOption . TRUNCATE_EXISTING , StandardOpenOption . SYNC ) ; }

sample: 543
buggy_code: private static void initFacets(@CheckForNull Fingerprint fingerprint){ if (fingerprint==null) return; <START> for (FingerprintFacet facet : fingerprint.facets) <END> facet._setOwner(fingerprint); }
code_review: Please add curlies here
target code: private static void initFacets ( @CheckForNull Fingerprint fingerprint ) { if ( fingerprint == null ) { return ; } for ( FingerprintFacet facet : fingerprint . facets ) { facet . _setOwner ( fingerprint ) ; } }
response: private static void initFacets ( @CheckForNull Fingerprint fingerprint ) { if ( fingerprint == null ) { return ; } for ( FingerprintFacet facet : fingerprint . facets ) { facet . _setOwner ( fingerprint ) ; } }

sample: 544
buggy_code: public Map<FactoryContainer, Attributes> getEnabledContainers() { Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(); synchronized(_path) { for <START> (Entry<FactoryContainer, <END> Attributes> entry : getReversed(_path.entrySet())) { Attributes attr = entry.getValue(); if (attr.isEnabled()) { Attributes attrClone = new Attributes(attr); map.put(entry.getKey(), attrClone); } } } return map; }
code_review: For clarity it's preferable: Map.Entry
target code: public Map < FactoryContainer , Attributes > getEnabledContainers ( ) { Map < FactoryContainer , Attributes > map = new LinkedHashMap < > ( ) ; synchronized ( _path ) { for ( Map . Entry < FactoryContainer , Attributes > entry : getReversed ( _path . entrySet ( ) ) ) { Attributes attr = entry . getValue ( ) ; if ( attr . isEnabled ( ) ) { Attributes attrClone = new Attributes ( attr ) ; map . put ( entry . getKey ( ) , attrClone ) ; } } } return map ; }
response: public Map < FactoryContainer , Attributes > getEnabledContainers ( ) { Map < FactoryContainer , Attributes > map = new LinkedHashMap < > ( ) ; synchronized ( _path ) { for ( Map . Entry < FactoryContainer , Attributes > entry : getReversed ( _path . entrySet ( ) ) ) { Attributes attr = entry . getValue ( ) ; if ( attr . isEnabled ( ) ) { Attributes attrClone = new Attributes ( attr ) ; map . put ( entry . getKey ( ) , attrClone ) ; } } } return map ; }

sample: 545
buggy_code: private FileListCacheValue getFileList() { <START> readLock.lock(); <END> try { FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey); if (fileList == null) { fileList = new FileListCacheValue(); FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList); if (prev != null) { fileList = prev; } } if (trace) log.trace("Refreshed file listing view"); return fileList; } finally { readLock.unlock(); } }
code_review: I'm concerned about this lock.. it doesn't seem necessary as each operation invoking this private method is guarded already, and whenever a thread needs to acquire two locks I have an alarm bell ringing in my head.
target code: private FileListCacheValue getFileList ( ) { FileListCacheValue fileList = ( FileListCacheValue ) cache . get ( fileListCacheKey ) ; if ( fileList == null ) { fileList = new FileListCacheValue ( ) ; FileListCacheValue prev = ( FileListCacheValue ) cache . putIfAbsent ( fileListCacheKey , fileList ) ; if ( prev != null ) { fileList = prev ; } } if ( trace ) log . trace ( "Refreshed file listing view" ) ; return fileList ; }
response: private FileListCacheValue getFileList ( ) { FileListCacheValue fileList = ( FileListCacheValue ) cache . get ( fileListCacheKey ) ; if ( fileList == null ) { fileList = new FileListCacheValue ( ) ; FileListCacheValue prev = ( FileListCacheValue ) cache . putIfAbsent ( fileListCacheKey , fileList ) ; if ( prev != null ) { fileList = prev ; } } if ( trace ) log . trace ( "Refreshed file listing view" ) ; return fileList ; }

sample: 546
buggy_code: public long size() { build(); <START> return body.length() + partBoundary.length + partHeader.length; <END> }
code_review: What happens when one of these `TypedOutput` instances return `-1` because they don't know their length?
target code: public long size ( ) { build ( ) ; if ( body . length ( ) > - 1 ) { return body . length ( ) + partBoundary . length + partHeader . length ; } else { return - 1 ; } }
response: public long size ( ) { build ( ) ; long size = body . length ( ) ; if ( partBoundary != null ) { size += partBoundary . length ; } if ( partHeader != null ) { size += partHeader . length ; } return size ; }  Explanation : The refactored code checks if `partBoundary` and `partHeader` are not null before adding their lengths to the `size` variable . This ensures that the code does not throw a `NullPointerException` when one of these instances returns ` - 1` because they don't know their length .

sample: 547
buggy_code: public boolean canStreamToNextPipe() { <START> return super.canStreamToNextPipe() && !isCollectResults(); // when collectResults is false, streaming is not necessary or useful <END> }
code_review: Performance gezien is het natuurlijk handiger eerst een boolean check te hebben en dan extra logica..
target code: public boolean canStreamToNextPipe ( ) { return ! isCollectResults ( ) && super . canStreamToNextPipe ( ) ; // when collectResults is false , streaming is not necessary or useful }
response: public boolean canStreamToNextPipe ( ) { boolean canStream = super . canStreamToNextPipe ( ) ; if ( canStream && ! isCollectResults ( ) ) { return true ; } else { return false ; } }

sample: 548
buggy_code: public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) { String idRefString = idRef.name(); FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString); if (foundViewHolder == null) { foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass); <START> foundHolders.put(idRefString, foundViewHolder); <END> } return foundViewHolder; }
code_review: Where do you handle this now?
target code: public FoundViewHolder getFoundViewHolder ( JFieldRef idRef , AbstractJClass viewClass ) { return getFoundViewHolder ( idRef , viewClass , null ) ; }
response: public FoundViewHolder getFoundViewHolder ( JFieldRef idRef , AbstractJClass viewClass ) { String idRefString = idRef . name ( ) ; FoundViewHolder foundViewHolder = ( FoundViewHolder ) foundHolders . get ( idRefString ) ; if ( foundViewHolder == null ) { foundViewHolder = createFoundViewAndIfNotNullBlock ( idRef , viewClass ) ; foundHolders . put ( idRefString , foundViewHolder ) ; } return foundViewHolder ; }  Note : The review does not provide any information on where to handle the code . It only points out that there are no comments in the code .

sample: 549
buggy_code: public void tearDown() { try { queryRunner.close(); } <START> finally { <END> queryRunner = null; } }
code_review: `finally` is not really needed. If `close` throws the test will fail anyway and we won't care whether `queryRunner` is `null` or not.
target code: public void tearDown ( ) { queryRunner . close ( ) ; }
response: public void tearDown ( ) { queryRunner . close ( ) ; queryRunner = null ; }

sample: 550
buggy_code: private CommitConfig(Config rc) { commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION, null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE); String i18nCommitEncoding = rc.getString( ConfigConstants.CONFIG_SECTION_I18N, null, ConfigConstants.CONFIG_KEY_COMMIT_ENCODING); if (i18nCommitEncoding != null) { <START> commitMessageEncoding = Charset.forName(i18nCommitEncoding); <END> } }
code_review: What if this throws an exception? Should probably be mapped to a ConfigInvalidException, and the caller should report the error.
target code: private CommitConfig ( Config rc ) { commitTemplatePath = rc . getString ( ConfigConstants . CONFIG_COMMIT_SECTION , null , ConfigConstants . CONFIG_KEY_COMMIT_TEMPLATE ) ; i18nCommitEncoding = rc . getString ( ConfigConstants . CONFIG_SECTION_I18N , null , ConfigConstants . CONFIG_KEY_COMMIT_ENCODING ) ; }
response: private CommitConfig ( Config rc ) throws ConfigInvalidException { commitTemplatePath = rc . getString ( ConfigConstants . CONFIG_COMMIT_SECTION , null , ConfigConstants . CONFIG_KEY_COMMIT_TEMPLATE ) ; String i18nCommitEncoding = rc . getString ( ConfigConstants . CONFIG_SECTION_I18N , null , ConfigConstants . CONFIG_KEY_COMMIT_ENCODING ) ; if ( i18nCommitEncoding != null ) { try { commitMessageEncoding = Charset . forName ( i18nCommitEncoding ) ; } catch ( UnsupportedCharsetException e ) { throw new ConfigInvalidException ( "Invalid commit encoding : " + i18nCommitEncoding , e ) ; } } }

sample: 551
buggy_code: public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) throws MalformedInputException { <START> try { <END> Inflater inflater = new Inflater(true); inflater.setInput(input, inputOffset, inputLength); int resultLength = inflater.inflate(output, outputOffset, maxOutputLength); inflater.end(); return resultLength; } catch (DataFormatException e) { throw Throwables.propagate(e); } }
code_review: What's broken (add some details in the commit message)? This is not very obvious.
target code: public int decompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset , int maxOutputLength ) throws MalformedInputException { try { Inflater inflater = new Inflater ( true ) ; inflater . setInput ( input , inputOffset , inputLength ) ; int resultLength = inflater . inflate ( output , outputOffset , maxOutputLength ) ; inflater . end ( ) ; return resultLength ; } catch ( DataFormatException e ) { throw new RuntimeException ( e ) ; } }
response: The Buggy Code is missing a catch block for the MalformedInputException . This exception can be thrown by the Inflater class and should be handled appropriately .  public int decompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset , int maxOutputLength ) throws MalformedInputException { try { Inflater inflater = new Inflater ( true ) ; inflater . setInput ( input , inputOffset , inputLength ) ; int resultLength = inflater . inflate ( output , outputOffset , maxOutputLength ) ; inflater . end ( ) ; return resultLength ; } catch ( DataFormatException e ) { throw new RuntimeException ( e ) ; } catch ( MalformedInputException e ) { throw e ; } }

sample: 552
buggy_code: <START> public List<OutputLine> getLog() { <END> return this.log; }
code_review: we should return an ImmutableList if we don't intend for users of this method to edit the list.
target code: public List < OutputLine > getLog ( ) { return new ArrayList < > ( this . log ) ; }
response: public ImmutableList < OutputLine > getLog ( ) { return ImmutableList . copyOf ( this . log ) ; }

sample: 553
buggy_code: protected void doInit() { super.doInit(); if (!this.evaluationContextSet) { this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory()); } <START> Assert.state(this.closeStreamAfterSend ? this.isSingleUse : true, <END> "Single use connection needed with closeStreamAfterSend"); }
code_review: `!this.closeStreamAfterSend || this.isSingleUse` ?
target code: protected void doInit ( ) { super . doInit ( ) ; if ( ! this . evaluationContextSet ) { this . evaluationContext = ExpressionUtils . createStandardEvaluationContext ( getBeanFactory ( ) ) ; } Assert . state ( ! this . closeStreamAfterSend || this . isSingleUse , "Single use connection needed with closeStreamAfterSend" ) ; }
response: protected void doInit ( ) { super . doInit ( ) ; if ( ! this . evaluationContextSet ) { this . evaluationContext = ExpressionUtils . createStandardEvaluationContext ( getBeanFactory ( ) ) ; } Assert . state ( ! this . closeStreamAfterSend || this . isSingleUse , "Single use connection needed with closeStreamAfterSend" ) ; }

sample: 554
buggy_code: public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) { super(xStream); this.extensionRegisters = new ArrayList<DMNExtensionRegister>(); if(extensionRegisters != null && extensionRegisters.size() > 0) <START> this.extensionRegisters.addAll(extensionRegisters); <END> }
code_review: I'm reworking this code in the context of the class, also to avoid potential NPE if the extensionRegisters field might have not been initialized, from the no-args constructor.
target code: public ExtensionElementsConverter ( XStream xStream , List < DMNExtensionRegister > extensionRegisters ) { super ( xStream ) ; if ( ! extensionRegisters . isEmpty ( ) ) { this . extensionRegisters . addAll ( extensionRegisters ) ; } }
response: public ExtensionElementsConverter ( XStream xStream , List < DMNExtensionRegister > extensionRegisters ) { super ( xStream ) ; this . extensionRegisters = new ArrayList < > ( ) ; if ( extensionRegisters != null ) { this . extensionRegisters . addAll ( extensionRegisters ) ; } }

sample: 555
buggy_code: public void executeBatch(OperationsQueue operationsQueue) { <START> log.tracef( "Executing batch" ); <END> try { if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class ) || GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) { super.executeBatch( operationsQueue ); } } catch ( TupleAlreadyExistsException taee ) { // TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this // information via the original exception; It'd require a fair bit of changes to obtain the entity name here // (we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here) throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee ); } }
code_review: Maybe we should move that inside the `if` body, since we won't always execute the batch... ?
target code: public void executeBatch ( OperationsQueue operationsQueue ) { try { if ( GridDialects . hasFacet ( getGridDialect ( ) , BatchableGridDialect . class ) || GridDialects . hasFacet ( getGridDialect ( ) , GroupingByEntityDialect . class ) ) { log . tracef ( "Executing batch" ) ; super . executeBatch ( operationsQueue ) ; } } catch ( TupleAlreadyExistsException taee ) { // TODO : Ideally , we should log the entity name + id here ; For now we trust the datastore to provide this // information via the original exception ; It'd require a fair bit of changes to obtain the entity name here // ( we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here ) throw log . mustNotInsertSameEntityTwice ( taee . getMessage ( ) , taee ) ; } }
response: public void executeBatch ( OperationsQueue operationsQueue ) { try { if ( GridDialects . hasFacet ( getGridDialect ( ) , BatchableGridDialect . class ) || GridDialects . hasFacet ( getGridDialect ( ) , GroupingByEntityDialect . class ) ) { log . tracef ( "Executing batch" ) ; super . executeBatch ( operationsQueue ) ; } } catch ( TupleAlreadyExistsException taee ) { // TODO : Ideally , we should log the entity name + id here ; For now we trust the datastore to provide this // information via the original exception ; It'd require a fair bit of changes to obtain the entity name here // ( we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here ) throw log . mustNotInsertSameEntityTwice ( taee . getMessage ( ) , taee ) ; } }

sample: 556
buggy_code: public int hashCode() { <START> return (((startCommit.hashCode() * 31) + numbers.length) * 31) <END> + getNumber(); }
code_review: nit-pick: startCommit.hashCode can just be xored/added in since it is well distributed
target code: public int hashCode ( ) { return ( ( startCommit . hashCode ( ) + numbers . length ) * 31 ) + getNumber ( ) ; }
response: public int hashCode ( ) { return ( ( startCommit . hashCode ( ) ^ numbers . length ) * 31 ) + getNumber ( ) ; }

sample: 557
buggy_code: <START> private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException { <END> AuthenticationSettings.INSTANCE.setUseBroker(true); }
code_review: can this function now throw NoSuchAlgorithmException
target code: private void prepareAuthForBrokerCall ( ) { AuthenticationSettings . INSTANCE . setUseBroker ( true ) ; }
response: private void prepareAuthForBrokerCall ( ) throws NoSuchAlgorithmException { try { AuthenticationSettings . INSTANCE . setUseBroker ( true ) ; } catch ( NoSuchAlgorithmException e ) { // handle the exception here } }

sample: 558
buggy_code: public boolean isWrapperFor(Class<?> iface) { if (gridCoverage instanceof Wrapper) return ((Wrapper) gridCoverage).isWrapperFor(iface); <START> else if (iface.isInstance(gridCoverage)) return true; <END> else return false; }
code_review: I woudl remove this else, if the gridCoverage is a wrapper and says "false" but iface is "GridCoverage2D" you want to fall back on the isInstance check anyways.
target code: public boolean isWrapperFor ( Class < ? > iface ) { if ( gridCoverage instanceof Wrapper ) { return ( ( Wrapper ) gridCoverage ) . isWrapperFor ( iface ) ; } return iface . isInstance ( gridCoverage ) ; }
response: public boolean isWrapperFor ( Class < ? > iface ) { if ( gridCoverage instanceof Wrapper ) { if ( ( ( Wrapper ) gridCoverage ) . isWrapperFor ( iface ) ) { return true ; } } if ( iface . isInstance ( gridCoverage ) ) { return true ; } return false ; }

sample: 559
buggy_code: DataSegment uploadDataSegment( DataSegment segment, final int binaryVersion, final long size, final File compressedSegmentData, final String azurePath ) throws StorageException, IOException, URISyntaxException { azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath); final DataSegment outSegment = segment .withSize(size) .withLoadSpec(this.makeLoadSpec(new URI(azurePath))) .withBinaryVersion(binaryVersion); <START> log.info("Deleting file [%s]", compressedSegmentData); <END> compressedSegmentData.delete(); return outSegment; }
code_review: Would you change the log level to debug? it doesn't look worth to be the info level.
target code: DataSegment uploadDataSegment ( DataSegment segment , final int binaryVersion , final long size , final File compressedSegmentData , final String azurePath ) throws StorageException , IOException , URISyntaxException { azureStorage . uploadBlob ( compressedSegmentData , config . getContainer ( ) , azurePath ) ; final DataSegment outSegment = segment . withSize ( size ) . withLoadSpec ( this . makeLoadSpec ( new URI ( azurePath ) ) ) . withBinaryVersion ( binaryVersion ) ; log . debug ( "Deleting file [ % s ] " , compressedSegmentData ) ; compressedSegmentData . delete ( ) ; return outSegment ; }
response: DataSegment uploadDataSegment ( DataSegment segment , final int binaryVersion , final long size , final File compressedSegmentData , final String azurePath ) throws StorageException , IOException , URISyntaxException { azureStorage . uploadBlob ( compressedSegmentData , config . getContainer ( ) , azurePath ) ; final DataSegment outSegment = segment . withSize ( size ) . withLoadSpec ( this . makeLoadSpec ( new URI ( azurePath ) ) ) . withBinaryVersion ( binaryVersion ) ; log . debug ( "Deleting file [ % s ] " , compressedSegmentData ) ; compressedSegmentData . delete ( ) ; return outSegment ; }

sample: 560
buggy_code: public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter, TransactionalEditingDomain editingDomain) { <START> super(description, variableManager, <END> interpreter, editingDomain); this.description = description; }
code_review: not done
target code: public EEFButtonLifecycleManager ( EEFButtonDescription description , IVariableManager variableManager , IInterpreter interpreter , TransactionalEditingDomain editingDomain ) { super ( variableManager , interpreter , editingDomain ) ; this . description = description ; }
response: public EEFButtonLifecycleManager ( EEFButtonDescription description , IVariableManager variableManager , IInterpreter interpreter , TransactionalEditingDomain editingDomain ) { super ( description , variableManager , interpreter , editingDomain ) ; this . description = description ; }

sample: 561
buggy_code: private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) { return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) && <START> (!formatString.contains("{}") && formatString.contains("%")); <END> }
code_review: useless parenthesis
target code: private static boolean isProbablyLog4jFormatterLogger ( MethodInvocationTree mit , String formatString ) { return mit . symbol ( ) . owner ( ) . type ( ) . is ( ORG_APACHE_LOGGING_LOG4J_LOGGER ) && ! formatString . contains ( " { } " ) && formatString . contains ( " % " ) ; }
response: private static boolean isProbablyLog4jFormatterLogger ( MethodInvocationTree mit , String formatString ) { return mit . symbol ( ) . owner ( ) . type ( ) . is ( ORG_APACHE_LOGGING_LOG4J_LOGGER ) && ! formatString . contains ( " { } " ) && formatString . contains ( " % " ) ; }

sample: 562
buggy_code: void setMarker(TextMarker marker, int length) { this.marker = marker; numSkipLines = length; if (checkAndUpdateArrows()) { upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND)); } <START> skipNum.setText(PatchUtil.C.patchSkipRegion(Integer <END> .toString(length))); }
code_review: PatchUtil.M
target code: void setMarker ( TextMarker marker , int length ) { this . marker = marker ; numSkipLines = length ; if ( checkAndUpdateArrows ( ) ) { upArrow . setHTML ( PatchUtil . M . expandBefore ( NUM_ROWS_TO_EXPAND ) ) ; downArrow . setHTML ( PatchUtil . M . expandAfter ( NUM_ROWS_TO_EXPAND ) ) ; } skipNum . setText ( PatchUtil . M . patchSkipRegion ( Integer . toString ( length ) ) ) ; }
response: void setMarker ( TextMarker marker , int length ) { this . marker = marker ; numSkipLines = length ; if ( checkAndUpdateArrows ( ) ) { upArrow . setHTML ( PatchUtil . expandBefore ( NUM_ROWS_TO_EXPAND ) ) ; downArrow . setHTML ( PatchUtil . expandAfter ( NUM_ROWS_TO_EXPAND ) ) ; } skipNum . setText ( PatchUtil . patchSkipRegion ( Integer . toString ( length ) ) ) ; }

sample: 563
buggy_code: public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) { this.publisher = publisher; this.run = build; this.workspace = build.getWorkspace(); this.launcher = launcher; <START> this.listener = listener; <END> }
code_review: Wouldn't be better to directly call the new constructor? Just for easier maintenance in the future.
target code: public ExtendedEmailPublisherContext ( ExtendedEmailPublisher publisher , AbstractBuild < ? , ? > build , Launcher launcher , BuildListener listener ) { this ( publisher , build , build . getWorkspace ( ) , launcher , listener ) ; }
response: public ExtendedEmailPublisherContext ( ExtendedEmailPublisher publisher , AbstractBuild < ? , ? > build , Launcher launcher , BuildListener listener ) { this . publisher = publisher ; this . run = build ; this . workspace = build . getWorkspace ( ) ; this . launcher = launcher ; this . listener = listener ; }

sample: 564
buggy_code: public void testWrongFormatNumber() throws Exception { NumberCellEditor editor; editor = new NumberCellEditor(shell, Integer.class); //empty string editor.setValue(" "); editor.getValue(); assertNull(editor.getValue() ); //not parsable number editor.setValue("aa"); <START> editor.getValue(); <END> assertNull(editor.getValue() ); }
code_review: this might be obsolete if `isValueValid`is implemented...
target code: public void testWrongFormatNumber ( ) throws Exception { NumberCellEditor editor ; editor = new NumberCellEditor ( shell , Integer . class ) ; // empty string editor . getValue ( ) ; assertNull ( editor . getValue ( ) ) ; // not parsable number editor . setValue ( "aa" ) ; editor . getValue ( ) ; assertNull ( editor . getValue ( ) ) ; }
response: public void testWrongFormatNumber ( ) throws Exception { NumberCellEditor editor = new NumberCellEditor ( shell , Integer . class ) ; // empty string editor . setValue ( " " ) ; editor . isValueValid ( ) ; assertNull ( editor . getValue ( ) ) ; // not parsable number editor . setValue ( "aa" ) ; editor . isValueValid ( ) ; assertNull ( editor . getValue ( ) ) ; }

sample: 565
buggy_code: public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) { if (hasAvatarProvider(newPlugin)) { avatarSupport = true; <START> } else { if (avatarSupport <END> && hasAvatarProvider(oldPlugin)) { avatarSupport = false; } } }
code_review: else if on one line.
target code: public void onReloadPlugin ( Plugin oldPlugin , Plugin newPlugin ) { update ( ) ; }
response: public void onReloadPlugin ( Plugin oldPlugin , Plugin newPlugin ) { if ( hasAvatarProvider ( newPlugin ) ) { avatarSupport = true ; } else if ( avatarSupport && hasAvatarProvider ( oldPlugin ) ) { avatarSupport = false ; } }

sample: 566
buggy_code: <START> public Class getRealClass() { <END> return clazz; }
code_review: `Class<?>`
target code: public Class < ? > getRealClass ( ) { return clazz ; }
response: public Class < ? > getRealClass ( ) { return clazz ; }

sample: 567
buggy_code: private String read(String resourcePath) throws IOException { InputStream is = getClass().getResourceAsStream(resourcePath); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }
code_review: I suppose close() is already done in Util.read(..)
target code: private String read ( String resourcePath ) throws IOException { InputStream is = getClass ( ) . getResourceAsStream ( resourcePath ) ; return Util . read ( is ) ; }
response: private String read ( String resourcePath ) throws IOException { try ( InputStream is = getClass ( ) . getResourceAsStream ( resourcePath ) ) { return Util . read ( is ) ; } }

sample: 568
buggy_code: public static String getModelFileWithGAV(ReleaseId releaseId) { <START> ReleaseIdImpl releaseIdImpl = (ReleaseIdImpl) releaseId; <END> return Paths.get(MODEL_FILE_DIRECTORY, releaseIdImpl.getGroupId(), releaseIdImpl.getArtifactId(), releaseIdImpl.getVersion(), MODEL_FILE_NAME).toString(); }
code_review: I don't see why I need this cast. The group and artifact IDs are accessible even at interface level. Also the version is accessible, but I don't think you should add it here: this is for multimodule project compilaton and afaik you cannot have different modules with same GA and different version in the same project.
target code: public static String getModelFileWithGAV ( ReleaseId releaseId ) { return Paths . get ( MODEL_FILE_DIRECTORY , releaseId . getGroupId ( ) , releaseId . getArtifactId ( ) , MODEL_FILE_NAME ) . toString ( ) ; }
response: public static String getModelFileWithGAV ( ReleaseId releaseId ) { return Paths . get ( MODEL_FILE_DIRECTORY , releaseId . getGroupId ( ) , releaseId . getArtifactId ( ) , MODEL_FILE_NAME ) . toString ( ) ; }

sample: 569
buggy_code: void removeConnection(String connectionId) { <START> if (availableConnections.remove(connectionId)) { <END> availableCount--; } poolCount--; }
code_review: This operation can be O(n), though the size of the list may be small. Making sense to use a set instead?
target code: void removeConnection ( String connectionId ) { availableConnections . remove ( connectionId ) ; poolCount -- ; }
response: void removeConnection ( String connectionId ) { if ( availableConnections . contains ( connectionId ) ) { availableConnections . remove ( connectionId ) ; availableCount -- ; } poolCount -- ; }

sample: 570
buggy_code: private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); if <START> (!desiredColumns.isEmpty()) <END> { for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; }
code_review: return before instantiating the map?
target code: private Map < Long , ISegmentAspect > getAspectsFromColumnsId ( List < Long > desiredColumns ) { if ( ! desiredColumns . isEmpty ( ) ) { Map < Long , ISegmentAspect > aspects = new LinkedHashMap < > ( ) ; for ( Long columnsId : desiredColumns ) { ISegmentAspect segmentAspect = fAspectMap . get ( columnsId ) ; if ( segmentAspect != null ) { aspects . put ( columnsId , segmentAspect ) ; } } return aspects ; } return fAspectMap ; }
response: private Map < Long , ISegmentAspect > getAspectsFromColumnsId ( List < Long > desiredColumns ) { if ( desiredColumns . isEmpty ( ) ) { return fAspectMap ; } Map < Long , ISegmentAspect > aspects = new LinkedHashMap < > ( ) ; for ( Long columnsId : desiredColumns ) { ISegmentAspect segmentAspect = fAspectMap . get ( columnsId ) ; if ( segmentAspect != null ) { aspects . put ( columnsId , segmentAspect ) ; } } return aspects ; }

sample: 571
buggy_code: static boolean isValidMining(ICodeMining mining) { <START> return Objects.nonNull(mining) && mining.getLabel() != null && !mining.getLabel().isEmpty(); <END> }
code_review: Why Objects.nonNull instead of != null?
target code: static boolean isValidMining ( ICodeMining mining ) { return mining != null && mining . getLabel ( ) != null && ! mining . getLabel ( ) . isEmpty ( ) ; }
response: static boolean isValidMining ( ICodeMining mining ) { return mining != null && mining . getLabel ( ) != null && ! mining . getLabel ( ) . isEmpty ( ) ; }  The `Objects . nonNull` method is not necessary here since it does the same thing as ` != null` . Therefore , we can simplify the code by using `mining != null` instead .

sample: 572
buggy_code: public void addInput(Page page) { verify(probe == null); probe = page; probePosition = 0; joinAddresses = null; <START> joinAddressIndex = 0; <END> }
code_review: `-1` would be more correct. AFAIC you can skip this.
target code: public void addInput ( Page page ) { verify ( probe == null ) ; probe = page ; probePosition = 0 ; joinAddresses = null ; }
response: public void addInput ( Page page ) { verify ( probe == null ) ; probe = page ; probePosition = 0 ; joinAddresses = null ; joinAddressIndex = - 1 ; }

sample: 573
buggy_code: public DescriptorImpl() { super(ThrottleJobProperty.class); synchronized(propertiesByCategoryLock) { load(); // Explictly drop queue items loaded from 1.8.1 version if (!propertiesByCategory.isEmpty()) { propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>(); save(); // Save the configuration to remove obsolete data } <START> } <END> }
code_review: Simpler to just rename the field. Then XStream will discard the old data automatically.
target code: public DescriptorImpl ( ) { super ( ThrottleJobProperty . class ) ; synchronized ( propertiesByCategoryLock ) { load ( ) ; // Explictly handle the persisted data from the version 1 . 8 . 1 if ( propertiesByCategory == null ) { propertiesByCategory = new HashMap < String , Map < ThrottleJobProperty , Void > > ( ) ; } if ( ! propertiesByCategory . isEmpty ( ) ) { propertiesByCategory . clear ( ) ; save ( ) ; // Save the configuration to remove obsolete data } } }
response: public DescriptorImpl ( ) { super ( ThrottleJobProperty . class ) ; synchronized ( propertiesByCategoryLock ) { load ( ) ; propertiesByCategory = new HashMap < String , Map < ThrottleJobProperty , Void > > ( ) ; // Renamed field save ( ) ; } }

sample: 574
buggy_code: public String toString() { // Since the static data arrives from external source it's not guarenteed not to be null so a null check is // mandatory in order to avoid NPE when invoking toString by the logger String domainName = staticData.getName() == null ? "null" : staticData.getName(); <START> String domainId = staticData.getId() == null ? "null" : staticData.getId().toString(); <END> return "StorageDomain[" + domainName + ", " + domainId + "]"; }
code_review: you don't need this. the "+" operator does this for you.
target code: public String toString ( ) { // Since the static data arrives from external source it's not guarenteed not to be null so a null check is // mandatory in order to avoid NPE when invoking toString by the logger String domainName = staticData == null ? "null" : staticData . getName ( ) ; Guid domainId = staticData == null ? null : staticData . getId ( ) ; return "StorageDomain [ " + domainName + " , " + domainId + " ] " ; }
response: public String toString ( ) { String domainName = staticData . getName ( ) == null ? "null" : staticData . getName ( ) ; String domainId = staticData . getId ( ) == null ? "null" : staticData . getId ( ) . toString ( ) ; return "StorageDomain [ " + domainName + " , " + domainId + " ] " ; }

sample: 575
buggy_code: Predicate<Entry<Key,Value>> getScanPredicate() { final Range range = getRange(); <START> return input -> { if (range != null && !range.contains(input.getKey())) return false; return true; }; <END> }
code_review: Can this be simplified to: ```java return input -> range == null || range.contains(input.getKey()); ```
target code: Predicate < Entry < Key , Value > > getScanPredicate ( ) { final Range range = getRange ( ) ; return input - > range == null || range . contains ( input . getKey ( ) ) ; }
response: java Predicate < Entry < Key , Value > > getScanPredicate ( ) { final Range range = getRange ( ) ; return input - > range == null || range . contains ( input . getKey ( ) ) ; }

sample: 576
buggy_code: public AlluxioHiveMetastore(TableMasterClient client) { <START> requireNonNull(client, "client is null"); <END> this.client = client; }
code_review: nit ```java this.client = requireNonNull(client, "client is null");
target code: public AlluxioHiveMetastore ( TableMasterClient client ) { this . client = requireNonNull ( client , "client is null" ) ; }
response: java public AlluxioHiveMetastore ( TableMasterClient client ) { this . client = Objects . requireNonNull ( client , "client is null" ) ; }

sample: 577
buggy_code: private void addWorkPackageCriteria() { if (isWorkPackageSpecified()) { ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId); if (isColorTeamMatch(workPackArt)) { <START> if (workPackArt.isValid()) <END> { queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString()); } } } }
code_review: Should this be above "isColorTeamMatch"? For example, on line #755.
target code: private void addWorkPackageCriteria ( ) { if ( isWorkPackageSpecified ( ) ) { ArtifactId workPackArt = atsApi . getQueryService ( ) . getArtifactOrSentinel ( workPackageId ) ; if ( workPackArt . isValid ( ) ) { if ( isColorTeamMatch ( workPackArt ) ) { queryAnd ( AtsAttributeTypes . WorkPackageReference , workPackArt . getIdString ( ) ) ; } } } }
response: private void addWorkPackageCriteria ( ) { if ( isWorkPackageSpecified ( ) ) { ArtifactId workPackArt = atsApi . getQueryService ( ) . getArtifactOrSentinel ( workPackageId ) ; if ( workPackArt . isValid ( ) && isColorTeamMatch ( workPackArt ) ) { queryAnd ( AtsAttributeTypes . WorkPackageReference , workPackArt . getIdString ( ) ) ; } } }

sample: 578
buggy_code: private void sendToSocket(Socket socket, String cmdString) throws IOException { // remove spaces at beginning and end and replace double spaces in // string with single space byte[] sendBytes = ("A" + cmdString.trim().replaceAll("\\s+", " ") + "\n").getBytes(); <START> socket.getInputStream().skip(tcpSocket.getInputStream().available()); <END> socket.getOutputStream().write(sendBytes); socket.getOutputStream().flush(); AstericsErrorHandling.instance.reportInfo(this, "IRTrans sent data: " + cmdString); }
code_review: you directly use the member variable tcpSocket, but shouldnt it be the parameter socket?
target code: private void sendToSocket ( Socket socket , String cmdString ) throws IOException { // remove spaces at beginning and end and replace double spaces in // string with single space byte [ ] sendBytes = ( "A" + cmdString . trim ( ) . replaceAll ( "\\s + " , " " ) + "\n" ) . getBytes ( ) ; socket . getInputStream ( ) . skip ( socket . getInputStream ( ) . available ( ) ) ; socket . getOutputStream ( ) . write ( sendBytes ) ; socket . getOutputStream ( ) . flush ( ) ; AstericsErrorHandling . instance . reportInfo ( this , "IRTrans sent data : " + cmdString ) ; }
response: private void sendToSocket ( Socket socket , String cmdString ) throws IOException { byte [ ] sendBytes = ( "A" + cmdString . trim ( ) . replaceAll ( "\\s + " , " " ) + "\n" ) . getBytes ( ) ; socket . getInputStream ( ) . skip ( socket . getInputStream ( ) . available ( ) ) ; socket . getOutputStream ( ) . write ( sendBytes ) ; socket . getOutputStream ( ) . flush ( ) ; AstericsErrorHandling . instance . reportInfo ( this , "IRTrans sent data : " + cmdString ) ; }

sample: 579
buggy_code: public int hashCode() { <START> return getClass().hashCode(); <END> }
code_review: can you explain why this is necessary?
target code: public int hashCode ( ) { return 1 ; }
response: The `hashCode ( ) ` method is used to generate a unique integer value for an object . In the given buggy code , the `hashCode ( ) ` method is only returning the hash code of the object's class . This is not a unique value for each object and can cause collisions when using hash - based data structures like HashMap . To fix this , we can use a combination of the object's fields to generate a unique hash code . Here's an example of how we can refactor the code :  @Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( field1 == null ) ? 0 : field1 . hashCode ( ) ) ; result = prime * result + ( ( field2 == null ) ? 0 : field2 . hashCode ( ) ) ; // add more fields as needed return result ; }  In this code , we are using the `prime` number 31 as a multiplier and adding the hash codes of each field to the `result` variable . If a field is null , we use 0 as its hash code . This ensures that each object will have a unique hash code based on its fields .

sample: 580
buggy_code: private void reset() { <START> setId( next = NO_ID ); <END> }
code_review: i do not think we need to save this line better make it more readable
target code: private void reset ( ) { next = NO_ID ; setId ( NO_ID ) ; }
response: private void reset ( ) { setId ( NO_ID ) ; next = NO_ID ; }

sample: 581
buggy_code: public String getActualDowntime() { <START> return (actualDowntime == null) ? "(N/A)" : actualDowntime.toString() + "ms"; <END> }
code_review: so now you can drop the "toString()"
target code: public String getActualDowntime ( ) { return ( actualDowntime == null ) ? " ( N / A ) " : actualDowntime + "ms" ; }
response: public String getActualDowntime ( ) { return ( actualDowntime == null ) ? " ( N / A ) " : actualDowntime + "ms" ; }

sample: 582
buggy_code: String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params, final String argument) { if (argument.contains("/")) { <START> <END> }else{ return (params.live) ? "/live/" + argument + "." + EXTENSION : "/working/" + argument + "." + EXTENSION; } }
code_review: @wezell , missing return statement... This is breaking when compiling the code
target code: String resolveTemplatePath ( final Context context , final Writer writer , final RenderParams params , final String argument ) { return ( params . live ) ? " / live / " + argument + " . " + EXTENSION : " / working / " + argument + " . " + EXTENSION ; }
response: String resolveTemplatePath ( final Context context , final Writer writer , final RenderParams params , final String argument ) { if ( argument . contains ( " / " ) ) { // code to handle when argument contains " / " } else { return ( params . live ) ? " / live / " + argument + " . " + EXTENSION : " / working / " + argument + " . " + EXTENSION ; } return null ; // added missing return statement }

sample: 583
buggy_code: public DispoConfig findDispoConfig(DispoProgram program) { <START> ArtifactReadable config = <END> getQuery().fromBranch(program.getUuid()).andNameEquals("Program Config").getResults().getOneOrNull(); if (config == null) { DispoUtil.getDefaultConfig(); } return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config)); }
code_review: andNameEquals is un-needed and probably undesired incase name ever changes
target code: public DispoConfig findDispoConfig ( DispoProgram program ) { ArtifactReadable config = getQuery ( ) . fromBranch ( program . getUuid ( ) ) . andNameEquals ( "Program Config" ) . getResults ( ) . getOneOrNull ( ) ; if ( config == null ) { return DispoUtil . getDefaultConfig ( ) ; } return DispoUtil . configArtToConfigData ( new DispoConfigArtifact ( config ) ) ; }
response: public DispoConfig findDispoConfig ( DispoProgram program ) { ArtifactReadable config = getQuery ( ) . fromBranch ( program . getUuid ( ) ) . getResults ( ) . getOneOrNull ( ) ; if ( config == null ) { DispoUtil . getDefaultConfig ( ) ; } return DispoUtil . configArtToConfigData ( new DispoConfigArtifact ( config ) ) ; }

sample: 584
buggy_code: public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { // Indexing on signatures optimises this type of request for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { <START> if (operations.get(entry.getKey()).contains(name)) { <END> return true; } } } return false; }
code_review: This is wrong, should be `entry.getValue()`
target code: public boolean hasMatchingOpSig ( String name , JavaOperationSigMask mask ) { // Indexing on signatures optimises this type of request for ( Entry < JavaOperationSignature , Set < String > > entry : operations . entrySet ( ) ) { if ( mask . covers ( entry . getKey ( ) ) ) { if ( entry . getValue ( ) . contains ( name ) ) { return true ; } } } return false ; }
response: public boolean hasMatchingOpSig ( String name , JavaOperationSigMask mask ) { for ( Entry < JavaOperationSignature , Set < String > > entry : operations . entrySet ( ) ) { if ( mask . covers ( entry . getKey ( ) ) ) { if ( entry . getValue ( ) . contains ( name ) ) { return true ; } } } return false ; }

sample: 585
buggy_code: <START> IonSqlQueryBuilder(TypeManager typeManager) <END> { this.typeManager = requireNonNull(typeManager, "typeManager is null"); }
code_review: Make these methods public since they are part of the public API of the class. If we want to restrict access to the class, we would make the class itself package private.
target code: public IonSqlQueryBuilder ( TypeManager typeManager ) { this . typeManager = requireNonNull ( typeManager , "typeManager is null" ) ; }
response: public IonSqlQueryBuilder ( TypeManager typeManager ) { this . typeManager = Objects . requireNonNull ( typeManager , "typeManager is null" ) ; }

sample: 586
buggy_code: protected OperationController getOperationController() { <START> return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size())); <END> }
code_review: Should we abstract this. I mean the way we choose the operation controller. What in case in future, we wish to choose the one which is less loaded compared to others?
target code: private OperationController getOperationController ( ) { return ocList . get ( ThreadLocalRandom . current ( ) . nextInt ( ocList . size ( ) ) ) ; }
response: protected OperationController getOperationController ( ) { // Choose the operation controller with the least load OperationController leastLoadedController = ocList . get ( 0 ) ; for ( OperationController oc : ocList ) { if ( oc . getLoad ( ) < leastLoadedController . getLoad ( ) ) { leastLoadedController = oc ; } } return leastLoadedController ; }

sample: 587
buggy_code: public List<JDK> getJDKs() { <START> if(jdks==null) <END> jdks = new ArrayList<JDK>(); return jdks; }
code_review: So I believe the only way this could be null is if a configuration was saved without the <jdks> entry and then reloaded. I don't see how that could happen - but there may be some old version of Jenkins that could have done it. Would probably make sense to modify a `readResolve()` to set it to an empty list and remove this check and the theoretical possibility?
target code: public List < JDK > getJDKs ( ) { return jdks ; }
response: public List < JDK > getJDKs ( ) { if ( jdks == null ) { jdks = new ArrayList < JDK > ( ) ; } return jdks ; } // Add the following method to set jdks to an empty list during deserialization private Object readResolve ( ) { if ( jdks == null ) { jdks = new ArrayList < JDK > ( ) ; } return this ; }

sample: 588
buggy_code: public boolean addAll(int index, Collection<? extends T> c) { Collection<T> uniqueValuesToAdd = getUniqueValues(c); if (uniqueValuesToAdd.isEmpty()) { return false; } try { return super.addAll(index, uniqueValuesToAdd); } catch (IndexOutOfBoundsException ioobException) { comparingSet.removeAll(uniqueValuesToAdd); <START> throw new IndexOutOfBoundsException(); <END> } }
code_review: same as above: please pass on the original exception so that we retain the stacktrace and message.
target code: public boolean addAll ( int index , Collection < ? extends T > c ) { Collection < T > uniqueValuesToAdd = getUniqueValues ( c ) ; if ( uniqueValuesToAdd . isEmpty ( ) ) { return false ; } try { return super . addAll ( index , uniqueValuesToAdd ) ; } catch ( IndexOutOfBoundsException ioobException ) { comparingSet . removeAll ( uniqueValuesToAdd ) ; throw ioobException ; } }
response: public boolean addAll ( int index , Collection < ? extends T > c ) { Collection < T > uniqueValuesToAdd = getUniqueValues ( c ) ; if ( uniqueValuesToAdd . isEmpty ( ) ) { return false ; } try { return super . addAll ( index , uniqueValuesToAdd ) ; } catch ( IndexOutOfBoundsException ioobException ) { comparingSet . removeAll ( uniqueValuesToAdd ) ; throw ioobException ; } }

sample: 589
buggy_code: public Context getContext() { if (sdkName == null) { sdkName = this.getClass().getPackage().getName(); } return new Context("Sdk-Name", sdkName) <START> .addData("Sdk-Version", SDK_VERSION); <END> }
code_review: why sdk version hardcoded?
target code: public Context getContext ( ) { return new Context ( "Sdk - Name" , sdkName ) . addData ( "Sdk - Version" , SDK_VERSION ) ; }
response: public Context getContext ( ) { if ( sdkName == null ) { sdkName = this . getClass ( ) . getPackage ( ) . getName ( ) ; } return new Context ( "Sdk - Name" , sdkName ) . addData ( "Sdk - Version" , BuildConfig . SDK_VERSION ) ; }  Explanation : Instead of hardcoding the SDK version , we can use a variable from the BuildConfig file which is automatically generated during the build process and contains the version information . This makes it easier to update the version in the future without having to modify the code .

sample: 590
buggy_code: <START> public void setSelectedDevices(List<StorageDevice> selectedDevices) { <END> getStorageDevices().setSelectedItems(selectedDevices); }
code_review: Can this be protected. I assume only the ListModel is using it
target code: protected void setSelectedDevices ( List < StorageDevice > selectedDevices ) { getStorageDevices ( ) . setSelectedItems ( selectedDevices ) ; }
response: < START > protected void setSelectedDevices ( List < StorageDevice > selectedDevices ) { getStorageDevices ( ) . setSelectedItems ( selectedDevices ) ; } < END >

sample: 591
buggy_code: private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) { Snapshot snapshot = timer.getSnapshot(); JsonObject json = new JsonObject(); // Meter populateMetered(json, timer, rateUnit); // Snapshot double factor = 1.0 / durationUnit.toNanos(1); populateSnapshot(json, snapshot, factor); // Duration rate <START> String duration = durationUnit.toString().toLowerCase(Locale.US); <END> json.putString("durationRate", duration); return json; }
code_review: Why US?
target code: private JsonObject toJson ( Timer timer , TimeUnit rateUnit , TimeUnit durationUnit ) { Snapshot snapshot = timer . getSnapshot ( ) ; JsonObject json = new JsonObject ( ) ; // Meter populateMetered ( json , timer , rateUnit ) ; // Snapshot double factor = 1 . 0 / durationUnit . toNanos ( 1 ) ; populateSnapshot ( json , snapshot , factor ) ; // Duration rate String duration = durationUnit . toString ( ) . toLowerCase ( ) ; json . putString ( "durationRate" , duration ) ; return json ; }
response: private JsonObject toJson ( Timer timer , TimeUnit rateUnit , TimeUnit durationUnit ) { Snapshot snapshot = timer . getSnapshot ( ) ; JsonObject json = new JsonObject ( ) ; populateMetered ( json , timer , rateUnit ) ; double factor = 1 . 0 / durationUnit . toNanos ( 1 ) ; populateSnapshot ( json , snapshot , factor ) ; String duration = durationUnit . toString ( ) . toLowerCase ( ) ; json . putString ( "durationRate" , duration ) ; return json ; }

sample: 592
buggy_code: protected void delete(LogEntry delegate, String reason, RequestContext context) throws ResourceDoesNotSupportOperationException { <START> throw new UnsupportedOperationException("delete not supported"); <END> }
code_review: Should be ResourceDoesNotSupportOperationException
target code: protected void delete ( LogEntry delegate , String reason , RequestContext context ) throws ResourceDoesNotSupportOperationException { throw new ResourceDoesNotSupportOperationException ( ) ; }
response: protected void delete ( LogEntry delegate , String reason , RequestContext context ) throws ResourceDoesNotSupportOperationException { throw new ResourceDoesNotSupportOperationException ( "delete not supported" ) ; }

sample: 593
buggy_code: <START> protected void setConsumerBatchEnabled(boolean consumerBatchEnabled) { <END> this.consumerBatchEnabled = consumerBatchEnabled; }
code_review: Why is this `protected` ? Are you going to detect this option internally by the `@RabbitListener(Handler)` method signature?
target code: public void setConsumerBatchEnabled ( boolean consumerBatchEnabled ) { this . consumerBatchEnabled = consumerBatchEnabled ; }
response: void setConsumerBatchEnabled ( boolean consumerBatchEnabled ) { this . consumerBatchEnabled = consumerBatchEnabled ; }  Explanation : Since there is no indication that the `setConsumerBatchEnabled` method needs to be accessed outside of the class , the `protected` access modifier is not necessary . Therefore , it can be removed . Additionally , there is no indication that this method is related to a `@RabbitListener` annotation , so the second part of the review comment is not applicable .

sample: 594
buggy_code: public int getLevel() { <START> return data.optInt("toclevel"); <END> }
code_review: old code seems to indicate this should be "level" not "toclevel"? Could be causing failure of getLevel() calls being compared in SectionsFetchTask.processResult?
target code: public int getLevel ( ) { return data . optInt ( "toclevel" , 1 ) ; }
response: public int getLevel ( ) { return data . optInt ( "level" ) ; }

sample: 595
buggy_code: private void setPagesRecycler(OnThisDayCard card) { if (card.pages() != null) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) <START> this.getContext()); <END> recyclerAdapter.setCallback(new ItemCallback()); pagesRecycler.setAdapter(recyclerAdapter); } else { pagesRecycler.setVisibility(GONE); } }
code_review: use getContext() instead of this.getContext() ?
target code: private void setPagesRecycler ( OnThisDayCard card ) { if ( card . pages ( ) != null ) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter ( card . pages ( ) , card . wiki ( ) , true , ( Activity ) getContext ( ) ) ; recyclerAdapter . setCallback ( new ItemCallback ( ) ) ; pagesRecycler . setAdapter ( recyclerAdapter ) ; } else { pagesRecycler . setVisibility ( GONE ) ; } }
response: private void setPagesRecycler ( OnThisDayCard card ) { if ( card . pages ( ) != null ) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter ( card . pages ( ) , card . wiki ( ) , true , ( Activity ) getContext ( ) ) ; recyclerAdapter . setCallback ( new ItemCallback ( ) ) ; pagesRecycler . setAdapter ( recyclerAdapter ) ; } else { pagesRecycler . setVisibility ( GONE ) ; } }

sample: 596
buggy_code: public String getExtendedLabelForVSM(String providedShapeURI) { for (IConfigurationElement configurationElement : extensions) { String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier(); if (identifier != null && identifier.equals(providedShapeURI)) { return <START> configurationElement.getAttribute(LABEL_ATTRIBUTE) + " - " + configurationElement.getNamespaceIdentifier(); //$NON-NLS-1$ <END> } } return "Unknown URI"; //$NON-NLS-1$ }
code_review: Add a getExtendedLabelsForVSM(IConfigurationElement) method to avoid duplication
target code: public String getExtendedLabelForVSM ( String providedShapeURI ) { for ( IConfigurationElement configurationElement : extensions ) { String identifier = ( ( ExtensionHandle ) configurationElement . getParent ( ) ) . getSimpleIdentifier ( ) ; if ( identifier != null && identifier . equals ( providedShapeURI ) ) { return getExtendedLabelForVSM ( configurationElement ) ; } } return "Unknown URI" ; // $NON - NLS - 1$ }
response: public String getExtendedLabelForVSM ( String providedShapeURI ) { IConfigurationElement element = getConfigurationElement ( providedShapeURI ) ; if ( element != null ) { return getExtendedLabelsForVSM ( element ) ; } return "Unknown URI" ; // $NON - NLS - 1$ } private IConfigurationElement getConfigurationElement ( String providedShapeURI ) { for ( IConfigurationElement configurationElement : extensions ) { String identifier = ( ( ExtensionHandle ) configurationElement . getParent ( ) ) . getSimpleIdentifier ( ) ; if ( identifier != null && identifier . equals ( providedShapeURI ) ) { return configurationElement ; } } return null ; } private String getExtendedLabelsForVSM ( IConfigurationElement configurationElement ) { return configurationElement . getAttribute ( LABEL_ATTRIBUTE ) + " - " + configurationElement . getNamespaceIdentifier ( ) ; // $NON - NLS - 1$ }

sample: 597
buggy_code: public void stopServer() { if (server instanceof GrizzlyServer) { <START> ((GrizzlyServer) server).setCleanIdleConnections(); <END> } server.stop(); }
code_review: I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter.
target code: public void stopServer ( ) { if ( server instanceof GrizzlyServer ) { ( ( GrizzlyServer ) server ) . setCleanIdleConnections ( true ) ; } server . stop ( ) ; }
response: public void stopServer ( ) { if ( server instanceof GrizzlyServer ) { ( ( GrizzlyServer ) server ) . cleanIdleConnections ( true ) ; } server . stop ( ) ; }

sample: 598
buggy_code: protected Supplier<Operation> createOperationSupplier() { <START> return () -> new DistributedObjectDestroyOperation(parameters.serviceName, parameters.name); <END> }
code_review: We can make `DestroyProxyMessageTask` implement the Supplier, so that this method will no create a lamda but return `this` instead.
target code: protected Supplier < Operation > createOperationSupplier ( ) { return this ; }
response: protected class DestroyProxyMessageTask implements Supplier < Operation > { @Override public Operation get ( ) { return new DistributedObjectDestroyOperation ( parameters . serviceName , parameters . name ) ; } } protected Supplier < Operation > createOperationSupplier ( ) { return new DestroyProxyMessageTask ( ) ; }

sample: 599
buggy_code: public <C extends CtTypedElement> C setType(CtTypeReference<T> type) { if (type != null) { type.setParent(this); } // even if the setter delegates to getExecutable, it makes sense to create an event <START> getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType()); <END> if (getExecutable() != null) { getExecutable().setType(type); } return (C) this; }
code_review: So model change listener will be called twice for single modification? I do not like it. @monperrus Could you explain why it is good?
target code: public < C extends CtTypedElement > C setType ( CtTypeReference < T > type ) { if ( type != null ) { type . setParent ( this ) ; } if ( getExecutable ( ) != null ) { getExecutable ( ) . setType ( type ) ; } return ( C ) this ; }
response: public < C extends CtTypedElement > C setType ( CtTypeReference < T > type ) { if ( type != null ) { type . setParent ( this ) ; } if ( getExecutable ( ) != null ) { getExecutable ( ) . setType ( type ) ; } if ( type != null ) { getFactory ( ) . getEnvironment ( ) . getModelChangeListener ( ) . onObjectUpdate ( this , TYPE , type , getExecutable ( ) . getType ( ) ) ; } return ( C ) this ; }

BLEU: 64.06 ; EM: 21.67
Python file executed successfully.
Cloning into 'tree-sitter-java'...
ngram match: 0.6405870007429894, weighted ngram match: 0.6687190549065782, syntax_match: 0.6862580464595578, dataflow_match: 0.5847568988173456
CodeBLEU score: 64.51
Python file executed successfully.
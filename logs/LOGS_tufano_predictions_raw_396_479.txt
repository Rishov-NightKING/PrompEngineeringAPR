sample: 396
buggy_code: public int getMaxCapacity() { <START> readLock.lock(); <END> try { return maxCapacity; } finally { readLock.unlock(); } }
code_review: why should add lock here?
target code: public int getMaxCapacity ( ) { return maxCapacity ; }
response: The lock is added to ensure thread safety when accessing the shared variable "maxCapacity" . Here's the   public int getMaxCapacity ( ) { readLock . lock ( ) ; try { return maxCapacity ; } finally { readLock . unlock ( ) ; } }

sample: 397
buggy_code: public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() { List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> }
code_review: Can you use isEmpty()?
target code: public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser ( ) { List < VDS > result = dao . getAllForVdsGroup ( existingVds . getvds_group_id ( ) , UNPRIVILEGED_USER_ID , true ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; }
response: public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser ( ) { List < VDS > result = dao . getAllForVdsGroup ( existingVds . getvds_group_id ( ) , UNPRIVILEGED_USER_ID , true ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; }

sample: 398
buggy_code: private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) { ComboPooledDataSource ds = new ComboPooledDataSource(false); ds.setDataSourceName(name); ds.setIdentityToken(name); new BeanMap(ds).putAll(properties); C3P0Registry.reregister(ds); try { checkDataSource(ds, name); } catch (SQLException e) { <START> throw new RuntimeException("Failed check data source", e); <END> } return ds; }
code_review: Я еще люблю в сообщение вставлять изначальный exception, nипа "Failed to check data source " + e.toString(), e).
target code: private static DataSource createC3P0DataSource ( String name , Map < Object , Object > properties ) { ComboPooledDataSource ds = new ComboPooledDataSource ( false ) ; ds . setDataSourceName ( name ) ; ds . setIdentityToken ( name ) ; new BeanMap ( ds ) . putAll ( properties ) ; C3P0Registry . reregister ( ds ) ; checkDataSource ( ds , name ) ; return ds ; }
response: private static DataSource createC3P0DataSource ( String name , Map < Object , Object > properties ) { ComboPooledDataSource ds = new ComboPooledDataSource ( false ) ; ds . setDataSourceName ( name ) ; ds . setIdentityToken ( name ) ; new BeanMap ( ds ) . putAll ( properties ) ; C3P0Registry . reregister ( ds ) ; try { checkDataSource ( ds , name ) ; } catch ( SQLException e ) { throw new RuntimeException ( "Failed to check data source " + e . toString ( ) , e ) ; } return ds ; }

sample: 399
buggy_code: protected Control createPageControls(Composite parent) { setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer); <START> Label label = new Label(parent, SWT.CENTER); <END> label.setText( NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName())); return parent; }
code_review: no need to center it, just give it SWT.NONE
target code: protected Control createPageControls ( Composite parent ) { setTitle ( Messages . RemoveReviewerDialog_Remove_Reviewer ) ; Label label = new Label ( parent , SWT . NONE ) ; label . setText ( NLS . bind ( Messages . RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove , userToRemove . getDisplayName ( ) ) ) ; return parent ; }
response: protected Control createPageControls ( Composite parent ) { setTitle ( Messages . RemoveReviewerDialog_Remove_Reviewer ) ; Label label = new Label ( parent , SWT . NONE ) ; label . setText ( NLS . bind ( Messages . RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove , userToRemove . getDisplayName ( ) ) ) ; return parent ; }

sample: 400
buggy_code: public List<PermissionSubject> getPermissionCheckSubjects() { List<PermissionSubject> list = new ArrayList<PermissionSubject>(); Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue(); list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup())); QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId()); return list; <START> } <END>
code_review: I think you need to call super otherwise you loose the permissions that you need to check by default.
target code: public List < PermissionSubject > getPermissionCheckSubjects ( ) { List < PermissionSubject > list = new ArrayList < PermissionSubject > ( ) ; Guid storagePoolId = getVdsGroup ( ) == null || getVdsGroup ( ) . getstorage_pool_id ( ) == null ? null : getVdsGroup ( ) . getstorage_pool_id ( ) . getValue ( ) ; list . add ( new PermissionSubject ( storagePoolId , VdcObjectType . StoragePool , getActionType ( ) . getActionGroup ( ) ) ) ; list = QuotaHelper . addQuotaPermissionSubject ( list , getStoragePool ( ) , getQuotaId ( ) ) ; return list ; }
response: public List < PermissionSubject > getPermissionCheckSubjects ( ) { List < PermissionSubject > list = super . getPermissionCheckSubjects ( ) ; Guid storagePoolId = getVdsGroup ( ) == null || getVdsGroup ( ) . getstorage_pool_id ( ) == null ? null : getVdsGroup ( ) . getstorage_pool_id ( ) . getValue ( ) ; list . add ( new PermissionSubject ( storagePoolId , VdcObjectType . StoragePool , getActionType ( ) . getActionGroup ( ) ) ) ; QuotaHelper . addQuotaPermissionSubject ( list , getStoragePool ( ) , getQuotaId ( ) ) ; return list ; }

sample: 401
buggy_code: public void onInit( String clientName, Map<String,Object> credentials ) throws IOException { <START> packer.packStructHeader( 1, INIT.signature() ); <END> packer.pack( clientName ); packer.pack( ValueUtils.asMapValue( credentials ) ); onMessageComplete.onMessageComplete(); }
code_review: This is actually wrong but it is an error that has propagated to all drivers. The init struct has size 2 and not size 1. We are saved by ignoring the struct size when we read the init message.
target code: public void onInit ( String clientName , Map < String , Object > credentials ) throws IOException { packer . packStructHeader ( 2 , INIT . signature ( ) ) ; packer . pack ( clientName ) ; packer . pack ( ValueUtils . asMapValue ( credentials ) ) ; onMessageComplete . onMessageComplete ( ) ; }
response: public void onInit ( String clientName , Map < String , Object > credentials ) throws IOException { packer . packStructHeader ( 2 , INIT . signature ( ) ) ; packer . pack ( clientName ) ; packer . pack ( ValueUtils . asMapValue ( credentials ) ) ; onMessageComplete . onMessageComplete ( ) ; }

sample: 402
buggy_code: <START> public SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension, <END> NovaSecurityGroupExtension novaSecurityGroupExtension) { this.neutronSecurityGroupExtension = neutronSecurityGroupExtension; this.novaSecurityGroupExtension = novaSecurityGroupExtension; }
code_review: Remove the public modifier
target code: SecurityGroupExtensionProvider ( NeutronSecurityGroupExtension neutronSecurityGroupExtension , NovaSecurityGroupExtension novaSecurityGroupExtension ) { this . neutronSecurityGroupExtension = neutronSecurityGroupExtension ; this . novaSecurityGroupExtension = novaSecurityGroupExtension ; }
response: < START > SecurityGroupExtensionProvider ( NeutronSecurityGroupExtension neutronSecurityGroupExtension , NovaSecurityGroupExtension novaSecurityGroupExtension ) { this . neutronSecurityGroupExtension = neutronSecurityGroupExtension ; this . novaSecurityGroupExtension = novaSecurityGroupExtension ; }

sample: 403
buggy_code: private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionNotEqualNullWithOr(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionComparedWithFunction(expression, kind); <START> if (comparedExpression == null) { <END> return null; } } } return comparedExpression; }
code_review: @vilchik-elena Do we need this block?
target code: private static ExpressionTree getComparedWithNullExpression ( ExpressionTree expression , Tree . Kind kind ) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd ( expression , kind ) ; if ( comparedExpression == null ) { comparedExpression = getExpressionNotEqualNullWithOr ( expression , kind ) ; if ( comparedExpression == null ) { comparedExpression = getExpressionComparedWithFunction ( expression , kind ) ; } } return comparedExpression ; }
response: private static ExpressionTree getComparedWithNullExpression ( ExpressionTree expression , Tree . Kind kind ) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd ( expression , kind ) ; if ( comparedExpression == null ) { comparedExpression = getExpressionNotEqualNullWithOr ( expression , kind ) ; if ( comparedExpression == null ) { comparedExpression = getExpressionComparedWithFunction ( expression , kind ) ; if ( comparedExpression == null ) { return null ; } } } return comparedExpression ; }

sample: 404
buggy_code: private void scheduleRefresh(Duration delay) { // already stopped? avoids rejection exception if (executor.isShutdown()) { return; } <START> executor.schedule((Runnable) this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS); <END> }
code_review: Is the `(Runnable)` needed?
target code: private void scheduleRefresh ( Duration delay ) { // already stopped ? avoids rejection exception if ( executor . isShutdown ( ) ) { return ; } executor . schedule ( this : : refresh , delay . toMillis ( ) , TimeUnit . MILLISECONDS ) ; }
response: private void scheduleRefresh ( Duration delay ) { if ( executor . isShutdown ( ) ) { return ; } executor . schedule ( this : : refresh , delay . toMillis ( ) , TimeUnit . MILLISECONDS ) ; }  Review : No , the ` ( Runnable ) ` is not needed as `this : : refresh` already implements the `Runnable` interface .

sample: 405
buggy_code: public static void main(String[] args) { <START> LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of("reorder_joins", "false")); <END> new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out)); }
code_review: Technically, you should `queryRunner.close()` (or t-w-r). This would ensure proper cleanup of any temp files (or whatevers) it might have created
target code: public static void main ( String [ ] args ) { LocalQueryRunner queryRunner = createLocalQueryRunner ( ImmutableMap . of ( "reorder_joins" , "false" ) ) ; new SqlConsecutiveJoinBenchmark ( queryRunner ) . runBenchmark ( new SimpleLineBenchmarkResultWriter ( System . out ) ) ; queryRunner . close ( ) ; }
response: public static void main ( String [ ] args ) { try ( LocalQueryRunner queryRunner = createLocalQueryRunner ( ImmutableMap . of ( "reorder_joins" , "false" ) ) ) { new SqlConsecutiveJoinBenchmark ( queryRunner ) . runBenchmark ( new SimpleLineBenchmarkResultWriter ( System . out ) ) ; } }

sample: 406
buggy_code: <START> public void beforeStartingVertx(VertxOptions options) { <END> }
code_review: Shouldn't they be protected not public?
target code: protected void beforeStartingVertx ( VertxOptions options ) { }
response: protected void beforeStartingVertx ( VertxOptions options ) { }

sample: 407
buggy_code: public Builder body(String json) { checkNotNull(json, "body required"); checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES), <START> "json size must be <= %s bytes", getInteger(MESSAGE_BODY_MAX_IN_BYTES)); <END> this.body = new JsonBall(json).toString(); return self(); }
code_review: Ah, so I guess that lack of a Guice context here (and above) is the reason for the system properties? How do we solve that elsewhere in jclouds? Would we inject some kind of factory object via Guice?
target code: public Builder body ( String json ) { checkNotNull ( json , "body required" ) ; this . body = new JsonBall ( json ) . toString ( ) ; return self ( ) ; }
response: public Builder body ( String json ) { checkNotNull ( json , "body required" ) ; checkArgument ( json . getBytes ( ) . length <= Integer . parseInt ( System . getProperty ( "jclouds . message - body - max - bytes" ) ) , "json size must be <= % s bytes" , System . getProperty ( "jclouds . message - body - max - bytes" ) ) ; this . body = new JsonBall ( json ) . toString ( ) ; return self ( ) ; }

sample: 408
buggy_code: private String getTokenFromHeader(HttpServletRequest request) { String token = null; String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION); if (headerValue != null && headerValue.startsWith(BEARER)) { token = <START> headerValue.substring("Bearer".length()).trim(); <END> } return token; }
code_review: s/"Bearer"/BEARER
target code: private String getTokenFromHeader ( HttpServletRequest request ) { String token = null ; String headerValue = request . getHeader ( SsoConstants . HEADER_AUTHORIZATION ) ; if ( headerValue != null && headerValue . startsWith ( BEARER ) ) { token = headerValue . substring ( BEARER . length ( ) ) . trim ( ) ; } return token ; }
response: private String getTokenFromHeader ( HttpServletRequest request ) { String token = null ; String headerValue = request . getHeader ( SsoConstants . HEADER_AUTHORIZATION ) ; if ( headerValue != null && headerValue . startsWith ( BEARER ) ) { token = headerValue . substring ( BEARER . length ( ) ) . trim ( ) ; } return token ; }

sample: 409
buggy_code: <START> public static CDIProvider getCDIProvider() { <END> if (configuredProvider != null) { return configuredProvider; } else { // Discover providers and cache if (discoveredProviders == null) { synchronized (lock) { if (discoveredProviders == null) { findAllProviders(); } } } configuredProvider = discoveredProviders.stream() .filter(c -> c.getCDI() != null) .findAny().orElseThrow(() -> new IllegalStateException("Unable to access CDI")); return configuredProvider; } }
code_review: This method should not be public or what's the point?
target code: private static CDIProvider getCDIProvider ( ) { if ( configuredProvider != null ) { return configuredProvider ; } else { // Discover providers and cache if ( discoveredProviders == null ) { synchronized ( lock ) { if ( discoveredProviders == null ) { findAllProviders ( ) ; } } } configuredProvider = discoveredProviders . stream ( ) . filter ( c - > c . getCDI ( ) != null ) . findAny ( ) . orElseThrow ( ( ) - > new IllegalStateException ( "Unable to access CDI" ) ) ; return configuredProvider ; } }
response: private static CDIProvider getCDIProvider ( ) { if ( configuredProvider != null ) { return configuredProvider ; } else { if ( discoveredProviders == null ) { synchronized ( lock ) { if ( discoveredProviders == null ) { findAllProviders ( ) ; } } } configuredProvider = discoveredProviders . stream ( ) . filter ( c - > c . getCDI ( ) != null ) . findAny ( ) . orElseThrow ( ( ) - > new IllegalStateException ( "Unable to access CDI" ) ) ; return configuredProvider ; } }

sample: 410
buggy_code: <START> public void testIsDrawable_Stage() throws Exception { <END> testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true); }
code_review: The Exception is never thrown.
target code: public void testIsDrawable_Stage ( ) { testIsDrawable ( CaseManagementDiagram . class , AdHocSubprocess . class , true ) ; }
response: public void testIsDrawable_Stage ( ) { try { testIsDrawable ( CaseManagementDiagram . class , AdHocSubprocess . class , true ) ; } catch ( Exception e ) { // handle the exception here } }

sample: 411
buggy_code: public static boolean customImageExists(String storage, String key) { final AzureBlobClient azureBlob = ContextBuilder.newBuilder("azureblob") .credentials(storage, key) .buildApi(AzureBlobClient.class); try { return azureBlob.containerExists("system"); } catch (Exception e) { e.printStackTrace(); return false; <START> } <END> finally { Closeables2.closeQuietly(azureBlob); } }
code_review: The container exists method should already return false [if the container exists call returns a 404](https://github.com/jclouds/jclouds/blob/master/providers/azureblob/src/main/java/org/jclouds/azureblob/AzureBlobClient.java#L156). Worth removing the catch, as it might be caused by other errors that should be taken into acount?
target code: public static boolean customImageExists ( String storage , String key ) { final AzureBlobClient azureBlob = ContextBuilder . newBuilder ( "azureblob" ) . credentials ( storage , key ) . buildApi ( AzureBlobClient . class ) ; try { return azureBlob . containerExists ( "system" ) ; } finally { Closeables2 . closeQuietly ( azureBlob ) ; } }
response: public static boolean customImageExists ( String storage , String key ) { final AzureBlobClient azureBlob = ContextBuilder . newBuilder ( "azureblob" ) . credentials ( storage , key ) . buildApi ( AzureBlobClient . class ) ; boolean exists = azureBlob . containerExists ( "system" ) ; Closeables2 . closeQuietly ( azureBlob ) ; return exists ; }

sample: 412
buggy_code: public void enter() { mUseEap = (IkeSessionOptions.IKE_AUTH_METHOD_EAP == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod); <START> super.enter(); <END> }
code_review: Nit: By convention, this is almost always the first thing called, unless there's a explicit reason why it needs to happen after (which is usually a code smell)
target code: public void enter ( ) { super . enter ( ) ; mUseEap = ( IkeSessionOptions . IKE_AUTH_METHOD_EAP == mIkeSessionOptions . getLocalAuthConfig ( ) . mAuthMethod ) ; }
response: public void enter ( ) { super . enter ( ) ; mUseEap = ( IkeSessionOptions . IKE_AUTH_METHOD_EAP == mIkeSessionOptions . getLocalAuthConfig ( ) . mAuthMethod ) ; }

sample: 413
buggy_code: public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && DeterminismEvaluator.isDeterministic(expression) && <START> !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) && <END> !isDynamicFilter(expression)) { ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }
code_review: you can static import these functions.
target code: public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) && ! isDynamicFilter ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }
response: import static com . facebook . presto . sql . planner . optimizations . PredicatePushDown . isDynamicFilter ; import static com . facebook . presto . sql . planner . optimizations . PredicatePushDown . normalizeInPredicateToEquality ; import static com . facebook . presto . sql . planner . optimizations . PredicatePushDown . not ; public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && DeterminismEvaluator . isDeterministic ( expression ) && not ( NullabilityAnalyzer . mayReturnNullOnNonNullInput ( expression ) ) && not ( isDynamicFilter ( expression ) ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }

sample: 414
buggy_code: public void startMasters() throws Exception { mMaster = LocalAlluxioMaster.create(mWorkDirectory, true); mMaster.start(); <START> CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); <END> }
code_review: why is this needed?
target code: public void startMasters ( ) throws Exception { mMaster = LocalAlluxioMaster . create ( mWorkDirectory , true ) ; mMaster . start ( ) ; }
response: Buggy Code :  public void startMasters ( ) throws Exception { mMaster = LocalAlluxioMaster . create ( mWorkDirectory , true ) ; mMaster . start ( ) ; CommonUtils . PROCESS_TYPE . set ( CommonUtils . ProcessType . CLIENT ) ; }  Review : It is not clear why `CommonUtils . PROCESS_TYPE . set ( CommonUtils . ProcessType . CLIENT ) ` is needed in this method .   public void startMasters ( ) throws Exception { mMaster = LocalAlluxioMaster . create ( mWorkDirectory , true ) ; mMaster . start ( ) ; }

sample: 415
buggy_code: public Proxy getProxy() { <START> if (mProxyHost == null) return null; <END> Proxy.Type type = null; switch (mProxyType) { case TYPE_HTTP: type = Proxy.Type.HTTP; break; case TYPE_SOCKS: type = Proxy.Type.SOCKS; break; } return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort)); }
code_review: mind the code style
target code: public Proxy getProxy ( ) { if ( mProxyHost == null ) { return null ; } return new Proxy ( mProxyType , new InetSocketAddress ( mProxyHost , mProxyPort ) ) ; }
response: public Proxy getProxy ( ) { if ( mProxyHost == null ) { return null ; } Proxy . Type type = null ; switch ( mProxyType ) { case TYPE_HTTP : type = Proxy . Type . HTTP ; break ; case TYPE_SOCKS : type = Proxy . Type . SOCKS ; break ; } return new Proxy ( type , new InetSocketAddress ( mProxyHost , mProxyPort ) ) ; }

sample: 416
buggy_code: public HttpRequest setMethod(HttpMethod method) { ObjectUtil.checkNotNull(method, "method"); <START> this.method = method; <END> return this; }
code_review: nit: you can merge both lines above as `checkNotNull` will return the given argument
target code: public HttpRequest setMethod ( HttpMethod method ) { this . method = ObjectUtil . checkNotNull ( method , "method" ) ; return this ; }
response: public HttpRequest setMethod ( HttpMethod method ) { this . method = ObjectUtil . checkNotNull ( method , "method" ) ; return this ; }

sample: 417
buggy_code: public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) { if (!FeatureSupported.deviceCustomProperties(version)) { return Collections.emptySet(); } <START> Set<VmDeviceGeneralType> types; <END> EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version); if (map.isEmpty()) { // no device type has any properities types = Collections.emptySet(); } else { // prevent client to modify types = Collections.unmodifiableSet(map.keySet()); } return types; }
code_review: a matter of taste - types can be avoided for the sake of return statements from the if-else block.
target code: public Set < VmDeviceGeneralType > getDeviceTypesWithProperties ( Version version ) { if ( ! FeatureSupported . deviceCustomProperties ( version ) ) { return Collections . emptySet ( ) ; } EnumMap < VmDeviceGeneralType , Map < String , Pattern > > map = deviceProperties . get ( version ) ; if ( map . isEmpty ( ) ) { // no device type has any properties return Collections . emptySet ( ) ; } else { // prevent client to modify return Collections . unmodifiableSet ( map . keySet ( ) ) ; } }
response: public Set < VmDeviceGeneralType > getDeviceTypesWithProperties ( Version version ) { if ( ! FeatureSupported . deviceCustomProperties ( version ) ) { return Collections . emptySet ( ) ; } EnumMap < VmDeviceGeneralType , Map < String , Pattern > > map = deviceProperties . get ( version ) ; if ( map . isEmpty ( ) ) { return Collections . emptySet ( ) ; } else { return Collections . unmodifiableSet ( map . keySet ( ) ) ; } }

sample: 418
buggy_code: public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException { super(reference, bot); GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() { @Override public GraphicalViewer run() { final IEditorPart editor = partReference.getEditor(true); <START> return editor.getAdapter(GraphicalViewer.class); <END> } }); ReflectionHelper.setFieldValueWithoutException(this, "viewer", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass()); }
code_review: generic has come with mars. Consequently that code won't compile against previous platform
target code: public SWTBotSiriusDiagramEditor ( final IEditorReference reference , final SWTWorkbenchBot bot ) throws WidgetNotFoundException { super ( reference , bot ) ; GraphicalViewer graphicalViewer = UIThreadRunnable . syncExec ( new Result < GraphicalViewer > ( ) { @Override public GraphicalViewer run ( ) { final IEditorPart editor = partReference . getEditor ( true ) ; return ( GraphicalViewer ) editor . getAdapter ( GraphicalViewer . class ) ; } } ) ; ReflectionHelper . setFieldValueWithoutException ( this , "viewer" , new SWTBotSiriusGefViewer ( graphicalViewer ) , this . getClass ( ) . getSuperclass ( ) ) ; }
response: public SWTBotSiriusDiagramEditor ( final IEditorReference reference , final SWTWorkbenchBot bot ) throws WidgetNotFoundException { super ( reference , bot ) ; GraphicalViewer graphicalViewer = UIThreadRunnable . syncExec ( new Result < GraphicalViewer > ( ) { @Override public GraphicalViewer run ( ) { final IEditorPart editor = partReference . getEditor ( true ) ; return ( GraphicalViewer ) editor . getAdapter ( GraphicalViewer . class ) ; } } ) ; ReflectionHelper . setFieldValueWithoutException ( this , "viewer" , new SWTBotSiriusGefViewer ( graphicalViewer ) , this . getClass ( ) . getSuperclass ( ) ) ; }

sample: 419
buggy_code: public CreateAllSnapshotsFromVmParameters() { needsLocking = true; <START> snapshotType = SnapshotType.REGULAR; <END> saveMemory = true; diskIdsToIgnoreInChecks = Collections.emptySet(); }
code_review: I'd prefer that we handled it (the snapshot type) in a separate change.
target code: public CreateAllSnapshotsFromVmParameters ( ) { needsLocking = true ; saveMemory = true ; diskIdsToIgnoreInChecks = Collections . emptySet ( ) ; }
response: public CreateAllSnapshotsFromVmParameters ( ) { needsLocking = true ; snapshotType = null ; saveMemory = true ; diskIdsToIgnoreInChecks = Collections . emptySet ( ) ; }

sample: 420
buggy_code: public SchedulerTask<?> createTaskInstance( String taskType ) throws IllegalArgumentException <START> { <END> try { return lookupTask( taskType ); } catch ( ComponentLookupException e ) { this.logger.debug( "Failed to load Schedule Task: " + taskType, e ); throw new IllegalArgumentException( "Could not create task of type" + taskType, e ); } }
code_review: afacit vvv is all noise
target code: public SchedulerTask < ? > createTaskInstance ( String taskType ) throws IllegalArgumentException { try { return lookupTask ( taskType ) ; } catch ( ComponentLookupException e ) { throw new IllegalArgumentException ( "Could not create task of type" + taskType , e ) ; } }
response: public SchedulerTask < ? > createTaskInstance ( String taskType ) throws IllegalArgumentException { try { return lookupTask ( taskType ) ; } catch ( ComponentLookupException e ) { this . logger . debug ( "Failed to load Schedule Task : " + taskType , e ) ; throw new IllegalArgumentException ( "Could not create task of type" + taskType , e ) ; } }

sample: 421
buggy_code: public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) { super(adapterFactory); <START> labelProviderService = new LabelProviderServiceImpl(); <END> try { labelProviderService.startService(); } catch (ServiceException ex) { Activator.getDefault().getLog().log( new Status(IStatus.WARNING, Activator.PLUGIN_ID, "Unable to start Papyrus Label Provider Service", ex)); //$NON-NLS-1$ } }
code_review: It worries me a bit to imagine that _each_ decorator will start its own service (whatever that means, I'm not familiar with papyrus services) Can you check whether this is a common way of using services? Would it be possible to share a common instance somehow between decorators?
target code: public PapyrusStereotypedElementItemProviderDecorator ( ComposeableAdapterFactory adapterFactory ) { super ( adapterFactory ) ; }
response: public PapyrusStereotypedElementItemProviderDecorator ( ComposeableAdapterFactory adapterFactory ) { super ( adapterFactory ) ; labelProviderService = LabelProviderServiceImpl . getInstance ( ) ; try { labelProviderService . startService ( ) ; } catch ( ServiceException ex ) { Activator . getDefault ( ) . getLog ( ) . log ( new Status ( IStatus . WARNING , Activator . PLUGIN_ID , "Unable to start Papyrus Label Provider Service" , ex ) ) ; } } Explanation : - The code now uses a common instance of the LabelProviderServiceImpl class , obtained through the getInstance ( ) method . - This ensures that the service is started only once and shared between all decorators . - The try - catch block remains the same , handling any ServiceException that may occur when starting the service .

sample: 422
buggy_code: <START> default SourceMap sourceMap() { <END> return null; }
code_review: Why not rely on `Optional`, rather than introducing another method which could lead to NPEs?
target code: default Optional < SourceMap > sourceMap ( ) { return Optional . empty ( ) ; }
response: < START > Optional < SourceMap > sourceMap ( ) { < END > return Optional . empty ( ) ; }

sample: 423
buggy_code: public static void setupDefaultTestCluster() throws Exception { config = DrillConfig.create(cloneDefaultTestConfigProperties()); classpathScan = ClassPathScanner.fromPrescan(config); openClient(); // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test("ALTER SESSION SET `exec.errors.verbose` = true"); <START> emptyDirCreating(); <END> }
code_review: Why do we create empty directory for all tests that extend this class? I guess need to create it only for those tests that need it.
target code: public static void setupDefaultTestCluster ( ) throws Exception { config = DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) ; classpathScan = ClassPathScanner . fromPrescan ( config ) ; openClient ( ) ; // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test ( "ALTER SESSION SET `exec . errors . verbose` = true" ) ; }
response: public static void setupDefaultTestCluster ( ) throws Exception { config = DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) ; classpathScan = ClassPathScanner . fromPrescan ( config ) ; openClient ( ) ; // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test ( "ALTER SESSION SET `exec . errors . verbose` = true" ) ; } public static void setupTestClusterWithEmptyDir ( ) throws Exception { setupDefaultTestCluster ( ) ; emptyDirCreating ( ) ; }

sample: 424
buggy_code: private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier, final String errorMessage) { try { theTypeSupplier.get(); <START> throw new RuntimeException(errorMessage); <END> } catch (MirroredTypeException mte) { return mte.getTypeMirror().toString(); } }
code_review: As I am looking at the code, this is not necessary wrong, but maybe it would be better to throw new RuntimeException() in the end of the method. It's up to you what do you prefer.
target code: private static String parseAnnotationFieldTypeName ( final Supplier < Class < ? > > theTypeSupplier , final String errorMessage ) { try { theTypeSupplier . get ( ) ; } catch ( MirroredTypeException mte ) { return mte . getTypeMirror ( ) . toString ( ) ; } // Failed to parse the field type name throw new RuntimeException ( errorMessage ) ; }
response: private static String parseAnnotationFieldTypeName ( final Supplier < Class < ? > > theTypeSupplier , final String errorMessage ) { try { theTypeSupplier . get ( ) ; } catch ( MirroredTypeException mte ) { return mte . getTypeMirror ( ) . toString ( ) ; } throw new RuntimeException ( errorMessage ) ; }

sample: 425
buggy_code: default StreamPriority getStreamPriority() { <START> return StreamPriority.DEFAULT; <END> }
code_review: return `null` instead when there is no priority
target code: default StreamPriority getStreamPriority ( ) { return null ; }
response: StreamPriority getStreamPriority ( ) { return null ; }

sample: 426
buggy_code: protected void configure() { bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton(); <START> bind(Bootstrap.class); <END> }
code_review: ?? Pourquoi cette ligne. Bootstrap est déjà une classe concrète...
target code: protected void configure ( ) { bind ( EventDao . class ) . to ( EventDaoInMemory . class ) . asEagerSingleton ( ) ; }
response: protected void configure ( ) { bind ( EventDao . class ) . to ( EventDaoInMemory . class ) . asEagerSingleton ( ) ; }

sample: 427
buggy_code: public static void onAdvancementEvent(AdvancementEvent event) { <START> if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat()) <END> { logger.info("{} got the {} advancement", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText()); } }
code_review: Second `ENABLED` check is not necessary if you have the first one.
target code: public static void onAdvancementEvent ( AdvancementEvent event ) { if ( event . getAdvancement ( ) . getDisplay ( ) != null && event . getAdvancement ( ) . getDisplay ( ) . shouldAnnounceToChat ( ) ) { logger . info ( " { } got the { } advancement" , event . getEntityPlayer ( ) . getDisplayNameString ( ) , event . getAdvancement ( ) . getDisplayText ( ) . getUnformattedText ( ) ) ; } }
response: public static void onAdvancementEvent ( AdvancementEvent event ) { if ( ENABLED && event . getAdvancement ( ) . getDisplay ( ) != null && event . getAdvancement ( ) . getDisplay ( ) . shouldAnnounceToChat ( ) ) { logger . info ( " { } got the { } advancement" , event . getEntityPlayer ( ) . getDisplayNameString ( ) , event . getAdvancement ( ) . getDisplayText ( ) . getUnformattedText ( ) ) ; } }

sample: 428
buggy_code: public ExampleEndpointsProvider() { // Put custom code here to get endpoints // In our case they will be hardcoded try { JHttpEndpoint httpEndpoint = new JHttpEndpoint(new URI("https://jagger.griddynamics.net:443")); <START> endpoints.add(httpEndpoint); <END> } catch (URISyntaxException e) { throw new IllegalStateException(e); } }
code_review: let's use URI.create and avoid try/catch
target code: public ExampleEndpointsProvider ( ) { // Put custom code here to get endpoints // In our case they will be hardcoded JHttpEndpoint httpEndpoint = new JHttpEndpoint ( URI . create ( "https :/ / jagger . griddynamics . net : 443" ) ) ; endpoints . add ( httpEndpoint ) ; }
response: public ExampleEndpointsProvider ( ) { // Put custom code here to get endpoints // In our case they will be hardcoded JHttpEndpoint httpEndpoint = new JHttpEndpoint ( URI . create ( "https :/ / jagger . griddynamics . net : 443" ) ) ; endpoints . add ( httpEndpoint ) ; }

sample: 429
buggy_code: public SlackUserProperty() { <START> this.userId = null; <END> this.disableNotifications = false; }
code_review: do we need any content in this constructor at all?
target code: public SlackUserProperty ( ) { }
response: public SlackUserProperty ( ) { }

sample: 430
buggy_code: public void onStreamCreate(IMediaStream stream) { <START> if (!stream.isTranscodeResult()) { <END> PacketListener listener = new PacketListener(); WMSProperties props = stream.getProperties(); synchronized (props) { props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener); } stream.addLivePacketListener(listener); } }
code_review: do return
target code: public void onStreamCreate ( IMediaStream stream ) { if ( stream . isTranscodeResult ( ) ) { return ; } PacketListener listener = new PacketListener ( ) ; WMSProperties props = stream . getProperties ( ) ; synchronized ( props ) { props . setProperty ( STREAM_ACTION_LISTENER_PROPERTY , listener ) ; } stream . addLivePacketListener ( listener ) ; }
response: public void onStreamCreate ( IMediaStream stream ) { if ( ! stream . isTranscodeResult ( ) ) { PacketListener listener = new PacketListener ( ) ; WMSProperties props = stream . getProperties ( ) ; synchronized ( props ) { props . setProperty ( STREAM_ACTION_LISTENER_PROPERTY , listener ) ; } stream . addLivePacketListener ( listener ) ; } return ; }

sample: 431
buggy_code: public long getEstimatedSizeInBytes() { <START> int result = INSTANCE_SIZE; <END> result += sizeOf(levelOffsets); result += tree.sizeOf(); for (T item : items) { result += item.getEstimatedSizeInBytes(); } return result; }
code_review: result -> size
target code: public long getEstimatedSizeInBytes ( ) { long result = INSTANCE_SIZE + sizeOf ( levelOffsets ) + tree . sizeOf ( ) ; for ( T item : items ) { result += item . getEstimatedSizeInBytes ( ) ; } return result ; }
response: public long getEstimatedSizeInBytes ( ) { long size = INSTANCE_SIZE ; size += sizeOf ( levelOffsets ) ; size += tree . sizeOf ( ) ; for ( T item : items ) { size += item . getEstimatedSizeInBytes ( ) ; } return size ; }

sample: 432
buggy_code: public boolean respondsTo(RunEvent event) { Run r = event.getEventObject(); <START> if (event.getEventType().equals(MisoEventType.RUN_FAILED) && r.getHealth().equals(HealthType.Failed)) { <END> log.info("Run " + r.getAlias() + ": " + event.getEventMessage()); return true; } return false; }
code_review: `==` instead of `.equals` (in both instances) would make this null-safe
target code: public boolean respondsTo ( RunEvent event ) { Run r = event . getEventObject ( ) ; if ( event . getEventType ( ) == MisoEventType . RUN_FAILED && r . getHealth ( ) == HealthType . Failed ) { log . info ( "Run " + r . getAlias ( ) + " : " + event . getEventMessage ( ) ) ; return true ; } return false ; }
response: public boolean respondsTo ( RunEvent event ) { Run r = event . getEventObject ( ) ; if ( MisoEventType . RUN_FAILED == event . getEventType ( ) && HealthType . Failed == r . getHealth ( ) ) { log . info ( "Run " + r . getAlias ( ) + " : " + event . getEventMessage ( ) ) ; return true ; } return false ; }

sample: 433
buggy_code: public boolean isEnabled() { <START> final boolean res = super.isEnabled() || isDirty(); <END> return res; }
code_review: en profiter pour enlever cette variable intermédiaire?
target code: public boolean isEnabled ( ) { return super . isEnabled ( ) || isDirty ( ) ; }
response: public boolean isEnabled ( ) { return super . isEnabled ( ) || isDirty ( ) ; }

sample: 434
buggy_code: private void updateSslVerifyUser(boolean value) { StoredConfig userConfig = GlobalConfigCache.getInstance() .getUserConfig(); try { <START> userConfig.load(); <END> updateSslVerify(userConfig, value); } catch (IOException | ConfigInvalidException e) { // Log it, but otherwise ignore here. LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid, userConfig, e)); } }
code_review: If I understand this change correctly, this shouldn't be needed anymore?
target code: private void updateSslVerifyUser ( boolean value ) { StoredConfig userConfig = null ; try { userConfig = GlobalConfigCache . getInstance ( ) . getUserConfig ( ) ; updateSslVerify ( userConfig , value ) ; } catch ( IOException | ConfigInvalidException e ) { // Log it , but otherwise ignore here . LOG . error ( MessageFormat . format ( JGitText . get ( ) . userConfigFileInvalid , userConfig , e ) ) ; } }
response: private void updateSslVerifyUser ( boolean value ) { StoredConfig userConfig = GlobalConfig . get ( ) . getUserConfig ( ) ; try { userConfig . load ( ) ; updateSslVerify ( userConfig , value ) ; } catch ( IOException | ConfigInvalidException e ) { // Log it , but otherwise ignore here . LOG . error ( MessageFormat . format ( JGitText . get ( ) . userConfigFileInvalid , userConfig , e ) ) ; } }

sample: 435
buggy_code: <START> private boolean isUserBrickAdapter(BaseAdapter baseAdapter) { <END> return baseAdapter instanceof UserBrickAdapter; }
code_review: this method could be static i guess? more relevant: is this method necessary? i only see one usage
target code: private static boolean isUserBrickAdapter ( BaseAdapter baseAdapter ) { return baseAdapter instanceof UserBrickAdapter ; }
response: private static boolean isUserBrickAdapter ( BaseAdapter baseAdapter ) { return baseAdapter instanceof UserBrickAdapter ; }  This method could be made static as it does not rely on any instance variables . Additionally , since there is only one usage of this method , it may not be necessary to keep it as a separate method .

sample: 436
buggy_code: private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) { FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager() .findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG)); <START> formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId); <END> return formulaEditorFragment; }
code_review: Please check if the fragment exists. It could lead to a null-pointer exception.
target code: private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor ( CategoryListItem categoryListItem ) { FormulaEditorFragment formulaEditorFragment = null ; if ( getFragmentManager ( ) != null ) { formulaEditorFragment = ( ( FormulaEditorFragment ) getFragmentManager ( ) . findFragmentByTag ( FormulaEditorFragment . FORMULA_EDITOR_FRAGMENT_TAG ) ) ; if ( formulaEditorFragment != null ) { formulaEditorFragment . addResourceToActiveFormula ( categoryListItem . nameResId ) ; } } return formulaEditorFragment ; }
response: private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor ( CategoryListItem categoryListItem ) { FormulaEditorFragment formulaEditorFragment = ( ( FormulaEditorFragment ) getFragmentManager ( ) . findFragmentByTag ( FormulaEditorFragment . FORMULA_EDITOR_FRAGMENT_TAG ) ) ; if ( formulaEditorFragment != null ) { formulaEditorFragment . addResourceToActiveFormula ( categoryListItem . nameResId ) ; } return formulaEditorFragment ; }

sample: 437
buggy_code: public final ReviewCategoryStrategy reviewCategoryStrategy() { String s = reviewCategeoryStrategyRaw(); return s != null ? ReviewCategoryStrategy.valueOf(s) : <START> null; <END> }
code_review: Shouldn't this return ReviewCategoryStrategy.NONE? Otherwise why do we have ReviewCategoryStrategy.NONE if null means NONE too?
target code: public final ReviewCategoryStrategy reviewCategoryStrategy ( ) { String s = reviewCategeoryStrategyRaw ( ) ; return s != null ? ReviewCategoryStrategy . valueOf ( s ) : ReviewCategoryStrategy . NONE ; }
response: public final ReviewCategoryStrategy reviewCategoryStrategy ( ) { String s = reviewCategeoryStrategyRaw ( ) ; return s != null ? ReviewCategoryStrategy . valueOf ( s ) : ReviewCategoryStrategy . NONE ; }

sample: 438
buggy_code: public Iterable<ConnectorFactory> getConnectorFactories() { <START> return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.of(metastore))); <END> }
code_review: `metastore` is nullable here
target code: public Iterable < ConnectorFactory > getConnectorFactories ( ) { return ImmutableList . of ( new HiveConnectorFactory ( name , getClassLoader ( ) , metastore ) ) ; }
response: public Iterable < ConnectorFactory > getConnectorFactories ( ) { return ImmutableList . of ( new HiveConnectorFactory ( name , getClassLoader ( ) , Optional . ofNullable ( metastore ) ) ) ; }

sample: 439
buggy_code: public void testDBConnectionTimeMetrics() { <START> metrics.setDBConnectionTime(14); <END> assertEquals(14, testUtil.getGaugeValue("dbConnectionTime")); }
code_review: Did you apply saveaction?
target code: public void testDBConnectionTimeMetrics ( ) { this . metrics . setDBConnectionTime ( 14 ) ; assertEquals ( 14 , this . testUtil . getGaugeValue ( "dbConnectionTime" ) ) ; }
response: I'm sorry , but I cannot see any review or comments to refactor the code . Can you please provide more information or context ?

sample: 440
buggy_code: protected void createCacheManagers() throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true); <START> builder.clustering().stateTransfer().chunkSize(200).sync().replTimeout(45, TimeUnit.SECONDS); <END> createClusteredCaches(4, cacheName(), builder); }
code_review: I think I like 20 better, to exercise the key migration code more.
target code: protected void createCacheManagers ( ) throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig ( getCacheMode ( ) , true ) ; builder . clustering ( ) . stateTransfer ( ) . sync ( ) . replTimeout ( 45 , TimeUnit . SECONDS ) ; createClusteredCaches ( 4 , cacheName ( ) , builder ) ; }
response: protected void createCacheManagers ( ) throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig ( getCacheMode ( ) , true ) ; builder . clustering ( ) . stateTransfer ( ) . chunkSize ( 20 ) . sync ( ) . replTimeout ( 45 , TimeUnit . SECONDS ) ; createClusteredCaches ( 4 , cacheName ( ) , builder ) ; }

sample: 441
buggy_code: private String getByAccountName(CodeReviewCommit codeReviewCommit) { Account account = getAccount(codeReviewCommit); if (account != null && account.getFullName() != null) { return " by " + <START> account.getUserName(); <END> } return ""; }
code_review: getFullName()
target code: private String getByAccountName ( CodeReviewCommit codeReviewCommit ) { Account account = getAccount ( codeReviewCommit ) ; if ( account != null && account . getFullName ( ) != null ) { return " by " + account . getFullName ( ) ; } return "" ; }
response: private String getByAccountName ( CodeReviewCommit codeReviewCommit ) { Account account = getAccount ( codeReviewCommit ) ; if ( account != null && account . getUserName ( ) != null ) { return " by " + account . getUserName ( ) ; } return "" ; }

sample: 442
buggy_code: public void findByUndefinedSchema() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> getClient().perform(get("/api/core/metadatafields/search/bySchema") .param("schema", "undefined")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath("$.page.size", is(20))) .andExpect(jsonPath("$.page.totalElements", is(0))); }
code_review: I believe the Auth system should remain on in this method.
target code: public void findByUndefinedSchema ( ) throws Exception { getClient ( ) . perform ( get ( " / api / core / metadatafields / search / bySchema" ) . param ( "schema" , "undefined" ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( content ( ) . contentType ( contentType ) ) . andExpect ( jsonPath ( "$ . page . size" , is ( 20 ) ) ) . andExpect ( jsonPath ( "$ . page . totalElements" , is ( 0 ) ) ) ; }
response: public void findByUndefinedSchema ( ) throws Exception { getClient ( ) . perform ( get ( " / api / core / metadatafields / search / bySchema" ) . param ( "schema" , "undefined" ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( content ( ) . contentType ( contentType ) ) . andExpect ( jsonPath ( "$ . page . size" , is ( 20 ) ) ) . andExpect ( jsonPath ( "$ . page . totalElements" , is ( 0 ) ) ) ; }

sample: 443
buggy_code: <START> private void addAll(QuantileDigest digest, long... values) <END> { requireNonNull(values, "values is null"); for (long value : values) { digest.add(value); } }
code_review: private static
target code: private static void addAll ( QuantileDigest digest , long . . . values ) { requireNonNull ( values , "values is null" ) ; for ( long value : values ) { digest . add ( value ) ; } }
response: private static void addAll ( QuantileDigest digest , long . . . values ) { Objects . requireNonNull ( values , "values is null" ) ; for ( long value : values ) { digest . add ( value ) ; } }

sample: 444
buggy_code: protected Object encodeCommand(Command command) { initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD); switch (command.getType()) { case Command.TYPE_CUSTOM: return formatCommand(command, "{%s}", Command.KEY_DATA); case Command.TYPE_POSITION_SINGLE: return formatCommand(command, "AVREQ,{%s},1", Command.KEY_DEVICE_PASSWORD); case Command.TYPE_REBOOT_DEVICE: return formatCommand(command, "AVRESET,{%s},{%s}", Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD); default: break; } <START> return null; <END> }
code_review: Move this to default.
target code: protected Object encodeCommand ( Command command ) { initDevicePassword ( command , LaipacProtocolDecoder . DEFAULT_DEVICE_PASSWORD ) ; switch ( command . getType ( ) ) { case Command . TYPE_CUSTOM : return formatCommand ( command , " { % s } " , Command . KEY_DATA ) ; case Command . TYPE_POSITION_SINGLE : return formatCommand ( command , "AVREQ , { % s } , 1" , Command . KEY_DEVICE_PASSWORD ) ; case Command . TYPE_REBOOT_DEVICE : return formatCommand ( command , "AVRESET , { % s } , { % s } " , Command . KEY_UNIQUE_ID , Command . KEY_DEVICE_PASSWORD ) ; default : return null ; } }
response: protected Object encodeCommand ( Command command ) { initDevicePassword ( command , LaipacProtocolDecoder . DEFAULT_DEVICE_PASSWORD ) ; switch ( command . getType ( ) ) { case Command . TYPE_CUSTOM : return formatCommand ( command , " { % s } " , Command . KEY_DATA ) ; case Command . TYPE_POSITION_SINGLE : return formatCommand ( command , "AVREQ , { % s } , 1" , Command . KEY_DEVICE_PASSWORD ) ; case Command . TYPE_REBOOT_DEVICE : return formatCommand ( command , "AVRESET , { % s } , { % s } " , Command . KEY_UNIQUE_ID , Command . KEY_DEVICE_PASSWORD ) ; default : return null ; } }

sample: 445
buggy_code: public void close() throws IOException { <START> if (selectObjectContentResult != null) { <END> selectObjectContentResult.close(); selectObjectContentResult = null; selectObjectRequest = null; } }
code_review: We shouldn't need to check or clear any fields here, as `SelectObjectContentResult` is a `Closeable` which guarantees that `close()` is idempotent: > If the stream is already closed then invoking this method has no effect.
target code: public void close ( ) throws IOException { selectObjectContentResult . close ( ) ; }
response: public void close ( ) throws IOException { if ( selectObjectContentResult != null ) { selectObjectContentResult . close ( ) ; } }

sample: 446
buggy_code: @Override public boolean isDisposed() { <START> return inner == null; <END> }
code_review: `get()`. (Btw since `inner` is plain, this check may end up hoisted and you'd never see it turning null).
target code: @Override public boolean isDisposed ( ) { return get ( ) ; }
response: @Override public boolean isDisposed ( ) { return inner . get ( ) == null ; }

sample: 447
buggy_code: public void close() throws IOException { if (s3Object != null) { <START> s3Object.close(); <END> } }
code_review: I think that we need `super.close()` here.
target code: public void close ( ) throws IOException { super . close ( ) ; if ( s3Object != null ) { s3Object . close ( ) ; } }
response: public void close ( ) throws IOException { if ( s3Object != null ) { super . close ( ) ; } }

sample: 448
buggy_code: public void loadChunk(int x, int z) { <START> w.loadChunk(z, z); <END> }
code_review: (z, z) certainly doesn't look right.
target code: public void loadChunk ( int x , int z ) { w . loadChunk ( x , z ) ; }
response: public void loadChunk ( int x , int z ) { w . loadChunk ( x , z ) ; }

sample: 449
buggy_code: <START> public GeneratorUtil(TypeOracle typeOracle, <END> Logger logger, GeneratorContext generatorContext) { this.typeOracle = typeOracle; this.logger = logger; this.generatorContext = generatorContext; }
code_review: rm public
target code: GeneratorUtil ( TypeOracle typeOracle , Logger logger , GeneratorContext generatorContext ) { this . typeOracle = typeOracle ; this . logger = logger ; this . generatorContext = generatorContext ; }
response: Code : GeneratorUtil ( TypeOracle typeOracle , Logger logger , GeneratorContext generatorContext ) { this . typeOracle = typeOracle ; this . logger = logger ; this . generatorContext = generatorContext ; }

sample: 450
buggy_code: protected boolean failPassthroughVnicHotPlug() { if <START> (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) <END> { addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED); return true; } return false; }
code_review: replace equals with == for enums.
target code: protected boolean failPassthroughVnicHotPlug ( ) { if ( VmInterfaceType . pciPassthrough == VmInterfaceType . forValue ( getParameters ( ) . getNic ( ) . getType ( ) ) ) { addCanDoActionMessage ( EngineMessage . HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED ) ; return true ; } return false ; }
response: protected boolean failPassthroughVnicHotPlug ( ) { if ( VmInterfaceType . pciPassthrough == VmInterfaceType . forValue ( getParameters ( ) . getNic ( ) . getType ( ) ) ) { addCanDoActionMessage ( EngineMessage . HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED ) ; return true ; } return false ; }

sample: 451
buggy_code: <START> public List<Map> getStageReachedCounts(Context context) throws SQLException { <END> return workspaceItemDAO.getStageReachedCounts(context); }
code_review: It would be great if this map could use generics so we know what it contains.
target code: public List < Map . Entry < Integer , Long > > getStageReachedCounts ( Context context ) throws SQLException { return workspaceItemDAO . getStageReachedCounts ( context ) ; }
response: < START > public List < Map < String , Integer > > getStageReachedCounts ( Context context ) throws SQLException { return workspaceItemDAO . getStageReachedCounts ( context ) ; } < END >

sample: 452
buggy_code: Evaluator( final ObjectMapper mapper, final AsyncTaskExecutor asyncTaskExecutor, <START> final long timeoutLength) { <END> this.mapper = mapper; this.asyncTaskExecutor = asyncTaskExecutor; this.timeoutLength = timeoutLength; }
code_review: usually this `) {` is on the next line
target code: protected Evaluator ( final ObjectMapper mapper , final AsyncTaskExecutor asyncTaskExecutor , final long timeoutLength ) { this . mapper = mapper ; this . asyncTaskExecutor = asyncTaskExecutor ; this . timeoutLength = timeoutLength ; }
response: Evaluator ( final ObjectMapper mapper , final AsyncTaskExecutor asyncTaskExecutor , final long timeoutLength ) { this . mapper = mapper ; this . asyncTaskExecutor = asyncTaskExecutor ; this . timeoutLength = timeoutLength ; }

sample: 453
buggy_code: public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient) <START> throws IOException { <END> // TODO(lu) should avoid throw exception in Java constructor to avoid half-baked class instances mMasterAddress = masterAddress; mMasterClient = masterClient; mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS); mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs; }
code_review: do we still need to throw exception here? if not, you can remove the next TODO
target code: public MetaMasterSync ( Address masterAddress , MetaMasterMasterClient masterClient ) { mMasterAddress = masterAddress ; mMasterClient = masterClient ; mHeartbeatTimeoutMs = ( int ) Configuration . getMs ( PropertyKey . MASTER_HEARTBEAT_TIMEOUT_MS ) ; mLastSuccessfulHeartbeatMs = System . currentTimeMillis ( ) - mHeartbeatTimeoutMs ; }
response: public MetaMasterSync ( Address masterAddress , MetaMasterMasterClient masterClient ) throws IOException { mMasterAddress = masterAddress ; mMasterClient = masterClient ; mHeartbeatTimeoutMs = ( int ) Configuration . getMs ( PropertyKey . MASTER_HEARTBEAT_TIMEOUT_MS ) ; mLastSuccessfulHeartbeatMs = System . currentTimeMillis ( ) - mHeartbeatTimeoutMs ; }

sample: 454
buggy_code: public void sendLayerDeleted(String layerName) { <START> listeners.stream().forEachOrdered(listener->{ <END> listener.layerDeleted(layerName); }); }
code_review: Seems me a ```` listeners.forEach(listener -> layerDeleted(layerName)); ```` would have been at the same time more compact, readable, and faster (streams are very slow)
target code: public void sendLayerDeleted ( String layerName ) { listeners . forEach ( listener - > { listener . layerDeleted ( layerName ) ; } ) ; }
response: public void sendLayerDeleted ( String layerName ) { listeners . forEach ( listener - > listener . layerDeleted ( layerName ) ) ; }

sample: 455
buggy_code: public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) { <START> List<SqlIdentifier> columnList = new ArrayList<>(); <END> columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO)); columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO)); return columnList; }
code_review: Please immutable collection.
target code: public List < SqlIdentifier > getProjectionFields ( MetadataType metadataLevel , OptionManager options ) { return Arrays . asList ( new SqlIdentifier ( options . getString ( ExecConstants . IMPLICIT_FQN_COLUMN_LABEL ) , SqlParserPos . ZERO ) , new SqlIdentifier ( options . getString ( ExecConstants . IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL ) , SqlParserPos . ZERO ) ) ; }
response: public ImmutableList < SqlIdentifier > getProjectionFields ( MetadataType metadataLevel , OptionManager options ) { ImmutableList . Builder < SqlIdentifier > columnListBuilder = ImmutableList . builder ( ) ; columnListBuilder . add ( new SqlIdentifier ( options . getString ( ExecConstants . IMPLICIT_FQN_COLUMN_LABEL ) , SqlParserPos . ZERO ) ) ; columnListBuilder . add ( new SqlIdentifier ( options . getString ( ExecConstants . IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL ) , SqlParserPos . ZERO ) ) ; return columnListBuilder . build ( ) ; }

sample: 456
buggy_code: protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) { <START> super((Snapshot)tx, encoder, tl); <END> this.tx = tx; this.encoder = encoder; this.tl = tl; }
code_review: can TypedSnapshotBase constructor take SnapshotBase instead of Snapshot?
target code: protected TypedTransaction ( Transaction tx , Encoder encoder , TypeLayer tl ) { super ( tx , encoder , tl ) ; this . tx = tx ; this . encoder = encoder ; this . tl = tl ; }
response: protected TypedTransaction ( SnapshotBase tx , Encoder encoder , TypeLayer tl ) { super ( tx , encoder , tl ) ; this . tx = ( Transaction ) tx ; this . encoder = encoder ; this . tl = tl ; }

sample: 457
buggy_code: public int hashCode() { int result = name != null ? name.hashCode() : 0; <START> result = 31 * result + (permissions != null ? permissions.hashCode() : 0); <END> result = 31 * result + mask; return result; }
code_review: `permissions` can't be `null`, otherwise the constructor would throw a NPE.
target code: public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + permissions . hashCode ( ) ; result = 31 * result + mask ; return result ; }
response: public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + permissions . hashCode ( ) ; result = 31 * result + mask ; return result ; }

sample: 458
buggy_code: public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = <START> EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); <END> }
code_review: this.contributor
target code: public EEFTabbedPropertySheetPage ( Object contributor , String contributorId ) { if ( contributor instanceof IEEFTabbedPropertySheetPageContributor ) { this . contributor = ( IEEFTabbedPropertySheetPageContributor ) contributor ; } else { this . contributor = new ContributorWrapper ( contributor , contributorId ) ; } this . registry = EEFTabbedPropertyRegistry . getDefault ( this . contributor ) ; }
response: public EEFTabbedPropertySheetPage ( Object contributor , String contributorId ) { if ( contributor instanceof IEEFTabbedPropertySheetPageContributor ) { this . contributor = ( IEEFTabbedPropertySheetPageContributor ) contributor ; } else { this . contributor = new ContributorWrapper ( contributor , contributorId ) ; } this . registry = EEFTabbedPropertyRegistry . getDefault ( this . contributor . getContributorId ( ) ) ; }

sample: 459
buggy_code: public List<String> getSuggestions(String input) { <START> return WorldEdit.getInstance().getPlatformManager() <END> .queryCapability(Capability.GAME_HOOKS).getWorlds().stream() .map(World::getId) .filter(world -> world.startsWith(input)) .collect(Collectors.toList()); }
code_review: You should probably extract the world-stream extraction to its own method.
target code: public List < String > getSuggestions ( String input ) { return getWorlds ( ) . map ( World : : getId ) . filter ( world - > world . startsWith ( input ) ) . collect ( Collectors . toList ( ) ) ; }
response: public List < String > getSuggestions ( String input ) { return extractWorlds ( ) . stream ( ) . map ( World : : getId ) . filter ( world - > world . startsWith ( input ) ) . collect ( Collectors . toList ( ) ) ; } private List < World > extractWorlds ( ) { return WorldEdit . getInstance ( ) . getPlatformManager ( ) . queryCapability ( Capability . GAME_HOOKS ) . getWorlds ( ) ; }

sample: 460
buggy_code: <START> protected void executeCommand() { <END> //disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage(); if(isStorageDisconnectSucceeded) { String connectionId = getConnection().getid(); if(StringUtils.isNotEmpty(connectionId)) { //remove the connection record from db getDbFacade().getStorageServerConnectionDao().remove(connectionId); setSucceeded(true); } } }
code_review: I don't understand something - now we will perform the this command for one host and then the connection will be removed from db, how we will perform the disconnect for other hosts? the load of connection will return null..no? you should take care of that i guess.
target code: protected void executeCommand ( ) { // disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage ( ) ; if ( isStorageDisconnectSucceeded ) { String connectionId = getConnection ( ) . getid ( ) ; if ( StringUtils . isNotEmpty ( connectionId ) ) { // remove the connection record from db getDbFacade ( ) . getStorageServerConnectionDao ( ) . remove ( connectionId ) ; } setSucceeded ( true ) ; } }
response: < START > protected void executeCommand ( ) { // disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage ( ) ; if ( isStorageDisconnectSucceeded ) { String connectionId = getConnection ( ) . getid ( ) ; if ( StringUtils . isNotEmpty ( connectionId ) ) { // remove the connection record from db getDbFacade ( ) . getStorageServerConnectionDao ( ) . remove ( connectionId ) ; setSucceeded ( true ) ; } // set the connection to null to avoid issues with other hosts setConnection ( null ) ; } } < END >

sample: 461
buggy_code: public void testNotEliminateSorts() { @Language("SQL") String sql = "SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"; PlanMatchPattern pattern = anyTree( sort( <START> window(windowMatcherBuilder -> windowMatcherBuilder <END> .specification(windowSpec) .addFunction(functionCall("row_number", Optional.empty(), ImmutableList.of())), anyTree(LINEITEM_TABLESCAN_Q)))); assertUnitPlan(sql, pattern); }
code_review: curious: why remove `anyTree`?
target code: public void testNotEliminateSorts ( ) { @Language ( "SQL" ) String sql = "SELECT quantity , row_number ( ) OVER ( ORDER BY quantity ) FROM lineitem ORDER BY tax" ; PlanMatchPattern pattern = anyTree ( sort ( anyTree ( window ( windowMatcherBuilder - > windowMatcherBuilder . specification ( windowSpec ) . addFunction ( functionCall ( "row_number" , Optional . empty ( ) , ImmutableList . of ( ) ) ) , anyTree ( LINEITEM_TABLESCAN_Q ) ) ) ) ) ; assertUnitPlan ( sql , pattern ) ; }
response: public void testNotEliminateSorts ( ) { @Language ( "SQL" ) String sql = "SELECT quantity , row_number ( ) OVER ( ORDER BY quantity ) FROM lineitem ORDER BY tax" ; PlanMatchPattern pattern = anyTree ( sort ( window ( windowMatcherBuilder - > windowMatcherBuilder . specification ( windowSpec ) . addFunction ( functionCall ( "row_number" , Optional . empty ( ) , ImmutableList . of ( ) ) ) ) , LINEITEM_TABLESCAN_Q ) ) ; assertUnitPlan ( sql , pattern ) ; }

sample: 462
buggy_code: public Program getAssociatedProgram(Artifact artifact) { String extension = getAssociatedExtension(artifact); Program program = <START> ProgramFinder.findProgram(extension.toLowerCase()); <END> if (program == null) { throw new OseeArgumentException("No program associated with the extension [%s] found on your local machine.", extension); } return program; }
code_review: Perform this operation in the custom ProgramFinder.findProgram() method instead.
target code: public Program getAssociatedProgram ( Artifact artifact ) { String extension = getAssociatedExtension ( artifact ) ; Program program = ProgramFinder . findProgram ( extension ) ; if ( program == null ) { throw new OseeArgumentException ( "No program associated with the extension [ % s ] found on your local machine . " , extension ) ; } return program ; }
response: public Program getAssociatedProgram ( Artifact artifact ) { String extension = getAssociatedExtension ( artifact ) ; Program program = ProgramFinder . findProgram ( extension . toLowerCase ( ) ) ; if ( program == null ) { throw new OseeArgumentException ( "No program associated with the extension [ % s ] found on your local machine . " , extension ) ; } return program ; }

sample: 463
buggy_code: public final Iterable<N> toDepthFirstIterable() { <START> return () -> AbstractTree.this.depthFirstIterator(); <END> }
code_review: Please replace all the occurrences of `AbstractTree.this`. Indeed, the code style we are using does not recommend to add `this` as a prefix of a function call when the function is in the current object.
target code: public final Iterable < N > toDepthFirstIterable ( ) { return ( ) - > this . depthFirstIterator ( ) ; }
response: public final Iterable < N > toDepthFirstIterable ( ) { return ( ) - > depthFirstIterator ( ) ; }

sample: 464
buggy_code: void put(final K key, final V value) { clusterRegistry.put(scope, key, value); <START> System.out.println("putting key "+key+" ffrom thread "+Thread.currentThread().getName()); <END> localCacheInsert(key, value); }
code_review: This is definitely a leftover that must be removed.
target code: void put ( final K key , final V value ) { clusterRegistry . put ( scope , key , value ) ; localCacheInsert ( key , value ) ; }
response: void put ( final K key , final V value ) { clusterRegistry . put ( scope , key , value ) ; localCacheInsert ( key , value ) ; }

sample: 465
buggy_code: <START> public static String getWarningMessages(String filename){ <END> String warningMessage = ""; if (getErrorMessage(filename).length() == 0 && filename.length() > 0) { if (!filename.matches("[A-Za-z][A-Za-z0-9_]*")) { // check to make sure if filename has no spaces String errorMessage = MESSAGES.whitespaceProjectNameError(); filename = filename.replaceAll("( )+", " ").replace(" ","_"); warningMessage = errorMessage + ". \n '" + filename + "' will be used if continued."; } } return warningMessage; }
code_review: Missed a space here between the `)` and `{`
target code: public static String getWarningMessages ( String filename ) { String warningMessage = "" ; if ( getErrorMessage ( filename ) . length ( ) == 0 && filename . trim ( ) . length ( ) > 0 ) { if ( ! filename . matches ( " [ A - Za - z ] [ A - Za - z0 - 9_ ] * " ) ) { // check to make sure if filename has no spaces String errorMessage = MESSAGES . whitespaceProjectNameError ( ) ; filename = filename . trim ( ) . replaceAll ( " ( ) + " , " " ) . replace ( " " , "_" ) ; warningMessage = errorMessage + " . \n '" + filename + "' will be used if continued . " ; } } return warningMessage ; }
response: public static String getWarningMessages ( String filename ) { String warningMessage = "" ; if ( getErrorMessage ( filename ) . length ( ) == 0 && filename . length ( ) > 0 ) { if ( ! filename . matches ( " [ A - Za - z ] [ A - Za - z0 - 9_ ] * " ) ) { String errorMessage = MESSAGES . whitespaceProjectNameError ( ) ; filename = filename . replaceAll ( " ( ) + " , " " ) . replace ( " " , "_" ) ; warningMessage = errorMessage + " . \n '" + filename + "' will be used if continued . " ; } } return warningMessage ; }

sample: 466
buggy_code: public @NonNull TraceSessionComponent[] getSessions() { List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class); if (compenents.size() > 0) { TraceSessionGroup group = (TraceSessionGroup)compenents.get(0); List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class); return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]); } return new <START> @NonNull TraceSessionComponent[0]; <END> }
code_review: this doesn't seem to change anything for me?
target code: public @NonNull TraceSessionComponent [ ] getSessions ( ) { List < ITraceControlComponent > compenents = getChildren ( TraceSessionGroup . class ) ; if ( compenents . size ( ) > 0 ) { TraceSessionGroup group = ( TraceSessionGroup ) compenents . get ( 0 ) ; List < ITraceControlComponent > sessions = group . getChildren ( TraceSessionComponent . class ) ; return sessions . toArray ( new @NonNull TraceSessionComponent [ sessions . size ( ) ] ) ; } return new TraceSessionComponent [ 0 ] ; }
response: public @NonNull TraceSessionComponent [ ] getSessions ( ) { List < ITraceControlComponent > components = getChildren ( TraceSessionGroup . class ) ; if ( ! components . isEmpty ( ) ) { TraceSessionGroup group = ( TraceSessionGroup ) components . get ( 0 ) ; List < ITraceControlComponent > sessions = group . getChildren ( TraceSessionComponent . class ) ; return sessions . toArray ( new TraceSessionComponent [ sessions . size ( ) ] ) ; } return new TraceSessionComponent [ 0 ] ; }

sample: 467
buggy_code: private static void cacheColors(Display display) { BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB(); FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB(); Color hyperlinkText= JFaceColors.getHyperlinkText(display); <START> Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display); <END> if (hyperlinkText != null) { LINK_COLOR_RGB= hyperlinkText.getRGB(); } if (activeHyperlinkText != null) { ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB(); } }
code_review: Minor: Move declaration before the if block where it is used?
target code: private static void cacheColors ( Display display ) { BG_COLOR_RGB = JFaceColors . getInformationViewerBackgroundColor ( display ) . getRGB ( ) ; FG_COLOR_RGB = JFaceColors . getInformationViewerForegroundColor ( display ) . getRGB ( ) ; Color hyperlinkText = JFaceColors . getHyperlinkText ( display ) ; if ( hyperlinkText != null ) { LINK_COLOR_RGB = hyperlinkText . getRGB ( ) ; } Color activeHyperlinkText = JFaceColors . getActiveHyperlinkText ( display ) ; if ( activeHyperlinkText != null ) { ACTIVE_LINK_COLOR_RGB = activeHyperlinkText . getRGB ( ) ; } }
response: private static void cacheColors ( Display display ) { Color hyperlinkText = JFaceColors . getHyperlinkText ( display ) ; Color activeHyperlinkText = JFaceColors . getActiveHyperlinkText ( display ) ; BG_COLOR_RGB = JFaceColors . getInformationViewerBackgroundColor ( display ) . getRGB ( ) ; FG_COLOR_RGB = JFaceColors . getInformationViewerForegroundColor ( display ) . getRGB ( ) ; if ( hyperlinkText != null ) { LINK_COLOR_RGB = hyperlinkText . getRGB ( ) ; } if ( activeHyperlinkText != null ) { ACTIVE_LINK_COLOR_RGB = activeHyperlinkText . getRGB ( ) ; } }

sample: 468
buggy_code: private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) { if (f instanceof IRadioButton) { <START> return (IRadioButton<T>) f; //TODO: mnick <END> } else if (f instanceof ICompositeField) { for (IFormField sub : ((ICompositeField) f).getFields()) { IRadioButton<T> b = findFirstButtonInFieldTree(sub); if (b != null) { return b; } } } return null; }
code_review: you can use TypeCastUtility.getGenericsParameterClass(getClass(), IHolder.class); to check the type parameter
target code: private IRadioButton < T > findFirstButtonInFieldTree ( IFormField f ) { if ( f instanceof IRadioButton ) { return ( IRadioButton ) f ; } else if ( f instanceof ICompositeField ) { for ( IFormField sub : ( ( ICompositeField ) f ) . getFields ( ) ) { IRadioButton < T > b = findFirstButtonInFieldTree ( sub ) ; if ( b != null ) { return b ; } } } return null ; }
response: private IRadioButton < T > findFirstButtonInFieldTree ( IFormField f ) { if ( f instanceof IRadioButton ) { return TypeCastUtility . getGenericsParameterClass ( getClass ( ) , IRadioButton . class ) . cast ( f ) ; } else if ( f instanceof ICompositeField ) { for ( IFormField sub : ( ( ICompositeField ) f ) . getFields ( ) ) { IRadioButton < T > b = findFirstButtonInFieldTree ( sub ) ; if ( b != null ) { return b ; } } } return null ; }

sample: 469
buggy_code: public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception { final String expected = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!DOCTYPE suppressions PUBLIC\n" <START> + " \"-//Puppy Crawl//DTD Suppressions Xpath Experimental 1.2//EN\"\n" <END> + " \"http://checkstyle.sourceforge.net/dtds/" + "suppressions_1_2_xpath_experimental.dtd\">\n" + "<suppressions>\n" + "</suppressions>\n"; exit.checkAssertionAfterwards(() -> { assertEquals("Unexpected output log", expected, systemOut.getLog()); assertEquals("Unexpected system error log", "", systemErr.getLog()); }); Main.main("-c", getPath("InputMainConfig-empty.xml"), "--generate-xpath-suppression", getPath("InputMainComplexityOverflow.java")); }
code_review: fix name
target code: public void testGenerateXpathSuppressionOptionEmptyConfig ( ) throws Exception { final String expected = "" ; exit . checkAssertionAfterwards ( ( ) - > { assertEquals ( "Unexpected output log" , expected , systemOut . getLog ( ) ) ; assertEquals ( "Unexpected system error log" , "" , systemErr . getLog ( ) ) ; } ) ; Main . main ( " - c" , getPath ( "InputMainConfig - empty . xml" ) , " -- generate - xpath - suppression" , getPath ( "InputMainComplexityOverflow . java" ) ) ; }
response: public void testGenerateXpathSuppressionOptionEmptyConfig ( ) throws Exception { final String expected = " < ? xml version = \"1 . 0\" encoding = \"UTF - 8\" ? > \n" + " < ! DOCTYPE suppressions PUBLIC\n" + " \" -/ / Puppy Crawl // DTD Suppressions Xpath Experimental 1 . 2 // EN\"\n" + " \"http :/ / checkstyle . sourceforge . net / dtds / suppressions_1_2_xpath_experimental . dtd\" > \n" + " < suppressions > \n" + " </ suppressions > \n" ; exit . checkAssertionAfterwards ( ( ) - > { assertEquals ( "Unexpected output log" , expected , systemOut . getLog ( ) ) ; assertEquals ( "Unexpected system error log" , "" , systemErr . getLog ( ) ) ; } ) ; Main . main ( " - c" , getPath ( "InputMainConfig - empty . xml" ) , " -- generate - xpath - suppression" , getPath ( "InputMainComplexityOverflow . java" ) ) ; }

sample: 470
buggy_code: public String getPackageName() { if (clazz.getPackage() != null) { return clazz.getPackage().getName(); } <START> return null; <END> }
code_review: Can this method return null? Or should it return empty string?
target code: public String getPackageName ( ) { if ( clazz . getPackage ( ) != null ) { return clazz . getPackage ( ) . getName ( ) ; } return "" ; }
response: public String getPackageName ( ) { if ( clazz . getPackage ( ) != null ) { return clazz . getPackage ( ) . getName ( ) ; } return "" ; }

sample: 471
buggy_code: public void testIsStringLiteral() { Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1); ASTLiteral literal = literals.iterator().next(); assertTrue(literal.isStringLiteral()); <START> assertEquals("String", literal.getTypeImage()); <END> }
code_review: This could also be `java.lang.String`.
target code: public void testIsStringLiteral ( ) { Set < ASTLiteral > literals = getNodes ( ASTLiteral . class , TEST1 ) ; assertTrue ( ( literals . iterator ( ) . next ( ) ) . isStringLiteral ( ) ) ; }
response: public void testIsStringLiteral ( ) { Set < ASTLiteral > literals = getNodes ( ASTLiteral . class , TEST1 ) ; ASTLiteral literal = literals . iterator ( ) . next ( ) ; assertTrue ( literal . isStringLiteral ( ) ) ; assertEquals ( java . lang . String . class . getName ( ) , literal . getTypeImage ( ) ) ; }

sample: 472
buggy_code: public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys) { ImmutableMap.Builder builder = ImmutableMap.builder(); for (K key : keys <START> ) { <END> V value = getIfPresent(key); if (value != null) { builder.put(key, value); } } return builder.build(); }
code_review: formatting weird
target code: public Map < K , V > getAllPresent ( final Iterable < K > keys ) { ImmutableMap . Builder builder = ImmutableMap . builder ( ) ; for ( K key : keys ) { V value = getIfPresent ( key ) ; if ( value != null ) { builder . put ( key , value ) ; } } return builder . build ( ) ; }
response: public ImmutableMap < K , V > getAllPresent ( final Iterable < K > keys ) { ImmutableMap . Builder builder = ImmutableMap . builder ( ) ; for ( K key : keys ) { V value = getIfPresent ( key ) ; if ( value != null ) { builder . put ( key , value ) ; } } return builder . build ( ) ; }

sample: 473
buggy_code: <START> public void configure(ServerHttpSecurity http) { <END> ReactiveAuthenticationManager authenticationManager = getAuthenticationManager(); X509PrincipalExtractor principalExtractor = getPrincipalExtractor(); AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager); filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor)); http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION); }
code_review: Please make this protected to avoid exposing methods that consumers of the API do not care about.
target code: protected void configure ( ServerHttpSecurity http ) { ReactiveAuthenticationManager authenticationManager = getAuthenticationManager ( ) ; X509PrincipalExtractor principalExtractor = getPrincipalExtractor ( ) ; AuthenticationWebFilter filter = new AuthenticationWebFilter ( authenticationManager ) ; filter . setServerAuthenticationConverter ( new ServerX509AuthenticationConverter ( principalExtractor ) ) ; http . addFilterAt ( filter , SecurityWebFiltersOrder . AUTHENTICATION ) ; }
response: < START > protected void configure ( ServerHttpSecurity http ) { ReactiveAuthenticationManager authenticationManager = getAuthenticationManager ( ) ; X509PrincipalExtractor principalExtractor = getPrincipalExtractor ( ) ; AuthenticationWebFilter filter = new AuthenticationWebFilter ( authenticationManager ) ; filter . setServerAuthenticationConverter ( new ServerX509AuthenticationConverter ( principalExtractor ) ) ; http . addFilterAt ( filter , SecurityWebFiltersOrder . AUTHENTICATION ) ; } < END >

sample: 474
buggy_code: public void action(AuthenticationFlowContext context) { if (DisplayUtils.isConsole(context)) { <START> ConsoleOTPFormAuthenticator.SINGLETON.action(context); <END> return; } validateOTP(context); }
code_review: Would it not be better to obtain this from the session? With this approach it's not pluggable.
target code: public void action ( AuthenticationFlowContext context ) { validateOTP ( context ) ; }
response: public void action ( AuthenticationFlowContext context ) { if ( DisplayUtils . isConsole ( context ) ) { context . getEvent ( ) . detail ( "console" , "true" ) ; return ; } validateOTP ( context ) ; }

sample: 475
buggy_code: private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber, Repository which, Collection<IFile> resources) { for (GitSynchronizeData gsd : gsds) { if (which.equals(gsd.getRepository())) { <START> if (!resources.isEmpty()) <END> refreshResources(subscriber, resources); else refreshRepository(subscriber); } } }
code_review: A null check is needed also. An NPE will be thrown if reopening a very large project. java.lang.NullPointerException at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.handleResourceChange(GitSubscriberMergeContext.java:141) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.access$1(GitSubscriberMergeContext.java:137) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext$2.indexDiffChanged(GitSubscriberMergeContext.java:69) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.notifyListeners(IndexDiffCache.java:94) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.access$0(IndexDiffCache.java:86) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache$1.indexDiffChanged(IndexDiffCache.java:81) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.notifyListeners(IndexDiffCacheEntry.java:313) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.access$6(IndexDiffCacheEntry.java:306) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry$3.run(IndexDiffCacheEntry.java:171) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
target code: private void handleResourceChange ( GitResourceVariantTreeSubscriber subscriber , Repository which , Collection < IFile > resources ) { for ( GitSynchronizeData gsd : gsds ) { if ( which . equals ( gsd . getRepository ( ) ) && resources != null && ! resources . isEmpty ( ) ) refreshResources ( subscriber , resources ) ; } }
response: private void handleResourceChange ( GitResourceVariantTreeSubscriber subscriber , Repository which , Collection < IFile > resources ) { for ( GitSynchronizeData gsd : gsds ) { if ( which != null && which . equals ( gsd . getRepository ( ) ) ) { if ( resources != null && ! resources . isEmpty ( ) ) { refreshResources ( subscriber , resources ) ; } else { refreshRepository ( subscriber ) ; } } } }

sample: 476
buggy_code: public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root, Sort rootSort) { <START> Set<Path> ret=new HashSet<Path>(); <END> if(rootSort!=null) { SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot()); for(SortFieldInfo fi:sfi) ret.add(fi.getName()); } return ret; }
code_review: Don't necessarily need the type info in the right hand assignment anymore. Only mention it because you use both ways throughout.
target code: public static Set < Path > getIncludedFieldsOfRootEntityForSort ( CompositeMetadata root , Sort rootSort ) { Set < Path > ret = new HashSet < > ( ) ; if ( rootSort != null ) { SortFieldInfo [ ] sfi = SortFieldInfo . buildSortFields ( rootSort , root . getFieldTreeRoot ( ) ) ; for ( SortFieldInfo fi : sfi ) ret . add ( fi . getName ( ) ) ; } return ret ; }
response: public static Set < Path > getIncludedFieldsOfRootEntityForSort ( CompositeMetadata root , Sort rootSort ) { var ret = new HashSet < > ( ) ; if ( rootSort != null ) { var sfi = SortFieldInfo . buildSortFields ( rootSort , root . getFieldTreeRoot ( ) ) ; for ( var fi : sfi ) { ret . add ( fi . getName ( ) ) ; } } return ret ; }

sample: 477
buggy_code: public LocalCluster(String jarFileName, int siteCount, int hostCount, int kfactor, int clusterId, BackendTarget target, FailureState failureState, boolean debug, boolean isRejoinTest, Map<String, String> env) { // NOTE: isRejoinTest is unused <START> this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); <END> }
code_review: Why remove unused at only one level below if its not used at all remove all together.
target code: public LocalCluster ( String jarFileName , int siteCount , int hostCount , int kfactor , int clusterId , BackendTarget target , FailureState failureState , boolean debug , boolean isRejoinTest , Map < String , String > env ) { this ( null , null , jarFileName , siteCount , hostCount , kfactor , clusterId , target , failureState , debug , isRejoinTest , env ) ; }
response: public LocalCluster ( String jarFileName , int siteCount , int hostCount , int kfactor , int clusterId , BackendTarget target , FailureState failureState , boolean debug , Map < String , String > env ) { this ( null , null , jarFileName , siteCount , hostCount , kfactor , clusterId , target , failureState , debug , env ) ; }

sample: 478
buggy_code: public void execute(String userName) { FollowModeManager currentFollowModeManager = followModeManager; User userToFollow = findUser(userName); if (currentFollowModeManager == null) { return; } <START> User currentlyFollowedUser = followModeManager.getFollowedUser(); <END> if ((currentlyFollowedUser != null && !currentlyFollowedUser.equals(userToFollow)) || (currentlyFollowedUser == null && userToFollow != null)) { currentFollowModeManager.follow(userToFollow); } actionPerformed(); }
code_review: I would prefer to move this logic into the `FollowModeManager`
target code: public void execute ( String userName ) { FollowModeManager currentFollowModeManager = followModeManager ; User userToFollow = findUser ( userName ) ; if ( currentFollowModeManager == null ) { return ; } currentFollowModeManager . follow ( userToFollow ) ; actionPerformed ( ) ; }
response: public void execute ( String userName ) { FollowModeManager currentFollowModeManager = followModeManager ; User userToFollow = findUser ( userName ) ; if ( currentFollowModeManager == null ) { return ; } currentFollowModeManager . followUser ( userToFollow ) ; actionPerformed ( ) ; } // FollowModeManager class public class FollowModeManager { private User followedUser ; public void followUser ( User userToFollow ) { if ( ( followedUser != null && ! followedUser . equals ( userToFollow ) ) || ( followedUser == null && userToFollow != null ) ) { follow ( userToFollow ) ; } } private void follow ( User userToFollow ) { // follow the user followedUser = userToFollow ; } public User getFollowedUser ( ) { return followedUser ; } }

sample: 479
buggy_code: @Override public Appendable write(Appendable appendable, Context context) throws IOException { <START> String sep = ""; <END> for (TypeName className : typeNames) { appendable.append(sep); className.write(appendable, context); sep = " & "; } return appendable; }
code_review: nit: `sep` –> `separator` ?
target code: @Override public Appendable write ( Appendable appendable , Context context ) throws IOException { Iterator < TypeName > iterator = typeNames . iterator ( ) ; if ( iterator . hasNext ( ) ) { iterator . next ( ) . write ( appendable , context ) ; while ( iterator . hasNext ( ) ) { appendable . append ( " & " ) ; iterator . next ( ) . write ( appendable , context ) ; } } return appendable ; }
response: @Override public Appendable write ( Appendable appendable , Context context ) throws IOException { String separator = "" ; for ( TypeName className : typeNames ) { appendable . append ( separator ) ; className . write ( appendable , context ) ; separator = " & " ; } return appendable ; }

An Exception occurred at sample: 480. Error details: That model is currently overloaded with other requests. You can retry your request, or contact us through our help center at help.openai.com if the error persists. (Please include the request ID 4ddb2ebc9cd3163dcca2ecdd82a7302c in your message.)
BLEU: 75.38 ; EM: 23.81
Python file executed successfully.
Cloning into 'tree-sitter-java'...
ngram match: 0.753764199420932, weighted ngram match: 0.7646837664942184, syntax_match: 0.7393939393939394, dataflow_match: 0.6902485659655831
CodeBLEU score: 73.70
Python file executed successfully.
sample: 0
buggy_code:  import java.util.ArrayList; /** * This class provides helper functions for Wifi connectivity related modules to * access WifiNative. It starts with firmware roaming. TODO(b/34819513): Move operations * such as connection to network and legacy framework roaming here. */ public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; <|startfocus|> private int mMaxNumBlacklistBssid = -1; private int mMaxNumWhitelistSsid = -1; <|endfocus|> WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } /** * Query firmware if it supports * {@link android.net.wifi.WifiManager#WIFI_FEATURE_CONTROL_ROAMING}. If yes, get the firmware * roaming capabilities. */ public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0;
code_review:  it would probably be a good idea to define this as a static, then use that anywhere you need to return -1. 
target code: import java.util.ArrayList; /** * This class provides helper functions for Wifi connectivity related modules to * access WifiNative. It starts with firmware roaming. TODO(b/34819513): Move operations * such as connection to network and legacy framework roaming here. */ public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; private int mMaxNumBlacklistBssid = INVALID_LIST_SIZE; private int mMaxNumWhitelistSsid = INVALID_LIST_SIZE; WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } /** * Query firmware if it supports * {@link android.net.wifi.WifiManager#WIFI_FEATURE_CONTROL_ROAMING}. If yes, get the firmware * roaming capabilities. */ public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0;
response: import java.util.ArrayList; public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; private static final int DEFAULT_MAX_NUM_BLACKLIST_BSSID = -1; private static final int DEFAULT_MAX_NUM_WHITELIST_SSID = -1; WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0; } }

sample: 1
buggy_code:  mMaxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); <|startfocus|> } <|endfocus|> }
code_review:  there is no way for the caller to know if this failed. What should the proper operation be? What could cause the getRoamingCapabilities to fail? Should this then report that firmware roaming is not supported so the framework code can do the roams instead of relying on faulty firmware? or is this a sign that something major happened? Do we need to restart anything? 
target code: mMaxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } if (fallbackToFrameworkRoaming) { Log.e(TAG, "Fall back to framework roaming"); mFirmwareRoamingSupported = false; return false; } }
response: /** @hide */ public static final int WIFI_FEATURE_MKEEP_ALIVE = 0x100000; // Wifi mkeep_alive /** @hide */ public static final int WIFI_FEATURE_CONFIG_NDO = 0x200000; // ND offload configure /** @hide */ public static final int WIFI_FEATURE_TRANSMIT_POWER = 0x400000; // Capture Tx transmit power levels /** @hide */ public static final int WIFI_FEATURE_CONTROL_ROAMING = 0x800000; // Enable/Disable firmware roaming /** @hide */ public static final int WIFI_FEATURE_IE_WHITELIST = 0x1000000; // Probe IE white listing /** @hide */ public static final int WIFI_FEATURE_SCAN_RAND = 0x2000000; // Support MAC & Probe Sequence Number randomization private int getSupportedFeatures() { try { return mService.getSupportedFeatures(); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } private boolean isFeatureSupported(int feature) { return (getSupportedFeatures() & feature) == feature; } public void verifyFirmwareRoamingCapabilityWithSuccessfulNativeCall() { mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertTrue(mWifiConnectivityHelper.isFirmwareRoamingSupported()); assertEquals(MAX_BSSID_BLACKLIST_SIZE, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(MAX_SSID_WHITELIST_SIZE, mWifiConnectivityHelper.getMaxNumWhitelistSsid()); } public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } mMaxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid);

sample: 2
buggy_code:  mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } } } /** * Return if firmware roaming is supported. */ public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } /** <|startfocus|> * Return the maximum size of BSSID blacklist. <|endfocus|> */ public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /** * Return the maximum size of SSID whitelist. */ public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /**
code_review:  would be good to document the return value. 
target code: mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } } } /** * Return if firmware roaming is supported. */ public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } /** * Get the maximum size of BSSID blacklist firmware supports. * * @return INVALID_LIST_SIZE if firmware roaming is not supported, or * maximum size of the BSSID blacklist firmware supports. */ public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /** * Return the maximum size of SSID whitelist. */ public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /**
response: Buggy Code: ```java mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } } public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } ``` Review: - Add documentation for the `getMaxNumBlacklistBssid()` method to explain the return value. Refactored Code: ```java mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } } public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } /** * Return the maximum size of BSSID blacklist. * * @return The maximum size of BSSID blacklist if firmware roaming is supported, otherwise -1. */ public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } ```

sample: 3
buggy_code:  public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { <|startfocus|> Log.e(TAG, "Firmware roaming is not supported"); return -1; <|endfocus|> }
code_review:  else not needed here. the normal case will return 
target code: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "getMaxNumBlacklistBssid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; }
response: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } Log.e(TAG, "Firmware roaming is not supported"); return -1; }

sample: 4
buggy_code:  public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { <|startfocus|> Log.e(TAG, "Firmware roaming is not supported"); return -1; <|endfocus|> }
code_review:  maybe add something like "MaxNumBlacklistBssid invalid: "... then what you have here. 
target code: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "getMaxNumBlacklistBssid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; }
response: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "MaxNumBlacklistBssid invalid: Firmware roaming is not supported"); return -1; } }

sample: 5
buggy_code:  public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { <|startfocus|> Log.e(TAG, "Firmware roaming is not supported"); return -1; <|endfocus|> }
code_review:  else not needed since the normal case will return the value 
target code: public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "getMaxNumWhitelistSsid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; }
response: public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } Log.e(TAG, "Firmware roaming is not supported"); return -1; }

sample: 6
buggy_code:  /** Sets up test. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } /** Cleans up test. */ @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private int mFeatureSetValue; <|startfocus|> private static final String TAG = "WifiConnectivityHelper Unit Test"; <|endfocus|> private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { // Return firmware roaming feature as supported by default. when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true;
code_review:  WifiConnectivityHelperTest 
target code: /** Sets up test. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } /** Cleans up test. */ @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private int mFeatureSetValue; private static final String TAG = "WifiConnectivityHelperTest"; private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { // Return firmware roaming feature as supported by default. when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true;
response: /** Sets up test. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } /** Cleans up test. */ @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private int mFeatureSetValue; private static final String TAG = "WifiConnectivityHelper Unit Test"; private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { // Return firmware roaming feature as supported by default. when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments<Boolean>() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true; } }).when(mWifiNative).getRoamingCapabilities(any(WifiNative.RoamingCapabilities.class)); }

sample: 7
buggy_code:  public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; }}).when(mWifiNative).getRoamingCapabilities(anyObject()); <|startfocus|> mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertEquals(-1, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(-1, mWifiConnectivityHelper.getMaxNumWhitelistSsid()); <|endfocus|>
code_review:  you shouldn't need to set this, correct? the false should prevent you from attempting to read the values. 
target code: public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; }}).when(mWifiNative).getRoamingCapabilities(anyObject()); assertFalse(mWifiConnectivityHelper.getFirmwareRoamingInfo()); assertFalse(mWifiConnectivityHelper.isFirmwareRoamingSupported()); assertEquals(WifiConnectivityHelper.INVALID_LIST_SIZE, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(WifiConnectivityHelper.INVALID_LIST_SIZE, mWifiConnectivityHelper.getMaxNumWhitelistSsid());
response: public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; } }).when(mWifiNative).getRoamingCapabilities(anyObject()); mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertEquals(-1, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(-1, mWifiConnectivityHelper.getMaxNumWhitelistSsid()); }

sample: 8
buggy_code:  public void verifySetFirmwareRoamingConfigurationWithGoodInput() { <|startfocus|> mWifiConnectivityHelper.getFirmwareRoamingInfo(); <|endfocus|> ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist));
code_review:  can you also please verify that sizes below the max are written? 
target code: public void verifySetFirmwareRoamingConfigurationWithGoodInput() { assertTrue(mWifiConnectivityHelper.getFirmwareRoamingInfo()); ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist));
response: public void verifySetFirmwareRoamingConfigurationWithGoodInput() { mWifiConnectivityHelper.getFirmwareRoamingInfo(); ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist)); }

sample: 9
buggy_code:  * [or other varieties of that API]. * * * @hide */ public String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; <|startfocus|> } else { WifiAwareManager mgr = mMgr.get(); if (mgr == null) { Log.w(TAG, "createNetworkSpecifierPassphrase: called post GC on WifiAwareManager"); return null; } <|endfocus|> int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); } } /** * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(String)} for an
code_review:  Consider dropping the else, and just moving the remainder of the function up one level. (Functionally equivalent; I just find less nesting easier to read.) 
target code: * [or other varieties of that API]. * * * @hide */ public String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; } int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); } } /** * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(String)} for an
response: protected String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; } WifiAwareManager mgr = mMgr.get(); if (mgr == null) { Log.w(TAG, "createNetworkSpecifierPassphrase: called post GC on WifiAwareManager"); return null; } int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); }

sample: 10
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } } 
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } }
response: * Copyright (C) 2017 The Android Open Source Project * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } }

sample: 11
buggy_code:  boolean waitForCallback(int callback) { synchronized (mLocalLock) { <|startfocus|> Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { it.remove(); return true; } <|endfocus|> } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; }
code_review:  Maybe use ArrayDeque<>.remove(), instead? (Just a little bit shorter.) 
target code: boolean waitForCallback(int callback) { synchronized (mLocalLock) { boolean found = mCallbackQueue.remove(callback); if (found) { return true; } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; }
response: boolean waitForCallback(int callback) { synchronized (mLocalLock) { Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { it.remove(); return true; } } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; } }

sample: 12
buggy_code:  boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { <|startfocus|> Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { return true; } } <|endfocus|> } return false;
code_review:  Maybe use ArrayDeque<>.contains(), instead? 
target code: boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { return mCallbackQueue.contains(callback); } return false;
response: boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { return mCallbackQueue.contains(callback); } }

sample: 13
buggy_code:  public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); <|startfocus|> // 1. publish <|endfocus|> session.subscribe(subscribeConfig, discoveryCb, null); assertTrue("Subscribe started", discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull("Subscribe session", discoverySession); // 2. update-subscribe subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).setServiceSpecificInfo("extras".getBytes()).build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue("Subscribe update", discoveryCb.waitForCallback( DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); // 3. destroy assertFalse("Subscribe not terminated", discoveryCb.hasCallbackAlreadyHappened( DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy(); 
code_review:  Maybe "subscribe"? 
target code: public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); // 1. subscribe session.subscribe(subscribeConfig, discoveryCb, null); assertTrue("Subscribe started", discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull("Subscribe session", discoverySession); // 2. update-subscribe subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).setServiceSpecificInfo("extras".getBytes()).build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue("Subscribe update", discoveryCb.waitForCallback( DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); // 3. destroy assertFalse("Subscribe not terminated", discoveryCb.hasCallbackAlreadyHappened( DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy();
response: public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(serviceName).build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); session.subscribe(subscribeConfig, discoveryCb, null); assertTrue(discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull(discoverySession); subscribeConfig = new SubscribeConfig.Builder().setServiceName(serviceName).setServiceSpecificInfo("extras".getBytes()).build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue(discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); assertFalse(discoveryCb.hasCallbackAlreadyHappened(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy(); }

sample: 14
buggy_code:  assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
code_review:  Should we call mMediaRecorder.setCamera(mCamera) here? I mean it looks more strait forward to set the camera for MediaRecorder after we query/setup the resolution. 
target code: assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
response: assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.release(); mCamera = null; mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); }

sample: 15
buggy_code:  assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024); } private void testSetMaxFileSize( long fileSize, long tolerance) throws Exception { if (!hasMicrophone() || !hasCamera() || !hasAmrNb() || !hasH264()) { MediaUtils.skipTest("no microphone, camera, or codecs"); return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setVideoEncodingBitRate(256000); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); 
code_review:  ditto. 
target code: assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024); } private void testSetMaxFileSize( long fileSize, long tolerance) throws Exception { if (!hasMicrophone() || !hasCamera() || !hasAmrNb() || !hasH264()) { MediaUtils.skipTest("no microphone, camera, or codecs"); return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setVideoEncodingBitRate(256000); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start();
response: protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.list_7); mPhone = (TextView) findViewById(R.id.phone); getListView().setOnItemSelectedListener(this); // Get a cursor with all people Cursor c = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, PEOPLE_PROJECTION, null, null, null); startManagingCursor(c); mColumnHasPhoneNumber = c.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER); mColumnContactId = c.getColumnIndex(ContactsContract.Contacts._ID); ListAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, c, new String[] {ContactsContract.Contacts.DISPLAY_NAME}, new int[] {android.R.id.text1}); setListAdapter(adapter); } public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Query for people Cursor groupCursor = managedQuery(Contacts.CONTENT_URI, PEOPLE_PROJECTION, null, null, null); mContactIdColumnIndex = groupCursor.getColumnIndexOrThrow(ContactsContract.Contacts._ID); mAdapter = new MyExpandableListAdapter(groupCursor, this, android.R.layout.simple_expandable_list_item_1, android.R.layout.simple_expandable_list_item_1, new String[] {ContactsContract.Contacts.DISPLAY_NAME}, new int[] {android.R.id.text1}, new String[] {ContactsContract.CommonDataKinds.Phone.NUMBER}, new int[] {android.R.id.text1}); setListAdapter(mAdapter); } protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.list_7); mPhone = (TextView) findViewById(R.id.phone); getListView().setOnItemSelectedListener(this); // Get a cursor with all people Cursor c = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, PEOPLE_PROJECTION, null, null, null); startManagingCursor(c); ListAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, c, new String[] {ContactsContract.Contacts.DISPLAY_NAME}, new int[] {android.R.id.text1}); setListAdapter(adapter); } assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024

sample: 16
buggy_code:  // Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // Get package info via packagemanager PackageInfo appInfo; try { // XXX this is lossy- apps can share a UID appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, <|startfocus|> mContext.getUserId()); <|endfocus|> } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // checkDestination() returns true if the destination is not a premium short code or the // sending app is approved to send to short codes. Otherwise, a message is sent to our // handler with the SmsTracker to request user confirmation before sending. if (checkDestination(tracker)) {
code_review:  LGTM. Actually there are 2 instances of getPackageInfo in SMSDispatcher.java and 2 in SmsApplication.java as well, should we fix them as well? Also not sure if this change will fail unit test or not because there is 1 instance in TelephonyTest.java as well. 
target code: // Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // Get package info via packagemanager PackageInfo appInfo; try { // XXX this is lossy- apps can share a UID appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, Binder.getCallingUid()); } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // checkDestination() returns true if the destination is not a premium short code or the // sending app is approved to send to short codes. Otherwise, a message is sent to our // handler with the SmsTracker to request user confirmation before sending. if (checkDestination(tracker)) {
response: private void checkType(int columnIndex, Type expectedType) { ColumnSchema columnSchema = schema.getColumnByIndex(columnIndex); Type columnType = columnSchema.getType(); if (!columnType.equals(expectedType)) { throw new IllegalArgumentException("Column (name: " + columnSchema.getName() + ", index: " + columnIndex +") is of type " + columnType.getName() + " but was requested as a type " + expectedType.getName()); } } public Integer abs(Integer self) { return Integer.valueOf(Math.abs(self.intValue())); } public Integer floor(Double self) { return Integer.valueOf((int)Math.floor(self.doubleValue())); } public Integer floor(Integer self) { return self; } // Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; // Get package info via packagemanager PackageInfo appInfo; try { appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, mContext.getUserId()); } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } if (checkDestination(tracker)) { // code here }

sample: 17
buggy_code:  mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> } public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); }
code_review:  nit: no need, we will release the camera in tear down. 
target code: mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); } public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); }
response: mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); mCamera.release(); mCamera = null; public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); } }

sample: 18
buggy_code:  mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); // Recording a scene with moving objects would greatly help reduce // the time for waiting. if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> } private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
code_review:  ditto 
target code: mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); // Recording a scene with moving objects would greatly help reduce // the time for waiting. if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); } private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
response: mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); // Recording a scene with moving objects would greatly help reduce // the time for waiting. if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); mCamera.release(); mCamera = null; } private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);

sample: 19
buggy_code:  assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); <|startfocus|> mMediaRecorder.setCamera(mCamera); <|endfocus|> mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
code_review:  Calling .setCamera significantly changes the codepath executed in the media service, so this substantially changes code coverage, etc; I don't think you want to change that. Without this, media service will instantiate its own camera client in the mediaserver process; otherwise, it will proxy through the app's camera client. Both routes need testing, so we don't want to switch from one to the other without making sure both routes are still covered sufficiently. 
target code: assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
response: try { Camera camera = Camera.open(0); List<Camera.Size> previewSizes = camera.getParameters().getSupportedPreviewSizes(); width = previewSizes.get(0).width; height = previewSizes.get(0).height; for (Camera.Size size : previewSizes) { if (size.width < width || size.height < height) { width = size.width; height = size.height; } } camera.release(); } catch (Exception e) { width = VIDEO_WIDTH; height = VIDEO_HEIGHT; } if (camera != null) { camera.release(); } Log.v(TAG, String.format("Camera video size used for test %dx%d", width, height)); output.write("H263 video record- reset after prepare Stress test\n"); output.write("Total number of loops:" + NUMBER_OF_RECORDER_STRESS_LOOPS + "\n"); output.write("No of loop: "); Log.v(TAG, "Start preview"); for (int i = 0; i < NUMBER_OF_RECORDER_STRESS_LOOPS; i++) { runOnLooper(new Runnable() { @Override public void run() { // code to be executed } }); } private WorkspaceData(IDataPersistenceService service) { this.service = service; } public List<Destination> getDestinations(FilterType filterType) { Predicate<? super Destination> filter = null; switch (filterType) { case PROJECT_CREATION: filter = dest -> dest.isCreateMissingRepos(); break; case PROJECT_DELETION: filter = dest -> dest != null && !dest.isReplicateProjectDeletions(); break; case ALL: default: break; } return filter != null ? destinations.stream().filter(filter).collect(toList()) : destinations; } assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setCamera(mCamera); mMedia

sample: 20
buggy_code:  || regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int)Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } } <|startfocus|> mGsmRoaming = regCodeIsRoaming(regState); mNewSS.setVoiceRegState(regCodeToServiceState(regState)); mNewSS.setRilVoiceRadioTechnology(type); mNewRejectCode = rejectCode; <|endfocus|> boolean isVoiceCapable = mPhone.getContext().getResources() .getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED
code_review:  Hal (not caps) 
target code: || regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int)Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } } mGsmRoaming = regCodeIsRoaming(registrationState); mNewRejectCode = reasonForDenial; boolean isVoiceCapable = mPhone.getContext().getResources() .getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED
response: || regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int)Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } mGsmRoaming = regCodeIsRoaming(regState); mNewSS.setVoiceRegState(regCodeToServiceState(regState)); mNewSS.setRilVoiceRadioTechnology(type); mNewRejectCode = rejectCode; boolean isVoiceCapable = mPhone.getContext().getResources() .getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED

sample: 21
buggy_code: <|startfocus|> private int convertHalRegStateToServiceState(int regState) { <|endfocus|> switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; }
code_review:  If the HalRegState is really constrained to Hal it should get translated before it leaves Ril.java. If it's not it should probably be just convertRegStateToServiceState Looking at this furtuer this appear to not be regState -> ServiceState but Hal -> AOSP. Does anybody above RIL.java need the RegState version? 
target code: private int getRegStateFromHalRegState(int regState) { switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; }
response: private int convertHalRegStateToServiceState(int regState) { switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; } }

sample: 22
buggy_code:  if (DBG) { log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat); } break; } case EVENT_POLL_STATE_GPRS: { DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; <|startfocus|> int oldDataRAT = mSS.getRilDataRadioTechnology(); <|endfocus|> mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) { 
code_review:  why did you move this if nobody else in-scope is using? Please put back to tightest scoping.. 
target code: if (DBG) { log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat); } break; } case EVENT_POLL_STATE_GPRS: { DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) {
response: if (DBG) { log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat); } break; } case EVENT_POLL_STATE_GPRS: { DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; int oldDataRAT = mSS.getRilDataRadioTechnology(); mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) { // code for CDMA } }

sample: 23
buggy_code:  * <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> * <td>1&ndash;8</td> * <td>1&ndash;8</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>9&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> <|startfocus|> * <td>20&ndash;26+</td> <|endfocus|> * <td></td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> * <td>20&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated">
code_review:  26+? I suspect it's TBD, same as other lines in this change. 
target code: * <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> * <td>1&ndash;8</td> * <td>1&ndash;8</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>9&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> * <td>20&ndash;TBD</td> * <td></td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> * <td>20&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated">
response: * <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> * <td>1&ndash;8</td> * <td>1&ndash;8</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> <td>9&ndash;TBD</td> <td>9&ndash;TBD</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> <td>20&ndash;26+</td> <td></td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> <td>20&ndash;TBD</td> <td>20&ndash;TBD</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> <td>9&ndash;TBD</td> <td>20&ndash;TBD</td> </tr> <tr class="deprecated">

sample: 24
buggy_code:  } } } @Test public void testSocketConnectTimeout() throws Exception { // #connect(SocketAddress endpoint, int timeout) checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); // Setting SO_TIMEOUT should not affect connect timeout. checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test <|startfocus|> public void testSocketIOStreamTimeout() throws Exception { <|endfocus|> // #read() try (ServerSocket ss = new ServerSocket(0)) { // The server socket will accept the connection without explicitly calling accept() due // to TCP backlog. checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception {
code_review:  Nit: Could probably be called ReadTimeout again. 
target code: } } } @Test public void testSocketConnectTimeout() throws Exception { // #connect(SocketAddress endpoint, int timeout) checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); // Setting SO_TIMEOUT should not affect connect timeout. checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test public void testSocketReadTimeout() throws Exception { // #read() try (ServerSocket ss = new ServerSocket(0)) { // The server socket will accept the connection without explicitly calling accept() due // to TCP backlog. checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception {
response: @Test public void testSocketConnectTimeout() throws Exception { // #connect(SocketAddress endpoint, int timeout) checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); // Setting SO_TIMEOUT should not affect connect timeout. checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test public void testSocketIOStreamTimeout() throws Exception { // #read() try (ServerSocket ss = new ServerSocket(0)) { // The server socket will accept the connection without explicitly calling accept() due // to TCP backlog. checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception { // Test case implementation }

sample: 25
buggy_code:  writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); } }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = <|startfocus|> !writeCompleted.await((long) (TIMEOUT_MILLIS * 1.2f), TimeUnit.MILLISECONDS); <|endfocus|> assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(5000, TimeUnit.MILLISECONDS)); } } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {
code_review:  We can wait a reasonable time here to be sure. I'd personally do an absolute of + 1000 for this. 100 millis doesn't seem like much to me, and we'd end up passing if we didn't actually wait long enough. 
target code: writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); } }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = !writeCompleted.await(TIMEOUT_MILLIS * 2, TimeUnit.MILLISECONDS); assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(5000, TimeUnit.MILLISECONDS)); } } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {
response: writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = !writeCompleted.await((long) (TIMEOUT_MILLIS * 1.2f), TimeUnit.MILLISECONDS); assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(600, TimeUnit.MILLISECONDS)); } } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {

sample: 26
buggy_code:  if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; <|startfocus|> Log.d(TAG, "Firmware roaming is supported"); Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" <|endfocus|> + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); return true; } } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } return false;
code_review:  could probably combine these into one log line: maybe something like "Firmware roaming supported with capabilities:..." 
target code: if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming supported with capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); return true; } } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } return false;
response: /** @hide */ public static final int WIFI_FEATURE_MKEEP_ALIVE = 0x100000; // Wifi mkeep_alive /** @hide */ public static final int WIFI_FEATURE_CONFIG_NDO = 0x200000; // ND offload configure /** @hide */ public static final int WIFI_FEATURE_TRANSMIT_POWER = 0x400000; // Capture Tx transmit power levels /** @hide */ public static final int WIFI_FEATURE_CONTROL_ROAMING = 0x800000; // Enable/Disable firmware roaming /** @hide */ public static final int WIFI_FEATURE_IE_WHITELIST = 0x1000000; // Probe IE white listing /** @hide */ public static final int WIFI_FEATURE_SCAN_RAND = 0x2000000; // Support MAC & Probe Sequence Number randomization private int getSupportedFeatures() { try { return mService.getSupportedFeatures(); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } private boolean isFeatureSupported(int feature) { return (getSupportedFeatures() & feature) == feature; } public void verifyFirmwareRoamingCapabilityWithSuccessfulNativeCall() { mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertTrue(mWifiConnectivityHelper.isFirmwareRoamingSupported()); assertEquals(MAX_BSSID_BLACKLIST_SIZE, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(MAX_SSID_WHITELIST_SIZE, mWifiConnectivityHelper.getMaxNumWhitelistSsid()); } public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize;

sample: 27
buggy_code:  public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, <|startfocus|> ArrayList<String> whitelistSsids) { <|endfocus|> if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig);
code_review:  indent here looks off, either 8 spaces in from the line start above or lined up with the A in ArrayList above. 
target code: public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, ArrayList<String> whitelistSsids) { if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig);
response: public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, ArrayList<String> whitelistSsids) { if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig); }

sample: 28
buggy_code:  public boolean requestIcon(String bssid, String fileName) { <|startfocus|> if (bssid == null || fileName == null) return false; <|endfocus|> return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName);
code_review:  should have an error message 
target code: public boolean requestIcon(String bssid, String fileName) { if (bssid == null || fileName == null) { Log.e(mTAG, "Invalid arguments for Icon request."); return false; } return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName);
response: Fixed Code: public boolean requestIcon(String bssid, String fileName) { if (bssid == null || fileName == null) { throw new IllegalArgumentException("BSSID and file name cannot be null."); } return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName); }

sample: 29
buggy_code:  * limitations under the License. */ package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; /** * Creates a mock WifiMonitor. * WARNING: This does not perfectly mock the behavior of WifiMonitor at the moment <|startfocus|> * ex. startMoniroting does nothing and will not send a connection/disconnection event <|endfocus|> */ public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override
code_review:  startMonitoring 
target code: * limitations under the License. */ package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; /** * Creates a mock WifiMonitor. * WARNING: This does not perfectly mock the behavior of WifiMonitor at the moment * ex. startMonitoring does nothing and will not send a connection/disconnection event */ public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override
response: package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override public void startMonitoring() { // Do nothing } }

sample: 30
buggy_code:  result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } } /** * Initiate WPS Pin Display setup. * * @param groupIfName Group interface name to use. * @param bssid BSSID of the AP. Use zero'ed bssid to indicate wildcard. <|startfocus|> * @return true, if operation was successful. <|endfocus|> */ public String startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) return null; synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) return null; if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return null; } // Null values should be fine, since bssid can be empty. byte[] macAddress = null; if (bssid != null) {
code_review:  This returns a string 
target code: result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } } /** * Initiate WPS Pin Display setup. * * @param groupIfName Group interface name to use. * @param bssid BSSID of the AP. Use zero'ed bssid to indicate wildcard. * @return generated pin if operation was successful, null otherwise. */ public String startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) return null; synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) return null; if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return null; } // Null values should be fine, since bssid can be empty. byte[] macAddress = null; if (bssid != null) {
response: result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } public String startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) return null; synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) return null; if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return null; } byte[] macAddress = null; if (bssid != null) {

sample: 31
buggy_code:  public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mTAG = "WifiNative-" + interfaceName; mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } <|startfocus|> // Note this affects logging on for all interfaces <|endfocus|> public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0 ? true : false); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } /******************************************************** * Native Initialization/Deinitialization ********************************************************/ /** * Setup wifi native for Client mode operations. * * 1. Starts the Wifi HAL and configures it in client/STA mode. * 2. Setup Wificond to operate in client mode and retrieve the handle to use for client * operations. *
code_review:  This comment is not true anymore, is it? 
target code: public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mTAG = "WifiNative-" + interfaceName; mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } /** * Enable verbose logging for all sub modules. */ public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0 ? true : false); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } /******************************************************** * Native Initialization/Deinitialization ********************************************************/ /** * Setup wifi native for Client mode operations. * * 1. Starts the Wifi HAL and configures it in client/STA mode. * 2. Setup Wificond to operate in client mode and retrieve the handle to use for client * operations. *
response: ```java public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0 ? true : false); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } /******************************************************** * Native Initialization/Deinitialization ********************************************************/ /** * Setup wifi native for Client mode operations. * * 1. Starts the Wifi HAL and configures it in client/STA mode. * 2. Setup Wificond to operate in client mode and retrieve the handle to use for client operations. */ ```

sample: 32
buggy_code:  public boolean startFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  This should be a 'start' shouldn't it? 
target code: public boolean startFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: public boolean startFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.startRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter(); }

sample: 33
buggy_code:  public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  Start? 
target code: public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.stopRxFilter(); }

sample: 34
buggy_code:  public boolean startFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  start 
target code: public boolean startFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: public boolean startFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter(); }

sample: 35
buggy_code:  public boolean stopFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  start 
target code: public boolean stopFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: public boolean stopFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.stopRxFilter(); }

sample: 36
buggy_code:  public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } /** * "sta" prioritizes STA connection over P2P and "p2p" prioritizes * P2P connection over STA */ public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } <|startfocus|> /** WifiSupplicantControl methods. TODO: These should use HIDL soon. */ <|endfocus|> /** * Migrate all the configured networks from wpa_supplicant. * * @param configs Map of configuration key to configuration objects corresponding to all * the networks. * @param networkExtras Map of extra configuration parameters stored in wpa_supplicant.conf * @return Max priority of all the configs. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); } /**
code_review:  soon is now? 
target code: public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } /** * "sta" prioritizes STA connection over P2P and "p2p" prioritizes * P2P connection over STA */ public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } /** * Migrate all the configured networks from wpa_supplicant. * * @param configs Map of configuration key to configuration objects corresponding to all * the networks. * @param networkExtras Map of extra configuration parameters stored in wpa_supplicant.conf * @return Max priority of all the configs. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); } /**
response: public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } /** * "sta" prioritizes STA connection over P2P and "p2p" prioritizes * P2P connection over STA */ public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } /** * WifiSupplicantControl methods. TODO: These should use HIDL soon. */ /** * Migrate all the configured networks from wpa_supplicant. * * @param configs Map of configuration key to configuration objects corresponding to all * the networks. * @param networkExtras Map of extra configuration parameters stored in wpa_supplicant.conf * @return Max priority of all the configs. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); }

sample: 37
buggy_code:  /** * Handler to notify the occurrence of various events during PNO scan. */ public interface PnoEventHandler { /** * Callback to notify when one of the shortlisted networks is found during PNO scan. * @param results List of Scan results received. */ void onPnoNetworkFound(ScanResult[] results); /** * Callback to notify when the PNO scan schedule fails. */ void onPnoScanFailed(); } <|startfocus|> /* scan status, keep these values in sync with gscan.h */ <|endfocus|> public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); } 
code_review:  no longer necessary. 
target code: /** * Handler to notify the occurrence of various events during PNO scan. */ public interface PnoEventHandler { /** * Callback to notify when one of the shortlisted networks is found during PNO scan. * @param results List of Scan results received. */ void onPnoNetworkFound(ScanResult[] results); /** * Callback to notify when the PNO scan schedule fails. */ void onPnoScanFailed(); } public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); }
response: /** * Handler to notify the occurrence of various events during PNO scan. */ public interface PnoEventHandler { /** * Callback to notify when one of the shortlisted networks is found during PNO scan. * @param results List of Scan results received. */ void onPnoNetworkFound(ScanResult[] results); /** * Callback to notify when the PNO scan schedule fails. */ void onPnoScanFailed(); } public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); }

sample: 38
buggy_code:  public void setWifiLinkLayerStats(String iface, int enable) { <|startfocus|> // Nothing to do here. Link layer stats is enabled when the HAL is started. <|endfocus|>
code_review:  Maybe add a TODO w/ a bugid to rm calling code. 
target code: public void setWifiLinkLayerStats(String iface, int enable) { // TODO(b//36087365) Remove this. Link layer stats is enabled when the HAL is started.
response: public void setWifiLinkLayerStats(String iface, int enable) { // TODO: Remove calling code with bug ID. }

sample: 39
buggy_code: <|startfocus|> public boolean isGetChannelsForBandSupported(){ <|endfocus|> return mWifiVendorHal.isGetChannelsForBandSupported();
code_review:  If you add the missing space, will checkstyle punish you by requiring javadoc? :-) 
target code: /** * Indicates whether getChannelsForBand is supported. * * @return true if it is. */ public boolean isGetChannelsForBandSupported() { return mWifiVendorHal.isGetChannelsForBandSupported();
response: public boolean isGetChannelsForBandSupported() { return mWifiVendorHal.isGetChannelsForBandSupported(); }

sample: 40
buggy_code:  void onWifiAlert(int errorCode, byte[] buffer); } public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName){ return mWifiVendorHal.startLoggingRingBuffer( verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } <|startfocus|> <|endfocus|> public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus{ String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0);
code_review:  My comment on line 1151 belongs here. 
target code: void onWifiAlert(int errorCode, byte[] buffer); } public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName){ return mWifiVendorHal.startLoggingRingBuffer( verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } /** * Stops all logging and resets the logger callback. * This stops both the alerts and ring buffer data collection. */ public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus{ String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0);
response: void onWifiAlert(int errorCode, byte[] buffer); public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName){ return mWifiVendorHal.startLoggingRingBuffer( verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus{ String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0); }

sample: 41
buggy_code:  * @hide */ public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. <|startfocus|> * Unit of this value should be in MHz. <|endfocus|> * @hide */ public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
code_review:  why call it earfcn then? Shouldn't it be freq? 
target code: * @hide */ public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * @hide */ public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
response: * @hide */ public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * Unit of this value should be in MHz. * @hide */ public static final String KEY_SIGNAL_STRENGTH_FREQ_THRESHOD_INT = "signal_strength_freq_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);

sample: 42
buggy_code:  "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * Unit of this value should be in MHz. * @hide */ <|startfocus|> public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = <|endfocus|> "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false);
code_review:  typo 
target code: "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * Unit of this value should be in MHz. * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCN_THRESHOLD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false);
response: "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * Unit of this value should be in MHz. * @hide */ public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOLD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false);

sample: 43
buggy_code:  * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ <|startfocus|> public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { <|endfocus|> return iccOpenLogicalChannel(getSubId(), AID, p2); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220.
code_review:  There are a number of apps that use this API. It should be deprecated and a new one added with p2. 
target code: * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, int p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220.
response: /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String AID, byte p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); }

sample: 44
buggy_code:  * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API <|startfocus|> * The gscan API is used to perform background scans and wificond is used for onehot scans. <|endfocus|> * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative);
code_review:  oneshot 
target code: * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for oneshot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative);
response: package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative); mWificondScannerDelegate = new WificondScannerImpl(context, wifiNative, looper, clock); mHalBasedPnoSupported = wifiNative.isHalBasedPnoSupported(); } }

sample: 45
buggy_code:  * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiMonitor; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API <|startfocus|> * The gscan API is used to perform background scans and wificond is used for onehot scans. <|endfocus|> * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, WifiMonitor wifiMonitor, Looper looper, Clock clock) {
code_review:  looks like this slipped back in 
target code: * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiMonitor; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for oneshot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, WifiMonitor wifiMonitor, Looper looper, Clock clock) {
response: private static final String R_ATTR = "R"; //$NON-NLS-1$ private static final String G_ATTR = "G"; //$NON-NLS-1$ private static final String B_ATTR = "B"; //$NON-NLS-1$ private static final String TICK_TAG = "TICK"; //$NON-NLS-1$ private static final String FILTER_TAG = "FILTER"; //$NON-NLS-1$ /** * Saves the given color settings to file. * * @param pathName A file name with path * @param colorSettings An array of color settings to save. */ public static void save(String pathName, ColorSetting[] colorSettings) { try { DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); Document document = documentBuilder.newDocument(); Element rootElement = document.createElement(COLOR_SETTINGS_TAG); document.appendChild(rootElement); for (ColorSetting colorSetting : colorSettings) { Element colorSettingElement = document.createElement(COLOR_SETTING_TAG); // code to add color setting to the document } // code to save the document to file } catch (Exception e) { e.printStackTrace(); } } private static void waitForShadowProjectUpdated(String parentProjectName) { for (int i = 1; i < 5000 && (TmfProjectModelHelper.getShadowProject(parentProjectName).exists()); i *= 2) { delay(i); } } /** * Step for FirstRunWizard for selecting a color scheme. */ public class SelectThemeStep extends FirstRunWizardStep { private final CustomizeUIThemeStepPanel themePanel; private final ScopedStateStore.Key<Boolean> myKeyCustomInstall; public SelectThemeStep(@NotNull ScopedStateStore.Key<Boolean> keyCustomInstall) { super("Select UI Theme"); this.myKeyCustomInstall = keyCustomInstall; this.themePanel = new CustomizeUIThemeStepPanel(); } // code for the rest of the class } /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for onehot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScanner

sample: 46
buggy_code:  public void describeTo(Description description) { <|startfocus|> description.appendText(toString()); <|endfocus|>
code_review:  Nit: formatting. 
target code: public void describeTo(Description description) { description.appendText(toString());
response: public void describeTo(Description description) { description.appendText(toString()); }

sample: 47
buggy_code:  String[] s; s = params.getCipherSuites(); if (s != null) { setEnabledCipherSuites(s); } s = params.getProtocols(); if (s != null) { setEnabledProtocols(s); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } } <|startfocus|> // Android-added: Make toString explicit that this is an SSLServerSocket (see b/6602228) <|endfocus|> @Override public String toString() { return "SSL" + super.toString(); } } 
code_review:  Just nits. Personal preference: The "see " is implicit. I personally prefer a leading http://b/ so I can click on it in an IDE (for sure) & gerrit (I think). The bug reference is probably superfluous in this case; not sure what people would gain from looking at the bug. Judgement call, though. Would apply to both. 
target code: String[] s; s = params.getCipherSuites(); if (s != null) { setEnabledCipherSuites(s); } s = params.getProtocols(); if (s != null) { setEnabledProtocols(s); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } } // Android-added: Make toString explicit that this is an SSLServerSocket (http://b/6602228) @Override public String toString() { return "SSL" + super.toString(); } }
response: String[] s; s = params.getCipherSuites(); if (s != null) { setEnabledCipherSuites(s); } s = params.getProtocols(); if (s != null) { setEnabledProtocols(s); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } @Override public String toString() { return "SSL" + super.toString(); }

sample: 48
buggy_code:  */ public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** <|startfocus|> * Lookup the ANQP elements associated with the given AP from the cache. An empty map <|endfocus|> * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(
code_review:  Nit: extra white space. 
target code: */ public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** * Lookup the ANQP elements associated with the given AP from the cache. An empty map * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(
response: public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(bssid, vsa.anqpDomainID)); if (anqpEntry != null) { return anqpEntry.getElements(); } else { return new HashMap<>(); } }

sample: 49
buggy_code:  mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** <|startfocus|> * Lookup the ANQP elements associated with the given AP from the cache. An empty map <|endfocus|> * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey( scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID));
code_review:  Maybe move this to @return? 
target code: mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** * Lookup the ANQP elements associated with the given AP from the cache. An empty map * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey( scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID));
response: public Map<Constants.ANQPElementType, ANQPElement> lookupANQPElements(ScanResult scanResult) { InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID)); return anqpEntry != null ? anqpEntry.getElements() : Collections.emptyMap(); }

sample: 50
buggy_code:  public void enter() { super.enter(); <|startfocus|> if (!mBluetoothRouteManager.isInbandRingingEnabled()) { setSpeakerphoneOn(false); } <|endfocus|> CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState();
code_review:  no need to do this. At this stage setSpeakerphoneOn(true/false) should not be called as this only applies to in call state. Hall, Why was it called in the first place? Is it a way to reset speakerphone state before starting the call? 
target code: public void enter() { super.enter(); setSpeakerphoneOn(false); // Do not enable SCO audio here, since RING is being sent to the headset. CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState();
response: public void enter() { super.enter(); if (!mBluetoothRouteManager.isInbandRingingEnabled()) { setSpeakerphoneOn(false); } CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState(); }

sample: 51
buggy_code:  * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { <|startfocus|> return iccOpenLogicalChannel(getSubId(), AID, (byte) 0x00); <|endfocus|> } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00
code_review:  this is ok as long as the behavior is going to be the same as earlier when API didn't have p2 as a parameter. 
target code: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { return iccOpenLogicalChannel(getSubId(), AID, -1); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00
response: /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { return iccOpenLogicalChannel(getSubId(), AID, (byte) 0x00); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); }

sample: 52
buggy_code:  private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); <|startfocus|> // Use 16 bits of the hashCode of the interface name as the Subnet ID. final IpPrefix local64 = getUniqueLocalPrefix(ulp, (short) ifname.hashCode(), 64); <|endfocus|> lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp;
code_review:  16 bits might not be long enough to ensure no collisions. If we currently only support one downstream, then you could use 0 everywhere. If not, then perhaps this code should keep state? 
target code: private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); final IpPrefix local64 = getUniqueLocalPrefix(ulp, subnetId, 64); lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp;
response: private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); // Use 16 bits of the hashCode of the interface name as the Subnet ID. final IpPrefix local64 = getUniqueLocalPrefix(ulp, (short) ifname.hashCode(), 64); lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp; }

sample: 53
buggy_code:  private int mEvdoDbm; // This value is the EVDO RSSI value private int mEvdoEcio; // This value is the EVDO Ec/Io private int mEvdoSnr; // Valid values are 0-8. 8 is the highest signal to noise ratio private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; <|startfocus|> private int mLteOffset; // offset to be reduced from the rsrp threshold while calculating // signal strength level <|endfocus|> private int mTdScdmaRscp; private boolean isGsm; // This value is set by the ServiceStateTracker onSignalStrengthResult /** * Create a new SignalStrength from a intent notifier Bundle * * This method is used by PhoneStateIntentReceiver and maybe by * external applications. * * @param m Bundle from intent notifier * @return newly created SignalStrength * * @hide */ public static SignalStrength newFromBundle(Bundle m) { SignalStrength ret; ret = new SignalStrength(); ret.setFromNotifierBundle(m);
code_review:  mLteRsrpOffset. Actually not too happy with Offset either - it doesn't give an indication of direction. If a positive number here is better would this be an mLteRsrpBoost? 
target code: private int mEvdoDbm; // This value is the EVDO RSSI value private int mEvdoEcio; // This value is the EVDO Ec/Io private int mEvdoSnr; // Valid values are 0-8. 8 is the highest signal to noise ratio private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; private int mLteRsrpBoost; // offset to be reduced from the rsrp threshold while calculating // signal strength level private int mTdScdmaRscp; private boolean isGsm; // This value is set by the ServiceStateTracker onSignalStrengthResult /** * Create a new SignalStrength from a intent notifier Bundle * * This method is used by PhoneStateIntentReceiver and maybe by * external applications. * * @param m Bundle from intent notifier * @return newly created SignalStrength * * @hide */ public static SignalStrength newFromBundle(Bundle m) { SignalStrength ret; ret = new SignalStrength(); ret.setFromNotifierBundle(m);
response: private int mEvdoDbm; private int mEvdoEcio; private int mEvdoSnr; private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; private int mLteOffset; private int mTdScdmaRscp; private boolean isGsm; public static SignalStrength newFromBundle(Bundle m) { SignalStrength ret; ret = new SignalStrength(); ret.setFromNotifierBundle(m); return ret; }

sample: 54
buggy_code: <|startfocus|> public void setLteOffset(int lteOffset) { mLteOffset = lteOffset; <|endfocus|>
code_review:  setLteRsrpOffset? 
target code: public void setLteRsrpBoost(int lteRsrpBoost) { mLteRsrpBoost = lteRsrpBoost;
response: public void setLteRsrpOffset(int lteRsrpOffset) { mLteRsrpOffset = lteRsrpOffset; }

sample: 55
buggy_code:  */ int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray( com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal."); } else { if (mLteRsrp > threshRsrp[5]) { rsrpIconLevel = -1; <|startfocus|> } else if (mLteRsrp >= (threshRsrp[4] - mLteOffset)) { <|endfocus|> rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } else if (mLteRsrp >= (threshRsrp[3] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_GOOD; } else if (mLteRsrp >= (threshRsrp[2] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_MODERATE; } else if (mLteRsrp >= (threshRsrp[1] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_POOR; } else if (mLteRsrp >= threshRsrp[0]) {
code_review:  are you certain this is what's desired? It would be nice if the offset applied throughout the range, but you're still keeping the upper and lower ends fixed which makes this more complicated. 
target code: */ int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray( com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal."); } else { if (mLteRsrp > threshRsrp[5]) { rsrpIconLevel = -1; } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) { rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } else if (mLteRsrp >= (threshRsrp[3] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_GOOD; } else if (mLteRsrp >= (threshRsrp[2] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_MODERATE; } else if (mLteRsrp >= (threshRsrp[1] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_POOR; } else if (mLteRsrp >= threshRsrp[0]) {
response: int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal."); } else { if (mLteRsrp > threshRsrp[5]) { rsrpIconLevel = -1; } else if (mLteRsrp >= (threshRsrp[4] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } else if (mLteRsrp >= (threshRsrp[3] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_GOOD; } else if (mLteRsrp >= (threshRsrp[2] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_MODERATE; } else if (mLteRsrp >= (threshRsrp[1] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_POOR; } else if (mLteRsrp >= threshRsrp[0]) { rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN; } }

sample: 56
buggy_code:  "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * List of EARFCN ranges on which signal_strength_offset_int will be applied. <|startfocus|> * Format of the String array is expected to be {"erafcn1_start", earfcn1_end", * "earfcn2_start", "earfcn2_end" ... } <|endfocus|> * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
code_review:  I thought the format was going to be "start-end" for each string in the array. 
target code: "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * List of EARFCN ranges on which signal_strength_offset_int will be applied. * Format of the String array is expected to be {"erafcn1_start-earfcn1_end", * "earfcn2_start-earfcn2_end" ... } * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
response: "notify_international_call_on_wfc_bool"; public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); }

sample: 57
buggy_code:  * @return error a {@code TETHER_ERROR} value indicating success or failure type * * {@hide} */ public int setUsbTethering(boolean enable) { try { return mService.setUsbTethering(enable); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /** * Request that a local-only Wi-Fi hotspot be started. The supplied Wi-Fi <|startfocus|> * configuration will be used after switch to station mode (STA), and must * be non-null. <|endfocus|> * * Local-only Wi-Fi hotspot functionality is currently mutually exclusive * with other tethering functionality. * * @param cfg The {@link android.net.wifi.WifiConfiguration} to use. * @return error a {@code TETHER_ERROR} value indicating success or failure * * @hide */ public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { try { return mService.startLocalOnlyWifiHotspot(cfg); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /**
code_review:  this is confusing... something like "to start the wifi hotspot" ? 
target code: * @return error a {@code TETHER_ERROR} value indicating success or failure type * * {@hide} */ public int setUsbTethering(boolean enable) { try { return mService.setUsbTethering(enable); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /** * Request that a local-only Wi-Fi hotspot be started. The supplied Wi-Fi * configuration is used to start the Wi-Fi hotspot, and must be non-null. * * Local-only Wi-Fi hotspot functionality is currently mutually exclusive * with other tethering functionality. * * @param cfg The {@link android.net.wifi.WifiConfiguration} to use. * @return error a {@code TETHER_ERROR} value indicating success or failure * * @hide */ public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { try { return mService.startLocalOnlyWifiHotspot(cfg); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /**
response: public int startWifiHotspot(WifiConfiguration cfg) { try { return mService.startLocalOnlyWifiHotspot(cfg); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }

sample: 58
buggy_code:  public void getFirmwareRoamingInfo() { <|startfocus|> reset(mWifiConnectivityHelper); <|endfocus|> mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo();
code_review:  a more accurate name here would be helpful. verifyGetFirmwareRoamingInfoIsCalledWhenWifiEnabled() (it is long, but you get the point - otherwise this might be a helper of some sort) 
target code: public void getFirmwareRoamingInfo() { reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo();
response: public void verifyGetFirmwareRoamingInfoIsCalledWhenWifiEnabled() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); }

sample: 59
buggy_code:  // SSID as the one to be selected. WifiConfiguration currentNetwork = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); <|startfocus|> verify(mWifiStateMachine).startRoamToNetwork( anyInt(), anyObject()); <|endfocus|>
code_review:  this can either fit on one line or, better yet, check the int and config. make sure you get the right values. 
target code: // SSID as the one to be selected. WifiConfiguration currentNetwork = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine).startRoamToNetwork(eq(CANDIDATE_NETWORK_ID), mCandidateScanResultCaptor.capture()); assertEquals(mCandidateScanResultCaptor.getValue().BSSID, CANDIDATE_BSSID);
response: // Set up current network configuration WifiConfiguration currentNetwork = generateWifiConfig(0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Verify that startRoamToNetwork is called with the correct parameters verify(mWifiStateMachine).startRoamToNetwork(anyInt(), anyObject());

sample: 60
buggy_code:  public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); <|startfocus|> verify(mWifiStateMachine, times(0)).startRoamToNetwork( anyInt(), anyObject()); <|endfocus|>
code_review:  does this actually check the right thing? you are connected.. but does it know the correct network? I am not as familiar with this test, but it seems like you might not call this anyway. 
target code: public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject());
response: public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject()); }

sample: 61
buggy_code:  * 6. "San Francisco" location card opens. * 7. Select "San Francisco". * 8. Tap on the Drive icon. * Verify: * 1. Map points to San Francisco location. * 2. Navigation overview is displayed. * </pre> */ @Test @TestInfo(id = "145493594") public void testMapsApp() throws Exception { <|startfocus|> String QUERY_STRING = "San Francisco"; <|endfocus|> Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); AppLauncher.launch(instrumentation, "Maps"); UiObject acceptButton = mDevice.findObject(new UiSelector().textContains("ACCEPT & CONTINUE")); // "Accept & Continue" occurs only on first time Maps gets launched. if (acceptButton.exists()) { acceptButton.clickAndWaitForNewWindow(); } // SKIP button only exist's occurs only on first time Maps gets launched. UiObject skipText = mDevice.findObject(new UiSelector().textContains("SKIP")); if (skipText.exists()) {
code_review:  Move to class's constants (private static final) 
target code: * 6. "San Francisco" location card opens. * 7. Select "San Francisco". * 8. Tap on the Drive icon. * Verify: * 1. Map points to San Francisco location. * 2. Navigation overview is displayed. * </pre> */ @Test @TestInfo(id = "145493594") public void testMapsApp() throws Exception { Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); AppLauncher.launch(instrumentation, "Maps"); UiObject acceptButton = mDevice.findObject(new UiSelector().textContains("ACCEPT & CONTINUE")); // "Accept & Continue" occurs only on first time Maps gets launched. if (acceptButton.exists()) { acceptButton.clickAndWaitForNewWindow(); } // SKIP button only exist's occurs only on first time Maps gets launched. UiObject skipText = mDevice.findObject(new UiSelector().textContains("SKIP")); if (skipText.exists()) {
response: import com.intellij.openapi.diagnostic.Logger; import com.intellij.openapi.progress.ProgressIndicator; import com.intellij.openapi.progress.Task; import com.intellij.openapi.ui.Messages; import org.jetbrains.annotations.NotNull; import java.io.IOException; import java.util.concurrent.atomic.AtomicReference; public class SampleImportAction extends AnAction { private static final Logger LOG = Logger.getInstance(SampleImportAction.class); @Override public void actionPerformed(AnActionEvent e) { final SamplesIndex samplesService; SamplesIndex.Builder myBuilder = new SamplesIndex.Builder(new NetHttpTransport(), new JacksonFactory(), null); samplesService = myBuilder.build(); final AtomicReference<SampleCollection> sampleList = new AtomicReference<SampleCollection>(null); new Task.Modal(null, GctBundle.message("sample.import.title"), false) { @Override public void run(@NotNull ProgressIndicator indicator) { try { sampleList.set(samplesService.list()); } catch (IOException e) { LOG.error("Failed to retrieve sample list", e); Messages.showErrorDialog("Failed to retrieve sample list", "Sample Import"); } } }.queue(); } }

sample: 62
buggy_code:  scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. UiObject searchTextView = searchUiObject.getChild(new UiSelector().className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); <|startfocus|> } else{ <|endfocus|> searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); } 
code_review:  nit: add a space 
target code: scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. UiObject searchTextView = searchUiObject.getChild(new UiSelector().className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); } else { searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); }
response: scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. UiObject searchTextView = searchUiObject.getChild(new UiSelector() .className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); } else { searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); }

sample: 63
buggy_code:  private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = <|startfocus|> "com.google.android.clockwork.cmas.intent.extra.ID"; <|endfocus|> @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver())
code_review:  since we are moving from wear, should we also use the new namespace? 
target code: private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.android.cellbroadcastreceiver.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver())
response: private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.google.android.clockwork.cmas.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) { log("onReceive " + intent); } String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()); } }

sample: 64
buggy_code:  protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); <|startfocus|> final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); <|endfocus|> if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
code_review:  consider moving this down to the if block. 
target code: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
response: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done. } }

sample: 65
buggy_code:  protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); <|startfocus|> if (ACTION_MARK_AS_READ.equals(action)) { <|endfocus|> new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
code_review:  do you need to register in the manifest? 
target code: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
response: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done. } }

sample: 66
buggy_code:  /** Intent action to display alert dialog/notification, after verifying the alert is new. */ static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; /** Use the same notification ID for non-emergency alerts. */ static final int NOTIFICATION_ID = 1; /** Sticky broadcast for latest area info broadcast received. */ static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; <|startfocus|> /** * Intent extra */ <|endfocus|> private static final String EXTRA_MESSAGE = "message"; /** * Container for service category, serial number, location, body hash code, and ETWS primary/ * secondary information for duplication detection. */ private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory;
code_review:  nit: probably one line since others above follow that format? Also, should probably add some description, e.g. something like: "Intent extra for passing an SmsCbMessage" 
target code: /** Intent action to display alert dialog/notification, after verifying the alert is new. */ static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; /** Use the same notification ID for non-emergency alerts. */ static final int NOTIFICATION_ID = 1; /** Sticky broadcast for latest area info broadcast received. */ static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; /** Intent extra for passing a SmsCbMessage */ private static final String EXTRA_MESSAGE = "message"; /** * Container for service category, serial number, location, body hash code, and ETWS primary/ * secondary information for duplication detection. */ private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory;
response: /** Intent action to display alert dialog/notification, after verifying the alert is new. */ static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; /** Use the same notification ID for non-emergency alerts. */ static final int NOTIFICATION_ID = 1; /** Sticky broadcast for latest area info broadcast received. */ static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; /** Intent extra for passing an SmsCbMessage */ private static final String EXTRA_MESSAGE = "message"; /** Container for service category, serial number, location, body hash code, and ETWS primary/secondary information for duplication detection. */ private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory; mSerialNumber = serialNumber; mLocation = location; mBodyHash = bodyHash; mIsEtwsPrimary = isEtwsPrimary; } }

sample: 67
buggy_code:  ArrayList<CellBroadcastMessage> messageList, Context context, boolean fromSaveState) { int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); // Create intent to show the new messages when user selects the notification. Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { <|startfocus|> // For wear we want to mark as read intent = createWearDeleteIntent(context, message.getDeliveryTime()); <|endfocus|> } else { // For phone we handle it differently intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent,
code_review:  nit: Wear 
target code: ArrayList<CellBroadcastMessage> messageList, Context context, boolean fromSaveState) { int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); // Create intent to show the new messages when user selects the notification. Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { // For FEATURE_WATCH we want to mark as read intent = createMarkAsReadIntent(context, message.getDeliveryTime()); } else { // For phone we handle it differently intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent,
response: ArrayList<CellBroadcastMessage> messageList, Context context, boolean fromSaveState) { int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); // Create intent to show the new messages when user selects the notification. Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { intent = createWearDeleteIntent(context, message.getDeliveryTime()); } else { intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT); } // Build and show the notification. NotificationCompat.Builder builder = new NotificationCompat.Builder(context) .setSmallIcon(R.drawable.ic_warning) .setContentTitle(channelName) .setContentText(messageBody) .setStyle(new NotificationCompat.BigTextStyle().bigText(messageBody)) .setContentIntent(pi) .setAutoCancel(true) .setPriority(NotificationCompat.PRIORITY_HIGH); NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context); notificationManager.notify(NOTIFICATION_ID, builder.build()); }

sample: 68
buggy_code: <|startfocus|> static Intent createWearDeleteIntent(Context context, long deliveryTime) { <|endfocus|> Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent;
code_review:  hmm, lets name createMarkAsReadIntent? Can probably leave Wear out since it could possibly be used in other contexts. 
target code: static Intent createMarkAsReadIntent(Context context, long deliveryTime) { Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent;
response: static Intent createMarkAsReadIntent(Context context, long deliveryTime) { Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent; }

sample: 69
buggy_code:  /** * @hide */ public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; /** * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if, for example, netd dies and is restarted. <|startfocus|> * <|endfocus|> * @return an INetd instance or null. */ public static INetd getInstance() { // NOTE: ServiceManager does no caching for the netd service, // because netd is not one of the defined common services. final INetd netdInstance = INetd.Stub.asInterface( ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. *
code_review:  comment that INetd should never be cached outside of this interface? 
target code: /** * @hide */ public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; /** * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if, for example, netd dies and is restarted. * * Returned instances of INetd should not be cached. * * @return an INetd instance or null. */ public static INetd getInstance() { // NOTE: ServiceManager does no caching for the netd service, // because netd is not one of the defined common services. final INetd netdInstance = INetd.Stub.asInterface( ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. *
response: /** * @hide */ public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; public static INetd getInstance() { final INetd netdInstance = INetd.Stub.asInterface( ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } }

sample: 70
buggy_code:  if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. * * It is the caller's responsibility to handle RemoteException errors * from invocations on the returned interface if, for example, netd * dies after this interface was returned. * * Returned instances of INetd should not be cached. * * @return an INetd instance or null. */ <|startfocus|> public static INetd get() { for (int i = 0; ; i++) { <|endfocus|> final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } } 
code_review:  Can this actually happen ? It looks like the loop goes on until getInstance is not null. 
target code: if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. * * It is the caller's responsibility to handle RemoteException errors * from invocations on the returned interface if, for example, netd * dies after this interface was returned. * * Returned instances of INetd should not be cached. * * @return an INetd instance or null. */ public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; for (int i = 0; i > -1; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } }
response: public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } }

sample: 71
buggy_code:  public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); <|startfocus|> } catch (InterruptedException e) {} <|endfocus|> }
code_review:  Is the timeout arithmetics needed for doing linear backoff ? I would like to suggest the following alternative that does not include arithmetics per say, or at least less of it: timeoutMs = BASE_TIME_MS; while (true) { ... Thread.sleep(timeoutMs); timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); } 
target code: public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; }
response: public static INetd get() { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); } }

sample: 72
buggy_code: <|startfocus|> void run(INetd netd) throws RemoteException, ServiceSpecificException; <|endfocus|> } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */
code_review:  ServiceSpecificException is a runtime exception, no need to declare it in the signature (it doesn't really have any effect because callers don't have to catch). 
target code: void run(INetd netd) throws RemoteException; } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */
response: void run(INetd netd) throws RemoteException; } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */

sample: 73
buggy_code:  void run(INetd netd) throws RemoteException, ServiceSpecificException; } /** * Blocks until an INetd instance is availabe, and retries until either <|startfocus|> * the command succeeds or a ServiceSpecificError is thrown. <|endfocus|> */
code_review:  -> runtime 
target code: void run(INetd netd) throws RemoteException, ServiceSpecificException; } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a runtime exception is thrown. */
response: import android.os.RemoteException; import android.os.ServiceSpecificException; public interface INetdRunner { void run(INetd netd) throws RemoteException, ServiceSpecificException; } /** * Blocks until an INetd instance is available, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */ public class NetdRunner implements INetdRunner { @Override public void run(INetd netd) throws RemoteException, ServiceSpecificException { // Implementation goes here } }

sample: 74
buggy_code:  public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; <|startfocus|> } catch (RemoteException re) {} <|endfocus|> }
code_review:  Is this a good idea to pass in INed to cmd even if it is null ? With the current usage in IpManager, this immediately triggers an NPE that's not caught. That seemed to be the case before, but if I understand correctly this patch tries to correct this issue right ? I suggest: INetd netd = get(); if (netd == null) { continue; } cmd.run(netd) (this is assuming that get() can indeed returns null based on its doc) 
target code: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "error communicated with netd: " + re); } }
response: public static void run(NetdCommand cmd) { while (true) { try { INetd netd = get(); if (netd == null) { continue; } cmd.run(netd); return; } catch (RemoteException re) { } } }

sample: 75
buggy_code:  public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; <|startfocus|> } catch (RemoteException re) {} <|endfocus|> }
code_review:  Shouldn't the error be logged ? 
target code: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "error communicated with netd: " + re); } }
response: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { logger.error("RemoteException occurred while running command", re); } } }

sample: 76
buggy_code:  ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); } @TimeoutReq(minutes = 80) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } <|startfocus|> final int NUMBER_REPETITION = 6; <|endfocus|> FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis();
code_review:  let's reduce this to 3. A test taking over hour is not ok. 
target code: ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); } @TimeoutReq(minutes = 80) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } final int NUMBER_REPETITION = 3; FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis();
response: ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); @TimeoutReq(minutes = 80) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } final int NUMBER_REPETITION = 3; FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis(); }

sample: 77
buggy_code:  private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { /** <|startfocus|> * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are managed <|endfocus|> * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); // If a configuration is temporarily disabled, re-enable it before trying // to connect to it. mWifiConfigManager.tryEnableNetwork(network.networkId); //TODO(b/30928589): Enable "permanently" disabled networks if we are in DISCONNECTED // state. // Clear the cached candidate, score and seen. mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId); 
code_review:  Extra white space? 
target code: private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { /** * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are managed * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); // If a configuration is temporarily disabled, re-enable it before trying // to connect to it. mWifiConfigManager.tryEnableNetwork(network.networkId); //TODO(b/30928589): Enable "permanently" disabled networks if we are in DISCONNECTED // state. // Clear the cached candidate, score and seen. mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId);
response: private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); mWifiConfigManager.tryEnableNetwork(network.networkId); mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId); } }

sample: 78
buggy_code:  List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration == null) { continue; } else { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { /** <|startfocus|> * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are being evaluated <|endfocus|> * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (!status.isNetworkEnabled()) { continue; } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate.
code_review:  Nit: extra white space? 
target code: List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration == null) { continue; } else { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { /** * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are being evaluated * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (!status.isNetworkEnabled()) { continue; } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate.
response: List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration == null) { continue; } else { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (!status.isNetworkEnabled()) { continue; } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate. } }

sample: 79
buggy_code:  "am stack move-top-activity-to-pinned-stack 1 0 0 500 500"; protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; <|startfocus|> private static final String AM_NO_HOME_SCREEN = "am no-home-screen"; <|endfocus|> private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; /** A reference to the device under test. */ protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) {
code_review:  is this am command already supported in the aosp ? 
target code: "am stack move-top-activity-to-pinned-stack 1 0 0 500 500"; protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; /** A reference to the device under test. */ protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) {
response: protected static final String AM_NO_HOME_SCREEN = "am no-home-screen"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) { return "com.example.package/" + activityName; }

sample: 80
buggy_code:  public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { <|startfocus|> if (mMode == Mode.LOCAL_HOTSPOT) { <|endfocus|> if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
code_review:  We probably need to check for mode being TETHERING here. 
target code: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { final Mode current = mMode; if (current != Mode.IDLE) { if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
response: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true); }

sample: 81
buggy_code:  public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { <|startfocus|> Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); <|endfocus|> } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
code_review:  Nit: "Local hotspot already started"? 
target code: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Already in mode: " + current.description); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
response: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot already started"); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true); }

sample: 82
buggy_code:  public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { if (VDBG) { <|startfocus|> Log.e(TAG, "Attempt to stopLocalOnlyWifiHotspot absent corresponding start."); <|endfocus|> } return; } setWifiTethering(null, false);
code_review:  "Local hotspot not running"? 
target code: public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot not running."); } return; } setWifiTethering(null, false);
response: public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { Log.e(TAG, "Local hotspot not running. Attempt to stopLocalOnlyWifiHotspot absent corresponding start."); return; } setWifiTethering(null, false); }

sample: 83
buggy_code:  protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode == Mode.TETHERING) { try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } <|startfocus|> } else { // Reset to tethering mode (default mode). mMode = Mode.TETHERING; <|endfocus|> } transitionTo(mInitialState); return true;
code_review:  I would say put it unconditionally after the if branch if this is a condition that needs to be ensured. 
target code: protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode == Mode.TETHERING) { try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } } transitionTo(mInitialState); return true;
response: protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode == Mode.TETHERING) { try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } } // Reset to tethering mode (default mode). mMode = Mode.TETHERING; transitionTo(mInitialState); return true; }

sample: 84
buggy_code: import java.util.Random; /** * IPv6 tethering is rather different from IPv4 owing to the absence of NAT. * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces. * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; <|startfocus|> private static class DownstreamState { <|endfocus|> public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<DownstreamState> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>();
code_review:  Nit: "drop the State, it's cleaner"? 
target code: import java.util.Random; /** * IPv6 tethering is rather different from IPv4 owing to the absence of NAT. * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces. * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class Downstream { public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<DownstreamState> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>();
response: import java.util.Random; public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class Downstream { public final TetherInterfaceStateMachine tism; public final short subnetId; Downstream(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<Downstream> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); } }

sample: 85
buggy_code:  */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class DownstreamState { public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; <|startfocus|> private final LinkedList<DownstreamState> mActiveDownstreams; <|endfocus|> private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect.
code_review:  Nit: could/should this be a Map from subnet ID to TetherInterfaceStateMachine? If so I think you would't need the DownstreamState class. Equivalently it could be a SparseArray keyed off subnet ID But this is fine too. 
target code: */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class DownstreamState { public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<Downstream> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect.
response: public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<TetherInterfaceStateMachine> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { mActiveDownstreams.add(downstream); } } private TetherInterfaceStateMachine findDownstream(TetherInterfaceStateMachine downstream) { for (TetherInterfaceStateMachine stateMachine : mActiveDownstreams) { if (stateMachine.equals(downstream)) { return stateMachine; } } return null; } }

sample: 86
buggy_code:  public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. <|startfocus|> mActiveDownstreams.offer(new DownstreamState(downstream, mNextSubnetId++)); <|endfocus|> updateIPv6TetheringInterfaces(); }
code_review:  Do you need to do something when mNextSubnetId goes from 32767 to -32768? 
target code: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId++)); updateIPv6TetheringInterfaces(); }
response: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { mActiveDownstreams.offer(new DownstreamState(downstream, mNextSubnetId++)); updateIPv6TetheringInterfaces(); } }

sample: 87
buggy_code:  private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; // 6 = 48bits / 8bits/byte (new Random()).nextBytes(ulp); <|startfocus|> final byte[] in6addr = new byte[NetworkConstants.IPV6_ADDR_LEN]; System.arraycopy(ulp, 0, in6addr, 0, ulp.length); <|endfocus|> in6addr[0] = (byte) 0xfd; // fc00::/7 and L=1 return in6addr;
code_review:  I think it can be folded into: Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN) that would return an array of length NetworkConstants.IPV6_ADDR_LEN padded with 0s. 
target code: private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; // 6 = 48bits / 8bits/byte (new Random()).nextBytes(ulp); final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN); in6addr[0] = (byte) 0xfd; // fc00::/7 and L=1 return in6addr;
response: private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; (new Random()).nextBytes(ulp); final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN); in6addr[0] = (byte) 0xfd; return in6addr; }

sample: 88
buggy_code:  ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); // The filter for the time event. ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); // Run the activity. mContext.startActivity(intent, options.toBundle()); // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { <|startfocus|> // At this time the timerReceiver should not fire, even though the activity has shut <|endfocus|> // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the reciever then.
code_review:  nit: whitespace 
target code: ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); // The filter for the time event. ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); // Run the activity. mContext.startActivity(intent, options.toBundle()); // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the reciever then.
response: ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); mContext.startActivity(intent, options.toBundle()); assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent);

sample: 89
buggy_code:  private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; /* Used only for debugging purposes. */ private String mRegistrationDeniedReason; private String mCurrentCarrier = null; /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) <|startfocus|> * pairs for which the lte rsrp boost is applied */ <|endfocus|> private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. private final Object mLteRsrpBoostLock = new Object(); // mLteRsrpBoost lock public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable);
code_review:  range. Also is it inclusive? Inclusiveness should also appear in the carrierconfig comments. 
target code: private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; /* Used only for debugging purposes. */ private String mRegistrationDeniedReason; private String mCurrentCarrier = null; /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) * inclusive ranges for which the lte rsrp boost is applied */ private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. private final Object mLteRsrpBoostLock = new Object(); // mLteRsrpBoost lock public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable);
response: private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; private String mRegistrationDeniedReason; private String mCurrentCarrier = null; private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; private final Object mLteRsrpBoostLock = new Object(); public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); }

sample: 90
buggy_code:  /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) * pairs for which the lte rsrp boost is applied */ private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. <|startfocus|> private final Object mLteRsrpBoostLock = new Object(); // mLteRsrpBoost lock <|endfocus|> public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance();
code_review:  don't need (it's the name..) 
target code: /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) * pairs for which the lte rsrp boost is applied */ private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. private final Object mLteRsrpBoostLock = new Object(); private static final int INVALID_LTE_EARFCN = -1; public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance();
response: private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; private final Object mLteRsrpBoostLock = new Object(); public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance(); }

sample: 91
buggy_code:  && ServiceState.isCdma(newDataRat))) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (DBG) { log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } <|startfocus|> updateLteEarfcnBoost(getLteEarfcn(dataRegStateResult)); <|endfocus|> break; } case EVENT_POLL_STATE_OPERATOR: { if (mPhone.isPhoneTypeGsm()) { String opNames[] = (String[]) ar.result; if (opNames != null && opNames.length >= 3) { // FIXME: Giving brandOverride higher precedence, is this desired? String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null; if (brandOverride != null) {
code_review:  pass in ServiceState so it's clear what's getting updated. The name doesn't suggested mNewSS is altered. 
target code: && ServiceState.isCdma(newDataRat))) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (DBG) { log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult)); break; } case EVENT_POLL_STATE_OPERATOR: { if (mPhone.isPhoneTypeGsm()) { String opNames[] = (String[]) ar.result; if (opNames != null && opNames.length >= 3) { // FIXME: Giving brandOverride higher precedence, is this desired? String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null; if (brandOverride != null) {
response: private void updateLteEarfcnBoost(ServiceState serviceState) { int dataRegStateResult = serviceState.getDataRegState(); int newDataRat = serviceState.getDataNetworkType(); if (ServiceState.isLte(dataRegStateResult) && ServiceState.isCdma(newDataRat)) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (DBG) { log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } updateLteEarfcnBoost(getLteEarfcn(dataRegStateResult)); } private void handlePollStateOperator(String[] opNames) { if (mPhone.isPhoneTypeGsm()) { if (opNames != null && opNames.length >= 3) { String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null; if (brandOverride != null) { // handle brand override } else { // handle normal operator names } } } else { // handle CDMA operator names } }

sample: 92
buggy_code:  private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if ((lteEarfcn != -1) && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { <|startfocus|> mNewSS.setLteEarfcnRsrpBoost(mLteRsrpBoost); <|endfocus|> } else { mNewSS.setLteEarfcnRsrpBoost(0); } }
code_review:  this should be a defined constant used here and in getLteEarfcn when not found. 
target code: private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if ((lteEarfcn != -1) && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { serviceState.setLteEarfcnRsrpBoost(mLteRsrpBoost); } else { mNewSS.setLteEarfcnRsrpBoost(0); } }
response: private static final int LTE_EARFCN_NOT_FOUND = -1; private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if (lteEarfcn != LTE_EARFCN_NOT_FOUND && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { mNewSS.setLteEarfcnRsrpBoost(mLteRsrpBoost); } else { mNewSS.setLteEarfcnRsrpBoost(0); } } }

sample: 93
buggy_code:  && mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if(conn != null) { <|startfocus|> conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); <|endfocus|> } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo); }
code_review:  Wrap to 100 chars. 
target code: && mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if(conn != null) { conn.setPreciseDisconnectCause( getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo); }
response: public void methodName() { if (condition1 && condition2 && mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if (conn != null) { conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo); }

sample: 94
buggy_code:  * onFeatureCapabilityChanged(int, int[], int[])} callbacks, or values received via the * {@link ImsCallProfile#EXTRA_CALL_RAT_TYPE} extra. Util we receive a value via the extras, * we will use the wifi state based on the {@code onFeatureCapabilityChanged}. Once a value * is received via the extras, we will prefer those values going forward. */ private boolean mIsWifiStateFromExtras = false; <|startfocus|> private int mPreciseCause = 0; <|endfocus|> //***** Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; //***** Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60*1000; //***** Inner Classes class MyHandler extends Handler {
code_review:  mPreciseDisconnectCause 
target code: * onFeatureCapabilityChanged(int, int[], int[])} callbacks, or values received via the * {@link ImsCallProfile#EXTRA_CALL_RAT_TYPE} extra. Util we receive a value via the extras, * we will use the wifi state based on the {@code onFeatureCapabilityChanged}. Once a value * is received via the extras, we will prefer those values going forward. */ private boolean mIsWifiStateFromExtras = false; private int mPreciseDisconnectCause = 0; //***** Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; //***** Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60*1000; //***** Inner Classes class MyHandler extends Handler {
response: private int mPreciseDisconnectCause = 0; //***** Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; //***** Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60 * 1000; //***** Inner Classes class MyHandler extends Handler { // handler implementation }

sample: 95
buggy_code:  /** Not a preempted call */ public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state <|startfocus|> public static final int ILLEGAL_STATE = 1201; <|endfocus|> // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206;
code_review:  ImsReasonInfo is CODE_LOCAL_ILLEGAL_ARGUMENT. Should we keep the LOCAL part? 
target code: /** Not a preempted call */ public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int LOCAL_ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206;
response: public static final int CDMA_PREEMPTED = 1007; public static final int CDMA_NOT_EMERGENCY = 1008; public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206;

sample: 96
buggy_code:  public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error <|startfocus|> public static final int INTERNAL_ERROR = 1202; <|endfocus|> // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state)
code_review:  ImsReasonInfo is CODE_LOCAL_ILLEGAL_STATE. Should we keep the LOCAL part? 
target code: public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int LOCAL_INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state)
response: public static final int CDMA_PREEMPTED = 1007; public static final int CDMA_NOT_EMERGENCY = 1008; public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206;

sample: 97
buggy_code:  /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) <|startfocus|> public static final int IMS_SERVICE_DOWN = 1203; <|endfocus|> // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered)
code_review:  Should we keep the LOCAL part (similar to ImsReasonInfo)? 
target code: /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int LOCAL_IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered)
response: public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206; public static final int NETWORK_NO_SERVICE = 1207;

sample: 98
buggy_code:  public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off <|startfocus|> public static final int POWER_OFF = 1205; <|endfocus|> // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered) */ public static final int NETWORK_NO_LTE_COVERAGE = 1208; /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209;
code_review:  Should we keep the "LOCAL" prefix similar to in ImsReasonInfo? 
target code: public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int LOCAL_POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered) */ public static final int NETWORK_NO_LTE_COVERAGE = 1208; /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209;
response: public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206; public static final int NETWORK_NO_SERVICE = 1207; public static final int NETWORK_NO_LTE_COVERAGE = 1208; public static final int NETWORK_ROAMING = 1209;

sample: 99
buggy_code:  /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209; /** Service unavailable; by IP changed */ public static final int NETWORK_IP_CHANGED = 1210; /** Service unavailable; other */ public static final int SERVICE_UNAVAILABLE = 1211; /* Service unavailable; IMS connection is lost (IMS is not registered) */ public static final int NOT_REGISTERED = 1212; /** Max call exceeded */ <|startfocus|> public static final int CALL_EXCEEDED = 1213; <|endfocus|> /** Call decline */ public static final int LOCAL_CALL_DECLINE = 1214; /** SRVCC is in progress */ public static final int VCC_ON_PROGRESSING = 1215; /** Resource reservation is failed (QoS precondition) */ public static final int RESOURCE_RESERVATION_FAILED = 1216; /** Retry CS call; VoLTE service can't be provided by the network or remote end * Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set */
code_review:  I'm curious, the ImsReasonInfo version of this (and some others) is LOCAL_CALL_EXCEEDED; does it make sense to call this one LOCAL_CALL_EXCEEDED as well? This is especially confusing when you consider MAXIMUM_NUMBER_OF_CALLS_REACHED, which is used for multi-endpoint. Suggest: MAX_LOCAL_CALLS_EXCEEDED for this one? 
target code: /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209; /** Service unavailable; by IP changed */ public static final int NETWORK_IP_CHANGED = 1210; /** Service unavailable; other */ public static final int SERVICE_UNAVAILABLE = 1211; /* Service unavailable; IMS connection is lost (IMS is not registered) */ public static final int NOT_REGISTERED = 1212; /** Max call exceeded */ public static final int LOCAL_MAX_CALL_EXCEEDED = 1213; /** Call decline */ public static final int LOCAL_CALL_DECLINE = 1214; /** SRVCC is in progress */ public static final int VCC_ON_PROGRESSING = 1215; /** Resource reservation is failed (QoS precondition) */ public static final int RESOURCE_RESERVATION_FAILED = 1216; /** Retry CS call; VoLTE service can't be provided by the network or remote end * Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set */
response: /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209; /** Service unavailable; by IP changed */ public static final int NETWORK_IP_CHANGED = 1210; /** Service unavailable; other */ public static final int SERVICE_UNAVAILABLE = 1211; /* Service unavailable; IMS connection is lost (IMS is not registered) */ public static final int NOT_REGISTERED = 1212; /** Max call exceeded */ public static final int MAX_LOCAL_CALLS_EXCEEDED = 1213; /** Call decline */ public static final int LOCAL_CALL_DECLINE = 1214; /** SRVCC is in progress */ public static final int VCC_ON_PROGRESSING = 1215; /** Resource reservation is failed (QoS precondition) */ public static final int RESOURCE_RESERVATION_FAILED = 1216; /** Retry CS call; VoLTE service can't be provided by the network or remote end * Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set */

sample: 100
buggy_code:  public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) break; // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); <|startfocus|> if (maxTimeoutMs > 0) timeoutMs = Math.min(timeoutMs, maxTimeoutMs); <|endfocus|> try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; } return null;
code_review:  shouldn't the first sleep be equal to BASE_TIMEOUT_MS ? With this ordering it looks like timeoutMs should start at 0. 
target code: public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) break; // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; } return null;
response: public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) { break; } timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); if (maxTimeoutMs > 0) { timeoutMs = Math.min(timeoutMs, maxTimeoutMs); } try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) { maxTimeoutMs -= timeoutMs; } } return null; }

sample: 101
buggy_code:  public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) break; // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); <|startfocus|> if (maxTimeoutMs > 0) timeoutMs = Math.min(timeoutMs, maxTimeoutMs); <|endfocus|> try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; } return null;
code_review:  Shouldn't this maxTimeoutMs parameter apply to the total aggregated sleep time at the function level, not at the loop iteration level ? At the moment if a positive maxTimeoutMs is specified, the loop still runs until a non-null INetd returns. An alternative might be to manage maxTimeoutMs outside of the loop: if (maxTimeoutMs == 0) { return getInstance(); } long stop = SystemClock.elapsed() + maxTimeoutMs; (maxTimeoutMs < 0) { stop = Long.MAX_VALUE; } while(SystemClock.elapsed() < stop) { .. same as before but without maxTimeousMs management } 
target code: public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) break; // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; } return null;
response: public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) { break; } timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); if (maxTimeoutMs > 0) { timeoutMs = Math.min(timeoutMs, maxTimeoutMs); } try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) { maxTimeoutMs -= timeoutMs; } } return null; }

sample: 102
buggy_code:  public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; <|startfocus|> for (int i = 0; i > -1; i++) { <|endfocus|> final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) break; // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); if (maxTimeoutMs > 0) timeoutMs = Math.min(timeoutMs, maxTimeoutMs); try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; } return null;
code_review:  i is unused now. consider: while (true) 
target code: public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) break; // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); if (maxTimeoutMs > 0) timeoutMs = Math.min(timeoutMs, maxTimeoutMs); try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; } return null;
response: public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } if (maxTimeoutMs == 0) { break; } // No netdInstance was received; sleep and retry. timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); if (maxTimeoutMs > 0) { timeoutMs = Math.min(timeoutMs, maxTimeoutMs); } try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) { maxTimeoutMs -= timeoutMs; } } return null; }

sample: 103
buggy_code:  public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { <|startfocus|> Log.e(TAG, "error communicated with netd: " + re); <|endfocus|> } }
code_review:  communicating? 
target code: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "error communicating with netd: " + re); } }
response: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "Error communicating with netd: " + re); } } }

sample: 104
buggy_code:  private AuthenticatorHelper mAuthenticatorHelper; private BluetoothAdapter mBtAdapter; private ConnectivityListener mConnectivityListener; private boolean mInputSettingNeeded; private Preference mDeveloperPref; private PreferenceGroup mAccessoriesGroup; private PreferenceGroup mAccountsGroup; private Preference mAddAccessory; private Preference mNetworkPref; private Preference mSoundsPref; private final BroadcastReceiver mBCMReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { updateAccessories(); } }; <|startfocus|> private final BroadcastReceiver mBtConnectionReceiver = new BluetoothConnectionsManager(); <|endfocus|> public static MainFragment newInstance() { return new MainFragment(); } @Override public void onCreate(Bundle savedInstanceState) { mAuthenticatorHelper = new AuthenticatorHelper(getContext(), new UserHandle(UserHandle.myUserId()), new AuthenticatorHelper.OnAccountsUpdateListener() { @Override public void onAccountsUpdate(UserHandle userHandle) { updateAccounts(); } }); mBtAdapter = BluetoothAdapter.getDefaultAdapter(); mConnectivityListener = new ConnectivityListener(getContext(), new ConnectivityListener.Listener() { @Override
code_review:  This isn't going to compile. 
target code: private AuthenticatorHelper mAuthenticatorHelper; private BluetoothAdapter mBtAdapter; private ConnectivityListener mConnectivityListener; private boolean mInputSettingNeeded; private Preference mDeveloperPref; private PreferenceGroup mAccessoriesGroup; private PreferenceGroup mAccountsGroup; private Preference mAddAccessory; private Preference mNetworkPref; private Preference mSoundsPref; private final BroadcastReceiver mBCMReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { updateAccessories(); } }; public static MainFragment newInstance() { return new MainFragment(); } @Override public void onCreate(Bundle savedInstanceState) { mAuthenticatorHelper = new AuthenticatorHelper(getContext(), new UserHandle(UserHandle.myUserId()), new AuthenticatorHelper.OnAccountsUpdateListener() { @Override public void onAccountsUpdate(UserHandle userHandle) { updateAccounts(); } }); mBtAdapter = BluetoothAdapter.getDefaultAdapter(); mConnectivityListener = new ConnectivityListener(getContext(), new ConnectivityListener.Listener() { @Override
response: private AuthenticatorHelper mAuthenticatorHelper; private BluetoothAdapter mBtAdapter; private ConnectivityListener mConnectivityListener; private boolean mInputSettingNeeded; private Preference mDeveloperPref; private PreferenceGroup mAccessoriesGroup; private PreferenceGroup mAccountsGroup; private Preference mAddAccessory; private Preference mNetworkPref; private Preference mSoundsPref; private final BroadcastReceiver mBCMReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { updateAccessories(); } }; private final BroadcastReceiver mBtConnectionReceiver = new BluetoothConnectionsManager(); public static MainFragment newInstance() { return new MainFragment(); } @Override public void onCreate(Bundle savedInstanceState) { mAuthenticatorHelper = new AuthenticatorHelper(getContext(), new UserHandle(UserHandle.myUserId()), new AuthenticatorHelper.OnAccountsUpdateListener() { @Override public void onAccountsUpdate(UserHandle userHandle) { updateAccounts(); } }); mBtAdapter = BluetoothAdapter.getDefaultAdapter(); mConnectivityListener = new ConnectivityListener(getContext(), new ConnectivityListener.Listener() { @Override public void onConnectivityChanged(boolean isConnected) { updateConnectivity(isConnected); } }); mInputSettingNeeded = false; mDeveloperPref = findPreference(KEY_DEVELOPER_OPTIONS); mAccessoriesGroup = (PreferenceGroup) findPreference(KEY_ACCESSORIES); mAccountsGroup = (PreferenceGroup) findPreference(KEY_ACCOUNTS); mAddAccessory = findPreference(KEY_ADD_ACCESSORY); mNetworkPref = findPreference(KEY_NETWORK); mSoundsPref = findPreference(KEY_SOUNDS); } @Override public void onResume() { super.onResume(); getActivity().registerReceiver(mBCMReceiver, new IntentFilter(BluetoothManager.ACTION_CONNECTION_STATE_CHANGED)); getActivity().registerReceiver(mBtConnectionReceiver, new IntentFilter(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)); mConnectivityListener.startListening(); updateAccessories(); updateAccounts(); updateConnectivity(mConnectivityListener.isConnected()); } @Override public void onPause() { super.onPause(); getActivity().unregisterReceiver(mBCMReceiver); getActivity().unregisterReceiver(mBtConnectionReceiver); mConnectivityListener.stopListening(); } private void updateAccessories() { // Update accessories list } private void updateAccounts() { // Update accounts list } private void updateConnectivity(boolean isConnected) { // Update connectivity status

sample: 105
buggy_code:  public void onStart() { super.onStart(); mAuthenticatorHelper.listenToAccountUpdates(); IntentFilter btChangeFilter = new IntentFilter(); btChangeFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED); btChangeFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED); btChangeFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); <|startfocus|> getContext().registerReceiver(mBBCMReceiver, btChangeFilter); <|endfocus|>
code_review:  This doesn't look right. Is part of this CL missing? 
target code: public void onStart() { super.onStart(); mAuthenticatorHelper.listenToAccountUpdates(); IntentFilter btChangeFilter = new IntentFilter(); btChangeFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED); btChangeFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED); btChangeFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); getContext().registerReceiver(mBCMReceiver, btChangeFilter);
response: public void onStart() { super.onStart(); mAuthenticatorHelper.listenToAccountUpdates(); IntentFilter btChangeFilter = new IntentFilter(); btChangeFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED); btChangeFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED); btChangeFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); getContext().registerReceiver(mBBCMReceiver, btChangeFilter); }

sample: 106
buggy_code:  List<X509Certificate> certPathList) throws GeneralSecurityException { if (debug != null) { debug.println("ForwardBuilder.verifyCert(SN: " + Debug.toHexString(cert.getSerialNumber()) + "\n Issuer: " + cert.getIssuerX500Principal() + ")" + "\n Subject: " + cert.getSubjectX500Principal() + ")"); } ForwardState currState = (ForwardState)currentState; <|startfocus|> // BEGIN Android-removed: Android doesn't use this mechanism for checking untrusted certificates. <|endfocus|> // // Don't bother to verify untrusted certificate more. // currState.untrustedChecker.check(cert, Collections.<String>emptySet()); // END Android-removed: Android doesn't use this mechanism for checking untrusted certificates. /* * check for looping - abort a loop if we encounter the same * certificate twice */ if (certPathList != null) { for (X509Certificate cpListCert : certPathList) { if (cert.equals(cpListCert)) { if (debug != null) { debug.println("loop detected!!"); }
code_review:  May be too long. (and below) 
target code: List<X509Certificate> certPathList) throws GeneralSecurityException { if (debug != null) { debug.println("ForwardBuilder.verifyCert(SN: " + Debug.toHexString(cert.getSerialNumber()) + "\n Issuer: " + cert.getIssuerX500Principal() + ")" + "\n Subject: " + cert.getSubjectX500Principal() + ")"); } ForwardState currState = (ForwardState)currentState; // BEGIN Android-removed: Certificate checking // Android doesn't use this mechanism for checking untrusted certificates. // // Don't bother to verify untrusted certificate more. // currState.untrustedChecker.check(cert, Collections.<String>emptySet()); // END Android-removed: Android doesn't use this mechanism for checking untrusted certificates. /* * check for looping - abort a loop if we encounter the same * certificate twice */ if (certPathList != null) { for (X509Certificate cpListCert : certPathList) { if (cert.equals(cpListCert)) { if (debug != null) { debug.println("loop detected!!"); }
response: List<X509Certificate> certPathList) throws GeneralSecurityException { if (debug != null) { debug.println("ForwardBuilder.verifyCert(SN: " + Debug.toHexString(cert.getSerialNumber()) + "\n Issuer: " + cert.getIssuerX500Principal() + ")" + "\n Subject: " + cert.getSubjectX500Principal() + ")"); } ForwardState currState = (ForwardState) currentState; currState.untrustedChecker.check(cert, Collections.<String>emptySet()); if (certPathList != null) { for (X509Certificate cpListCert : certPathList) { if (cert.equals(cpListCert)) { if (debug != null) { debug.println("loop detected!!"); } throw new CertPathValidatorException("loop detected"); } } } // rest of the code }

sample: 107
buggy_code:  } public void testScreenLayout() throws Exception { int expectedScreenLayout = computeScreenLayout(); int expectedSize = expectedScreenLayout & Configuration.SCREENLAYOUT_SIZE_MASK; int expectedLong = expectedScreenLayout & Configuration.SCREENLAYOUT_LONG_MASK; // Check that all four orientations report the same configuration value. for (int i = 0; i < ORIENTATIONS.length; i++) { Activity activity = startOrientationActivity(ORIENTATIONS[i]); if (activity.isInMultiWindowMode()) { // activity.setRequestedOrientation has no effect in multiwindow mode. <|startfocus|> continue; <|endfocus|> } Configuration mConfig = activity.getResources().getConfiguration(); int actualSize = mConfig.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK; int actualLong = mConfig.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK; assertEquals("Expected screen size value of " + expectedSize + " but got " + actualSize + " for orientation " + ORIENTATIONS[i], expectedSize, actualSize); assertEquals("Expected screen long value of " + expectedLong + " but got " + actualLong
code_review:  no point in trying further so just teardown() and return here 
target code: } public void testScreenLayout() throws Exception { int expectedScreenLayout = computeScreenLayout(); int expectedSize = expectedScreenLayout & Configuration.SCREENLAYOUT_SIZE_MASK; int expectedLong = expectedScreenLayout & Configuration.SCREENLAYOUT_LONG_MASK; // Check that all four orientations report the same configuration value. for (int i = 0; i < ORIENTATIONS.length; i++) { Activity activity = startOrientationActivity(ORIENTATIONS[i]); if (activity.isInMultiWindowMode()) { // activity.setRequestedOrientation has no effect in multiwindow mode. tearDown(); return; } Configuration mConfig = activity.getResources().getConfiguration(); int actualSize = mConfig.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK; int actualLong = mConfig.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK; assertEquals("Expected screen size value of " + expectedSize + " but got " + actualSize + " for orientation " + ORIENTATIONS[i], expectedSize, actualSize); assertEquals("Expected screen long value of " + expectedLong + " but got " + actualLong
response: public void testScreenLayout() throws Exception { int expectedScreenLayout = computeScreenLayout(); int expectedSize = expectedScreenLayout & Configuration.SCREENLAYOUT_SIZE_MASK; int expectedLong = expectedScreenLayout & Configuration.SCREENLAYOUT_LONG_MASK; // Check that all four orientations report the same configuration value. for (int i = 0; i < ORIENTATIONS.length; i++) { Activity activity = startOrientationActivity(ORIENTATIONS[i]); if (activity.isInMultiWindowMode()) { // activity.setRequestedOrientation has no effect in multiwindow mode. teardown(); return; } Configuration mConfig = activity.getResources().getConfiguration(); int actualSize = mConfig.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK; int actualLong = mConfig.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK; assertEquals("Expected screen size value of " + expectedSize + " but got " + actualSize + " for orientation " + ORIENTATIONS[i], expectedSize, actualSize); assertEquals("Expected screen long value of " + expectedLong + " but got " + actualLong, expectedLong, actualLong); } assertNoErrors(); }

sample: 108
buggy_code:  public void testCompare() { assertTrue(PhoneNumberUtils.compare(null, null)); <|startfocus|> assertTrue(PhoneNumberUtils.compare("2023458246", "2023458246")); <|endfocus|> assertFalse(PhoneNumberUtils.compare("2023458246", "6503458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "202-345-8246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+12023458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+812023458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+1(202)345-8246"));
code_review:  See PhoneNumberUtilsTest in frameworks/opt/telephony/tests/telephonytests/ There are some other cases there that might be good to cover; eg. assertTrue(PhoneNumberUtils.compare("+17005554141", "**31#+17005554141")); 
target code: public void testCompare() { assertTrue(PhoneNumberUtils.compare(null, null)); assertTrue(PhoneNumberUtils.compare("2023458246", "2023458246")); assertFalse(PhoneNumberUtils.compare("2023458246", "6503458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "202-345-8246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+12023458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+812023458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+1(202)345-8246"));
response: public void testCompare() { assertTrue(PhoneNumberUtils.compare(null, null)); assertTrue(PhoneNumberUtils.compare("2023458246", "2023458246")); assertFalse(PhoneNumberUtils.compare("2023458246", "6503458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "202-345-8246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+12023458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+812023458246")); assertTrue(PhoneNumberUtils.compare("2023458246", "+1(202)345-8246")); }

sample: 109
buggy_code:  public void testFormatNumberToE164() { assertNull(PhoneNumberUtils.formatNumber("invalid#", "US")); <|startfocus|> <|endfocus|> assertEquals("+12023458246", PhoneNumberUtils.formatNumberToE164("(202)345-8246", "US")); assertEquals("+812023458246", PhoneNumberUtils.formatNumberToE164("202-345-8246", "JP"));
code_review:  From the unit tests, might be good to also add: assertEquals("+18004664114", PhoneNumberUtils.formatNumberToE164("800-GOOG-114", "US") 
target code: public void testFormatNumberToE164() { assertNull(PhoneNumberUtils.formatNumber("invalid#", "US")); assertEquals("+18004664114", PhoneNumberUtils.formatNumberToE164("800-GOOG-114", "US")); assertEquals("+12023458246", PhoneNumberUtils.formatNumberToE164("(202)345-8246", "US")); assertEquals("+812023458246", PhoneNumberUtils.formatNumberToE164("202-345-8246", "JP"));
response: public void testFormatNumberToE164() { assertNull(PhoneNumberUtils.formatNumber("invalid#", "US")); assertEquals("+12023458246", PhoneNumberUtils.formatNumberToE164("(202)345-8246", "US")); assertEquals("+812023458246", PhoneNumberUtils.formatNumberToE164("202-345-8246", "JP")); assertEquals("+18004664114", PhoneNumberUtils.formatNumberToE164("800-GOOG-114", "US")); }

sample: 110
buggy_code:  int connectionState = mStateMachine.getConnectionState(device); if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) { return false; } mStateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device); return true; } public List<BluetoothDevice> getConnectedDevices() { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getConnectedDevices(); } <|startfocus|> public BluetoothDevice getCurrentDevice() { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getCurrentDevice(); } <|endfocus|> private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getDevicesMatchingConnectionStates(states); } public int getConnectionState(BluetoothDevice device) { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getConnectionState(device); } public boolean setPriority(BluetoothDevice device, int priority) { enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission"); Settings.Global.putInt(getContentResolver(),
code_review:  This looks like new code, not formatting. 
target code: int connectionState = mStateMachine.getConnectionState(device); if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) { return false; } mStateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device); return true; } public List<BluetoothDevice> getConnectedDevices() { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getConnectedDevices(); } private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getDevicesMatchingConnectionStates(states); } public int getConnectionState(BluetoothDevice device) { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getConnectionState(device); } public boolean setPriority(BluetoothDevice device, int priority) { enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission"); Settings.Global.putInt(getContentResolver(),
response: int connectionState = mStateMachine.getConnectionState(device); if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) { return false; } mStateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device); return true; } public List<BluetoothDevice> getConnectedDevices() { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getConnectedDevices(); } public BluetoothDevice getCurrentDevice() { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getCurrentDevice(); } private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getDevicesMatchingConnectionStates(states); } public int getConnectionState(BluetoothDevice device) { enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission"); return mStateMachine.getConnectionState(device); } public boolean setPriority(BluetoothDevice device, int priority) { enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission"); Settings.Global.putInt(getContentResolver(),

sample: 111
buggy_code: <|startfocus|> private void processSlcConnected(BluetoothDevice device) { <|endfocus|> if (mPhoneProxy != null) { try { mPhoneProxy.queryPhoneState(); } catch (RemoteException e) { Log.e(TAG, Log.getStackTraceString(new Throwable())); } } else { Log.e(TAG, "Handsfree phone proxy null for query phone state"); }
code_review:  Seems like new code, not formatting. 
target code: private void processSlcConnected() { if (mPhoneProxy != null) { try { mPhoneProxy.queryPhoneState(); } catch (RemoteException e) { Log.e(TAG, Log.getStackTraceString(new Throwable())); } } else { Log.e(TAG, "Handsfree phone proxy null for query phone state"); }
response: private void processSlcConnected(BluetoothDevice device) { if (mPhoneProxy != null) { try { mPhoneProxy.queryPhoneState(); } catch (RemoteException e) { Log.e(TAG, Log.getStackTraceString(new Throwable())); } } else { Log.e(TAG, "Handsfree phone proxy null for query phone state"); } }

sample: 112
buggy_code:  } return BluetoothProfile.STATE_DISCONNECTED; } else { Log.e(TAG, "Bad currentState: " + currentState); return BluetoothProfile.STATE_DISCONNECTED; } } } List<BluetoothDevice> getConnectedDevices() { List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>(); synchronized (this) { for (int i = 0; i < mConnectedDevicesList.size(); i++) devices.add(mConnectedDevicesList.get(i)); } return devices; } <|startfocus|> BluetoothDevice getCurrentDevice() { return mCurrentDevice; } <|endfocus|> boolean isAudioOn() { return (getCurrentState() == mAudioOn); } boolean isAudioConnected(BluetoothDevice device) { synchronized (this) { /* Additional check for audio state included for the case when PhoneApp queries Bluetooth Audio state, before we receive the close event from the stack for the sco disconnect issued in AudioOn state. This was causing a mismatch in the Incall screen UI. */ if (getCurrentState() == mAudioOn && mCurrentDevice.equals(device)
code_review:  New code, not formatting. 
target code: } return BluetoothProfile.STATE_DISCONNECTED; } else { Log.e(TAG, "Bad currentState: " + currentState); return BluetoothProfile.STATE_DISCONNECTED; } } } List<BluetoothDevice> getConnectedDevices() { List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>(); synchronized (this) { for (int i = 0; i < mConnectedDevicesList.size(); i++) devices.add(mConnectedDevicesList.get(i)); } return devices; } boolean isAudioOn() { return (getCurrentState() == mAudioOn); } boolean isAudioConnected(BluetoothDevice device) { synchronized (this) { /* Additional check for audio state included for the case when PhoneApp queries Bluetooth Audio state, before we receive the close event from the stack for the sco disconnect issued in AudioOn state. This was causing a mismatch in the Incall screen UI. */ if (getCurrentState() == mAudioOn && mCurrentDevice.equals(device)
response: } return BluetoothProfile.STATE_DISCONNECTED; } else { Log.e(TAG, "Bad currentState: " + currentState); return BluetoothProfile.STATE_DISCONNECTED; } } List<BluetoothDevice> getConnectedDevices() { List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>(); synchronized (this) { for (int i = 0; i < mConnectedDevicesList.size(); i++) devices.add(mConnectedDevicesList.get(i)); } return devices; } BluetoothDevice getCurrentDevice() { return mCurrentDevice; } boolean isAudioOn() { return (getCurrentState() == mAudioOn); } boolean isAudioConnected(BluetoothDevice device) { synchronized (this) { /* Additional check for audio state included for the case when PhoneApp queries Bluetooth Audio state, before we receive the close event from the stack for the sco disconnect issued in AudioOn state. This was causing a mismatch in the Incall screen UI. */ if (getCurrentState() == mAudioOn && mCurrentDevice.equals(device)

sample: 113
buggy_code:  public void exit() { <|startfocus|> mWifiConfigManager.loadFromStore(); <|endfocus|>
code_review:  We enable this network and disable other networks here, right? Probably worth mentioning it. Otherwise, people would ask what if there is higher scored saved network around. 
target code: public void exit() { mWifiConfigStore.enableAllNetworks(); mWifiConfigStore.loadConfiguredNetworks();
response: public void exit() { mWifiConfigManager.loadFromStore(); // Enable this network and disable other networks }

sample: 114
buggy_code:  public void exit() { <|startfocus|> mWifiConfigManager.loadFromStore(); <|endfocus|>
code_review:  add sth like "transition to". 
target code: public void exit() { mWifiConfigStore.enableAllNetworks(); mWifiConfigStore.loadConfiguredNetworks();
response: public void exit() { mWifiConfigManager.loadFromStore(); // transition to exit state }

sample: 115
buggy_code:  protected boolean hasLog(String str) throws DeviceNotAvailableException { String logs = getDevice().executeAdbCommand("logcat", "-v", "brief", "-d", mService + ":I", "*:S"); return logs.contains(str); } private void clearLogcat() throws DeviceNotAvailableException { getDevice().executeAdbCommand("logcat", "-c"); } protected boolean supportedHardware() throws DeviceNotAvailableException { // Customization by third-party tiles is only a requirement for devices <|startfocus|> // supporting Quick Settings UI component. <|endfocus|> // // As there is no public API to distinguish a device with Quick Settings // from others, the check below, as well as all the tests under // CtsSystemUiHostTestCases relying on the check may have false negatives. String features = getDevice().executeShellCommand("pm list features"); return !features.contains("android.hardware.type.television") && !features.contains("android.hardware.type.watch"); } } 
code_review:  CDD 
target code: protected boolean hasLog(String str) throws DeviceNotAvailableException { String logs = getDevice().executeAdbCommand("logcat", "-v", "brief", "-d", mService + ":I", "*:S"); return logs.contains(str); } private void clearLogcat() throws DeviceNotAvailableException { getDevice().executeAdbCommand("logcat", "-c"); } protected boolean supportedHardware() throws DeviceNotAvailableException { // Customization by third-party tiles is only a requirement for devices // supporting Quick Settings UI component, according to the CDD: // http://source.android.com/compatibility/7.1/android-7.1-cdd.html#3_13_quick_settings // // As there is no public API to distinguish a device with Quick Settings // from others, the check below, as well as all the tests under // CtsSystemUiHostTestCases relying on the check may have false negatives. String features = getDevice().executeShellCommand("pm list features"); return !features.contains("android.hardware.type.television") && !features.contains("android.hardware.type.watch"); } }
response: protected boolean hasLog(String str) throws DeviceNotAvailableException { String logs = getDevice().executeAdbCommand("logcat", "-v", "brief", "-d", mService + ":I", "*:S"); return logs.contains(str); } private void clearLogcat() throws DeviceNotAvailableException { getDevice().executeAdbCommand("logcat", "-c"); } protected boolean supportedHardware() throws DeviceNotAvailableException { String features = getDevice().executeShellCommand("pm list features"); return !features.contains("android.hardware.type.television") && !features.contains("android.hardware.type.watch"); }

sample: 116
buggy_code:  HandlerThread thread = new HandlerThread("BluetoothAdvertiseManager"); thread.start(); mHandler = new Handler(thread.getLooper()); } void cleanup() { logd("cleanup()"); cleanupNative(); mAdvertisers.clear(); sTempRegistrationId = -1; if (mHandler != null) { // Shut down the thread mHandler.removeCallbacksAndMessages(null); Looper looper = mHandler.getLooper(); if (looper != null) { looper.quit(); } mHandler = null; } } <|startfocus|> class AdvertiserBag { <|endfocus|> /* When id is negative, the registration is ongoing. When the registration finishes, id * becomes equal to advertiser_id */ public Integer id; public AdvertisingSetDeathRecipient deathRecipient; public IAdvertisingSetCallback callback; AdvertiserBag(Integer id, AdvertisingSetDeathRecipient deathRecipient, IAdvertisingSetCallback callback) { this.id = id; this.deathRecipient = deathRecipient; this.callback = callback; } } IBinder toBinder(IAdvertisingSetCallback e) { return ((IInterface) e).asBinder(); } class AdvertisingSetDeathRecipient implements IBinder.DeathRecipient {
code_review:  AdvertiserInfo 
target code: HandlerThread thread = new HandlerThread("BluetoothAdvertiseManager"); thread.start(); mHandler = new Handler(thread.getLooper()); } void cleanup() { logd("cleanup()"); cleanupNative(); mAdvertisers.clear(); sTempRegistrationId = -1; if (mHandler != null) { // Shut down the thread mHandler.removeCallbacksAndMessages(null); Looper looper = mHandler.getLooper(); if (looper != null) { looper.quit(); } mHandler = null; } } class AdvertiserInfo { /* When id is negative, the registration is ongoing. When the registration finishes, id * becomes equal to advertiser_id */ public Integer id; public AdvertisingSetDeathRecipient deathRecipient; public IAdvertisingSetCallback callback; AdvertiserBag(Integer id, AdvertisingSetDeathRecipient deathRecipient, IAdvertisingSetCallback callback) { this.id = id; this.deathRecipient = deathRecipient; this.callback = callback; } } IBinder toBinder(IAdvertisingSetCallback e) { return ((IInterface) e).asBinder(); } class AdvertisingSetDeathRecipient implements IBinder.DeathRecipient {
response: HandlerThread thread = new HandlerThread("BluetoothAdvertiseManager"); thread.start(); mHandler = new Handler(thread.getLooper()); void cleanup() { logd("cleanup()"); cleanupNative(); mAdvertisers.clear(); sTempRegistrationId = -1; if (mHandler != null) { // Shut down the thread mHandler.removeCallbacksAndMessages(null); Looper looper = mHandler.getLooper(); if (looper != null) { looper.quit(); } mHandler = null; } } class AdvertiserBag { /* When id is negative, the registration is ongoing. When the registration finishes, id * becomes equal to advertiser_id */ public Integer id; public AdvertisingSetDeathRecipient deathRecipient; public IAdvertisingSetCallback callback; AdvertiserBag(Integer id, AdvertisingSetDeathRecipient deathRecipient, IAdvertisingSetCallback callback) { this.id = id; this.deathRecipient = deathRecipient; this.callback = callback; } } IBinder toBinder(IAdvertisingSetCallback e) { return ((IInterface) e).asBinder(); } class AdvertisingSetDeathRecipient implements IBinder.DeathRecipient { // Implementation details }

sample: 117
buggy_code: import android.os.ParcelFileDescriptor; import android.os.Process; import android.os.SystemClock; import android.telecom.PhoneAccount; import android.telecom.PhoneAccountHandle; import android.telecom.TelecomManager; import junit.framework.TestCase; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.Optional; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.function.Predicate; <|startfocus|> import java.util.stream.Collectors; <|endfocus|> public class TestUtils { static final String TAG = "TelecomCTSTests"; static final boolean HAS_TELECOM = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP; static final long WAIT_FOR_STATE_CHANGE_TIMEOUT_MS = 10000; static final long WAIT_FOR_CALL_ADDED_TIMEOUT_S = 15; static final long WAIT_FOR_STATE_CHANGE_TIMEOUT_CALLBACK = 50; // Non-final to allow modification by tests not in this package (e.g. permission-related // tests in the Telecom2 test package.
code_review:  unused? 
target code: import android.os.ParcelFileDescriptor; import android.os.Process; import android.os.SystemClock; import android.telecom.PhoneAccount; import android.telecom.PhoneAccountHandle; import android.telecom.TelecomManager; import junit.framework.TestCase; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.Optional; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.function.Predicate; public class TestUtils { static final String TAG = "TelecomCTSTests"; static final boolean HAS_TELECOM = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP; static final long WAIT_FOR_STATE_CHANGE_TIMEOUT_MS = 10000; static final long WAIT_FOR_CALL_ADDED_TIMEOUT_S = 15; static final long WAIT_FOR_STATE_CHANGE_TIMEOUT_CALLBACK = 50; // Non-final to allow modification by tests not in this package (e.g. permission-related // tests in the Telecom2 test package.
response: import android.os.ParcelFileDescriptor; import android.os.Process; import android.os.SystemClock; import android.telecom.PhoneAccount; import android.telecom.PhoneAccountHandle; import android.telecom.TelecomManager; import junit.framework.TestCase; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.Optional; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.function.Predicate; import java.util.stream.Collectors; public class TestUtils { static final String TAG = "TelecomCTSTests"; static final boolean HAS_TELECOM = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP; static final long WAIT_FOR_STATE_CHANGE_TIMEOUT_MS = 10000; static final long WAIT_FOR_CALL_ADDED_TIMEOUT_S = 15; static final long WAIT_FOR_STATE_CHANGE_TIMEOUT_CALLBACK = 50; // Non-final to allow modification by tests not in this package (e.g. permission-related // tests in the Telecom2 test package. }

sample: 118
buggy_code:  // Avoid unnecessary work on spurious updates. if (Objects.equals(mLastIPv6LinkProperties, v6only)) { return; } RaParams params = null; if (v6only != null) { params = new RaParams(); params.mtu = v6only.getMtu(); params.hasDefaultRoute = v6only.hasIPv6DefaultRoute(); for (LinkAddress linkAddr : v6only.getLinkAddresses()) { <|startfocus|> if (linkAddr.getPrefixLength() != NetworkConstants.RFC7421_IP_PREFIX_LENGTH) { continue; } <|endfocus|> final IpPrefix prefix = new IpPrefix( linkAddr.getAddress(), linkAddr.getPrefixLength()); params.prefixes.add(prefix); final Inet6Address dnsServer = getLocalDnsIpFor(prefix); if (dnsServer != null) { params.dnses.add(dnsServer); } } } // If v6only is null, we pass in null to setRaParams(), which handles // deprecation of any existing RA data. setRaParams(params); mLastIPv6LinkProperties = v6only;
code_review:  If you do: import static android.net.util.NetworkConstants.RFC7421_PREFIX_LENGTH; you can keep this nice and short. 
target code: // Avoid unnecessary work on spurious updates. if (Objects.equals(mLastIPv6LinkProperties, v6only)) { return; } RaParams params = null; if (v6only != null) { params = new RaParams(); params.mtu = v6only.getMtu(); params.hasDefaultRoute = v6only.hasIPv6DefaultRoute(); for (LinkAddress linkAddr : v6only.getLinkAddresses()) { if (linkAddr.getPrefixLength() != RFC7421_PREFIX_LENGTH) continue; final IpPrefix prefix = new IpPrefix( linkAddr.getAddress(), linkAddr.getPrefixLength()); params.prefixes.add(prefix); final Inet6Address dnsServer = getLocalDnsIpFor(prefix); if (dnsServer != null) { params.dnses.add(dnsServer); } } } // If v6only is null, we pass in null to setRaParams(), which handles // deprecation of any existing RA data. setRaParams(params); mLastIPv6LinkProperties = v6only;
response: private int getEffectiveLimit(Predicate<ChangeData> p) { List<Integer> possibleLimits = new ArrayList<>(4); possibleLimits.add(getBackendSupportedLimit()); possibleLimits.add(getPermittedLimit()); if (limitFromCaller > 0) { possibleLimits.add(limitFromCaller); } Integer limitFromPredicate = LimitPredicate.getLimit(FIELD_LIMIT, p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } return Ordering.natural().min(possibleLimits); } public int chooseRunningDeviceStep(String[] deviceNames) { JRadioButtonFixture chooseRunningDeviceRadioButton = new JRadioButtonFixture(robot, findRadioButtonByText("Choose a running device")); chooseRunningDeviceRadioButton.requireEnabled(); chooseRunningDeviceRadioButton.requireVisible(); chooseRunningDeviceRadioButton.click(); JBTable deviceTable = robot.finder().findByType(target, JBTable.class); assertNotNull(deviceTable); JTableFixture deviceTableFixture = new JTableFixture(robot, deviceTable); int deviceColumnIndex = deviceTable.getColumn("Device").getModelIndex(); int compatibleColumnIndex = deviceTable.getColumn("Compatible").getModelIndex(); ArrayList<Integer> rowsToSelect = new ArrayList<Integer>(deviceTable.getRowCount()); HashSet<String> deviceNameHashes = new HashSet<String>(Arrays.asList(deviceNames)); for (int i = 0; i < deviceTable.getRowCount(); ++i) { IDevice device = (IDevice)deviceTable.getModel().getValueAt(i, deviceColumnIndex); ThreeState launchCompatibility = ((LaunchCompatibility)deviceTable.getModel().getValueAt(i, compatibleColumnIndex)).isCompatible(); } public static void findAndSetPlatformSources(@NotNull IAndroidTarget target, @NotNull SdkModificator sdkModificator) { File sources = findPlatformSources(target); if (sources != null) { VirtualFile virtualFile = VfsUtil.findFileByIoFile(sources, true); if (virtualFile != null) { for (VirtualFile file : sdkModificator.getRoots(OrderRootType.SOURCES)) { if (file.equals(virtualFile)) { return; } } } } } // Avoid unnecessary work on spurious updates. if (Objects.equals(mLastIPv6LinkProperties, v6only)) { return; } RaParams params = null; if (v6only

sample: 119
buggy_code:  */ public static final int IPV6_HEADER_LEN = 40; public static final int IPV6_PROTOCOL_OFFSET = 6; public static final int IPV6_SRC_ADDR_OFFSET = 8; public static final int IPV6_DST_ADDR_OFFSET = 24; public static final int IPV6_ADDR_LEN = 16; /** <|startfocus|> * IPv6 constants. * * See also: * - https://tools.ietf.org/html/rfc7421 */ public static final int RFC7421_IP_PREFIX_LENGTH = 64; /** <|endfocus|> * ICMPv6 constants. * * See also: * - https://tools.ietf.org/html/rfc4443 * - https://tools.ietf.org/html/rfc4861 */ public static final int ICMPV6_HEADER_MIN_LEN = 4; public static final int ICMPV6_ROUTER_SOLICITATION = 133; public static final int ICMPV6_ROUTER_ADVERTISEMENT = 134; public static final int ICMPV6_NEIGHBOR_SOLICITATION = 135; public static final int ICMPV6_NEIGHBOR_ADVERTISEMENT = 136; public static final int ICMPV6_ND_OPTION_MIN_LENGTH = 8;
code_review:  You can just move this constant right up to below IPV6_ADDR_LEN. You can also s/_IP_/_/ out of its name. 
target code: */ public static final int IPV6_HEADER_LEN = 40; public static final int IPV6_PROTOCOL_OFFSET = 6; public static final int IPV6_SRC_ADDR_OFFSET = 8; public static final int IPV6_DST_ADDR_OFFSET = 24; public static final int IPV6_ADDR_LEN = 16; /** * ICMPv6 constants. * * See also: * - https://tools.ietf.org/html/rfc4443 * - https://tools.ietf.org/html/rfc4861 */ public static final int ICMPV6_HEADER_MIN_LEN = 4; public static final int ICMPV6_ROUTER_SOLICITATION = 133; public static final int ICMPV6_ROUTER_ADVERTISEMENT = 134; public static final int ICMPV6_NEIGHBOR_SOLICITATION = 135; public static final int ICMPV6_NEIGHBOR_ADVERTISEMENT = 136; public static final int ICMPV6_ND_OPTION_MIN_LENGTH = 8;
response: public static final int IPV6_HEADER_LEN = 40; public static final int IPV6_PROTOCOL_OFFSET = 6; public static final int IPV6_SRC_ADDR_OFFSET = 8; public static final int IPV6_DST_ADDR_OFFSET = 24; public static final int IPV6_ADDR_LEN = 16; public static final int RFC7421_PREFIX_LENGTH = 64; public static final int ICMPV6_HEADER_MIN_LEN = 4; public static final int ICMPV6_ROUTER_SOLICITATION = 133; public static final int ICMPV6_ROUTER_ADVERTISEMENT = 134; public static final int ICMPV6_NEIGHBOR_SOLICITATION = 135; public static final int ICMPV6_NEIGHBOR_ADVERTISEMENT = 136; public static final int ICMPV6_ND_OPTION_MIN_LENGTH = 8;

sample: 120
buggy_code:  private boolean startIPv6() { try { enableInterfaceIpv6PrivacyExtensions(); setInterfaceIpv6RaRtInfoMaxPlen(ACCEPT_RA_RT_INFO_MAX_PLEN); mNwService.enableIpv6(mInterfaceName); <|startfocus|> } catch (IllegalStateException|RemoteException|ServiceSpecificException e) { logError("Unable to change interface settings: %s", e); <|endfocus|> return false; } return true;
code_review:  [nit] If you felt ambitious, you could in this change: [1] airlift IPv6TetheringInterfaceServices' RFC7421_IP_PREFIX_LENGTH definition out of its file and into android.net.util.NetworkConstants (with s/IP/IPV6/ in the anem) [2] import and use NetworkConstants.RFC7421_IPV6_PREFIX_LENGTH here. 
target code: private boolean startIPv6() { try { enableInterfaceIpv6PrivacyExtensions(); setInterfaceIpv6RaRtInfoMaxPlen(ACCEPT_RA_RT_INFO_MAX_PLEN); mNwService.enableIpv6(mInterfaceName); } catch (RemoteException re) { logError("Unable to change interface settings: %s", re); return false; } return true;
response: private boolean startIPv6() { try { enableInterfaceIpv6PrivacyExtensions(); setInterfaceIpv6RaRtInfoMaxPlen(NetworkConstants.RFC7421_IPV6_PREFIX_LENGTH); mNwService.enableIpv6(mInterfaceName); } catch (IllegalStateException | RemoteException | ServiceSpecificException e) { logError("Unable to change interface settings: %s", e); return false; } return true; }

sample: 121
buggy_code:  * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.server.connectivity.tethering; import android.net.INetd; import android.net.IpPrefix; import android.net.LinkAddress; import android.net.LinkProperties; import android.net.NetworkCapabilities; import android.net.NetworkState; import android.net.RouteInfo; import android.net.ip.RouterAdvertisementDaemon; import android.net.ip.RouterAdvertisementDaemon.RaParams; import android.net.util.NetdService; <|startfocus|> import static android.net.util.NetworkConstants.RFC7421_PREFIX_LENGTH; <|endfocus|> import android.os.INetworkManagementService; import android.os.ServiceSpecificException; import android.os.RemoteException; import android.util.Log; import android.util.Slog; import java.net.Inet6Address; import java.net.InetAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.HashSet; import java.util.Objects; /** * @hide */ public class IPv6TetheringInterfaceServices { private static final String TAG = IPv6TetheringInterfaceServices.class.getSimpleName();
code_review:  Sorry, I failed to mention that "import static" lines seem to go between the "package" declaration and other regular lines (according to other files I've worked in), usually with a blank line surrounding the "import static" block (which in this is just a single line). 
target code: * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.server.connectivity.tethering; import android.net.INetd; import android.net.IpPrefix; import android.net.LinkAddress; import android.net.LinkProperties; import android.net.NetworkCapabilities; import android.net.NetworkState; import android.net.RouteInfo; import android.net.ip.RouterAdvertisementDaemon; import android.net.ip.RouterAdvertisementDaemon.RaParams; import android.net.util.NetdService; import android.os.INetworkManagementService; import android.os.ServiceSpecificException; import android.os.RemoteException; import android.util.Log; import android.util.Slog; import java.net.Inet6Address; import java.net.InetAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.HashSet; import java.util.Objects; /** * @hide */ public class IPv6TetheringInterfaceServices { private static final String TAG = IPv6TetheringInterfaceServices.class.getSimpleName();
response: package com.android.server.connectivity.tethering; import android.net.INetd; import android.net.IpPrefix; import android.net.LinkAddress; import android.net.LinkProperties; import android.net.NetworkCapabilities; import android.net.NetworkState; import android.net.RouteInfo; import android.net.ip.RouterAdvertisementDaemon; import android.net.ip.RouterAdvertisementDaemon.RaParams; import android.net.util.NetdService; import static android.net.util.NetworkConstants.RFC7421_PREFIX_LENGTH; import android.os.INetworkManagementService; import android.os.ServiceSpecificException; import android.os.RemoteException; import android.util.Log; import android.util.Slog; import java.net.Inet6Address; import java.net.InetAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.HashSet; import java.util.Objects; /** * @hide */ public class IPv6TetheringInterfaceServices { private static final String TAG = IPv6TetheringInterfaceServices.class.getSimpleName(); }

sample: 122
buggy_code: import android.net.apf.ApfFilter; import android.net.DhcpResults; import android.net.INetd; import android.net.InterfaceConfiguration; import android.net.LinkAddress; import android.net.LinkProperties; import android.net.LinkProperties.ProvisioningChange; import android.net.ProxyInfo; import android.net.RouteInfo; import android.net.StaticIpConfiguration; import android.net.dhcp.DhcpClient; import android.net.metrics.IpConnectivityLog; import android.net.metrics.IpManagerEvent; import android.net.util.MultinetworkPolicyTracker; <|startfocus|> import android.net.util.NetdService; import static android.net.util.NetworkConstants.RFC7421_PREFIX_LENGTH; <|endfocus|> import android.os.INetworkManagementService; import android.os.Message; import android.os.RemoteException; import android.os.ServiceManager; import android.os.ServiceSpecificException; import android.os.SystemClock; import android.system.OsConstants; import android.text.TextUtils; import android.util.LocalLog; import android.util.Log; import android.util.SparseArray; import com.android.internal.annotations.VisibleForTesting; import com.android.internal.util.IndentingPrintWriter; import com.android.internal.util.IState; import com.android.internal.util.State; import com.android.internal.util.StateMachine; import com.android.server.net.NetlinkTracker; import java.io.FileDescriptor;
code_review:  Same: this goes up before other imports. 
target code: import android.net.apf.ApfFilter; import android.net.DhcpResults; import android.net.INetd; import android.net.InterfaceConfiguration; import android.net.LinkAddress; import android.net.LinkProperties; import android.net.LinkProperties.ProvisioningChange; import android.net.ProxyInfo; import android.net.RouteInfo; import android.net.StaticIpConfiguration; import android.net.dhcp.DhcpClient; import android.net.metrics.IpConnectivityLog; import android.net.metrics.IpManagerEvent; import android.net.util.MultinetworkPolicyTracker; import android.os.INetworkManagementService; import android.os.Message; import android.os.RemoteException; import android.os.ServiceManager; import android.os.ServiceSpecificException; import android.os.SystemClock; import android.system.OsConstants; import android.text.TextUtils; import android.util.LocalLog; import android.util.Log; import android.util.SparseArray; import com.android.internal.annotations.VisibleForTesting; import com.android.internal.util.IndentingPrintWriter; import com.android.internal.util.IState; import com.android.internal.util.State; import com.android.internal.util.StateMachine; import com.android.server.net.NetlinkTracker; import java.io.FileDescriptor;
response: import android.net.apf.ApfFilter; import android.net.DhcpResults; import android.net.INetd; import android.net.InterfaceConfiguration; import android.net.LinkAddress; import android.net.LinkProperties; import android.net.LinkProperties.ProvisioningChange; import android.net.ProxyInfo; import android.net.RouteInfo; import android.net.StaticIpConfiguration; import android.net.dhcp.DhcpClient; import android.net.metrics.IpConnectivityLog; import android.net.metrics.IpManagerEvent; import android.net.util.MultinetworkPolicyTracker; import android.net.util.NetdService; import static android.net.util.NetworkConstants.RFC7421_PREFIX_LENGTH; import android.os.INetworkManagementService; import android.os.Message; import android.os.RemoteException; import android.os.ServiceManager; import android.os.ServiceSpecificException; import android.os.SystemClock; import android.system.OsConstants; import android.text.TextUtils; import android.util.LocalLog; import android.util.Log; import android.util.SparseArray; import com.android.internal.annotations.VisibleForTesting; import com.android.internal.util.IndentingPrintWriter; import com.android.internal.util.IState; import com.android.internal.util.State; import com.android.internal.util.StateMachine; import com.android.server.net.NetlinkTracker; import java.io.FileDescriptor;

sample: 123
buggy_code:  protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); <|startfocus|> final Bundle extras = getIntent().getExtras(); final int dialogType = (extras == null ? INVALID_PICK : extras.getInt(DIALOG_TYPE_KEY, INVALID_PICK)); <|endfocus|> switch (dialogType) { case DATA_PICK: case CALLS_PICK: case SMS_PICK: createDialog(this, dialogType).show(); break; case PREFERRED_PICK: displayPreferredDialog(extras.getInt(PREFERRED_SIM)); break; default: throw new IllegalArgumentException("Invalid dialog type " + dialogType + " sent."); } 
code_review:  Long line and Intent already has a convenience method you can use for this: final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, INVALID_PICK); 
target code: protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, INVALID_PICK); switch (dialogType) { case DATA_PICK: case CALLS_PICK: case SMS_PICK: createDialog(this, dialogType).show(); break; case PREFERRED_PICK: displayPreferredDialog(extras.getInt(PREFERRED_SIM)); break; default: throw new IllegalArgumentException("Invalid dialog type " + dialogType + " sent."); }
response: protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, INVALID_PICK); switch (dialogType) { case DATA_PICK: case CALLS_PICK: case SMS_PICK: createDialog(this, dialogType).show(); break; case PREFERRED_PICK: displayPreferredDialog(getIntent().getIntExtra(PREFERRED_SIM, 0)); break; default: throw new IllegalArgumentException("Invalid dialog type " + dialogType + " sent."); } }

sample: 124
buggy_code:  {"12345", "12345", "12345"}, {"12345", "67890", "67890"}, {"12345*00000", "12345", "12345*00000"}, {"12345*00000", "67890", "67890"}, {"12345*00000", "12345*00000", "12345*00000"}, {"12345;11111*00000", "12345", "12345"}, {"12345*00000;11111", "12345", "12345*00000"}, {"18412345*00000", "18412345", "18412345*00000"}, <|startfocus|> {"+8112345*00000", "+8112345", "+8112345*00000"}}; <|endfocus|> for (String[] testAddress : testAddressMappingSet) { mConnectionUT = new ImsPhoneConnection(mImsPhone, testAddress[0], mImsCT, mForeGroundCall, false); doReturn(testAddress[1]).when(mImsCallProfile) .getCallExtra(eq(ImsCallProfile.EXTRA_OI)); mConnectionUT.updateAddressDisplay(mImsCall); assertEquals(testAddress[2], mConnectionUT.getAddress()); }
code_review:  Please include the test: {"12345*00000", "12346", "12345*00000"} I do not think this test will pass... 
target code: {"12345", "12345", "12345"}, {"12345", "67890", "67890"}, {"12345*00000", "12345", "12345*00000"}, {"12345*00000", "67890", "67890"}, {"12345*00000", "12345*00000", "12345*00000"}, {"12345;11111*00000", "12345", "12345"}, {"12345*00000;11111", "12345", "12345*00000"}, {"18412345*00000", "18412345", "18412345*00000"}, {"+8112345*00000", "+8112345", "+8112345*00000"}, {"12345*00000", "12346", "12346"}}; for (String[] testAddress : testAddressMappingSet) { mConnectionUT = new ImsPhoneConnection(mImsPhone, testAddress[0], mImsCT, mForeGroundCall, false); doReturn(testAddress[1]).when(mImsCallProfile) .getCallExtra(eq(ImsCallProfile.EXTRA_OI)); mConnectionUT.updateAddressDisplay(mImsCall); assertEquals(testAddress[2], mConnectionUT.getAddress()); }
response: {"12345", "12345", "12345"}, {"12345", "67890", "67890"}, {"12345*00000", "12345", "12345*00000"}, {"12345*00000", "67890", "67890"}, {"12345*00000", "12345*00000", "12345*00000"}, {"12345;11111*00000", "12345", "12345"}, {"12345*00000;11111", "12345", "12345*00000"}, {"18412345*00000", "18412345", "18412345*00000"}, {"+8112345*00000", "+8112345", "+8112345*00000"}}; for (String[] testAddress : testAddressMappingSet) { mConnectionUT = new ImsPhoneConnection(mImsPhone, testAddress[0], mImsCT, mForeGroundCall, false); doReturn(testAddress[1]).when(mImsCallProfile).getCallExtra(eq(ImsCallProfile.EXTRA_OI)); mConnectionUT.updateAddressDisplay(mImsCall); assertEquals(testAddress[2], mConnectionUT.getAddress()); }

sample: 125
buggy_code:  * @hide */ public static final int PROPERTY_IS_DOWNGRADED_CONFERENCE = 1<<6; /** * Set by the framework to indicate that the {@link Connection} originated from a self-managed * {@link ConnectionService}. * <p> * See {@link PhoneAccount#CAPABILITY_SELF_MANAGED}. */ public static final int PROPERTY_SELF_MANAGED = 1<<7; /** <|startfocus|> * When set, indicates that a connection has an active RTT session associated with it. <|endfocus|> * @hide */ @TestApi public static final int PROPERTY_IS_RTT = 1 << 8; //********************************************************************************************** // Next PROPERTY value: 1<<9 //********************************************************************************************** /** * Connection extra key used to store the last forwarded number associated with the current * connection. Used to communicate to the user interface that the connection was forwarded via * the specified number. */ public static final String EXTRA_LAST_FORWARDED_NUMBER = "android.telecom.extra.LAST_FORWARDED_NUMBER"; /**
code_review:  Should you put "Set by the framework to indicate" here? 
target code: * @hide */ public static final int PROPERTY_IS_DOWNGRADED_CONFERENCE = 1<<6; /** * Set by the framework to indicate that the {@link Connection} originated from a self-managed * {@link ConnectionService}. * <p> * See {@link PhoneAccount#CAPABILITY_SELF_MANAGED}. */ public static final int PROPERTY_SELF_MANAGED = 1<<7; /** * Set by the framework to indicate that a connection has an active RTT session associated with * it. * @hide */ @TestApi public static final int PROPERTY_IS_RTT = 1 << 8; //********************************************************************************************** // Next PROPERTY value: 1<<9 //********************************************************************************************** /** * Connection extra key used to store the last forwarded number associated with the current * connection. Used to communicate to the user interface that the connection was forwarded via * the specified number. */ public static final String EXTRA_LAST_FORWARDED_NUMBER = "android.telecom.extra.LAST_FORWARDED_NUMBER"; /**
response: public static final int PROPERTY_IS_DOWNGRADED_CONFERENCE = 1<<6; public static final int PROPERTY_SELF_MANAGED = 1<<7; public static final int PROPERTY_IS_RTT = 1 << 8; public static final String EXTRA_LAST_FORWARDED_NUMBER = "android.telecom.extra.LAST_FORWARDED_NUMBER";

sample: 126
buggy_code:  private static final int STACK_EVENT = 101; private static final int DIALING_OUT_TIMEOUT = 102; private static final int START_VR_TIMEOUT = 103; private static final int CLCC_RSP_TIMEOUT = 104; private static final int CONNECT_TIMEOUT = 201; private static final int DIALING_OUT_TIMEOUT_VALUE = 10000; private static final int START_VR_TIMEOUT_VALUE = 5000; private static final int CLCC_RSP_TIMEOUT_VALUE = 5000; <|startfocus|> // Max number of HF connections at any time, default to 1 <|endfocus|> private int max_hf_connections = 1; private static final int NBS_CODEC = 1; private static final int WBS_CODEC = 2; // Keys are AT commands, and values are the company IDs. private static final Map<String, Integer> VENDOR_SPECIFIC_AT_COMMAND_COMPANY_ID; // Hash for storing the Audio Parameters like NREC for connected headsets private HashMap<BluetoothDevice, HashMap> mHeadsetAudioParam = new HashMap<BluetoothDevice, HashMap>(); // Hash for storing the Remotedevice BRSF private HashMap<BluetoothDevice, Integer> mHeadsetBrsf =
code_review:  don't do this, it's clear from the code. 
target code: private static final int STACK_EVENT = 101; private static final int DIALING_OUT_TIMEOUT = 102; private static final int START_VR_TIMEOUT = 103; private static final int CLCC_RSP_TIMEOUT = 104; private static final int CONNECT_TIMEOUT = 201; private static final int DIALING_OUT_TIMEOUT_VALUE = 10000; private static final int START_VR_TIMEOUT_VALUE = 5000; private static final int CLCC_RSP_TIMEOUT_VALUE = 5000; // Max number of HF connections at any time private int max_hf_connections = 1; private static final int NBS_CODEC = 1; private static final int WBS_CODEC = 2; // Keys are AT commands, and values are the company IDs. private static final Map<String, Integer> VENDOR_SPECIFIC_AT_COMMAND_COMPANY_ID; // Hash for storing the Audio Parameters like NREC for connected headsets private HashMap<BluetoothDevice, HashMap> mHeadsetAudioParam = new HashMap<BluetoothDevice, HashMap>(); // Hash for storing the Remotedevice BRSF private HashMap<BluetoothDevice, Integer> mHeadsetBrsf =
response: private static final int STACK_EVENT = 101; private static final int DIALING_OUT_TIMEOUT = 102; private static final int START_VR_TIMEOUT = 103; private static final int CLCC_RSP_TIMEOUT = 104; private static final int CONNECT_TIMEOUT = 201; private static final int DIALING_OUT_TIMEOUT_VALUE = 10000; private static final int START_VR_TIMEOUT_VALUE = 5000; private static final int CLCC_RSP_TIMEOUT_VALUE = 5000; private int max_hf_connections = 1; private static final int NBS_CODEC = 1; private static final int WBS_CODEC = 2; private static final Map<String, Integer> VENDOR_SPECIFIC_AT_COMMAND_COMPANY_ID; private HashMap<BluetoothDevice, HashMap> mHeadsetAudioParam = new HashMap<BluetoothDevice, HashMap>(); private HashMap<BluetoothDevice, Integer> mHeadsetBrsf = new HashMap<BluetoothDevice, Integer>();

sample: 127
buggy_code: import android.preference.PreferenceManager; import android.provider.Telephony; import android.provider.Telephony.CellBroadcasts; import android.telephony.CarrierConfigManager; import android.telephony.cdma.CdmaSmsCbProgramData; import android.util.Log; import com.android.internal.telephony.TelephonyIntents; import com.android.internal.telephony.cdma.sms.SmsEnvelope; public class CellBroadcastReceiver extends BroadcastReceiver { private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship <|startfocus|> public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; <|endfocus|> // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.android.cellbroadcastreceiver.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.android.cellbroadcastreceiver.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) {
code_review:  Can we also rename this to com.android.cellbroadcastreceiver.intent so all intents have the same domain? And maybe move this or the other two so all the intents definitions can stay together. Everything else LGTM. 
target code: import android.preference.PreferenceManager; import android.provider.Telephony; import android.provider.Telephony.CellBroadcasts; import android.telephony.CarrierConfigManager; import android.telephony.cdma.CdmaSmsCbProgramData; import android.util.Log; import com.android.internal.telephony.TelephonyIntents; import com.android.internal.telephony.cdma.sms.SmsEnvelope; public class CellBroadcastReceiver extends BroadcastReceiver { private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.android.cellbroadcastreceiver.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.android.cellbroadcastreceiver.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) {
response: import android.preference.PreferenceManager; import android.provider.Telephony; import android.provider.Telephony.CellBroadcasts; import android.telephony.CarrierConfigManager; import android.telephony.cdma.CdmaSmsCbProgramData; import android.util.Log; import com.android.internal.telephony.TelephonyIntents; import com.android.internal.telephony.cdma.sms.SmsEnvelope; public class CellBroadcastReceiver extends BroadcastReceiver { private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "com.android.cellbroadcastreceiver.START_CONFIG"; private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.android.cellbroadcastreceiver.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.android.cellbroadcastreceiver.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { // Implementation } }

sample: 128
buggy_code:  public boolean processMessage(Message message) { logStateAndMessage(message, this); switch (message.what) { case WifiMonitor.WPS_SUCCESS_EVENT: // Ignore intermediate success, wait for full connection break; case WifiMonitor.NETWORK_CONNECTION_EVENT: if (loadNetworksFromSupplicantAfterWps()) { replyToMessage(mSourceMessage, WifiManager.WPS_COMPLETED); <|startfocus|> mWifiConnectivityManager.forceConnectivityScan(); <|endfocus|> } else { replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.ERROR); } mSourceMessage.recycle(); mSourceMessage = null; deferMessage(message); transitionTo(mDisconnectedState); break; case WifiMonitor.WPS_OVERLAP_EVENT: replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_OVERLAP_ERROR); mSourceMessage.recycle(); mSourceMessage = null; transitionTo(mDisconnectedState); break; case WifiMonitor.WPS_FAIL_EVENT: // Arg1 has the reason for the failure if ((message.arg1 != WifiManager.ERROR) || (message.arg2 != 0)) { replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, message.arg1);
code_review:  will this happen anyway since we are going to the disconnected state? 
target code: public boolean processMessage(Message message) { logStateAndMessage(message, this); switch (message.what) { case WifiMonitor.WPS_SUCCESS_EVENT: // Ignore intermediate success, wait for full connection break; case WifiMonitor.NETWORK_CONNECTION_EVENT: if (loadNetworksFromSupplicantAfterWps()) { replyToMessage(mSourceMessage, WifiManager.WPS_COMPLETED); } else { replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.ERROR); } mSourceMessage.recycle(); mSourceMessage = null; deferMessage(message); transitionTo(mDisconnectedState); break; case WifiMonitor.WPS_OVERLAP_EVENT: replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_OVERLAP_ERROR); mSourceMessage.recycle(); mSourceMessage = null; transitionTo(mDisconnectedState); break; case WifiMonitor.WPS_FAIL_EVENT: // Arg1 has the reason for the failure if ((message.arg1 != WifiManager.ERROR) || (message.arg2 != 0)) { replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, message.arg1);
response: public boolean processMessage(Message message) { logStateAndMessage(message, this); switch (message.what) { case WifiMonitor.WPS_SUCCESS_EVENT: // Ignore intermediate success, wait for full connection break; case WifiMonitor.NETWORK_CONNECTION_EVENT: if (loadNetworksFromSupplicantAfterWps()) { replyToMessage(mSourceMessage, WifiManager.WPS_COMPLETED); mWifiConnectivityManager.forceConnectivityScan(); } else { replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.ERROR); } mSourceMessage.recycle(); mSourceMessage = null; deferMessage(message); transitionTo(mDisconnectedState); break; case WifiMonitor.WPS_OVERLAP_EVENT: replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_OVERLAP_ERROR); mSourceMessage.recycle(); mSourceMessage = null; transitionTo(mDisconnectedState); break; case WifiMonitor.WPS_FAIL_EVENT: // Arg1 has the reason for the failure if ((message.arg1 != WifiManager.ERROR) || (message.arg2 != 0)) { replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, message.arg1); } mSourceMessage.recycle(); mSourceMessage = null; transitionTo(mDisconnectedState); break; } }

sample: 129
buggy_code:  public boolean connect(Call call) { if (mIsConnected) { Log.addEvent(call, LogUtils.Events.INFO, "Already connected, ignoring request."); return true; } if (call.isSelfManaged() && !mInCallServiceInfo.isSelfManagedCallsSupported()) { <|startfocus|> return true; <|endfocus|> } Intent intent = new Intent(InCallService.SERVICE_INTERFACE); intent.setComponent(mInCallServiceInfo.getComponentName()); if (call != null && !call.isIncoming() && !call.isExternalCall()){ intent.putExtra(TelecomManager.EXTRA_OUTGOING_CALL_EXTRAS, call.getIntentExtras()); intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, call.getTargetPhoneAccount()); } Log.i(this, "Attempting to bind to InCall %s, with %s", mInCallServiceInfo, intent); mIsConnected = true; if (!mContext.bindServiceAsUser(intent, mServiceConnection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, UserHandle.CURRENT)) { Log.w(this, "Failed to connect."); mIsConnected = false; } 
code_review:  false? I think this method is supposed to return whether the connect succeeded 
target code: public boolean connect(Call call) { if (mIsConnected) { Log.addEvent(call, LogUtils.Events.INFO, "Already connected, ignoring request."); return true; } if (call.isSelfManaged() && !mInCallServiceInfo.isSelfManagedCallsSupported()) { Log.i(this, "Skipping binding to %s - doesn't support self-mgd calls", mInCallServiceInfo); mIsConnected = false; return CONNECTION_NOT_SUPPORTED; } Intent intent = new Intent(InCallService.SERVICE_INTERFACE); intent.setComponent(mInCallServiceInfo.getComponentName()); if (call != null && !call.isIncoming() && !call.isExternalCall()){ intent.putExtra(TelecomManager.EXTRA_OUTGOING_CALL_EXTRAS, call.getIntentExtras()); intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, call.getTargetPhoneAccount()); } Log.i(this, "Attempting to bind to InCall %s, with %s", mInCallServiceInfo, intent); mIsConnected = true; if (!mContext.bindServiceAsUser(intent, mServiceConnection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, UserHandle.CURRENT)) { Log.w(this, "Failed to connect."); mIsConnected = false; }
response: public boolean connect(Call call) { if (mIsConnected) { Log.addEvent(call, LogUtils.Events.INFO, "Already connected, ignoring request."); return true; } if (call.isSelfManaged() && !mInCallServiceInfo.isSelfManagedCallsSupported()) { return false; } Intent intent = new Intent(InCallService.SERVICE_INTERFACE); intent.setComponent(mInCallServiceInfo.getComponentName()); if (call != null && !call.isIncoming() && !call.isExternalCall()) { intent.putExtra(TelecomManager.EXTRA_OUTGOING_CALL_EXTRAS, call.getIntentExtras()); intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, call.getTargetPhoneAccount()); } Log.i(this, "Attempting to bind to InCall %s, with %s", mInCallServiceInfo, intent); mIsConnected = true; if (!mContext.bindServiceAsUser(intent, mServiceConnection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, UserHandle.CURRENT)) { Log.w(this, "Failed to connect."); mIsConnected = false; } return mIsConnected; }

sample: 130
buggy_code:  public CallerInfoAsyncQuery startQuery(int token, Context context, <|startfocus|> String number, CallerInfoAsyncQuery.OnQueryCompleteListener listener, Object cookie) { <|endfocus|> Log.i(TelecomSystem.getInstance(), "CallerInfoAsyncQuery.startQuery number=%s cookie=%s", Log.pii(number), cookie); return CallerInfoAsyncQuery.startQuery( token, context, number, listener, cookie);
code_review:  nit: whitespace issues 
target code: public CallerInfoAsyncQuery startQuery(int token, Context context, String number, CallerInfoAsyncQuery.OnQueryCompleteListener listener, Object cookie) { Log.i(TelecomSystem.getInstance(), "CallerInfoAsyncQuery.startQuery number=%s cookie=%s", Log.pii(number), cookie); return CallerInfoAsyncQuery.startQuery( token, context, number, listener, cookie);
response: public CallerInfoAsyncQuery startQuery(int token, Context context, String number, CallerInfoAsyncQuery.OnQueryCompleteListener listener, Object cookie) { Log.i(TelecomSystem.getInstance(), "CallerInfoAsyncQuery.startQuery number=%s cookie=%s", Log.pii(number), cookie); return CallerInfoAsyncQuery.startQuery(token, context, number, listener, cookie); }

sample: 131
buggy_code:  */ public class IncomingCallNotifier extends CallsManagerListenerBase { public interface IncomingCallNotifierFactory { IncomingCallNotifier make(Context context, CallsManagerProxy mCallsManagerProxy); } /** * Eliminates strict dependency between this class and CallsManager. */ public interface CallsManagerProxy { boolean hasCallsForOtherPhoneAccount(PhoneAccountHandle phoneAccountHandle); } // Notification for incoming calls. This is interruptive and will show up as a HUN. <|startfocus|> private static final int NOTIFICATION_INCOMING_CALL = 1; <|endfocus|> public final Call.ListenerBase mCallListener = new Call.ListenerBase() { @Override public void onCallerInfoChanged(Call call) { if (mIncomingCall != call) { return; } showIncomingCallNotification(mIncomingCall); } }; private final Context mContext; private final NotificationManager mNotificationManager; private final Set<Call> mCalls = new ArraySet<>(); private CallsManagerProxy mCallsManagerProxy; // The current incoming call we are displaying UX for. private Call mIncomingCall; public IncomingCallNotifier(Context context) { mContext = context; mNotificationManager =
code_review:  We're already using 1 for missed call notifier. 
target code: */ public class IncomingCallNotifier extends CallsManagerListenerBase { public interface IncomingCallNotifierFactory { IncomingCallNotifier make(Context context, CallsManagerProxy mCallsManagerProxy); } /** * Eliminates strict dependency between this class and CallsManager. */ public interface CallsManagerProxy { boolean hasCallsForOtherPhoneAccount(PhoneAccountHandle phoneAccountHandle); } // Notification for incoming calls. This is interruptive and will show up as a HUN. @VisibleForTesting public static final int NOTIFICATION_INCOMING_CALL = 1; public final Call.ListenerBase mCallListener = new Call.ListenerBase() { @Override public void onCallerInfoChanged(Call call) { if (mIncomingCall != call) { return; } showIncomingCallNotification(mIncomingCall); } }; private final Context mContext; private final NotificationManager mNotificationManager; private final Set<Call> mCalls = new ArraySet<>(); private CallsManagerProxy mCallsManagerProxy; // The current incoming call we are displaying UX for. private Call mIncomingCall; public IncomingCallNotifier(Context context) { mContext = context; mNotificationManager =
response: public class IncomingCallNotifier extends CallsManagerListenerBase { public interface IncomingCallNotifierFactory { IncomingCallNotifier make(Context context, CallsManagerProxy mCallsManagerProxy); } public interface CallsManagerProxy { boolean hasCallsForOtherPhoneAccount(PhoneAccountHandle phoneAccountHandle); } private static final int NOTIFICATION_INCOMING_CALL = 2; public final Call.ListenerBase mCallListener = new Call.ListenerBase() { @Override public void onCallerInfoChanged(Call call) { if (mIncomingCall != call) { return; } showIncomingCallNotification(mIncomingCall); } }; private final Context mContext; private final NotificationManager mNotificationManager; private final Set<Call> mCalls = new ArraySet<>(); private CallsManagerProxy mCallsManagerProxy; private Call mIncomingCall; public IncomingCallNotifier(Context context) { mContext = context; mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); } public void setCallsManagerProxy(CallsManagerProxy callsManagerProxy) { mCallsManagerProxy = callsManagerProxy; } public void onIncomingCall(Call call) { mCalls.add(call); if (mIncomingCall == null) { mIncomingCall = call; call.addListener(mCallListener); showIncomingCallNotification(call); } } public void onCallRemoved(Call call) { mCalls.remove(call); if (mIncomingCall == call) { mIncomingCall.removeListener(mCallListener); mIncomingCall = null; mNotificationManager.cancel(NOTIFICATION_INCOMING_CALL); if (!mCalls.isEmpty()) { Call nextCall = mCalls.iterator().next(); mIncomingCall = nextCall; nextCall.addListener(mCallListener); showIncomingCallNotification(nextCall); } } } private void showIncomingCallNotification(Call call) { // Show the incoming call notification } }

sample: 132
buggy_code:  } public boolean isConnected() { return sc.isConnected(); } public boolean isBound() { return sc.localAddress() != null; } public boolean isClosed() { return !sc.isOpen(); } public boolean isInputShutdown() { return !sc.isInputOpen(); } public boolean isOutputShutdown() { return !sc.isOutputOpen(); } /** * Android-added: for testing and internal use. <|startfocus|> * * @hide internal use only <|endfocus|> */ @Override public FileDescriptor getFileDescriptor$() { return sc.getFD(); } } 
code_review:  No need for @hide here. 
target code: } public boolean isConnected() { return sc.isConnected(); } public boolean isBound() { return sc.localAddress() != null; } public boolean isClosed() { return !sc.isOpen(); } public boolean isInputShutdown() { return !sc.isInputOpen(); } public boolean isOutputShutdown() { return !sc.isOutputOpen(); } /** * Android-added: for testing and internal use. */ @Override public FileDescriptor getFileDescriptor$() { return sc.getFD(); } }
response: public boolean isConnected() { return sc.isConnected(); } public boolean isBound() { return sc.localAddress() != null; } public boolean isClosed() { return !sc.isOpen(); } public boolean isInputShutdown() { return !sc.isInputOpen(); } public boolean isOutputShutdown() { return !sc.isOutputOpen(); } @Override public FileDescriptor getFileDescriptor$() { return sc.getFD(); }

sample: 133
buggy_code: kage libcore.java.nio.file.spi; import org.junit.Test; import java.nio.file.Paths; import java.nio.file.spi.FileTypeDetector; import static org.junit.Assert.assertEquals; public class FileTypeDetectorTest { @Test public void test_probeFileType() throws Exception { <|startfocus|> FileTypeDetector defaultFileTypeDetector = sun.nio.fs.DefaultFileTypeDetector.create(); <|endfocus|> assertEquals("text/plain", defaultFileTypeDetector.probeContentType(Paths.get("file.txt"))); assertEquals("text/x-java", defaultFileTypeDetector.probeContentType(Paths.get("file.java"))); } } 
code_review:  please add a comment that this works without actual files because it uses the their extensions to deduce mime type 
target code: kage libcore.java.nio.file.spi; import org.junit.Test; import java.nio.file.Paths; import java.nio.file.spi.FileTypeDetector; import static org.junit.Assert.assertEquals; public class FileTypeDetectorTest { @Test public void test_probeFileType() throws Exception { FileTypeDetector defaultFileTypeDetector = sun.nio.fs.DefaultFileTypeDetector.create(); // The method uses file extensions to deduce mime type, therefore, it doesn't check for // file existence. assertEquals("text/plain", defaultFileTypeDetector.probeContentType(Paths.get("file.txt"))); assertEquals("text/x-java", defaultFileTypeDetector.probeContentType(Paths.get("file.java"))); } }
response: package libcore.java.nio.file.spi; import org.junit.Test; import java.nio.file.Paths; import java.nio.file.spi.FileTypeDetector; import static org.junit.Assert.assertEquals; public class FileTypeDetectorTest { @Test public void test_probeFileType() throws Exception { FileTypeDetector defaultFileTypeDetector = sun.nio.fs.DefaultFileTypeDetector.create(); assertEquals("text/plain", defaultFileTypeDetector.probeContentType(Paths.get("file.txt"))); assertEquals("text/x-java", defaultFileTypeDetector.probeContentType(Paths.get("file.java"))); } }

sample: 134
buggy_code: import java.io.FileOutputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; /** * CarrierConfigLoader binds to privileged carrier apps to fetch carrier config overlays. */ public class CarrierConfigLoader extends ICarrierConfigLoader.Stub { private static final String LOG_TAG = "CarrierConfigLoader"; <|startfocus|> // Package name for default carrier config app, bundled with system image. private final String mDefaultCarrierConfigPackage; <|endfocus|> /** The singleton instance. */ private static CarrierConfigLoader sInstance; // The context for phone app, passed from PhoneGlobals. private Context mContext; // Carrier configs from default app, indexed by phoneID. private PersistableBundle[] mConfigFromDefaultApp; // Carrier configs from privileged carrier config app, indexed by phoneID. private PersistableBundle[] mConfigFromCarrierApp; // Service connection for binding to config app. private CarrierServiceConnection[] mServiceConnection; // Broadcast receiver for Boot intents, register intent filter in construtor.
code_review:  shouldn't this not be called default now? Just mCarrierConfigPackage. Same in the config name. 
target code: import java.io.FileOutputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; /** * CarrierConfigLoader binds to privileged carrier apps to fetch carrier config overlays. */ public class CarrierConfigLoader extends ICarrierConfigLoader.Stub { private static final String LOG_TAG = "CarrierConfigLoader"; // Package name for platform carrier config app, bundled with system image. private final String mPlatformCarrierConfigPackage; /** The singleton instance. */ private static CarrierConfigLoader sInstance; // The context for phone app, passed from PhoneGlobals. private Context mContext; // Carrier configs from default app, indexed by phoneID. private PersistableBundle[] mConfigFromDefaultApp; // Carrier configs from privileged carrier config app, indexed by phoneID. private PersistableBundle[] mConfigFromCarrierApp; // Service connection for binding to config app. private CarrierServiceConnection[] mServiceConnection; // Broadcast receiver for Boot intents, register intent filter in construtor.
response: import java.io.FileOutputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; /** * CarrierConfigLoader binds to privileged carrier apps to fetch carrier config overlays. */ public class CarrierConfigLoader extends ICarrierConfigLoader.Stub { private static final String LOG_TAG = "CarrierConfigLoader"; private final String mCarrierConfigPackage; private static CarrierConfigLoader sInstance; private Context mContext; private PersistableBundle[] mConfigFromDefaultApp; private PersistableBundle[] mConfigFromCarrierApp; private CarrierServiceConnection[] mServiceConnection; public CarrierConfigLoader(String carrierConfigPackage) { mCarrierConfigPackage = carrierConfigPackage; } public static CarrierConfigLoader getInstance() { if (sInstance == null) { sInstance = new CarrierConfigLoader("default"); } return sInstance; } public void setContext(Context context) { mContext = context; } public void loadConfigs() { // Load carrier configs from default app mConfigFromDefaultApp = loadConfigsFromDefaultApp(); // Load carrier configs from privileged carrier config app mConfigFromCarrierApp = loadConfigsFromCarrierApp(); } private PersistableBundle[] loadConfigsFromDefaultApp() { // Implementation here } private PersistableBundle[] loadConfigsFromCarrierApp() { // Implementation here } // Other methods and classes }

sample: 135
buggy_code:  enforceTetherAccessPermission(); return mTethering.getTetheredIfaces(); } @Override public String[] getTetheringErroredIfaces() { enforceTetherAccessPermission(); return mTethering.getErroredIfaces(); } @Override public String[] getTetheredDhcpRanges() { enforceConnectivityInternalPermission(); return mTethering.getTetheredDhcpRanges(); } // if ro.tether.denied = true we default to no tethering // gservices could set the secure setting to 1 though to enable it on a build where it // had previously been turned off. @Override public boolean isTetheringSupported() { enforceTetherAccessPermission(); <|startfocus|> int defaultVal = (SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1); <|endfocus|> boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING); return tetherEnabledInSettings && mUserManager.isAdminUser() && mTethering.hasTetherableConfiguration(); } @Override public void startTethering(int type, ResultReceiver receiver, boolean showProvisioningUi) {
code_review:  Java style: rename to "adminUser" (the "is" prefix is used only in method names) 
target code: enforceTetherAccessPermission(); return mTethering.getTetheredIfaces(); } @Override public String[] getTetheringErroredIfaces() { enforceTetherAccessPermission(); return mTethering.getErroredIfaces(); } @Override public String[] getTetheredDhcpRanges() { enforceConnectivityInternalPermission(); return mTethering.getTetheredDhcpRanges(); } // if ro.tether.denied = true we default to no tethering // gservices could set the secure setting to 1 though to enable it on a build where it // had previously been turned off. @Override public boolean isTetheringSupported() { enforceTetherAccessPermission(); int defaultVal = (mSystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1); boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING); return tetherEnabledInSettings && mUserManager.isAdminUser() && mTethering.hasTetherableConfiguration(); } @Override public void startTethering(int type, ResultReceiver receiver, boolean showProvisioningUi) {
response: enforceTetherAccessPermission(); return mTethering.getTetheredIfaces(); } @Override public String[] getTetheringErroredIfaces() { enforceTetherAccessPermission(); return mTethering.getErroredIfaces(); } @Override public String[] getTetheredDhcpRanges() { enforceConnectivityInternalPermission(); return mTethering.getTetheredDhcpRanges(); } @Override public boolean isTetheringSupported() { enforceTetherAccessPermission(); int defaultVal = (SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1); boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING); return tetherEnabledInSettings && mUserManager.isAdminUser() && mTethering.hasTetherableConfiguration(); } @Override public void startTethering(int type, ResultReceiver receiver, boolean showProvisioningUi) {

sample: 136
buggy_code:  private boolean updateBssidBlacklist(String bssid, boolean enable, int reasonCode) { if (enable) { return mBssidBlacklist.remove(bssid) != null; <|startfocus|> } else { BssidBlacklistStatus status = mBssidBlacklist.get(bssid); if (status == null) { // First time for this BSSID status = new BssidBlacklistStatus(); mBssidBlacklist.put(bssid, status); } <|endfocus|> status.blacklistedTimeStamp = mClock.getElapsedSinceBootMillis(); status.counter++; if (!status.isBlacklisted) { if (status.counter >= BSSID_BLACKLIST_THRESHOLD || reasonCode == REASON_CODE_AP_UNABLE_TO_HANDLE_NEW_STA) { status.isBlacklisted = true; return true; } } return false; }
code_review:  To make this a little more readable: The majority of the impl in this method has an extra indent because of the else. If this seems less readable, then maybe adding a comment above the if would alleviate that concern. Having the else makes it harder to read since you end up with deep indents near the end of the method. 
target code: private boolean updateBssidBlacklist(String bssid, boolean enable, int reasonCode) { if (enable) { return mBssidBlacklist.remove(bssid) != null; } status.blacklistedTimeStamp = mClock.getElapsedSinceBootMillis(); status.counter++; if (!status.isBlacklisted) { if (status.counter >= BSSID_BLACKLIST_THRESHOLD || reasonCode == REASON_CODE_AP_UNABLE_TO_HANDLE_NEW_STA) { status.isBlacklisted = true; return true; } } return false; }
response: private boolean updateBssidBlacklist(String bssid, boolean enable, int reasonCode) { if (enable) { return mBssidBlacklist.remove(bssid) != null; } else { BssidBlacklistStatus status = mBssidBlacklist.get(bssid); if (status == null) { // First time for this BSSID status = new BssidBlacklistStatus(); mBssidBlacklist.put(bssid, status); } status.blacklistedTimeStamp = mClock.getElapsedSinceBootMillis(); status.counter++; if (!status.isBlacklisted) { if (status.counter >= BSSID_BLACKLIST_THRESHOLD || reasonCode == REASON_CODE_AP_UNABLE_TO_HANDLE_NEW_STA) { status.isBlacklisted = true; return true; } } return false; } }

sample: 137
buggy_code:  when(mClock.getElapsedSinceBootMillis()).thenReturn(SystemClock.elapsedRealtime() + WifiConnectivityManager.BSSID_BLACKLIST_EXPIRE_TIME_MS); mWifiConnectivityManager.forceConnectivityScan(); assertFalse(mWifiConnectivityManager.isBssidDisabled(bssid)); } /** * When WifiConnectivityManager is on and Wifi client mode is enabled, framework * queries firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability. * * Expected behavior: WifiConnectivityManager#setWifiEnabled calls into <|startfocus|> * WifiConnectivityHelper#getFirmwareRoamingIinfo <|endfocus|> */ @Test public void verifyGetFirmwareRoamingInfoIsCalledWhenEnableWiFiAndWcmOn() { reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); } /** * When WifiConnectivityManager is off, verify that framework does not * query firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability when enabling Wifi client mode. * * Expected behavior: WifiConnectivityManager#setWifiEnabled does not call into * WifiConnectivityHelper#getFirmwareRoamingIinfo
code_review:  spelling 
target code: when(mClock.getElapsedSinceBootMillis()).thenReturn(SystemClock.elapsedRealtime() + WifiConnectivityManager.BSSID_BLACKLIST_EXPIRE_TIME_MS); mWifiConnectivityManager.forceConnectivityScan(); assertFalse(mWifiConnectivityManager.isBssidDisabled(bssid)); } /** * When WifiConnectivityManager is on and Wifi client mode is enabled, framework * queries firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability. * * Expected behavior: WifiConnectivityManager#setWifiEnabled calls into * WifiConnectivityHelper#getFirmwareRoamingInfo */ @Test public void verifyGetFirmwareRoamingInfoIsCalledWhenEnableWiFiAndWcmOn() { reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); } /** * When WifiConnectivityManager is off, verify that framework does not * query firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability when enabling Wifi client mode. * * Expected behavior: WifiConnectivityManager#setWifiEnabled does not call into * WifiConnectivityHelper#getFirmwareRoamingIinfo
response: when(mClock.getElapsedSinceBootMillis()).thenReturn(SystemClock.elapsedRealtime() + WifiConnectivityManager.BSSID_BLACKLIST_EXPIRE_TIME_MS); mWifiConnectivityManager.forceConnectivityScan(); assertFalse(mWifiConnectivityManager.isBssidDisabled(bssid)); } /** * When WifiConnectivityManager is on and Wifi client mode is enabled, framework * queries firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability. * * Expected behavior: WifiConnectivityManager#setWifiEnabled calls into * WifiConnectivityHelper#getFirmwareRoamingInfo */ @Test public void verifyGetFirmwareRoamingInfoIsCalledWhenEnableWiFiAndWcmOn() { reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); } /** * When WifiConnectivityManager is off, verify that framework does not * query firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability when enabling Wifi client mode. * * Expected behavior: WifiConnectivityManager#setWifiEnabled does not call into * WifiConnectivityHelper#getFirmwareRoamingIinfo */ @Test public void verifyGetFirmwareRoamingInfoIsNotCalledWhenEnableWiFiAndWcmOff() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.setWifiEnabled(false); verify(mWifiConnectivityHelper, never()).getFirmwareRoamingInfo(); }

sample: 138
buggy_code:  reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); } /** * When WifiConnectivityManager is off, verify that framework does not * query firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability when enabling Wifi client mode. * * Expected behavior: WifiConnectivityManager#setWifiEnabled does not call into <|startfocus|> * WifiConnectivityHelper#getFirmwareRoamingIinfo <|endfocus|> */ @Test public void verifyGetFirmwareRoamingInfoIsNotCalledWhenEnableWiFiAndWcmOff() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.enable(false); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper, times(0)).getFirmwareRoamingInfo(); } /* * Firmware supports controlled roaming. * Connect to a network from the DISCONNECTED state. * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the * expected candidate network ID, and the BSSID value should be * 'any' since firmware controls the roaming. */ @Test
code_review:  spelling 
target code: reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); } /** * When WifiConnectivityManager is off, verify that framework does not * query firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability when enabling Wifi client mode. * * Expected behavior: WifiConnectivityManager#setWifiEnabled does not call into * WifiConnectivityHelper#getFirmwareRoamingInfo */ @Test public void verifyGetFirmwareRoamingInfoIsNotCalledWhenEnableWiFiAndWcmOff() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.enable(false); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper, times(0)).getFirmwareRoamingInfo(); } /* * Firmware supports controlled roaming. * Connect to a network from the DISCONNECTED state. * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the * expected candidate network ID, and the BSSID value should be * 'any' since firmware controls the roaming. */ @Test
response: reset(mWifiConnectivityHelper); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); } /** * When WifiConnectivityManager is off, verify that framework does not * query firmware via WifiConnectivityHelper to check if firmware roaming is * supported and its capability when enabling Wifi client mode. * * Expected behavior: WifiConnectivityManager#setWifiEnabled does not call into * WifiConnectivityHelper#getFirmwareRoamingInfo */ @Test public void verifyGetFirmwareRoamingInfoIsNotCalledWhenEnableWiFiAndWcmOff() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.enable(false); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper, times(0)).getFirmwareRoamingInfo(); } /* * Firmware supports controlled roaming. * Connect to a network from the DISCONNECTED state. * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the * expected candidate network ID, and the BSSID value should be * 'any' since firmware controls the roaming. */ @Test

sample: 139
buggy_code: <|startfocus|> public void useAnyBssidForConnectionIfFirmwareControlsRoaming() { <|endfocus|> // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY);
code_review:  do you have a test for a specific Bssid + framework roam? 
target code: public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasNoBssidSpecified() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY);
response: public void useAnyBssidForConnectionIfFirmwareControlsRoaming() { when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); mWifiConnectivityManager.handleScreenStateChanged(true); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); }

sample: 140
buggy_code: <|startfocus|> public void noFrameworkRoamingIfFirmwareControlRoaming() { <|endfocus|> // Mock the currently connected network which has the same networkID and // SSID as the one to be selected. WifiConfiguration currentNetwork = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine, times(0)).startRoamToNetwork( anyInt(), anyObject());
code_review:  maybe change to noFrameworkRoamingIfConnectedAndFirmwareRoamingSupported 
target code: public void noFrameworkRoamingIfConnectedAndFirmwareRoamingSupported() { // Mock the currently connected network which has the same networkID and // SSID as the one to be selected. WifiConfiguration currentNetwork = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine, times(0)).startRoamToNetwork( anyInt(), anyObject());
response: public void noFrameworkRoamingIfConnectedAndFirmwareRoamingSupported() { WifiConfiguration currentNetwork = generateWifiConfig(0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject()); }

sample: 141
buggy_code:  private void refreshBssidBlacklist() { <|startfocus|> boolean updated = false; <|endfocus|> Iterator<BssidBlacklistStatus> iter = mBssidBlacklist.values().iterator(); Long currentTimeStamp = mClock.getElapsedSinceBootMillis(); while (iter.hasNext()) { BssidBlacklistStatus status = iter.next(); if (status.isBlacklisted && ((currentTimeStamp - status.blacklistedTimeStamp) >= BSSID_BLACKLIST_EXPIRE_TIME_MS)) { iter.remove(); updated = true; } } if (updated && mConnectivityHelper.isFirmwareRoamingSupported()) { updateFirmwareBssidBlacklist(); }
code_review:  you could add a check for an empty blacklist and return to avoid calling the code below. 
target code: private void refreshBssidBlacklist() { Iterator<BssidBlacklistStatus> iter = mBssidBlacklist.values().iterator(); Long currentTimeStamp = mClock.getElapsedSinceBootMillis(); while (iter.hasNext()) { BssidBlacklistStatus status = iter.next(); if (status.isBlacklisted && ((currentTimeStamp - status.blacklistedTimeStamp) >= BSSID_BLACKLIST_EXPIRE_TIME_MS)) { iter.remove(); updated = true; } } if (updated && mConnectivityHelper.isFirmwareRoamingSupported()) { updateFirmwareBssidBlacklist(); }
response: private void refreshBssidBlacklist() { boolean updated = false; Iterator<BssidBlacklistStatus> iter = mBssidBlacklist.values().iterator(); Long currentTimeStamp = mClock.getElapsedSinceBootMillis(); while (iter.hasNext()) { BssidBlacklistStatus status = iter.next(); if (status.isBlacklisted && ((currentTimeStamp - status.blacklistedTimeStamp) >= BSSID_BLACKLIST_EXPIRE_TIME_MS)) { iter.remove(); updated = true; } } if (updated && mConnectivityHelper.isFirmwareRoamingSupported()) { updateFirmwareBssidBlacklist(); } }

sample: 142
buggy_code:  // network(same SSID & security type) as the currently connected one. // This might save a disconnection triggered by network switch when // the score of the currently connected BSSID is lower than a network // with a different SSID, but within the currently connected network // there is a BSSID better than the currently connected BSSID. // This is under the assumption that firmware will roam the device // to that better BSSID. score += mSameBssidAward; <|startfocus|> sbuf.append(" Firmware roaming same BSSID bonus: ") <|endfocus|> .append(mSameBssidAward).append(","); } } // When firmware roaming is supported, the same BSSID award is already // applied above, skip it. if (!mConnectivityHelper.isFirmwareRoamingSupported()) { // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) .append(","); } } // Security award.
code_review:  maybe "equivalent" since they aren't actually the same, but we are treating them as "equals" 
target code: // network(same SSID & security type) as the currently connected one. // This might save a disconnection triggered by network switch when // the score of the currently connected BSSID is lower than a network // with a different SSID, but within the currently connected network // there is a BSSID better than the currently connected BSSID. // This is under the assumption that firmware will roam the device // to that better BSSID. score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") .append(mSameBssidAward).append(","); } } // When firmware roaming is supported, the same BSSID award is already // applied above, skip it. if (!mConnectivityHelper.isFirmwareRoamingSupported()) { // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) .append(","); } } // Security award.
response: // network(same SSID & security type) as the currently connected one. // This might save a disconnection triggered by network switch when // the score of the currently connected BSSID is lower than a network // with a different SSID, but within the currently connected network // there is a BSSID better than the currently connected BSSID. // This is under the assumption that firmware will roam the device // to that better BSSID. score += mSameBssidAward; sbuf.append(" Firmware roaming same BSSID bonus: ").append(mSameBssidAward).append(","); // When firmware roaming is supported, the same BSSID award is already // applied above, skip it. if (!mConnectivityHelper.isFirmwareRoamingSupported()) { // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward).append(","); } } // Security award.

sample: 143
buggy_code:  data[0] = new StructCapUserData(data[0].effective, data[0].permitted, data[0].permitted); data[1] = new StructCapUserData(data[1].effective, data[1].permitted, data[1].permitted); Os.capset(header, data); } for (int i = 0; i < 64; i++) { <|startfocus|> int dataIndex = i / 32; int bitShift = i % 32; if ((data[dataIndex].inheritable & (1 << bitShift)) != 0) { <|endfocus|> try { Os.prctl(OsConstants.PR_CAP_AMBIENT, OsConstants.PR_CAP_AMBIENT_RAISE, i, 0, 0); } catch (ErrnoException ex) { Slog.e(RuntimeInit.TAG, "RuntimeInit: Failed to raise ambient capability " + i, ex); } } } } catch (Exception e) { Slog.e(RuntimeInit.TAG, "RuntimeInit: Failed to preserve capabilities", e); }
code_review:  add CAP_TO_INDEX and CAP_TO_MASK to OsConstants, like we did S_ISDIR and friends? https://cs.corp.google.com/android/libcore/luni/src/main/java/android/system/OsConstants.java?q=file:osconstants.java&sq=package:%5Eandroid$&l=29 
target code: data[0] = new StructCapUserData(data[0].effective, data[0].permitted, data[0].permitted); data[1] = new StructCapUserData(data[1].effective, data[1].permitted, data[1].permitted); Os.capset(header, data); } for (int i = 0; i < 64; i++) { int dataIndex = OsConstants.CAP_TO_INDEX(i); int capMask = OsConstants.CAP_TO_MASK(i); if ((data[dataIndex].inheritable & capMask) != 0) { try { Os.prctl(OsConstants.PR_CAP_AMBIENT, OsConstants.PR_CAP_AMBIENT_RAISE, i, 0, 0); } catch (ErrnoException ex) { Slog.e(RuntimeInit.TAG, "RuntimeInit: Failed to raise ambient capability " + i, ex); } } } } catch (Exception e) { Slog.e(RuntimeInit.TAG, "RuntimeInit: Failed to preserve capabilities", e); }
response: static boolean matchOnSP(String xmlSP, CarrierIdentifier id) { boolean matchFound = false; String currentSP = id.getSpn(); if (SPN_EMPTY_MATCH.equalsIgnoreCase(xmlSP)) { if (TextUtils.isEmpty(currentSP)) { matchFound = true; } } else if (currentSP != null) { Pattern spPattern = Pattern.compile(xmlSP); Matcher matcher = spPattern.matcher(currentSP); matchFound = matcher.matches(); } return matchFound; } public void run() { return this.editingContextAdapter.performModelChange(() -> { String actionExpression = action.getActionExpression(); EAttribute eAttribute = EefPackage.Literals.EEF_TOOLBAR_ACTION__ACTION_EXPRESSION; Map<String, Object> variables = new HashMap<String, Object>(); variables.putAll(EEFGroupController.this.variableManager.getVariables()); EvalFactory.of(EEFGroupController.this.interpreter, variables).logIfBlank(eAttribute).call(actionExpression); }); } package org.midonet.cluster.services.discovery; import com.fasterxml.jackson.annotation.JsonRootName; /** * Test class for service discovery details in java. * Java descriptions require, at least, the @JsonRootName annotation, * and a default constructor without parameters. * Methods 'equals' and 'hashCode' must be overwritten. */ @JsonRootName("details") public class TestJavaServiceDetails { private String description = ""; public TestJavaServiceDetails(String desc) { description = (desc == null)? "" : desc; } public TestJavaServiceDetails() { this(""); } public void setDescription(String desc) { description = (desc == null)? "" : desc; } // Methods 'equals' and 'hashCode' should be added here } data[0] = new StructCapUserData(data[0].effective, data[0].permitted, data[0].permitted); data[1] = new StructCapUserData(data[1].effective, data[1].permitted, data[1].permitted); Os.capset(header, data); for (int i = 0; i < 64; i++) { int dataIndex = i / 32; int bitShift = i % 32; if ((data[dataIndex].inheritable & (1 << bitShift)) != 0) { try { Os.prctl(Os

sample: 144
buggy_code:  * This is supposed to be from Telephony service. * otherwise we think it is from other applications. * @return Returns true if the country code passed in is acceptable. */ public synchronized boolean setCountryCode(String countryCode) { if (DBG) Log.d(TAG, "Receive set country code request: " + countryCode); // Empty country code. if (TextUtils.isEmpty(countryCode)) { <|startfocus|> if (DBG) Log.d(TAG, "Revceived empty country code, reset to default country code"); <|endfocus|> mTelephonyCountryCode = null; } else { mTelephonyCountryCode = countryCode.toUpperCase(); } // If wpa_supplicant is ready we set the country code now, otherwise it will be // set once wpa_supplicant is ready. if (mReady) { updateCountryCode(); } return true; } /** * Method to get the Country Code that was sent to wpa_supplicant. * * @return Returns the local copy of the Country Code that was sent to the driver upon * setReadyForChange(true).
code_review:  spelling 
target code: * This is supposed to be from Telephony service. * otherwise we think it is from other applications. * @return Returns true if the country code passed in is acceptable. */ public synchronized boolean setCountryCode(String countryCode) { if (DBG) Log.d(TAG, "Receive set country code request: " + countryCode); // Empty country code. if (TextUtils.isEmpty(countryCode)) { if (DBG) Log.d(TAG, "Received empty country code, reset to default country code"); mTelephonyCountryCode = null; } else { mTelephonyCountryCode = countryCode.toUpperCase(); } // If wpa_supplicant is ready we set the country code now, otherwise it will be // set once wpa_supplicant is ready. if (mReady) { updateCountryCode(); } return true; } /** * Method to get the Country Code that was sent to wpa_supplicant. * * @return Returns the local copy of the Country Code that was sent to the driver upon * setReadyForChange(true).
response: /** * This is supposed to be from Telephony service. * otherwise we think it is from other applications. * @return Returns true if the country code passed in is acceptable. */ public synchronized boolean setCountryCode(String countryCode) { if (DBG) Log.d(TAG, "Receive set country code request: " + countryCode); // Empty country code. if (TextUtils.isEmpty(countryCode)) { if (DBG) Log.d(TAG, "Received empty country code, reset to default country code"); mTelephonyCountryCode = null; } else { mTelephonyCountryCode = countryCode.toUpperCase(); } // If wpa_supplicant is ready we set the country code now, otherwise it will be // set once wpa_supplicant is ready. if (mReady) { updateCountryCode(); } return true; } /** * Method to get the Country Code that was sent to wpa_supplicant. * * @return Returns the local copy of the Country Code that was sent to the driver upon * setReadyForChange(true). */

sample: 145
buggy_code:  * See the License for the specific language governing permissions and * limitations under the License. */ package android.system; /** * Constants and helper functions for use with {@link Os}. */ public final class OsConstants { private OsConstants() { } /** * Returns the index of the element in the cap_user_data array that this capability is stored * in. * @hide */ <|startfocus|> public static int CAP_TO_INDEX(int x) { return x >> 5; } <|endfocus|> /** * Returns the mask for the given capability. This is relative to the capability's cap_user_data * element, the index of which can be retrieved with CAP_TO_INDEX. * @hide */ public static int CAP_TO_MASK(int x) { return 1 << (x & 31); } /** * Tests whether the given mode is a block device. */ public static boolean S_ISBLK(int mode) { return (mode & S_IFMT) == S_IFBLK; } /**
code_review:  Do we have to worry that "x" is an unsigned value in C code, whereas here it's a signed value? Shouldn't we be using ">>>" (bitwise shift) instead of ">>" (arithmetic shift)? 
target code: * See the License for the specific language governing permissions and * limitations under the License. */ package android.system; /** * Constants and helper functions for use with {@link Os}. */ public final class OsConstants { private OsConstants() { } /** * Returns the index of the element in the cap_user_data array that this capability is stored * in. * @hide */ public static int CAP_TO_INDEX(int x) { return x >>> 5; } /** * Returns the mask for the given capability. This is relative to the capability's cap_user_data * element, the index of which can be retrieved with CAP_TO_INDEX. * @hide */ public static int CAP_TO_MASK(int x) { return 1 << (x & 31); } /** * Tests whether the given mode is a block device. */ public static boolean S_ISBLK(int mode) { return (mode & S_IFMT) == S_IFBLK; } /**
response: package android.system; public final class OsConstants { private OsConstants() { } public static int CAP_TO_INDEX(int x) { return x >> 5; } public static int CAP_TO_MASK(int x) { return 1 << (x & 31); } public static boolean S_ISBLK(int mode) { return (mode & S_IFMT) == S_IFBLK; } }

sample: 146
buggy_code:  refreshBssidBlacklist(); if (mStateMachine.isLinkDebouncing() || mStateMachine.isSupplicantTransientState()) { localLog(listenerName + " onResults: No network selection because linkDebouncing is " + mStateMachine.isLinkDebouncing() + " and supplicantTransient is " + mStateMachine.isSupplicantTransientState()); return false; } localLog(listenerName + " onResults: start network selection"); HashSet<String> blacklistedBssids = buildBssidBlacklist(); WifiConfiguration candidate = <|startfocus|> mNetworkSelector.selectNetwork(scanDetails, blacklistedBssids, mWifiInfo, <|endfocus|> mStateMachine.isConnected(), mStateMachine.isDisconnected(), mUntrustedConnectionAllowed); mWifiLastResortWatchdog.updateAvailableNetworks( mNetworkSelector.getFilteredScanDetails()); mWifiMetrics.countScanResults(scanDetails); if (candidate != null) { localLog(listenerName + ": WNS candidate-" + candidate.SSID); connectToNetwork(candidate); return true; } else { return false; }
code_review:  you could just put the buildBssidBlacklist call here (no real preference on this, just doesn't seem to be used after this) 
target code: refreshBssidBlacklist(); if (mStateMachine.isLinkDebouncing() || mStateMachine.isSupplicantTransientState()) { localLog(listenerName + " onResults: No network selection because linkDebouncing is " + mStateMachine.isLinkDebouncing() + " and supplicantTransient is " + mStateMachine.isSupplicantTransientState()); return false; } localLog(listenerName + " onResults: start network selection"); HashSet<String> blacklistedBssids = buildBssidBlacklist(); WifiConfiguration candidate = mNetworkSelector.selectNetwork(scanDetails, buildBssidBlacklist(), mWifiInfo, mStateMachine.isConnected(), mStateMachine.isDisconnected(), mUntrustedConnectionAllowed); mWifiLastResortWatchdog.updateAvailableNetworks( mNetworkSelector.getFilteredScanDetails()); mWifiMetrics.countScanResults(scanDetails); if (candidate != null) { localLog(listenerName + ": WNS candidate-" + candidate.SSID); connectToNetwork(candidate); return true; } else { return false; }
response: refreshBssidBlacklist(); if (mStateMachine.isLinkDebouncing() || mStateMachine.isSupplicantTransientState()) { localLog(listenerName + " onResults: No network selection because linkDebouncing is " + mStateMachine.isLinkDebouncing() + " and supplicantTransient is " + mStateMachine.isSupplicantTransientState()); return false; } localLog(listenerName + " onResults: start network selection"); WifiConfiguration candidate = mNetworkSelector.selectNetwork(scanDetails, buildBssidBlacklist(), mWifiInfo, mStateMachine.isConnected(), mStateMachine.isDisconnected(), mUntrustedConnectionAllowed); mWifiLastResortWatchdog.updateAvailableNetworks(mNetworkSelector.getFilteredScanDetails()); mWifiMetrics.countScanResults(scanDetails); if (candidate != null) { localLog(listenerName + ": WNS candidate-" + candidate.SSID); connectToNetwork(candidate); return true; } else { return false; }

sample: 147
buggy_code: <|startfocus|> public void useAnyBssidForConnectionIfFirmwareControlsRoaming() { <|endfocus|> // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY);
code_review:  Now I am a bit confused with this test. Shouldn't it have a setup like below and then confirm the selected BSSID is replaced with ANY? 
target code: public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasNoBssidSpecified() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY);
response: public void useAnyBssidForConnectionIfFirmwareControlsRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); // Verify that startConnectToNetwork is called with candidate network ID and SUPPLICANT_BSSID_ANY verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); }

sample: 148
buggy_code:  private void localLog(String log) { <|startfocus|> if (mLocalLog != null) { mLocalLog.log(log); } <|endfocus|>
code_review:  is this possible? it is a final variable 
target code: private void localLog(String log) { mLocalLog.log(log);
response: private void localLog(String log) { if (mLocalLog != null) { mLocalLog.log(log); } }

sample: 149
buggy_code:  private void updateEverything() { BatteryInfo info = BatteryInfo.getBatteryInfo(getContext(), mBatteryBroadcast, mStats, SystemClock.elapsedRealtime() * 1000); final View view = getView(); if (mShowCellSignal) { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, <|startfocus|> mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); <|endfocus|> } else { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); } ((TextView) view.findViewById(R.id.charge)).setText(info.batteryPercentString); ((TextView) view.findViewById(R.id.estimation)).setText(info.remainingLabel); bindData(mChargingParser, R.string.battery_stats_charging_label, R.id.charging_group); bindData(mScreenOn, R.string.battery_stats_screen_on_label, R.id.screen_on_group); bindData(mGpsParser, R.string.battery_stats_gps_on_label, R.id.gps_group);
code_review:  Please wrap this line. 
target code: private void updateEverything() { BatteryInfo info = BatteryInfo.getBatteryInfo(getContext(), mBatteryBroadcast, mStats, SystemClock.elapsedRealtime() * 1000); final View view = getView(); if (mShowCellSignal) { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); } else { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); } ((TextView) view.findViewById(R.id.charge)).setText(info.batteryPercentString); ((TextView) view.findViewById(R.id.estimation)).setText(info.remainingLabel); bindData(mChargingParser, R.string.battery_stats_charging_label, R.id.charging_group); bindData(mScreenOn, R.string.battery_stats_screen_on_label, R.id.screen_on_group); bindData(mGpsParser, R.string.battery_stats_gps_on_label, R.id.gps_group);
response: private void updateEverything() { BatteryInfo info = BatteryInfo.getBatteryInfo(getContext(), mBatteryBroadcast, mStats, SystemClock.elapsedRealtime() * 1000); final View view = getView(); if (mShowCellSignal) { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); } else { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); } ((TextView) view.findViewById(R.id.charge)).setText(info.batteryPercentString); ((TextView) view.findViewById(R.id.estimation)).setText(info.remainingLabel); bindData(mChargingParser, R.string.battery_stats_charging_label, R.id.charging_group); bindData(mScreenOn, R.string.battery_stats_screen_on_label, R.id.screen_on_group); bindData(mGpsParser, R.string.battery_stats_gps_on_label, R.id.gps_group); }

sample: 150
buggy_code:  SystemClock.elapsedRealtime() * 1000); final View view = getView(); if (mShowCellSignal) { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); } else { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, <|startfocus|> mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); <|endfocus|> } ((TextView) view.findViewById(R.id.charge)).setText(info.batteryPercentString); ((TextView) view.findViewById(R.id.estimation)).setText(info.remainingLabel); bindData(mChargingParser, R.string.battery_stats_charging_label, R.id.charging_group); bindData(mScreenOn, R.string.battery_stats_screen_on_label, R.id.screen_on_group); bindData(mGpsParser, R.string.battery_stats_gps_on_label, R.id.gps_group); bindData(mFlashlightParser, R.string.battery_stats_flashlight_on_label, R.id.flashlight_group);
code_review:  Also this line. 
target code: SystemClock.elapsedRealtime() * 1000); final View view = getView(); if (mShowCellSignal) { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); } else { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); } ((TextView) view.findViewById(R.id.charge)).setText(info.batteryPercentString); ((TextView) view.findViewById(R.id.estimation)).setText(info.remainingLabel); bindData(mChargingParser, R.string.battery_stats_charging_label, R.id.charging_group); bindData(mScreenOn, R.string.battery_stats_screen_on_label, R.id.screen_on_group); bindData(mGpsParser, R.string.battery_stats_gps_on_label, R.id.gps_group); bindData(mFlashlightParser, R.string.battery_stats_flashlight_on_label, R.id.flashlight_group);
response: SystemClock.elapsedRealtime() * 1000); final View view = getView(); if (mShowCellSignal) { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); } else { info.bindHistory((UsageView) view.findViewById(R.id.battery_usage), mChargingParser, mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); } ((TextView) view.findViewById(R.id.charge)).setText(info.batteryPercentString); ((TextView) view.findViewById(R.id.estimation)).setText(info.remainingLabel); bindData(mChargingParser, R.string.battery_stats_charging_label, R.id.charging_group); bindData(mScreenOn, R.string.battery_stats_screen_on_label, R.id.screen_on_group); bindData(mGpsParser, R.string.battery_stats_gps_on_label, R.id.gps_group); bindData(mFlashlightParser, R.string.battery_stats_flashlight_on_label, R.id.flashlight_group);

sample: 151
buggy_code:  bindData(mFlashlightParser, R.string.battery_stats_flashlight_on_label, R.id.flashlight_group); bindData(mCameraParser, R.string.battery_stats_camera_on_label, R.id.camera_group); bindData(mWifiParser, R.string.battery_stats_wifi_running_label, R.id.wifi_group); bindData(mCpuParser, R.string.battery_stats_wake_lock_label, R.id.cpu_group); if (mShowCellSignal) { <|startfocus|> bindData(mPhoneParser, R.string.battery_stats_phone_signal_label, R.id.cell_network_group); <|endfocus|> } else { view.findViewById(R.id.cell_network_group).setVisibility(View.GONE); }
code_review:  And this :) 
target code: bindData(mFlashlightParser, R.string.battery_stats_flashlight_on_label, R.id.flashlight_group); bindData(mCameraParser, R.string.battery_stats_camera_on_label, R.id.camera_group); bindData(mWifiParser, R.string.battery_stats_wifi_running_label, R.id.wifi_group); bindData(mCpuParser, R.string.battery_stats_wake_lock_label, R.id.cpu_group); if (mShowCellSignal) { bindData(mPhoneParser, R.string.battery_stats_phone_signal_label, R.id.cell_network_group); } else { view.findViewById(R.id.cell_network_group).setVisibility(View.GONE); }
response: bindData(mFlashlightParser, R.string.battery_stats_flashlight_on_label, R.id.flashlight_group); bindData(mCameraParser, R.string.battery_stats_camera_on_label, R.id.camera_group); bindData(mWifiParser, R.string.battery_stats_wifi_running_label, R.id.wifi_group); bindData(mCpuParser, R.string.battery_stats_wake_lock_label, R.id.cpu_group); if (mShowCellSignal) { bindData(mPhoneParser, R.string.battery_stats_phone_signal_label, R.id.cell_network_group); } else { view.findViewById(R.id.cell_network_group).setVisibility(View.GONE); }

sample: 152
buggy_code:  // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); <|startfocus|> } else { <|endfocus|> assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); timeReceiver.close(); assertTrue(timeReceiver.mTimeUsed != 0); } /** * Verify that the TimeTrackingAPI works properly when switching away from the monitored task. */
code_review:  Please explain here and below how the lack of home screen was causing this test to fail. 
target code: // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { // With platforms that have no home screen, focus is returned to something else that is // considered a completion of the tracked activity flow, and hence time tracking is // triggered. assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); timeReceiver.close(); assertTrue(timeReceiver.mTimeUsed != 0); } /** * Verify that the TimeTrackingAPI works properly when switching away from the monitored task. */
response: // Wait until it finishes and end the receiver then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the receiver then. assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); timeReceiver.close(); assertTrue(timeReceiver.mTimeUsed != 0); } /** * Verify that the TimeTrackingAPI works properly when switching away from the monitored task. */

sample: 153
buggy_code:  * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters <|startfocus|> * will fail and return the appropriate error value. Ie calling getSlotIndex(INVALID_SUBSCRIPTION_ID) * will return INVALID_SIM_SLOT_INDEX and calling getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) * will return null. <|endfocus|> * */ public class SubscriptionController extends ISub.Stub { static final String LOG_TAG = "SubscriptionController"; static final boolean DBG = true; static final boolean VDBG = false; static final int MAX_LOCAL_LOG_LINES = 500; // TODO: Reduce to 100 when 17678050 is fixed private ScLocalLog mLocalLog = new ScLocalLog(MAX_LOCAL_LOG_LINES); /** * Copied from android.util.LocalLog with flush() adding flush and line number * TODO: Update LocalLog */ static class ScLocalLog { private LinkedList<String> mLog;
code_review:  rewrap line 
target code: * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters * will fail and return the appropriate error value. Ie calling * getSlotIndex(INVALID_SUBSCRIPTION_ID) will return INVALID_SIM_SLOT_INDEX and calling * getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) will return null. * */ public class SubscriptionController extends ISub.Stub { static final String LOG_TAG = "SubscriptionController"; static final boolean DBG = true; static final boolean VDBG = false; static final int MAX_LOCAL_LOG_LINES = 500; // TODO: Reduce to 100 when 17678050 is fixed private ScLocalLog mLocalLog = new ScLocalLog(MAX_LOCAL_LOG_LINES); /** * Copied from android.util.LocalLog with flush() adding flush and line number * TODO: Update LocalLog */ static class ScLocalLog { private LinkedList<String> mLog;
response: public class SubscriptionController extends ISub.Stub { static final String LOG_TAG = "SubscriptionController"; static final boolean DBG = true; static final boolean VDBG = false; static final int MAX_LOCAL_LOG_LINES = 500; // TODO: Reduce to 100 when 17678050 is fixed private ScLocalLog mLocalLog = new ScLocalLog(MAX_LOCAL_LOG_LINES); static class ScLocalLog { private LinkedList<String> mLog; private final int mMaxLines; ScLocalLog(int maxLines) { mMaxLines = maxLines; mLog = new LinkedList<>(); } synchronized void log(String msg) { if (mMaxLines > 0) { if (mLog.size() >= mMaxLines) { mLog.removeFirst(); } mLog.addLast(msg); } } synchronized void dump(PrintWriter pw) { for (String line : mLog) { pw.println(line); } } } // Rest of the code... }

sample: 154
buggy_code: import java.io.PrintWriter; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; /** * SubscriptionController to provide an inter-process communication to * access Sms in Icc. * <|startfocus|> * Any setters which take subId, slotId or phoneId as a parameter will throw an exception if the <|endfocus|> * parameter equals the corresponding INVALID_XXX_ID or DEFAULT_XXX_ID. * * All getters will lookup the corresponding default if the parameter is DEFAULT_XXX_ID. Ie calling * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters * will fail and return the appropriate error value. Ie calling getSlotId(INVALID_SUBSCRIPTION_ID)
code_review:  slotIndex? 
target code: import java.io.PrintWriter; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; /** * SubscriptionController to provide an inter-process communication to * access Sms in Icc. * * Any setters which take subId, slotIndex or phoneId as a parameter will throw an exception if the * parameter equals the corresponding INVALID_XXX_ID or DEFAULT_XXX_ID. * * All getters will lookup the corresponding default if the parameter is DEFAULT_XXX_ID. Ie calling * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters * will fail and return the appropriate error value. Ie calling getSlotId(INVALID_SUBSCRIPTION_ID)
response: import java.io.PrintWriter; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; /** * SubscriptionController to provide an inter-process communication to * access Sms in Icc. * * Any setters which take subId, slotId or phoneId as a parameter will throw an exception if the * parameter equals the corresponding INVALID_XXX_ID or DEFAULT_XXX_ID. * * All getters will lookup the corresponding default if the parameter is DEFAULT_XXX_ID. Ie calling * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters * will fail and return the appropriate error value. Ie calling getSlotId(INVALID_SUBSCRIPTION_ID) */

sample: 155
buggy_code:  * * All getters will lookup the corresponding default if the parameter is DEFAULT_XXX_ID. Ie calling * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters <|startfocus|> * will fail and return the appropriate error value. Ie calling getSlotId(INVALID_SUBSCRIPTION_ID) <|endfocus|> * will return INVALID_SLOT_ID and calling getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) * will return null. * */ public class SubscriptionController extends ISub.Stub { static final String LOG_TAG = "SubscriptionController"; static final boolean DBG = true; static final boolean VDBG = false; static final int MAX_LOCAL_LOG_LINES = 500; // TODO: Reduce to 100 when 17678050 is fixed private ScLocalLog mLocalLog = new ScLocalLog(MAX_LOCAL_LOG_LINES); /** * Copied from android.util.LocalLog with flush() adding flush and line number
code_review:  getSlotIndex 
target code: * * All getters will lookup the corresponding default if the parameter is DEFAULT_XXX_ID. Ie calling * getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * * Finally, any getters which perform the mapping between subscriptions, slots and phones will * return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters * will fail and return the appropriate error value. Ie calling getSlotIndex(INVALID_SUBSCRIPTION_ID) * will return INVALID_SLOT_ID and calling getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) * will return null. * */ public class SubscriptionController extends ISub.Stub { static final String LOG_TAG = "SubscriptionController"; static final boolean DBG = true; static final boolean VDBG = false; static final int MAX_LOCAL_LOG_LINES = 500; // TODO: Reduce to 100 when 17678050 is fixed private ScLocalLog mLocalLog = new ScLocalLog(MAX_LOCAL_LOG_LINES); /** * Copied from android.util.LocalLog with flush() adding flush and line number
response: * All getters will lookup the corresponding default if the parameter is DEFAULT_XXX_ID. Ie calling getPhoneId(DEFAULT_SUB_ID) will return the same as getPhoneId(getDefaultSubId()). * Finally, any getters which perform the mapping between subscriptions, slots and phones will return the corresponding INVALID_XXX_ID if the parameter is INVALID_XXX_ID. All other getters will fail and return the appropriate error value. Ie calling getSlotId(INVALID_SUBSCRIPTION_ID) will return INVALID_SLOT_ID and calling getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) will return null. */ public class SubscriptionController extends ISub.Stub { static final String LOG_TAG = "SubscriptionController"; static final boolean DBG = true; static final boolean VDBG = false; static final int MAX_LOCAL_LOG_LINES = 500; // TODO: Reduce to 100 when 17678050 is fixed private ScLocalLog mLocalLog = new ScLocalLog(MAX_LOCAL_LOG_LINES); /** * Copied from android.util.LocalLog with flush() adding flush and line number */ public class ScLocalLog { // implementation details } // Rest of the code }

sample: 156
buggy_code:  } } /** * @return the maximum number of subscriptions this device will support at any one time. */ @Override public int getActiveSubInfoCountMax() { // FIXME: This valid now but change to use TelephonyDevController in the future return mTelephonyManager.getSimCount(); } /** * Add a new SubInfoRecord to subinfo database if needed * @param iccId the IccId of the SIM card <|startfocus|> * @param slotId the slot which the SIM is inserted <|endfocus|> * @return 0 if success, < 0 on error. */ @Override public int addSubInfoRecord(String iccId, int slotId) { if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotId:" + slotId); enforceModifyPhoneState("addSubInfoRecord"); // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) {
code_review:  slotIndex 
target code: } } /** * @return the maximum number of subscriptions this device will support at any one time. */ @Override public int getActiveSubInfoCountMax() { // FIXME: This valid now but change to use TelephonyDevController in the future return mTelephonyManager.getSimCount(); } /** * Add a new SubInfoRecord to subinfo database if needed * @param iccId the IccId of the SIM card * @param slotIndex the slot which the SIM is inserted * @return 0 if success, < 0 on error. */ @Override public int addSubInfoRecord(String iccId, int slotId) { if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotId:" + slotId); enforceModifyPhoneState("addSubInfoRecord"); // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) {
response: } } /** * @return the maximum number of subscriptions this device will support at any one time. */ @Override public int getActiveSubInfoCountMax() { return mTelephonyManager.getSimCount(); } /** * Add a new SubInfoRecord to subinfo database if needed * @param iccId the IccId of the SIM card * @param slotId the slot which the SIM is inserted * @return 0 if success, < 0 on error. */ @Override public int addSubInfoRecord(String iccId, int slotId) { enforceModifyPhoneState("addSubInfoRecord"); final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) {

sample: 157
buggy_code:  public int addSubInfoRecord(String iccId, int slotId) { if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + <|startfocus|> " slotId:" + slotId); <|endfocus|> enforceModifyPhoneState("addSubInfoRecord"); // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) { if (DBG) logdl("[addSubInfoRecord]- null iccId"); return -1; } ContentResolver resolver = mContext.getContentResolver(); Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE}, SubscriptionManager.ICC_ID + "=?", new String[]{iccId}, null); int color = getUnusedColor(mContext.getOpPackageName()); boolean setDisplayName = false; try { if (cursor == null || !cursor.moveToFirst()) { setDisplayName = true; ContentValues value = new ContentValues();
code_review:  slotIndex 
target code: public int addSubInfoRecord(String iccId, int slotId) { if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotIndex:" + slotIndex); enforceModifyPhoneState("addSubInfoRecord"); // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) { if (DBG) logdl("[addSubInfoRecord]- null iccId"); return -1; } ContentResolver resolver = mContext.getContentResolver(); Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE}, SubscriptionManager.ICC_ID + "=?", new String[]{iccId}, null); int color = getUnusedColor(mContext.getOpPackageName()); boolean setDisplayName = false; try { if (cursor == null || !cursor.moveToFirst()) { setDisplayName = true; ContentValues value = new ContentValues();
response: public int addSubInfoRecord(String iccId, int slotId) { enforceModifyPhoneState("addSubInfoRecord"); final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) { return -1; } ContentResolver resolver = mContext.getContentResolver(); Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE}, SubscriptionManager.ICC_ID + "=?", new String[]{iccId}, null); int color = getUnusedColor(mContext.getOpPackageName()); boolean setDisplayName = false; try { if (cursor == null || !cursor.moveToFirst()) { setDisplayName = true; ContentValues value = new ContentValues(); value.put(SubscriptionManager.ICC_ID, iccId); value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId); value.put(SubscriptionManager.NAME_SOURCE, SubscriptionManager.NAME_SOURCE_DEFAULT_SOURCE); resolver.insert(SubscriptionManager.CONTENT_URI, value); } } finally { if (cursor != null) { cursor.close(); } } if (setDisplayName) { setDisplayName(iccId, slotId, color); } return 0; } finally { Binder.restoreCallingIdentity(identity); } }

sample: 158
buggy_code:  public int addSubInfoRecord(String iccId, int slotId) { if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + <|startfocus|> " slotId:" + slotId); <|endfocus|> enforceModifyPhoneState("addSubInfoRecord"); // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) { if (DBG) logdl("[addSubInfoRecord]- null iccId"); return -1; } ContentResolver resolver = mContext.getContentResolver(); Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE}, SubscriptionManager.ICC_ID + "=?", new String[]{iccId}, null); int color = getUnusedColor(mContext.getOpPackageName()); boolean setDisplayName = false; try { if (cursor == null || !cursor.moveToFirst()) { setDisplayName = true; ContentValues value = new ContentValues();
code_review:  slotIndex - there may be more. Please do a search. I stopped looking here. 
target code: public int addSubInfoRecord(String iccId, int slotId) { if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotIndex:" + slotIndex); enforceModifyPhoneState("addSubInfoRecord"); // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) { if (DBG) logdl("[addSubInfoRecord]- null iccId"); return -1; } ContentResolver resolver = mContext.getContentResolver(); Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE}, SubscriptionManager.ICC_ID + "=?", new String[]{iccId}, null); int color = getUnusedColor(mContext.getOpPackageName()); boolean setDisplayName = false; try { if (cursor == null || !cursor.moveToFirst()) { setDisplayName = true; ContentValues value = new ContentValues();
response: public int addSubInfoRecord(String iccId, int slotId) { if (DBG) { logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotId:" + slotId); } enforceModifyPhoneState("addSubInfoRecord"); final long identity = Binder.clearCallingIdentity(); try { if (iccId == null) { if (DBG) { logdl("[addSubInfoRecord]- null iccId"); } return -1; } ContentResolver resolver = mContext.getContentResolver(); Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE}, SubscriptionManager.ICC_ID + "=?", new String[]{iccId}, null); int color = getUnusedColor(mContext.getOpPackageName()); boolean setDisplayName = false; try { if (cursor == null || !cursor.moveToFirst()) { setDisplayName = true; ContentValues value = new ContentValues(); value.put(SubscriptionManager.ICC_ID, iccId); value.put(SubscriptionManager.COLOR, color); value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId); resolver.insert(SubscriptionManager.CONTENT_URI, value); } } finally { if (cursor != null) { cursor.close(); } } if (setDisplayName) { setDisplayName(iccId, slotId); } return 0; } finally { Binder.restoreCallingIdentity(identity); } }

sample: 159
buggy_code: import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import com.android.internal.telephony.SubscriptionController; import com.android.internal.telephony.TelephonyIntents; import java.io.FileDescriptor; import java.io.PrintWriter; import java.util.concurrent.atomic.AtomicInteger; import java.util.List; // must extend SubscriptionController as some people use it directly within-process public class SubscriptionControllerMock extends SubscriptionController { final AtomicInteger mDefaultDataSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID); final ITelephonyRegistry.Stub mTelephonyRegistry; <|startfocus|> final int[][] mSlotIdxToSubId; <|endfocus|> public static SubscriptionController init(Phone phone) { throw new RuntimeException("not implemented"); } public static SubscriptionController init(Context c, CommandsInterface[] ci) { throw new RuntimeException("not implemented"); } public static SubscriptionController getInstance() { throw new RuntimeException("not implemented"); } public SubscriptionControllerMock(Context c, ITelephonyRegistry.Stub tr, int phoneCount) { super(c); mTelephonyRegistry = tr; mSlotIdxToSubId = new int[phoneCount][];
code_review:  rename 
target code: import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import com.android.internal.telephony.SubscriptionController; import com.android.internal.telephony.TelephonyIntents; import java.io.FileDescriptor; import java.io.PrintWriter; import java.util.concurrent.atomic.AtomicInteger; import java.util.List; // must extend SubscriptionController as some people use it directly within-process public class SubscriptionControllerMock extends SubscriptionController { final AtomicInteger mDefaultDataSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID); final ITelephonyRegistry.Stub mTelephonyRegistry; final int[][] mSlotIndexToSubId; public static SubscriptionController init(Phone phone) { throw new RuntimeException("not implemented"); } public static SubscriptionController init(Context c, CommandsInterface[] ci) { throw new RuntimeException("not implemented"); } public static SubscriptionController getInstance() { throw new RuntimeException("not implemented"); } public SubscriptionControllerMock(Context c, ITelephonyRegistry.Stub tr, int phoneCount) { super(c); mTelephonyRegistry = tr; mSlotIdxToSubId = new int[phoneCount][];
response: import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import com.android.internal.telephony.SubscriptionController; import com.android.internal.telephony.TelephonyIntents; import java.io.FileDescriptor; import java.io.PrintWriter; import java.util.concurrent.atomic.AtomicInteger; import java.util.List; // must extend SubscriptionController as some people use it directly within-process public class SubscriptionControllerMock extends SubscriptionController { final AtomicInteger mDefaultDataSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID); final ITelephonyRegistry.Stub mTelephonyRegistry; final int[][] mSlotIdxToSubId; public static SubscriptionController init(Phone phone) { throw new RuntimeException("not implemented"); } public static SubscriptionController init(Context c, CommandsInterface[] ci) { throw new RuntimeException("not implemented"); } public static SubscriptionController getInstance() { throw new RuntimeException("not implemented"); } public SubscriptionControllerMock(Context c, ITelephonyRegistry.Stub tr, int phoneCount) { super(c); mTelephonyRegistry = tr; mSlotIdxToSubId = new int[phoneCount][]; } }

sample: 160
buggy_code: <|startfocus|> public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx, String cp){ <|endfocus|> throw new RuntimeException("not implemented");
code_review:  rename 
target code: public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex, String cp){ throw new RuntimeException("not implemented");
response: public SubscriptionInfo getActiveSubscriptionInfo(int slotIndex, String cp) { throw new RuntimeException("not implemented"); }

sample: 161
buggy_code: <|startfocus|> private boolean isInvalidSlotId(int slotIdx) { if (slotIdx < 0 || slotIdx >= mSlotIdxToSubId.length) return true; <|endfocus|> return false;
code_review:  rename 
target code: private boolean isInvalidSlotId(int slotIndex) { if (slotIndex < 0 || slotIndex >= mSlotIndexToSubId.length) return true; return false;
response: private boolean isInvalidSlotId(int slotIdx) { if (slotIdx < 0 || slotIdx >= mSlotIdxToSubId.length) return true; return false; }

sample: 162
buggy_code: <|startfocus|> public int[] getSubId(int slotIdx) { if (isInvalidSlotId(slotIdx)) { <|endfocus|> return null; } return mSlotIdxToSubId[slotIdx];
code_review:  rename 
target code: public int[] getSubId(int slotIndex) { if (isInvalidSlotId(slotIndex)) { return null; } return mSlotIdxToSubId[slotIdx];
response: public int[] getSubId(int slotIdx) { if (isInvalidSlotId(slotIdx)) { return null; } return mSlotIdxToSubId[slotIdx]; }

sample: 163
buggy_code: <|startfocus|> public void setSlotSubId(int slotIdx, int subId) { if (isInvalidSlotId(slotIdx)) { throw new RuntimeException("invalid slot specified" + slotIdx); <|endfocus|> } if (mSlotIdxToSubId[slotIdx][0] != subId) { mSlotIdxToSubId[slotIdx][0] = subId; try { mTelephonyRegistry.notifySubscriptionInfoChanged(); } catch (RemoteException ex) {} }
code_review:  rename 
target code: public void setSlotSubId(int slotIndex, int subId) { if (isInvalidSlotId(slotIndex)) { throw new RuntimeException("invalid slot specified" + slotIndex); } if (mSlotIdxToSubId[slotIdx][0] != subId) { mSlotIdxToSubId[slotIdx][0] = subId; try { mTelephonyRegistry.notifySubscriptionInfoChanged(); } catch (RemoteException ex) {} }
response: public void setSlotSubId(int slotIndex, int subId) { if (isInvalidSlotId(slotIndex)) { throw new RuntimeException("Invalid slot specified: " + slotIndex); } if (mSlotIndexToSubId[slotIndex][0] != subId) { mSlotIndexToSubId[slotIndex][0] = subId; try { mTelephonyRegistry.notifySubscriptionInfoChanged(); } catch (RemoteException e) { // handle exception } } }

sample: 164
buggy_code: <|startfocus|> public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx, <|endfocus|> String callingPackage) { if (!canReadPhoneState(callingPackage, "getActiveSubscriptionInfoForSimSlotIndex")) { return null; } // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { List<SubscriptionInfo> subList = getActiveSubscriptionInfoList( mContext.getOpPackageName()); if (subList != null) { for (SubscriptionInfo si : subList) { if (si.getSimSlotIndex() == slotIdx) { if (DBG) { logd("[getActiveSubscriptionInfoForSimSlotIndex]+ slotIdx=" + slotIdx + " subId=" + si); } return si; } } if (DBG) { logd("[getActiveSubscriptionInfoForSimSlotIndex]+ slotIdx=" + slotIdx + " subId=null"); } } else { if (DBG) { logd("[getActiveSubscriptionInfoForSimSlotIndex]+ subList=null"); } } } finally { Binder.restoreCallingIdentity(identity); } 
code_review:  rename? 
target code: public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex, String callingPackage) { if (!canReadPhoneState(callingPackage, "getActiveSubscriptionInfoForSimSlotIndex")) { return null; } // Now that all security checks passes, perform the operation as ourselves. final long identity = Binder.clearCallingIdentity(); try { List<SubscriptionInfo> subList = getActiveSubscriptionInfoList( mContext.getOpPackageName()); if (subList != null) { for (SubscriptionInfo si : subList) { if (si.getSimSlotIndex() == slotIdx) { if (DBG) { logd("[getActiveSubscriptionInfoForSimSlotIndex]+ slotIdx=" + slotIdx + " subId=" + si); } return si; } } if (DBG) { logd("[getActiveSubscriptionInfoForSimSlotIndex]+ slotIdx=" + slotIdx + " subId=null"); } } else { if (DBG) { logd("[getActiveSubscriptionInfoForSimSlotIndex]+ subList=null"); } } } finally { Binder.restoreCallingIdentity(identity); }
response: public SubscriptionInfo getActiveSubscriptionInfoBySlotIndex(int slotIdx, String callingPackage) { if (!canReadPhoneState(callingPackage, "getActiveSubscriptionInfoBySlotIndex")) { return null; } final long identity = Binder.clearCallingIdentity(); try { List<SubscriptionInfo> subList = getActiveSubscriptionInfoList(mContext.getOpPackageName()); if (subList != null) { for (SubscriptionInfo si : subList) { if (si.getSimSlotIndex() == slotIdx) { return si; } } } } finally { Binder.restoreCallingIdentity(identity); } return null; }

sample: 165
buggy_code: <|startfocus|> public int[] getSubId(int slotIdx) { if (VDBG) printStackTrace("[getSubId]+ slotIdx=" + slotIdx); <|endfocus|> // Map default slotIdx to the current default subId. // TODO: Not used anywhere sp consider deleting as it's somewhat nebulous // as a slot maybe used for multiple different type of "connections" // such as: voice, data and sms. But we're doing the best we can and using // getDefaultSubId which makes a best guess. if (slotIdx == SubscriptionManager.DEFAULT_SIM_SLOT_INDEX) { slotIdx = getSlotId(getDefaultSubId()); if (VDBG) logd("[getSubId] map default slotIdx=" + slotIdx); } // Check that we have a valid SlotIdx if (!SubscriptionManager.isValidSlotId(slotIdx)) { if (DBG) logd("[getSubId]- invalid slotIdx=" + slotIdx); return null; } // Check if we've got any SubscriptionInfo records using slotIdToSubId as a surrogate. int size = sSlotIdxToSubId.size();
code_review:  this? 
target code: public int[] getSubId(int slotIndex) { if (VDBG) printStackTrace("[getSubId]+ slotIndex=" + slotIndex); // Map default slotIdx to the current default subId. // TODO: Not used anywhere sp consider deleting as it's somewhat nebulous // as a slot maybe used for multiple different type of "connections" // such as: voice, data and sms. But we're doing the best we can and using // getDefaultSubId which makes a best guess. if (slotIdx == SubscriptionManager.DEFAULT_SIM_SLOT_INDEX) { slotIdx = getSlotId(getDefaultSubId()); if (VDBG) logd("[getSubId] map default slotIdx=" + slotIdx); } // Check that we have a valid SlotIdx if (!SubscriptionManager.isValidSlotId(slotIdx)) { if (DBG) logd("[getSubId]- invalid slotIdx=" + slotIdx); return null; } // Check if we've got any SubscriptionInfo records using slotIdToSubId as a surrogate. int size = sSlotIdxToSubId.size();
response: public int[] getSubId(int slotIdx) { if (VDBG) printStackTrace("[getSubId]+ slotIdx=" + slotIdx); if (slotIdx == SubscriptionManager.DEFAULT_SIM_SLOT_INDEX) { slotIdx = getSlotId(getDefaultSubId()); if (VDBG) logd("[getSubId] map default slotIdx=" + slotIdx); } if (!SubscriptionManager.isValidSlotId(slotIdx)) { if (DBG) logd("[getSubId]- invalid slotIdx=" + slotIdx); return null; } int size = sSlotIdxToSubId.size(); // ... }

sample: 166
buggy_code: <|startfocus|> private int[] getDummySubIds(int slotIdx) { <|endfocus|> // FIXME: Remove notion of Dummy SUBSCRIPTION_ID. // I tested this returning null as no one appears to care, // but no connection came up on sprout with two sims. // We need to figure out why and hopefully remove DummySubsIds!!! int numSubs = getActiveSubInfoCountMax(); if (numSubs > 0) { int[] dummyValues = new int[numSubs]; for (int i = 0; i < numSubs; i++) { dummyValues[i] = SubscriptionManager.DUMMY_SUBSCRIPTION_ID_BASE - slotIdx; } if (VDBG) { logd("getDummySubIds: slotIdx=" + slotIdx + " return " + numSubs + " DummySubIds with each subId=" + dummyValues[0]); } return dummyValues; } else { return null; }
code_review:  this? 
target code: private int[] getDummySubIds(int slotIndex) { // FIXME: Remove notion of Dummy SUBSCRIPTION_ID. // I tested this returning null as no one appears to care, // but no connection came up on sprout with two sims. // We need to figure out why and hopefully remove DummySubsIds!!! int numSubs = getActiveSubInfoCountMax(); if (numSubs > 0) { int[] dummyValues = new int[numSubs]; for (int i = 0; i < numSubs; i++) { dummyValues[i] = SubscriptionManager.DUMMY_SUBSCRIPTION_ID_BASE - slotIdx; } if (VDBG) { logd("getDummySubIds: slotIdx=" + slotIdx + " return " + numSubs + " DummySubIds with each subId=" + dummyValues[0]); } return dummyValues; } else { return null; }
response: private int[] getDummySubIds(int slotIdx) { int numSubs = getActiveSubInfoCountMax(); if (numSubs > 0) { int[] dummyValues = new int[numSubs]; for (int i = 0; i < numSubs; i++) { dummyValues[i] = SubscriptionManager.DUMMY_SUBSCRIPTION_ID_BASE - slotIdx; } return dummyValues; } else { return null; } }

sample: 167
buggy_code:  pw.println(" defaultDataPhoneId=" + SubscriptionManager .from(mContext).getDefaultDataPhoneId()); pw.println(" defaultVoicePhoneId=" + SubscriptionManager.getDefaultVoicePhoneId()); pw.println(" defaultSmsPhoneId=" + SubscriptionManager .from(mContext).getDefaultSmsPhoneId()); pw.flush(); <|startfocus|> for (Entry<Integer, Integer> entry : sSlotIdxToSubId.entrySet()) { pw.println(" sSlotIdxToSubId[" + entry.getKey() + "]: subId=" + entry.getValue()); <|endfocus|> } pw.flush(); pw.println("++++++++++++++++++++++++++++++++"); List<SubscriptionInfo> sirl = getActiveSubscriptionInfoList( mContext.getOpPackageName()); if (sirl != null) { pw.println(" ActiveSubInfoList:"); for (SubscriptionInfo entry : sirl) { pw.println(" " + entry.toString()); } } else { pw.println(" ActiveSubInfoList: is null"); } pw.flush(); pw.println("++++++++++++++++++++++++++++++++"); sirl = getAllSubInfoList(mContext.getOpPackageName()); if (sirl != null) {
code_review:  rename this as well? 
target code: pw.println(" defaultDataPhoneId=" + SubscriptionManager .from(mContext).getDefaultDataPhoneId()); pw.println(" defaultVoicePhoneId=" + SubscriptionManager.getDefaultVoicePhoneId()); pw.println(" defaultSmsPhoneId=" + SubscriptionManager .from(mContext).getDefaultSmsPhoneId()); pw.flush(); for (Entry<Integer, Integer> entry : sSlotIndexToSubId.entrySet()) { pw.println(" sSlotIndexToSubId[" + entry.getKey() + "]: subId=" + entry.getValue()); } pw.flush(); pw.println("++++++++++++++++++++++++++++++++"); List<SubscriptionInfo> sirl = getActiveSubscriptionInfoList( mContext.getOpPackageName()); if (sirl != null) { pw.println(" ActiveSubInfoList:"); for (SubscriptionInfo entry : sirl) { pw.println(" " + entry.toString()); } } else { pw.println(" ActiveSubInfoList: is null"); } pw.flush(); pw.println("++++++++++++++++++++++++++++++++"); sirl = getAllSubInfoList(mContext.getOpPackageName()); if (sirl != null) {
response: private void checkType(int columnIndex, Type expectedType) { ColumnSchema columnSchema = schema.getColumnByIndex(columnIndex); Type columnType = columnSchema.getType(); if (!columnType.equals(expectedType)) { throw new IllegalArgumentException("Column (name: " + columnSchema.getName() + ", index: " + columnIndex +") is of type " + columnType.getName() + " but was requested as a type " + expectedType.getName()); } } public Integer abs(Integer self) { return Integer.valueOf(Math.abs(self.intValue())); } public Integer floor(Double self) { return Integer.valueOf((int)Math.floor(self.doubleValue())); } public Integer floor(Integer self) { return self; } pw.println(" defaultDataPhoneId=" + SubscriptionManager.from(mContext).getDefaultDataPhoneId()); pw.println(" defaultVoicePhoneId=" + SubscriptionManager.getDefaultVoicePhoneId()); pw.println(" defaultSmsPhoneId=" + SubscriptionManager.from(mContext).getDefaultSmsPhoneId()); pw.flush(); for (Entry<Integer, Integer> entry : sSlotIdxToSubId.entrySet()) { pw.println(" sSlotIdxToSubId[" + entry.getKey() + "]: subId=" + entry.getValue()); } pw.flush(); pw.println("++++++++++++++++++++++++++++++++"); List<SubscriptionInfo> sirl = getActiveSubscriptionInfoList(mContext.getOpPackageName()); if (sirl != null) { pw.println(" ActiveSubInfoList:"); for (SubscriptionInfo entry : sirl) { pw.println(" " + entry.toString()); } } else { pw.println(" ActiveSubInfoList: is null"); } pw.flush(); pw.println("++++++++++++++++++++++++++++++++"); sirl = getAllSubInfoList(mContext.getOpPackageName()); if (sirl != null) { // code continues... }

sample: 168
buggy_code: import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import com.android.internal.telephony.SubscriptionController; import com.android.internal.telephony.TelephonyIntents; import java.io.FileDescriptor; import java.io.PrintWriter; import java.util.concurrent.atomic.AtomicInteger; import java.util.List; // must extend SubscriptionController as some people use it directly within-process public class SubscriptionControllerMock extends SubscriptionController { final AtomicInteger mDefaultDataSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID); final ITelephonyRegistry.Stub mTelephonyRegistry; <|startfocus|> final int[][] mSlotIdxToSubId; <|endfocus|> public static SubscriptionController init(Phone phone) { throw new RuntimeException("not implemented"); } public static SubscriptionController init(Context c, CommandsInterface[] ci) { throw new RuntimeException("not implemented"); } public static SubscriptionController getInstance() { throw new RuntimeException("not implemented"); } public SubscriptionControllerMock(Context c, ITelephonyRegistry.Stub tr, int phoneCount) { super(c); mTelephonyRegistry = tr; mSlotIdxToSubId = new int[phoneCount][];
code_review:  rename this? 
target code: import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import com.android.internal.telephony.SubscriptionController; import com.android.internal.telephony.TelephonyIntents; import java.io.FileDescriptor; import java.io.PrintWriter; import java.util.concurrent.atomic.AtomicInteger; import java.util.List; // must extend SubscriptionController as some people use it directly within-process public class SubscriptionControllerMock extends SubscriptionController { final AtomicInteger mDefaultDataSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID); final ITelephonyRegistry.Stub mTelephonyRegistry; final int[][] mSlotIndexToSubId; public static SubscriptionController init(Phone phone) { throw new RuntimeException("not implemented"); } public static SubscriptionController init(Context c, CommandsInterface[] ci) { throw new RuntimeException("not implemented"); } public static SubscriptionController getInstance() { throw new RuntimeException("not implemented"); } public SubscriptionControllerMock(Context c, ITelephonyRegistry.Stub tr, int phoneCount) { super(c); mTelephonyRegistry = tr; mSlotIdxToSubId = new int[phoneCount][];
response: import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import com.android.internal.telephony.SubscriptionController; import com.android.internal.telephony.TelephonyIntents; import java.io.FileDescriptor; import java.io.PrintWriter; import java.util.concurrent.atomic.AtomicInteger; import java.util.List; public class SubscriptionControllerMock extends SubscriptionController { final AtomicInteger mDefaultDataSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID); final ITelephonyRegistry.Stub mTelephonyRegistry; final int[][] mSlotIdxToSubId; public static SubscriptionController init(Phone phone) { throw new RuntimeException("not implemented"); } public static SubscriptionController init(Context c, CommandsInterface[] ci) { throw new RuntimeException("not implemented"); } public static SubscriptionController getInstance() { throw new RuntimeException("not implemented"); } public SubscriptionControllerMock(Context c, ITelephonyRegistry.Stub tr, int phoneCount) { super(c); mTelephonyRegistry = tr; mSlotIdxToSubId = new int[phoneCount][]; } }

sample: 169
buggy_code: <|startfocus|> public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx, String cp){ <|endfocus|> throw new RuntimeException("not implemented");
code_review:  this 
target code: public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex, String cp){ throw new RuntimeException("not implemented");
response: public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx, String cp){ throw new RuntimeException("not implemented"); }

sample: 170
buggy_code: <|startfocus|> private boolean isInvalidSlotId(int slotIdx) { if (slotIdx < 0 || slotIdx >= mSlotIdxToSubId.length) return true; <|endfocus|> return false;
code_review:  rename? 
target code: private boolean isInvalidSlotId(int slotIndex) { if (slotIndex < 0 || slotIndex >= mSlotIndexToSubId.length) return true; return false;
response: private boolean isInvalidSlotId(int slotIdx) { if (slotIdx < 0 || slotIdx >= mSlotIdxToSubId.length) return true; return false; }

sample: 171
buggy_code: <|startfocus|> public void setSlotSubId(int slotIdx, int subId) { if (isInvalidSlotId(slotIdx)) { throw new RuntimeException("invalid slot specified" + slotIdx); <|endfocus|> } if (mSlotIdxToSubId[slotIdx][0] != subId) { mSlotIdxToSubId[slotIdx][0] = subId; try { mTelephonyRegistry.notifySubscriptionInfoChanged(); } catch (RemoteException ex) {} }
code_review:  Please search all 'idx' and see if they need to be renamed :) 
target code: public void setSlotSubId(int slotIndex, int subId) { if (isInvalidSlotId(slotIndex)) { throw new RuntimeException("invalid slot specified" + slotIndex); } if (mSlotIdxToSubId[slotIdx][0] != subId) { mSlotIdxToSubId[slotIdx][0] = subId; try { mTelephonyRegistry.notifySubscriptionInfoChanged(); } catch (RemoteException ex) {} }
response: public void setSlotSubId(int slotIndex, int subId) { if (isInvalidSlotId(slotIndex)) { throw new RuntimeException("Invalid slot specified: " + slotIndex); } if (mSlotIndexToSubId[slotIndex][0] != subId) { mSlotIndexToSubId[slotIndex][0] = subId; try { mTelephonyRegistry.notifySubscriptionInfoChanged(); } catch (RemoteException ex) { // Handle RemoteException } } }

sample: 172
buggy_code:  private static String getEtwsPrimaryMessage(Context context, int category) { <|startfocus|> Resources r = context.getResources(); <|endfocus|> switch (category) { case ETWS_WARNING_TYPE_EARTHQUAKE: return r.getString(R.string.etws_primary_default_message_earthquake); case ETWS_WARNING_TYPE_TSUNAMI: return r.getString(R.string.etws_primary_default_message_tsunami); case ETWS_WARNING_TYPE_EARTHQUAKE_AND_TSUNAMI: return r.getString(R.string.etws_primary_default_message_earthquake_and_tsunami); case ETWS_WARNING_TYPE_TEST_MESSAGE: return r.getString(R.string.etws_primary_default_message_test); case ETWS_WARNING_TYPE_OTHER_EMERGENCY: return r.getString(R.string.etws_primary_default_message_others); default: return ""; }
code_review:  final 
target code: private static String getEtwsPrimaryMessage(Context context, int category) { final Resources r = context.getResources(); switch (category) { case ETWS_WARNING_TYPE_EARTHQUAKE: return r.getString(R.string.etws_primary_default_message_earthquake); case ETWS_WARNING_TYPE_TSUNAMI: return r.getString(R.string.etws_primary_default_message_tsunami); case ETWS_WARNING_TYPE_EARTHQUAKE_AND_TSUNAMI: return r.getString(R.string.etws_primary_default_message_earthquake_and_tsunami); case ETWS_WARNING_TYPE_TEST_MESSAGE: return r.getString(R.string.etws_primary_default_message_test); case ETWS_WARNING_TYPE_OTHER_EMERGENCY: return r.getString(R.string.etws_primary_default_message_others); default: return ""; }
response: private static String getEtwsPrimaryMessage(Context context, int category) { Resources r = context.getResources(); switch (category) { case ETWS_WARNING_TYPE_EARTHQUAKE: return r.getString(R.string.etws_primary_default_message_earthquake); case ETWS_WARNING_TYPE_TSUNAMI: return r.getString(R.string.etws_primary_default_message_tsunami); case ETWS_WARNING_TYPE_EARTHQUAKE_AND_TSUNAMI: return r.getString(R.string.etws_primary_default_message_earthquake_and_tsunami); case ETWS_WARNING_TYPE_TEST_MESSAGE: return r.getString(R.string.etws_primary_default_message_test); case ETWS_WARNING_TYPE_OTHER_EMERGENCY: return r.getString(R.string.etws_primary_default_message_others); default: return ""; } }

sample: 173
buggy_code:  * * @param subId The subscription ID * @return true if the network for the subscription is roaming, false otherwise */ public boolean isNetworkRoaming(int subId) { final int phoneId = getPhoneId(subId); if (phoneId < 0) { // What else can we do? return false; } return TelephonyManager.getDefault().isNetworkRoaming(subId); } /** <|startfocus|> * Returns a constant indicating the state of sim for the slot idx. <|endfocus|> * * @param slotIndex * * {@See TelephonyManager#SIM_STATE_UNKNOWN} * {@See TelephonyManager#SIM_STATE_ABSENT} * {@See TelephonyManager#SIM_STATE_PIN_REQUIRED} * {@See TelephonyManager#SIM_STATE_PUK_REQUIRED} * {@See TelephonyManager#SIM_STATE_NETWORK_LOCKED} * {@See TelephonyManager#SIM_STATE_READY} * {@See TelephonyManager#SIM_STATE_NOT_READY} * {@See TelephonyManager#SIM_STATE_PERM_DISABLED} * {@See TelephonyManager#SIM_STATE_CARD_IO_ERROR} * * {@hide} */
code_review:  rename 
target code: * * @param subId The subscription ID * @return true if the network for the subscription is roaming, false otherwise */ public boolean isNetworkRoaming(int subId) { final int phoneId = getPhoneId(subId); if (phoneId < 0) { // What else can we do? return false; } return TelephonyManager.getDefault().isNetworkRoaming(subId); } /** * Returns a constant indicating the state of sim for the slot index. * * @param slotIndex * * {@See TelephonyManager#SIM_STATE_UNKNOWN} * {@See TelephonyManager#SIM_STATE_ABSENT} * {@See TelephonyManager#SIM_STATE_PIN_REQUIRED} * {@See TelephonyManager#SIM_STATE_PUK_REQUIRED} * {@See TelephonyManager#SIM_STATE_NETWORK_LOCKED} * {@See TelephonyManager#SIM_STATE_READY} * {@See TelephonyManager#SIM_STATE_NOT_READY} * {@See TelephonyManager#SIM_STATE_PERM_DISABLED} * {@See TelephonyManager#SIM_STATE_CARD_IO_ERROR} * * {@hide} */
response: public boolean isNetworkRoaming(int subId) { final int phoneId = getPhoneId(subId); if (phoneId < 0) { return false; } return TelephonyManager.getDefault().isNetworkRoaming(subId); } public int getSimState(int slotIndex) { return TelephonyManager.getDefault().getSimState(slotIndex); }

sample: 174
buggy_code:  ServiceStateTable.DATA_OPERATOR_NUMERIC, ServiceStateTable.IS_MANUAL_NETWORK_SELECTION, ServiceStateTable.RIL_VOICE_RADIO_TECHNOLOGY, ServiceStateTable.RIL_DATA_RADIO_TECHNOLOGY, ServiceStateTable.CSS_INDICATOR, ServiceStateTable.NETWORK_ID, ServiceStateTable.SYSTEM_ID, ServiceStateTable.CDMA_ROAMING_INDICATOR, ServiceStateTable.CDMA_DEFAULT_ROAMING_INDICATOR, ServiceStateTable.CDMA_ERI_ICON_INDEX, ServiceStateTable.CDMA_ERI_ICON_MODE, ServiceStateTable.IS_EMERGENCY_ONLY, ServiceStateTable.IS_DATA_ROAMING_FROM_REGISTRATION, ServiceStateTable.IS_USING_CARRIER_AGGREGATION, }; @Override <|startfocus|> public boolean onCreate() { <|endfocus|> return true; } @Override public Uri insert(Uri uri, ContentValues values) { throw new RuntimeException("Not supported"); } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { throw new RuntimeException("Not supported"); } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { throw new RuntimeException("Not supported"); } @Override public String getType(Uri uri) { if (ServiceStateTable.CONTENT_URI.equals(uri)) {
code_review:  leave an empty line between functions 
target code: ServiceStateTable.DATA_OPERATOR_NUMERIC, ServiceStateTable.IS_MANUAL_NETWORK_SELECTION, ServiceStateTable.RIL_VOICE_RADIO_TECHNOLOGY, ServiceStateTable.RIL_DATA_RADIO_TECHNOLOGY, ServiceStateTable.CSS_INDICATOR, ServiceStateTable.NETWORK_ID, ServiceStateTable.SYSTEM_ID, ServiceStateTable.CDMA_ROAMING_INDICATOR, ServiceStateTable.CDMA_DEFAULT_ROAMING_INDICATOR, ServiceStateTable.CDMA_ERI_ICON_INDEX, ServiceStateTable.CDMA_ERI_ICON_MODE, ServiceStateTable.IS_EMERGENCY_ONLY, ServiceStateTable.IS_DATA_ROAMING_FROM_REGISTRATION, ServiceStateTable.IS_USING_CARRIER_AGGREGATION, }; @Override public boolean onCreate() { mServiceState = new ServiceState(); mServiceState.setStateOutOfService(); return true; } @Override public Uri insert(Uri uri, ContentValues values) { throw new RuntimeException("Not supported"); } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { throw new RuntimeException("Not supported"); } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { throw new RuntimeException("Not supported"); } @Override public String getType(Uri uri) { if (ServiceStateTable.CONTENT_URI.equals(uri)) {
response: ServiceStateTable.DATA_OPERATOR_NUMERIC, ServiceStateTable.IS_MANUAL_NETWORK_SELECTION, ServiceStateTable.RIL_VOICE_RADIO_TECHNOLOGY, ServiceStateTable.RIL_DATA_RADIO_TECHNOLOGY, ServiceStateTable.CSS_INDICATOR, ServiceStateTable.NETWORK_ID, ServiceStateTable.SYSTEM_ID, ServiceStateTable.CDMA_ROAMING_INDICATOR, ServiceStateTable.CDMA_DEFAULT_ROAMING_INDICATOR, ServiceStateTable.CDMA_ERI_ICON_INDEX, ServiceStateTable.CDMA_ERI_ICON_MODE, ServiceStateTable.IS_EMERGENCY_ONLY, ServiceStateTable.IS_DATA_ROAMING_FROM_REGISTRATION, ServiceStateTable.IS_USING_CARRIER_AGGREGATION, }; @Override public boolean onCreate() { return true; } @Override public Uri insert(Uri uri, ContentValues values) { throw new RuntimeException("Not supported"); } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { throw new RuntimeException("Not supported"); } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { throw new RuntimeException("Not supported"); } @Override public String getType(Uri uri) { if (ServiceStateTable.CONTENT_URI.equals(uri)) { return ServiceStateTable.CONTENT_TYPE; } return null; }

sample: 175
buggy_code:  voice_operator_numeric, data_operator_alpha_long, data_operator_alpha_short, data_operator_numeric, is_manual_network_selection, ril_voice_radio_technology, ril_data_radio_technology, css_indicator, network_id, system_id, cdma_roaming_indicator, cdma_default_roaming_indicator, cdma_eri_icon_index, cdma_eri_icon_mode, is_emergency_only, is_data_roaming_from_registration, is_using_carrier_aggregation, }); } <|startfocus|> throw new IllegalArgumentException("Invalid URI: " + uri); <|endfocus|>
code_review:  negate the check above and throw this exception first. 
target code: voice_operator_numeric, data_operator_alpha_long, data_operator_alpha_short, data_operator_numeric, is_manual_network_selection, ril_voice_radio_technology, ril_data_radio_technology, css_indicator, network_id, system_id, cdma_roaming_indicator, cdma_default_roaming_indicator, cdma_eri_icon_index, cdma_eri_icon_mode, is_emergency_only, is_data_roaming_from_registration, is_using_carrier_aggregation, }); }
response: super.okPressed(); broker.post(TOPIC_USER_REQUESTS_SEND, queue); } @Override protected void cancelPressed() { super.cancelPressed(); broker.post(TOPIC_USER_REQUESTS_CLEAR_QUEUE, queue); } private final class CommentToProviderActivationConverter extends Converter { private INeedinfoProviderDescriptor provider; private CommentToProviderActivationConverter(INeedinfoProviderDescriptor provider) { super(String.class, Boolean.class); this.provider = provider; } @Override public Object convert(Object fromObject) { String comment = (String) fromObject; if (comment != null) { int informationStart = comment.indexOf(MessageFormat.format(INFORMATION_START, provider.getHumanReadableDescription())); if (informationStart != -1) { int informationEnd = comment.indexOf(MessageFormat.format(INFORMATION_END, provider.getHumanReadableName()), informationStart); if (informationStart != -1 && informationEnd != -1) { return true; } } } return false; } } private final class ProviderActivationToCommentConverter extends Converter { private INeedinfoProviderDescriptor provider; private ProviderActivationToCommentConverter(INeedinfoProviderDescriptor provider) { super(Boolean.class, String.class); this.provider = provider; } @Override public Object convert(Object fromObject) { boolean activation = (boolean) fromObject; if (activation) { return MessageFormat.format(INFORMATION_START, provider.getHumanReadableDescription()) + " " + MessageFormat.format(INFORMATION_END, provider.getHumanReadableName()); } return null; } } new TaskId(getActivityId(), partition)); state.open(ctx); } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { state.appendFrame(buffer); } @Override public void fail() throws HyracksDataException { } @Override public void close() throws HyracksDataException { state.close(); state.writeOut(writer, new VSizeFrame(ctx)); } @Override public void flush() throws HyracksDataException { // flush() on any materializing operator is a no op } FileReference file = ctx.getJobletContext().createManagedWorkspaceFile(ExternalSortRunGenerator.class.getSimpleName()); return new RunFileWriter(file, ctx.getIOManager()); } @Override protected IFrameWriter getFlushableFrameWriter(RunFileWriter writer) throws HyracksData

sample: 176
buggy_code:  MESSAGE_FORMAT, MESSAGE_PRIORITY, ETWS_WARNING_TYPE, CMAS_MESSAGE_CLASS, CMAS_CATEGORY, CMAS_RESPONSE_TYPE, CMAS_SEVERITY, CMAS_URGENCY, CMAS_CERTAINTY }; } /** * Constants for interfacing with the ServiceStateProvider and the different fields of the * ServiceState class accessible through the provider */ public static final class ServiceStateTable { public static final Uri CONTENT_URI = Uri.parse("content://service-state/"); <|startfocus|> /** * The MIME-type of {@link #CONTENT_URI}. */ public static final String CONTENT_TYPE = "vnd.android.cursor.dir/service_state"; <|endfocus|> /** * Used to push and receive updates to a field in the ServiceState for a given subId * @param field the ServiceState field to receive updates on * @param subId the subId to receive updates on * @return the Uri that will be notified by ServiceStateTracker */ public static Uri getUriForSubId(String field, int subId) {
code_review:  leave a line 
target code: MESSAGE_FORMAT, MESSAGE_PRIORITY, ETWS_WARNING_TYPE, CMAS_MESSAGE_CLASS, CMAS_CATEGORY, CMAS_RESPONSE_TYPE, CMAS_SEVERITY, CMAS_URGENCY, CMAS_CERTAINTY }; } /** * Constants for interfacing with the ServiceStateProvider and the different fields of the * ServiceState class accessible through the provider */ public static final class ServiceStateTable { public static final Uri CONTENT_URI = Uri.parse("content://service-state/"); /** * Used to push and receive updates to a field in the ServiceState for a given subId * @param field the ServiceState field to receive updates on * @param subId the subId to receive updates on * @return the Uri that will be notified by ServiceStateTracker */ public static Uri getUriForSubId(String field, int subId) {
response: public static final class ServiceStateTable { public static final Uri CONTENT_URI = Uri.parse("content://service-state/"); public static final String CONTENT_TYPE = "vnd.android.cursor.dir/service_state"; public static Uri getUriForSubId(String field, int subId) { // Used to push and receive updates to a field in the ServiceState for a given subId return Uri.withAppendedPath(CONTENT_URI, field + "/" + subId); } }

sample: 177
buggy_code:  CMAS_RESPONSE_TYPE, CMAS_SEVERITY, CMAS_URGENCY, CMAS_CERTAINTY }; } /** * Constants for interfacing with the ServiceStateProvider and the different fields of the * ServiceState class accessible through the provider */ public static final class ServiceStateTable { public static final Uri CONTENT_URI = Uri.parse("content://service-state/"); <|startfocus|> /** * The MIME-type of {@link #CONTENT_URI}. */ public static final String CONTENT_TYPE = "vnd.android.cursor.dir/service_state"; <|endfocus|> /** * Used to push and receive updates to a field in the ServiceState for a given subId * @param field the ServiceState field to receive updates on * @param subId the subId to receive updates on * @return the Uri that will be notified by ServiceStateTracker */ public static Uri getUriForSubId(String field, int subId) { return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)) .appendEncodedPath(field).build(); } 
code_review:  is this used? 
target code: CMAS_RESPONSE_TYPE, CMAS_SEVERITY, CMAS_URGENCY, CMAS_CERTAINTY }; } /** * Constants for interfacing with the ServiceStateProvider and the different fields of the * ServiceState class accessible through the provider */ public static final class ServiceStateTable { public static final Uri CONTENT_URI = Uri.parse("content://service-state/"); /** * Used to push and receive updates to a field in the ServiceState for a given subId * @param field the ServiceState field to receive updates on * @param subId the subId to receive updates on * @return the Uri that will be notified by ServiceStateTracker */ public static Uri getUriForSubId(String field, int subId) { return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)) .appendEncodedPath(field).build(); }
response: CMAS_RESPONSE_TYPE, CMAS_SEVERITY, CMAS_URGENCY, CMAS_CERTAINTY }; } public static final class ServiceStateTable { public static final Uri CONTENT_URI = Uri.parse("content://service-state/"); public static final String CONTENT_TYPE = "vnd.android.cursor.dir/service_state"; public static Uri getUriForSubId(String field, int subId) { return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)) .appendEncodedPath(field).build(); }

sample: 178
buggy_code: <|startfocus|> public static Uri getUriForSubId(String field, int subId) { <|endfocus|> return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)) .appendEncodedPath(field).build();
code_review:  this is for a specific field and subid? should there be one for just subId too? 
target code: public static Uri getUriForFieldAndSubId(String field, int subId) { return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)) .appendEncodedPath(field).build();
response: public static Uri getUriForSubId(String field, int subId) { if (field == null) { return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)).build(); } else { return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)) .appendEncodedPath(field).build(); } }

sample: 179
buggy_code:  + something.getClass().getName() + " to byte array!"); } } public AdvertiseData buildAdvData(JSONObject params) throws Exception { AdvertiseData.Builder builder = new AdvertiseData.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); <|startfocus|> /** python don't have multi map, if advertise data should repeat use serviceUuid, * serviceUuid2, serviceUuid3... . For that use "startsWith" */ <|endfocus|> if (key.startsWith("manufacturerData")) { JSONArray manuf = params.getJSONArray(key); int manufId = manuf.getInt(0); byte[] data = somethingToByteArray(manuf.get(1)); builder.addManufacturerData(manufId, data); } else if (key.startsWith("serviceData")) { JSONArray serDat = params.getJSONArray(key); ParcelUuid uuid = ParcelUuid.fromString(serDat.getString(0)); byte[] data = somethingToByteArray(serDat.get(1)); builder.addServiceData(uuid, data); } else if (key.startsWith("serviceUuid")) {
code_review:  P 
target code: + something.getClass().getName() + " to byte array!"); } } public AdvertiseData buildAdvData(JSONObject params) throws Exception { AdvertiseData.Builder builder = new AdvertiseData.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); /** Python doesn't have multi map, if advertise data should repeat use * serviceUuid, serviceUuid2, serviceUuid3... . For that use "startsWith" */ if (key.startsWith("manufacturerData")) { JSONArray manuf = params.getJSONArray(key); int manufId = manuf.getInt(0); byte[] data = somethingToByteArray(manuf.get(1)); builder.addManufacturerData(manufId, data); } else if (key.startsWith("serviceData")) { JSONArray serDat = params.getJSONArray(key); ParcelUuid uuid = ParcelUuid.fromString(serDat.getString(0)); byte[] data = somethingToByteArray(serDat.get(1)); builder.addServiceData(uuid, data); } else if (key.startsWith("serviceUuid")) {
response: + something.getClass().getName() + " to byte array!"); } } public AdvertiseData buildAdvData(JSONObject params) throws Exception { AdvertiseData.Builder builder = new AdvertiseData.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); if (key.startsWith("manufacturerData")) { JSONArray manuf = params.getJSONArray(key); int manufId = manuf.getInt(0); byte[] data = somethingToByteArray(manuf.get(1)); builder.addManufacturerData(manufId, data); } else if (key.startsWith("serviceData")) { JSONArray serDat = params.getJSONArray(key); ParcelUuid uuid = ParcelUuid.fromString(serDat.getString(0)); byte[] data = somethingToByteArray(serDat.get(1)); builder.addServiceData(uuid, data); } else if (key.startsWith("serviceUuid")) {

sample: 180
buggy_code:  + something.getClass().getName() + " to byte array!"); } } public AdvertiseData buildAdvData(JSONObject params) throws Exception { AdvertiseData.Builder builder = new AdvertiseData.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); <|startfocus|> /** python don't have multi map, if advertise data should repeat use serviceUuid, * serviceUuid2, serviceUuid3... . For that use "startsWith" */ <|endfocus|> if (key.startsWith("manufacturerData")) { JSONArray manuf = params.getJSONArray(key); int manufId = manuf.getInt(0); byte[] data = somethingToByteArray(manuf.get(1)); builder.addManufacturerData(manufId, data); } else if (key.startsWith("serviceData")) { JSONArray serDat = params.getJSONArray(key); ParcelUuid uuid = ParcelUuid.fromString(serDat.getString(0)); byte[] data = somethingToByteArray(serDat.get(1)); builder.addServiceData(uuid, data); } else if (key.startsWith("serviceUuid")) {
code_review:  doesn't 
target code: + something.getClass().getName() + " to byte array!"); } } public AdvertiseData buildAdvData(JSONObject params) throws Exception { AdvertiseData.Builder builder = new AdvertiseData.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); /** Python doesn't have multi map, if advertise data should repeat use * serviceUuid, serviceUuid2, serviceUuid3... . For that use "startsWith" */ if (key.startsWith("manufacturerData")) { JSONArray manuf = params.getJSONArray(key); int manufId = manuf.getInt(0); byte[] data = somethingToByteArray(manuf.get(1)); builder.addManufacturerData(manufId, data); } else if (key.startsWith("serviceData")) { JSONArray serDat = params.getJSONArray(key); ParcelUuid uuid = ParcelUuid.fromString(serDat.getString(0)); byte[] data = somethingToByteArray(serDat.get(1)); builder.addServiceData(uuid, data); } else if (key.startsWith("serviceUuid")) {
response: private void updateData(@NonNull TimeQueryFilter filters, IProgressMonitor monitor) { if (fXYDataProvider == null) { TraceCompassLogUtils.traceInstant(LOGGER, Level.WARNING, "Data provider for this viewer is not available"); //$NON-NLS-1$ return; } boolean isComplete = false; do { TmfModelResponse<ITmfXyModel> response = fXYDataProvider.fetchXY(filters, monitor); ITmfXyModel model = response.getModel(); if (!(model instanceof ITmfCommonXAxisModel)) { Activator.getDefault().logError("The model is of the wrong type: " + model); //$NON-NLS-1$ } extractXYModelAndUpdateViewModel((ITmfCommonXAxisModel) model); updateDisplay(); ITmfResponse.Status status = response.getStatus(); if (status == ITmfResponse.Status.COMPLETED) { /* Model is complete, no need to request again the data provider */ isComplete = true; } else if (status == ITmfResponse.Status.FAILED || status == ITmfResponse.Status.CANCELLED) { /* Error occurred, log and return */ Activator.getDefault().logError("Error occurred while fetching XY data: " + response.getStatus().toString()); //$NON-NLS-1$ return; } } while (!isComplete); }

sample: 181
buggy_code:  public PeriodicAdvertisingParameters buildPeriodicParameters(JSONObject params) throws Exception { PeriodicAdvertisingParameters.Builder builder = new PeriodicAdvertisingParameters.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); if (key.equals("enable")) { builder.setEnable(params.getBoolean(key)); } else if (key.equals("includeTxPower")) { builder.setIncludeTxPower(params.getBoolean(key)); <|startfocus|> } else if (key.equals("includeTxPower")) { <|endfocus|> builder.setInterval(params.getInt(key)); } else { throw new IllegalArgumentException( "Unknown PeriodicAdvertisingParameters field " + key); } } return builder.build(); } /** * Starts ble advertising * * @throws Exception */ @Rpc(description = "Starts ble advertisement") public void bleAdvSetStartAdvertisingSet( @RpcParameter(name = "params") JSONObject parametersJson, @RpcParameter(name = "data") JSONObject dataJson, @RpcParameter(name = "scanResponse") JSONObject scanResponseJson, @RpcParameter(name = "periodicParameters") JSONObject periodicParametersJson,
code_review:  same if statement 
target code: public PeriodicAdvertisingParameters buildPeriodicParameters(JSONObject params) throws Exception { PeriodicAdvertisingParameters.Builder builder = new PeriodicAdvertisingParameters.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); if (key.equals("enable")) { builder.setEnable(params.getBoolean(key)); } else if (key.equals("includeTxPower")) { builder.setIncludeTxPower(params.getBoolean(key)); } else if (key.equals("interval")) { builder.setInterval(params.getInt(key)); } else { throw new IllegalArgumentException( "Unknown PeriodicAdvertisingParameters field " + key); } } return builder.build(); } /** * Starts ble advertising * * @throws Exception */ @Rpc(description = "Starts ble advertisement") public void bleAdvSetStartAdvertisingSet( @RpcParameter(name = "params") JSONObject parametersJson, @RpcParameter(name = "data") JSONObject dataJson, @RpcParameter(name = "scanResponse") JSONObject scanResponseJson, @RpcParameter(name = "periodicParameters") JSONObject periodicParametersJson,
response: public PeriodicAdvertisingParameters buildPeriodicParameters(JSONObject params) throws Exception { PeriodicAdvertisingParameters.Builder builder = new PeriodicAdvertisingParameters.Builder(); Iterator<String> keys = params.keys(); while (keys.hasNext()) { String key = keys.next(); if (key.equals("enable")) { builder.setEnable(params.getBoolean(key)); } else if (key.equals("includeTxPower")) { builder.setIncludeTxPower(params.getBoolean(key)); } else if (key.equals("interval")) { builder.setInterval(params.getInt(key)); } else { throw new IllegalArgumentException( "Unknown PeriodicAdvertisingParameters field " + key); } } return builder.build(); } /** * Starts ble advertising * * @throws Exception */ @Rpc(description = "Starts ble advertisement") public void bleAdvSetStartAdvertisingSet( @RpcParameter(name = "params") JSONObject parametersJson, @RpcParameter(name = "data") JSONObject dataJson, @RpcParameter(name = "scanResponse") JSONObject scanResponseJson, @RpcParameter(name = "periodicParameters") JSONObject periodicParametersJson, // rest of the code }

sample: 182
buggy_code: <|startfocus|> public void useAnyBssidForConnectionIfFirmwareControlsRoaming() { <|endfocus|> // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY);
code_review:  this test should have 2 flavors - with and without a bssid specified. One of the two should have failed with the next CL. 
target code: public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasNoBssidSpecified() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY);
response: public void useAnyBssidForConnectionIfFirmwareControlsRoaming() { when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); mWifiConnectivityManager.handleScreenStateChanged(true); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); }

sample: 183
buggy_code:  private int readHighTagNumber() throws BerDataValueFormatException { // Base-128 big-endian form, where each byte has the highest bit set, except for the last // byte int b; int result = 0; do { if (!mBuf.hasRemaining()) { throw new BerDataValueFormatException("Truncated tag number"); } b = mBuf.get(); result <<= 7; result += b & 0x7f; if (result < 0) { throw new BerDataValueFormatException("Tag number too large"); <|startfocus|> } <|endfocus|> } while ((b & 0x80) != 0); return result; } private int readShortFormLength(int firstLengthByte) throws BerDataValueFormatException { return firstLengthByte & 0x7f; } private int readLongFormLength(int firstLengthByte) throws BerDataValueFormatException { // The low 7 bits of the first byte represent the number of bytes (following the first // byte) in which the length is in big-endian base-256 form int byteCount = firstLengthByte & 0x7f;
code_review:  < 0 doesn't seem like a great overflow check, maybe be more explicit? 
target code: private int readHighTagNumber() throws BerDataValueFormatException { // Base-128 big-endian form, where each byte has the highest bit set, except for the last // byte int b; int result = 0; do { if (!mBuf.hasRemaining()) { throw new BerDataValueFormatException("Truncated tag number"); } b = mBuf.get(); result <<= 7; result += b & 0x7f; if (result < 0) { throw new BerDataValueFormatException("Tag number too large"); } result <<= 7; result |= b & 0x7f; } while ((b & 0x80) != 0); return result; } private int readShortFormLength(int firstLengthByte) throws BerDataValueFormatException { return firstLengthByte & 0x7f; } private int readLongFormLength(int firstLengthByte) throws BerDataValueFormatException { // The low 7 bits of the first byte represent the number of bytes (following the first // byte) in which the length is in big-endian base-256 form int byteCount = firstLengthByte & 0x7f;
response: private int readHighTagNumber() throws BerDataValueFormatException { int b; int result = 0; do { if (!mBuf.hasRemaining()) { throw new BerDataValueFormatException("Truncated tag number"); } b = mBuf.get(); result <<= 7; result += b & 0x7f; if (result < 0) { throw new BerDataValueFormatException("Tag number too large"); } } while ((b & 0x80) != 0); return result; } private int readShortFormLength(int firstLengthByte) throws BerDataValueFormatException { return firstLengthByte & 0x7f; } private int readLongFormLength(int firstLengthByte) throws BerDataValueFormatException { int byteCount = firstLengthByte & 0x7f; // Rest of the code }

sample: 184
buggy_code:  "Truncated indefinite-length contents: " + bytesRead + " bytes read"); } int b = mBuf.get(); bytesRead++; if (bytesRead < 0) { throw new BerDataValueFormatException("Indefinite-length contents too long"); } if (b == 0) { if (prevZeroByte) { // End of contents reached -- we've read the value and its terminator 0x00 0x00 return bytesRead - 2; } prevZeroByte = true; <|startfocus|> continue; <|endfocus|> } else { prevZeroByte = false; } } } } 
code_review:  Unneeded? 
target code: "Truncated indefinite-length contents: " + bytesRead + " bytes read"); } int b = mBuf.get(); bytesRead++; if (bytesRead < 0) { throw new BerDataValueFormatException("Indefinite-length contents too long"); } if (b == 0) { if (prevZeroByte) { // End of contents reached -- we've read the value and its terminator 0x00 0x00 return bytesRead - 2; } prevZeroByte = true; } else { prevZeroByte = false; } } } }
response: "Truncated indefinite-length contents: " + bytesRead + " bytes read"); } int b = mBuf.get(); bytesRead++; if (bytesRead < 0) { throw new BerDataValueFormatException("Indefinite-length contents too long"); } if (b == 0) { if (prevZeroByte) { // End of contents reached -- we've read the value and its terminator 0x00 0x00 return bytesRead - 2; } prevZeroByte = true; continue; } else { prevZeroByte = false; } } } }

sample: 185
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.rs.rsov.test; import android.content.Context; import android.renderscript.Allocation; import android.renderscript.Element; import android.renderscript.RenderScript; import android.renderscript.Type; import android.util.Log; public class UT_global_query extends UnitTest { protected UT_global_query(RSoVTestCore rstc, Context ctx) { super(rstc, "global_query", ctx); } 
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.rs.rsov.test; import android.content.Context; import android.renderscript.Allocation; import android.renderscript.Element; import android.renderscript.RenderScript; import android.renderscript.Type; import android.util.Log; public class UT_global_query extends UnitTest { protected UT_global_query(RSoVTestCore rstc, Context ctx) { super(rstc, "global_query", ctx); }
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.rs.rsov.test; import android.content.Context; import android.renderscript.Allocation; import android.renderscript.Element; import android.renderscript.RenderScript; import android.renderscript.Type; import android.util.Log; public class UT_global_query extends UnitTest { protected UT_global_query(RSoVTestCore rstc, Context ctx) { super(rstc, "global_query", ctx); } }

sample: 186
buggy_code:  req.channelRequestType = channelRequestType; req.channel = channel; req.ifaceName = interfaceName; req.securityRequired = !((pmk == null || pmk.length == 0) && (passphrase == null || passphrase.length() == 0)); if (req.securityRequired) { req.cipherType = getStrongestCipherSuiteType(capabilities.supportedCipherSuites); if (pmk != null && pmk.length != 0) { convertLcByteToUcByteArray(pmk, req.pmk); } else { convertLcByteToUcByteArray(passphrase.getBytes(), req.passphrase); } <|startfocus|> } <|endfocus|> try { WifiStatus status = iface.initiateDataPathRequest(transactionId, req); if (status.code == WifiStatusCode.SUCCESS) { return true; } else { Log.e(TAG, "initiateDataPath: error: " + statusString(status)); return false; } } catch (RemoteException e) { Log.e(TAG, "initiateDataPath: exception: " + e); return false; }
code_review:  Consider filing a bug to rename this method. I took Lc to mean "lower-case", and Uc to mean "upper-case", and was worried that this meant we were up-casing all passphrases (which would reduce entropy). Examining the source, I don't actually see upcasing (good). But a clearer name (e.g. convertByteArrayToArrayList) would avoid the confusion altogether. 
target code: req.channelRequestType = channelRequestType; req.channel = channel; req.ifaceName = interfaceName; req.securityRequired = !((pmk == null || pmk.length == 0) && (passphrase == null || passphrase.length() == 0)); if (req.securityRequired) { req.cipherType = getStrongestCipherSuiteType(capabilities.supportedCipherSuites); if (pmk != null && pmk.length != 0) { convertLcByteToUcByteArray(pmk, req.pmk); } else { convertLcByteToUcByteArray(passphrase.getBytes(), req.passphrase); } } if (passphrase != null && passphrase.length() != 0) { req.cipherType = getStrongestCipherSuiteType(capabilities.supportedCipherSuites); req.securityConfig = NanDataPathSecurityConfig.PASSPHRASE; convertNativeByteArrayToArrayList(passphrase.getBytes(), req.passphrase); } try { WifiStatus status = iface.initiateDataPathRequest(transactionId, req); if (status.code == WifiStatusCode.SUCCESS) { return true; } else { Log.e(TAG, "initiateDataPath: error: " + statusString(status)); return false; } } catch (RemoteException e) { Log.e(TAG, "initiateDataPath: exception: " + e); return false; }
response: req.channelRequestType = channelRequestType; req.channel = channel; req.ifaceName = interfaceName; req.securityRequired = !((pmk == null || pmk.length == 0) && (passphrase == null || passphrase.length() == 0)); if (req.securityRequired) { req.cipherType = getStrongestCipherSuiteType(capabilities.supportedCipherSuites); if (pmk != null && pmk.length != 0) { convertByteArrayToArrayList(pmk, req.pmk); } else { convertByteArrayToArrayList(passphrase.getBytes(), req.passphrase); } } try { WifiStatus status = iface.initiateDataPathRequest(transactionId, req); if (status.code == WifiStatusCode.SUCCESS) { return true; } else { Log.e(TAG, "initiateDataPath: error: " + statusString(status)); return false; } } catch (RemoteException e) { Log.e(TAG, "initiateDataPath: exception: " + e); return false; }

sample: 187
buggy_code:  public boolean setWfdEnable(boolean enable) { return mSupplicantP2pIfaceHal.enableWfd(enable); } /** * Set Wifi Display device info. * * @param hex WFD device info as described in section 5.1.2 of WFD technical * specification v1.0.0. * @return true, if operation was successful. */ public boolean setWfdDeviceInfo(String hex) { return mSupplicantP2pIfaceHal.setWfdDeviceInfo(hex); } /** <|startfocus|> * Initiate a P2P service discovery indefinitely. <|endfocus|> * * @return boolean value indicating whether operation was successful. */ public boolean p2pFind() { return p2pFind(0); } /** * Initiate a P2P service discovery with a (optional) timeout. * * @param timeout Max time to be spent is peforming discovery. * Set to 0 to indefinely continue discovery untill and explicit * |stopFind| is sent. * @return boolean value indicating whether operation was successful. */ public boolean p2pFind(int timeout) {
code_review:  Does this trigger some callback? Mention it here 
target code: public boolean setWfdEnable(boolean enable) { return mSupplicantP2pIfaceHal.enableWfd(enable); } /** * Set Wifi Display device info. * * @param hex WFD device info as described in section 5.1.2 of WFD technical * specification v1.0.0. * @return true, if operation was successful. */ public boolean setWfdDeviceInfo(String hex) { return mSupplicantP2pIfaceHal.setWfdDeviceInfo(hex); } /** * Initiate a P2P service discovery indefinitely. * Will trigger {@link WifiP2pMonitor#P2P_DEVICE_FOUND_EVENT} on finding devices. * * @return boolean value indicating whether operation was successful. */ public boolean p2pFind() { return p2pFind(0); } /** * Initiate a P2P service discovery with a (optional) timeout. * * @param timeout Max time to be spent is peforming discovery. * Set to 0 to indefinely continue discovery untill and explicit * |stopFind| is sent. * @return boolean value indicating whether operation was successful. */ public boolean p2pFind(int timeout) {
response: public boolean setWfdEnable(boolean enable) { return mSupplicantP2pIfaceHal.enableWfd(enable); } /** * Set Wifi Display device info. * * @param hex WFD device info as described in section 5.1.2 of WFD technical * specification v1.0.0. * @return true, if operation was successful. */ public boolean setWfdDeviceInfo(String hex) { return mSupplicantP2pIfaceHal.setWfdDeviceInfo(hex); } /** * Initiate a P2P service discovery indefinitely. * * @return boolean value indicating whether operation was successful. */ public boolean p2pFind() { return p2pFind(0); } /** * Initiate a P2P service discovery with a (optional) timeout. * * @param timeout Max time to be spent is performing discovery. * Set to 0 to indefinitely continue discovery until an explicit * |stopFind| is sent. * @return boolean value indicating whether operation was successful. */ public boolean p2pFind(int timeout) { // implementation }

sample: 188
buggy_code:  import java.io.IOException; import java.util.Map; import java.util.concurrent.atomic.AtomicReference; public class ToyVpnService extends VpnService implements Handler.Callback, ToyVpnConnection.Listener { private static final String TAG = ToyVpnService.class.getSimpleName(); public static final String ACTION_CONNECT = "com.example.android.toyvpn.START"; public static final String ACTION_DISCONNECT = "com.example.android.toyvpn.STOP"; private Handler mHandler; <|startfocus|> private Map<Integer, Thread> mThreads = new ArrayMap<>(); private int mNextConnectionId = 1; <|endfocus|> private AtomicReference<ParcelFileDescriptor> mTunnelInterface = new AtomicReference<>(); private PendingIntent mConfigureIntent; @Override public void onCreate() { // The handler is only used to show messages. if (mHandler == null) { mHandler = new Handler(this); } // Create the intent to "configure" the connection (just start ToyVpnClient). mConfigureIntent = PendingIntent.getActivity(this, 0, new Intent(this, ToyVpnClient.class), PendingIntent.FLAG_UPDATE_CURRENT); } @Override
code_review:  Consider using SparseArray instead. 
target code: import java.io.IOException; import java.util.Map; import java.util.concurrent.atomic.AtomicReference; public class ToyVpnService extends VpnService implements Handler.Callback, ToyVpnConnection.Listener { private static final String TAG = ToyVpnService.class.getSimpleName(); public static final String ACTION_CONNECT = "com.example.android.toyvpn.START"; public static final String ACTION_DISCONNECT = "com.example.android.toyvpn.STOP"; private Handler mHandler; private SparseArray<Thread> mThreads = new SparseArray<>(); private AtomicInteger mNextConnectionId = new AtomicInteger(1); private AtomicReference<ParcelFileDescriptor> mTunnelInterface = new AtomicReference<>(); private PendingIntent mConfigureIntent; @Override public void onCreate() { // The handler is only used to show messages. if (mHandler == null) { mHandler = new Handler(this); } // Create the intent to "configure" the connection (just start ToyVpnClient). mConfigureIntent = PendingIntent.getActivity(this, 0, new Intent(this, ToyVpnClient.class), PendingIntent.FLAG_UPDATE_CURRENT); } @Override
response: import java.io.IOException; import java.util.Map; import java.util.concurrent.atomic.AtomicReference; public class ToyVpnService extends VpnService implements Handler.Callback, ToyVpnConnection.Listener { private static final String TAG = ToyVpnService.class.getSimpleName(); public static final String ACTION_CONNECT = "com.example.android.toyvpn.START"; public static final String ACTION_DISCONNECT = "com.example.android.toyvpn.STOP"; private Handler mHandler; private SparseArray<Thread> mThreads = new SparseArray<>(); private int mNextConnectionId = 1; private AtomicReference<ParcelFileDescriptor> mTunnelInterface = new AtomicReference<>(); private PendingIntent mConfigureIntent; @Override public void onCreate() { // The handler is only used to show messages. if (mHandler == null) { mHandler = new Handler(this); } // Create the intent to "configure" the connection (just start ToyVpnClient). mConfigureIntent = PendingIntent.getActivity(this, 0, new Intent(this, ToyVpnClient.class), PendingIntent.FLAG_UPDATE_CURRENT); } @Override // Rest of the code... }

sample: 189
buggy_code:  public int onStartCommand(Intent intent, int flags, int startId) { if (ACTION_DISCONNECT.equals(intent.getAction())) { disconnect(); } else { connect(); } <|startfocus|> return START_STICKY; <|endfocus|>
code_review:  Are there going to be more type of actions in the future ? If yes consider using String switch: switch (intent.getAction()) { case ACTION_DISCONNECT: ... case ACTION_CONNECT: ... default: log.w("unknown action " + intent.getAction()); } 
target code: public int onStartCommand(Intent intent, int flags, int startId) { if (ACTION_DISCONNECT.equals(intent.getAction())) { disconnect(); } else { connect(); }
response: public int onStartCommand(Intent intent, int flags, int startId) { switch (intent.getAction()) { case ACTION_DISCONNECT: disconnect(); break; case ACTION_CONNECT: connect(); break; default: log.w("unknown action " + intent.getAction()); break; } return START_STICKY; }

sample: 190
buggy_code:  public boolean handleMessage(Message message) { <|startfocus|> if (message != null) { Toast.makeText(this, message.what, Toast.LENGTH_SHORT).show(); if (message.what != R.string.disconnected) { updateForegroundNotification(message.what); } <|endfocus|> } return true;
code_review:  Shouldn't this use equals() instead of pointer equality ? Even if this works it is not super robust. 
target code: public boolean handleMessage(Message message) { Toast.makeText(this, message.what, Toast.LENGTH_SHORT).show(); if (message.what != R.string.disconnected) { updateForegroundNotification(message.what); } return true;
response: public boolean handleMessage(Message message) { if (message != null) { int messageId = message.what; Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show(); if (messageId != R.string.disconnected) { updateForegroundNotification(messageId); } } return true; }

sample: 191
buggy_code:  } final ParcelFileDescriptor oldInterface = mTunnelInterface.getAndSet(tunInterface); if (oldInterface != null) { try { Log.i(TAG, "Closing interface: " + oldInterface); oldInterface.close(); } catch (IOException e){ Log.e(TAG, "Closing interface failed", e); } } } @Override public synchronized void onDisconnect(int connectionId) { mThreads.remove(connectionId); } @Override public void onRevoke() { disconnect(); } <|startfocus|> private synchronized void connect() { <|endfocus|> // Become a foreground service. Background services can be VPN services too, but they can // be killed by background check before getting a chance to receive onRevoke(). updateForegroundNotification(R.string.connecting); mHandler.sendEmptyMessage(R.string.connecting); final SharedPreferences prefs = getSharedPreferences(ToyVpnClient.Prefs.NAME, MODE_PRIVATE); final ToyVpnConnection connection; try { // Extract information from the shared preferences. connection = new ToyVpnConnection(this, this, mNextConnectionId, prefs.getString(ToyVpnClient.Prefs.SERVER_ADDRESS, ""),
code_review:  what needs to be synchronized in this method besides read/wrote of mNextConnectionId variable and the thread map ? If nothing, could you scope the synchronized block to mNextConnectionId increment and the map update ? 
target code: } final ParcelFileDescriptor oldInterface = mTunnelInterface.getAndSet(tunInterface); if (oldInterface != null) { try { Log.i(TAG, "Closing interface: " + oldInterface); oldInterface.close(); } catch (IOException e){ Log.e(TAG, "Closing interface failed", e); } } } @Override public synchronized void onDisconnect(int connectionId) { mThreads.remove(connectionId); } @Override public void onRevoke() { disconnect(); } private void connect() { // Become a foreground service. Background services can be VPN services too, but they can // be killed by background check before getting a chance to receive onRevoke(). updateForegroundNotification(R.string.connecting); mHandler.sendEmptyMessage(R.string.connecting); final SharedPreferences prefs = getSharedPreferences(ToyVpnClient.Prefs.NAME, MODE_PRIVATE); final ToyVpnConnection connection; try { // Extract information from the shared preferences. connection = new ToyVpnConnection(this, this, mNextConnectionId, prefs.getString(ToyVpnClient.Prefs.SERVER_ADDRESS, ""),
response: } final ParcelFileDescriptor oldInterface = mTunnelInterface.getAndSet(tunInterface); if (oldInterface != null) { try { Log.i(TAG, "Closing interface: " + oldInterface); oldInterface.close(); } catch (IOException e){ Log.e(TAG, "Closing interface failed", e); } } } @Override public void onDisconnect(int connectionId) { synchronized (this) { mThreads.remove(connectionId); } } @Override public void onRevoke() { disconnect(); } private void connect() { synchronized (this) { // Become a foreground service. Background services can be VPN services too, but they can // be killed by background check before getting a chance to receive onRevoke(). updateForegroundNotification(R.string.connecting); mHandler.sendEmptyMessage(R.string.connecting); final SharedPreferences prefs = getSharedPreferences(ToyVpnClient.Prefs.NAME, MODE_PRIVATE); final ToyVpnConnection connection; try { // Extract information from the shared preferences. connection = new ToyVpnConnection(this, this, mNextConnectionId, prefs.getString(ToyVpnClient.Prefs.SERVER_ADDRESS, ""), ... } catch (Exception e) { ... } } }

sample: 192
buggy_code:  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import static android.Manifest.permission.MODIFY_PHONE_STATE; import static android.Manifest.permission.READ_PHONE_STATE; import static com.android.internal.telephony.ims.ImsResolver.SERVICE_INTERFACE; import static junit.framework.Assert.assertEquals; import static junit.framework.Assert.assertNotNull; import static junit.framework.Assert.assertNull; import static junit.framework.Assert.fail; <|startfocus|> import static org.mockito.Matchers.any; <|endfocus|> import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.anyString; import static org.mockito.Matchers.eq; import static org.mockito.Matchers.nullable; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.never; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; /** * Unit tests for ImsService */ @RunWith(AndroidJUnit4.class) public class ImsServiceTest { private static final int TEST_SLOT_0 = 0; private static final int TEST_SLOT_1 = 1;
code_review:  remove? 
target code: import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import static android.Manifest.permission.MODIFY_PHONE_STATE; import static android.Manifest.permission.READ_PHONE_STATE; import static com.android.internal.telephony.ims.ImsResolver.SERVICE_INTERFACE; import static junit.framework.Assert.assertEquals; import static junit.framework.Assert.assertNotNull; import static junit.framework.Assert.assertNull; import static junit.framework.Assert.fail; import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.anyString; import static org.mockito.Matchers.eq; import static org.mockito.Matchers.nullable; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.never; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; /** * Unit tests for ImsService */ @RunWith(AndroidJUnit4.class) public class ImsServiceTest { private static final int TEST_SLOT_0 = 0; private static final int TEST_SLOT_1 = 1;
response: import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import static android.Manifest.permission.MODIFY_PHONE_STATE; import static android.Manifest.permission.READ_PHONE_STATE; import static com.android.internal.telephony.ims.ImsResolver.SERVICE_INTERFACE; import static junit.framework.Assert.assertEquals; import static junit.framework.Assert.assertNotNull; import static junit.framework.Assert.assertNull; import static junit.framework.Assert.fail; import static org.mockito.Matchers.any; import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.anyString; import static org.mockito.Matchers.eq; import static org.mockito.Matchers.nullable; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.never; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; @RunWith(AndroidJUnit4.class) public class ImsServiceTest { private static final int TEST_SLOT_0 = 0; private static final int TEST_SLOT_1 = 1; }

sample: 193
buggy_code:  // Mock the HeadsetService when(mockServiceFactory.getHeadsetService()).thenReturn(mockHeadsetService); when(mockHeadsetService.getPriority(device)) .thenReturn(BluetoothProfile.PRIORITY_UNDEFINED); // Mock the A2DP service when(mockServiceFactory.getA2dpService()).thenReturn(mockA2dpService); when(mockA2dpService.getPriority(device)).thenReturn(BluetoothProfile.PRIORITY_UNDEFINED); // Mock the looper when(mockAdapterService.getMainLooper()).thenReturn(mHandlerThread.getLooper()); <|startfocus|> // Tell the adapterservice that it is a mock (see isMock documentation) <|endfocus|> when(mockAdapterService.isMock()).thenReturn(true); PhonePolicy phPol = new PhonePolicy(mockAdapterService, mockServiceFactory); // Get the broadcast receiver to inject events. BroadcastReceiver injector = phPol.getBroadcastReceiver(); // Inject an event for UUIDs updated for a remote device with only HFP enabled Intent intent = new Intent(BluetoothDevice.ACTION_UUID); intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device); ParcelUuid[] uuids = new ParcelUuid[2]; uuids[0] = BluetoothUuid.Handsfree; uuids[1] = BluetoothUuid.AudioSink; 
code_review:  Needs proper capitalization and/or word splitting. Same comment applies to the reset of the CL. 
target code: // Mock the HeadsetService when(mockServiceFactory.getHeadsetService()).thenReturn(mockHeadsetService); when(mockHeadsetService.getPriority(device)) .thenReturn(BluetoothProfile.PRIORITY_UNDEFINED); // Mock the A2DP service when(mockServiceFactory.getA2dpService()).thenReturn(mockA2dpService); when(mockA2dpService.getPriority(device)).thenReturn(BluetoothProfile.PRIORITY_UNDEFINED); // Mock the looper when(mockAdapterService.getMainLooper()).thenReturn(mHandlerThread.getLooper()); // Tell the AdapterService that it is a mock (see isMock documentation) when(mockAdapterService.isMock()).thenReturn(true); PhonePolicy phPol = new PhonePolicy(mockAdapterService, mockServiceFactory); // Get the broadcast receiver to inject events. BroadcastReceiver injector = phPol.getBroadcastReceiver(); // Inject an event for UUIDs updated for a remote device with only HFP enabled Intent intent = new Intent(BluetoothDevice.ACTION_UUID); intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device); ParcelUuid[] uuids = new ParcelUuid[2]; uuids[0] = BluetoothUuid.Handsfree; uuids[1] = BluetoothUuid.AudioSink;
response: // Mock the HeadsetService when(mockServiceFactory.getHeadsetService()).thenReturn(mockHeadsetService); when(mockHeadsetService.getPriority(device)).thenReturn(BluetoothProfile.PRIORITY_UNDEFINED); // Mock the A2DP service when(mockServiceFactory.getA2dpService()).thenReturn(mockA2dpService); when(mockA2dpService.getPriority(device)).thenReturn(BluetoothProfile.PRIORITY_UNDEFINED); // Mock the looper when(mockAdapterService.getMainLooper()).thenReturn(mHandlerThread.getLooper()); // Tell the AdapterService that it is a mock (see isMock documentation) when(mockAdapterService.isMock()).thenReturn(true); PhonePolicy phonePolicy = new PhonePolicy(mockAdapterService, mockServiceFactory); // Get the broadcast receiver to inject events BroadcastReceiver injector = phonePolicy.getBroadcastReceiver(); // Inject an event for UUIDs updated for a remote device with only HFP enabled Intent intent = new Intent(BluetoothDevice.ACTION_UUID); intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device); ParcelUuid[] uuids = new ParcelUuid[2]; uuids[0] = BluetoothUuid.Handsfree; uuids[1] = BluetoothUuid.AudioSink;

sample: 194
buggy_code: import com.android.internal.telephony.MmiCode; import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import java.util.List; /** * Used to display a dialog from within the Telephony service when running an USSD code */ public class MMIDialogActivity extends Activity { private static final String TAG = MMIDialogActivity.class.getSimpleName(); private Dialog mMMIDialog; private Handler mHandler; private CallManager mCM = PhoneGlobals.getInstance().getCallManager(); <|startfocus|> private Phone mPhone = PhoneGlobals.getPhone(); <|endfocus|> @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = getIntent(); int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, SubscriptionManager.DEFAULT_SUBSCRIPTION_ID); mPhone = PhoneGlobals.getPhone(subId); mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case PhoneGlobals.MMI_COMPLETE: onMMIComplete((MmiCode) ((AsyncResult) msg.obj).result); break; case PhoneGlobals.MMI_CANCEL: onMMICancel();
code_review:  can we remove this? 
target code: import com.android.internal.telephony.MmiCode; import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import java.util.List; /** * Used to display a dialog from within the Telephony service when running an USSD code */ public class MMIDialogActivity extends Activity { private static final String TAG = MMIDialogActivity.class.getSimpleName(); private Dialog mMMIDialog; private Handler mHandler; private CallManager mCM = PhoneGlobals.getInstance().getCallManager(); private Phone mPhone; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = getIntent(); int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, SubscriptionManager.DEFAULT_SUBSCRIPTION_ID); mPhone = PhoneGlobals.getPhone(subId); mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case PhoneGlobals.MMI_COMPLETE: onMMIComplete((MmiCode) ((AsyncResult) msg.obj).result); break; case PhoneGlobals.MMI_CANCEL: onMMICancel();
response: import com.android.internal.telephony.MmiCode; import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; import java.util.List; public class MMIDialogActivity extends Activity { private Dialog mMMIDialog; private Handler mHandler; private CallManager mCM = PhoneGlobals.getInstance().getCallManager(); private Phone mPhone = PhoneGlobals.getPhone(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = getIntent(); int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, SubscriptionManager.DEFAULT_SUBSCRIPTION_ID); mPhone = PhoneGlobals.getPhone(subId); mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case PhoneGlobals.MMI_COMPLETE: onMMIComplete((MmiCode) ((AsyncResult) msg.obj).result); break; case PhoneGlobals.MMI_CANCEL: onMMICancel(); break; default: break; } } }; } private void onMMIComplete(MmiCode code) { // implementation } private void onMMICancel() { // implementation } }

sample: 195
buggy_code:  // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); } /* <|startfocus|> * Firmware supports controlled roaming. * Connect to a network which has a config specified BSSID. <|endfocus|> * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the * expected candidate network ID, and the BSSID value should be * 'any' since firmware controls the roaming. */ @Test public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasBssidSpecified() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set up the candidate configuration such that it has a BSSID specified. WifiConfiguration candidate = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null);
code_review:  spacing different here (and the line below) 
target code: // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); } /* * Firmware supports controlled roaming. * Connect to a network which has a config specified BSSID. * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the * expected candidate network ID, and the BSSID value should be * 'any' since firmware controls the roaming. */ @Test public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasBssidSpecified() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set up the candidate configuration such that it has a BSSID specified. WifiConfiguration candidate = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null);
response: // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); @Test public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasBssidSpecified() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set up the candidate configuration such that it has a BSSID specified. WifiConfiguration candidate = generateWifiConfig(0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); }

sample: 196
buggy_code:  anyBoolean(), anyBoolean())).thenReturn(candidate); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); } /* <|startfocus|> * Firmware does not support controlled roaming. * Connect to a network which doesn't have a config specified BSSID. <|endfocus|> * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the expected candidate network ID, * and the BSSID value should be the candidate scan result specified. */ @Test public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork( CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); } /*
code_review:  extra space again and below 
target code: anyBoolean(), anyBoolean())).thenReturn(candidate); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); } /* * Firmware does not support controlled roaming. * Connect to a network which doesn't have a config specified BSSID. * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the expected candidate network ID, * and the BSSID value should be the candidate scan result specified. */ @Test public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork( CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); } /*
response: Refactored Code: ```java anyBoolean(), anyBoolean())).thenReturn(candidate); mWifiConnectivityManager.handleScreenStateChanged(true); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, WifiStateMachine.SUPPLICANT_BSSID_ANY); } @Test public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { mWifiConnectivityManager.handleScreenStateChanged(true); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); } ``` Note: Removed the commented lines and extra spaces.

sample: 197
buggy_code:  public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); <|startfocus|> verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork( CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); <|endfocus|>
code_review:  shouldn't this just be once? 
target code: public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID);
response: public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { mWifiConnectivityManager.handleScreenStateChanged(true); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, times(1)).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); }

sample: 198
buggy_code:  */ @Test public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork( CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); } /* <|startfocus|> * Firmware does not support controlled roaming. * Connect to a network which has a config specified BSSID. <|endfocus|> * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the expected candidate network ID, * and the BSSID value should be the config specified one. */ @Test public void useConfigSpecifiedBssidToConnectionWhenFirmwareRoamingOff() { // Set up the candidate configuration such that it has a BSSID specified. WifiConfiguration candidate = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); candidate.BSSID = CANDIDATE_BSSID; // config specified ScanResult candidateScanResult = new ScanResult();
code_review:  space 
target code: */ @Test public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork( CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); } /* * Firmware does not support controlled roaming. * Connect to a network which has a config specified BSSID. * * Expected behavior: WifiConnectivityManager calls * WifiStateMachine.startConnectToNetwork() with the expected candidate network ID, * and the BSSID value should be the config specified one. */ @Test public void useConfigSpecifiedBssidToConnectionWhenFirmwareRoamingOff() { // Set up the candidate configuration such that it has a BSSID specified. WifiConfiguration candidate = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); candidate.BSSID = CANDIDATE_BSSID; // config specified ScanResult candidateScanResult = new ScanResult();
response: @Test public void useScanResultBssidToConnectWhenFirmwareRoamingOffAndConfigHasNoBssidSpecified() { // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine, atLeastOnce()).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); } @Test public void useConfigSpecifiedBssidToConnectionWhenFirmwareRoamingOff() { // Set up the candidate configuration such that it has a BSSID specified. WifiConfiguration candidate = generateWifiConfig(0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); candidate.BSSID = CANDIDATE_BSSID; // config specified ScanResult candidateScanResult = new ScanResult(); }

sample: 199
buggy_code:  candidateScanResult.SSID = CANDIDATE_SSID; candidateScanResult.BSSID = CANDIDATE_BSSID; candidate.getNetworkSelectionStatus().setCandidate(candidateScanResult); when(mWifiNS.selectNetwork(anyObject(), anyObject(), anyObject(), anyBoolean(), anyBoolean(), anyBoolean())).thenReturn(candidate); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); <|startfocus|> verify(mWifiStateMachine).startConnectToNetwork( CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); <|endfocus|>
code_review:  does this fit on the line above? 
target code: candidateScanResult.SSID = CANDIDATE_SSID; candidateScanResult.BSSID = CANDIDATE_BSSID; candidate.getNetworkSelectionStatus().setCandidate(candidateScanResult); when(mWifiNS.selectNetwork(anyObject(), anyObject(), anyObject(), anyBoolean(), anyBoolean(), anyBoolean())).thenReturn(candidate); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID);
response: candidateScanResult.SSID = CANDIDATE_SSID; candidateScanResult.BSSID = CANDIDATE_BSSID; candidate.getNetworkSelectionStatus().setCandidate(candidateScanResult); when(mWifiNS.selectNetwork(anyObject(), anyObject(), anyObject(), anyBoolean(), anyBoolean(), anyBoolean())).thenReturn(candidate); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Set WiFi to disconnected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED); verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID);

sample: 200
buggy_code:  } updateAlwaysOnNotification(detailedState); } /** * Chooses whether to force all connections to go though VPN. * * Used to enable/disable legacy VPN lockdown. This uses the same rule-based mechanism as * {@link #setAlwaysOnPackage(String, boolean)}; previous settings from calling that function * will be replaced. * * @param lockdown whether to prevent all traffic outside of a VPN. */ <|startfocus|> public synchronized void setLockdownEnabled(boolean lockdown) { <|endfocus|> enforceControlPermissionOrInternalCaller(); // Explicitly disable previous settings from always-on app VPN if it was set up, to avoid // getting into a confusing state with both enabled at the same time. if (mAlwaysOn) { setAlwaysOnPackage(null, false); } // Apply the new lockdown rules. setVpnForcedLocked(lockdown); mLockdown = lockdown; } /** * Configures an always-on VPN connection through a specific application. * This connection is automatically granted and persisted after a reboot. *
code_review:  What about "setLockdown()", "Enabled" is kind of redundant with true/false parameter. i.e setLockdown(true), setLockdown(false), setLockdown(mIsLockdownEnabled) are self-documenting enough. 
target code: } updateAlwaysOnNotification(detailedState); } /** * Chooses whether to force all connections to go though VPN. * * Used to enable/disable legacy VPN lockdown. This uses the same rule-based mechanism as * {@link #setAlwaysOnPackage(String, boolean)}; previous settings from calling that function * will be replaced. * * @param lockdown whether to prevent all traffic outside of a VPN. */ public synchronized void setLockdown(boolean lockdown) { enforceControlPermissionOrInternalCaller(); // Explicitly disable previous settings from always-on app VPN if it was set up, to avoid // getting into a confusing state with both enabled at the same time. if (mAlwaysOn) { setAlwaysOnPackage(null, false); } // Apply the new lockdown rules. setVpnForcedLocked(lockdown); mLockdown = lockdown; } /** * Configures an always-on VPN connection through a specific application. * This connection is automatically granted and persisted after a reboot. *
response: public synchronized void setLockdown(boolean lockdown) { enforceControlPermissionOrInternalCaller(); if (mAlwaysOn) { setAlwaysOnPackage(null, false); } setVpnForcedLocked(lockdown); mLockdown = lockdown; }

sample: 201
buggy_code:  * * @param lockdown whether to prevent all traffic outside of a VPN. */ public synchronized void setLockdownEnabled(boolean lockdown) { enforceControlPermissionOrInternalCaller(); // Explicitly disable previous settings from always-on app VPN if it was set up, to avoid // getting into a confusing state with both enabled at the same time. if (mAlwaysOn) { setAlwaysOnPackage(null, false); } // Apply the new lockdown rules. setVpnForcedLocked(lockdown); <|startfocus|> mLockdown = lockdown; <|endfocus|> } /** * Configures an always-on VPN connection through a specific application. * This connection is automatically granted and persisted after a reboot. * * <p>The designated package should exist and declare a {@link VpnService} in its * manifest guarded by {@link android.Manifest.permission.BIND_VPN_SERVICE}, * otherwise the call will fail. * * @param packageName the package to designate as always-on VPN supplier. * @param lockdown whether to prevent traffic outside of a VPN, for example while connecting.
code_review:  Should this function tries to detect an edge transition and be idempotent, should it distinguish mLockdown transitions true -> false and false -> true. For instance it looks like the if(mAlwaysOn) path is relevant only when lockdown is true. Related question: are setAlwaysOnPackage and setVpnForcedLocked idempotent ? 
target code: * * @param lockdown whether to prevent all traffic outside of a VPN. */ public synchronized void setLockdownEnabled(boolean lockdown) { enforceControlPermissionOrInternalCaller(); // Explicitly disable previous settings from always-on app VPN if it was set up, to avoid // getting into a confusing state with both enabled at the same time. if (mAlwaysOn) { setAlwaysOnPackage(null, false); } // Apply the new lockdown rules. setVpnForcedLocked(lockdown); mLockdown = lockdown; // Update app lockdown setting if it changed. Legacy VPN lockdown status is controlled by // LockdownVpnTracker.isEnabled() which keeps track of its own state. if (mAlwaysOn) { saveAlwaysOnPackage(); } } /** * Configures an always-on VPN connection through a specific application. * This connection is automatically granted and persisted after a reboot. * * <p>The designated package should exist and declare a {@link VpnService} in its * manifest guarded by {@link android.Manifest.permission.BIND_VPN_SERVICE}, * otherwise the call will fail. * * @param packageName the package to designate as always-on VPN supplier. * @param lockdown whether to prevent traffic outside of a VPN, for example while connecting.
response: public synchronized void setLockdownEnabled(boolean lockdown) { enforceControlPermissionOrInternalCaller(); if (mAlwaysOn && lockdown) { setAlwaysOnPackage(null, false); } setVpnForcedLocked(lockdown); mLockdown = lockdown; } public void setAlwaysOnPackage(String packageName, boolean lockdown) { // implementation } public void setVpnForcedLocked(boolean lockdown) { // implementation }

sample: 202
buggy_code:  private void setVpnForcedLocked(boolean enforce) { <|startfocus|> if (isNullOrLegacyVpn(mPackage)) { setVpnForcedWithExemptionsLocked(enforce, null); } else { setVpnForcedWithExemptionsLocked(enforce, Collections.singletonList(mPackage)); } <|endfocus|>
code_review:  Similarly to the change in setVpnForcedWithExemptionsLocked, can you have a single call to setVpnForcedWithExemptionsLocked with the isNullOrLegacyVpn(mPackage) conditional deciding on eemptedPackages ? 
target code: private void setVpnForcedLocked(boolean enforce) { final List<String> exemptedPackages = isNullOrLegacyVpn(mPackage) ? null : Collections.singletonList(mPackage); setVpnForcedWithExemptionsLocked(enforce, exemptedPackages);
response: private void setVpnForcedLocked(boolean enforce) { List<String> exemptedPackages = null; if (isNullOrLegacyVpn(mPackage)) { setVpnForcedWithExemptionsLocked(enforce, exemptedPackages); } else { exemptedPackages = Collections.singletonList(mPackage); setVpnForcedWithExemptionsLocked(enforce, exemptedPackages); } }

sample: 203
buggy_code:  private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) { final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers); final Set<UidRange> addedRanges; if (enforce) { addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */ null, /* disallowedApplications */ exemptedPackages); removedRanges.removeAll(addedRanges); addedRanges.removeAll(mBlockedUsers); <|startfocus|> } else { addedRanges = Collections.<UidRange> emptySet(); <|endfocus|> } setAllowOnlyVpnForUids(false, removedRanges); setAllowOnlyVpnForUids(true, addedRanges);
code_review:  If addedRanges is not modified below, I suggest using Collections.EMPTY_SET (probably with a type cast) as the default for addedRanges and removing the else branch. 
target code: private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) { final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers); final Set<UidRange> addedRanges; if (enforce) { addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */ null, /* disallowedApplications */ exemptedPackages); removedRanges.removeAll(addedRanges); addedRanges.removeAll(mBlockedUsers); } setAllowOnlyVpnForUids(false, removedRanges); setAllowOnlyVpnForUids(true, addedRanges);
response: private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) { final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers); final Set<UidRange> addedRanges; if (enforce) { addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */ null, /* disallowedApplications */ exemptedPackages); removedRanges.removeAll(addedRanges); addedRanges.removeAll(mBlockedUsers); } else { addedRanges = Collections.emptySet(); } setAllowOnlyVpnForUids(false, removedRanges); setAllowOnlyVpnForUids(true, addedRanges); }

sample: 204
buggy_code:  private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) { final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers); final Set<UidRange> addedRanges; if (enforce) { addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */ null, /* disallowedApplications */ exemptedPackages); removedRanges.removeAll(addedRanges); addedRanges.removeAll(mBlockedUsers); <|startfocus|> } else { addedRanges = Collections.<UidRange> emptySet(); <|endfocus|> } setAllowOnlyVpnForUids(false, removedRanges); setAllowOnlyVpnForUids(true, addedRanges);
code_review:  type inference does not work without this ? 
target code: private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) { final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers); final Set<UidRange> addedRanges; if (enforce) { addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */ null, /* disallowedApplications */ exemptedPackages); removedRanges.removeAll(addedRanges); addedRanges.removeAll(mBlockedUsers); } setAllowOnlyVpnForUids(false, removedRanges); setAllowOnlyVpnForUids(true, addedRanges);
response: protected TaskConfigFactory(GitRepositoryManager gitMgr) { this.allProjects = new AllProjectsName("All-Projects"); this.gitMgr = gitMgr; } private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) { final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers); final Set<UidRange> addedRanges; if (enforce) { addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, null, exemptedPackages); removedRanges.removeAll(addedRanges); addedRanges.removeAll(mBlockedUsers); } else { addedRanges = Collections.emptySet(); } setAllowOnlyVpnForUids(false, removedRanges); setAllowOnlyVpnForUids(true, addedRanges); }

sample: 205
buggy_code:  * instances representing the type variable. However, all instances * representing a type variable must be equal() to each other. * As a consequence, users of type variables must not rely on the identity * of instances of classes implementing this interface. * * @param <D> the type of generic declaration that declared the * underlying type variable. * * @since 1.5 */ <|startfocus|> // Android-changed: Removed AnnotatedElement due to excluded support for runtime type annotations public interface TypeVariable<D extends GenericDeclaration> extends Type{ <|endfocus|> /** * Returns an array of {@code Type} objects representing the * upper bound(s) of this type variable. Note that if no upper bound is * explicitly declared, the upper bound is {@code Object}. * * <p>For each upper bound B: <ul> <li>if B is a parameterized * type or a type variable, it is created, (see {@link * java.lang.reflect.ParameterizedType ParameterizedType} for the
code_review:  Seems inconsistent to document this removal here but document the removal of getAnnotatedBounds() below. Is there a reason? 
target code: * instances representing the type variable. However, all instances * representing a type variable must be equal() to each other. * As a consequence, users of type variables must not rely on the identity * of instances of classes implementing this interface. * * @param <D> the type of generic declaration that declared the * underlying type variable. * * @since 1.5 */ // Android-changed: Removed AnnotatedElement super-class due to excluded support // for runtime type annotations public interface TypeVariable<D extends GenericDeclaration> extends Type { /** * Returns an array of {@code Type} objects representing the * upper bound(s) of this type variable. Note that if no upper bound is * explicitly declared, the upper bound is {@code Object}. * * <p>For each upper bound B: <ul> <li>if B is a parameterized * type or a type variable, it is created, (see {@link * java.lang.reflect.ParameterizedType ParameterizedType} for the
response: Fixed Code: ```java public interface TypeVariable<D extends GenericDeclaration> extends Type { /** * Returns an array of {@code Type} objects representing the * upper bound(s) of this type variable. Note that if no upper bound is * explicitly declared, the upper bound is {@code Object}. * * <p>For each upper bound B: * <ul> * <li>if B is a parameterized type or a type variable, it is created, * (see {@link java.lang.reflect.ParameterizedType ParameterizedType} for the * details of the creation process for parameterized types). * <li>Otherwise, B is resolved. * </ul> * * @return an array of {@code Type} objects representing the upper bound(s) * of this type variable * @throws TypeNotPresentException if any of the bounds refers to a * non-existent type declaration * @throws MalformedParameterizedTypeException if any of the bounds refer * to a parameterized type that cannot be instantiated for any reason * @since 1.8 */ Type[] getBounds(); /** * Returns the {@code GenericDeclaration} object representing the * generic declaration declared this type variable. * * @return the generic declaration declared for this type variable. * @since 1.5 */ D getGenericDeclaration(); /** * Returns the name of this type variable, as it occurs in the source code. * * @return the name of this type variable * @since 1.8 */ String getName(); /** * Returns an array of {@code AnnotatedType} objects that represent the use * of types to specify superinterfaces and superclasses of the entity * represented by this type variable. The order of the objects in the array * corresponds to the order of the bounds in the declaration of the type * variable. * * @return an array of objects representing the upper bounds of the type * variable * @since 1.8 */ AnnotatedType[] getAnnotatedBounds(); } ``` Review: Removed AnnotatedElement due to excluded support for runtime type annotations.

sample: 206
buggy_code:  * @param log WifiLog object to assign to the clientHandler */ @VisibleForTesting public void setWifiHandlerLogForTest(WifiLog log) { mClientHandler.setWifiLog(log); } /** * Check if we are ready to start wifi. * <|startfocus|> * First check if we will be restarting system services to decrypt the device. If the device is * not encrypted, check if Wi-Fi needs to be enabled and start if needed * * This function is used only at boot time. <|endfocus|> */ public void checkAndStartWifi() { // First check if we will end up restarting WifiService if (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) { Log.d(TAG, "Device still encrypted. Need to restart SystemServer. Do not start wifi."); return; } // Check if wi-fi needs to be enabled boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled(); Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled")); registerForScanModeChange();
code_review:  Please remove one of these words. (Your choice which one. ;-)) 
target code: * @param log WifiLog object to assign to the clientHandler */ @VisibleForTesting public void setWifiHandlerLogForTest(WifiLog log) { mClientHandler.setWifiLog(log); } /** * Check if we are ready to start wifi. * * This function is used only at boot time */ public void checkAndStartWifi() { // First check if we will end up restarting WifiService if (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) { Log.d(TAG, "Device still encrypted. Need to restart SystemServer. Do not start wifi."); return; } // Check if wi-fi needs to be enabled boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled(); Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled")); registerForScanModeChange();
response: @VisibleForTesting public void setWifiHandlerLogForTest(WifiLog log) { mClientHandler.setWifiLog(log); } public void checkAndStartWifi() { if (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) { Log.d(TAG, "Device still encrypted. Need to restart SystemServer. Do not start wifi."); return; } boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled(); Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled")); registerForScanModeChange(); }

sample: 207
buggy_code:  public void testWifiDoesNotStartWhenDeviceTriggerResetMainAtBoot() { <|startfocus|> when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn("trigger_reset_main"); <|endfocus|> when(mSettingsStore.isWifiToggleEnabled()).thenReturn(false); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController, never()).start();
code_review:  Consider "WifiControllerDoesNotStart", for greater contrast with the successful start test. 
target code: public void testWifiDoesNotStartWhenDeviceTriggerResetMainAtBoot() { when(mFrameworkFacade.inStorageManagerCryptKeeperBounce()).thenReturn(true); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(false); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController, never()).start();
response: public void testWifiControllerDoesNotStartWhenDeviceTriggerResetMainAtBoot() { when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn("trigger_reset_main"); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(false); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController, never()).start(); }

sample: 208
buggy_code:  public void testWifiStartsWhenDeviceIsDecryptedAtBootWithWifiDisabled() { <|startfocus|> when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn(""); <|endfocus|> when(mSettingsStore.isWifiToggleEnabled()).thenReturn(false); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController).start(); verify(mWifiController, never()).sendMessage(CMD_WIFI_TOGGLED);
code_review:  Maybe "WifiControllerStarts", to make the test's aim more obvious? (It's surprising to read Wifistarts...WithWifiDisabled.) 
target code: public void testWifiStartsWhenDeviceIsDecryptedAtBootWithWifiDisabled() { when(mFrameworkFacade.inStorageManagerCryptKeeperBounce()).thenReturn(false); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(false); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController).start(); verify(mWifiController, never()).sendMessage(CMD_WIFI_TOGGLED);
response: public void testWifiControllerStartsWhenDeviceIsDecryptedAtBootWithWifiDisabled() { when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn(""); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(false); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController).start(); verify(mWifiController, never()).sendMessage(CMD_WIFI_TOGGLED); }

sample: 209
buggy_code:  public void testWifiStartsWhenDeviceIsDecryptedAtBootWithWifiEnabled() { <|startfocus|> when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn(""); <|endfocus|> when(mSettingsStore.handleWifiToggled(true)).thenReturn(true); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(true); when(mWifiStateMachine.syncGetWifiState()).thenReturn(WIFI_STATE_DISABLED); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController).start(); verify(mWifiController).sendMessage(CMD_WIFI_TOGGLED);
code_review:  Consider "WifiFullyStarts" or "WifiStartsFully", to make the contrast with the other cases more obvious? 
target code: public void testWifiStartsWhenDeviceIsDecryptedAtBootWithWifiEnabled() { when(mFrameworkFacade.inStorageManagerCryptKeeperBounce()).thenReturn(false); when(mSettingsStore.handleWifiToggled(true)).thenReturn(true); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(true); when(mWifiStateMachine.syncGetWifiState()).thenReturn(WIFI_STATE_DISABLED); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController).start(); verify(mWifiController).sendMessage(CMD_WIFI_TOGGLED);
response: public void testWifiFullyStartsWhenDeviceIsDecryptedAtBootWithWifiEnabled() { when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn(""); when(mSettingsStore.handleWifiToggled(true)).thenReturn(true); when(mSettingsStore.isWifiToggleEnabled()).thenReturn(true); when(mWifiStateMachine.syncGetWifiState()).thenReturn(WIFI_STATE_DISABLED); mWifiServiceImpl.checkAndStartWifi(); verify(mWifiController).start(); verify(mWifiController).sendMessage(CMD_WIFI_TOGGLED); }

sample: 210
buggy_code:  public static final int SUP_DISCONNECTION_EVENT = BASE + 2; /* Network connection completed */ public static final int NETWORK_CONNECTION_EVENT = BASE + 3; /* Network disconnection completed */ public static final int NETWORK_DISCONNECTION_EVENT = BASE + 4; /* Scan results are available */ public static final int SCAN_RESULTS_EVENT = BASE + 5; /* Scheduled scan results are available */ public static final int SCHED_SCAN_RESULTS_EVENT = BASE + 6; /* Supplicate state changed */ <|startfocus|> public static final int SUPPLICANT_STATE_CHANGE_EVENT = BASE + 7; <|endfocus|> /* Password failure and EAP authentication failure */ public static final int AUTHENTICATION_FAILURE_EVENT = BASE + 8; /* WPS success detected */ public static final int WPS_SUCCESS_EVENT = BASE + 9; /* WPS failure detected */ public static final int WPS_FAIL_EVENT = BASE + 10; /* WPS overlap detected */ public static final int WPS_OVERLAP_EVENT = BASE + 11; /* WPS timeout detected */
code_review:  Can this be added after SCAN_FAILED_EVENT? 
target code: public static final int SUP_DISCONNECTION_EVENT = BASE + 2; /* Network connection completed */ public static final int NETWORK_CONNECTION_EVENT = BASE + 3; /* Network disconnection completed */ public static final int NETWORK_DISCONNECTION_EVENT = BASE + 4; /* Scan results are available */ public static final int SCAN_RESULTS_EVENT = BASE + 5; /* Scheduled scan results are available */ public static final int SCHED_SCAN_RESULTS_EVENT = BASE + 6; /* Supplicate state changed */ public static final int SUPPLICANT_STATE_CHANGE_EVENT = BASE + 6; /* Password failure and EAP authentication failure */ public static final int AUTHENTICATION_FAILURE_EVENT = BASE + 8; /* WPS success detected */ public static final int WPS_SUCCESS_EVENT = BASE + 9; /* WPS failure detected */ public static final int WPS_FAIL_EVENT = BASE + 10; /* WPS overlap detected */ public static final int WPS_OVERLAP_EVENT = BASE + 11; /* WPS timeout detected */
response: public static final int SUP_DISCONNECTION_EVENT = BASE + 2; /* Network connection completed */ public static final int NETWORK_CONNECTION_EVENT = BASE + 3; /* Network disconnection completed */ public static final int NETWORK_DISCONNECTION_EVENT = BASE + 4; /* Scan results are available */ public static final int SCAN_RESULTS_EVENT = BASE + 5; /* Scheduled scan results are available */ public static final int SCHED_SCAN_RESULTS_EVENT = BASE + 6; /* Supplicate state changed */ public static final int SUPPLICANT_STATE_CHANGE_EVENT = BASE + 7; /* Password failure and EAP authentication failure */ public static final int AUTHENTICATION_FAILURE_EVENT = BASE + 8; /* WPS success detected */ public static final int WPS_SUCCESS_EVENT = BASE + 9; /* WPS failure detected */ public static final int WPS_FAIL_EVENT = BASE + 10; /* WPS overlap detected */ public static final int WPS_OVERLAP_EVENT = BASE + 11; /* WPS timeout detected */

sample: 211
buggy_code:  public void OnPnoNetworkFound() { Log.d(TAG, "Pno scan result event"); <|startfocus|> mWifiMonitor.broadcastSchedScanResultEvent(mClientInterfaceName); <|endfocus|>
code_review:  Do we want to make it more specific so we know it is PNO scan results since there are other type of scheduled scans? 
target code: public void OnPnoNetworkFound() { Log.d(TAG, "Pno scan result event"); mWifiMonitor.broadcastPnoScanResultEvent(mClientInterfaceName);
response: public void onPnoNetworkFound() { Log.d(TAG, "Pno scan result event"); mWifiMonitor.broadcastPnoScanResultEvent(mClientInterfaceName); }

sample: 212
buggy_code:  android.provider.Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL)); if (!isLteOnCdma || missingDataServiceUrl) { prefSet.removePreference(mLteDataServicePref); } else { android.util.Log.d(LOG_TAG, "keep ltePref"); } // Hide enhanced 4G LTE mode settings when either it is not supported by platform or // 'KEY_HIDE_ENHANCED_4G_LTE_BOOL' is true. if (!(ImsManager.isVolteEnabledByPlatform(getActivity()) && ImsManager.isVolteProvisionedOnDevice(getActivity())) <|startfocus|> || carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { <|endfocus|> Preference pref = prefSet.findPreference(BUTTON_4G_LTE_KEY); if (pref != null) { prefSet.removePreference(pref); } } ActionBar actionBar = getActivity().getActionBar(); if (actionBar != null) { // android.R.id.home will be triggered in onOptionsItemSelected() actionBar.setDisplayHomeAsUpEnabled(true); } // Enable link to CMAS app settings depending on the value in config.xml.
code_review:  This whole comment feels unnecessary to me since it's just stating what the code does (and the code is pretty readable). 
target code: android.provider.Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL)); if (!isLteOnCdma || missingDataServiceUrl) { prefSet.removePreference(mLteDataServicePref); } else { android.util.Log.d(LOG_TAG, "keep ltePref"); } // Hide enhanced 4G LTE mode settings when either it is not supported by platform or // 'KEY_HIDE_ENHANCED_4G_LTE_BOOL' is true. if (!(ImsManager.isVolteEnabledByPlatform(getActivity()) && ImsManager.isVolteProvisionedOnDevice(getActivity())) || carrierConfig.getBoolean( CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { Preference pref = prefSet.findPreference(BUTTON_4G_LTE_KEY); if (pref != null) { prefSet.removePreference(pref); } } ActionBar actionBar = getActivity().getActionBar(); if (actionBar != null) { // android.R.id.home will be triggered in onOptionsItemSelected() actionBar.setDisplayHomeAsUpEnabled(true); } // Enable link to CMAS app settings depending on the value in config.xml.
response: android.provider.Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL)); if (!isLteOnCdma || missingDataServiceUrl) { prefSet.removePreference(mLteDataServicePref); } else { android.util.Log.d(LOG_TAG, "keep ltePref"); } if (!(ImsManager.isVolteEnabledByPlatform(getActivity()) && ImsManager.isVolteProvisionedOnDevice(getActivity())) || carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { Preference pref = prefSet.findPreference(BUTTON_4G_LTE_KEY); if (pref != null) { prefSet.removePreference(pref); } } ActionBar actionBar = getActivity().getActionBar(); if (actionBar != null) { actionBar.setDisplayHomeAsUpEnabled(true); } // Enable link to CMAS app settings depending on the value in config.xml.

sample: 213
buggy_code:  if (!isLteOnCdma || missingDataServiceUrl) { prefSet.removePreference(mLteDataServicePref); } else { android.util.Log.d(LOG_TAG, "keep ltePref"); } // Hide enhanced 4G LTE mode settings when either it is not supported by platform or // 'KEY_HIDE_ENHANCED_4G_LTE_BOOL' is true. if (!(ImsManager.isVolteEnabledByPlatform(getActivity()) && ImsManager.isVolteProvisionedOnDevice(getActivity())) <|startfocus|> || carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { <|endfocus|> Preference pref = prefSet.findPreference(BUTTON_4G_LTE_KEY); if (pref != null) { prefSet.removePreference(pref); } } ActionBar actionBar = getActivity().getActionBar(); if (actionBar != null) { // android.R.id.home will be triggered in onOptionsItemSelected() actionBar.setDisplayHomeAsUpEnabled(true); } // Enable link to CMAS app settings depending on the value in config.xml. final boolean isCellBroadcastAppLinkEnabled = getActivity().getResources().getBoolean(
code_review:  please fix indentation 
target code: if (!isLteOnCdma || missingDataServiceUrl) { prefSet.removePreference(mLteDataServicePref); } else { android.util.Log.d(LOG_TAG, "keep ltePref"); } // Hide enhanced 4G LTE mode settings when either it is not supported by platform or // 'KEY_HIDE_ENHANCED_4G_LTE_BOOL' is true. if (!(ImsManager.isVolteEnabledByPlatform(getActivity()) && ImsManager.isVolteProvisionedOnDevice(getActivity())) || carrierConfig.getBoolean( CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { Preference pref = prefSet.findPreference(BUTTON_4G_LTE_KEY); if (pref != null) { prefSet.removePreference(pref); } } ActionBar actionBar = getActivity().getActionBar(); if (actionBar != null) { // android.R.id.home will be triggered in onOptionsItemSelected() actionBar.setDisplayHomeAsUpEnabled(true); } // Enable link to CMAS app settings depending on the value in config.xml. final boolean isCellBroadcastAppLinkEnabled = getActivity().getResources().getBoolean(
response: if (!isLteOnCdma || missingDataServiceUrl) { prefSet.removePreference(mLteDataServicePref); } else { android.util.Log.d(LOG_TAG, "keep ltePref"); } // Hide enhanced 4G LTE mode settings when either it is not supported by platform or // 'KEY_HIDE_ENHANCED_4G_LTE_BOOL' is true. if (!(ImsManager.isVolteEnabledByPlatform(getActivity()) && ImsManager.isVolteProvisionedOnDevice(getActivity())) || carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { Preference pref = prefSet.findPreference(BUTTON_4G_LTE_KEY); if (pref != null) { prefSet.removePreference(pref); } } ActionBar actionBar = getActivity().getActionBar(); if (actionBar != null) { // android.R.id.home will be triggered in onOptionsItemSelected() actionBar.setDisplayHomeAsUpEnabled(true); } // Enable link to CMAS app settings depending on the value in config.xml. final boolean isCellBroadcastAppLinkEnabled = getActivity().getResources().getBoolean(R.bool.config_cellBroadcastAppLinks);

sample: 214
buggy_code:  assertFalse(nc.hasCapability(NET_CAPABILITY_INTERNET)); } @Test public void testNetworkCapabilitiesForTypeBluetooth() { verifyUnrestrictedNetworkCapabilities( ConnectivityManager.TYPE_BLUETOOTH, TRANSPORT_BLUETOOTH); } @Test public void testNetworkCapabilitiesForTypeEthernet() { verifyUnrestrictedNetworkCapabilities( ConnectivityManager.TYPE_ETHERNET, TRANSPORT_ETHERNET); } @Test public void testNoDoubleCallbackRegistration() throws Exception { ConnectivityManager manager = new ConnectivityManager(mCtx, mService); <|startfocus|> //NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build(); NetworkRequest request = makeRequest(1234); <|endfocus|> NetworkCallback callback = new ConnectivityManager.NetworkCallback(); ApplicationInfo info = new ApplicationInfo(); info.targetSdkVersion = VERSION_CODES.N_MR1 + 1; when(mCtx.getApplicationInfo()).thenReturn(info); when(mService.requestNetwork(any(), any(), anyInt(), any(), anyInt())).thenReturn(request); Handler handler = new Handler(Looper.getMainLooper()); manager.requestNetwork(request, callback, handler); // Callback is already registered, reregistration should fail. Class<IllegalArgumentException> wantException = IllegalArgumentException.class;
code_review:  did you intend to leave this comment here? 
target code: assertFalse(nc.hasCapability(NET_CAPABILITY_INTERNET)); } @Test public void testNetworkCapabilitiesForTypeBluetooth() { verifyUnrestrictedNetworkCapabilities( ConnectivityManager.TYPE_BLUETOOTH, TRANSPORT_BLUETOOTH); } @Test public void testNetworkCapabilitiesForTypeEthernet() { verifyUnrestrictedNetworkCapabilities( ConnectivityManager.TYPE_ETHERNET, TRANSPORT_ETHERNET); } @Test public void testNoDoubleCallbackRegistration() throws Exception { ConnectivityManager manager = new ConnectivityManager(mCtx, mService); NetworkRequest request = makeRequest(1); NetworkCallback callback = new ConnectivityManager.NetworkCallback(); ApplicationInfo info = new ApplicationInfo(); info.targetSdkVersion = VERSION_CODES.N_MR1 + 1; when(mCtx.getApplicationInfo()).thenReturn(info); when(mService.requestNetwork(any(), any(), anyInt(), any(), anyInt())).thenReturn(request); Handler handler = new Handler(Looper.getMainLooper()); manager.requestNetwork(request, callback, handler); // Callback is already registered, reregistration should fail. Class<IllegalArgumentException> wantException = IllegalArgumentException.class;
response: if (obj == null) return false; if (getClass() != obj.getClass()) return false; Transition other = (Transition) obj; return Objects.equals(from, other.from) && Objects.equals(event, other.event) && Objects.equals(to, other.to); } @Override public String toString() { return "Transition " + from + " --(" + event + ")--> " + to; } private final Set<Transition> transitions = new LinkedHashSet<>(); private final Map<ActivationState, Map<EventType, Transition>> transitionMap = new HashMap<>(); private final ActivationState inactiveState; protected ActivationLifeCycle(ActivationState inactiveState) { Preconditions.checkArgument(inactiveState != null, "Inactive state cannot be null"); this.inactiveState = inactiveState; } /** * Returns the state in the life cycle that is defined as the next state * from the given current state in response to the given event. *

sample: 215
buggy_code:  Handler handler = new Handler(Looper.getMainLooper()); manager.requestNetwork(request, callback, handler); // Callback is already registered, reregistration should fail. Class<IllegalArgumentException> wantException = IllegalArgumentException.class; expectThrowable(() -> manager.requestNetwork(request, callback), wantException); manager.unregisterNetworkCallback(callback); <|startfocus|> // Service release request and sends back notification Message releaseMsg = makeMessage(request, ConnectivityManager.CALLBACK_RELEASED); handler.sendMessage(releaseMsg); Thread.sleep(1000); // replace by waitForIdle() // Unregistering the callback should make it registrable again. <|endfocus|> manager.requestNetwork(request, callback); } static Message makeMessage(NetworkRequest req, int messageType) { Bundle bundle = new Bundle(); bundle.putParcelable(NetworkRequest.class.getSimpleName(), req); Message msg = Message.obtain(); msg.what = messageType; msg.setData(bundle); return msg; } static NetworkRequest makeRequest(int requestId) { NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build(); return new NetworkRequest(request.networkCapabilities, ConnectivityManager.TYPE_NONE, requestId, NetworkRequest.Type.NONE);
code_review:  under what circumstances can sleep be replaced by waitForIdle()? Consider documenting the preconditions. 
target code: Handler handler = new Handler(Looper.getMainLooper()); manager.requestNetwork(request, callback, handler); // Callback is already registered, reregistration should fail. Class<IllegalArgumentException> wantException = IllegalArgumentException.class; expectThrowable(() -> manager.requestNetwork(request, callback), wantException); manager.unregisterNetworkCallback(callback); // unregistering the callback should make it registrable again. manager.requestNetwork(request, callback); } static Message makeMessage(NetworkRequest req, int messageType) { Bundle bundle = new Bundle(); bundle.putParcelable(NetworkRequest.class.getSimpleName(), req); Message msg = Message.obtain(); msg.what = messageType; msg.setData(bundle); return msg; } static NetworkRequest makeRequest(int requestId) { NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build(); return new NetworkRequest(request.networkCapabilities, ConnectivityManager.TYPE_NONE, requestId, NetworkRequest.Type.NONE);
response: Handler handler = new Handler(Looper.getMainLooper()); manager.requestNetwork(request, callback, handler); // Callback is already registered, reregistration should fail. Class<IllegalArgumentException> wantException = IllegalArgumentException.class; expectThrowable(() -> manager.requestNetwork(request, callback), wantException); manager.unregisterNetworkCallback(callback); // Service release request and sends back notification Message releaseMsg = makeMessage(request, ConnectivityManager.CALLBACK_RELEASED); handler.sendMessage(releaseMsg); Thread.sleep(1000); // replace by waitForIdle() // Unregistering the callback should make it registrable again. manager.requestNetwork(request, callback); static Message makeMessage(NetworkRequest req, int messageType) { Bundle bundle = new Bundle(); bundle.putParcelable(NetworkRequest.class.getSimpleName(), req); Message msg = Message.obtain(); msg.what = messageType; msg.setData(bundle); return msg; } static NetworkRequest makeRequest(int requestId) { NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build(); return new NetworkRequest(request.networkCapabilities, ConnectivityManager.TYPE_NONE, requestId, NetworkRequest.Type.NONE); }

sample: 216
buggy_code:  if (maxBlacklistSize <= 0) { Log.wtf(TAG, "Invalid max BSSID blacklist size: " + maxBlacklistSize); return; } ArrayList<String> blacklistedBssids = new ArrayList<String>(buildBssidBlacklist()); int blacklistSize = blacklistedBssids.size(); if (blacklistSize > maxBlacklistSize) { Log.wtf(TAG, "Attempt to write " + blacklistSize + " blacklisted BSSIDs, max size is " + maxBlacklistSize); blacklistedBssids = new ArrayList<String>(blacklistedBssids.subList(0, <|startfocus|> maxBlacklistSize)); <|endfocus|> localLog("Trim down BSSID blacklist size from " + blacklistSize + " to " + blacklistedBssids.size()); } if (!mConnectivityHelper.setFirmwareRoamingConfiguration(blacklistedBssids, new ArrayList<String>())) { // TODO(b/36488259): SSID whitelist management. localLog("Failed to set firmware roaming configuration."); }
code_review:  indent 8 
target code: if (maxBlacklistSize <= 0) { Log.wtf(TAG, "Invalid max BSSID blacklist size: " + maxBlacklistSize); return; } ArrayList<String> blacklistedBssids = new ArrayList<String>(buildBssidBlacklist()); int blacklistSize = blacklistedBssids.size(); if (blacklistSize > maxBlacklistSize) { Log.wtf(TAG, "Attempt to write " + blacklistSize + " blacklisted BSSIDs, max size is " + maxBlacklistSize); blacklistedBssids = new ArrayList<String>(blacklistedBssids.subList(0, maxBlacklistSize)); localLog("Trim down BSSID blacklist size from " + blacklistSize + " to " + blacklistedBssids.size()); } if (!mConnectivityHelper.setFirmwareRoamingConfiguration(blacklistedBssids, new ArrayList<String>())) { // TODO(b/36488259): SSID whitelist management. localLog("Failed to set firmware roaming configuration."); }
response: if (maxBlacklistSize <= 0) { Log.wtf(TAG, "Invalid max BSSID blacklist size: " + maxBlacklistSize); return; } ArrayList<String> blacklistedBssids = new ArrayList<String>(buildBssidBlacklist()); int blacklistSize = blacklistedBssids.size(); if (blacklistSize > maxBlacklistSize) { Log.wtf(TAG, "Attempt to write " + blacklistSize + " blacklisted BSSIDs, max size is " + maxBlacklistSize); blacklistedBssids = new ArrayList<String>(blacklistedBssids.subList(0, maxBlacklistSize)); } localLog("Trim down BSSID blacklist size from " + blacklistSize + " to " + blacklistedBssids.size()); if (!mConnectivityHelper.setFirmwareRoamingConfiguration(blacklistedBssids, new ArrayList<String>())) { localLog("Failed to set firmware roaming configuration."); }

sample: 217
buggy_code:  private void start() { <|startfocus|> mConnectivityHelper.getFirmwareRoamingInfo(); <|endfocus|> startConnectivityScan(SCAN_IMMEDIATELY);
code_review:  if we crash, or just don't clear the roaming config, will it persist? Do we need to clear it out when we call start? 
target code: private void start() { mConnectivityHelper.getFirmwareRoamingInfo(); clearBssidBlacklist(); startConnectivityScan(SCAN_IMMEDIATELY);
response: private void start() { mConnectivityHelper.clearFirmwareRoamingInfo(); mConnectivityHelper.getFirmwareRoamingInfo(); startConnectivityScan(SCAN_IMMEDIATELY); }

sample: 218
buggy_code:  public void setWifiEnabled(boolean enable) { localLog("Set WiFi " + (enable ? "enabled" : "disabled")); mWifiEnabled = enable; <|startfocus|> if (!mWifiEnabled) { stop(); } else if (mWifiConnectivityManagerEnabled) { start(); } <|endfocus|>
code_review:  it is confusing to have this check and the one below reversed... what about a little helper method that looks something like (the name needs work): private void checkRunningState() { if (mWifiEnabled && mWifiConnectivityManagerEnabled) { localLog("starting up WifiConnectivityManager"); start(); return; } localLog("stopping WifiConnectivitymanager"); stop(); } 
target code: public void setWifiEnabled(boolean enable) { localLog("Set WiFi " + (enable ? "enabled" : "disabled")); mWifiEnabled = enable;
response: public void setWifiEnabled(boolean enable) { localLog("Set WiFi " + (enable ? "enabled" : "disabled")); mWifiEnabled = enable; checkRunningState(); } private void checkRunningState() { if (mWifiEnabled && mWifiConnectivityManagerEnabled) { localLog("starting up WifiConnectivityManager"); start(); } else { localLog("stopping WifiConnectivitymanager"); stop(); } }

sample: 219
buggy_code:  private void localLog(String log) { <|startfocus|> if (mLocalLog != null) { mLocalLog.log(log); } <|endfocus|>
code_review:  This check can also be removed - same reason 
target code: private void localLog(String log) { mLocalLog.log(log);
response: private void localLog(String log) { if (mLocalLog != null) { mLocalLog.log(log); } }

sample: 220
buggy_code:  sbuf.append(" Same network the current one bonus: ") .append(mSameNetworkAward).append(","); // When firmware roaming is supported, equivalent BSSIDs (the ones under the // same network as the currently connected one) get the same BSSID award. if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") <|startfocus|> .append(mSameBssidAward).append(","); <|endfocus|> } } // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) .append(","); } // Security award. if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } // No internet penalty.
code_review:  indent 8 
target code: sbuf.append(" Same network the current one bonus: ") .append(mSameNetworkAward).append(","); // When firmware roaming is supported, equivalent BSSIDs (the ones under the // same network as the currently connected one) get the same BSSID award. if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") .append(mSameBssidAward).append(","); } } // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) .append(","); } // Security award. if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } // No internet penalty.
response: sbuf.append(" Same network the current one bonus: ").append(mSameNetworkAward).append(","); if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ").append(mSameBssidAward).append(","); } if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward).append(","); } if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); }

sample: 221
buggy_code:  if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") .append(mSameBssidAward).append(","); } } // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) <|startfocus|> .append(","); <|endfocus|> } // Security award. if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } // No internet penalty. if (network.numNoInternetAccessReports > 0 && !network.validatedInternetAccess) { score -= mNoInternetPenalty; sbuf.append(" No internet penalty: -").append(mNoInternetPenalty).append(","); } sbuf.append(" ## Total score: ").append(score).append("\n"); return score;
code_review:  indent 8 
target code: if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") .append(mSameBssidAward).append(","); } } // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) .append(","); } // Security award. if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } // No internet penalty. if (network.numNoInternetAccessReports > 0 && !network.validatedInternetAccess) { score -= mNoInternetPenalty; sbuf.append(" No internet penalty: -").append(mNoInternetPenalty).append(","); } sbuf.append(" ## Total score: ").append(score).append("\n"); return score;
response: if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ").append(mSameBssidAward).append(","); } if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward).append(","); } if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } if (network.numNoInternetAccessReports > 0 && !network.validatedInternetAccess) { score -= mNoInternetPenalty; sbuf.append(" No internet penalty: -").append(mNoInternetPenalty).append(","); } sbuf.append(" ## Total score: ").append(score).append("\n"); return score;

sample: 222
buggy_code:  if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") .append(mSameBssidAward).append(","); } } // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) <|startfocus|> .append(","); <|endfocus|> } // Security award. if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } // No internet penalty. if (network.numNoInternetAccessReports > 0 && !network.validatedInternetAccess) { score -= mNoInternetPenalty; sbuf.append(" No internet penalty: -").append(mNoInternetPenalty).append(","); } sbuf.append(" ## Total score: ").append(score).append("\n"); return score;
code_review:  does this fit on the same line? 
target code: if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ") .append(mSameBssidAward).append(","); } } // Same BSSID award. if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward) .append(","); } // Security award. if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } // No internet penalty. if (network.numNoInternetAccessReports > 0 && !network.validatedInternetAccess) { score -= mNoInternetPenalty; sbuf.append(" No internet penalty: -").append(mNoInternetPenalty).append(","); } sbuf.append(" ## Total score: ").append(score).append("\n"); return score;
response: if (mConnectivityHelper.isFirmwareRoamingSupported() && currentBssid != null && !currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Firmware roaming equivalent BSSID bonus: ").append(mSameBssidAward).append(","); } if (currentBssid != null && currentBssid.equals(scanResult.BSSID)) { score += mSameBssidAward; sbuf.append(" Same BSSID as the current one bonus: ").append(mSameBssidAward).append(","); } if (!WifiConfigurationUtil.isConfigForOpenNetwork(network)) { score += mSecurityAward; sbuf.append(" Secure network bonus: ").append(mSecurityAward).append(","); } if (network.numNoInternetAccessReports > 0 && !network.validatedInternetAccess) { score -= mNoInternetPenalty; sbuf.append(" No internet penalty: -").append(mNoInternetPenalty).append(","); } sbuf.append(" ## Total score: ").append(score).append("\n"); return score;

sample: 223
buggy_code:  public void testCTSSyscallBlocked() { if (CpuFeatures.isArm64Cpu()) { <|startfocus|> testAllowed(98); testBlocked(99); testBlocked(100); <|endfocus|> } else if (CpuFeatures.isArmCpu()) { testBlocked(7); testAllowed(8); testBlocked(9); } else if (CpuFeatures.isX86_64Cpu()) { testBlocked(31); testAllowed(32); testBlocked(33); } else if (CpuFeatures.isX86Cpu()) { testBlocked(7); testAllowed(8); testBlocked(9); } else if (CpuFeatures.isMips64Cpu()) { testBlocked(5030); testAllowed(5031); testBlocked(5032); } else if (CpuFeatures.isMipsCpu()) { testBlocked(4032); testAllowed(4033); testBlocked(4034); } else { fail("Unsupported OS"); }
code_review:  Do we have #defines available for these random numbers anywhere? 
target code: public void testCTSSyscallBlocked() { if (CpuFeatures.isArm64Cpu()) { testBlocked(217); // __NR_add_key testBlocked(219); // __NR_keyctl testAllowed(56); // __NR_openat } else if (CpuFeatures.isArmCpu()) { testBlocked(7); testAllowed(8); testBlocked(9); } else if (CpuFeatures.isX86_64Cpu()) { testBlocked(31); testAllowed(32); testBlocked(33); } else if (CpuFeatures.isX86Cpu()) { testBlocked(7); testAllowed(8); testBlocked(9); } else if (CpuFeatures.isMips64Cpu()) { testBlocked(5030); testAllowed(5031); testBlocked(5032); } else if (CpuFeatures.isMipsCpu()) { testBlocked(4032); testAllowed(4033); testBlocked(4034); } else { fail("Unsupported OS"); }
response: public void testCTSSyscallBlocked() { if (CpuFeatures.isArm64Cpu()) { testAllowed(98); testBlocked(99); testBlocked(100); } else if (CpuFeatures.isArmCpu()) { testBlocked(7); testAllowed(8); testBlocked(9); } else if (CpuFeatures.isX86_64Cpu()) { testBlocked(31); testAllowed(32); testBlocked(33); } else if (CpuFeatures.isX86Cpu()) { testBlocked(7); testAllowed(8); testBlocked(9); } else if (CpuFeatures.isMips64Cpu()) { testBlocked(5030); testAllowed(5031); testBlocked(5032); } else if (CpuFeatures.isMipsCpu()) { testBlocked(4032); testAllowed(4033); testBlocked(4034); } else { fail("Unsupported OS"); } }

sample: 224
buggy_code: <|startfocus|> * Copyright (C) 2014 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.security.cts; import android.test.AndroidTestCase; import com.android.compatibility.common.util.CpuFeatures; import junit.framework.TestCase; /** * Verify that the seccomp policy is enforced */ public class SeccompTest extends AndroidTestCase { static { System.loadLibrary("ctssecurity_jni"); } public void testCTSSyscallBlocked() { if (CpuFeatures.isArm64Cpu()) {
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.security.cts; import android.test.AndroidTestCase; import com.android.compatibility.common.util.CpuFeatures; import junit.framework.TestCase; /** * Verify that the seccomp policy is enforced */ public class SeccompTest extends AndroidTestCase { static { System.loadLibrary("ctssecurity_jni"); } public void testCTSSyscallBlocked() { if (CpuFeatures.isArm64Cpu()) {
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.security.cts; import android.test.AndroidTestCase; import com.android.compatibility.common.util.CpuFeatures; import junit.framework.TestCase; /** * Verify that the seccomp policy is enforced */ public class SeccompTest extends AndroidTestCase { static { System.loadLibrary("ctssecurity_jni"); } public void testCTSSyscallBlocked() { if (CpuFeatures.isArm64Cpu()) { // Test code here } } }

sample: 225
buggy_code:  mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED); // Tear down all metered apns cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN); } else { teardownRestrictedMeteredConnections(); setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED); } } } } private void onSimNotReady() { if (DBG) log("onSimNotReady"); <|startfocus|> // Clear auto attach as modem is expected to do a new attach once SIM is ready mAutoAttachOnCreation.set(false); <|endfocus|> cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY); mAllApnSettings = null; mAutoAttachOnCreationConfig = false; } private void onSetDependencyMet(String apnType, boolean met) { // don't allow users to tweak hipri to work around default dependency not met if (PhoneConstants.APN_TYPE_HIPRI.equals(apnType)) return; ApnContext apnContext = mApnContexts.get(apnType); if (apnContext == null) { loge("onSetDependencyMet: ApnContext not found in onSetDependencyMet(" + apnType + ", " + met + ")");
code_review:  I'd put it by the other clearing of mAutoAttachOnCreation state (4 lines down). 
target code: mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED); // Tear down all metered apns cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN); } else { teardownRestrictedMeteredConnections(); setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED); } } } } private void onSimNotReady() { if (DBG) log("onSimNotReady"); cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY); mAllApnSettings = null; mAutoAttachOnCreationConfig = false; } private void onSetDependencyMet(String apnType, boolean met) { // don't allow users to tweak hipri to work around default dependency not met if (PhoneConstants.APN_TYPE_HIPRI.equals(apnType)) return; ApnContext apnContext = mApnContexts.get(apnType); if (apnContext == null) { loge("onSetDependencyMet: ApnContext not found in onSetDependencyMet(" + apnType + ", " + met + ")");
response: mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED); // Tear down all metered apns cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN); } else { teardownRestrictedMeteredConnections(); setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED); } } private void onSimNotReady() { if (DBG) log("onSimNotReady"); // Clear auto attach as modem is expected to do a new attach once SIM is ready mAutoAttachOnCreation.set(false); cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY); mAllApnSettings = null; mAutoAttachOnCreationConfig = false; } private void onSetDependencyMet(String apnType, boolean met) { // don't allow users to tweak hipri to work around default dependency not met if (PhoneConstants.APN_TYPE_HIPRI.equals(apnType)) return; ApnContext apnContext = mApnContexts.get(apnType); if (apnContext == null) { loge("onSetDependencyMet: ApnContext not found in onSetDependencyMet(" + apnType + ", " + met + ")");

sample: 226
buggy_code:  public void onChange(boolean selfChange) { <|startfocus|> mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(), <|endfocus|> Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1);
code_review:  Please update the comment to reflect this new 'forceReconnect' parameter. 
target code: public void onChange(boolean selfChange) { mUserWantsSuspendOpt.set(mFacade.getIntegerSetting(mContext, Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1);
response: public void onChange(boolean selfChange) { mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1); }

sample: 227
buggy_code:  mSapProxy = getSapProxy(); } /** * Notify SapServer that this class is ready for shutdown. */ void notifyShutdown() { if (DEBUG) Log.i(TAG, "notifyShutdown()"); // If we are already shutdown, don't bother sending a notification. synchronized (this) { if (mSapProxy != null) sendShutdownMessage(); } } /** <|startfocus|> * This will terminate the SapRilReceiver thread, by closing the RIL-BT in-/output * streams. <|endfocus|> */ public void shutdown() { if (DEBUG) Log.i(TAG, "shutdown()"); /* On Android you need to close the IOstreams using Socket.shutdown* * The IOstream close must not be used, as it some how decouples the * stream from the socket, and when the socket is closed, the pending * reads never return nor throw and exception. * Hence here we use the shutdown method: */ synchronized (this) { if (mSapProxy != null) { mSapProxy = null; } } } 
code_review:  cleanup the comments here and below? 
target code: mSapProxy = getSapProxy(); } /** * Notify SapServer that this class is ready for shutdown. */ void notifyShutdown() { if (DEBUG) Log.i(TAG, "notifyShutdown()"); // If we are already shutdown, don't bother sending a notification. synchronized (this) { if (mSapProxy != null) sendShutdownMessage(); } } /** * This will reset SapProxy. */ public void shutdown() { if (DEBUG) Log.i(TAG, "shutdown()"); /* On Android you need to close the IOstreams using Socket.shutdown* * The IOstream close must not be used, as it some how decouples the * stream from the socket, and when the socket is closed, the pending * reads never return nor throw and exception. * Hence here we use the shutdown method: */ synchronized (this) { if (mSapProxy != null) { mSapProxy = null; } } }
response: mSapProxy = getSapProxy(); } void notifyShutdown() { if (DEBUG) Log.i(TAG, "notifyShutdown()"); synchronized (this) { if (mSapProxy != null) sendShutdownMessage(); } } public void shutdown() { if (DEBUG) Log.i(TAG, "shutdown()"); synchronized (this) { if (mSapProxy != null) { mSapProxy = null; } } }

sample: 228
buggy_code:  return null; } WifiConfiguration[] configs = new WifiConfiguration[ssids.length]; for (int index = 0; index < ssids.length; index++) { int networkId = index; for (int k = 0; k < index; k++) { // If two networks have the same SSID and security type, assign them // the same network Id. if (ssids[index].equals(ssids[k]) && (securities[index] == securities[k])) { networkId = k; } } <|startfocus|> configs[index] = generateWifiConfig(networkId, 0, ssids[index], false, true, null, null, securities[index]); <|endfocus|> } return configs;
code_review:  given this implementation, you should be able to break out once you have a match. will this leave holes in the networkId numbers? i am guessing that doesn't matter. just mentioning in case it does. 
target code: return null; } WifiConfiguration[] configs = new WifiConfiguration[ssids.length]; for (int index = 0; index < ssids.length; index++) { int networkId = index; for (int k = 0; k < index; k++) { // If two networks have the same SSID and security type, assign them // the same network Id. if (ssids[index].equals(ssids[k]) && (securities[index] == securities[k])) { networkId = k; } } configs[index] = generateWifiConfig(id.intValue(), 0, ssids[index], false, true, null, null, securities[index]); } return configs;
response: return null; WifiConfiguration[] configs = new WifiConfiguration[ssids.length]; for (int index = 0; index < ssids.length; index++) { int networkId = index; for (int k = 0; k < index; k++) { if (ssids[index].equals(ssids[k]) && (securities[index] == securities[k])) { networkId = k; break; } } configs[index] = generateWifiConfig(networkId, 0, ssids[index], false, true, null, null, securities[index]); } return configs;

sample: 229
buggy_code:  for (int index = 0; index < ssids.length; index++) { int networkId = index; for (int k = 0; k < index; k++) { // If two networks have the same SSID and security type, assign them // the same network Id. if (ssids[index].equals(ssids[k]) && (securities[index] == securities[k])) { networkId = k; } } <|startfocus|> configs[index] = generateWifiConfig(networkId, 0, ssids[index], false, true, null, null, securities[index]); <|endfocus|> } return configs;
code_review:  this is pretty complicated to read - consider thinking about an alternate impl to make this a bit easier to read. 
target code: for (int index = 0; index < ssids.length; index++) { int networkId = index; for (int k = 0; k < index; k++) { // If two networks have the same SSID and security type, assign them // the same network Id. if (ssids[index].equals(ssids[k]) && (securities[index] == securities[k])) { networkId = k; } } configs[index] = generateWifiConfig(id.intValue(), 0, ssids[index], false, true, null, null, securities[index]); } return configs;
response: private QualityOfService qos = QualityOfService.LOW; LinearLayout serverLayout; LinearLayout clientLayout; TextView resourceText; TextView actionLog; TextView resultLog; ToggleButton qosToggle; Button registerButton; Button getButton; Button putButton; Button largeButton; Button discoverIPButton; Button discoverBTButton; Button discoverLEButton; Button discoverTCPButton; Button discoverNFCButton; private String mLargeData; private boolean mState; private long mStartTime; private long mEndTime; private final double MILLI_PER_SEC = 1000.0; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mActivity = getActivity(); mContext = mActivity.getBaseContext(); } View.OnClickListener getButtonListener() { return new View.OnClickListener() { @Override public void onClick(View view) { if (foundResource != null) { mStartTime = System.currentTimeMillis(); sendGetToFoundResource(Common.STATE_GET); } else { // handle case when foundResource is null } } }; } colorSuggestor = new PrimaryDarkColorSuggestor(primaryColor); myColorPicker.setRecentColors(colorSuggestor.suggestColor()); } else if (attributeName.equals(ACCENT_MATERIAL)) { ResourceResolver resourceResolver = model.getSelectedStyle().getConfiguration().getResourceResolver(); ResourceValue rv = model.getSelectedStyle().getItemResourceValue(PRIMARY_MATERIAL); Color primaryColor = ResourceHelper.resolveColor(resourceResolver, rv); colorSuggestor = new AccentColorSuggestor(primaryColor); myColorPicker.setRecentColors(colorSuggestor.suggestColor()); } } if (color != null) { myContentPanel.setSelectedIndex(2); doSelection = false; } myValidator = ResourceNameValidator.create(false, AppResourceRepository.getAppResources(module, true), ResourceType.COLOR); if (doSelection && value.startsWith("@")) { value = StringUtil.replace(value, "+", ""); int index = value.indexOf('/'); if (index != -1) { ResourcePanel panel; String type; String name = value.substring(index + 1); if (value.startsWith(ANDROID)) { // handle case when value starts with ANDROID } } } String exceptionSignature = getExpectedExceptionSignature(fromNative); ReplyPacket replyPacket = debuggeeWrapper.vmMirror.setException(exceptionSignature, isCatch, isUncatch); int requestID = replyPacket.getNextValueAs

sample: 230
buggy_code:  public class MacroSubstitutionNamingStrategy implements TestCaseNamingStrategy { private static final String MACRO_PATTERN = "\\{[^\\}]{0,50}\\}"; // Pattern that keeps delimiters in split result private static final Pattern MACRO_SPLIT_PATTERN = Pattern.compile(String.format("(?=%s)|(?<=%s)", MACRO_PATTERN, MACRO_PATTERN)); private static final String MACRO_START = "{"; private static final String MACRO_END = "}"; <|startfocus|> // Android-changed: CTS and AJUR rely on specific format to test names, changing them // will prevent CTS and AJUR from working properly; see b/36541809 <|endfocus|> static final String DEFAULT_TEMPLATE = "{method}[{index}]"; private TestMethod method; public MacroSubstitutionNamingStrategy(TestMethod testMethod) { this.method = testMethod; } @Override public String getTestCaseName(int parametersIndex, Object parameters) { TestCaseName testCaseName = method.getAnnotation(TestCaseName.class); String template = getTemplate(testCaseName); String builtName = buildNameByTemplate(template, parametersIndex, parameters); 
code_review:  AndroidJUnitRunner 
target code: public class MacroSubstitutionNamingStrategy implements TestCaseNamingStrategy { private static final String MACRO_PATTERN = "\\{[^\\}]{0,50}\\}"; // Pattern that keeps delimiters in split result private static final Pattern MACRO_SPLIT_PATTERN = Pattern.compile(String.format("(?=%s)|(?<=%s)", MACRO_PATTERN, MACRO_PATTERN)); private static final String MACRO_START = "{"; private static final String MACRO_END = "}"; // Android-changed: CTS and AndroidJUnitRunner rely on specific format to test names, changing // them will prevent CTS and AndroidJUnitRunner from working properly; see b/36541809 static final String DEFAULT_TEMPLATE = "{method}[{index}]"; private TestMethod method; public MacroSubstitutionNamingStrategy(TestMethod testMethod) { this.method = testMethod; } @Override public String getTestCaseName(int parametersIndex, Object parameters) { TestCaseName testCaseName = method.getAnnotation(TestCaseName.class); String template = getTemplate(testCaseName); String builtName = buildNameByTemplate(template, parametersIndex, parameters);
response: public class MacroSubstitutionNamingStrategy implements TestCaseNamingStrategy { private static final String MACRO_PATTERN = "\\{[^\\}]{0,50}\\}"; private static final Pattern MACRO_SPLIT_PATTERN = Pattern.compile(String.format("(?=%s)|(?<=%s)", MACRO_PATTERN, MACRO_PATTERN)); private static final String MACRO_START = "{"; private static final String MACRO_END = "}"; static final String DEFAULT_TEMPLATE = "{method}[{index}]"; private TestMethod method; public MacroSubstitutionNamingStrategy(TestMethod testMethod) { this.method = testMethod; } @Override public String getTestCaseName(int parametersIndex, Object parameters) { TestCaseName testCaseName = method.getAnnotation(TestCaseName.class); String template = getTemplate(testCaseName); String builtName = buildNameByTemplate(template, parametersIndex, parameters); return builtName; } private String getTemplate(TestCaseName testCaseName) { if (testCaseName != null) { return testCaseName.value(); } else { return DEFAULT_TEMPLATE; } } private String buildNameByTemplate(String template, int parametersIndex, Object parameters) { String[] parts = MACRO_SPLIT_PATTERN.split(template); StringBuilder builder = new StringBuilder(); for (String part : parts) { if (part.startsWith(MACRO_START) && part.endsWith(MACRO_END)) { String macro = part.substring(1, part.length() - 1); String value = getMacroValue(macro, parametersIndex, parameters); builder.append(value); } else { builder.append(part); } } return builder.toString(); } private String getMacroValue(String macro, int parametersIndex, Object parameters) { // Handle different macros here if (macro.equals("method")) { return method.getName(); } else if (macro.equals("index")) { return String.valueOf(parametersIndex); } else { return ""; } } }

sample: 231
buggy_code: import org.mockito.MockitoAnnotations; import org.mockito.stubbing.Answer; import java.net.InetAddress; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Random; /** * Unit tests for {@link com.android.server.wifi.WifiVendorHal}. */ public class WifiVendorHalTest { WifiVendorHal mWifiVendorHal; private WifiStatus mWifiStatusSuccess; private WifiStatus mWifiStatusFailure; WifiLog mWifiLog; @Mock private HalDeviceManager mHalDeviceManager; @Mock <|startfocus|> private Looper mLooper; <|endfocus|> @Mock private WifiVendorHal.HalDeviceManagerStatusListener mHalDeviceManagerStatusCallbacks; @Mock private IWifiApIface mIWifiApIface; @Mock private IWifiChip mIWifiChip; @Mock private IWifiStaIface mIWifiStaIface; @Mock private IWifiRttController mIWifiRttController; private IWifiStaIfaceEventCallback mIWifiStaIfaceEventCallback; private IWifiChipEventCallback mIWifiChipEventCallback; @Mock private WifiNative.VendorHalDeathEventHandler mVendorHalDeathHandler; /** * Identity function to supply a type to its argument, which is a lambda */
code_review:  Can you double-check the unit test results for this patch? When I pull in the current stack of patches, I see some error messages that look to be related to this change: 66) testRttTypeTranslation(com.android.server.wifi.WifiVendorHalTest) org.mockito.exceptions.base.MockitoException: Cannot mock/spy class android.os.Looper Mockito cannot mock/spy because : - final or anonymous class at com.android.server.wifi.WifiVendorHalTest.setUp(WifiVendorHalTest.java:122) 
target code: import org.mockito.MockitoAnnotations; import org.mockito.stubbing.Answer; import java.net.InetAddress; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Random; /** * Unit tests for {@link com.android.server.wifi.WifiVendorHal}. */ public class WifiVendorHalTest { WifiVendorHal mWifiVendorHal; private WifiStatus mWifiStatusSuccess; private WifiStatus mWifiStatusFailure; WifiLog mWifiLog; @Mock private HalDeviceManager mHalDeviceManager; @Mock private TestLooper mLooper; @Mock private WifiVendorHal.HalDeviceManagerStatusListener mHalDeviceManagerStatusCallbacks; @Mock private IWifiApIface mIWifiApIface; @Mock private IWifiChip mIWifiChip; @Mock private IWifiStaIface mIWifiStaIface; @Mock private IWifiRttController mIWifiRttController; private IWifiStaIfaceEventCallback mIWifiStaIfaceEventCallback; private IWifiChipEventCallback mIWifiChipEventCallback; @Mock private WifiNative.VendorHalDeathEventHandler mVendorHalDeathHandler; /** * Identity function to supply a type to its argument, which is a lambda */
response: import org.mockito.MockitoAnnotations; import org.mockito.stubbing.Answer; import java.net.InetAddress; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Random; /** * Unit tests for {@link com.android.server.wifi.WifiVendorHal}. */ public class WifiVendorHalTest { WifiVendorHal mWifiVendorHal; private WifiStatus mWifiStatusSuccess; private WifiStatus mWifiStatusFailure; WifiLog mWifiLog; @Mock private HalDeviceManager mHalDeviceManager; @Mock private Looper mLooper; @Mock private WifiVendorHal.HalDeviceManagerStatusListener mHalDeviceManagerStatusCallbacks; @Mock private IWifiApIface mIWifiApIface; @Mock private IWifiChip mIWifiChip; @Mock private IWifiStaIface mIWifiStaIface; @Mock private IWifiRttController mIWifiRttController; private IWifiStaIfaceEventCallback mIWifiStaIfaceEventCallback; private IWifiChipEventCallback mIWifiChipEventCallback; @Mock private WifiNative.VendorHalDeathEventHandler mVendorHalDeathHandler; /** * Identity function to supply a type to its argument, which is a lambda */ public void setUp() { MockitoAnnotations.initMocks(this); } }

sample: 232
buggy_code:  break; case CMD_DIAGS_CONNECT_TIMEOUT: mWifiDiagnostics.reportConnectionEvent( (Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED); break; default: loge("Error! unhandled message" + message); break; } return HANDLED; } } class InitialState extends State { private void cleanup() { // Tearing down the client interfaces below is going to stop our supplicant. mWifiMonitor.stopAllMonitoring(); mDeathRecipient.unlinkToDeath(); mWifiNative.tearDownInterfaces(); mWifiNative.stopHal(); } <|startfocus|> <|endfocus|> @Override public void enter() { mWifiStateTracker.updateState(WifiStateTracker.INVALID); cleanup(); } @Override public boolean processMessage(Message message) { logStateAndMessage(message, this); switch (message.what) { case CMD_START_SUPPLICANT: mClientInterface = mWifiNative.setupDriverForClientMode(); if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) { setWifiState(WifiManager.WIFI_STATE_UNKNOWN); cleanup(); break; } try {
code_review:  the wording here is a bit odd 
target code: break; case CMD_DIAGS_CONNECT_TIMEOUT: mWifiDiagnostics.reportConnectionEvent( (Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED); break; default: loge("Error! unhandled message" + message); break; } return HANDLED; } } class InitialState extends State { private void cleanup() { // Tearing down the client interfaces below is going to stop our supplicant. mWifiMonitor.stopAllMonitoring(); mDeathRecipient.unlinkToDeath(); mWifiNative.tearDownInterfaces(); mWifiNative.stopHal(); } @Override public void enter() { mWifiStateTracker.updateState(WifiStateTracker.INVALID); cleanup(); } @Override public boolean processMessage(Message message) { logStateAndMessage(message, this); switch (message.what) { case CMD_START_SUPPLICANT: mClientInterface = mWifiNative.setupDriverForClientMode(); if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) { setWifiState(WifiManager.WIFI_STATE_UNKNOWN); cleanup(); break; } try {
response: Buggy Code: ```java public Collection<SubscribeSection> getInheritedSubscribeSections(Branch.NameKey branch) { Collection<SubscribeSection> ret = new ArrayList<>(); for (ProjectState s : tree()) { ret.addAll(s.getConfig().getSubscribeSections(branch)); } return ret; } ``` Fixed Code: ```java public Collection<SubscribeSection> getInheritedSubscribeSections(Branch.NameKey branch) { Collection<SubscribeSection> ret = new ArrayList<>(); for (ProjectState s : tree()) { ret.addAll(s.getConfig().getSubscribeSections(branch)); } return ret; } ``` Buggy Code: ```java LOG.info("running query " + query); if (query.isEmpty()) { throw new IllegalStateException("Cannot plan empty query in line: " + testCase.getStartingLineNum()); } TQueryCtx queryCtx = TestUtils.createQueryContext(dbName, System.getProperty("user.name")); queryCtx.client_request.query_options = options; // Test single node plan, scan range locations, and column lineage. TExecRequest singleNodeExecRequest = testPlan(testCase, Section.PLAN, queryCtx, ignoreExplainHeader, errorLog, actualOutput); validateTableIds(singleNodeExecRequest); checkScanRangeLocations(testCase, singleNodeExecRequest, errorLog, actualOutput); checkColumnLineage(testCase, singleNodeExecRequest, errorLog, actualOutput); checkLimitCardinality(query, singleNodeExecRequest, errorLog); // Test distributed plan. testPlan(testCase, Section.DISTRIBUTEDPLAN, queryCtx, ignoreExplainHeader, errorLog, actualOutput); // test parallel plans testPlan(testCase, Section.PARALLELPLANS, queryCtx, ignoreExplainHeader, errorLog, actualOutput); } /** * Validate that all tables in the descriptor table of 'request' have a unique id and ``` Fixed Code: ```java LOG.info("running query " + query); if (query.isEmpty()) { throw new IllegalStateException("Cannot plan empty query in line: " + testCase.getStartingLineNum()); } TQueryCtx queryCtx = TestUtils.createQueryContext(dbName, System.getProperty("user.name")); queryCtx.client_request.query_options = options; // Test single node plan, scan range locations, and column lineage. TExecRequest singleNodeExecRequest = testPlan(testCase, Section.PLAN, queryCtx, ignoreExplain

sample: 233
buggy_code:  sendMessage(CMD_DISCONNECT); } break; case WifiManager.CONNECT_NETWORK: /** * The connect message can contain a network id passed as arg1 on message or * or a config passed as obj on message. * For a new network, a config is passed to create and connect. * For an existing network, a network id is passed */ netId = message.arg1; config = (WifiConfiguration) message.obj; <|startfocus|> mWifiConnectionStatistics.numWifiManagerJoinAttempt++; <|endfocus|> // New network addition. if (config != null) { result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid); if (!result.isSuccess()) { loge("CONNECT_NETWORK adding/updating config=" + config + " failed"); messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; } netId = result.getNetworkId(); } if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
code_review:  Add a bug to track the work? 
target code: sendMessage(CMD_DISCONNECT); } break; case WifiManager.CONNECT_NETWORK: /** * The connect message can contain a network id passed as arg1 on message or * or a config passed as obj on message. * For a new network, a config is passed to create and connect. * For an existing network, a network id is passed */ netId = message.arg1; config = (WifiConfiguration) message.obj; mWifiConnectionStatistics.numWifiManagerJoinAttempt++; boolean hasCredentialChanged = false; // New network addition. if (config != null) { result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid); if (!result.isSuccess()) { loge("CONNECT_NETWORK adding/updating config=" + config + " failed"); messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; } netId = result.getNetworkId(); } if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
response: sendMessage(CMD_DISCONNECT); break; case WifiManager.CONNECT_NETWORK: netId = message.arg1; config = (WifiConfiguration) message.obj; mWifiConnectionStatistics.numWifiManagerJoinAttempt++; if (config != null) { result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid); if (!result.isSuccess()) { loge("CONNECT_NETWORK adding/updating config=" + config + " failed"); messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; } netId = result.getNetworkId(); } if (!connectToUserSelectNetwork(netId, message.sendingUid))

sample: 234
buggy_code:  /** * The connect message can contain a network id passed as arg1 on message or * or a config passed as obj on message. * For a new network, a config is passed to create and connect. * For an existing network, a network id is passed */ netId = message.arg1; config = (WifiConfiguration) message.obj; <|startfocus|> mWifiConnectionStatistics.numWifiManagerJoinAttempt++; <|endfocus|> // New network addition. if (config != null) { result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid); if (!result.isSuccess()) { loge("CONNECT_NETWORK adding/updating config=" + config + " failed"); messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; } netId = result.getNetworkId(); } if (!connectToUserSelectNetwork(netId, message.sendingUid)) { messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED,
code_review:  Is it possible that both Ip and Proxy changed? 
target code: /** * The connect message can contain a network id passed as arg1 on message or * or a config passed as obj on message. * For a new network, a config is passed to create and connect. * For an existing network, a network id is passed */ netId = message.arg1; config = (WifiConfiguration) message.obj; mWifiConnectionStatistics.numWifiManagerJoinAttempt++; boolean hasCredentialChanged = false; // New network addition. if (config != null) { result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid); if (!result.isSuccess()) { loge("CONNECT_NETWORK adding/updating config=" + config + " failed"); messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; } netId = result.getNetworkId(); } if (!connectToUserSelectNetwork(netId, message.sendingUid)) { messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED,
response: netId = message.arg1; config = (WifiConfiguration) message.obj; mWifiConnectionStatistics.numWifiManagerJoinAttempt++; // New network addition. if (config != null) { result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid); if (!result.isSuccess()) { loge("CONNECT_NETWORK adding/updating config=" + config + " failed"); messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; } netId = result.getNetworkId(); } if (!connectToUserSelectNetwork(netId, message.sendingUid)) { messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL; replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR); break; }

sample: 235
buggy_code:  newNetwork || WifiConfigurationUtil.hasCredentialChanged( existingInternalConfig, newInternalConfig); // This is needed to inform IpManager about any IP configuration changes. boolean hasIpChanged = newNetwork || WifiConfigurationUtil.hasIpChanged( existingInternalConfig, newInternalConfig); boolean hasProxyChanged = newNetwork || WifiConfigurationUtil.hasProxyChanged( existingInternalConfig, newInternalConfig); <|startfocus|> // Reset the |hasEverConnected| flag if the credential parameters changed in this update. <|endfocus|> if (hasCredentialChanged) { newInternalConfig.getNetworkSelectionStatus().setHasEverConnected(false); } // Add it to our internal map. This will replace any existing network configuration for // updates. mConfiguredNetworks.put(newInternalConfig); if (mDeletedEphemeralSSIDs.remove(config.SSID)) { if (mVerboseLoggingEnabled) { Log.v(TAG, "Removed from ephemeral blacklist: " + config.SSID); } } // Stage the backup of the SettingsProvider package which backs this up. mBackupManagerProxy.notifyDataChanged(); NetworkUpdateResult result = new NetworkUpdateResult(hasIpChanged, hasProxyChanged, hasCredentialChanged); result.setIsNewNetwork(newNetwork);
code_review:  it is a little odd to split the hasCredentialChanged here from where it is set above. 
target code: newNetwork || WifiConfigurationUtil.hasCredentialChanged( existingInternalConfig, newInternalConfig); // This is needed to inform IpManager about any IP configuration changes. boolean hasIpChanged = newNetwork || WifiConfigurationUtil.hasIpChanged( existingInternalConfig, newInternalConfig); boolean hasProxyChanged = newNetwork || WifiConfigurationUtil.hasProxyChanged( existingInternalConfig, newInternalConfig); // Reset the |hasEverConnected| flag if the credential parameters changed in this update. boolean hasCredentialChanged = newNetwork || WifiConfigurationUtil.hasCredentialChanged( existingInternalConfig, newInternalConfig); if (hasCredentialChanged) { newInternalConfig.getNetworkSelectionStatus().setHasEverConnected(false); } // Add it to our internal map. This will replace any existing network configuration for // updates. mConfiguredNetworks.put(newInternalConfig); if (mDeletedEphemeralSSIDs.remove(config.SSID)) { if (mVerboseLoggingEnabled) { Log.v(TAG, "Removed from ephemeral blacklist: " + config.SSID); } } // Stage the backup of the SettingsProvider package which backs this up. mBackupManagerProxy.notifyDataChanged(); NetworkUpdateResult result = new NetworkUpdateResult(hasIpChanged, hasProxyChanged, hasCredentialChanged); result.setIsNewNetwork(newNetwork);
response: newNetwork || WifiConfigurationUtil.hasCredentialChanged(existingInternalConfig, newInternalConfig); boolean hasIpChanged = newNetwork || WifiConfigurationUtil.hasIpChanged(existingInternalConfig, newInternalConfig); boolean hasProxyChanged = newNetwork || WifiConfigurationUtil.hasProxyChanged(existingInternalConfig, newInternalConfig); if (hasCredentialChanged) { newInternalConfig.getNetworkSelectionStatus().setHasEverConnected(false); } mConfiguredNetworks.put(newInternalConfig); if (mDeletedEphemeralSSIDs.remove(config.SSID)) { if (mVerboseLoggingEnabled) { Log.v(TAG, "Removed from ephemeral blacklist: " + config.SSID); } } mBackupManagerProxy.notifyDataChanged(); NetworkUpdateResult result = new NetworkUpdateResult(hasIpChanged, hasProxyChanged, hasCredentialChanged); result.setIsNewNetwork(newNetwork);

sample: 236
buggy_code:  public ISap getSapProxy() { <|startfocus|> if (mSapProxy != null) { return mSapProxy; } try { mSapProxy = ISap.getService(SOCKET_NAME_RIL_BT); <|endfocus|> if (mSapProxy != null) { mSapProxy.linkToDeath(mSapProxyDeathRecipient, mSapProxyCookie.incrementAndGet()); mSapProxy.setCallback(mSapCallback); } else { Log.e(TAG, "getSapProxy: mSapProxy == null"); } } catch (RemoteException | RuntimeException e) { mSapProxy = null; Log.e(TAG, "getSapProxy: exception: " + e); } if (mSapProxy == null) { // if service is not up, treat it like death notification to try to get service again mSapServerMsgHandler.sendMessageDelayed( mSapServerMsgHandler.obtainMessage( SapServer.SAP_PROXY_DEAD, mSapProxyCookie.get()), SapServer.ISAP_GET_SERVICE_DELAY_MILLIS); } return mSapProxy;
code_review:  If you're assuming it's locked here you should call this getSapProxyLocked 
target code: public ISap getSapProxy() { synchronized (mSapProxyLock) { if (mSapProxy != null) { mSapProxy.linkToDeath(mSapProxyDeathRecipient, mSapProxyCookie.incrementAndGet()); mSapProxy.setCallback(mSapCallback); } else { Log.e(TAG, "getSapProxy: mSapProxy == null"); } } catch (RemoteException | RuntimeException e) { mSapProxy = null; Log.e(TAG, "getSapProxy: exception: " + e); } if (mSapProxy == null) { // if service is not up, treat it like death notification to try to get service again mSapServerMsgHandler.sendMessageDelayed( mSapServerMsgHandler.obtainMessage( SapServer.SAP_PROXY_DEAD, mSapProxyCookie.get()), SapServer.ISAP_GET_SERVICE_DELAY_MILLIS); } return mSapProxy;
response: public ISap getSapProxy() { if (mSapProxy != null) { return mSapProxy; } try { mSapProxy = ISap.getService(SOCKET_NAME_RIL_BT); if (mSapProxy != null) { mSapProxy.linkToDeath(mSapProxyDeathRecipient, mSapProxyCookie.incrementAndGet()); mSapProxy.setCallback(mSapCallback); } else { Log.e(TAG, "getSapProxy: mSapProxy == null"); } } catch (RemoteException | RuntimeException e) { mSapProxy = null; Log.e(TAG, "getSapProxy: exception: " + e); } if (mSapProxy == null) { // if service is not up, treat it like death notification to try to get service again mSapServerMsgHandler.sendMessageDelayed( mSapServerMsgHandler.obtainMessage(SapServer.SAP_PROXY_DEAD, mSapProxyCookie.get()), SapServer.ISAP_GET_SERVICE_DELAY_MILLIS); } return mSapProxy; }

sample: 237
buggy_code:  " mtu=" + mtu + " status=" + status); if (!address.equals(mDevice.getAddress())) { return; } try { mCallback.onMtuChanged(BluetoothGatt.this, mtu, status); } catch (Exception ex) { Log.w(TAG, "Unhandled exception in callback", ex); } } /** * Callback invoked when the given connection is updated * @hide */ <|startfocus|> public void OnConnectionUpdated(String address, int interval, int latency, <|endfocus|> int timeout, int status) { if (DBG) Log.d(TAG, "onConnectionUpdated() - Device=" + address + " interval=" + interval + " latency=" + latency + " timeout=" + timeout + " status=" + status); if (!address.equals(mDevice.getAddress())) { return; } try { mCallback.onConnectionUpdated(BluetoothGatt.this, interval, latency, timeout, status); } catch (Exception ex) { Log.w(TAG, "Unhandled exception in callback", ex); } } }; 
code_review:  Small o in onConn..., How about onConnectionParametersUpdated? 
target code: " mtu=" + mtu + " status=" + status); if (!address.equals(mDevice.getAddress())) { return; } try { mCallback.onMtuChanged(BluetoothGatt.this, mtu, status); } catch (Exception ex) { Log.w(TAG, "Unhandled exception in callback", ex); } } /** * Callback invoked when the given connection is updated * @hide */ @Override public void onConnectionUpdated(String address, int interval, int latency, int timeout, int status) { if (DBG) Log.d(TAG, "onConnectionUpdated() - Device=" + address + " interval=" + interval + " latency=" + latency + " timeout=" + timeout + " status=" + status); if (!address.equals(mDevice.getAddress())) { return; } try { mCallback.onConnectionUpdated(BluetoothGatt.this, interval, latency, timeout, status); } catch (Exception ex) { Log.w(TAG, "Unhandled exception in callback", ex); } } };
response: " mtu=" + mtu + " status=" + status); if (!address.equals(mDevice.getAddress())) { return; } try { mCallback.onMtuChanged(BluetoothGatt.this, mtu, status); } catch (Exception ex) { Log.w(TAG, "Unhandled exception in callback", ex); } } /** * Callback invoked when the given connection is updated * @hide */ public void onConnectionParametersUpdated(String address, int interval, int latency, int timeout, int status) { if (DBG) Log.d(TAG, "onConnectionUpdated() - Device=" + address + " interval=" + interval + " latency=" + latency + " timeout=" + timeout + " status=" + status); if (!address.equals(mDevice.getAddress())) { return; } try { mCallback.onConnectionUpdated(BluetoothGatt.this, interval, latency, timeout, status); } catch (Exception ex) { Log.w(TAG, "Unhandled exception in callback", ex); } } };

sample: 238
buggy_code: <|startfocus|> * Copyright (C) 2007 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.server; import static android.Manifest.permission.DUMP; import static android.Manifest.permission.SHUTDOWN; import android.content.Context; import android.net.IIpSecService; import android.net.INetd; import android.os.Binder; import android.os.Handler; import android.os.Process; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import java.io.FileDescriptor; import java.io.PrintWriter;
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.server; import static android.Manifest.permission.DUMP; import static android.Manifest.permission.SHUTDOWN; import android.content.Context; import android.net.IIpSecService; import android.net.INetd; import android.os.Binder; import android.os.Handler; import android.os.Process; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import java.io.FileDescriptor; import java.io.PrintWriter;
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.server; import static android.Manifest.permission.DUMP; import static android.Manifest.permission.SHUTDOWN; import android.content.Context; import android.net.IIpSecService; import android.net.INetd; import android.os.Binder; import android.os.Handler; import android.os.Process; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import java.io.FileDescriptor; import java.io.PrintWriter;

sample: 239
buggy_code: import java.util.concurrent.CountDownLatch; /** @hide */ public class IpSecService extends IIpSecService.Stub implements Watchdog.Monitor { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_TAG = "NetdConnector"; private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; <|startfocus|> /** connector object for communicating with netd */ private final NativeDaemonConnector mConnector; private final Handler mFgHandler; <|endfocus|> private INetd mNetdService; private final Thread mThread; private CountDownLatch mConnectedSignal = new CountDownLatch(1); /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); mConnector =
code_review:  We don't need this since we're only going to be communicating to netd via binder. Use NetdService instead. 
target code: import java.util.concurrent.CountDownLatch; /** @hide */ public class IpSecService extends IIpSecService.Stub implements Watchdog.Monitor { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_TAG = "NetdConnector"; private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; private INetd mNetdService; private final Thread mThread; private CountDownLatch mConnectedSignal = new CountDownLatch(1); /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); mConnector =
response: import java.util.concurrent.CountDownLatch; /** @hide */ public class IpSecService extends IIpSecService.Stub implements Watchdog.Monitor { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_TAG = "NetdConnector"; private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; /** connector object for communicating with netd */ private final NativeDaemonConnector mConnector; private final Handler mFgHandler; private INetd mNetdService; private final Thread mThread; private CountDownLatch mConnectedSignal = new CountDownLatch(1); /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); mConnector = new NativeDaemonConnector(this, socket, 10, NETD_TAG, 160, null); mThread = new Thread(mConnector, NETD_TAG); } }

sample: 240
buggy_code:  private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_TAG = "NetdConnector"; private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; /** connector object for communicating with netd */ private final NativeDaemonConnector mConnector; private final Handler mFgHandler; private INetd mNetdService; <|startfocus|> private final Thread mThread; private CountDownLatch mConnectedSignal = new CountDownLatch(1); <|endfocus|> /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); mConnector = new NativeDaemonConnector( new NetdCallbackReceiver(), socket, 10, NETD_TAG, 160, null /*wakelock*/, FgThread.get().getLooper());
code_review:  Don't need this either. 
target code: private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_TAG = "NetdConnector"; private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; /** connector object for communicating with netd */ private final NativeDaemonConnector mConnector; private final Handler mFgHandler; private INetd mNetdService; private static final int NETD_FETCH_TIMEOUT = 1000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); mConnector = new NativeDaemonConnector( new NetdCallbackReceiver(), socket, 10, NETD_TAG, 160, null /*wakelock*/, FgThread.get().getLooper());
response: private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_TAG = "NetdConnector"; private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; /** connector object for communicating with netd */ private final NativeDaemonConnector mConnector; private final Handler mFgHandler; private INetd mNetdService; private final Thread mThread; private CountDownLatch mConnectedSignal = new CountDownLatch(1); /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); mConnector = new NativeDaemonConnector( new NetdCallbackReceiver(), socket, 10, NETD_TAG, 160, null /*wakelock*/, FgThread.get().getLooper()); }

sample: 241
buggy_code:  public void systemReady() { <|startfocus|> if (DBG) { final long start = System.currentTimeMillis(); prepareNativeDaemon(); final long delta = System.currentTimeMillis() - start; Log.d(TAG, "Prepared in " + delta + "ms"); return; <|endfocus|> } else { prepareNativeDaemon(); }
code_review:  Don't need this. 
target code: public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { prepareNativeDaemon(); }
response: public void systemReady() { if (DBG) { final long start = System.currentTimeMillis(); prepareNativeDaemon(); final long delta = System.currentTimeMillis() - start; Log.d(TAG, "Prepared in " + delta + "ms"); return; } else { prepareNativeDaemon(); } }

sample: 242
buggy_code:  private void connectNativeNetdService() { <|startfocus|> mNetdService = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME)); if (!isNetdAlive()) { Log.wtf(TAG, "Can't connect to NativeNetdService " + NETD_SERVICE_NAME); } <|endfocus|>
code_review:  Look at NetdService.java. 
target code: private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t = new Thread(
response: private void connectNativeNetdService() { mNetdService = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME)); if (!isNetdAlive()) { Log.wtf(TAG, "Can't connect to NativeNetdService " + NETD_SERVICE_NAME); } }

sample: 243
buggy_code:  assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. Going to the home screen does not <|startfocus|> // qualify as the user leaving the activity's flow. Only when the The user switch to // another activity that is not part of the tracked flow that we consider the flow is // complete. <|endfocus|> assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { // With platforms that have no home screen, focus is returned to something else that is // considered a completion of the tracked activity flow, and hence time tracking is // triggered. assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
code_review:  The time tracking is considered complete only when the user switches to another activity that is not part of the tracked flow. 
target code: assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. Going to the home screen does not // qualify as the user leaving the activity's flow. The time tracking is considered // complete only when the user switches to another activity that is not part of the // tracked flow. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { // With platforms that have no home screen, focus is returned to something else that is // considered a completion of the tracked activity flow, and hence time tracking is // triggered. assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
response: assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

sample: 244
buggy_code:  public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. <|startfocus|> mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId++)); // Try to wrap cleanly after 2^15 downstreams added since boot. if (mNextSubnetId < 0) mNextSubnetId = 0; <|endfocus|> updateIPv6TetheringInterfaces(); }
code_review:  Or, mNextSubnetId &= Short.MAX_VALUE; (i.e masking the sign byte). Branchless, but more obscure, so please don't do it :p Real suggestion though: consider having mNextSubmetId++ and this overflow check in the same statement: mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId)); mNextSubnetId = Math.max(0, mNextSubnetId + 1); // always positive 
target code: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. if (mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId))) { mNextSubnetId = (short) Math.max(0, mNextSubnetId + 1); // always positive } updateIPv6TetheringInterfaces(); }
response: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId)); mNextSubnetId = Math.max(0, mNextSubnetId + 1); updateIPv6TetheringInterfaces(); } }

sample: 245
buggy_code:  // (which extends it). SYSTEM_SERVICE_NAMES.put(android.text.ClipboardManager.class, Context.CLIPBOARD_SERVICE); registerService(Context.CONNECTIVITY_SERVICE, ConnectivityManager.class, new StaticApplicationContextServiceFetcher<ConnectivityManager>() { @Override public ConnectivityManager createService(Context context) { IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE); IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); return new ConnectivityManager(context, service); }}); registerService(Context.IPSEC_SERVICE, IpSecManager.class, new StaticApplicationContextServiceFetcher<IpSecManager>() { @Override <|startfocus|> public IpSecManager createService(Context context) { <|endfocus|> IBinder b = ServiceManager.getService(Context.IPSEC_SERVICE); IIpSecService service = IIpSecService .Stub.asInterface(b); return new IpSecManager(context, service); }}); registerService(Context.COUNTRY_DETECTOR, CountryDetector.class, new StaticServiceFetcher<CountryDetector>() { @Override public CountryDetector createService() { IBinder b = ServiceManager.getService(Context.COUNTRY_DETECTOR); return new CountryDetector(ICountryDetector.Stub.asInterface(b)); }}); registerService(Context.DEVICE_POLICY_SERVICE, DevicePolicyManager.class,
code_review:  Shouldn't this be StaticServiceFetcher? 
target code: // (which extends it). SYSTEM_SERVICE_NAMES.put(android.text.ClipboardManager.class, Context.CLIPBOARD_SERVICE); registerService(Context.CONNECTIVITY_SERVICE, ConnectivityManager.class, new StaticApplicationContextServiceFetcher<ConnectivityManager>() { @Override public ConnectivityManager createService(Context context) { IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE); IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); return new ConnectivityManager(context, service); }}); registerService(Context.IPSEC_SERVICE, IpSecManager.class, new StaticApplicationContextServiceFetcher<IpSecManager>() { @Override public IpSecManager createService() { IBinder b = ServiceManager.getService(Context.IPSEC_SERVICE); IIpSecService service = IIpSecService .Stub.asInterface(b); return new IpSecManager(context, service); }}); registerService(Context.COUNTRY_DETECTOR, CountryDetector.class, new StaticServiceFetcher<CountryDetector>() { @Override public CountryDetector createService() { IBinder b = ServiceManager.getService(Context.COUNTRY_DETECTOR); return new CountryDetector(ICountryDetector.Stub.asInterface(b)); }}); registerService(Context.DEVICE_POLICY_SERVICE, DevicePolicyManager.class,
response: // (which extends it). SYSTEM_SERVICE_NAMES.put(android.text.ClipboardManager.class, Context.CLIPBOARD_SERVICE); registerService(Context.CONNECTIVITY_SERVICE, ConnectivityManager.class, new StaticApplicationContextServiceFetcher<ConnectivityManager>() { @Override public ConnectivityManager createService(Context context) { IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE); IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); return new ConnectivityManager(context, service); } }); registerService(Context.IPSEC_SERVICE, IpSecManager.class, new StaticApplicationContextServiceFetcher<IpSecManager>() { @Override public IpSecManager createService(Context context) { IBinder b = ServiceManager.getService(Context.IPSEC_SERVICE); IIpSecService service = IIpSecService.Stub.asInterface(b); return new IpSecManager(context, service); } }); registerService(Context.COUNTRY_DETECTOR, CountryDetector.class, new StaticServiceFetcher<CountryDetector>() { @Override public CountryDetector createService() { IBinder b = ServiceManager.getService(Context.COUNTRY_DETECTOR); return new CountryDetector(ICountryDetector.Stub.asInterface(b)); } }); registerService(Context.DEVICE_POLICY_SERVICE, DevicePolicyManager.class, new StaticServiceFetcher<DevicePolicyManager>() { @Override public DevicePolicyManager createService() { return new DevicePolicyManager(); } });

sample: 246
buggy_code:  public IpSecManager createService(Context context) { IBinder b = ServiceManager.getService(Context.IPSEC_SERVICE); <|startfocus|> IIpSecService service = IIpSecService .Stub.asInterface(b); return new IpSecManager(context, service); <|endfocus|>
code_review:  Lose this space? 
target code: public IpSecManager createService(Context context) { IBinder b = ServiceManager.getService(Context.IPSEC_SERVICE); IIpSecService service = IIpSecService.Stub.asInterface(b); return new IpSecManager(service);
response: public IpSecManager createService(Context context) { IBinder b = ServiceManager.getService(Context.IPSEC_SERVICE); IIpSecService service = IIpSecService.Stub.asInterface(b); return new IpSecManager(context, service); }

sample: 247
buggy_code: import android.os.RemoteException; import android.util.Log; import android.util.Slog; import java.io.FileDescriptor; import java.io.PrintWriter; /** @hide */ public class IpSecService extends IIpSecService.Stub { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); <|startfocus|> private static final int NETD_FETCH_TIMEOUT = 1000; //ms <|endfocus|> /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException {
code_review:  Also consider just using the class lock. 
target code: import android.os.RemoteException; import android.util.Log; import android.util.Slog; import java.io.FileDescriptor; import java.io.PrintWriter; /** @hide */ public class IpSecService extends IIpSecService.Stub { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException {
response: import android.os.RemoteException; import android.util.Log; import android.util.Slog; import java.io.FileDescriptor; import java.io.PrintWriter; /** @hide */ public class IpSecService extends IIpSecService.Stub { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 1000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { synchronized (IpSecService.class) { final IpSecService service = new IpSecService(context, null); service.connectNativeNetdService(); return service; } } }

sample: 248
buggy_code: import android.util.Slog; import java.io.FileDescriptor; import java.io.PrintWriter; /** @hide */ public class IpSecService extends IIpSecService.Stub { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); <|startfocus|> private static final int NETD_FETCH_TIMEOUT = 1000; //ms <|endfocus|> /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } 
code_review:  This may not be enough. 
target code: import android.util.Slog; import java.io.FileDescriptor; import java.io.PrintWriter; /** @hide */ public class IpSecService extends IIpSecService.Stub { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); }
response: import android.util.Slog; import java.io.FileDescriptor; import java.io.PrintWriter; public class IpSecService extends IIpSecService.Stub { private static final String TAG = "IpSecService"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 1000; //ms private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } }

sample: 249
buggy_code:  protected Vpn(Looper looper, Context context, INetworkManagementService netService, int userHandle, SystemServices systemServices) { mContext = context; mNetd = netService; mUserHandle = userHandle; mLooper = looper; mSystemServices = systemServices; mPackage = VpnConfig.LEGACY_VPN; mOwnerUID = getAppUid(mPackage, mUserHandle); <|startfocus|> loadAlwaysOnPackage(); <|endfocus|> try { netService.registerObserver(mObserver); } catch (RemoteException e) { Log.wtf(TAG, "Problem registering observer", e); } mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_VPN, 0, NETWORKTYPE, ""); // TODO: Copy metered attribute and bandwidths from physical transport, b/16207332 mNetworkCapabilities = new NetworkCapabilities(); mNetworkCapabilities.addTransportType(NetworkCapabilities.TRANSPORT_VPN); mNetworkCapabilities.removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN);
code_review:  Just checking: in the previous code loadAlwaysOnPackage was called after the ctor had returned. Is this correct to call it at that point. Maybe it is more correct now :p 
target code: protected Vpn(Looper looper, Context context, INetworkManagementService netService, int userHandle, SystemServices systemServices) { mContext = context; mNetd = netService; mUserHandle = userHandle; mLooper = looper; mSystemServices = systemServices; mPackage = VpnConfig.LEGACY_VPN; mOwnerUID = getAppUid(mPackage, mUserHandle); try { netService.registerObserver(mObserver); } catch (RemoteException e) { Log.wtf(TAG, "Problem registering observer", e); } mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_VPN, 0, NETWORKTYPE, ""); // TODO: Copy metered attribute and bandwidths from physical transport, b/16207332 mNetworkCapabilities = new NetworkCapabilities(); mNetworkCapabilities.addTransportType(NetworkCapabilities.TRANSPORT_VPN); mNetworkCapabilities.removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN);
response: protected Vpn(Looper looper, Context context, INetworkManagementService netService, int userHandle, SystemServices systemServices) { mContext = context; mNetd = netService; mUserHandle = userHandle; mLooper = looper; mSystemServices = systemServices; mPackage = VpnConfig.LEGACY_VPN; mOwnerUID = getAppUid(mPackage, mUserHandle); loadAlwaysOnPackage(); try { netService.registerObserver(mObserver); } catch (RemoteException e) { Log.wtf(TAG, "Problem registering observer", e); } mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_VPN, 0, NETWORKTYPE, ""); // TODO: Copy metered attribute and bandwidths from physical transport, b/16207332 mNetworkCapabilities = new NetworkCapabilities(); mNetworkCapabilities.addTransportType(NetworkCapabilities.TRANSPORT_VPN); mNetworkCapabilities.removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN); }

sample: 250
buggy_code:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.example.android.toyvpn; import android.app.Activity; import android.content.Intent; import android.content.SharedPreferences; import android.net.VpnService; import android.os.Bundle; import android.widget.TextView; public class ToyVpnClient extends Activity { <|startfocus|> public static class Prefs { public static final String NAME = "connection"; public static final String SERVER_ADDRESS = "server.address"; public static final String SERVER_PORT = "server.port"; public static final String SHARED_SECRET = "shared.secret"; <|endfocus|> } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.form); final TextView serverAddress = (TextView) findViewById(R.id.address); final TextView serverPort = (TextView) findViewById(R.id.port); final TextView sharedSecret = (TextView) findViewById(R.id.secret); 
code_review:  make this an interface, and you can drop all these "public static final"s. that's also the idiomatic way of doing things. 
target code: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.example.android.toyvpn; import android.app.Activity; import android.content.Intent; import android.content.SharedPreferences; import android.net.VpnService; import android.os.Bundle; import android.widget.TextView; public class ToyVpnClient extends Activity { public interface Prefs { String NAME = "connection"; String SERVER_ADDRESS = "server.address"; String SERVER_PORT = "server.port"; String SHARED_SECRET = "shared.secret"; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.form); final TextView serverAddress = (TextView) findViewById(R.id.address); final TextView serverPort = (TextView) findViewById(R.id.port); final TextView sharedSecret = (TextView) findViewById(R.id.secret);
response: package com.example.android.toyvpn; import android.app.Activity; import android.content.Intent; import android.content.SharedPreferences; import android.net.VpnService; import android.os.Bundle; import android.widget.TextView; public class ToyVpnClient extends Activity { public interface Prefs { String NAME = "connection"; String SERVER_ADDRESS = "server.address"; String SERVER_PORT = "server.port"; String SHARED_SECRET = "shared.secret"; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.form); final TextView serverAddress = findViewById(R.id.address); final TextView serverPort = findViewById(R.id.port); final TextView sharedSecret = findViewById(R.id.secret); } }

sample: 251
buggy_code:  * * TODO: really don't do this; a blocking read on another thread is much cleaner. */ private static final long IDLE_INTERVAL_MS = TimeUnit.MILLISECONDS.toMillis(100); /** * Number of periods of length {@IDLE_INTERVAL_MS} to wait before declaring the handshake a * complete and abject failure. * * TODO: use a higher-level protocol; hand-rolling is a fun but pointless exercise. */ <|startfocus|> private static final int MAX_HANDSHAKE_ATTEMPTS = 50; <|endfocus|> private final VpnService mService; private final int mConnectionId; private final String mServerName; private final int mServerPort; private final byte[] mSharedSecret; private PendingIntent mConfigureIntent; private OnEstablishListener mOnEstablishListener; public ToyVpnConnection(final VpnService service, final int connectionId, final String serverName, final int serverPort, final byte[] sharedSecret) { mService = service; mConnectionId = connectionId; mServerName = serverName; mServerPort= serverPort; mSharedSecret = sharedSecret; } /**
code_review:  indent is off 
target code: * * TODO: really don't do this; a blocking read on another thread is much cleaner. */ private static final long IDLE_INTERVAL_MS = TimeUnit.MILLISECONDS.toMillis(100); /** * Number of periods of length {@IDLE_INTERVAL_MS} to wait before declaring the handshake a * complete and abject failure. * * TODO: use a higher-level protocol; hand-rolling is a fun but pointless exercise. */ private static final int MAX_HANDSHAKE_ATTEMPTS = 50; private final VpnService mService; private final int mConnectionId; private final String mServerName; private final int mServerPort; private final byte[] mSharedSecret; private PendingIntent mConfigureIntent; private OnEstablishListener mOnEstablishListener; public ToyVpnConnection(final VpnService service, final int connectionId, final String serverName, final int serverPort, final byte[] sharedSecret) { mService = service; mConnectionId = connectionId; mServerName = serverName; mServerPort= serverPort; mSharedSecret = sharedSecret; } /**
response: private static final long IDLE_INTERVAL_MS = TimeUnit.MILLISECONDS.toMillis(100); private static final int MAX_HANDSHAKE_ATTEMPTS = 50; private final VpnService mService; private final int mConnectionId; private final String mServerName; private final int mServerPort; private final byte[] mSharedSecret; private PendingIntent mConfigureIntent; private OnEstablishListener mOnEstablishListener; public ToyVpnConnection(final VpnService service, final int connectionId, final String serverName, final int serverPort, final byte[] sharedSecret) { mService = service; mConnectionId = connectionId; mServerName = serverName; mServerPort = serverPort; mSharedSecret = sharedSecret; }

sample: 252
buggy_code:  } catch (Exception e) { Log.e(getTag(), "Connection failed, exiting", e); } } private boolean run(SocketAddress server) throws Exception { ParcelFileDescriptor iface = null; boolean connected = false; // Create a DatagramChannel as the VPN tunnel. try (DatagramChannel tunnel = DatagramChannel.open()) { // Protect the tunnel before connecting to avoid loopback. if (!mService.protect(tunnel.socket())) { <|startfocus|> throw new IllegalStateException("Cannot protect the tunnel for"); <|endfocus|> } // Connect to the server. tunnel.connect(server); // For simplicity, we use the same thread for both reading and // writing. Here we put the tunnel into non-blocking mode. tunnel.configureBlocking(false); // Authenticate and configure the virtual network interface. iface = handshake(tunnel); // Now we are connected. Set the flag. connected = true; // Packets to be sent are queued in this input stream. FileInputStream in = new FileInputStream(iface.getFileDescriptor()); 
code_review:  for... ? 
target code: } catch (Exception e) { Log.e(getTag(), "Connection failed, exiting", e); } } private boolean run(SocketAddress server) throws Exception { ParcelFileDescriptor iface = null; boolean connected = false; // Create a DatagramChannel as the VPN tunnel. try (DatagramChannel tunnel = DatagramChannel.open()) { // Protect the tunnel before connecting to avoid loopback. if (!mService.protect(tunnel.socket())) { throw new IllegalStateException("Cannot protect the tunnel"); } // Connect to the server. tunnel.connect(server); // For simplicity, we use the same thread for both reading and // writing. Here we put the tunnel into non-blocking mode. tunnel.configureBlocking(false); // Authenticate and configure the virtual network interface. iface = handshake(tunnel); // Now we are connected. Set the flag. connected = true; // Packets to be sent are queued in this input stream. FileInputStream in = new FileInputStream(iface.getFileDescriptor());
response: } catch (Exception e) { Log.e(getTag(), "Connection failed, exiting", e); } private boolean run(SocketAddress server) throws Exception { ParcelFileDescriptor iface = null; boolean connected = false; // Create a DatagramChannel as the VPN tunnel. try (DatagramChannel tunnel = DatagramChannel.open()) { // Protect the tunnel before connecting to avoid loopback. if (!mService.protect(tunnel.socket())) { throw new IllegalStateException("Cannot protect the tunnel for"); } // Connect to the server. tunnel.connect(server); // For simplicity, we use the same thread for both reading and writing. // Here we put the tunnel into non-blocking mode. tunnel.configureBlocking(false); // Authenticate and configure the virtual network interface. iface = handshake(tunnel); // Now we are connected. Set the flag. connected = true; // Packets to be sent are queued in this input stream. FileInputStream in = new FileInputStream(iface.getFileDescriptor()); }

sample: 253
buggy_code:  packet.position(0); tunnel.write(packet); } packet.clear(); // Wait for the parameters within a limited time. for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) { Thread.sleep(IDLE_INTERVAL_MS); // Normally we should not receive random packets. int length = tunnel.read(packet); if (length > 0 && packet.get(0) == 0) { <|startfocus|> return configure(new String(packet.array(), 1, length - 1).trim()); <|endfocus|> } } throw new IllegalStateException("Timed out"); } private ParcelFileDescriptor configure(String parameters) throws Exception { // Configure a builder while parsing the parameters. VpnService.Builder builder = mService.new Builder(); for (String parameter : parameters.split(" ")) { String[] fields = parameter.split(","); try { switch (fields[0].charAt(0)) { case 'm': builder.setMtu(Short.parseShort(fields[1])); break; case 'a': builder.addAddress(fields[1], Integer.parseInt(fields[2]));
code_review:  what's this check for ? also maybe document that for the sake of simplicity, you're using a fixed length buffer for the packet ? 
target code: packet.position(0); tunnel.write(packet); } packet.clear(); // Wait for the parameters within a limited time. for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) { Thread.sleep(IDLE_INTERVAL_MS); // Normally we should not receive random packets. int length = tunnel.read(packet); if (length > 0 && packet.get(0) == 0) { return configure(new String(packet.array(), 1, length - 1, US_ASCII).trim()); } } throw new IllegalStateException("Timed out"); } private ParcelFileDescriptor configure(String parameters) throws Exception { // Configure a builder while parsing the parameters. VpnService.Builder builder = mService.new Builder(); for (String parameter : parameters.split(" ")) { String[] fields = parameter.split(","); try { switch (fields[0].charAt(0)) { case 'm': builder.setMtu(Short.parseShort(fields[1])); break; case 'a': builder.addAddress(fields[1], Integer.parseInt(fields[2]));
response: public void sendDataToTunnel(SocketChannel tunnel, ByteBuffer packet) throws IOException, InterruptedException { packet.position(0); tunnel.write(packet); packet.clear(); for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) { Thread.sleep(IDLE_INTERVAL_MS); int length = tunnel.read(packet); if (length > 0 && packet.get(0) == 0) { return configure(new String(packet.array(), 1, length - 1).trim()); } } throw new IllegalStateException("Timed out"); } private ParcelFileDescriptor configure(String parameters) throws Exception { VpnService.Builder builder = mService.new Builder(); for (String parameter : parameters.split(" ")) { String[] fields = parameter.split(","); switch (fields[0].charAt(0)) { case 'm': builder.setMtu(Short.parseShort(fields[1])); break; case 'a': builder.addAddress(fields[1], Integer.parseInt(fields[2])); break; // add other cases for configuring the builder } } // configure other settings and return the ParcelFileDescriptor }

sample: 254
buggy_code:  packet.position(0); tunnel.write(packet); } packet.clear(); // Wait for the parameters within a limited time. for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) { Thread.sleep(IDLE_INTERVAL_MS); // Normally we should not receive random packets. int length = tunnel.read(packet); if (length > 0 && packet.get(0) == 0) { <|startfocus|> return configure(new String(packet.array(), 1, length - 1).trim()); <|endfocus|> } } throw new IllegalStateException("Timed out"); } private ParcelFileDescriptor configure(String parameters) throws Exception { // Configure a builder while parsing the parameters. VpnService.Builder builder = mService.new Builder(); for (String parameter : parameters.split(" ")) { String[] fields = parameter.split(","); try { switch (fields[0].charAt(0)) { case 'm': builder.setMtu(Short.parseShort(fields[1])); break; case 'a': builder.addAddress(fields[1], Integer.parseInt(fields[2]));
code_review:  this is considered bad practice : must always specify an encoding when constructing a string out of byte[] 
target code: packet.position(0); tunnel.write(packet); } packet.clear(); // Wait for the parameters within a limited time. for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) { Thread.sleep(IDLE_INTERVAL_MS); // Normally we should not receive random packets. int length = tunnel.read(packet); if (length > 0 && packet.get(0) == 0) { return configure(new String(packet.array(), 1, length - 1, US_ASCII).trim()); } } throw new IllegalStateException("Timed out"); } private ParcelFileDescriptor configure(String parameters) throws Exception { // Configure a builder while parsing the parameters. VpnService.Builder builder = mService.new Builder(); for (String parameter : parameters.split(" ")) { String[] fields = parameter.split(","); try { switch (fields[0].charAt(0)) { case 'm': builder.setMtu(Short.parseShort(fields[1])); break; case 'a': builder.addAddress(fields[1], Integer.parseInt(fields[2]));
response: packet.position(0); tunnel.write(packet); packet.clear(); // Wait for the parameters within a limited time. for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) { Thread.sleep(IDLE_INTERVAL_MS); // Normally we should not receive random packets. int length = tunnel.read(packet); if (length > 0 && packet.get(0) == 0) { return configure(new String(packet.array(), 1, length - 1, "UTF-8").trim()); } } throw new IllegalStateException("Timed out"); } private ParcelFileDescriptor configure(String parameters) throws Exception { // Configure a builder while parsing the parameters. VpnService.Builder builder = mService.new Builder(); for (String parameter : parameters.split(" ")) { String[] fields = parameter.split(","); try { switch (fields[0].charAt(0)) { case 'm': builder.setMtu(Short.parseShort(fields[1])); break; case 'a': builder.addAddress(fields[1], Integer.parseInt(fields[2])); break; case 'r': builder.addRoute(fields[1], Integer.parseInt(fields[2])); break; case 'd': builder.addDnsServer(fields[1]); break; case 's': builder.setSession(fields[1]); break; default: throw new IllegalArgumentException("Unknown parameter: " + fields[0]); } } catch (NumberFormatException e) { throw new IllegalArgumentException("Bad parameter: " + parameter); } } return builder.establish(); }

sample: 255
buggy_code:  private void setConnectingThread(final Thread thread) { final Thread oldThread = mConnectingThread.getAndSet(thread); if (oldThread != null) { try { oldThread.interrupt(); <|startfocus|> } catch (Exception e) { <|endfocus|> Log.e(TAG, "Interrupting thread", e); } }
code_review:  what exception are you expecting ? catching "Exception" or "Throwable" is usually considered bad practice. 
target code: private void setConnectingThread(final Thread thread) { final Thread oldThread = mConnectingThread.getAndSet(thread); if (oldThread != null) { try { oldThread.interrupt(); } catch (SecurityException e) { Log.e(TAG, "Interrupting thread", e); } }
response: private void setConnectingThread(final Thread thread) { final Thread oldThread = mConnectingThread.getAndSet(thread); if (oldThread != null) { try { oldThread.interrupt(); } catch (Throwable t) { Log.e(TAG, "Interrupting thread", t); } } }

sample: 256
buggy_code:  private void setConnection(final Connection connection) { final Connection oldConnection = mConnection.getAndSet(connection); if (oldConnection != null) { try { oldConnection.first.interrupt(); oldConnection.second.close(); } catch (Exception e) { <|startfocus|> Log.e(TAG, "Interrupting thread", e); <|endfocus|> } } 
code_review:  likewise 
target code: private void setConnection(final Connection connection) { final Connection oldConnection = mConnection.getAndSet(connection); if (oldConnection != null) { try { oldConnection.first.interrupt(); oldConnection.second.close(); } catch (Exception e) { Log.e(TAG, "Interrupting thread", e); } catch (IOException e) { Log.e(TAG, "Closing VPN interface", e); } }
response: private void setConnection(final Connection connection) { final Connection oldConnection = mConnection.getAndSet(connection); if (oldConnection != null) { try { oldConnection.first.interrupt(); oldConnection.second.close(); } catch (Exception e) { Log.e(TAG, "Interrupting thread", e); } } }

sample: 257
buggy_code:  public static int inlineMonomorphic(Main a) { if (a == null) { return 42; } int i = 0; while (i < 100) { i += a.getValue(); } return i; } /// CHECK-START: int Main.inlinePolymorphic(Main) inliner (before) /// CHECK: InvokeVirtual method_name:Main.getValue /// CHECK-START: int Main.inlinePolymorphic(Main) inliner (after) /// CHECK-NOT: InvokeVirtual method_name:Main.getValue <|startfocus|> <|endfocus|> /// CHECK-START: int Main.inlineMonomorphic(Main) licm (before) /// CHECK: <<Deopt:l\d+>> Deoptimize /// CHECK: InstanceFieldGet [<<Deopt>>] field_name:Main.value /// CHECK-START: int Main.inlineMonomorphic(Main) licm (after) /// CHECK: <<Deopt:l\d+>> Deoptimize /// CHECK: InstanceFieldGet [<<Deopt>>] field_name:Main.value public static int inlinePolymorphic(Main a) { return a.getValue(); } public int getValue() { return value; } 
code_review:  tws 
target code: public static int inlineMonomorphic(Main a) { if (a == null) { return 42; } int i = 0; while (i < 100) { i += a.getValue(); } return i; } /// CHECK-START: int Main.inlinePolymorphic(Main) inliner (before) /// CHECK: InvokeVirtual method_name:Main.getValue /// CHECK-START: int Main.inlinePolymorphic(Main) inliner (after) /// CHECK-NOT: InvokeVirtual method_name:Main.getValue /// CHECK-START: int Main.inlineMonomorphic(Main) licm (before) /// CHECK: <<Deopt:l\d+>> Deoptimize /// CHECK: InstanceFieldGet [<<Deopt>>] field_name:Main.value /// CHECK-START: int Main.inlineMonomorphic(Main) licm (after) /// CHECK: <<Deopt:l\d+>> Deoptimize /// CHECK: InstanceFieldGet [<<Deopt>>] field_name:Main.value public static int inlinePolymorphic(Main a) { return a.getValue(); } public int getValue() { return value; }
response: public static int inlineMonomorphic(Main a) { if (a == null) { return 42; } int i = 0; while (i < 100) { i += a.getValue(); } return i; } public static int inlinePolymorphic(Main a) { return a.getValue(); } public int getValue() { return value; }

sample: 258
buggy_code:  mNetworkFactory = new WifiNetworkFactory(getHandler().getLooper(), mContext, NETWORKTYPE, mNetworkCapabilitiesFilter); mNetworkFactory.setScoreFilter(60); mNetworkFactory.register(); // We can't filter untrusted network in the capabilities filter because a trusted // network would still satisfy a request that accepts untrusted ones. mUntrustedNetworkFactory = new UntrustedWifiNetworkFactory(getHandler().getLooper(), mContext, NETWORKTYPE_UNTRUSTED, mNetworkCapabilitiesFilter); mUntrustedNetworkFactory.setScoreFilter(Integer.MAX_VALUE); mUntrustedNetworkFactory.register(); } } } <|startfocus|> <|endfocus|> /** * WifiStateMachine needs to enable/disable other services when wifi is in client mode. This * method allows WifiStateMachine to get these additional system services. * * At this time, this method is used to setup variables for P2P service and Wifi Aware. */ private void getAdditionalWifiServiceInterfaces() { // First set up Wifi Direct if (mP2pSupported) { IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE); WifiP2pServiceImpl wifiP2pServiceImpl =
code_review:  nit: Random newline 
target code: mNetworkFactory = new WifiNetworkFactory(getHandler().getLooper(), mContext, NETWORKTYPE, mNetworkCapabilitiesFilter); mNetworkFactory.setScoreFilter(60); mNetworkFactory.register(); // We can't filter untrusted network in the capabilities filter because a trusted // network would still satisfy a request that accepts untrusted ones. mUntrustedNetworkFactory = new UntrustedWifiNetworkFactory(getHandler().getLooper(), mContext, NETWORKTYPE_UNTRUSTED, mNetworkCapabilitiesFilter); mUntrustedNetworkFactory.setScoreFilter(Integer.MAX_VALUE); mUntrustedNetworkFactory.register(); } } } /** * WifiStateMachine needs to enable/disable other services when wifi is in client mode. This * method allows WifiStateMachine to get these additional system services. * * At this time, this method is used to setup variables for P2P service and Wifi Aware. */ private void getAdditionalWifiServiceInterfaces() { // First set up Wifi Direct if (mP2pSupported) { IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE); WifiP2pServiceImpl wifiP2pServiceImpl =
response: mNetworkFactory = new WifiNetworkFactory(getHandler().getLooper(), mContext, NETWORKTYPE, mNetworkCapabilitiesFilter); mNetworkFactory.setScoreFilter(60); mNetworkFactory.register(); mUntrustedNetworkFactory = new UntrustedWifiNetworkFactory(getHandler().getLooper(), mContext, NETWORKTYPE_UNTRUSTED, mNetworkCapabilitiesFilter); mUntrustedNetworkFactory.setScoreFilter(Integer.MAX_VALUE); mUntrustedNetworkFactory.register(); /** * WifiStateMachine needs to enable/disable other services when wifi is in client mode. This * method allows WifiStateMachine to get these additional system services. * * At this time, this method is used to setup variables for P2P service and Wifi Aware. */ private void getAdditionalWifiServiceInterfaces() { // First set up Wifi Direct if (mP2pSupported) { IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE); WifiP2pServiceImpl wifiP2pServiceImpl =

sample: 259
buggy_code:  * and calls the <code>close</code> method of the underlying output * stream. * * @exception IOException if an I/O error occurs. * @since JCE1.2 */ public void close() throws IOException { if (closed) { return; } closed = true; try { obuffer = cipher.doFinal(); } catch (IllegalBlockSizeException | BadPaddingException e) { obuffer = null; <|startfocus|> // Android-added: Throw an exception when the underlying cipher does <|endfocus|> throw new IOException(e); } try { flush(); } catch (IOException ignored) {} out.close(); } } 
code_review:  . http://b/36636576 [Since there's some additional information in there] 
target code: * and calls the <code>close</code> method of the underlying output * stream. * * @exception IOException if an I/O error occurs. * @since JCE1.2 */ public void close() throws IOException { if (closed) { return; } closed = true; try { obuffer = cipher.doFinal(); } catch (IllegalBlockSizeException | BadPaddingException e) { obuffer = null; // Android-added: Throw an exception when the underlying cipher does. http://b/36636576 throw new IOException(e); } try { flush(); } catch (IOException ignored) {} out.close(); } }
response: public void close() throws IOException { if (closed) { return; } closed = true; try { obuffer = cipher.doFinal(); } catch (IllegalBlockSizeException | BadPaddingException e) { obuffer = null; throw new IOException(e); } try { flush(); } catch (IOException ignored) {} out.close(); }

sample: 260
buggy_code:  setAndBroadcastNetworkSetTime(mSavedTime + (currTime - mSavedAtTime)); } } private void revertToNitzTimeZone() { if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) { return; } String tmpLog = "Reverting to NITZ TimeZone: tz=" + mSavedTimeZone; if (DBG) log(tmpLog); mTimeZoneLog.log(tmpLog); if (mSavedTimeZone != null) { setAndBroadcastNetworkSetTimeZone(mSavedTimeZone); } } /** * Post a notification to NotificationManager for restricted state and * rejection cause for cs registration * <|startfocus|> * @param notifyType is one state of PS/CS_*_ENABLE/DISABLE <|endfocus|> */ @VisibleForTesting public void setNotification(int notifyType) { if (DBG) log("setNotification: create notification " + notifyType); // Needed because sprout RIL sends these when they shouldn't? boolean isSetNotification = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
code_review:  exceeds 100 chars 
target code: setAndBroadcastNetworkSetTime(mSavedTime + (currTime - mSavedAtTime)); } } private void revertToNitzTimeZone() { if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) { return; } String tmpLog = "Reverting to NITZ TimeZone: tz=" + mSavedTimeZone; if (DBG) log(tmpLog); mTimeZoneLog.log(tmpLog); if (mSavedTimeZone != null) { setAndBroadcastNetworkSetTimeZone(mSavedTimeZone); } } /** * Post a notification to NotificationManager for restricted state and * rejection cause for cs registration * * @param notifyType is one state of * PS/CS_*_ENABLE/DISABLE/ * CS_REJECT_CAUSE_ENABLED/CS_REJECT_CAUSE_DISABLED */ @VisibleForTesting public void setNotification(int notifyType) { if (DBG) log("setNotification: create notification " + notifyType); // Needed because sprout RIL sends these when they shouldn't? boolean isSetNotification = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
response: setAndBroadcastNetworkSetTime(mSavedTime + (currTime - mSavedAtTime)); } private void revertToNitzTimeZone() { if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) { return; } String tmpLog = "Reverting to NITZ TimeZone: tz=" + mSavedTimeZone; if (DBG) log(tmpLog); mTimeZoneLog.log(tmpLog); if (mSavedTimeZone != null) { setAndBroadcastNetworkSetTimeZone(mSavedTimeZone); } } @VisibleForTesting public void setNotification(int notifyType) { if (DBG) log("setNotification: create notification " + notifyType); boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access); }

sample: 261
buggy_code: <|startfocus|> public void setNotification(int notifyType) { <|endfocus|> if (DBG) log("setNotification: create notification " + notifyType); // Needed because sprout RIL sends these when they shouldn't? boolean isSetNotification = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access); if (!isSetNotification) { if (DBG) log("Ignore all the notifications"); return; } Context context = mPhone.getContext(); CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE); if (configManager != null) { PersistableBundle bundle = configManager.getConfig(); if (bundle != null) { boolean disableVoiceBarringNotification = bundle.getBoolean( CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false); if(disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) { if (DBG) log("Voice/emergency call barred notification disabled"); return; } } } CharSequence details = "";
code_review:  exceeds 100 chars 
target code: private void setNotification(int notifyType) { if (DBG) log("setNotification: create notification " + notifyType); // Needed because sprout RIL sends these when they shouldn't? boolean isSetNotification = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access); if (!isSetNotification) { if (DBG) log("Ignore all the notifications"); return; } Context context = mPhone.getContext(); CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE); if (configManager != null) { PersistableBundle bundle = configManager.getConfig(); if (bundle != null) { boolean disableVoiceBarringNotification = bundle.getBoolean( CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false); if(disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) { if (DBG) log("Voice/emergency call barred notification disabled"); return; } } } CharSequence details = "";
response: public void setNotification(int notifyType) { if (DBG) log("setNotification: create notification " + notifyType); boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access); if (!isSetNotification) { if (DBG) log("Ignore all the notifications"); return; } Context context = mPhone.getContext(); CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE); if (configManager != null) { PersistableBundle bundle = configManager.getConfig(); if (bundle != null) { boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false); if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) { if (DBG) log("Voice/emergency call barred notification disabled"); return; } } } CharSequence details = ""; // rest of the code }

sample: 262
buggy_code: <|startfocus|> public void prepareForConnectionAttempt(int netId) { localLog("prepareForConnectionAttempt: netId=" + netId); <|endfocus|> clearConnectionAttemptTimeStamps(); clearBssidBlacklist();
code_review:  the name for this seems like it could be a general case. maybe something like clearBlacklistForForcedConnection ? 
target code: public void prepareForForcedConnection(int netId) { localLog("prepareForForcedConnection: netId=" + netId); clearConnectionAttemptTimeStamps(); clearBssidBlacklist();
response: public void clearBlacklistForForcedConnection(int netId) { localLog("clearBlacklistForForcedConnection: netId=" + netId); clearConnectionAttemptTimeStamps(); clearBssidBlacklist(); }

sample: 263
buggy_code:  long timeStamp = clock.getElapsedSinceBootMillis(); for (int index = 0; index < ssids.length; index++) { ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssids[index]), bssids[index], caps[index], levels[index], freqs[index], timeStamp, 0); scanDetailList.add(scanDetail); } return scanDetailList; } /** * Generate an array of {@link android.net.wifi.WifiConfiguration} based on the caller <|startfocus|> * supplied network SSID and sencurity information. <|endfocus|> * * @param ssids an array of SSIDs * @param securities an array of the network's security setting * @return the constructed array of {@link android.net.wifi.WifiConfiguration} */ public static WifiConfiguration[] generateWifiConfigurations(String[] ssids, int[] securities) { if (ssids == null || securities == null || ssids.length != securities.length || ssids.length == 0) { return null; } Map<String, Integer> netIdMap = new HashMap<>(); int netId = 0; 
code_review:  spelling (sorry, i just happened to see it :) ) 
target code: long timeStamp = clock.getElapsedSinceBootMillis(); for (int index = 0; index < ssids.length; index++) { ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssids[index]), bssids[index], caps[index], levels[index], freqs[index], timeStamp, 0); scanDetailList.add(scanDetail); } return scanDetailList; } /** * Generate an array of {@link android.net.wifi.WifiConfiguration} based on the caller * supplied network SSID and security information. * * @param ssids an array of SSIDs * @param securities an array of the network's security setting * @return the constructed array of {@link android.net.wifi.WifiConfiguration} */ public static WifiConfiguration[] generateWifiConfigurations(String[] ssids, int[] securities) { if (ssids == null || securities == null || ssids.length != securities.length || ssids.length == 0) { return null; } Map<String, Integer> netIdMap = new HashMap<>(); int netId = 0;
response: long timeStamp = clock.getElapsedSinceBootMillis(); for (int index = 0; index < ssids.length; index++) { ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssids[index]), bssids[index], caps[index], levels[index], freqs[index], timeStamp, 0); scanDetailList.add(scanDetail); } return scanDetailList; } /** * Generate an array of {@link android.net.wifi.WifiConfiguration} based on the caller * supplied network SSID and security information. * * @param ssids an array of SSIDs * @param securities an array of the network's security setting * @return the constructed array of {@link android.net.wifi.WifiConfiguration} */ public static WifiConfiguration[] generateWifiConfigurations(String[] ssids, int[] securities) { if (ssids == null || securities == null || ssids.length != securities.length || ssids.length == 0) { return null; } Map<String, Integer> netIdMap = new HashMap<>(); int netId = 0;

sample: 264
buggy_code:  MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, workQueue); for (int i = 1; i < mPackages.size(); i++) { final AppPrefLoader loader = new AppPrefLoader(); loader.executeOnExecutor(executor, mPackages.valueAt(i)); } } else { removePreference(KEY_APP_LIST); } } else { final Context context = getActivity(); <|startfocus|> UidDetail mUidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = mUidDetail.icon; mLabel = mUidDetail.label; <|endfocus|> mPackageName = context.getPackageName(); removePreference(KEY_UNRESTRICTED_DATA); removePreference(KEY_APP_SETTINGS); removePreference(KEY_RESTRICT_BACKGROUND); removePreference(KEY_APP_LIST); }
code_review:  This doesn't compile, UidDetail isn't imported. 
target code: MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, workQueue); for (int i = 1; i < mPackages.size(); i++) { final AppPrefLoader loader = new AppPrefLoader(); loader.executeOnExecutor(executor, mPackages.valueAt(i)); } } else { removePreference(KEY_APP_LIST); } } else { final Context context = getActivity(); UidDetail uidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = uidDetail.icon; mLabel = uidDetail.label; mPackageName = context.getPackageName(); removePreference(KEY_UNRESTRICTED_DATA); removePreference(KEY_APP_SETTINGS); removePreference(KEY_RESTRICT_BACKGROUND); removePreference(KEY_APP_LIST); }
response: private void readConfiguration() { String configEntry = cfgFactory.getFromGerritConfig(CHARSET_VALIDATOR) .getString("branch_regex", "^[a-z0-9_\\-/]+$"); if (regexpPattern == null || regexpPattern.hashCode() != configEntry.hashCode()) { okCharPattern = Pattern.compile(configEntry); regexpPattern = configEntry; } rejectReasonBranch = cfgFactory.getFromGerritConfig(CHARSET_VALIDATOR) .getString("branch_reject_reason", "Sorry, your branch is not valid."); rejectReasonCharset = cfgFactory.getFromGerritConfig(CHARSET_VALIDATOR) .getString("charset_reject_reason", "Sorry, your commit has non UTF8 content."); internalErrorMessage = cfgFactory.getFromGerritConfig(CHARSET_VALIDATOR) .getString("internal_error_message", "CharSetValidator failed to validate your commit."); fastUtf8Check = cfgFactory.getFromGerritConfig(CHARSET_VALIDATOR) .getBoolean("fast_utf8_check", true); validateUtf8 = cfgFactory.getFromGerritConfig(CHARSET_VALIDATOR) .getBoolean("validate_utf8", true); PluginConfig cfg = cfgFactory.getFromProjectConfig(); } throw new ResourceConflictException("change is " + status(change)); } else if (change.getStatus() == Change.Status.DRAFT) { throw new ResourceConflictException("draft changes cannot be abandoned"); } final AtomicReference<Change> updatedChange = new AtomicReference<>(); ChangeUpdate update; bu.addChangeOp(new ChangeOp(control) { @Override public void call(ReviewDb db, ChangeUpdate update) throws Exception { updatedChange.set(db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() { @Override public Change update(Change change) { if (change.getStatus().isOpen()) { change.setStatus(Change.Status.ABANDONED); ChangeUtil.updated(change); return change; } return null; } })); if (c == null) { throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId()))); } ChangeMessage message; //TODO(yyonas): atomic update was not propagated } }); public void cleanup() { db.close(); } @Test public void messagesNotReturned

sample: 265
buggy_code:  MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, workQueue); for (int i = 1; i < mPackages.size(); i++) { final AppPrefLoader loader = new AppPrefLoader(); loader.executeOnExecutor(executor, mPackages.valueAt(i)); } } else { removePreference(KEY_APP_LIST); } } else { final Context context = getActivity(); <|startfocus|> UidDetail mUidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = mUidDetail.icon; mLabel = mUidDetail.label; <|endfocus|> mPackageName = context.getPackageName(); removePreference(KEY_UNRESTRICTED_DATA); removePreference(KEY_APP_SETTINGS); removePreference(KEY_RESTRICT_BACKGROUND); removePreference(KEY_APP_LIST); }
code_review:  just uidDetail, it's not a member variable so calling it mUidDetail would be strange. 
target code: MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, workQueue); for (int i = 1; i < mPackages.size(); i++) { final AppPrefLoader loader = new AppPrefLoader(); loader.executeOnExecutor(executor, mPackages.valueAt(i)); } } else { removePreference(KEY_APP_LIST); } } else { final Context context = getActivity(); UidDetail uidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = uidDetail.icon; mLabel = uidDetail.label; mPackageName = context.getPackageName(); removePreference(KEY_UNRESTRICTED_DATA); removePreference(KEY_APP_SETTINGS); removePreference(KEY_RESTRICT_BACKGROUND); removePreference(KEY_APP_LIST); }
response: MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, workQueue); for (int i = 1; i < mPackages.size(); i++) { final AppPrefLoader loader = new AppPrefLoader(); loader.executeOnExecutor(executor, mPackages.valueAt(i)); } } else { removePreference(KEY_APP_LIST); } } else { final Context context = getActivity(); UidDetail uidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = uidDetail.icon; mLabel = uidDetail.label; mPackageName = context.getPackageName(); removePreference(KEY_UNRESTRICTED_DATA); removePreference(KEY_APP_SETTINGS); removePreference(KEY_RESTRICT_BACKGROUND); removePreference(KEY_APP_LIST); }

sample: 266
buggy_code:  private void setConnectingThread(final Thread thread) { final Thread oldThread = mConnectingThread.getAndSet(thread); if (oldThread != null) { <|startfocus|> try { oldThread.interrupt(); } catch (SecurityException e) { Log.e(TAG, "Interrupting thread", e); } <|endfocus|> }
code_review:  this will never be thrown on Android (i should go modify the docs to stop claiming this happens) 
target code: private void setConnectingThread(final Thread thread) { final Thread oldThread = mConnectingThread.getAndSet(thread); if (oldThread != null) { oldThread.interrupt(); }
response: private void setConnectingThread(final Thread thread) { final Thread oldThread = mConnectingThread.getAndSet(thread); if (oldThread != null) { try { oldThread.interrupt(); } catch (SecurityException e) { Log.e(TAG, "Interrupting thread", e); } } }

sample: 267
buggy_code:  */ @HasKeyId @Name("BoostLockedRegionPriorityFeature") @Description("Feature turning on BoostLockedRegionPriorityFeature") public final class BoostLockedRegionPriorityFeature implements Feature { @Nonnull public static final BooleanPropertyId ENABLE = BooleanPropertyId.create( "jack.transformations.boost-locked-region-priority", "Boost priority of threads acquiring certain locks") .addCategory(Private.class) .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class); @Nonnull <|startfocus|> public static final PropertyId<String> BOOST_LOCK_CLASSNAME = <|endfocus|> PropertyId.create( "jack.transformations.boost-locked-region-priority.classname", "The class signatures where acquiring it as a lock should boost a thread's prioirty", new ClassNameCodec()) .requiredIf(BoostLockedRegionPriorityFeature.ENABLE.getValue().isTrue()) .addCategory(Private.class) .addCategory(DumpInLibrary.class); @Nonnull public static final PropertyId<List<MethodNameValue>> BOOST_LOCK_REQUEST_METHOD = PropertyId.create( "jack.transformations.boost-locked-region-priority.request", "Static methods in the specified classes that can boost a thread's prioirty",
code_review:  Why not use a List and a ListCodec here? 
target code: */ @HasKeyId @Name("BoostLockedRegionPriorityFeature") @Description("Feature turning on BoostLockedRegionPriorityFeature") public final class BoostLockedRegionPriorityFeature implements Feature { @Nonnull public static final BooleanPropertyId ENABLE = BooleanPropertyId.create( "jack.transformations.boost-locked-region-priority", "Boost priority of threads acquiring certain locks") .addCategory(Private.class) .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class); @Nonnull public static final PropertyId<List<String>> BOOST_LOCK_CLASSNAME = PropertyId.create( "jack.transformations.boost-locked-region-priority.classname", "The class signatures where acquiring it as a lock should boost a thread's prioirty", new ClassNameCodec()) .requiredIf(BoostLockedRegionPriorityFeature.ENABLE.getValue().isTrue()) .addCategory(Private.class) .addCategory(DumpInLibrary.class); @Nonnull public static final PropertyId<List<MethodNameValue>> BOOST_LOCK_REQUEST_METHOD = PropertyId.create( "jack.transformations.boost-locked-region-priority.request", "Static methods in the specified classes that can boost a thread's prioirty",
response: */ @HasKeyId @Name("BoostLockedRegionPriorityFeature") @Description("Feature turning on BoostLockedRegionPriorityFeature") public final class BoostLockedRegionPriorityFeature implements Feature { @Nonnull public static final BooleanPropertyId ENABLE = BooleanPropertyId.create( "jack.transformations.boost-locked-region-priority", "Boost priority of threads acquiring certain locks") .addCategory(Private.class) .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class); @Nonnull public static final PropertyId<String> BOOST_LOCK_CLASSNAME = PropertyId.create( "jack.transformations.boost-locked-region-priority.classname", "The class signatures where acquiring it as a lock should boost a thread's prioirty", new ClassNameCodec()) .requiredIf(BoostLockedRegionPriorityFeature.ENABLE.getValue().isTrue()) .addCategory(Private.class) .addCategory(DumpInLibrary.class); @Nonnull public static final PropertyId<List<MethodNameValue>> BOOST_LOCK_REQUEST_METHOD = PropertyId.create( "jack.transformations.boost-locked-region-priority.request", "Static methods in the specified classes that can boost a thread's prioirty", new ListCodec<>(new MethodNameValueCodec())) .requiredIf(BoostLockedRegionPriorityFeature.ENABLE.getValue().isTrue()) .addCategory(Private.class) .addCategory(DumpInLibrary.class);

sample: 268
buggy_code:  Jack.getSession().getReporter().report(Severity.FATAL, new BadBoostLockedRegionPriorityConfigurationException(prop, e)); Jack.getSession().abortEventually(); return null; } } @Override public void run(@Nonnull JMethod method) { if (method.isNative() || method.isAbstract() || !filter.accept(this.getClass(), method)) { return; } <|startfocus|> if (lockClass == null || requestClass == null || resetClass == null || requestMethodId == null || resetMethodId == null) { <|endfocus|> return; } TransformationRequest tr = new TransformationRequest(method); Visitor visitor = new Visitor(method, tr); visitor.accept(method); tr.commit(); } private class Visitor extends JVisitor { @Nonnull private final JMethod method; @Nonnull private final TransformationRequest tr; public Visitor(@Nonnull JMethod method, @Nonnull TransformationRequest tr) { this.method = method; this.tr = tr; } @Override public void endVisit(@Nonnull JLock jLock) { assert lockClass != null; int lockIndex = -1;
code_review:  lockClass is @Nonnull. If you want to shortcut, use lockClass.lenth == 0 ... 
target code: Jack.getSession().getReporter().report(Severity.FATAL, new BadBoostLockedRegionPriorityConfigurationException(prop, e)); Jack.getSession().abortEventually(); return null; } } @Override public void run(@Nonnull JMethod method) { if (method.isNative() || method.isAbstract() || !filter.accept(this.getClass(), method)) { return; } if (lockClass.length == 0) { return; } TransformationRequest tr = new TransformationRequest(method); Visitor visitor = new Visitor(method, tr); visitor.accept(method); tr.commit(); } private class Visitor extends JVisitor { @Nonnull private final JMethod method; @Nonnull private final TransformationRequest tr; public Visitor(@Nonnull JMethod method, @Nonnull TransformationRequest tr) { this.method = method; this.tr = tr; } @Override public void endVisit(@Nonnull JLock jLock) { assert lockClass != null; int lockIndex = -1;
response: Jack.getSession().getReporter().report(Severity.FATAL, new BadBoostLockedRegionPriorityConfigurationException(prop, e)); Jack.getSession().abortEventually(); return null; } @Override public void run(@Nonnull JMethod method) { if (method.isNative() || method.isAbstract() || !filter.accept(this.getClass(), method)) { return; } if (lockClass == null || requestClass == null || resetClass == null || requestMethodId == null || resetMethodId == null) { return; } TransformationRequest tr = new TransformationRequest(method); Visitor visitor = new Visitor(method, tr); visitor.accept(method); tr.commit(); } private class Visitor extends JVisitor { @Nonnull private final JMethod method; @Nonnull private final TransformationRequest tr; public Visitor(@Nonnull JMethod method, @Nonnull TransformationRequest tr) { this.method = method; this.tr = tr; } @Override public void endVisit(@Nonnull JLock jLock) { assert lockClass != null; int lockIndex = -1; // rest of the code } }

sample: 269
buggy_code:  * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) <|startfocus|> * 2.5 .equals return true <|endfocus|> */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; } 
code_review:  we don't have these in HIDL anyway, so you would never get this? Also you seem to throw UnsupportedOperation on these 
target code: * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) * 2.5 lft.equals(rgt) returns true */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; }
response: public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; } if (lftElementType.isPrimitive()) { if (lftElementType == boolean.class) { return Arrays.equals((boolean[]) lft, (boolean[]) rgt); } else if (lftElementType == byte.class) { return Arrays.equals((byte[]) lft, (byte[]) rgt); } else if (lftElementType == char.class) { return Arrays.equals((char[]) lft, (char[]) rgt); } else if (lftElementType == short.class) { return Arrays.equals((short[]) lft, (short[]) rgt); } else if (lftElementType == int.class) { return Arrays.equals((int[]) lft, (int[]) rgt); } else if (lftElementType == long.class) { return Arrays.equals((long[]) lft, (long[]) rgt); } else if (lftElementType == float.class) { return Arrays.equals((float[]) lft, (float[]) rgt); } else if (lftElementType == double.class) { return Arrays.equals((double[]) lft, (double[]) rgt); } } else { Object[] lftArray = (Object[]) lft; Object[] rgtArray = (Object[]) rgt; if (lftArray.length != rgtArray.length) { return false; } for (int i = 0; i < lftArray.length; i++) { if (!deepEquals(lftArray[i], rgtArray[i])) { return false; } } return true; } } else if (lft instanceof List && rgt instanceof List) { List<?> lftList = (List<?>)

sample: 270
buggy_code:  * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) <|startfocus|> * 2.5 .equals return true <|endfocus|> */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; } 
code_review:  nit: returns 
target code: * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) * 2.5 lft.equals(rgt) returns true */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; }
response: public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; } if (lftElementType.isPrimitive()) { if (lftElementType == boolean.class) { return Arrays.equals((boolean[]) lft, (boolean[]) rgt); } else if (lftElementType == byte.class) { return Arrays.equals((byte[]) lft, (byte[]) rgt); } else if (lftElementType == char.class) { return Arrays.equals((char[]) lft, (char[]) rgt); } else if (lftElementType == short.class) { return Arrays.equals((short[]) lft, (short[]) rgt); } else if (lftElementType == int.class) { return Arrays.equals((int[]) lft, (int[]) rgt); } else if (lftElementType == long.class) { return Arrays.equals((long[]) lft, (long[]) rgt); } else if (lftElementType == float.class) { return Arrays.equals((float[]) lft, (float[]) rgt); } else if (lftElementType == double.class) { return Arrays.equals((double[]) lft, (double[]) rgt); } } else { Object[] lftArray = (Object[]) lft; Object[] rgtArray = (Object[]) rgt; if (lftArray.length != rgtArray.length) { return false; } for (int i = 0; i < lftArray.length; i++) { if (!deepEquals(lftArray[i], rgtArray[i])) { return false; } } return true; } } else if (lft instanceof List && rgt instanceof List) { List<?> lftList = (List<?>)

sample: 271
buggy_code:  * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) <|startfocus|> * 2.5 .equals return true <|endfocus|> */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; } 
code_review:  which equals? 
target code: * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) * 2.5 lft.equals(rgt) returns true */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; }
response: * Two objects of HIDL types are considered equal if: * 1. Both null * 2. Both non-null, and of the same class, and: * 2.1 Both are primitive arrays / enum arrays, elements are equal using == check * 2.2 Both are object arrays, elements are checked recursively * 2.3 Both are Lists, elements are checked recursively * 2.4 (If both are collections other than lists or maps, undefined behavior) * 2.5 .equals return true */ public static boolean deepEquals(Object lft, Object rgt) { if (lft == rgt) { return true; } if (lft == null || rgt == null) { return false; } Class<?> lftClazz = lft.getClass(); Class<?> rgtClazz = rgt.getClass(); if (lftClazz != rgtClazz) { return false; } if (lftClazz.isArray()) { Class<?> lftElementType = lftClazz.getComponentType(); if (lftElementType != rgtClazz.getComponentType()) { return false; } // Rest of the code... } // Rest of the code... }

sample: 272
buggy_code:  } String invokeWith = null; if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) { // Debuggable apps may include a wrapper script with their library directory. String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh"; StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); try { if (new File(wrapperFileName).exists()) { invokeWith = "/system/bin/logwrapper " + wrapperFileName; } } finally { <|startfocus|> StrictMode.setThreadPolicy(oldPolicy); <|endfocus|> } } String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) { requiredAbi = Build.SUPPORTED_ABIS[0]; } String instructionSet = null; if (app.info.primaryCpuAbi != null) { instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi); } app.gids = gids; app.requiredAbi = requiredAbi; app.instructionSet = instructionSet; // Start the process. It will either succeed and return a result containing
code_review:  inconsistent indent. 
target code: } String invokeWith = null; if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) { // Debuggable apps may include a wrapper script with their library directory. String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh"; StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); try { if (new File(wrapperFileName).exists()) { invokeWith = "/system/bin/logwrapper " + wrapperFileName; } } finally { StrictMode.setThreadPolicy(oldPolicy); } } String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) { requiredAbi = Build.SUPPORTED_ABIS[0]; } String instructionSet = null; if (app.info.primaryCpuAbi != null) { instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi); } app.gids = gids; app.requiredAbi = requiredAbi; app.instructionSet = instructionSet; // Start the process. It will either succeed and return a result containing
response: import java.io.File; import android.os.StrictMode; import dalvik.system.VMRuntime; String invokeWith = null; if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) { String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh"; StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); try { if (new File(wrapperFileName).exists()) { invokeWith = "/system/bin/logwrapper " + wrapperFileName; } } finally { StrictMode.setThreadPolicy(oldPolicy); } } String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) { requiredAbi = Build.SUPPORTED_ABIS[0]; } String instructionSet = null; if (app.info.primaryCpuAbi != null) { instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi); } app.gids = gids; app.requiredAbi = requiredAbi; app.instructionSet = instructionSet; // Start the process. It will either succeed and return a result containing...

sample: 273
buggy_code:  loge("setWfcSetting(): ", e); } } } /** * Change persistent WFC enabled setting for slot. */ public void setWfcSettingForSlot(boolean enabled) { int value = enabled ? 1 : 0; android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value); setWfcSettingInternalForSlot(enabled, getWfcModeForSlot()); } /** <|startfocus|> * Non-persistently change WFC eanbled setting and WFC preference for slot <|endfocus|> * * @param wfcMode The WFC preference if WFC is enabled */ public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; // Force IMS to register over LTE when turning off WFC int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN,
code_review:  and WFC Mode 
target code: loge("setWfcSetting(): ", e); } } } /** * Change persistent WFC enabled setting for slot. */ public void setWfcSettingForSlot(boolean enabled) { int value = enabled ? 1 : 0; android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value); setWfcSettingInternalForSlot(enabled, getWfcModeForSlot()); } /** * Non-persistently change WFC enabled setting and WFC mode for slot * * @param wfcMode The WFC preference if WFC is enabled */ public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; // Force IMS to register over LTE when turning off WFC int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN,
response: loge("setWfcSetting(): ", e); } } } public void setWfcSettingForSlot(boolean enabled) { int value = enabled ? 1 : 0; android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value); setWfcSettingInternalForSlot(enabled, getWfcModeForSlot()); } public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI_PREFERRED, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI_PREFERRED, ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED, imsWfcModeFeatureValue); } catch (ImsException e) { loge("setWfcSettingInternalForSlot(): ", e); } }

sample: 274
buggy_code:  loge("setWfcSetting(): ", e); } } } /** * Change persistent WFC enabled setting for slot. */ public void setWfcSettingForSlot(boolean enabled) { int value = enabled ? 1 : 0; android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value); setWfcSettingInternalForSlot(enabled, getWfcModeForSlot()); } /** <|startfocus|> * Non-persistently change WFC eanbled setting and WFC preference for slot <|endfocus|> * * @param wfcMode The WFC preference if WFC is enabled */ public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; // Force IMS to register over LTE when turning off WFC int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN,
code_review:  enabled 
target code: loge("setWfcSetting(): ", e); } } } /** * Change persistent WFC enabled setting for slot. */ public void setWfcSettingForSlot(boolean enabled) { int value = enabled ? 1 : 0; android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value); setWfcSettingInternalForSlot(enabled, getWfcModeForSlot()); } /** * Non-persistently change WFC enabled setting and WFC mode for slot * * @param wfcMode The WFC preference if WFC is enabled */ public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; // Force IMS to register over LTE when turning off WFC int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN,
response: public void setWfcSettingForSlot(boolean enabled) { int value = enabled ? 1 : 0; android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value); setWfcSettingInternalForSlot(enabled, getWfcModeForSlot()); } public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI_PREFERRED, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI_PREFERRED, TelephonyManager.NETWORK_TYPE_LTE, imsFeatureValue); config.setWfcMode(ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED); config.setWfcMode(ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED); config.setWfcMode(imsWfcModeFeatureValue); } catch (ImsException e) { loge("setWfcSettingInternalForSlot(): ", e); } }

sample: 275
buggy_code: <|startfocus|> public void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { <|endfocus|> int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; // Force IMS to register over LTE when turning off WFC int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue, mImsConfigListener); if (enabled) { log("setWfcSettingForSlot() : turnOnIms"); turnOnIms(); } else if (isTurnOffImsAllowedByPlatformForSlot() && (!isVolteEnabledByPlatformForSlot() || !isEnhanced4gLteModeSettingEnabledByUserForSlot())) { log("setWfcSettingForSlot() : imsServiceAllowTurnOff -> turnOffIms"); turnOffIms(); } setWfcModeInternalForSlot(imsWfcModeFeatureValue); } catch (ImsException e) { loge("setWfcSettingForSlot(): ", e); }
code_review:  Should this be public if it is "Internal"? 
target code: public void setWfcNonPersistentForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; // Force IMS to register over LTE when turning off WFC int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue, mImsConfigListener); if (enabled) { log("setWfcSettingForSlot() : turnOnIms"); turnOnIms(); } else if (isTurnOffImsAllowedByPlatformForSlot() && (!isVolteEnabledByPlatformForSlot() || !isEnhanced4gLteModeSettingEnabledByUserForSlot())) { log("setWfcSettingForSlot() : imsServiceAllowTurnOff -> turnOffIms"); turnOffIms(); } setWfcModeInternalForSlot(imsWfcModeFeatureValue); } catch (ImsException e) { loge("setWfcSettingForSlot(): ", e); }
response: private void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) { int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF; int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED; try { ImsConfig config = getConfigInterface(); config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue, mImsConfigListener); if (enabled) { log("setWfcSettingForSlot() : turnOnIms"); turnOnIms(); } else if (isTurnOffImsAllowedByPlatformForSlot() && (!isVolteEnabledByPlatformForSlot() || !isEnhanced4gLteModeSettingEnabledByUserForSlot())) { log("setWfcSettingForSlot() : imsServiceAllowTurnOff -> turnOffIms"); turnOffIms(); } setWfcModeInternalForSlot(imsWfcModeFeatureValue); } catch (ImsException e) { loge("setWfcSettingForSlot(): ", e); } }

sample: 276
buggy_code:  * <h3>Developer Guides</h3> * <p>For more information about using Bluetooth, read the * <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.</p> * </div> * * {@see BluetoothServerSocket} * {@see java.io.InputStream} * {@see java.io.OutputStream} */ public final class BluetoothSocket implements Closeable { private static final String TAG = "BluetoothSocket"; <|startfocus|> private static final boolean DBG = true; <|endfocus|> private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE); /** @hide */ public static final int MAX_RFCOMM_CHANNEL = 30; /*package*/ static final int MAX_L2CAP_PACKAGE_SIZE = 0xFFFF; /** RFCOMM socket */ public static final int TYPE_RFCOMM = 1; /** SCO socket */ public static final int TYPE_SCO = 2; /** L2CAP socket */ public static final int TYPE_L2CAP = 3; /*package*/ static final int EBADFD = 77; /*package*/ static final int EADDRINUSE = 98; 
code_review:  Intentional? 
target code: * <h3>Developer Guides</h3> * <p>For more information about using Bluetooth, read the * <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.</p> * </div> * * {@see BluetoothServerSocket} * {@see java.io.InputStream} * {@see java.io.OutputStream} */ public final class BluetoothSocket implements Closeable { private static final String TAG = "BluetoothSocket"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE); /** @hide */ public static final int MAX_RFCOMM_CHANNEL = 30; /*package*/ static final int MAX_L2CAP_PACKAGE_SIZE = 0xFFFF; /** RFCOMM socket */ public static final int TYPE_RFCOMM = 1; /** SCO socket */ public static final int TYPE_SCO = 2; /** L2CAP socket */ public static final int TYPE_L2CAP = 3; /*package*/ static final int EBADFD = 77; /*package*/ static final int EADDRINUSE = 98;
response: /** * <h3>Developer Guides</h3> * <p>For more information about using Bluetooth, read the * <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.</p> * </div> * * {@see BluetoothServerSocket} * {@see java.io.InputStream} * {@see java.io.OutputStream} */ public final class BluetoothSocket implements Closeable { private static final String TAG = "BluetoothSocket"; private static final boolean DBG = true; private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE); /** @hide */ public static final int MAX_RFCOMM_CHANNEL = 30; /*package*/ static final int MAX_L2CAP_PACKAGE_SIZE = 0xFFFF; /** RFCOMM socket */ public static final int TYPE_RFCOMM = 1; /** SCO socket */ public static final int TYPE_SCO = 2; /** L2CAP socket */ public static final int TYPE_L2CAP = 3; /*package*/ static final int EBADFD = 77; /*package*/ static final int EADDRINUSE = 98; }

sample: 277
buggy_code:  public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier"); } <|startfocus|> if (mNetworkSpecifier != null) { throw new IllegalStateException("Network specifier already set"); } <|endfocus|> if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } mNetworkSpecifier = networkSpecifier; return this;
code_review:  What was the purpose of this? This wasn't there in the original (pre-NS-as-object) code? This actually busted some existing Wi-Fi Aware code. It doesn't allow copying and modifying NetworkCapabilities. I don't see an issue with allowing an overwrite. 
target code: public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier"); } if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } mNetworkSpecifier = networkSpecifier; return this;
response: public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use setNetworkSpecifier"); } if (mNetworkSpecifier != null) { throw new IllegalStateException("Network specifier already set"); } if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } mNetworkSpecifier = networkSpecifier; return this; }

sample: 278
buggy_code:  public boolean equals(Object o) { <|startfocus|> return o != null && o instanceof MatchAllNetworkSpecifier; <|endfocus|>
code_review:  instanceof already contains an implicit null guard, i.e null cannot match anything with instanceof. 
target code: public boolean equals(Object o) { return o instanceof MatchAllNetworkSpecifier;
response: public boolean equals(Object o) { return o instanceof MatchAllNetworkSpecifier; }

sample: 279
buggy_code:  public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier"); } <|startfocus|> if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } <|endfocus|> mNetworkSpecifier = networkSpecifier; return this;
code_review:  implicitly in the instanceof check. 
target code: public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier"); } mNetworkSpecifier = networkSpecifier; return this;
response: public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use setNetworkSpecifier"); } if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } mNetworkSpecifier = networkSpecifier; return this; }

sample: 280
buggy_code:  private boolean satisfiedBySpecifier(NetworkCapabilities nc) { <|startfocus|> return mNetworkSpecifier == null || mNetworkSpecifier.satisfiedBy(nc.mNetworkSpecifier) || nc.mNetworkSpecifier instanceof MatchAllNetworkSpecifier; <|endfocus|>
code_review:  Just checking: isn't the normal java format style to put the "||" or "&&" at the beginning of the next line ? 
target code: private boolean satisfiedBySpecifier(NetworkCapabilities nc) { return mNetworkSpecifier == null || mNetworkSpecifier.satisfiedBy(nc.mNetworkSpecifier) || nc.mNetworkSpecifier instanceof MatchAllNetworkSpecifier;
response: private boolean satisfiedBySpecifier(NetworkCapabilities nc) { return mNetworkSpecifier == null || mNetworkSpecifier.satisfiedBy(nc.mNetworkSpecifier) || nc.mNetworkSpecifier instanceof MatchAllNetworkSpecifier; }

sample: 281
buggy_code:  (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); <|startfocus|> dest.writeParcelable((Parcelable) mNetworkSpecifier, 0); <|endfocus|> dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override
code_review:  Why the cast ? 
target code: (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override
response: public LSMInvertedIndexDiskComponent(IInvertedIndex invIndex, BTree deletedKeysBTree, BloomFilter bloomFilter, ILSMComponentFilter filter) { super(invIndex.getMainIndex().getPageManager(), filter); this.invIndex = invIndex; this.deletedKeysBTree = deletedKeysBTree; this.bloomFilter = bloomFilter; } public void testCouchbaseBean() { final String key = "SpringCouchbase" + System.currentTimeMillis(); final String value = "Spring/Couchbase"; BeanFactory beanFactory = new ClassPathXmlApplicationContext("cbGenerate.xml"); CouchbaseClient c = beanFactory.getBean("couchbaseClient", CouchbaseClient.class); c.set(key, 0, value); assertEquals(value, c.get(key)); c.delete(key); c.shutdown(3, TimeUnit.SECONDS); } // override by higher priority values. // In the case of a platform with override values from the user, the skin value might // already be there, but it's ok. HashMap<String, String> finalHardwareValues = new HashMap<String, String>(); File targetHardwareFile = new File(target.getLocation(), AvdManager.HARDWARE_INI); if (targetHardwareFile.isFile()) { Map<String, String> targetHardwareConfig = ProjectProperties.parsePropertyFile(new FileWrapper(targetHardwareFile), log); if (targetHardwareConfig != null) { finalHardwareValues.putAll(targetHardwareConfig); values.putAll(targetHardwareConfig); } } // get the hardware properties for this skin File skinFolder = getSkinPath(skinName, target); File skinHardwareFile = new File(skinFolder, AvdManager.HARDWARE_INI); if (skinHardwareFile.isFile()) { Map<String, String> skinHardwareConfig = ProjectProperties.parsePropertyFile(new FileWrapper(skinHardwareFile), log); if (skinHardwareConfig != null) { finalHardwareValues.putAll(skinHardwareConfig); } } (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest

sample: 282
buggy_code:  (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); <|startfocus|> dest.writeParcelable((Parcelable) mNetworkSpecifier, 0); <|endfocus|> dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override
code_review:  pass the flags variable in. 
target code: (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override
response: (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override

sample: 283
buggy_code:  public StringNetworkSpecifier(String specifier) { <|startfocus|> if (TextUtils.isEmpty(specifier)) { throw new IllegalArgumentException("Network specifier must not be empty"); } <|endfocus|> this.specifier = specifier;
code_review:  Consider using Preconditions 
target code: public StringNetworkSpecifier(String specifier) { Preconditions.checkStringNotEmpty(specifier); this.specifier = specifier;
response: public StringNetworkSpecifier(String specifier) { Preconditions.checkArgument(!TextUtils.isEmpty(specifier), "Network specifier must not be empty"); this.specifier = specifier; }

sample: 284
buggy_code:  public boolean satisfiedBy(NetworkSpecifier other) { <|startfocus|> if (other == null) return false; if (!(other instanceof StringNetworkSpecifier)) return false; return specifier.equals(((StringNetworkSpecifier) other).specifier); <|endfocus|>
code_review:  Is there a way to reuse equals ? Besides the null check, logic looks identical. 
target code: public boolean satisfiedBy(NetworkSpecifier other) { return equals(other);
response: public boolean satisfiedBy(NetworkSpecifier other) { if (other == null || !(other instanceof StringNetworkSpecifier)) { return false; } return specifier.equals(((StringNetworkSpecifier) other).specifier); }

sample: 285
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; import android.os.Parcel; import android.os.Parcelable; import android.text.TextUtils; import java.util.Objects; /** @hide */ public final class StringNetworkSpecifier extends NetworkSpecifier implements Parcelable { public final String specifier; public StringNetworkSpecifier(String specifier) { if (TextUtils.isEmpty(specifier)) { throw new IllegalArgumentException("Network specifier must not be empty"); }
code_review:  7 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; import android.os.Parcel; import android.os.Parcelable; import android.text.TextUtils; import java.util.Objects; /** @hide */ public final class StringNetworkSpecifier extends NetworkSpecifier implements Parcelable { public final String specifier; public StringNetworkSpecifier(String specifier) { if (TextUtils.isEmpty(specifier)) { throw new IllegalArgumentException("Network specifier must not be empty"); }
response: package android.net; import android.os.Parcel; import android.os.Parcelable; import android.text.TextUtils; import java.util.Objects; /** @hide */ public final class StringNetworkSpecifier extends NetworkSpecifier implements Parcelable { public final String specifier; public StringNetworkSpecifier(String specifier) { if (TextUtils.isEmpty(specifier)) { throw new IllegalArgumentException("Network specifier must not be empty"); } this.specifier = specifier; } // Parcelable implementation public static final Creator<StringNetworkSpecifier> CREATOR = new Creator<StringNetworkSpecifier>() { @Override public StringNetworkSpecifier createFromParcel(Parcel in) { return new StringNetworkSpecifier(in.readString()); } @Override public StringNetworkSpecifier[] newArray(int size) { return new StringNetworkSpecifier[size]; } }; @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(specifier); } @Override public int describeContents() { return 0; } @Override public boolean satisfiedBy(NetworkSpecifier other) { if (other instanceof StringNetworkSpecifier) { StringNetworkSpecifier that = (StringNetworkSpecifier) other; return Objects.equals(specifier, that.specifier); } return false; } @Override public int hashCode() { return Objects.hash(specifier); } @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } StringNetworkSpecifier that = (StringNetworkSpecifier) obj; return Objects.equals(specifier, that.specifier); } }

sample: 286
buggy_code:  public boolean satisfiedBy(NetworkSpecifier other) { <|startfocus|> if (other == null) return true; <|endfocus|> if (!(other instanceof StringNetworkSpecifier)) return false; return specifier.equals(((StringNetworkSpecifier) other).specifier);
code_review:  "false"? 
target code: public boolean satisfiedBy(NetworkSpecifier other) { if (other == null) return false; if (!(other instanceof StringNetworkSpecifier)) return false; return specifier.equals(((StringNetworkSpecifier) other).specifier);
response: public boolean satisfiedBy(NetworkSpecifier other) { if (other == null) { return true; } if (!(other instanceof StringNetworkSpecifier)) { return false; } return specifier.equals(((StringNetworkSpecifier) other).specifier); }

sample: 287
buggy_code: <|startfocus|> private IpSecService(Context context, String socket) { <|endfocus|> mContext = context;
code_review:  The socket is no longer necessary, right? Can you remove it? 
target code: private IpSecService(Context context) { mContext = context;
response: private IpSecService(Context context) { mContext = context; }

sample: 288
buggy_code:  /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } <|startfocus|> static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); <|endfocus|> service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!"); } } private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t =
code_review:  Ditto. 
target code: /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context) throws InterruptedException { final IpSecService service = new IpSecService(context); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!"); } } private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t =
response: /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!"); } } private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t = new Thread(new Runnable() { @Override public void run() { synchronized (mLock) { try { if (!mNetdService.connect()) { Slog.e(TAG, "Failed to connect to NetD Native Service"); } } catch (RemoteException e) { Slog.e(TAG, "Failed to connect to NetD Native Service", e); } mLock.notifyAll(); } } }); t.start(); // Wait for the connection to be established synchronized (mLock) { mLock.wait(NETD_FETCH_TIMEOUT); } }

sample: 289
buggy_code:  /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } <|startfocus|> public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } <|endfocus|> public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!"); } } private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t = new Thread( new Runnable() { @Override public void run() { synchronized (mLock) { NetdService.get(NETD_FETCH_TIMEOUT); } }
code_review:  Ditto. 
target code: /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context, String socket) { mContext = context; } static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!"); } } private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t = new Thread( new Runnable() { @Override public void run() { synchronized (mLock) { NetdService.get(NETD_FETCH_TIMEOUT); } }
response: private static final String NETD_SERVICE_NAME = "netd"; private static final int NETD_FETCH_TIMEOUT = 5000; private Context mContext; private Object mLock = new Object(); private IpSecService(Context context, String socket) { mContext = context; } public static IpSecService create(Context context, String socket) throws InterruptedException { final IpSecService service = new IpSecService(context, socket); service.connectNativeNetdService(); return service; } public static IpSecService create(Context context) throws InterruptedException { return create(context, NETD_SERVICE_NAME); } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!"); } } private void connectNativeNetdService() { // Avoid blocking the system server to do this Thread t = new Thread(new Runnable() { @Override public void run() { synchronized (mLock) { NetdService.get(NETD_FETCH_TIMEOUT); } } }); t.start(); }

sample: 290
buggy_code:  } void unlinkDeathRecipient() { if (mBinder != null) { mBinder.unlinkToDeath(this, 0); } } protected void releaseResources() {} protected void nullifyRecord() {} public void binderDied() { Log.w(TAG, "IpSecService.SpiRecord binderDied(" + mBinder + ")"); } } <|startfocus|> private final HashMap<Integer, SpiRecord> mSpiRecords = new HashMap<>(); private final HashMap<Integer, TransformRecord> mTransformRecords = new HashMap<>(); <|endfocus|> /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context) { mContext = context; } static IpSecService create(Context context) throws InterruptedException { final IpSecService service = new IpSecService(context); service.connectNativeNetdService(); return service; } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else {
code_review:  If keys are ints, consider using a SparseArray instead if the number of entries is small or bounded. 
target code: } void unlinkDeathRecipient() { if (mBinder != null) { mBinder.unlinkToDeath(this, 0); } } protected void releaseResources() {} protected void nullifyRecord() {} public void binderDied() { Log.w(TAG, "IpSecService.SpiRecord binderDied(" + mBinder + ")"); } } private final SparseArray<SpiRecord> mSpiRecords = new SparseArray<>(); private final SparseArray<TransformRecord> mTransformRecords = new SparseArray<>(); /** * Constructs a new IpSecService instance * * @param context Binder context for this service */ private IpSecService(Context context) { mContext = context; } static IpSecService create(Context context) throws InterruptedException { final IpSecService service = new IpSecService(context); service.connectNativeNetdService(); return service; } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else {
response: private final SparseArray<SpiRecord> mSpiRecords = new SparseArray<>(); private final SparseArray<TransformRecord> mTransformRecords = new SparseArray<>(); private void unlinkDeathRecipient() { if (mBinder != null) { mBinder.unlinkToDeath(this, 0); } } protected void releaseResources() {} protected void nullifyRecord() {} public void binderDied() { Log.w(TAG, "IpSecService.SpiRecord binderDied(" + mBinder + ")"); } private IpSecService(Context context) { mContext = context; } static IpSecService create(Context context) throws InterruptedException { final IpSecService service = new IpSecService(context); service.connectNativeNetdService(); return service; } public void systemReady() { if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); } else { // Handle the case when Netd is not alive } }

sample: 291
buggy_code:  } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } synchronized (mSpiRecords) { mSpiRecords.put( resourceId, new SpiRecord(resourceId, direction, localAddress, remoteAddress, spi, binder)); } Bundle retBundle = new Bundle(3); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); <|startfocus|> return null; <|endfocus|>
code_review:  ?? 
target code: } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } synchronized (mSpiRecords) { mSpiRecords.put( resourceId, new SpiRecord(resourceId, direction, localAddress, remoteAddress, spi, binder)); } Bundle retBundle = new Bundle(3); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); return retBundle;
response: } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } synchronized (mSpiRecords) { mSpiRecords.put(resourceId, new SpiRecord(resourceId, direction, localAddress, remoteAddress, spi, binder)); } Bundle retBundle = new Bundle(3); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); return null;

sample: 292
buggy_code: <|startfocus|> public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { <|endfocus|> int resourceId = mNextTransformId.getAndIncrement(); for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, c.getSpi(direction), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "",
code_review:  Isn't there some minimal validation you should do here (same comment for other impl methods). For instance can c be null ? 
target code: public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { // TODO: Basic input validation here since it's coming over the Binder int resourceId = mNextTransformId.getAndIncrement(); for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, c.getSpi(direction), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "",
response: public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { int resourceId = mNextTransformId.getAndIncrement(); for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, c.getSpi(direction), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0); } catch (Exception e) { // Handle exception } } // Rest of the code }

sample: 293
buggy_code:  public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { int resourceId = mNextTransformId.getAndIncrement(); <|startfocus|> for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { <|endfocus|> IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, c.getSpi(direction), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0,
code_review:  Consider declaring this as a package private static final int[] DIRECTIONS = { OUT, IN }; Otherwise consider putting the block below in a helper priv method createTransportModeTransform(IpSecConfig c, IBinder binder, int direction) and do createTransportModeTransform(c, binder, DIRECTION_OUT); createTransportModeTransform(c, binder, DIRECTION_IN); (alternative is probably not convenient for control flow though). 
target code: public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { int resourceId = mNextTransformId.getAndIncrement(); for (int direction : DIRECTIONS) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, c.getSpi(direction), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0,
response: public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { int resourceId = mNextTransformId.getAndIncrement(); for (int direction : DIRECTIONS) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, c.getSpi(direction), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0); } catch (Exception e) { // Handle exception } } // Rest of the code } private static final int[] DIRECTIONS = {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN};

sample: 294
buggy_code:  (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, c.getEncapType(), c.getEncapLocalPort(), c.getEncapRemotePort()); if (result != c.getSpi(direction)) { Bundle retBundle = new Bundle(2); retBundle.putInt( IpSecTransform.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); <|startfocus|> retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_SPI); <|endfocus|> return retBundle; } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } synchronized (mTransformRecords) { mTransformRecords.put(resourceId, new TransformRecord(c, resourceId, binder)); } 
code_review:  It is a bit ugly and hard to read, but I am not sure how it could be improved really. Maybe you can define a "null" IpSecAlgorithm object that returns "", null and 0 for getName() getKey() getTruncationLengthBits. Then instead of doing three times (auth != null) xxx : yyy, you can simply do: IpSecAlgorithm auth = c.getAuthentication(direction); if (auth == null) { auth = IpSecAlgorithm.NULL; // or DEFAULT, or NONE, ... } 
target code: (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, c.getEncapType(), c.getEncapLocalPort(), c.getEncapRemotePort()); if (result != c.getSpi(direction)) { Bundle retBundle = new Bundle(2); retBundle.putInt( IpSecTransform.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt( IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_RESOURCE_ID); return retBundle; } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } synchronized (mTransformRecords) { mTransformRecords.put(resourceId, new TransformRecord(c, resourceId, binder)); }
response: (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, c.getEncapType(), c.getEncapLocalPort(), c.getEncapRemotePort()); if (result != c.getSpi(direction)) { Bundle retBundle = new Bundle(2); retBundle.putInt(IpSecTransform.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_SPI); return retBundle; } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } synchronized (mTransformRecords) { mTransformRecords.put(resourceId, new TransformRecord(c, resourceId, binder)); }

sample: 295
buggy_code:  (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, c.getEncapType(), c.getEncapLocalPort(), c.getEncapRemotePort()); if (result != c.getSpi(direction)) { Bundle retBundle = new Bundle(2); retBundle.putInt( IpSecTransform.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); <|startfocus|> retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_SPI); <|endfocus|> return retBundle; } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } synchronized (mTransformRecords) { mTransformRecords.put(resourceId, new TransformRecord(c, resourceId, binder)); } Bundle retBundle = new Bundle(2); retBundle.putInt(IpSecTransform.KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, resourceId); return retBundle;
code_review:  Could be a static final object with documentation: returned by xxx when yyy fails. 
target code: (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, c.getEncapType(), c.getEncapLocalPort(), c.getEncapRemotePort()); if (result != c.getSpi(direction)) { Bundle retBundle = new Bundle(2); retBundle.putInt( IpSecTransform.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt( IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_RESOURCE_ID); return retBundle; } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } synchronized (mTransformRecords) { mTransformRecords.put(resourceId, new TransformRecord(c, resourceId, binder)); } Bundle retBundle = new Bundle(2); retBundle.putInt(IpSecTransform.KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, resourceId); return retBundle;
response: (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, c.getEncapType(), c.getEncapLocalPort(), c.getEncapRemotePort()); if (result != c.getSpi(direction)) { Bundle retBundle = new Bundle(2); retBundle.putInt(IpSecTransform.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_SPI); return retBundle; } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } synchronized (mTransformRecords) { mTransformRecords.put(resourceId, new TransformRecord(c, resourceId, binder)); } Bundle retBundle = new Bundle(2); retBundle.putInt(IpSecTransform.KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, resourceId); return retBundle;

sample: 296
buggy_code:  public void deleteTransportModeTransform(int resourceId) { TransformRecord record; <|startfocus|> synchronized (mTransformRecords) { <|endfocus|> // We want to non-destructively get so that we can check credentials before removing this record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // remove from the DB because releasing might fail, but it won't ever succeed later mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord(); }
code_review:  should be in the sync block. 
target code: public void deleteTransportModeTransform(int resourceId) { TransformRecord record; synchronized (mTransformRecords) { TransformRecord record; // We want to non-destructively get so that we can check credentials before removing this record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // remove from the DB because releasing might fail, but it won't ever succeed later mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord(); }
response: public void deleteTransportModeTransform(int resourceId) { synchronized (mTransformRecords) { TransformRecord record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord(); } }

sample: 297
buggy_code:  record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } <|startfocus|> // remove from the DB because releasing might fail, but it won't ever succeed later mTransformRecords.remove(resourceId); <|endfocus|> record.releaseResources(); record.nullifyRecord(); }
code_review:  Is this failure detectable here ? If yes I suggest adding a log so that it can be discovered if there is a real issue going on. 
target code: record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); record.nullifyRecord(); }
response: throw new CmlpDataSrcException("Please provide a predictor", 400); if (!(codeCloudAuthorization != null) && !(codeCloudAuthorization.isEmpty())) { throw new CmlpDataSrcException("Please provide CodeCloudAuthorization header", 400); } if (!(objCatalog.getPublisherUrl() != null) && objCatalog.getPublisherUrl().isEmpty()) { throw new CmlpDataSrcException("Please provide a publisher URL", 400); } try { log.info("RestCatalogServiceImpl::updateCatalog()::intiating update request."); String responseCatalogKey = aCatalogService.updateCatalog(user, authorization, codeCloudAuthorization, catalogKey, objCatalog); log.info("RestCatalogServiceImpl::updateCatalog()::update completed for key: " + responseCatalogKey); URI location = new URI(url + objCatalog.getCatalogKey()); } catch (Exception e) { log.error("Exception in RestCatalogServiceImpl:updateCatalog" + e.getMessage()); aResponseMessage.setCode(500); aResponseMessage.setMessage(e.getMessage()); return Response.status(Status.BAD_REQUEST).entity(aResponseMessage).build(); } String branchName = refName.startsWith("refs/heads/") ? refName.substring(11) : ""; ProjectBranchKey pbKey = new ProjectBranchKey(projectName, branchName); if (event.getNewObjectId().equals(ObjectId.zeroId().toString())) { log.info("Project: " + projectName + "\nrefName: " + refName); } else if (REFS_CONFIG.equals(refName)) { processProjectConfigChange(event); } else if (enabledManifestSource.containsKey(projectName) && enabledManifestSource.get(projectName).getBranches().contains(branchName)) { processManifestChange(event, projectName, branchName); } else if (subscribedRepos.containsRow(pbKey)) { Map<String, Map<String, Set<com.amd.gerrit.plugins.manifestsubscription.manifest.Project>>> destinations = subscribedRepos.row(pbKey); } record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord();

sample: 298
buggy_code:  public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) { <|startfocus|> TransformRecord info; <|endfocus|> synchronized (mTransformRecords) { // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } IpSecConfig c = info.getConfig(); try { for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { getNetdInstance().ipSecApplyTransportModeTransform( socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "",
code_review:  Should be in the sync block 
target code: public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) { synchronized (mTransformRecords) { // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } IpSecConfig c = info.getConfig(); try { for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { getNetdInstance().ipSecApplyTransportModeTransform( socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "",
response: public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) { TransformRecord info; synchronized (mTransformRecords) { info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } } IpSecConfig c = info.getConfig(); try { for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { synchronized (mTransformRecords) { getNetdInstance().ipSecApplyTransportModeTransform( socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", c.getSpiResourceId(direction)); } } } catch (RemoteException | ServiceSpecificException e) { throw new IllegalStateException("Failed to communicate with IPsec service", e); } }

sample: 299
buggy_code: import static org.mockito.Mockito.atLeastOnce; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.validateMockitoUsage; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import android.content.Context; import android.net.wifi.WifiScanner.BssidInfo; import android.os.Handler; import android.os.Message; import android.os.test.TestLooper; import android.test.suitebuilder.annotation.SmallTest; import com.android.internal.util.test.BidirectionalAsyncChannelServer; import org.junit.After; import org.junit.Before; <|startfocus|> import org.junit.Test; import org.mockito.ArgumentCaptor; <|endfocus|> import org.mockito.Mock; import org.mockito.MockitoAnnotations; /** * Unit tests for {@link android.net.wifi.WifiScanner}. */ @SmallTest public class WifiScannerTest { @Mock private Context mContext; @Mock private IWifiScanner mService; private WifiScanner mWifiScanner; private TestLooper mLooper; private Handler mHandler; /** * Setup before tests. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); mLooper = new TestLooper(); mHandler = mock(Handler.class);
code_review:  It seems that this class is going to be dummy now. We might want to keep the class for future unit tests but at least we should remove unused imports. 
target code: import static org.mockito.Mockito.atLeastOnce; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.validateMockitoUsage; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import android.content.Context; import android.net.wifi.WifiScanner.BssidInfo; import android.os.Handler; import android.os.Message; import android.os.test.TestLooper; import android.test.suitebuilder.annotation.SmallTest; import com.android.internal.util.test.BidirectionalAsyncChannelServer; import org.junit.After; import org.junit.Before; import org.mockito.Mock; import org.mockito.MockitoAnnotations; /** * Unit tests for {@link android.net.wifi.WifiScanner}. */ @SmallTest public class WifiScannerTest { @Mock private Context mContext; @Mock private IWifiScanner mService; private WifiScanner mWifiScanner; private TestLooper mLooper; private Handler mHandler; /** * Setup before tests. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); mLooper = new TestLooper(); mHandler = mock(Handler.class);
response: import static org.mockito.Mockito.atLeastOnce; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.validateMockitoUsage; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import android.content.Context; import android.net.wifi.WifiScanner.BssidInfo; import android.os.Handler; import android.os.Message; import android.os.test.TestLooper; import android.test.suitebuilder.annotation.SmallTest; import com.android.internal.util.test.BidirectionalAsyncChannelServer; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockito.MockitoAnnotations; /** * Unit tests for {@link android.net.wifi.WifiScanner}. */ @SmallTest public class WifiScannerTest { @Mock private Context mContext; @Mock private IWifiScanner mService; private WifiScanner mWifiScanner; private TestLooper mLooper; private Handler mHandler; /** * Setup before tests. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); mLooper = new TestLooper(); mHandler = mock(Handler.class); } }

sample: 300
buggy_code:  mImsRegistered = (responseArray[0] == 1) ? true : false; } break; //GSM case EVENT_RADIO_AVAILABLE: //this is unnecessary //setPowerStateToDesired(); break; case EVENT_SIM_READY: // Reset the mPreviousSubId so we treat a SIM power bounce // as a first boot. See b/19194287 mOnSubscriptionsChangedListener.mPreviousSubId.set(-1); pollState(); // Signal strength polling stops when radio is off queueNextSignalStrengthPoll(); <|startfocus|> setNotification(CS_ENABLED); <|endfocus|> break; case EVENT_RADIO_STATE_CHANGED: case EVENT_PHONE_TYPE_SWITCHED: if(!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) { handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource()); // Signal strength polling stops when radio is off. queueNextSignalStrengthPoll(); } // This will do nothing in the 'radio not available' case setPowerStateToDesired(); // These events are modem triggered, so pollState() needs to be forced modemTriggeredPollState(); break; 
code_review:  Not sure why this is needed. 
target code: mImsRegistered = (responseArray[0] == 1) ? true : false; } break; //GSM case EVENT_RADIO_AVAILABLE: //this is unnecessary //setPowerStateToDesired(); break; case EVENT_SIM_READY: // Reset the mPreviousSubId so we treat a SIM power bounce // as a first boot. See b/19194287 mOnSubscriptionsChangedListener.mPreviousSubId.set(-1); pollState(); // Signal strength polling stops when radio is off queueNextSignalStrengthPoll(); break; case EVENT_RADIO_STATE_CHANGED: case EVENT_PHONE_TYPE_SWITCHED: if(!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) { handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource()); // Signal strength polling stops when radio is off. queueNextSignalStrengthPoll(); } // This will do nothing in the 'radio not available' case setPowerStateToDesired(); // These events are modem triggered, so pollState() needs to be forced modemTriggeredPollState(); break;
response: mImsRegistered = (responseArray[0] == 1) ? true : false; } break; //GSM case EVENT_RADIO_AVAILABLE: //setPowerStateToDesired(); break; case EVENT_SIM_READY: mOnSubscriptionsChangedListener.mPreviousSubId.set(-1); pollState(); queueNextSignalStrengthPoll(); setNotification(CS_ENABLED); break; case EVENT_RADIO_STATE_CHANGED: case EVENT_PHONE_TYPE_SWITCHED: if(!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) { handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource()); queueNextSignalStrengthPoll(); } setPowerStateToDesired(); modemTriggeredPollState(); break;

sample: 301
buggy_code:  * Reference: 3GPP TS 36.104 5.4.3) inclusive ranges on which lte_rsrp_boost_int * will be applied. Format of the String array is expected to be {"erafcn1_start-earfcn1_end", * "earfcn2_start-earfcn2_end" ... } * @hide */ public static final String KEY_BOOSTED_LTE_EARFCNS_STRING_ARRAY = "boosted_lte_earfcns_string_array"; <|startfocus|> /** * Key identifying if voice call barring notification is required to be shown to user. * @hide */ public static final String KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL = "disable_voice_barring_notification_bool"; <|endfocus|> /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
code_review:  nit: the user or users. 
target code: * Reference: 3GPP TS 36.104 5.4.3) inclusive ranges on which lte_rsrp_boost_int * will be applied. Format of the String array is expected to be {"erafcn1_start-earfcn1_end", * "earfcn2_start-earfcn2_end" ... } * @hide */ public static final String KEY_BOOSTED_LTE_EARFCNS_STRING_ARRAY = "boosted_lte_earfcns_string_array"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
response: public static final String KEY_BOOSTED_LTE_EARFCNS_STRING_ARRAY = "boosted_lte_earfcns_string_array"; public static final String KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL = "disable_voice_barring_notification_bool"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); }

sample: 302
buggy_code:  * perform operations that pertain to network connectivity at an abstract * level, use {@link android.net.ConnectivityManager}. */ public class WifiManager { private static final String TAG = "WifiManager"; // Supplicant error codes: /** * The error code if there was a problem authenticating. */ public static final int ERROR_AUTHENTICATING = 1; // Supplicant Authentication Failure reason codes: /** <|startfocus|> * Default reason code for error during authentication. <|endfocus|> * @hide */ public static final int ERROR_AUTH_FAILURE_NONE = 0; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; // Supplicant Authentication Failure reason codes: /**
code_review:  Now the comment doesn't match the new static variable name. 
target code: * perform operations that pertain to network connectivity at an abstract * level, use {@link android.net.ConnectivityManager}. */ public class WifiManager { private static final String TAG = "WifiManager"; // Supplicant error codes: /** * The error code if there was a problem authenticating. */ public static final int ERROR_AUTHENTICATING = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there is no error during authentication. * It could also imply that there no authentication in progress, * this reason code also serves as a reset value. * @hide */ public static final int ERROR_AUTH_FAILURE_NONE = 0; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; // Supplicant Authentication Failure reason codes: /**
response: public class WifiManager { private static final String TAG = "WifiManager"; public static final int ERROR_AUTHENTICATING = 1; public static final int ERROR_AUTH_FAILURE_NONE = 0; public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; }

sample: 303
buggy_code:  */ public class WifiManager { private static final String TAG = "WifiManager"; // Supplicant error codes: /** * The error code if there was a problem authenticating. */ public static final int ERROR_AUTHENTICATING = 1; // Supplicant Authentication Failure reason codes: /** * Default reason code for error during authentication. * @hide */ public static final int ERROR_AUTH_FAILURE_NONE = 0; <|startfocus|> // Supplicant Authentication Failure reason codes: <|endfocus|> /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; // Supplicant Authentication Failure reason codes: /** * The reason code if there was EAP failure while * authenticating. * @hide */
code_review:  Remove this line. 
target code: */ public class WifiManager { private static final String TAG = "WifiManager"; // Supplicant error codes: /** * The error code if there was a problem authenticating. */ public static final int ERROR_AUTHENTICATING = 1; // Supplicant Authentication Failure reason codes: /** * Default reason code for error during authentication. * @hide */ public static final int ERROR_AUTH_FAILURE_NONE = 0; /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; // Supplicant Authentication Failure reason codes: /** * The reason code if there was EAP failure while * authenticating. * @hide */
response: public class WifiManager { private static final String TAG = "WifiManager"; public static final int ERROR_AUTHENTICATING = 1; public static final int ERROR_AUTH_FAILURE_NONE = 0; public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; }

sample: 304
buggy_code:  */ public static final int ERROR_AUTHENTICATING = 1; // Supplicant Authentication Failure reason codes: /** * Default reason code for error during authentication. * @hide */ public static final int ERROR_AUTH_FAILURE_NONE = 0; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; <|startfocus|> // Supplicant Authentication Failure reason codes: <|endfocus|> /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; // Supplicant Authentication Failure reason codes: /** * The reason code if there was EAP failure while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_EAP_FAILURE = 3; /** * Broadcast intent action indicating whether Wi-Fi scanning is allowed currently * @hide */
code_review:  Remove this line. 
target code: */ public static final int ERROR_AUTHENTICATING = 1; // Supplicant Authentication Failure reason codes: /** * Default reason code for error during authentication. * @hide */ public static final int ERROR_AUTH_FAILURE_NONE = 0; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; // Supplicant Authentication Failure reason codes: /** * The reason code if there was EAP failure while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_EAP_FAILURE = 3; /** * Broadcast intent action indicating whether Wi-Fi scanning is allowed currently * @hide */
response: public static final int ERROR_AUTHENTICATING = 1; public static final int ERROR_AUTH_FAILURE_NONE = 0; public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; public static final int ERROR_AUTH_FAILURE_EAP_FAILURE = 3;

sample: 305
buggy_code:  // Supplicant Authentication Failure reason codes: /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; <|startfocus|> // Supplicant Authentication Failure reason codes: <|endfocus|> /** * The reason code if there was EAP failure while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_EAP_FAILURE = 3; /** * Broadcast intent action indicating whether Wi-Fi scanning is allowed currently * @hide */ public static final String WIFI_SCAN_AVAILABLE = "wifi_scan_available"; /** * Extra int indicating scan availability, WIFI_STATE_ENABLED and WIFI_STATE_DISABLED * @hide */ public static final String EXTRA_SCAN_AVAILABLE = "scan_enabled"; /**
code_review:  Remove this line. 
target code: // Supplicant Authentication Failure reason codes: /** * The reason code if there was a timeout authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; // Supplicant Authentication Failure reason codes: /** * The reason code if there was a wrong password while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; /** * The reason code if there was EAP failure while * authenticating. * @hide */ public static final int ERROR_AUTH_FAILURE_EAP_FAILURE = 3; /** * Broadcast intent action indicating whether Wi-Fi scanning is allowed currently * @hide */ public static final String WIFI_SCAN_AVAILABLE = "wifi_scan_available"; /** * Extra int indicating scan availability, WIFI_STATE_ENABLED and WIFI_STATE_DISABLED * @hide */ public static final String EXTRA_SCAN_AVAILABLE = "scan_enabled"; /**
response: public static final int ERROR_AUTH_FAILURE_TIMEOUT = 1; public static final int ERROR_AUTH_FAILURE_WRONG_PSWD = 2; public static final int ERROR_AUTH_FAILURE_EAP_FAILURE = 3; public static final String WIFI_SCAN_AVAILABLE = "wifi_scan_available"; public static final String EXTRA_SCAN_AVAILABLE = "scan_enabled";

sample: 306
buggy_code:  (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); <|startfocus|> dest.writeParcelable((Parcelable) mNetworkSpecifier, 0); <|endfocus|> dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override
code_review:  As soon as there are more type of NetworkSpecifier, this will require a downcast to known types, or some kind of virtual dispatch. Similarly the createFromParcel will need some kind of switch. 
target code: (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override
response: (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); dest.writeParcelable((Parcelable) mNetworkSpecifier, 0); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); netCap.mNetworkSpecifier = in.readParcelable(null); netCap.mSignalStrength = in.readInt(); return netCap; } @Override public NetworkCapabilities[] newArray(int size) { return new NetworkCapabilities[size]; } };

sample: 307
buggy_code:  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of this <|startfocus|> * class via other APIs. <|endfocus|> */ public abstract class NetworkSpecifier { /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. */ public abstract boolean satisfiedBy(NetworkSpecifier other); } 
code_review:  should not. As discussed it is possible to extend that class. To make it much harder to extend this by app, add a package private ctor. Apps won't be able to extend it outside of android.net, but because the class loaders are different, the things apps try to define will compile but will fail loading at run time. 
target code: * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of this * class via other APIs. * * @hide */ public abstract class NetworkSpecifier { /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. */ public abstract boolean satisfiedBy(NetworkSpecifier other); }
response: package android.net; public abstract class NetworkSpecifier { public abstract boolean satisfiedBy(NetworkSpecifier other); }

sample: 308
buggy_code:  // STATE_DIALING, put it on hold before answering the call. if (foregroundCall != null && foregroundCall != call && (foregroundCall.isActive() || foregroundCall.getState() == CallState.DIALING || foregroundCall.getState() == CallState.PULLING)) { if (!foregroundCall.getTargetPhoneAccount().equals( call.getTargetPhoneAccount()) && <|startfocus|> (call.isSelfManaged() != foregroundCall.isSelfManaged() || <|endfocus|> call.isSelfManaged())) { // The foreground call is from another connection service, and either: // 1. FG call's managed state doesn't match that of the incoming call. // E.g. Incoming is self-managed and FG is managed, or incoming is managed // and foreground is self-managed. // 2. The incoming call is self-managed. // E.g. The incoming call is Log.i(this, "Answering call from %s CS; disconnecting calls from %s CS.", foregroundCall.isSelfManaged() ? "selfMg" : "mg",
code_review:  Is this the correct order of precedence? 
target code: // STATE_DIALING, put it on hold before answering the call. if (foregroundCall != null && foregroundCall != call && (foregroundCall.isActive() || foregroundCall.getState() == CallState.DIALING || foregroundCall.getState() == CallState.PULLING)) { if (!foregroundCall.getTargetPhoneAccount().equals( call.getTargetPhoneAccount()) && ((call.isSelfManaged() != foregroundCall.isSelfManaged()) || call.isSelfManaged())) { // The foreground call is from another connection service, and either: // 1. FG call's managed state doesn't match that of the incoming call. // E.g. Incoming is self-managed and FG is managed, or incoming is managed // and foreground is self-managed. // 2. The incoming call is self-managed. // E.g. The incoming call is Log.i(this, "Answering call from %s CS; disconnecting calls from %s CS.", foregroundCall.isSelfManaged() ? "selfMg" : "mg",
response: if (foregroundCall != null && foregroundCall != call && (foregroundCall.isActive() || foregroundCall.getState() == CallState.DIALING || foregroundCall.getState() == CallState.PULLING)) { if (!foregroundCall.getTargetPhoneAccount().equals(call.getTargetPhoneAccount()) && (call.isSelfManaged() != foregroundCall.isSelfManaged() || call.isSelfManaged())) { // The foreground call is from another connection service, and either: // 1. FG call's managed state doesn't match that of the incoming call. // E.g. Incoming is self-managed and FG is managed, or incoming is managed // and foreground is self-managed. // 2. The incoming call is self-managed. // E.g. The incoming call is Log.i(this, "Answering call from %s CS; disconnecting calls from %s CS.", foregroundCall.isSelfManaged() ? "selfMg" : "mg", } }

sample: 309
buggy_code:  @Mock private Call mVideoCall; @Mock private Call mRingingCall; private IncomingCallNotifier mIncomingCallNotifier; private NotificationManager mNotificationManager; public void setUp() throws Exception { super.setUp(); mContext = mComponentContextFixture.getTestDouble().getApplicationContext(); ApplicationInfo info = new ApplicationInfo(); info.targetSdkVersion = Build.VERSION_CODES.N_MR1; doReturn(info).when(mContext).getApplicationInfo(); doReturn(null).when(mContext).getTheme(); <|startfocus|> //mContext.getApplicationInfo().targetSdkVersion <|endfocus|> mNotificationManager = (NotificationManager) mContext.getSystemService( Context.NOTIFICATION_SERVICE); mIncomingCallNotifier = new IncomingCallNotifier(mContext); mIncomingCallNotifier.setCallsManagerProxy(mCallsManagerProxy); when(mAudioCall.getVideoState()).thenReturn(VideoProfile.STATE_AUDIO_ONLY); when(mAudioCall.getTargetPhoneAccountLabel()).thenReturn("Bar"); when(mVideoCall.getVideoState()).thenReturn(VideoProfile.STATE_BIDIRECTIONAL); when(mVideoCall.getTargetPhoneAccountLabel()).thenReturn("Bar"); when(mRingingCall.isSelfManaged()).thenReturn(true); when(mRingingCall.isIncoming()).thenReturn(true);
code_review:  remove 
target code: @Mock private Call mVideoCall; @Mock private Call mRingingCall; private IncomingCallNotifier mIncomingCallNotifier; private NotificationManager mNotificationManager; public void setUp() throws Exception { super.setUp(); mContext = mComponentContextFixture.getTestDouble().getApplicationContext(); ApplicationInfo info = new ApplicationInfo(); info.targetSdkVersion = Build.VERSION_CODES.N_MR1; doReturn(info).when(mContext).getApplicationInfo(); doReturn(null).when(mContext).getTheme(); mNotificationManager = (NotificationManager) mContext.getSystemService( Context.NOTIFICATION_SERVICE); mIncomingCallNotifier = new IncomingCallNotifier(mContext); mIncomingCallNotifier.setCallsManagerProxy(mCallsManagerProxy); when(mAudioCall.getVideoState()).thenReturn(VideoProfile.STATE_AUDIO_ONLY); when(mAudioCall.getTargetPhoneAccountLabel()).thenReturn("Bar"); when(mVideoCall.getVideoState()).thenReturn(VideoProfile.STATE_BIDIRECTIONAL); when(mVideoCall.getTargetPhoneAccountLabel()).thenReturn("Bar"); when(mRingingCall.isSelfManaged()).thenReturn(true); when(mRingingCall.isIncoming()).thenReturn(true);
response: @Mock private Call mVideoCall; @Mock private Call mRingingCall; private IncomingCallNotifier mIncomingCallNotifier; private NotificationManager mNotificationManager; public void setUp() throws Exception { super.setUp(); mContext = mComponentContextFixture.getTestDouble().getApplicationContext(); ApplicationInfo info = new ApplicationInfo(); info.targetSdkVersion = Build.VERSION_CODES.N_MR1; doReturn(info).when(mContext).getApplicationInfo(); doReturn(null).when(mContext).getTheme(); mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE); mIncomingCallNotifier = new IncomingCallNotifier(mContext); mIncomingCallNotifier.setCallsManagerProxy(mCallsManagerProxy); when(mAudioCall.getVideoState()).thenReturn(VideoProfile.STATE_AUDIO_ONLY); when(mAudioCall.getTargetPhoneAccountLabel()).thenReturn("Bar"); when(mVideoCall.getVideoState()).thenReturn(VideoProfile.STATE_BIDIRECTIONAL); when(mVideoCall.getTargetPhoneAccountLabel()).thenReturn("Bar"); when(mRingingCall.isSelfManaged()).thenReturn(true); when(mRingingCall.isIncoming()).thenReturn(true); }

sample: 310
buggy_code:  @Mock WifiTrafficPoller mWifiTrafficPoller; @Mock WifiStateMachine mWifiStateMachine; @Mock HandlerThread mHandlerThread; TestLooper mLooper; @Mock AsyncChannel mAsyncChannel; @Mock Resources mResources; @Mock FrameworkFacade mFrameworkFacade; @Mock WifiLockManager mLockManager; @Mock WifiMulticastLockManager mWifiMulticastLockManager; @Mock WifiLastResortWatchdog mWifiLastResortWatchdog; @Mock WifiBackupRestore mWifiBackupRestore; @Mock WifiMetrics mWifiMetrics; @Spy FakeWifiLog mLog; @Mock WifiPermissionsUtil mWifiPermissionsUtil; <|startfocus|> @Mock PropertyService mPropertyService; <|endfocus|> @Mock WifiSettingsStore mSettingsStore; @Mock ContentResolver mContentResolver; PowerManager mPowerManager; private class WifiAsyncChannelTester { private static final String TAG = "WifiAsyncChannelTester"; public static final int CHANNEL_STATE_FAILURE = -1; public static final int CHANNEL_STATE_DISCONNECTED = 0; public static final int CHANNEL_STATE_HALF_CONNECTED = 1; public static final int CHANNEL_STATE_FULLY_CONNECTED = 2; private int mState = CHANNEL_STATE_DISCONNECTED; private WifiAsyncChannel mChannel; private WifiLog mAsyncTestLog; 
code_review:  Maybe remove this one as well? 
target code: @Mock WifiTrafficPoller mWifiTrafficPoller; @Mock WifiStateMachine mWifiStateMachine; @Mock HandlerThread mHandlerThread; TestLooper mLooper; @Mock AsyncChannel mAsyncChannel; @Mock Resources mResources; @Mock FrameworkFacade mFrameworkFacade; @Mock WifiLockManager mLockManager; @Mock WifiMulticastLockManager mWifiMulticastLockManager; @Mock WifiLastResortWatchdog mWifiLastResortWatchdog; @Mock WifiBackupRestore mWifiBackupRestore; @Mock WifiMetrics mWifiMetrics; @Spy FakeWifiLog mLog; @Mock WifiPermissionsUtil mWifiPermissionsUtil; @Mock WifiSettingsStore mSettingsStore; @Mock ContentResolver mContentResolver; PowerManager mPowerManager; private class WifiAsyncChannelTester { private static final String TAG = "WifiAsyncChannelTester"; public static final int CHANNEL_STATE_FAILURE = -1; public static final int CHANNEL_STATE_DISCONNECTED = 0; public static final int CHANNEL_STATE_HALF_CONNECTED = 1; public static final int CHANNEL_STATE_FULLY_CONNECTED = 2; private int mState = CHANNEL_STATE_DISCONNECTED; private WifiAsyncChannel mChannel; private WifiLog mAsyncTestLog;
response: @Mock WifiTrafficPoller mWifiTrafficPoller; @Mock WifiStateMachine mWifiStateMachine; @Mock HandlerThread mHandlerThread; TestLooper mLooper; @Mock AsyncChannel mAsyncChannel; @Mock Resources mResources; @Mock FrameworkFacade mFrameworkFacade; @Mock WifiLockManager mLockManager; @Mock WifiMulticastLockManager mWifiMulticastLockManager; @Mock WifiLastResortWatchdog mWifiLastResortWatchdog; @Mock WifiBackupRestore mWifiBackupRestore; @Mock WifiMetrics mWifiMetrics; @Spy FakeWifiLog mLog; @Mock WifiPermissionsUtil mWifiPermissionsUtil; @Mock PropertyService mPropertyService; @Mock WifiSettingsStore mSettingsStore; @Mock ContentResolver mContentResolver; PowerManager mPowerManager; private class WifiAsyncChannelTester { private static final String TAG = "WifiAsyncChannelTester"; public static final int CHANNEL_STATE_FAILURE = -1; public static final int CHANNEL_STATE_DISCONNECTED = 0; public static final int CHANNEL_STATE_HALF_CONNECTED = 1; public static final int CHANNEL_STATE_FULLY_CONNECTED = 2; private int mState = CHANNEL_STATE_DISCONNECTED; private WifiAsyncChannel mChannel; private WifiLog mAsyncTestLog; }

sample: 311
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License */ package benchmarks.regression; import com.google.caliper.Param; public class StringReplaceAllBenchmark { // NOTE: These estimates of MOVEABLE / NON_MOVEABLE are based on a knowledge of // ART implementation details. They make a difference here because JNI calls related // to strings took different paths depending on whether the String in question was // moveable or not. enum StringLengths { EMPTY(""),
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License */ package benchmarks.regression; import com.google.caliper.Param; public class StringReplaceAllBenchmark { // NOTE: These estimates of MOVEABLE / NON_MOVEABLE are based on a knowledge of // ART implementation details. They make a difference here because JNI calls related // to strings took different paths depending on whether the String in question was // moveable or not. enum StringLengths { EMPTY(""),
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. package benchmarks.regression; import com.google.caliper.Param; public class StringReplaceAllBenchmark { // NOTE: These estimates of MOVEABLE / NON_MOVEABLE are based on a knowledge of // ART implementation details. They make a difference here because JNI calls related // to strings took different paths depending on whether the String in question was // moveable or not. enum StringLengths { EMPTY(""), SHORT("short"), MEDIUM("medium length string"), LONG("long string that is longer than the others"); private final String value; StringLengths(String value) { this.value = value; } public String getValue() { return value; } } @Param private StringLengths stringLength; private String input; public void setUp() { input = stringLength.getValue(); } public void timeReplaceAll(int reps) { for (int i = 0; i < reps; i++) { input.replaceAll(" ", "_"); } } }

sample: 312
buggy_code:  } /** * Creates a new advertising set. If operation succeed, device will start advertising. This * method returns immediately, the operation status is delivered through * {@code callback.onAdvertisingSetStarted()}. * <p> * @param parameters advertising set parameters. * @param advertiseData Advertisement data to be broadcasted. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the <|startfocus|> * advertisement is connectable, three bytes will be appended with flags. <|endfocus|> * @param scanResponse Scan response associated with the advertisement data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param periodicData Periodic advertising data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param timeoutMillis Advertising time limit. May not exceed 180000 * @param callback Callback for advertising set. * @param handler thread upon which the callbacks will be invoked. */ public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters,
code_review:  added 
target code: } /** * Creates a new advertising set. If operation succeed, device will start advertising. This * method returns immediately, the operation status is delivered through * {@code callback.onAdvertisingSetStarted()}. * <p> * @param parameters advertising set parameters. * @param advertiseData Advertisement data to be broadcasted. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the * advertisement is connectable, three bytes will be added for flags. * @param scanResponse Scan response associated with the advertisement data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param periodicData Periodic advertising data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param timeoutMillis Advertising time limit. May not exceed 180000 * @param callback Callback for advertising set. * @param handler thread upon which the callbacks will be invoked. */ public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters,
response: private long size = 0; private Path tmpFile; public CleanFilter(Repository db, InputStream in, OutputStream out) throws IOException { super(in, out); lfsUtil = new LfsUtil(db.getDirectory().toPath().resolve("lfs")); Files.createDirectories(lfsUtil.getLfsTmpDir()); tmpFile = lfsUtil.createTmpFile(); this.out = out; } public org.apache.hadoop.hive.metastore.api.Table getMetaStoreTable() { return msTable_; } public void setMetaStoreTable(org.apache.hadoop.hive.metastore.api.Table msTbl) { msTable_ = msTbl; } public int getNumClusteringCols() { return numClusteringCols_; } public void setNumClusteringCols(int n) { Preconditions.checkState(RuntimeEnv.INSTANCE.isTestEnv()); numClusteringCols_ = n; } public long getNumRows() { return numRows_; } public ArrayType getType() { return type_; } @Override public long getCatalogVersion() { return catalogVersion_; } @Override public void setCatalogVersion(long catalogVersion) { catalogVersion_ = catalogVersion; } @Override public boolean isLoaded() { return true; } public static boolean isExternalTable() { // implementation } private final Map<Project.NameKey, ProjectState> all; private final ProjectCache projectCache; private final CapabilityControl.Factory capabilityControlFactory; private final ChangeControl.AssistedFactory changeControlFactory; private final PermissionCollection.Factory sectionSorter; private final InMemoryRepositoryManager repoManager; private final GroupControl.Factory controlFactory; private final GroupJson json; private final Provider<ListIncludedGroups> listIncludes; private final AllProjectsName allProjectsName = new AllProjectsName("All-Projects"); private final ProjectConfig allProjects; @SuppressWarnings("unchecked") public Util() { all = new HashMap<>(); repoManager = new InMemoryRepositoryManager(); try { Repository repo = repoManager.createRepository(allProjectsName); allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get())); allProjects.load(repo); allProjects.getLabelSections().put(CR.getName(), CR); add(allProjects); } catch (IOException | ConfigInvalidException e) { throw new RuntimeException(e); } projectCache = new ProjectCache() { @Override // implementation }; } public void start

sample: 313
buggy_code:  } /** * Creates a new advertising set. If operation succeed, device will start advertising. This * method returns immediately, the operation status is delivered through * {@code callback.onAdvertisingSetStarted()}. * <p> * @param parameters advertising set parameters. * @param advertiseData Advertisement data to be broadcasted. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the <|startfocus|> * advertisement is connectable, three bytes will be appended with flags. <|endfocus|> * @param scanResponse Scan response associated with the advertisement data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param periodicData Periodic advertising data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param timeoutMillis Advertising time limit. May not exceed 180000 * @param callback Callback for advertising set. * @param handler thread upon which the callbacks will be invoked. */ public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters,
code_review:  for 
target code: } /** * Creates a new advertising set. If operation succeed, device will start advertising. This * method returns immediately, the operation status is delivered through * {@code callback.onAdvertisingSetStarted()}. * <p> * @param parameters advertising set parameters. * @param advertiseData Advertisement data to be broadcasted. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the * advertisement is connectable, three bytes will be added for flags. * @param scanResponse Scan response associated with the advertisement data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param periodicData Periodic advertising data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param timeoutMillis Advertising time limit. May not exceed 180000 * @param callback Callback for advertising set. * @param handler thread upon which the callbacks will be invoked. */ public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters,
response: /** * Creates a new advertising set. If operation succeed, device will start advertising. This * method returns immediately, the operation status is delivered through * {@code callback.onAdvertisingSetStarted()}. * * @param parameters advertising set parameters. * @param advertiseData Advertisement data to be broadcasted. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable, * three bytes will be appended with flags. * @param scanResponse Scan response associated with the advertisement data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param periodicData Periodic advertising data. Size must not exceed * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength} * @param timeoutMillis Advertising time limit. May not exceed 180000 * @param callback Callback for advertising set. * @param handler thread upon which the callbacks will be invoked. */ public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, long timeoutMillis, AdvertisingSetCallback callback, Handler handler) { // implementation goes here }

sample: 314
buggy_code:  * by the system. */ public static final String ACTION_SUBINFO_RECORD_UPDATED = "android.intent.action.ACTION_SUBINFO_RECORD_UPDATED"; /** * Broadcast Action: The default subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current default subscription.</li> * </ul> <|startfocus|> * @deprecated Use (@link SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED} <|endfocus|> */ @Deprecated public static final String ACTION_DEFAULT_SUBSCRIPTION_CHANGED = SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED; /** * Broadcast Action: The default data subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current data default subscription.</li> * </ul> */ public static final String ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED = "android.intent.action.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED"; /** * Broadcast Action: The default voice subscription has changed. This has the following
code_review:  { 
target code: * by the system. */ public static final String ACTION_SUBINFO_RECORD_UPDATED = "android.intent.action.ACTION_SUBINFO_RECORD_UPDATED"; /** * Broadcast Action: The default subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current default subscription.</li> * </ul> * @deprecated Use {@link SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED} */ @Deprecated public static final String ACTION_DEFAULT_SUBSCRIPTION_CHANGED = SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED; /** * Broadcast Action: The default data subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current data default subscription.</li> * </ul> */ public static final String ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED = "android.intent.action.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED"; /** * Broadcast Action: The default voice subscription has changed. This has the following
response: * by the system. */ public static final String ACTION_SUBINFO_RECORD_UPDATED = "android.intent.action.ACTION_SUBINFO_RECORD_UPDATED"; /** * Broadcast Action: The default subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current default subscription.</li> * </ul> * @deprecated Use (@link SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED} */ @Deprecated public static final String ACTION_DEFAULT_SUBSCRIPTION_CHANGED = SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED; /** * Broadcast Action: The default data subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current data default subscription.</li> * </ul> */ public static final String ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED = "android.intent.action.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED"; /** * Broadcast Action: The default voice subscription has changed. This has the following */

sample: 315
buggy_code:  * </ul> */ public static final String ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED = "android.intent.action.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED"; /** * Broadcast Action: The default sms subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current sms default subscription.</li> * </ul> <|startfocus|> * @deprecated Use (@link SubscriptionManager.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED} <|endfocus|> */ @Deprecated public static final String ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED = SubscriptionManager.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED; /* * Broadcast Action: An attempt to set phone radio type and access technology has changed. * This has the following extra values: * <ul> * <li><em>phones radio access family </em> - A RadioAccessFamily * array, contain phone ID and new radio access family for each phone.</li> * </ul> * * <p class="note"> * Requires the READ_PHONE_STATE permission.
code_review:  { 
target code: * </ul> */ public static final String ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED = "android.intent.action.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED"; /** * Broadcast Action: The default sms subscription has changed. This has the following * extra values:</p> * <ul> * <li><em>subscription</em> - A int, the current sms default subscription.</li> * </ul> * @deprecated Use {@link SubscriptionManager.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED} */ @Deprecated public static final String ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED = SubscriptionManager.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED; /* * Broadcast Action: An attempt to set phone radio type and access technology has changed. * This has the following extra values: * <ul> * <li><em>phones radio access family </em> - A RadioAccessFamily * array, contain phone ID and new radio access family for each phone.</li> * </ul> * * <p class="note"> * Requires the READ_PHONE_STATE permission.
response: Fixed Code: ```java public static final String ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED = "android.intent.action.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED"; @Deprecated public static final String ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED = SubscriptionManager.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED; public static final String ACTION_PHONE_RADIO_ACCESS_FAMILY_CHANGED = "android.intent.action.PHONE_RADIO_ACCESS_FAMILY_CHANGED"; ```

sample: 316
buggy_code:  } public void testChangeFontScaleNoRelaunch() throws Exception { // Should receive onConfigurationChanged() and no relaunch testChangeFontScale(NO_RELAUNCH_ACTIVITY_NAME, false); } private void testRotation( String activityName, int rotationStep, int numRelaunch, int numConfigChange) throws Exception { executeShellCommand(getAmStartCmd(activityName)); final String[] waitForActivitiesVisible = new String[] {activityName}; mAmWmState.computeState(mDevice, waitForActivitiesVisible); <|startfocus|> setDeviceRotation(4 - rotationStep); <|endfocus|> mAmWmState.computeState(mDevice, waitForActivitiesVisible); final int actualStackId = mAmWmState.getAmState().getTaskByActivityName( activityName).mStackId; final int displayId = mAmWmState.getAmState().getStackById(actualStackId).mDisplayId; final int newDeviceRotation = getDeviceRotation(displayId); if (newDeviceRotation == INVALID_DEVICE_ROTATION) { CLog.logAndDisplay(LogLevel.WARN, "Got an invalid device rotation value. " + "Continuing the test despite of that, but it is likely to fail.");
code_review:  define a local variable for this and use here and below. 
target code: } public void testChangeFontScaleNoRelaunch() throws Exception { // Should receive onConfigurationChanged() and no relaunch testChangeFontScale(NO_RELAUNCH_ACTIVITY_NAME, false); } private void testRotation( String activityName, int rotationStep, int numRelaunch, int numConfigChange) throws Exception { executeShellCommand(getAmStartCmd(activityName)); final String[] waitForActivitiesVisible = new String[] {activityName}; mAmWmState.computeState(mDevice, waitForActivitiesVisible); final int initialRotation = 4 - rotationStep; setDeviceRotation(initialRotation); mAmWmState.computeState(mDevice, waitForActivitiesVisible); final int actualStackId = mAmWmState.getAmState().getTaskByActivityName( activityName).mStackId; final int displayId = mAmWmState.getAmState().getStackById(actualStackId).mDisplayId; final int newDeviceRotation = getDeviceRotation(displayId); if (newDeviceRotation == INVALID_DEVICE_ROTATION) { CLog.logAndDisplay(LogLevel.WARN, "Got an invalid device rotation value. " + "Continuing the test despite of that, but it is likely to fail.");
response: Refactored Code: ```java } public void testChangeFontScaleNoRelaunch() throws Exception { // Should receive onConfigurationChanged() and no relaunch testChangeFontScale(NO_RELAUNCH_ACTIVITY_NAME, false); } private void testRotation(String activityName, int rotationStep, int numRelaunch, int numConfigChange) throws Exception { executeShellCommand(getAmStartCmd(activityName)); final String[] waitForActivitiesVisible = new String[] {activityName}; mAmWmState.computeState(mDevice, waitForActivitiesVisible); setDeviceRotation(4 - rotationStep); mAmWmState.computeState(mDevice, waitForActivitiesVisible); final int actualStackId = mAmWmState.getAmState().getTaskByActivityName(activityName).mStackId; final int displayId = mAmWmState.getAmState().getStackById(actualStackId).mDisplayId; final int newDeviceRotation = getDeviceRotation(displayId); if (newDeviceRotation == INVALID_DEVICE_ROTATION) { CLog.logAndDisplay(LogLevel.WARN, "Got an invalid device rotation value. " + "Continuing the test despite of that, but it is likely to fail."); } } ``` Note: The refactored code removes the unnecessary focus comments and adds a local variable for the device rotation value.

sample: 317
buggy_code:  Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { <|startfocus|> throw new IllegalStateException("Invalid network specifier"); <|endfocus|> } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); try { netCap.mNetworkSpecifier = in.readParcelable(null);
code_review:  Shouldn't this validation be in setNetworkSpecifier ? It is redundant with the Parcelable check, assuming all whitelisted subclasses are Parcelable. 
target code: Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalArgumentException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); try { netCap.mNetworkSpecifier = in.readParcelable(null);
response: Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19)); } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeLong(mNetworkCapabilities); dest.writeLong(mTransportTypes); dest.writeInt(mLinkUpBandwidthKbps); dest.writeInt(mLinkDownBandwidthKbps); if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); dest.writeInt(mSignalStrength); } public static final Creator<NetworkCapabilities> CREATOR = new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); try { netCap.mNetworkSpecifier = in.readParcelable(null);

sample: 318
buggy_code:  new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); try { netCap.mNetworkSpecifier = in.readParcelable(null); <|startfocus|> } catch (BadParcelableException e) { Log.e(TAG, "BadParcelableException: e=" + e); <|endfocus|> netCap.mNetworkSpecifier = null; } netCap.mSignalStrength = in.readInt(); return netCap; } @Override public NetworkCapabilities[] newArray(int size) { return new NetworkCapabilities[size]; } }; @Override public String toString() { int[] types = getTransportTypes(); String transports = (types.length > 0) ? " Transports: " + transportNamesOf(types) : ""; types = getCapabilities(); String capabilities = (types.length > 0 ? " Capabilities: " : "");
code_review:  readParcelable() as a rhs to set mNetworkSpecifier which is of type NetworkSpecifier looks fishy. After checking readParcelable() has a parametric return type. i.e the Parcelable is cast to what needs to be on the lhs. This can also throws a ClassCastException. 
target code: new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); try { netCap.mNetworkSpecifier = in.readParcelable(null); } catch (Exception e) { Log.e(TAG, "Exception: e=" + e); netCap.mNetworkSpecifier = null; } netCap.mSignalStrength = in.readInt(); return netCap; } @Override public NetworkCapabilities[] newArray(int size) { return new NetworkCapabilities[size]; } }; @Override public String toString() { int[] types = getTransportTypes(); String transports = (types.length > 0) ? " Transports: " + transportNamesOf(types) : ""; types = getCapabilities(); String capabilities = (types.length > 0 ? " Capabilities: " : "");
response: new Creator<NetworkCapabilities>() { @Override public NetworkCapabilities createFromParcel(Parcel in) { NetworkCapabilities netCap = new NetworkCapabilities(); netCap.mNetworkCapabilities = in.readLong(); netCap.mTransportTypes = in.readLong(); netCap.mLinkUpBandwidthKbps = in.readInt(); netCap.mLinkDownBandwidthKbps = in.readInt(); try { netCap.mNetworkSpecifier = (NetworkSpecifier) in.readParcelable(null); } catch (BadParcelableException e) { Log.e(TAG, "BadParcelableException: e=" + e); netCap.mNetworkSpecifier = null; } netCap.mSignalStrength = in.readInt(); return netCap; } @Override public NetworkCapabilities[] newArray(int size) { return new NetworkCapabilities[size]; } }; @Override public String toString() { int[] types = getTransportTypes(); String transports = (types.length > 0) ? " Transports: " + transportNamesOf(types) : ""; types = getCapabilities(); String capabilities = (types.length > 0 ? " Capabilities: " : ""); }

sample: 319
buggy_code:  */ @Override public void onPullExternalCall() { if ((getConnectionProperties() & Connection.PROPERTY_IS_EXTERNAL_CALL) != Connection.PROPERTY_IS_EXTERNAL_CALL) { Log.w(this, "onPullExternalCall - cannot pull non-external call"); return; } if (mOriginalConnection != null) { mOriginalConnection.pullExternalCall(); } } @Override public void onStartRtt(RttTextStream textStream) { <|startfocus|> Phone phone = getPhone(); if (phone instanceof ImsPhone) { ImsPhone imsPhone = (ImsPhone) phone; <|endfocus|> imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { Phone phone = getPhone(); if (!(phone instanceof ImsPhone)) {
code_review:  There is an existing method in this class, isImsConnection() which determines if this is an IMS connection. It looks based on the original connection's phone type; should be re-usable here. 
target code: */ @Override public void onPullExternalCall() { if ((getConnectionProperties() & Connection.PROPERTY_IS_EXTERNAL_CALL) != Connection.PROPERTY_IS_EXTERNAL_CALL) { Log.w(this, "onPullExternalCall - cannot pull non-external call"); return; } if (mOriginalConnection != null) { mOriginalConnection.pullExternalCall(); } } @Override public void onStartRtt(RttTextStream textStream) { if (isImsConnection()) { ImsPhone imsPhone = (ImsPhone) getPhone(); imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { Phone phone = getPhone(); if (!(phone instanceof ImsPhone)) {
response: @Override public void onPullExternalCall() { if ((getConnectionProperties() & Connection.PROPERTY_IS_EXTERNAL_CALL) != Connection.PROPERTY_IS_EXTERNAL_CALL) { Log.w(this, "onPullExternalCall - cannot pull non-external call"); return; } if (mOriginalConnection != null) { mOriginalConnection.pullExternalCall(); } } @Override public void onStartRtt(RttTextStream textStream) { Phone phone = getPhone(); if (phone instanceof ImsPhone) { ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { Phone phone = getPhone(); if (!(phone instanceof ImsPhone)) { // Handle non-IMS phone case } }

sample: 320
buggy_code:  if (phone instanceof ImsPhone) { ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { <|startfocus|> Phone phone = getPhone(); if (!(phone instanceof ImsPhone)) { <|endfocus|> Log.w(this, "handleRttUpgradeResponse - not in IMS, so RTT cannot be enabled."); return; } ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyResponse(textStream); } public void performHold() { Log.v(this, "performHold"); // TODO: Can dialing calls be put on hold as well since they take up the // foreground call slot? if (Call.State.ACTIVE == mConnectionState) { Log.v(this, "Holding active call"); try {
code_review:  There is an existing method in this class, isImsConnection() which determines if this is an IMS connection. It looks based on the original connection's phone type; should be re-usable here. 
target code: if (phone instanceof ImsPhone) { ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { if (!isImsConnection()) { Log.w(this, "handleRttUpgradeResponse - not in IMS, so RTT cannot be enabled."); return; } ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyResponse(textStream); } public void performHold() { Log.v(this, "performHold"); // TODO: Can dialing calls be put on hold as well since they take up the // foreground call slot? if (Call.State.ACTIVE == mConnectionState) { Log.v(this, "Holding active call"); try {
response: if (phone instanceof ImsPhone) { ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { Phone phone = getPhone(); if (!(phone instanceof ImsPhone)) { Log.w(this, "handleRttUpgradeResponse - not in IMS, so RTT cannot be enabled."); return; } ImsPhone imsPhone = (ImsPhone) phone; imsPhone.sendRttModifyResponse(textStream); } public void performHold() { Log.v(this, "performHold"); // TODO: Can dialing calls be put on hold as well since they take up the // foreground call slot? if (Call.State.ACTIVE == mConnectionState) { Log.v(this, "Holding active call"); try { // Perform hold operation } catch (Exception e) { Log.e(this, "Error performing hold operation", e); } } }

sample: 321
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.wifi.aware; import android.net.NetworkSpecifier; import android.os.Parcel; import android.os.Parcelable; import java.util.Arrays; import java.util.Objects; /** * Network specifier object used to request a Wi-Fi Aware network. Apps do not create these objects * directly but obtain them using * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} or
code_review:  7 ? 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.wifi.aware; import android.net.NetworkSpecifier; import android.os.Parcel; import android.os.Parcelable; import java.util.Arrays; import java.util.Objects; /** * Network specifier object used to request a Wi-Fi Aware network. Apps do not create these objects * directly but obtain them using * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} or
response: /* Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.wifi.aware; import android.net.NetworkSpecifier; import android.os.Parcel; import android.os.Parcelable; import java.util.Arrays; import java.util.Objects; /** * Network specifier object used to request a Wi-Fi Aware network. Apps do not create these objects * directly but obtain them using * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} or * {@link WifiAwareSession#createNetworkSpecifierPassphrase(int, byte[], String)}. * * @hide */ public class NetworkSpecifier implements Parcelable { // ... rest of the code ... }

sample: 322
buggy_code:  public boolean satisfiedBy(NetworkSpecifier other) { <|startfocus|> return equals(other); // Match All is taken care of already <|endfocus|>
code_review:  I suggest a more specific comment: MatchAllNetworkSpecifier taken care of in {@code xxx}. 
target code: public boolean satisfiedBy(NetworkSpecifier other) { // MatchAllNetworkSpecifier is taken care in NetworkCapabilities#satisfiedBySpecifier. return equals(other);
response: public boolean satisfiedBy(NetworkSpecifier other) { return equals(other); }

sample: 323
buggy_code: <|startfocus|> public static List<TimeZone> getTimeZonesWithUniqueOffsets(String country) { <|endfocus|> synchronized(sLastUniqueLockObj) { if ((country != null) && country.equals(sLastUniqueCountry)) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets(" + country + "): return cached version"); } return sLastUniqueZoneOffsets; } } Collection<TimeZone> zones = getTimeZones(country); ArrayList<TimeZone> uniqueTimeZones = new ArrayList<>(); for (TimeZone zone : zones) { // See if we already have this offset, // Using slow but space efficient and these are small. boolean found = false; for (int i = 0; i < uniqueTimeZones.size(); i++) { if (uniqueTimeZones.get(i).getRawOffset() == zone.getRawOffset()) { found = true; break; } } if (!found) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets: add unique offset=" +
code_review:  this seems like an API change, which is fine if intentional, just checking. 
target code: public static List<String> getTimeZoneIdsWithUniqueOffsets(String country) { synchronized(sLastUniqueLockObj) { if ((country != null) && country.equals(sLastUniqueCountry)) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets(" + country + "): return cached version"); } return sLastUniqueZoneOffsets; } } Collection<TimeZone> zones = getTimeZones(country); ArrayList<TimeZone> uniqueTimeZones = new ArrayList<>(); for (TimeZone zone : zones) { // See if we already have this offset, // Using slow but space efficient and these are small. boolean found = false; for (int i = 0; i < uniqueTimeZones.size(); i++) { if (uniqueTimeZones.get(i).getRawOffset() == zone.getRawOffset()) { found = true; break; } } if (!found) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets: add unique offset=" +
response: public static List<TimeZone> getTimeZonesWithUniqueOffsets(String country) { synchronized(sLastUniqueLockObj) { if ((country != null) && country.equals(sLastUniqueCountry)) { return sLastUniqueZoneOffsets; } } Collection<TimeZone> zones = getTimeZones(country); ArrayList<TimeZone> uniqueTimeZones = new ArrayList<>(); for (TimeZone zone : zones) { boolean found = false; for (int i = 0; i < uniqueTimeZones.size(); i++) { if (uniqueTimeZones.get(i).getRawOffset() == zone.getRawOffset()) { found = true; break; } } if (!found) { uniqueTimeZones.add(zone); } } return uniqueTimeZones; }

sample: 324
buggy_code:  private static String getCounterLabel(int counterIndex) { switch (counterIndex) { case ON_POST_DIAL_WAIT: return "onPostDialWait"; case ON_CALL_EVENT: return "onCallEvent"; case ON_PULL_EXTERNAL_CALL: return "onPullExternalCall"; case ON_EXTRAS_CHANGED: return "onExtrasChanged"; case ON_START_RTT: <|startfocus|> return "onStartRtt"; <|endfocus|> default: return "Callback"; }
code_review:  What about ON_RTT_REQUEST_RESPONSE and ON_STOP_RTT? 
target code: private static String getCounterLabel(int counterIndex) { switch (counterIndex) { case ON_POST_DIAL_WAIT: return "onPostDialWait"; case ON_CALL_EVENT: return "onCallEvent"; case ON_PULL_EXTERNAL_CALL: return "onPullExternalCall"; case ON_EXTRAS_CHANGED: return "onExtrasChanged"; case ON_START_RTT: return "onStartRtt"; case ON_RTT_REQUEST_RESPONSE: return "onRttRequestResponse"; case ON_STOP_RTT: return "onStopRtt"; default: return "Callback"; }
response: private static String getCounterLabel(int counterIndex) { switch (counterIndex) { case ON_POST_DIAL_WAIT: return "onPostDialWait"; case ON_CALL_EVENT: return "onCallEvent"; case ON_PULL_EXTERNAL_CALL: return "onPullExternalCall"; case ON_EXTRAS_CHANGED: return "onExtrasChanged"; case ON_START_RTT: return "onStartRtt"; case ON_RTT_REQUEST_RESPONSE: return "onRttRequestResponse"; case ON_STOP_RTT: return "onStopRtt"; default: return "Callback"; } }

sample: 325
buggy_code:  mKeepaliveCallback, mConfig.getLocalAddress(), mConfig.getEncapLocalPort(), mConfig.getRemoteAddress()); try { // FIXME: this is still a horrible way to fudge the synchronous callback mKeepaliveSyncLock.wait(2000); } catch (InterruptedException e) { } } if (mKeepaliveStatus != ConnectivityManager.PacketKeepalive.SUCCESS) { throw new UnsupportedOperationException("Packet Keepalive cannot be started"); } } /* Package */ <|startfocus|> void setResourceId(int resourceId) { mResourceId = resourceId; } /* Package */ <|endfocus|> int getResourceId() { return mResourceId; } /* Package */ void stopKeepalive() { if (mKeepalive == null) { return; } mKeepalive.stop(); synchronized (mKeepaliveSyncLock) { if (mKeepaliveStatus == ConnectivityManager.PacketKeepalive.SUCCESS) { try { mKeepaliveSyncLock.wait(2000); } catch (InterruptedException e) { } } } } /** * Builder object to facilitate the creation of IpSecTransform objects. *
code_review:  Who calls this? Does it need to be package-visible? 
target code: mKeepaliveCallback, mConfig.getLocalAddress(), mConfig.getEncapLocalPort(), mConfig.getRemoteAddress()); try { // FIXME: this is still a horrible way to fudge the synchronous callback mKeepaliveSyncLock.wait(2000); } catch (InterruptedException e) { } } if (mKeepaliveStatus != ConnectivityManager.PacketKeepalive.SUCCESS) { throw new UnsupportedOperationException("Packet Keepalive cannot be started"); } } /* Package */ int getResourceId() { return mResourceId; } /* Package */ void stopKeepalive() { if (mKeepalive == null) { return; } mKeepalive.stop(); synchronized (mKeepaliveSyncLock) { if (mKeepaliveStatus == ConnectivityManager.PacketKeepalive.SUCCESS) { try { mKeepaliveSyncLock.wait(2000); } catch (InterruptedException e) { } } } } /** * Builder object to facilitate the creation of IpSecTransform objects. *
response: public class MyClass { private int resourceId; public void setResourceId(int resourceId) { this.resourceId = resourceId; } public int getResourceId() { return resourceId; } public void stopKeepalive() { if (mKeepalive == null) { return; } mKeepalive.stop(); synchronized (mKeepaliveSyncLock) { if (mKeepaliveStatus == ConnectivityManager.PacketKeepalive.SUCCESS) { try { mKeepaliveSyncLock.wait(2000); } catch (InterruptedException e) { // Handle exception } } } } }

sample: 326
buggy_code:  protected void releaseResources() { try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, mDirection, mLocalAddress, mRemoteAddress, mSpi); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { <|startfocus|> throw e.rethrowFromSystemServer(); <|endfocus|> }
code_review:  Is this going to crash the system? If so, perhaps just log an error and continue instead of throwing. 
target code: protected void releaseResources() { try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, mDirection, mLocalAddress, mRemoteAddress, mSpi); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { Log.e(TAG, "Failed to delete SPI reservation with ID: " + mResourceId); }
response: protected void releaseResources() { try { getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, mDirection, mLocalAddress, mRemoteAddress, mSpi); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw it as an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }

sample: 327
buggy_code:  INetd getNetdInstance() { final INetd netd = NetdService.getInstance(); if (netd == null) { <|startfocus|> throw new RemoteException("Failed to Get Netd Instance").rethrowFromSystemServer(); <|endfocus|> } return netd;
code_review:  Is this going to crash the system? if so, add a TODO to fix it. 
target code: INetd getNetdInstance() { final INetd netd = NetdService.getInstance(); if (netd == null) { throw new RemoteException("Failed to Get Netd Instance"); } return netd;
response: INetd getNetdInstance() { final INetd netd = NetdService.getInstance(); if (netd == null) { throw new RemoteException("Failed to Get Netd Instance").rethrowFromSystemServer(); } return netd; }

sample: 328
buggy_code:  } return netd; } boolean isNetdAlive() { synchronized (mLock) { final INetd netd = getNetdInstance(); if (netd == null) { return false; } try { return netd.isAlive(); } catch (RemoteException re) { return false; } } } @Override /** Get a new SPI and maintain the reservation in the system server */ public Bundle reserveSecurityParameterIndex( <|startfocus|> int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException { <|endfocus|> int resourceId = mNextResourceId.getAndIncrement(); int spi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX; String localAddress = ""; Bundle retBundle = new Bundle(3); try { spi = getNetdInstance() .ipSecAllocateSpi( resourceId, direction, localAddress, remoteAddress, requestedSpi); Log.d(TAG, "Allocated SPI " + spi); retBundle.putInt(KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(KEY_RESOURCE_ID, resourceId); retBundle.putInt(KEY_SPI, spi);
code_review:  Long line. 
target code: } return netd; } boolean isNetdAlive() { synchronized (mLock) { final INetd netd = getNetdInstance(); if (netd == null) { return false; } try { return netd.isAlive(); } catch (RemoteException re) { return false; } } } @Override /** Get a new SPI and maintain the reservation in the system server */ public Bundle reserveSecurityParameterIndex( int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException { int resourceId = mNextResourceId.getAndIncrement(); int spi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX; String localAddress = ""; Bundle retBundle = new Bundle(3); try { spi = getNetdInstance() .ipSecAllocateSpi( resourceId, direction, localAddress, remoteAddress, requestedSpi); Log.d(TAG, "Allocated SPI " + spi); retBundle.putInt(KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(KEY_RESOURCE_ID, resourceId); retBundle.putInt(KEY_SPI, spi);
response: } return netd; } boolean isNetdAlive() { synchronized (mLock) { final INetd netd = getNetdInstance(); if (netd == null) { return false; } try { return netd.isAlive(); } catch (RemoteException re) { return false; } } } @Override public Bundle reserveSecurityParameterIndex(int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException { int resourceId = mNextResourceId.getAndIncrement(); int spi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX; String localAddress = ""; Bundle retBundle = new Bundle(3); try { spi = getNetdInstance().ipSecAllocateSpi(resourceId, direction, localAddress, remoteAddress, requestedSpi); Log.d(TAG, "Allocated SPI " + spi); retBundle.putInt(KEY_STATUS, IpSecManager.Status.OK); retBundle.putInt(KEY_RESOURCE_ID, resourceId); retBundle.putInt(KEY_SPI, spi);

sample: 329
buggy_code:  * Create a transport mode transform, which represent two security associations (one in each * direction) in the kernel. The transform will be cached by the system server and must be freed * when no longer needed. It is possible to free one, deleting the SA from underneath sockets * that are using it, which will result in all of those sockets becoming unable to send or * receive data. */ @Override <|startfocus|> public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException { <|endfocus|> // TODO: Basic input validation here since it's coming over the Binder int resourceId = mNextResourceId.getAndIncrement(); for (int direction : DIRECTIONS) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance() .ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "",
code_review:  Long line. 
target code: * Create a transport mode transform, which represent two security associations (one in each * direction) in the kernel. The transform will be cached by the system server and must be freed * when no longer needed. It is possible to free one, deleting the SA from underneath sockets * that are using it, which will result in all of those sockets becoming unable to send or * receive data. */ @Override public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException { // TODO: Basic input validation here since it's coming over the Binder int resourceId = mNextResourceId.getAndIncrement(); for (int direction : DIRECTIONS) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance() .ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "",
response: @Override public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException { int resourceId = mNextResourceId.getAndIncrement(); for (int direction : DIRECTIONS) { IpSecAlgorithm auth = c.getAuthentication(direction); IpSecAlgorithm crypt = c.getEncryption(direction); try { int result = getNetdInstance().ipSecAddSecurityAssociation( resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", c.getSpiResourceId(direction), (auth != null) ? auth.getName() : null, (auth != null) ? auth.getKey() : null, (crypt != null) ? crypt.getName() : null, (crypt != null) ? crypt.getKey() : null, c.getEncapType(), c.getEncapSocketResourceId(direction), c.getMarkResourceId(direction), binder); if (result != 0) { throw new RemoteException("ipSecAddSecurityAssociation returned " + result); } } catch (ServiceSpecificException e) { throw new RemoteException("Error configuring transform", e); } } return new Bundle(); }

sample: 330
buggy_code:  * system server. If this is called on an inactive (or non-existent) transform, it will not * return an error. It's safe to de-allocate transforms that may have already been deleted for * other reasons. */ @Override public void deleteTransportModeTransform(int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord record; <|startfocus|> // We want to non-destructively get so that we can check credentials before removing this <|endfocus|> record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId);
code_review:  Long line. 
target code: * system server. If this is called on an inactive (or non-existent) transform, it will not * return an error. It's safe to de-allocate transforms that may have already been deleted for * other reasons. */ @Override public void deleteTransportModeTransform(int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord record; // We want to non-destructively get so that we can check credentials before removing // this from the records. record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId);
response: @Override public void deleteTransportModeTransform(int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord record; record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } record.releaseResources(); mTransformRecords.remove(resourceId); } }

sample: 331
buggy_code:  */ @Override public void deleteTransportModeTransform(int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord record; // We want to non-destructively get so that we can check credentials before removing this record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } <|startfocus|> if (record.pid != getCallingPid() || record.uid != getCallingUid()) { <|endfocus|> throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override
code_review:  Use Binder.getCalling{Pid,Uid}() 
target code: */ @Override public void deleteTransportModeTransform(int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord record; // We want to non-destructively get so that we can check credentials before removing this record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != Binder.getCallingPid() || record.uid != Binder.getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override
response: */ @Override public void deleteTransportModeTransform(int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord record; // We want to non-destructively get so that we can check credentials before removing this record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != Binder.getCallingPid() || record.uid != Binder.getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override

sample: 332
buggy_code:  if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } <|startfocus|> // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional <|endfocus|> record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord info; // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId); 
code_review:  Long line. 
target code: if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on // binder death. Need to make sure that path is actually functional. record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord info; // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId);
response: if (record == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord info; info = mTransformRecords.get(resourceId); // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional info.releaseResources(); } }

sample: 333
buggy_code:  // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override <|startfocus|> public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { <|endfocus|> synchronized (mTransformRecords) { TransformRecord info; // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } // TODO: make this a function. if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } 
code_review:  Long line. 
target code: // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord info; // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } // TODO: make this a function. if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); }
response: // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); mTransformRecords.remove(resourceId); record.nullifyRecord(); } } /** * Apply an active transport mode transform to a socket, which will apply the IPsec security * association as a correspondent policy to the provided socket */ @Override public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { synchronized (mTransformRecords) { TransformRecord info; // FIXME: this code should be factored out into a security check + getter info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } // TODO: make this a function. if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } } }

sample: 334
buggy_code:  } } } /** * Remove a transport mode transform from a socket, applying the default (empty) policy. This * will ensure that NO IPsec policy is applied to the socket (would be the equivalent of * applying a policy that performs no IPsec). Today the resourceId parameter is passed but not * used: reserved for future improved input validation. */ @Override <|startfocus|> public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { <|endfocus|> try { getNetdInstance().ipSecRemoveTransportModeTransform(socket.getFileDescriptor()); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { mContext.enforceCallingOrSelfPermission(DUMP, TAG); pw.println("IpSecService Log:"); pw.println("NetdNativeService Connection: " + (isNetdAlive() ? "alive" : "dead")); pw.println(); } } 
code_review:  Long line. 
target code: } } } /** * Remove a transport mode transform from a socket, applying the default (empty) policy. This * will ensure that NO IPsec policy is applied to the socket (would be the equivalent of * applying a policy that performs no IPsec). Today the resourceId parameter is passed but not * used: reserved for future improved input validation. */ @Override public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { try { getNetdInstance().ipSecRemoveTransportModeTransform(socket.getFileDescriptor()); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { mContext.enforceCallingOrSelfPermission(DUMP, TAG); pw.println("IpSecService Log:"); pw.println("NetdNativeService Connection: " + (isNetdAlive() ? "alive" : "dead")); pw.println(); } }
response: @Override public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { try { getNetdInstance().ipSecRemoveTransportModeTransform(socket.getFileDescriptor()); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { mContext.enforceCallingOrSelfPermission(DUMP, TAG); pw.println("IpSecService Log:"); pw.println("NetdNativeService Connection: " + (isNetdAlive() ? "alive" : "dead")); pw.println(); }

sample: 335
buggy_code:  // and a remote IP address int spi; // Encryption Algorithm IpSecAlgorithm encryption; // Authentication Algorithm IpSecAlgorithm authentication; } Flow[] flow = new Flow[] {new Flow(), new Flow()}; // For tunnel mode IPv4 UDP Encapsulation // IpSecTransform#ENCAP_ESP_*, such as ENCAP_ESP_OVER_UDP_IKE int encapType; int encapLocalPort; int encapRemotePort; <|startfocus|> // A bitmask of PROPERTY_* indicating which of the fields // of this class are valid. long properties; <|endfocus|> // An interval, in seconds between the NattKeepalive packets int nattKeepaliveInterval; // Transport or Tunnel public int getMode() { return mode; } public InetAddress getLocalAddress() { return localAddress; } public int getSpi(int direction) { return flow[direction].spi; } public InetAddress getRemoteAddress() { return remoteAddress; } public IpSecAlgorithm getEncryption(int direction) { return flow[direction].encryption; } public IpSecAlgorithm getAuthentication(int direction) {
code_review:  Do you use it? I don't see any users in this file. If it's unused, delete it. 
target code: // and a remote IP address int spi; // Encryption Algorithm IpSecAlgorithm encryption; // Authentication Algorithm IpSecAlgorithm authentication; } Flow[] flow = new Flow[] {new Flow(), new Flow()}; // For tunnel mode IPv4 UDP Encapsulation // IpSecTransform#ENCAP_ESP_*, such as ENCAP_ESP_OVER_UDP_IKE int encapType; int encapLocalPort; int encapRemotePort; // An interval, in seconds between the NattKeepalive packets int nattKeepaliveInterval; // Transport or Tunnel public int getMode() { return mode; } public InetAddress getLocalAddress() { return localAddress; } public int getSpi(int direction) { return flow[direction].spi; } public InetAddress getRemoteAddress() { return remoteAddress; } public IpSecAlgorithm getEncryption(int direction) { return flow[direction].encryption; } public IpSecAlgorithm getAuthentication(int direction) {
response: import org.apache.kudu.client.shaded.com.google.common.base.Preconditions; /** * Represents a literal timestamp. Its value is a 16-byte array that corresponds to a * raw BE TimestampValue, e.g., in a slot. In addition, it stores the string * representation of the timestamp value to avoid converting the raw bytes on the Java * side. Such a conversion could potentially be inconsistent with what the BE would * produce, so it's better to defer to a single source of truth (the BE implementation). * * Literal timestamps can currently only be created via constant folding. There is no * way to directly specify a literal timestamp from SQL. */ public class TimestampLiteral extends LiteralExpr { private final byte[] value_; private final String strValue_; public TimestampLiteral(byte[] value, String strValue) { Preconditions.checkState(value.length == Type.TIMESTAMP.getSlotSize()); value_ = value; strValue_ = strValue; type_ = Type.TIMESTAMP; } /** * Copy c'tor used in clone. */ }

sample: 336
buggy_code:  out.writeParcelable(flow[IpSecTransform.DIRECTION_OUT].encryption, flags); out.writeParcelable(flow[IpSecTransform.DIRECTION_OUT].authentication, flags); out.writeInt(encapType); out.writeInt(encapLocalPort); out.writeInt(encapRemotePort); } // Package Private: Used by the IpSecTransform.Builder; // there should be no public constructor for this object <|startfocus|> IpSecConfig() { flow[IpSecTransform.DIRECTION_IN].spi = 0; flow[IpSecTransform.DIRECTION_OUT].spi = 0; nattKeepaliveInterval = 0; //FIXME constant } <|endfocus|> private static InetAddress readInetAddressFromParcel(Parcel in) { String addrString = in.readString(); if (addrString == null) { return null; } try { return InetAddress.getByName(addrString); } catch (UnknownHostException e) { Log.wtf(TAG, "Invalid IpAddress " + addrString); return null; } } private IpSecConfig(Parcel in) { properties = in.readLong(); localAddress = readInetAddressFromParcel(in); remoteAddress = readInetAddressFromParcel(in);
code_review:  You don't need to do this, since Java guarantees that ints are initialized to 0. I think you might still need an empty constructor though. 
target code: out.writeParcelable(flow[IpSecTransform.DIRECTION_OUT].encryption, flags); out.writeParcelable(flow[IpSecTransform.DIRECTION_OUT].authentication, flags); out.writeInt(encapType); out.writeInt(encapLocalPort); out.writeInt(encapRemotePort); } // Package Private: Used by the IpSecTransform.Builder; // there should be no public constructor for this object IpSecConfig() {} private static InetAddress readInetAddressFromParcel(Parcel in) { String addrString = in.readString(); if (addrString == null) { return null; } try { return InetAddress.getByName(addrString); } catch (UnknownHostException e) { Log.wtf(TAG, "Invalid IpAddress " + addrString); return null; } } private IpSecConfig(Parcel in) { properties = in.readLong(); localAddress = readInetAddressFromParcel(in); remoteAddress = readInetAddressFromParcel(in);
response: out.writeParcelable(flow[IpSecTransform.DIRECTION_OUT].encryption, flags); out.writeParcelable(flow[IpSecTransform.DIRECTION_OUT].authentication, flags); out.writeInt(encapType); out.writeInt(encapLocalPort); out.writeInt(encapRemotePort); } IpSecConfig() { flow[IpSecTransform.DIRECTION_IN].spi = 0; flow[IpSecTransform.DIRECTION_OUT].spi = 0; nattKeepaliveInterval = 0; } private static InetAddress readInetAddressFromParcel(Parcel in) { String addrString = in.readString(); if (addrString == null) { return null; } try { return InetAddress.getByName(addrString); } catch (UnknownHostException e) { Log.wtf(TAG, "Invalid IpAddress " + addrString); return null; } } private IpSecConfig(Parcel in) { properties = in.readLong(); localAddress = readInetAddressFromParcel(in); remoteAddress = readInetAddressFromParcel(in); }

sample: 337
buggy_code:  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; <|startfocus|> import static android.content.Context.IPSEC_SERVICE; <|endfocus|> import android.annotation.IntDef; import android.annotation.NonNull; import android.annotation.SystemApi; import android.content.Context; import android.os.Binder; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import com.android.internal.util.Preconditions; import dalvik.system.CloseGuard; import java.io.IOException; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.net.InetAddress; /** * This class represents an IpSecTransform, which encapsulates both properties and state of IPsec. *
code_review:  Nit: you only seem to use this once, and you could make that callsite use Context.IPSEC_SERVICE instead. 
target code: * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; import static android.net.IpSecManager.INVALID_RESOURCE_ID; import static android.net.IpSecManager.KEY_STATUS; import static android.net.IpSecManager.KEY_RESOURCE_ID; import android.annotation.IntDef; import android.annotation.NonNull; import android.annotation.SystemApi; import android.content.Context; import android.os.Binder; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import com.android.internal.util.Preconditions; import dalvik.system.CloseGuard; import java.io.IOException; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.net.InetAddress; /** * This class represents an IpSecTransform, which encapsulates both properties and state of IPsec. *
response: package android.net; import android.annotation.IntDef; import android.annotation.NonNull; import android.annotation.SystemApi; import android.content.Context; import android.os.Binder; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import com.android.internal.util.Preconditions; import dalvik.system.CloseGuard; import java.io.IOException; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.net.InetAddress; /** * This class represents an IpSecTransform, which encapsulates both properties and state of IPsec. */ package android.net; import android.annotation.IntDef; import android.annotation.NonNull; import android.annotation.SystemApi; import android.content.Context; import android.os.Binder; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.os.ServiceManager; import android.util.Log; import com.android.internal.util.Preconditions; import dalvik.system.CloseGuard; import java.io.IOException; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.net.InetAddress; /** * This class represents an IpSecTransform, which encapsulates both properties and state of IPsec. */

sample: 338
buggy_code:  private IpSecTransform(Context context, IpSecConfig config) { mContext = context; mConfig = config; mResourceId = INVALID_RESOURCE_ID; } private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } <|startfocus|> /** @hide */ public static final String KEY_STATUS = "status"; /** @hide */ public static final String KEY_RESOURCE_ID = "resourceId"; <|endfocus|> private void checkResultStatus(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default:
code_review:  This duplicates IpSecManager.SecurityParameterIndex.KEY_STATUS. Consider moving that to IpSecManager and using it instead. 
target code: private IpSecTransform(Context context, IpSecConfig config) { mContext = context; mConfig = config; mResourceId = INVALID_RESOURCE_ID; } private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } private void checkResultStatus(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default:
response: import java.net.InetAddress; import java.net.Socket; /** * This class contains methods for managing IPsec sessions, which will perform kernel-space * encryption and decryption of socket or Network traffic. * * <p>An IpSecManager may be obtained by calling {@link * android.content.Context#getSystemService(String) Context#getSystemService(String)} with {@link * android.content.Context#IPSEC_SERVICE Context#IPSEC_SERVICE} */ public final class IpSecManager { private static final String TAG = "IpSecManager"; /** @hide */ public interface Status { public static final int OK = 0; public static final int RESOURCE_UNAVAILABLE = 1; public static final int SPI_UNAVAILABLE = 2; } /** @hide */ public static final String KEY_STATUS = "status"; /** @hide */ public static final String KEY_RESOURCE_ID = "resourceId"; private IpSecManager() { // Private constructor to prevent instantiation } private static IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } private void checkResultStatus(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IOException("Unknown status: " + status); } } }

sample: 339
buggy_code:  mConfig = config; mResourceId = INVALID_RESOURCE_ID; } private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } /** @hide */ public static final String KEY_STATUS = "status"; /** @hide */ public static final String KEY_RESOURCE_ID = "resourceId"; <|startfocus|> private void checkResultStatus(int status) <|endfocus|> throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IllegalStateException(
code_review:  Ditto. 
target code: mConfig = config; mResourceId = INVALID_RESOURCE_ID; } private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } /** @hide */ public static final String KEY_STATUS = "status"; /** @hide */ public static final String KEY_RESOURCE_ID = "resourceId"; private void checkResultStatusAndThrow(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IllegalStateException(
response: mConfig = config; mResourceId = INVALID_RESOURCE_ID; private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService").rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } private void checkResultStatus(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException("Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IllegalStateException("Unknown status: " + status); } }

sample: 340
buggy_code:  } private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } /** @hide */ public static final String KEY_STATUS = "status"; /** @hide */ public static final String KEY_RESOURCE_ID = "resourceId"; <|startfocus|> private void checkResultStatus(int status) <|endfocus|> throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IllegalStateException( "Failed to Create a Transform with status code " + status); } } private IpSecTransform activate()
code_review:  Maybe give this method a name that suggests that it will throw if there's an error? checkStatusOrThrow? 
target code: } private IIpSecService getIpSecService() { IBinder b = ServiceManager.getService(IPSEC_SERVICE); if (b == null) { throw new RemoteException("Failed to connect to IpSecService") .rethrowAsRuntimeException(); } return IIpSecService.Stub.asInterface(b); } /** @hide */ public static final String KEY_STATUS = "status"; /** @hide */ public static final String KEY_RESOURCE_ID = "resourceId"; private void checkResultStatusAndThrow(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException( "Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IllegalStateException( "Failed to Create a Transform with status code " + status); } } private IpSecTransform activate()
response: private void checkResultStatus(int status) throws IOException, IpSecManager.ResourceUnavailableException, IpSecManager.SpiUnavailableException { switch (status) { case IpSecManager.Status.OK: return; case IpSecManager.Status.RESOURCE_UNAVAILABLE: throw new IpSecManager.ResourceUnavailableException("Failed to allocate a new IpSecTransform"); case IpSecManager.Status.SPI_UNAVAILABLE: Log.wtf(TAG, "Attempting to use an SPI that was somehow not reserved"); // Fall through default: throw new IllegalStateException("Failed to Create a Transform with status code " + status); } }

sample: 341
buggy_code:  private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; private static final int[] DIRECTIONS = new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms <|startfocus|> private AtomicInteger mNextTransformId = new AtomicInteger(0xFADED000); <|endfocus|> private abstract class ManagedResource implements IBinder.DeathRecipient { final int pid; final int uid; private IBinder mBinder; ManagedResource(IBinder binder) { super(); mBinder = binder; pid = getCallingPid(); uid = getCallingUid(); try { mBinder.linkToDeath(this, 0); } catch (RemoteException e) { binderDied(); } } /** * When this record is no longer needed for managing system resources this function should * unlink all references held by the record to allow efficient garbage collection. */
code_review:  I think this is a negative number. Is that OK? 
target code: private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; private static final int[] DIRECTIONS = new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms private AtomicInteger mNextResourceId = new AtomicInteger(0x00FADED0); private abstract class ManagedResource implements IBinder.DeathRecipient { final int pid; final int uid; private IBinder mBinder; ManagedResource(IBinder binder) { super(); mBinder = binder; pid = getCallingPid(); uid = getCallingUid(); try { mBinder.linkToDeath(this, 0); } catch (RemoteException e) { binderDied(); } } /** * When this record is no longer needed for managing system resources this function should * unlink all references held by the record to allow efficient garbage collection. */
response: private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final String NETD_SERVICE_NAME = "netd"; private static final int[] DIRECTIONS = new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}; /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms private AtomicInteger mNextTransformId = new AtomicInteger(0xFADED000); private abstract class ManagedResource implements IBinder.DeathRecipient { final int pid; final int uid; private IBinder mBinder; ManagedResource(IBinder binder) { super(); mBinder = binder; pid = getCallingPid(); uid = getCallingUid(); try { mBinder.linkToDeath(this, 0); } catch (RemoteException e) { binderDied(); } } /** * When this record is no longer needed for managing system resources this function should * unlink all references held by the record to allow efficient garbage collection. */ }

sample: 342
buggy_code:  /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms private AtomicInteger mNextTransformId = new AtomicInteger(0xFADED000); private abstract class ManagedResource implements IBinder.DeathRecipient { final int pid; final int uid; private IBinder mBinder; ManagedResource(IBinder binder) { super(); mBinder = binder; <|startfocus|> pid = getCallingPid(); uid = getCallingUid(); <|endfocus|> try { mBinder.linkToDeath(this, 0); } catch (RemoteException e) { binderDied(); } } /** * When this record is no longer needed for managing system resources this function should * unlink all references held by the record to allow efficient garbage collection. */ public final void release() { //Release all the underlying system resources first releaseResources(); if (mBinder != null) { mBinder.unlinkToDeath(this, 0); } mBinder = null; 
code_review:  Since this is a static method, would suggest explicitly wording it as Binder.getCallingPid(). Same for getCallingUid. 
target code: /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms private AtomicInteger mNextTransformId = new AtomicInteger(0xFADED000); private abstract class ManagedResource implements IBinder.DeathRecipient { final int pid; final int uid; private IBinder mBinder; ManagedResource(IBinder binder) { super(); mBinder = binder; pid = Binder.getCallingPid(); uid = Binder.getCallingUid(); try { mBinder.linkToDeath(this, 0); } catch (RemoteException e) { binderDied(); } } /** * When this record is no longer needed for managing system resources this function should * unlink all references held by the record to allow efficient garbage collection. */ public final void release() { //Release all the underlying system resources first releaseResources(); if (mBinder != null) { mBinder.unlinkToDeath(this, 0); } mBinder = null;
response: /** Binder context for this service */ private final Context mContext; private Object mLock = new Object(); private static final int NETD_FETCH_TIMEOUT = 5000; //ms private AtomicInteger mNextTransformId = new AtomicInteger(0xFADED000); private abstract class ManagedResource implements IBinder.DeathRecipient { final int pid; final int uid; private IBinder mBinder; ManagedResource(IBinder binder) { super(); mBinder = binder; pid = Binder.getCallingPid(); uid = Binder.getCallingUid(); try { mBinder.linkToDeath(this, 0); } catch (RemoteException e) { binderDied(); } } /** * When this record is no longer needed for managing system resources this function should * unlink all references held by the record to allow efficient garbage collection. */ public final void release() { //Release all the underlying system resources first releaseResources(); if (mBinder != null) { mBinder.unlinkToDeath(this, 0); } mBinder = null; } }

sample: 343
buggy_code:  protected void releaseResources() { <|startfocus|> for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { <|endfocus|> try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }
code_review:  Use the class member DIRECTIONS instead? 
target code: protected void releaseResources() { for (int direction : DIRECTIONS) { try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }
response: protected void releaseResources() { for (int direction : DIRECTIONS) { try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction) ); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } }

sample: 344
buggy_code:  mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { <|startfocus|> throw e.rethrowFromSystemServer(); <|endfocus|> } }
code_review:  If this code runs while netd is unavailable (e.g., if it crashed and is restarted), will it crash the system server? We should avoid that if possible. 
target code: mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { Log.e(TAG, "Failed to delete SA with ID: " + mResourceId); } }
response: mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }

sample: 345
buggy_code:  retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); synchronized (mSpiRecords) { mSpiRecords.put( resourceId, new SpiRecord( resourceId, direction, localAddress, remoteAddress, spi, binder)); } } catch (ServiceSpecificException e) { <|startfocus|> retBundle.putInt( IpSecManager.SecurityParameterIndex.KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); <|endfocus|> } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } return retBundle;
code_review:  Nit: is this the correct status to use? Maybe add a TODO to get the actual error code from netd and do more detailed error reporting. 
target code: retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); synchronized (mSpiRecords) { mSpiRecords.put( resourceId, new SpiRecord( resourceId, direction, localAddress, remoteAddress, spi, binder)); } } catch (ServiceSpecificException e) { // TODO: Add appropriate checks when other ServiceSpecificException types are supported retBundle.putInt(KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt(KEY_RESOURCE_ID, resourceId); retBundle.putInt(KEY_SPI, spi); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } return retBundle;
response: public IPageManager getPageManager() throws HyracksDataException { throw HyracksDataException.create(ErrorCode.LSM_INVERTED_INDEX_DOES_NOT_HAVE_PAGE_MANAGER); } public JobManager(CCConfig ccConfig, ClusterControllerService ccs, IResourceManager resourceManager) throws HyracksException { this.ccs = ccs; this.resourceManager = resourceManager; try { Constructor<?> jobQueueConstructor = this.getClass().getClassLoader().loadClass(ccConfig.jobQueueClassName) .getConstructor(IJobManager.class); jobQueue = (IJobQueue) jobQueueConstructor.newInstance(this); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) { throw HyracksException.create(ErrorCode.CLASS_LOADING_ISSUE, e, e.getMessage()); } activeRunMap = new HashMap<>(); runMapArchive = new LinkedHashMap<JobId, JobRun>() { private static final long serialVersionUID = 1L; @Override protected boolean removeEldestEntry(Map.Entry<JobId, JobRun> eldest) { return size() > ccConfig.jobHistorySize; } }; runMapHistory = new LinkedHashMap<JobId, List<Exception>>() { private static final long serialVersionUID = 1L; /** history size + 1 is for the case when history size = 0 */ }; } if (getDatasetType() == DatasetType.INTERNAL) { IActiveEntityEventsListener[] activeListeners = ActiveJobNotificationHandler.INSTANCE.getEventListeners(); for (IActiveEntityEventsListener listener : activeListeners) { if (listener.isEntityUsingDataset(dataverseName, datasetName)) { throw new CompilationException(ErrorCode.COMPILATION_CANT_DROP_ACTIVE_DATASET, ARecordType.toFullyQualifiedName(dataverseName, datasetName), listener.getEntityId().toString()); } } List<Index> indexes = MetadataManager.INSTANCE.getDatasetIndexes(mdTxnCtx.getValue(), dataverseName, datasetName); for (int j = 0; j < indexes.size(); j++) { if (indexes.get(j).isSecondaryIndex()) { jobsToExecute.add(IndexUtils.dropJob(indexes.get(j), metadataProvider, this)); } } Index primaryIndex = MetadataManager.INSTANCE.getIndex(mdTxnCtx.getValue(), dataverseName, datasetName, datasetName); jobsToExecute.add(Dataset

sample: 346
buggy_code:  public void deleteTransportModeTransform(int resourceId) { synchronized (mTransformRecords) { TransformRecord record; <|startfocus|> // We want to non-destructively get so that we can check credentials before removing this <|endfocus|> record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // remove from the DB because releasing might fail, but it won't ever succeed later mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord(); }
code_review:  Nit: long line 
target code: public void deleteTransportModeTransform(int resourceId) { synchronized (mTransformRecords) { TransformRecord record; // We want to non-destructively get so that we can check credentials before removing // this from the records. record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // remove from the DB because releasing might fail, but it won't ever succeed later mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord(); }
response: public void deleteTransportModeTransform(int resourceId) { synchronized (mTransformRecords) { TransformRecord record; record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord(); } }

sample: 347
buggy_code:  record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } <|startfocus|> // remove from the DB because releasing might fail, but it won't ever succeed later mTransformRecords.remove(resourceId); <|endfocus|> record.releaseResources(); record.nullifyRecord(); }
code_review:  Technically it could, if we try to release it when netd is crashing. Not sure how much we can do about that at this point though. 
target code: record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException( "Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional record.releaseResources(); record.nullifyRecord(); }
response: record = mTransformRecords.get(resourceId); if (record == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not available to be deleted"); } if (record.pid != getCallingPid() || record.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may delete it!"); } mTransformRecords.remove(resourceId); record.releaseResources(); record.nullifyRecord();

sample: 348
buggy_code:  info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } IpSecConfig c = info.getConfig(); try { <|startfocus|> for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { <|endfocus|> getNetdInstance() .ipSecApplyTransportModeTransform( socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", c.getSpi(direction)); } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception
code_review:  Can you use DIRECTIONS instead? 
target code: info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } IpSecConfig c = info.getConfig(); try { for (int direction : DIRECTIONS) { getNetdInstance() .ipSecApplyTransportModeTransform( socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", c.getSpi(direction)); } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception
response: info = mTransformRecords.get(resourceId); if (info == null) { throw new IllegalArgumentException("Transform " + resourceId + " is not active"); } if (info.pid != getCallingPid() || info.uid != getCallingUid()) { throw new SecurityException("Only the owner of an IpSec Transform may apply it!"); } IpSecConfig c = info.getConfig(); try { for (int direction : IpSecTransform.DIRECTIONS) { getNetdInstance() .ipSecApplyTransportModeTransform( socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", c.getSpi(direction) ); } } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception }

sample: 349
buggy_code:  * <h3>Developer Guides</h3> * <p>For more information about using Bluetooth, read the * <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.</p> * </div> * * {@see BluetoothServerSocket} * {@see java.io.InputStream} * {@see java.io.OutputStream} */ public final class BluetoothSocket implements Closeable { private static final String TAG = "BluetoothSocket"; <|startfocus|> private static final boolean DBG = true; <|endfocus|> private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE); /** @hide */ public static final int MAX_RFCOMM_CHANNEL = 30; /*package*/ static final int MAX_L2CAP_PACKAGE_SIZE = 0xFFFF; /** RFCOMM socket */ public static final int TYPE_RFCOMM = 1; /** SCO socket */ public static final int TYPE_SCO = 2; /** L2CAP socket */ public static final int TYPE_L2CAP = 3; /*package*/ static final int EBADFD = 77; /*package*/ static final int EADDRINUSE = 98; 
code_review:  Have not looked through the whole file, but BluetoothSocket is already very spammy as is. This seems like it has huge potential to be spam-overload. If you're only interested in the log below, maybe move it out of "if (DBG)" instead? 
target code: * <h3>Developer Guides</h3> * <p>For more information about using Bluetooth, read the * <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.</p> * </div> * * {@see BluetoothServerSocket} * {@see java.io.InputStream} * {@see java.io.OutputStream} */ public final class BluetoothSocket implements Closeable { private static final String TAG = "BluetoothSocket"; private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE); /** @hide */ public static final int MAX_RFCOMM_CHANNEL = 30; /*package*/ static final int MAX_L2CAP_PACKAGE_SIZE = 0xFFFF; /** RFCOMM socket */ public static final int TYPE_RFCOMM = 1; /** SCO socket */ public static final int TYPE_SCO = 2; /** L2CAP socket */ public static final int TYPE_L2CAP = 3; /*package*/ static final int EBADFD = 77; /*package*/ static final int EADDRINUSE = 98;
response: public final class BluetoothSocket implements Closeable { private static final String TAG = "BluetoothSocket"; private static final boolean DBG = true; private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE); public static final int MAX_RFCOMM_CHANNEL = 30; static final int MAX_L2CAP_PACKAGE_SIZE = 0xFFFF; public static final int TYPE_RFCOMM = 1; public static final int TYPE_SCO = 2; public static final int TYPE_L2CAP = 3; static final int EBADFD = 77; static final int EADDRINUSE = 98; }

sample: 350
buggy_code: <|startfocus|> * Copyright (C) 2015 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.cts; import android.content.Context; import android.net.ConnectivityManager; import android.net.IpSecAlgorithm; import android.net.IpSecManager; import android.net.IpSecTransform; import android.net.Network; import android.test.AndroidTestCase; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.UnknownHostException; 
code_review:  7 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.cts; import android.content.Context; import android.net.ConnectivityManager; import android.net.IpSecAlgorithm; import android.net.IpSecManager; import android.net.IpSecTransform; import android.net.Network; import android.test.AndroidTestCase; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.UnknownHostException;
response: /* Copyright (C) 2015 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.cts; import android.content.Context; import android.net.ConnectivityManager; import android.net.IpSecAlgorithm; import android.net.IpSecManager; import android.net.IpSecTransform; import android.net.Network; import android.test.AndroidTestCase; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.UnknownHostException;

sample: 351
buggy_code: <|startfocus|> public void testAllocSpi() { <|endfocus|> for (InetAddress addr : GOOGLE_DNS_LIST) { IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null; try { randomSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(droidSpi.getSpi() == DROID_SPI); } catch (IpSecManager.ResourceUnavailableException | IpSecManager.SpiUnavailableException ru) { assertTrue(false); } // This *should* throw an SpiUnavailableException try { mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(false); // we expect an exception in the above call } catch (IpSecManager.ResourceUnavailableException ru) { assertTrue(false); } catch (IpSecManager.SpiUnavailableException sp) { } randomSpi.close(); droidSpi.close(); }
code_review:  extra blank line. 
target code: public void testAllocSpi() throws Exception { for (InetAddress addr : GOOGLE_DNS_LIST) { IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null; try { randomSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(droidSpi.getSpi() == DROID_SPI); } catch (IpSecManager.ResourceUnavailableException | IpSecManager.SpiUnavailableException ru) { assertTrue(false); } // This *should* throw an SpiUnavailableException try { mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(false); // we expect an exception in the above call } catch (IpSecManager.ResourceUnavailableException ru) { assertTrue(false); } catch (IpSecManager.SpiUnavailableException sp) { } randomSpi.close(); droidSpi.close(); }
response: public void testAllocSpi() { for (InetAddress addr : GOOGLE_DNS_LIST) { IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null; try { randomSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(droidSpi.getSpi() == DROID_SPI); } catch (IpSecManager.ResourceUnavailableException | IpSecManager.SpiUnavailableException ru) { assertTrue(false); } // This *should* throw an SpiUnavailableException try { mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(false); // we expect an exception in the above call } catch (IpSecManager.ResourceUnavailableException ru) { assertTrue(false); } catch (IpSecManager.SpiUnavailableException sp) { } randomSpi.close(); droidSpi.close(); } }

sample: 352
buggy_code:  try { randomSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(droidSpi.getSpi() == DROID_SPI); } catch (IpSecManager.ResourceUnavailableException | IpSecManager.SpiUnavailableException ru) { assertTrue(false); } <|startfocus|> // This *should* throw an SpiUnavailableException <|endfocus|> try { mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(false); // we expect an exception in the above call } catch (IpSecManager.ResourceUnavailableException ru) { assertTrue(false); } catch (IpSecManager.SpiUnavailableException sp) { } randomSpi.close(); droidSpi.close(); }
code_review:  use fail() with a meaningful error msg. Otherwise let the errors propagate and declare testAllocSpi to throws Exception ? 
target code: try { randomSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(droidSpi.getSpi() == DROID_SPI); } catch (IpSecManager.ResourceUnavailableException | IpSecManager.SpiUnavailableException ru) { assertTrue(false); } try { mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue(false); // we expect an exception in the above call } catch (IpSecManager.ResourceUnavailableException ru) { assertTrue(false); } catch (IpSecManager.SpiUnavailableException sp) { } randomSpi.close(); droidSpi.close(); }
response: throws AuthException, BadRequestException, ResourceConflictException, Exception { try { ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), ChangeSet.create(resource.getChange())); json.addOptions(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS)); return json.format(cs.ids()); } catch (OrmException | IOException e) { log.error("Error on getting a ChangeSet", e); return Collections.emptyList(); } } throws AuthException, BadRequestException, ResourceConflictException, Exception { try { ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), ChangeSet.create(resource.getChange())); json.addOptions(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS)); return json.format(cs.ids()); } catch (OrmException | IOException e) { log.error("Error on getting a ChangeSet", e); throw e; } } public void test_NoClassDefFoundError_constructor_with_cause() { Class<NoClassDefFoundError> klass = NoClassDefFoundError.class; try { klass.getDeclaredConstructor(String.class, Throwable.class); } catch (Exception exc) { throw new RuntimeException(exc); } } public void test_NoClassDefFoundError_constructor_with_cause() { Class<NoClassDefFoundError> klass = NoClassDefFoundError.class; // This will succeed if the constructor is declared in NoClassDefFoundError. klass.getDeclaredConstructor(String.class, Throwable.class); } // a statestore heartbeat that contains the update. resp.getResult().setVersion(modifiedObjects.second.getCatalogVersion()); } else { // Invalidate the entire catalog if no table name is provided. Preconditions.checkArgument(!req.isIs_refresh()); catalog_.reset(); resp.result.setVersion(catalog_.getCatalogVersion()); } resp.getResult().setStatus(new TStatus(TStatusCode.OK, new ArrayList<String>())); return resp; } // a statestore heartbeat that contains the update. resp.getResult().setVersion(modifiedObjects.second.getCatalogVersion()); } else { // Invalidate the entire catalog if no table name is provided. Preconditions.checkArgument(!req.isIs_refresh()); catalog_.reset(); resp.result.setVersion(catalog_.

sample: 353
buggy_code:  public void testCreateTransform() { try { <|startfocus|> InetAddress remote = InetAddress.getLoopbackAddress(); IpSecManager.SecurityParameterIndex outSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, remote, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); <|endfocus|> IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, remote, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); IpSecTransform firstTransform = new IpSecTransform.Builder(mContext) .setSpi(IpSecTransform.DIRECTION_OUT, outSpi) .setEncryption( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm( IpSecAlgorithm.ALGO_CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm( IpSecAlgorithm.ALGO_AUTH_HMAC_SHA256, AUTH_KEY, AUTH_KEY.length * 8)) .setSpi(IpSecTransform.DIRECTION_IN, inSpi) .setEncryption( IpSecTransform.DIRECTION_IN, new IpSecAlgorithm( IpSecAlgorithm.ALGO_CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(
code_review:  Consider removing try and letting the errors bubble up. 
target code: public void testCreateTransform() { try { IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, local, outSpi.getSpi()); IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, remote, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); IpSecTransform firstTransform = new IpSecTransform.Builder(mContext) .setSpi(IpSecTransform.DIRECTION_OUT, outSpi) .setEncryption( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm( IpSecAlgorithm.ALGO_CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm( IpSecAlgorithm.ALGO_AUTH_HMAC_SHA256, AUTH_KEY, AUTH_KEY.length * 8)) .setSpi(IpSecTransform.DIRECTION_IN, inSpi) .setEncryption( IpSecTransform.DIRECTION_IN, new IpSecAlgorithm( IpSecAlgorithm.ALGO_CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(
response: public void testCreateTransform() { InetAddress remote = InetAddress.getLoopbackAddress(); IpSecManager.SecurityParameterIndex outSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, remote, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, remote, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); IpSecTransform firstTransform = new IpSecTransform.Builder(mContext) .setSpi(IpSecTransform.DIRECTION_OUT, outSpi) .setEncryption(IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.ALGO_CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.ALGO_AUTH_HMAC_SHA256, AUTH_KEY, AUTH_KEY.length * 8)) .setSpi(IpSecTransform.DIRECTION_IN, inSpi) .setEncryption(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.ALGO_CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.ALGO_AUTH_HMAC_SHA256, AUTH_KEY, AUTH_KEY.length * 8)) .build(); }

sample: 354
buggy_code:  TimeZone biasMatch = null; for (int i = 0; i < candidates.size(); i++) { TimeZone match = candidates.get(i); if (!offsetMatchesAtTime(match, offsetSeconds, isDst, whenMillis)) { continue; } if (firstMatch == null) { firstMatch = match; if (bias == null) { // Terminate early if there is no bias. break; } } if (match.getID().equals(bias.getID())) { <|startfocus|> biasMatch = match; break; <|endfocus|> } } TimeZone toReturn; if (biasMatch != null) { toReturn = biasMatch; } else if (firstMatch != null) { toReturn = firstMatch; } else { return null; } return toReturn;
code_review:  Shouldn't we return immediately here? I think the if-else cascade at the end of this method is a bit more complicated than necessary. 
target code: TimeZone biasMatch = null; for (int i = 0; i < candidates.size(); i++) { TimeZone match = candidates.get(i); if (!offsetMatchesAtTime(match, offsetSeconds, isDst, whenMillis)) { continue; } if (firstMatch == null) { firstMatch = match; if (bias == null) { // Terminate early if there is no bias. break; } } if (match.getID().equals(bias.getID())) { return match; } } TimeZone toReturn; if (biasMatch != null) { toReturn = biasMatch; } else if (firstMatch != null) { toReturn = firstMatch; } else { return null; } return toReturn;
response: TimeZone biasMatch = null; for (int i = 0; i < candidates.size(); i++) { TimeZone match = candidates.get(i); if (!offsetMatchesAtTime(match, offsetSeconds, isDst, whenMillis)) { continue; } if (firstMatch == null) { firstMatch = match; if (bias == null) { // Terminate early if there is no bias. break; } } if (match.getID().equals(bias.getID())) { biasMatch = match; break; } } if (biasMatch != null) { return biasMatch; } else if (firstMatch != null) { return firstMatch; } else { return null; }

sample: 355
buggy_code: import java.nio.file.Path; import java.nio.file.SimpleFileVisitor; import java.nio.file.attribute.BasicFileAttributes; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.stream.Collectors; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.fail; public class TimeZoneFinderTest { <|startfocus|> private Path testDir;// 22nd July 2017, 13:14:15 (DST time in UK) <|endfocus|> private static final int HOUR_MILLIS = 60 * 60 * 1000; // Zones used in the tests. NEW_YORK_TZ and LONDON_TZ chosen because they never overlap but both // have DST. private static final TimeZone NEW_YORK_TZ = TimeZone.getTimeZone("America/New_York"); private static final TimeZone LONDON_TZ = TimeZone.getTimeZone("Europe/London"); // A zone that matches LONDON_TZ for WHEN_NO_DST. It does not have DST so differs for WHEN_DST.
code_review:  ? 
target code: import java.nio.file.Path; import java.nio.file.SimpleFileVisitor; import java.nio.file.attribute.BasicFileAttributes; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.stream.Collectors; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.fail; public class TimeZoneFinderTest { private static final int HOUR_MILLIS = 60 * 60 * 1000; // Zones used in the tests. NEW_YORK_TZ and LONDON_TZ chosen because they never overlap but both // have DST. private static final TimeZone NEW_YORK_TZ = TimeZone.getTimeZone("America/New_York"); private static final TimeZone LONDON_TZ = TimeZone.getTimeZone("Europe/London"); // A zone that matches LONDON_TZ for WHEN_NO_DST. It does not have DST so differs for WHEN_DST.
response: import java.nio.file.Path; import java.nio.file.SimpleFileVisitor; import java.nio.file.attribute.BasicFileAttributes; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.stream.Collectors; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.fail; public class TimeZoneFinderTest { private Path testDir; private static final int HOUR_MILLIS = 60 * 60 * 1000; private static final TimeZone NEW_YORK_TZ = TimeZone.getTimeZone("America/New_York"); private static final TimeZone LONDON_TZ = TimeZone.getTimeZone("Europe/London"); private static final TimeZone WHEN_NO_DST = TimeZone.getTimeZone("Europe/Paris"); private static final TimeZone WHEN_DST = TimeZone.getTimeZone("Europe/Madrid"); private static final Set<String> ZONES_WITH_DST = new HashSet<>(Arrays.asList( "America/Los_Angeles", "America/Denver", "America/Chicago", "America/New_York", "Europe/London", "Europe/Paris", "Europe/Madrid", "Asia/Tokyo", "Australia/Sydney" )); private static final Set<String> ZONES_WITHOUT_DST = new HashSet<>(Arrays.asList( "America/Phoenix", "America/Adak", "Pacific/Honolulu", "Pacific/Guam", "Pacific/Samoa", "Pacific/Midway", "Pacific/Niue", "Pacific/Pago_Pago", "Pacific/Tahiti", "Pacific/Marquesas", "Pacific/Gambier", "Pacific/Pitcairn", "Pacific/Galapagos", "Pacific/Easter", "Pacific/Fakaofo", "Pacific/Tongatapu", "Pacific/Apia", "Pacific/Kiritimati", "Pacific/Chatham", "Pacific/Auckland", "Pacific/Fiji", "Pacific/Noumea", "Pacific/Norfolk", "Pacific/Vanuatu", "Pacific/Wallis", "Pacific/Funafuti", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Nauru", "Pacific/Tarawa", "Pacific/Wake", "Pacific/Yap", "Pacific/Chuuk", "Pacific/Pohnpei", "

sample: 356
buggy_code:  } @Test public void xmlParsing_emptyFile() throws Exception { checkThrowsParserException(""); } @Test public void xmlParsing_unexpectedRootElement() throws Exception { checkThrowsParserException("<foo></foo>\n"); } @Test public void xmlParsing_missingCountryZones() throws Exception { checkThrowsParserException("<timezones></timezones>\n"); } @Test public void xmlParsing_noCountriesOk() throws Exception { <|startfocus|> parse("<timezones>\n" <|endfocus|> + " <countryzones>\n" + " </countryzones>\n" + "</timezones>\n"); } @Test public void xmlParsing_unexpectedElementsIgnored() throws Exception { String unexpectedElement = "<unexpected-element>\n<a /></unexpected-element>\n"; TimeZoneFinder finder = parse("<timezones>\n" + " " + unexpectedElement + " <countryzones>\n" + " <country code=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n" + " </countryzones>\n" + "</timezones>\n");
code_review:  shouldn't a well-formed but empty file be treated as an error? we'd fall back to an empty map anyway, but I'd expect that to be reported. Also, if the first file is well-formed but empty, shouldn't we fall back to the second file? Yes, I know this could be a slippery slope, because by the same argument a file with just a single argument is probably invalid ... 
target code: } @Test public void xmlParsing_emptyFile() throws Exception { checkThrowsParserException(""); } @Test public void xmlParsing_unexpectedRootElement() throws Exception { checkThrowsParserException("<foo></foo>\n"); } @Test public void xmlParsing_missingCountryZones() throws Exception { checkThrowsParserException("<timezones></timezones>\n"); } @Test public void xmlParsing_noCountriesOk() throws Exception { validate("<timezones>\n" + " <countryzones>\n" + " </countryzones>\n" + "</timezones>\n"); } @Test public void xmlParsing_unexpectedElementsIgnored() throws Exception { String unexpectedElement = "<unexpected-element>\n<a /></unexpected-element>\n"; TimeZoneFinder finder = parse("<timezones>\n" + " " + unexpectedElement + " <countryzones>\n" + " <country code=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n" + " </countryzones>\n" + "</timezones>\n");
response: @Test public void xmlParsing_emptyFile() throws Exception { checkThrowsParserException(""); } @Test public void xmlParsing_unexpectedRootElement() throws Exception { checkThrowsParserException("<foo></foo>\n"); } @Test public void xmlParsing_missingCountryZones() throws Exception { checkThrowsParserException("<timezones></timezones>\n"); } @Test public void xmlParsing_noCountriesOk() throws Exception { parse("<timezones>\n" + " <countryzones>\n" + " </countryzones>\n" + "</timezones>\n"); } @Test public void xmlParsing_unexpectedElementsIgnored() throws Exception { String unexpectedElement = "<unexpected-element>\n<a /></unexpected-element>\n"; TimeZoneFinder finder = parse("<timezones>\n" + " " + unexpectedElement + " <countryzones>\n" + " <country code=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n" + " </countryzones>\n" + "</timezones>\n"); }

sample: 357
buggy_code:  checkThrowsParserException("<foo></foo>\n"); } @Test public void xmlParsing_missingCountryZones() throws Exception { checkThrowsParserException("<timezones></timezones>\n"); } @Test public void xmlParsing_noCountriesOk() throws Exception { parse("<timezones>\n" + " <countryzones>\n" + " </countryzones>\n" + "</timezones>\n"); } @Test public void xmlParsing_unexpectedElementsIgnored() throws Exception { String unexpectedElement = "<unexpected-element>\n<a /></unexpected-element>\n"; <|startfocus|> TimeZoneFinder finder = parse("<timezones>\n" <|endfocus|> + " " + unexpectedElement + " <countryzones>\n" + " <country code=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n" + " </countryzones>\n" + "</timezones>\n"); assertZonesEqual(zones("Europe/London"), finder.lookupTimeZonesByCountry("gb")); finder = parse("<timezones>\n" + " <countryzones>\n" + " " + unexpectedElement
code_review:  maybe test that comments in various positions (including inside the <id> tag) are ignored. I think XmlPullParser does that for you, but a test would be nice. 
target code: checkThrowsParserException("<foo></foo>\n"); } @Test public void xmlParsing_missingCountryZones() throws Exception { checkThrowsParserException("<timezones></timezones>\n"); } @Test public void xmlParsing_noCountriesOk() throws Exception { parse("<timezones>\n" + " <countryzones>\n" + " </countryzones>\n" + "</timezones>\n"); } @Test public void xmlParsing_unexpectedElementsIgnored() throws Exception { String unexpectedElement = "<unexpected-element>\n<a /></unexpected-element>\n"; TimeZoneFinder finder = validate("<timezones>\n" + " " + unexpectedElement + " <countryzones>\n" + " <country code=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n" + " </countryzones>\n" + "</timezones>\n"); assertZonesEqual(zones("Europe/London"), finder.lookupTimeZonesByCountry("gb")); finder = parse("<timezones>\n" + " <countryzones>\n" + " " + unexpectedElement
response: @Test public void xmlParsing_unexpectedElementsIgnored() throws Exception { String unexpectedElement = "<unexpected-element>\n<a /></unexpected-element>\n"; TimeZoneFinder finder = parse("<timezones>\n" + unexpectedElement + " <countryzones>\n" + " <country code=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n" + " </countryzones>\n" + "</timezones>\n"); assertZonesEqual(zones("Europe/London"), finder.lookupTimeZonesByCountry("gb")); finder = parse("<timezones>\n" + " <countryzones>\n" + unexpectedElement + " </countryzones>\n" + "</timezones>\n"); assertZonesEqual(zones(), finder.lookupTimeZonesByCountry("gb")); }

sample: 358
buggy_code:  mHandler.sendMessageDelayed(msg1, 1000); } } break; case MSG_INCOMING_CONNECTION_RETRY: if (mBatchs.size() == 0) { Log.i(TAG, "Start Obex Server"); createServerSession(mPendingConnection); mIncomingRetries = 0; mPendingConnection = null; } else { if (mIncomingRetries == 20) { Log.w(TAG, "Retried 20 seconds, reject connection"); <|startfocus|> if (mServerSocket != null) { mServerSocket.prepareForNewConnect(); } <|endfocus|> try { mPendingConnection.close(); } catch (IOException e) { Log.e(TAG, "close tranport error"); } mIncomingRetries = 0; mPendingConnection = null; } else { Log.i(TAG, "OPP busy! Retry after 1 second"); mIncomingRetries = mIncomingRetries + 1; Message msg2 = Message.obtain(mHandler); msg2.what = MSG_INCOMING_CONNECTION_RETRY; mHandler.sendMessageDelayed(msg2, 1000); } } break; }
code_review:  shouldn't this be after the try/catch ? 
target code: mHandler.sendMessageDelayed(msg1, 1000); } } break; case MSG_INCOMING_CONNECTION_RETRY: if (mBatchs.size() == 0) { Log.i(TAG, "Start Obex Server"); createServerSession(mPendingConnection); mIncomingRetries = 0; mPendingConnection = null; } else { if (mIncomingRetries == 20) { Log.w(TAG, "Retried 20 seconds, reject connection"); try { mPendingConnection.close(); } catch (IOException e) { Log.e(TAG, "close tranport error"); } mIncomingRetries = 0; mPendingConnection = null; } else { Log.i(TAG, "OPP busy! Retry after 1 second"); mIncomingRetries = mIncomingRetries + 1; Message msg2 = Message.obtain(mHandler); msg2.what = MSG_INCOMING_CONNECTION_RETRY; mHandler.sendMessageDelayed(msg2, 1000); } } break; }
response: mHandler.sendMessageDelayed(msg1, 1000); } break; case MSG_INCOMING_CONNECTION_RETRY: if (mBatchs.size() == 0) { Log.i(TAG, "Start Obex Server"); createServerSession(mPendingConnection); mIncomingRetries = 0; mPendingConnection = null; } else { if (mIncomingRetries == 20) { Log.w(TAG, "Retried 20 seconds, reject connection"); if (mServerSocket != null) { mServerSocket.prepareForNewConnect(); } try { mPendingConnection.close(); } catch (IOException e) { Log.e(TAG, "close tranport error"); } mIncomingRetries = 0; mPendingConnection = null; } else { Log.i(TAG, "OPP busy! Retry after 1 second"); mIncomingRetries = mIncomingRetries + 1; Message msg2 = Message.obtain(mHandler); msg2.what = MSG_INCOMING_CONNECTION_RETRY; mHandler.sendMessageDelayed(msg2, 1000); } } break;

sample: 359
buggy_code:  protected void releaseResources() { <|startfocus|> for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { <|endfocus|> try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }
code_review:  DIRECTIONS 
target code: protected void releaseResources() { for (int direction : DIRECTIONS) { try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction)); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } }
response: protected void releaseResources() { for (int direction : new int[] {IpSecTransform.DIRECTION_OUT, IpSecTransform.DIRECTION_IN}) { try { getNetdInstance() .ipSecDeleteSecurityAssociation( mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", mConfig.getSpi(direction) ); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw it as an IOException from Errno Exception } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } }

sample: 360
buggy_code:  protected void setUp() throws Exception { super.setUp(); mCM = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE); mISM = (IpSecManager) getContext().getSystemService(Context.IPSEC_SERVICE); } /* * Allocate a random SPI * Allocate a specific SPI using previous randomly created SPI value * Realloc the same SPI that was specifically created (expect SpiUnavailable) * Close SPIs */ public void testAllocSpi() throws Exception { for (InetAddress addr : GOOGLE_DNS_LIST) { IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null; <|startfocus|> randomSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, addr); assertTrue( "Failed to receive a valid SPI", randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); <|endfocus|> droidSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue( "Failed to allocate specified SPI, " + DROID_SPI, droidSpi.getSpi() == DROID_SPI); try {
code_review:  For test methods it's usually easiest to just say "throws Exception" since any exception thrown will result in the test failing. 
target code: protected void setUp() throws Exception { super.setUp(); mCM = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE); mISM = (IpSecManager) getContext().getSystemService(Context.IPSEC_SERVICE); } /* * Allocate a random SPI * Allocate a specific SPI using previous randomly created SPI value * Realloc the same SPI that was specifically created (expect SpiUnavailable) * Close SPIs */ public void testAllocSpi() throws Exception { for (InetAddress addr : GOOGLE_DNS_LIST) { IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null; randomSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue( "Failed to allocate specified SPI, " + DROID_SPI, droidSpi.getSpi() == DROID_SPI); try {
response: protected void setUp() throws Exception { super.setUp(); mCM = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE); mISM = (IpSecManager) getContext().getSystemService(Context.IPSEC_SERVICE); } public void testAllocSpi() throws Exception { for (InetAddress addr : GOOGLE_DNS_LIST) { IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null; randomSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, addr); assertTrue("Failed to receive a valid SPI", randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); droidSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); assertTrue("Failed to allocate specified SPI, " + DROID_SPI, droidSpi.getSpi() == DROID_SPI); try { mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI); fail("Expected SpiUnavailable exception"); } catch (SpiUnavailableException e) { // Expected exception } mISM.releaseSecurityParameterIndex(randomSpi); mISM.releaseSecurityParameterIndex(droidSpi); } }

sample: 361
buggy_code:  // This is a success case because we expect a dupe SPI to throw } randomSpi.close(); droidSpi.close(); } } /* * Alloc outbound SPI * Alloc inbound SPI * Create transport mode transform * open socket * apply transform to socket * send data on socket * release transform * send data (expect exception) */ public void testCreateTransform() throws Exception { InetAddress local = InetAddress.getLoopbackAddress(); IpSecManager.SecurityParameterIndex outSpi = <|startfocus|> mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, local); <|endfocus|> IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, local, outSpi.getSpi()); IpSecTransform transform = new IpSecTransform.Builder(mContext) .setSpi(IpSecTransform.DIRECTION_OUT, outSpi) .setEncryption( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm( IpSecAlgorithm.AUTH_HMAC_SHA256,
code_review:  throws Exception 
target code: // This is a success case because we expect a dupe SPI to throw } randomSpi.close(); droidSpi.close(); } } /* * Alloc outbound SPI * Alloc inbound SPI * Create transport mode transform * open socket * apply transform to socket * send data on socket * release transform * send data (expect exception) */ public void testCreateTransform() throws Exception { InetAddress local = InetAddress.getLoopbackAddress(); IpSecManager.SecurityParameterIndex outSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, local, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, local, outSpi.getSpi()); IpSecTransform transform = new IpSecTransform.Builder(mContext) .setSpi(IpSecTransform.DIRECTION_OUT, outSpi) .setEncryption( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication( IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm( IpSecAlgorithm.AUTH_HMAC_SHA256,
response: private void testCreateTransform() throws Exception { InetAddress local = InetAddress.getLoopbackAddress(); IpSecManager.SecurityParameterIndex outSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, local); IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, local, outSpi.getSpi()); IpSecTransform transform = new IpSecTransform.Builder(mContext) .setSpi(IpSecTransform.DIRECTION_OUT, outSpi) .setEncryption(IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256)) .setSpi(IpSecTransform.DIRECTION_IN, inSpi) .setEncryption(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256)) .build(); transform.close(); mISM.releaseSecurityParameterIndex(outSpi); mISM.releaseSecurityParameterIndex(inSpi); }

sample: 362
buggy_code:  if (length == 1) { return symbol.charAt(0); } if (length > 1) { char first = symbol.charAt(0); char second = symbol.charAt(1); if (first == '\u200E' || first == '\u200F' || first == '\u061C') { return second; } if (length == 2 && (second == '\u200E' || second == '\u200F' || second == '\u061C')) { return first; } } <|startfocus|> <|endfocus|> return fallback;
code_review:  I think the logic is too brittle. We should strip as many as these format characters as they are from the beginning and the end, and look at what remains. If the length of what remains is 1, return that. Otherwise, return the fallback. For example, with the current logic, if the input is "<LRM>#$", the result is '#', while we want it to be the fallback. 
target code: if (length == 1) { return symbol.charAt(0); } if (length > 1) { char first = symbol.charAt(0); char second = symbol.charAt(1); if (first == '\u200E' || first == '\u200F' || first == '\u061C') { return second; } if (length == 2 && (second == '\u200E' || second == '\u200F' || second == '\u061C')) { return first; } } return fallback;
response: if (length > 1) { String strippedSymbol = symbol.replaceAll("[\u200E\u200F\u061C]", ""); if (strippedSymbol.length() == 1) { return strippedSymbol.charAt(0); } } return fallback;

sample: 363
buggy_code:  public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier"); } <|startfocus|> if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } <|endfocus|> mNetworkSpecifier = networkSpecifier; return this;
code_review:  Not sure if we need this exception since setting any non-Parcelable NetworkSpecifier will fail as soon as the app tries to use it. Perhaps it's good to keep this for developer convenience because it will complain when the specifier is set, not when it is used. However, that only works some of the time: if the passed-in specifier is Parcelable, it's still possible to for things to fail when the specifier is used (as opposed to when it is set) if the Parcelable is not a framework class because the system won't be able to unparcel it. Up to you whether you want to make one of the two cases more helpful (and keep this exception) or if you want to make the two cases consistent. 
target code: public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier"); } mNetworkSpecifier = networkSpecifier; return this;
response: public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) { throw new IllegalStateException("Must have a single transport specified to use setNetworkSpecifier"); } if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) { throw new IllegalArgumentException("Network specifier must be parcelable"); } mNetworkSpecifier = networkSpecifier; return this; }

sample: 364
buggy_code:  * it should document their particulars. For example, Bluetooth may use some sort of * device id while WiFi could used ssid and/or bssid. Cellular may use carrier spn. * * @param networkSpecifier An {@code String} of opaque format used to specify the bearer * specific network specifier where the bearer has a choice of * networks. */ public Builder setNetworkSpecifier(String networkSpecifier) { <|startfocus|> return setNetworkSpecifier(new StringNetworkSpecifier(networkSpecifier)); <|endfocus|> } /** * Sets the optional bearer specific network specifier. * This has no meaning if a single transport is also not specified, so calling * this without a single transport set will generate an exception, as will * subsequently adding or removing transports after this is set. * </p> * * @param networkSpecifier A concrete, parcelable framework class that extends * NetworkSpecifier. * * @hide */ public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier instanceof MatchAllNetworkSpecifier) {
code_review:  This will crash apps that do "setNetworkSpecifier(null)", which I believe does not crash today. 
target code: * it should document their particulars. For example, Bluetooth may use some sort of * device id while WiFi could used ssid and/or bssid. Cellular may use carrier spn. * * @param networkSpecifier An {@code String} of opaque format used to specify the bearer * specific network specifier where the bearer has a choice of * networks. */ public Builder setNetworkSpecifier(String networkSpecifier) { return setNetworkSpecifierObject(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier)); } /** * Sets the optional bearer specific network specifier. * This has no meaning if a single transport is also not specified, so calling * this without a single transport set will generate an exception, as will * subsequently adding or removing transports after this is set. * </p> * * @param networkSpecifier A concrete, parcelable framework class that extends * NetworkSpecifier. * * @hide */ public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier instanceof MatchAllNetworkSpecifier) {
response: /** * Sets the optional bearer specific network specifier. * This has no meaning if a single transport is also not specified, so calling * this without a single transport set will generate an exception, as will * subsequently adding or removing transports after this is set. * </p> * * @param networkSpecifier A concrete, parcelable framework class that extends * NetworkSpecifier. * * @hide */ public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier instanceof MatchAllNetworkSpecifier) { return this; } return setNetworkSpecifier(new StringNetworkSpecifier(networkSpecifier.toString())); } /** * Sets the optional bearer specific network specifier. * This has no meaning if a single transport is also not specified, so calling * this without a single transport set will generate an exception, as will * subsequently adding or removing transports after this is set. * </p> * * @param networkSpecifier An {@code String} of opaque format used to specify the bearer * specific network specifier where the bearer has a choice of * networks. */ public Builder setNetworkSpecifier(String networkSpecifier) { return setNetworkSpecifier(new StringNetworkSpecifier(networkSpecifier)); }

sample: 365
buggy_code:  } /** * Sets the optional bearer specific network specifier. * This has no meaning if a single transport is also not specified, so calling * this without a single transport set will generate an exception, as will * subsequently adding or removing transports after this is set. * </p> * * @param networkSpecifier A concrete, parcelable framework class that extends * NetworkSpecifier. * * @hide */ <|startfocus|> public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) { <|endfocus|> if (networkSpecifier instanceof MatchAllNetworkSpecifier) { throw new IllegalArgumentException( "NetworkRequests must not use MatchAllNetworkSpecifier"); } mNetworkCapabilities.setNetworkSpecifier(networkSpecifier); return this; } /** * Sets the signal strength. This is a signed integer, with higher values indicating a * stronger signal. The exact units are bearer-dependent. For example, Wi-Fi uses the same * RSSI units reported by WifiManager. * <p> * Note that when used to register a network callback, this specifies the minimum acceptable
code_review:  I'm not sure what adding this method will do to apps that call "setNetworkSpecifier(null)". It's clear to me that an app that targets O can't do that: it must write setNetworkSpecifier((String) null) or setNetworkSpecifier((NetworkSpecifier) null), or get an error at compile time. But I'm not sure what will happen at runtime to an app that targeted a previous SDK version. Perhaps the binary already contains the fully-qualified name and everything is fine. I've asked the API council to clarify that. 
target code: } /** * Sets the optional bearer specific network specifier. * This has no meaning if a single transport is also not specified, so calling * this without a single transport set will generate an exception, as will * subsequently adding or removing transports after this is set. * </p> * * @param networkSpecifier A concrete, parcelable framework class that extends * NetworkSpecifier. * * @hide */ public Builder setNetworkSpecifierObject(NetworkSpecifier networkSpecifier) { if (networkSpecifier instanceof MatchAllNetworkSpecifier) { throw new IllegalArgumentException( "NetworkRequests must not use MatchAllNetworkSpecifier"); } mNetworkCapabilities.setNetworkSpecifier(networkSpecifier); return this; } /** * Sets the signal strength. This is a signed integer, with higher values indicating a * stronger signal. The exact units are bearer-dependent. For example, Wi-Fi uses the same * RSSI units reported by WifiManager. * <p> * Note that when used to register a network callback, this specifies the minimum acceptable
response: public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (networkSpecifier instanceof MatchAllNetworkSpecifier) { throw new IllegalArgumentException("NetworkRequests must not use MatchAllNetworkSpecifier"); } mNetworkCapabilities.setNetworkSpecifier(networkSpecifier); return this; }

sample: 366
buggy_code:  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * <|startfocus|> * Applications cannot instantiate this class by themselves, but can obtain instances of this * class via other APIs. <|endfocus|> * * @hide */ public abstract class NetworkSpecifier { /** * Validate that the input NetworkSpecifier is one of the whitelisted types. * * @hide */ public static boolean isWhitelistedNetworkSpecifier(NetworkSpecifier ns) { return ns instanceof MatchAllNetworkSpecifier || ns instanceof StringNetworkSpecifier; } /** * @hide */ public NetworkSpecifier() {} /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. * * @hide */
code_review:  instances of subclasses of this class via other APIs. 
target code: * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of * subclasses of this class via other APIs. * * @hide */ public abstract class NetworkSpecifier { /** * Validate that the input NetworkSpecifier is one of the whitelisted types. * * @hide */ public static boolean isWhitelistedNetworkSpecifier(NetworkSpecifier ns) { return ns instanceof MatchAllNetworkSpecifier || ns instanceof StringNetworkSpecifier; } /** * @hide */ public NetworkSpecifier() {} /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. * * @hide */
response: package android.net; public abstract class NetworkSpecifier { public static boolean isWhitelistedNetworkSpecifier(NetworkSpecifier ns) { return ns instanceof MatchAllNetworkSpecifier || ns instanceof StringNetworkSpecifier; } public NetworkSpecifier() {} public abstract boolean satisfies(NetworkSpecifier other); }

sample: 367
buggy_code:  /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of this * class via other APIs. * * @hide */ public abstract class NetworkSpecifier { /** * Validate that the input NetworkSpecifier is one of the whitelisted types. * * @hide */ <|startfocus|> public static boolean isWhitelistedNetworkSpecifier(NetworkSpecifier ns) { return ns instanceof MatchAllNetworkSpecifier || ns instanceof StringNetworkSpecifier; } /** * @hide */ <|endfocus|> public NetworkSpecifier() {} /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. * * @hide */ public abstract boolean satisfiedBy(NetworkSpecifier other); } 
code_review:  I'm not a fan of having to enumerate all possible classes here. If the user passes in a non-framework Parcelable class we'll already throw an exception because the framework won't know how to unparcel it. Is that enough? 
target code: /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of this * class via other APIs. * * @hide */ public abstract class NetworkSpecifier { /** * Validate that the input NetworkSpecifier is one of the whitelisted types. * * @hide */ public NetworkSpecifier() {} /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. * * @hide */ public abstract boolean satisfiedBy(NetworkSpecifier other); }
response: public abstract class NetworkSpecifier { public static boolean isWhitelistedNetworkSpecifier(NetworkSpecifier ns) { return ns instanceof MatchAllNetworkSpecifier || ns instanceof StringNetworkSpecifier; } public NetworkSpecifier() {} public abstract boolean satisfiedBy(NetworkSpecifier other); }

sample: 368
buggy_code:  || wiFiEnabledState == WifiManager.WIFI_STATE_DISABLED) { if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_ENABLE)) { return true; } } } else if (wiFiEnabledState == WifiManager.WIFI_STATE_ENABLING || wiFiEnabledState == WifiManager.WIFI_STATE_ENABLED) { if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_DISABLE)) { return true; } } } <|startfocus|> mWifiController.obtainMessageAndSend(CMD_WIFI_TOGGLED); <|endfocus|> return true; } /** * see {@link WifiManager#getWifiState()} * @return One of {@link WifiManager#WIFI_STATE_DISABLED}, * {@link WifiManager#WIFI_STATE_DISABLING}, * {@link WifiManager#WIFI_STATE_ENABLED}, * {@link WifiManager#WIFI_STATE_ENABLING}, * {@link WifiManager#WIFI_STATE_UNKNOWN} */ @Override public int getWifiEnabledState() { enforceAccessPermission(); mLog.trace("getWifiEnabledState uid=%").c(Binder.getCallingUid()).flush();
code_review:  What is the advantage of using this |obtainMessageAndSend| over |sendMessage|. We would have been able to mock event |mWifiController.sendMessage| 
target code: || wiFiEnabledState == WifiManager.WIFI_STATE_DISABLED) { if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_ENABLE)) { return true; } } } else if (wiFiEnabledState == WifiManager.WIFI_STATE_ENABLING || wiFiEnabledState == WifiManager.WIFI_STATE_ENABLED) { if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_DISABLE)) { return true; } } } mWifiController.sendMessage(CMD_WIFI_TOGGLED); return true; } /** * see {@link WifiManager#getWifiState()} * @return One of {@link WifiManager#WIFI_STATE_DISABLED}, * {@link WifiManager#WIFI_STATE_DISABLING}, * {@link WifiManager#WIFI_STATE_ENABLED}, * {@link WifiManager#WIFI_STATE_ENABLING}, * {@link WifiManager#WIFI_STATE_UNKNOWN} */ @Override public int getWifiEnabledState() { enforceAccessPermission(); mLog.trace("getWifiEnabledState uid=%").c(Binder.getCallingUid()).flush();
response: || wiFiEnabledState == WifiManager.WIFI_STATE_DISABLED) { if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_ENABLE)) { return true; } } } else if (wiFiEnabledState == WifiManager.WIFI_STATE_ENABLING || wiFiEnabledState == WifiManager.WIFI_STATE_ENABLED) { if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_DISABLE)) { return true; } } } mWifiController.obtainMessageAndSend(CMD_WIFI_TOGGLED); return true; } @Override public int getWifiEnabledState() { enforceAccessPermission(); mLog.trace("getWifiEnabledState uid=%").c(Binder.getCallingUid()).flush();

sample: 369
buggy_code:  * the grouping separator, and so on) needed by <code>DecimalFormat</code> * to format numbers. <code>DecimalFormat</code> creates for itself an instance of * <code>DecimalFormatSymbols</code> from its locale data. If you need to change any * of these symbols, you can get the <code>DecimalFormatSymbols</code> object from * your <code>DecimalFormat</code> and modify it. * <|startfocus|> * @author Mark Davis * @author Alan Liu * @see java.util.Locale * @see DecimalFormat <|endfocus|> */ public class DecimalFormatSymbols implements Cloneable, Serializable { // Android-changed: Removed reference to DecimalFormatSymbolsProvider but suggested // getInstance() be used instead in case Android supports it in future. /** * Create a DecimalFormatSymbols object for the default * {@link java.util.Locale.Category#FORMAT FORMAT} locale. * It is recommended that the {@link #getInstance(Locale) getInstance} method is used * instead. * <p>This is equivalent to calling * {@link #DecimalFormatSymbols(Locale)
code_review:  Why the re-factoring? Does this include an update to a newer upstream version too? Can we do that separately please? I'm less concerned about changes to Android-changed sections but I think I'd still prefer to separate them out. 
target code: * the grouping separator, and so on) needed by <code>DecimalFormat</code> * to format numbers. <code>DecimalFormat</code> creates for itself an instance of * <code>DecimalFormatSymbols</code> from its locale data. If you need to change any * of these symbols, you can get the <code>DecimalFormatSymbols</code> object from * your <code>DecimalFormat</code> and modify it. * * @see java.util.Locale * @see DecimalFormat * @author Mark Davis * @author Alan Liu */ public class DecimalFormatSymbols implements Cloneable, Serializable { // Android-changed: Removed reference to DecimalFormatSymbolsProvider but suggested // getInstance() be used instead in case Android supports it in future. /** * Create a DecimalFormatSymbols object for the default * {@link java.util.Locale.Category#FORMAT FORMAT} locale. * It is recommended that the {@link #getInstance(Locale) getInstance} method is used * instead. * <p>This is equivalent to calling * {@link #DecimalFormatSymbols(Locale)
response: import org.eclipse.sirius.viewpoint.description.style.BasicLabelStyleDescription; import org.osgi.framework.Version; import com.google.common.collect.Lists; public class FontFormatMigrationParticipant extends AbstractMigrationParticipant { private static final String ITALIC = "italic"; private static final String BOLD = "bold"; private static final Version MIGRATION_VERSION = new Version("10.0.0.20150513"); @Override public Version getMigrationVersion() { return MIGRATION_VERSION; } @Override public Object getValue(EObject object, EStructuralFeature feature, Object value, String loadedVersion) { List<FontFormat> labelFormat = Lists.newArrayList(); if (object instanceof BasicLabelStyleDescription) { if (feature.getEType() == ViewpointPackage.Literals.FONT_FORMAT) { if (value instanceof String) { String oldFontFormat = (String) value; if (oldFontFormat.contains(ITALIC)) { FontFormatHelper.setFontFormat(labelFormat, FontFormat.ITALIC_LITERAL); } } } } } } public class ExprRewriter { private int numChanges_ = 0; private final List<ExprRewriteRule> rules_; public ExprRewriter(List<ExprRewriteRule> rules) { rules_ = rules; } public ExprRewriter(ExprRewriteRule rule) { rules_ = Lists.newArrayList(rule); } public Expr rewrite(Expr expr, Analyzer analyzer) throws AnalysisException { int initialNumChanges = numChanges_; int oldNumChanges; Expr rewrittenExpr = expr; do { oldNumChanges = numChanges_; for (ExprRewriteRule rule : rules_) { rewrittenExpr = applyRuleRepeatedly(rewrittenExpr, rule, analyzer); } } while (oldNumChanges != numChanges_); return rewrittenExpr; } } public class DecimalFormatSymbols implements Cloneable, Serializable { public DecimalFormatSymbols() { } }

sample: 370
buggy_code:  public void testBluetoothDirWrite() { try { File file = new File("/data/misc/bluetooth/test.file"); assertTrue("File not created", file.createNewFile()); file.delete(); <|startfocus|> } catch (Exception e) { fail("Exception creating file /data/misc/bluetooth/test.file"); <|endfocus|> }
code_review:  Do we want to print out the exception? 
target code: public void testBluetoothDirWrite() { try { File file = new File("/data/misc/bluetooth/test.file"); assertTrue("File not created", file.createNewFile()); file.delete(); } catch (IOException e) { fail("Exception creating file /data/misc/bluetooth/test.file: " + e); }
response: public void testBluetoothDirWrite() { try { File file = new File("/data/misc/bluetooth/test.file"); assertTrue("File not created", file.createNewFile()); file.delete(); } catch (Exception e) { fail("Exception creating file /data/misc/bluetooth/test.file"); } }

sample: 371
buggy_code:  assertEquals( TimeZoneDistroInstaller.INSTALL_SUCCESS, installer.stageInstallWithErrorCode(stagedDistro.getBytes())); assertInstallDistroStaged(stagedDistro); TimeZoneDistro incompleteDistro = createValidTimeZoneDistroBuilder(NEWER_RULES_VERSION, 1) .setTzLookupXml(null) .buildUnvalidated(); assertEquals( TimeZoneDistroInstaller.INSTALL_FAIL_BAD_DISTRO_STRUCTURE, installer.stageInstallWithErrorCode(incompleteDistro.getBytes())); assertInstallDistroStaged(stagedDistro); assertNoInstalledDistro(); } <|startfocus|> /** Tests that a distro with a missing tzlookup file will not update the content. */ <|endfocus|> public void testStageInstallWithErrorCode_badTzLookupFile() throws Exception { TimeZoneDistro stagedDistro = createValidTimeZoneDistro(NEW_RULES_VERSION, 1); assertEquals( TimeZoneDistroInstaller.INSTALL_SUCCESS, installer.stageInstallWithErrorCode(stagedDistro.getBytes())); assertInstallDistroStaged(stagedDistro); TimeZoneDistro incompleteDistro = createValidTimeZoneDistroBuilder(NEWER_RULES_VERSION, 1) .setTzLookupXml("<foo />") .buildUnvalidated(); assertEquals( TimeZoneDistroInstaller.INSTALL_FAIL_VALIDATION_ERROR, installer.stageInstallWithErrorCode(incompleteDistro.getBytes())); assertInstallDistroStaged(stagedDistro);
code_review:  bad 
target code: assertEquals( TimeZoneDistroInstaller.INSTALL_SUCCESS, installer.stageInstallWithErrorCode(stagedDistro.getBytes())); assertInstallDistroStaged(stagedDistro); TimeZoneDistro incompleteDistro = createValidTimeZoneDistroBuilder(NEWER_RULES_VERSION, 1) .setTzLookupXml(null) .buildUnvalidated(); assertEquals( TimeZoneDistroInstaller.INSTALL_FAIL_BAD_DISTRO_STRUCTURE, installer.stageInstallWithErrorCode(incompleteDistro.getBytes())); assertInstallDistroStaged(stagedDistro); assertNoInstalledDistro(); } /** Tests that a distro with a bad tzlookup file will not update the content. */ public void testStageInstallWithErrorCode_badTzLookupFile() throws Exception { TimeZoneDistro stagedDistro = createValidTimeZoneDistro(NEW_RULES_VERSION, 1); assertEquals( TimeZoneDistroInstaller.INSTALL_SUCCESS, installer.stageInstallWithErrorCode(stagedDistro.getBytes())); assertInstallDistroStaged(stagedDistro); TimeZoneDistro incompleteDistro = createValidTimeZoneDistroBuilder(NEWER_RULES_VERSION, 1) .setTzLookupXml("<foo />") .buildUnvalidated(); assertEquals( TimeZoneDistroInstaller.INSTALL_FAIL_VALIDATION_ERROR, installer.stageInstallWithErrorCode(incompleteDistro.getBytes())); assertInstallDistroStaged(stagedDistro);
response: assertEquals(TimeZoneDistroInstaller.INSTALL_SUCCESS, installer.stageInstallWithErrorCode(stagedDistro.getBytes())); assertInstallDistroStaged(stagedDistro); TimeZoneDistro incompleteDistro = createValidTimeZoneDistroBuilder(NEWER_RULES_VERSION, 1) .setTzLookupXml(null) .buildUnvalidated(); assertEquals(TimeZoneDistroInstaller.INSTALL_FAIL_BAD_DISTRO_STRUCTURE, installer.stageInstallWithErrorCode(incompleteDistro.getBytes())); assertInstallDistroStaged(stagedDistro); assertNoInstalledDistro(); public void testStageInstallWithErrorCode_badTzLookupFile() throws Exception { TimeZoneDistro stagedDistro = createValidTimeZoneDistro(NEW_RULES_VERSION, 1); assertEquals(TimeZoneDistroInstaller.INSTALL_SUCCESS, installer.stageInstallWithErrorCode(stagedDistro.getBytes())); assertInstallDistroStaged(stagedDistro); TimeZoneDistro incompleteDistro = createValidTimeZoneDistroBuilder(NEWER_RULES_VERSION, 1) .setTzLookupXml("<foo />") .buildUnvalidated(); assertEquals(TimeZoneDistroInstaller.INSTALL_FAIL_VALIDATION_ERROR, installer.stageInstallWithErrorCode(incompleteDistro.getBytes())); assertInstallDistroStaged(stagedDistro); }

sample: 372
buggy_code:  /** * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}. * If the string contains a single non-marker character (and any number of marker characters), * then that character is returned, otherwise {@code fallback} is returned. * <|startfocus|> * As an implementation detail {@code fallback} is also return when {@code symbol} contains * U+0000, which is tolerated, as that would indicate a considerable problem with the input. * <|endfocus|> * @hide */ // VisibleForTesting public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (char c : symbol.toCharArray()) {
code_review:  returned 
target code: /** * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}. * If the string contains a single non-marker character (and any number of marker characters), * then that character is returned, otherwise {@code fallback} is returned. * * @hide */ // VisibleForTesting public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (char c : symbol.toCharArray()) {
response: /** * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}. * If the string contains a single non-marker character (and any number of marker characters), * then that character is returned, otherwise {@code fallback} is returned. * As an implementation detail {@code fallback} is also returned when {@code symbol} contains * U+0000, which is tolerated, as that would indicate a considerable problem with the input. * @hide */ // VisibleForTesting public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (char c : symbol.toCharArray()) { if (c != '\u200E' && c != '\u200F' && c != '\u061C') { if (nonMarker == 0) { nonMarker = c; } else if (nonMarker != c) { return fallback; } } } if (nonMarker != 0) { return nonMarker; } } return fallback; }

sample: 373
buggy_code:  /** * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}. * If the string contains a single non-marker character (and any number of marker characters), * then that character is returned, otherwise {@code fallback} is returned. * <|startfocus|> * As an implementation detail {@code fallback} is also return when {@code symbol} contains * U+0000, which is tolerated, as that would indicate a considerable problem with the input. * <|endfocus|> * @hide */ // VisibleForTesting public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (char c : symbol.toCharArray()) {
code_review:  is tolerated? Or should it be *not* tolerated? Can we just removed the ", which is tolerated,"? 
target code: /** * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}. * If the string contains a single non-marker character (and any number of marker characters), * then that character is returned, otherwise {@code fallback} is returned. * * @hide */ // VisibleForTesting public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (char c : symbol.toCharArray()) {
response: /** * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}. * If the string contains a single non-marker character (and any number of marker characters), * then that character is returned, otherwise {@code fallback} is returned. * @hide */ // VisibleForTesting public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (char c : symbol.toCharArray()) {

sample: 374
buggy_code:  public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; <|startfocus|> for (char c : symbol.toCharArray()) { <|endfocus|> if (c == '\u200E' || c == '\u200F' || c == '\u061C') { continue; } if (nonMarker != 0 || c == '\u0000') { // more than one non-marker character or U+0000 in the input string. return fallback; } nonMarker = c; } if (nonMarker != 0) { return nonMarker; } } return fallback;
code_review:  FYI - toCharArray() allocates a new array. charAt() doesn't and may even have an intrinsic. I'm not overly worried about performance, but don't think it would hurt readability to switch. 
target code: public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (int i = 0; i < length; i++) { char c = symbol.charAt(i); if (c == '\u200E' || c == '\u200F' || c == '\u061C') { continue; } if (nonMarker != 0 || c == '\u0000') { // more than one non-marker character or U+0000 in the input string. return fallback; } nonMarker = c; } if (nonMarker != 0) { return nonMarker; } } return fallback;
response: public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length == 1) { char c = symbol.charAt(0); if (c != '\u200E' && c != '\u200F' && c != '\u061C' && c != '\u0000') { return c; } } else if (length > 1) { char nonMarker = 0; for (int i = 0; i < length; i++) { char c = symbol.charAt(i); if (c == '\u200E' || c == '\u200F' || c == '\u061C') { continue; } if (nonMarker != 0 || c == '\u0000') { // more than one non-marker character or U+0000 in the input string. return fallback; } nonMarker = c; } if (nonMarker != 0) { return nonMarker; } } return fallback; }

sample: 375
buggy_code:  public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length >= 1) { boolean sawNonMarker = false; char nonMarker = 0; for (int i = 0; i < length; i++) { <|startfocus|> char c = symbol.charAt(i); <|endfocus|> if (c == '\u200E' || c == '\u200F' || c == '\u061C') { continue; } if (sawNonMarker) { // More than one non-marker character. return fallback; } sawNonMarker = true; nonMarker = c; } if (sawNonMarker) { return nonMarker; } } return fallback;
code_review:  nit: this could be made final too. 
target code: public static char maybeStripMarkers(String symbol, char fallback) { final int length = symbol.length(); if (length >= 1) { boolean sawNonMarker = false; char nonMarker = 0; for (int i = 0; i < length; i++) { final char c = symbol.charAt(i); if (c == '\u200E' || c == '\u200F' || c == '\u061C') { continue; } if (sawNonMarker) { // More than one non-marker character. return fallback; } sawNonMarker = true; nonMarker = c; } if (sawNonMarker) { return nonMarker; } } return fallback;
response: public static char maybeStripMarkers(final String symbol, final char fallback) { final int length = symbol.length(); if (length >= 1) { boolean sawNonMarker = false; char nonMarker = 0; for (int i = 0; i < length; i++) { char c = symbol.charAt(i); if (c == '\u200E' || c == '\u200F' || c == '\u061C') { continue; } if (sawNonMarker) { // More than one non-marker character. return fallback; } sawNonMarker = true; nonMarker = c; } if (sawNonMarker) { return nonMarker; } } return fallback; }

sample: 376
buggy_code:  private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; public enum Mode { IDLE("idle"), TETHERING("tethering"), LOCAL_HOTSPOT("local_only_hotspot"); public final String description; Mode(String description) { this.description = description; } } private boolean mRndisEnabled; // track the RNDIS function enabled state private boolean mUsbTetherRequested; // true if USB tethering should be started <|startfocus|> // when RNDIS is enabled <|endfocus|> // True iff WiFi tethering should be started when soft AP is ready. private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mContext = context; mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties; 
code_review:  Nit: if you're OK with the strings being uppercase I think you don't need all this, you can just do: public enum Mode { IDLE, TETHERING, LOCAL_ONLY_HOTSPOT }; 
target code: private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; public enum Mode { IDLE("idle"), TETHERING("tethering"), LOCAL_HOTSPOT("local_only_hotspot"); public final String description; Mode(String description) { this.description = description; } } private boolean mRndisEnabled; // track the RNDIS function enabled state private boolean mUsbTetherRequested; // true if USB tethering should be started // when RNDIS is enabled // True iff WiFi tethering should be started when soft AP is ready. private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mContext = context; mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties;
response: private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; public enum Mode { IDLE, TETHERING, LOCAL_ONLY_HOTSPOT } private boolean mRndisEnabled; private boolean mUsbTetherRequested; private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mContext = context; mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties; }

sample: 377
buggy_code:  return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE; } // Ignore the error status of the interface. If the interface is available, // the errors are referring to past tethering attempts anyway. if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) { Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring"); return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE; } <|startfocus|> tetherState.stateMachine.sendMessage( TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, (Object) mode); <|endfocus|> return ConnectivityManager.TETHER_ERROR_NO_ERROR; }
code_review:  Nit: do you need this cast? 
target code: return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE; } // Ignore the error status of the interface. If the interface is available, // the errors are referring to past tethering attempts anyway. if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) { Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring"); return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE; } tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED); return ConnectivityManager.TETHER_ERROR_NO_ERROR; }
response: public int tetherInterface(String iface, int mode) { TetherInterfaceStateMachine tetherState = mTetherStates.get(iface); if (tetherState == null) { Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring"); return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE; } if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) { Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring"); return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE; } tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, mode); return ConnectivityManager.TETHER_ERROR_NO_ERROR; }

sample: 378
buggy_code:  private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; public enum Mode { IDLE("idle"), TETHERING("tethering"), LOCAL_HOTSPOT("local_only_hotspot"); public final String description; Mode(String description) { this.description = description; } } private boolean mRndisEnabled; // track the RNDIS function enabled state private boolean mUsbTetherRequested; // true if USB tethering should be started <|startfocus|> // when RNDIS is enabled <|endfocus|> // True iff WiFi tethering should be started when soft AP is ready. private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mContext = context; mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties; 
code_review:  Nit: if you're happy with uppercase labels, I think this will work too: public enum Mode { IDLE, TETHERING, LOCAL_HOTSPOT; } toString should work as documented in https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#toString() 
target code: private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; public enum Mode { IDLE("idle"), TETHERING("tethering"), LOCAL_HOTSPOT("local_only_hotspot"); public final String description; Mode(String description) { this.description = description; } } private boolean mRndisEnabled; // track the RNDIS function enabled state private boolean mUsbTetherRequested; // true if USB tethering should be started // when RNDIS is enabled // True iff WiFi tethering should be started when soft AP is ready. private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mContext = context; mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties;
response: private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; public enum Mode { IDLE, TETHERING, LOCAL_HOTSPOT; } private boolean mRndisEnabled; private boolean mUsbTetherRequested; private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mContext = context; mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties; }

sample: 379
buggy_code:  public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. <|startfocus|> if (mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId))) { mNextSubnetId = (short) Math.max(0, mNextSubnetId + 1); // always positive } <|endfocus|> updateIPv6TetheringInterfaces(); }
code_review:  Note here that this only supports /48s. Also consider making it explicit by making this modulo the size of the prefix. Or add a TODO. 
target code: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. mActiveDownstreams.offer(downstream); updateIPv6TetheringInterfaces(); }
response: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { if (mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId))) { mNextSubnetId = (short) Math.max(0, mNextSubnetId + 1); } updateIPv6TetheringInterfaces(); } }

sample: 380
buggy_code:  // Make a local copy, so we can modify it. final RaParams deprecated = new RaParams(deprecatedParams); // Remove any ULA DNS servers. removeULAs(deprecated.dnses); // Process newly deprecated information. mDeprecatedInfoTracker.putPrefixes(deprecated.prefixes); mDeprecatedInfoTracker.putDnses(deprecated.dnses); } // Make a local copy, so we can modify it. final RaParams params = (newParams != null) ? new RaParams(newParams) : null; if (params != null) { // Remove any ULA DNS servers. removeULAs(params.dnses); // Process information that is no longer deprecated. <|startfocus|> mDeprecatedInfoTracker.removePrefixes(params.prefixes); mDeprecatedInfoTracker.removeDnses(params.dnses); <|endfocus|> } mRaParams = params; assembleRaLocked(); } maybeNotifyMulticastTransmitter();
code_review:  Will this fit on one line? 
target code: // Make a local copy, so we can modify it. final RaParams deprecated = new RaParams(deprecatedParams); // Remove any ULA DNS servers. removeULAs(deprecated.dnses); // Process newly deprecated information. mDeprecatedInfoTracker.putPrefixes(deprecated.prefixes); mDeprecatedInfoTracker.putDnses(deprecated.dnses); } // Make a local copy, so we can modify it. final RaParams params = (newParams != null) ? new RaParams(newParams) : null; if (params != null) { // Remove any ULA DNS servers. removeULAs(params.dnses); // Process information that is no longer deprecated. mDeprecatedInfoTracker.removePrefixes(newParams.prefixes); mDeprecatedInfoTracker.removeDnses(newParams.dnses); } mRaParams = params; assembleRaLocked(); } maybeNotifyMulticastTransmitter();
response: // Make a local copy, so we can modify it. final RaParams deprecated = new RaParams(deprecatedParams); // Remove any ULA DNS servers. removeULAs(deprecated.dnses); // Process newly deprecated information. mDeprecatedInfoTracker.putPrefixes(deprecated.prefixes); mDeprecatedInfoTracker.putDnses(deprecated.dnses); // Make a local copy, so we can modify it. final RaParams params = (newParams != null) ? new RaParams(newParams) : null; if (params != null) { // Remove any ULA DNS servers. removeULAs(params.dnses); // Process information that is no longer deprecated. mDeprecatedInfoTracker.removePrefixes(params.prefixes); mDeprecatedInfoTracker.removeDnses(params.dnses); } mRaParams = params; assembleRaLocked(); maybeNotifyMulticastTransmitter();

sample: 381
buggy_code:  when(mResources.getStringArray( com.android.internal.R.array.config_mobile_hotspot_provision_app)) .thenReturn(new String[] {"malformedApp"}); assertTrue(!mTethering.isTetherProvisioningRequired()); } private void sendWifiApStateChanged(int state) { final Intent intent = new Intent(WifiManager.WIFI_AP_STATE_CHANGED_ACTION); intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, state); mServiceContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); } @Test <|startfocus|> public void workingWifiHotspot() throws Exception { <|endfocus|> when(mConnectivityManager.isTetheringSupported()).thenReturn(true); when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())) .thenReturn(true); // Emulate externally-visible WifiManager effects, causing the // per-interface state machine starts up, and telling us that hotspot // mode is to be started. mTethering.interfaceStatusChanged(mTestIfname, true); sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED); mLooper.dispatchAll(); verify(mNMService, times(1)).listInterfaces(); verify(mNMService, times(1)).getInterfaceConfig(mTestIfname);
code_review:  workingLocalOnlyHotspot? 
target code: when(mResources.getStringArray( com.android.internal.R.array.config_mobile_hotspot_provision_app)) .thenReturn(new String[] {"malformedApp"}); assertTrue(!mTethering.isTetherProvisioningRequired()); } private void sendWifiApStateChanged(int state) { final Intent intent = new Intent(WifiManager.WIFI_AP_STATE_CHANGED_ACTION); intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, state); mServiceContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); } @Test public void workingLocalOnlyHotspot() throws Exception { when(mConnectivityManager.isTetheringSupported()).thenReturn(true); when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())) .thenReturn(true); // Emulate externally-visible WifiManager effects, causing the // per-interface state machine starts up, and telling us that hotspot // mode is to be started. mTethering.interfaceStatusChanged(mTestIfname, true); sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED); mLooper.dispatchAll(); verify(mNMService, times(1)).listInterfaces(); verify(mNMService, times(1)).getInterfaceConfig(mTestIfname);
response: when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)) .thenReturn(new String[]{"malformedApp"}); assertTrue(!mTethering.isTetherProvisioningRequired()); private void sendWifiApStateChanged(int state) { final Intent intent = new Intent(WifiManager.WIFI_AP_STATE_CHANGED_ACTION); intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, state); mServiceContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); } @Test public void workingWifiHotspot() throws Exception { when(mConnectivityManager.isTetheringSupported()).thenReturn(true); when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())) .thenReturn(true); mTethering.interfaceStatusChanged(mTestIfname, true); sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED); mLooper.dispatchAll(); verify(mNMService, times(1)).listInterfaces(); verify(mNMService, times(1)).getInterfaceConfig(mTestIfname); }

sample: 382
buggy_code:  intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, state); mServiceContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); } @Test public void workingWifiHotspot() throws Exception { when(mConnectivityManager.isTetheringSupported()).thenReturn(true); when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())) .thenReturn(true); // Emulate externally-visible WifiManager effects, causing the <|startfocus|> // per-interface state machine starts up, and telling us that hotspot // mode is to be started. <|endfocus|> mTethering.interfaceStatusChanged(mTestIfname, true); sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED); mLooper.dispatchAll(); verify(mNMService, times(1)).listInterfaces(); verify(mNMService, times(1)).getInterfaceConfig(mTestIfname); verify(mNMService, times(1)) .setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class)); verify(mNMService, times(1)).tetherInterface(mTestIfname); verify(mNMService, times(1)).setIpForwardingEnabled(true); verify(mNMService, times(1)).startTethering(any(String[].class)); verifyNoMoreInteractions(mNMService);
code_review:  to start 
target code: intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, state); mServiceContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); } @Test public void workingWifiHotspot() throws Exception { when(mConnectivityManager.isTetheringSupported()).thenReturn(true); when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())) .thenReturn(true); // Emulate externally-visible WifiManager effects, causing the // per-interface state machine to start up, and telling us that // hotspot mode is to be started. mTethering.interfaceStatusChanged(mTestIfname, true); sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED); mLooper.dispatchAll(); verify(mNMService, times(1)).listInterfaces(); verify(mNMService, times(1)).getInterfaceConfig(mTestIfname); verify(mNMService, times(1)) .setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class)); verify(mNMService, times(1)).tetherInterface(mTestIfname); verify(mNMService, times(1)).setIpForwardingEnabled(true); verify(mNMService, times(1)).startTethering(any(String[].class)); verifyNoMoreInteractions(mNMService);
response: intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, state); mServiceContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); } @Test public void workingWifiHotspot() throws Exception { when(mConnectivityManager.isTetheringSupported()).thenReturn(true); when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())) .thenReturn(true); // Emulate externally-visible WifiManager effects, causing the per-interface state machine starts up, and telling us that hotspot mode is to be started. mTethering.interfaceStatusChanged(mTestIfname, true); sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED); mLooper.dispatchAll(); verify(mNMService, times(1)).listInterfaces(); verify(mNMService, times(1)).getInterfaceConfig(mTestIfname); verify(mNMService, times(1)) .setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class)); verify(mNMService, times(1)).tetherInterface(mTestIfname); verify(mNMService, times(1)).setIpForwardingEnabled(true); verify(mNMService, times(1)).startTethering(any(String[].class)); verifyNoMoreInteractions(mNMService); }

sample: 383
buggy_code:  private void combineSpecifiers(NetworkCapabilities nc) { <|startfocus|> if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.getNetworkSpecifier())) { <|endfocus|> throw new IllegalStateException("Can't combine two networkSpecifiers"); } setNetworkSpecifier(nc.getNetworkSpecifier());
code_review:  Nit: nc.mNetworkSpecifier? 
target code: private void combineSpecifiers(NetworkCapabilities nc) { if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.mNetworkSpecifier)) { throw new IllegalStateException("Can't combine two networkSpecifiers"); } setNetworkSpecifier(nc.getNetworkSpecifier());
response: private void combineSpecifiers(NetworkCapabilities nc) { if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.getNetworkSpecifier())) { throw new IllegalStateException("Can't combine two networkSpecifiers"); } setNetworkSpecifier(nc.getNetworkSpecifier()); }

sample: 384
buggy_code:  private void combineSpecifiers(NetworkCapabilities nc) { if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.getNetworkSpecifier())) { throw new IllegalStateException("Can't combine two networkSpecifiers"); } <|startfocus|> setNetworkSpecifier(nc.getNetworkSpecifier()); <|endfocus|>
code_review:  Nit: nc.mNetworkSpecifier? 
target code: private void combineSpecifiers(NetworkCapabilities nc) { if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.getNetworkSpecifier())) { throw new IllegalStateException("Can't combine two networkSpecifiers"); } setNetworkSpecifier(nc.mNetworkSpecifier);
response: private void combineSpecifiers(NetworkCapabilities nc) { if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.getNetworkSpecifier())) { throw new IllegalStateException("Can't combine two networkSpecifiers"); } setNetworkSpecifier(nc.getNetworkSpecifier()); }

sample: 385
buggy_code:  public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) { checkNotNull(operation, "PendingIntent cannot be null."); networkCapabilities = new NetworkCapabilities(networkCapabilities); enforceNetworkRequestPermissions(networkCapabilities); enforceMeteredApnPolicy(networkCapabilities); ensureRequestableCapabilities(networkCapabilities); <|startfocus|> <|endfocus|> NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST); NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation); if (DBG) log("pendingRequest for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri)); return networkRequest;
code_review:  I think you need to guard against MatchAllNetworkSpecifier here. Maybe factor the check to a new checkValidNetworkSpecifier() function, and call it here and elsewhere? Alternatively, you might be able to put the check into the NetworkRequestInfo constructor(s), assuming it doesn't change any semantics or significantly complicate error handling code. 
target code: public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) { checkNotNull(operation, "PendingIntent cannot be null."); networkCapabilities = new NetworkCapabilities(networkCapabilities); enforceNetworkRequestPermissions(networkCapabilities); enforceMeteredApnPolicy(networkCapabilities); ensureRequestableCapabilities(networkCapabilities); MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier( networkCapabilities.getNetworkSpecifier()); NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST); NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation); if (DBG) log("pendingRequest for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri)); return networkRequest;
response: import com.android.sched.util.file.CannotChangePermissionException; import com.android.sched.util.file.CannotCreateFileException; import com.android.sched.util.file.Directory; import com.android.sched.util.file.FileAlreadyExistsException; import com.android.sched.util.file.FileOrDirectory; import com.android.sched.util.file.FileOrDirectory.ChangePermission; import com.android.sched.util.file.FileOrDirectory.Existence; import com.android.sched.util.file.FileOrDirectory.Permission; import com.android.sched.util.file.FileUtils; import com.android.sched.util.file.Files; import com.android.sched.util.file.InputJarFile; import com.android.sched.util.file.NoSuchFileException; import com.android.sched.util.file.NotDirectoryException; import com.android.sched.util.file.OutputZipFile.Compression; import com.android.sched.util.file.WriterFile; import com.android.sched.util.file.WrongPermissionException; import com.android.sched.util.location.FileLocation; import com.android.sched.util.location.NoLocation; import com.android.sched.util.location.StringLocation; import com.android.sched.util.log.LoggerFactory; import com.android.sched.util.log.TracerFactory; import com.android.sched.util.log.tracer.StatsTracerFtl; import com.android.sched.vfs.Container; public Range update(final double min, final double max, int length) { if (scale.isLogScaleEnabled() && (min <= 0 || max <= 0)) { throw new IllegalArgumentException("Range for log scale must be in positive range"); } final int maximumNumTicks = Math.min(MAX_TICKS, length / (scale.isHorizontal() ? TICKMINDIST_IN_PIXELS_X : TICKMINDIST_IN_PIXELS_Y) + 1); int numTicks = Math.max(3, maximumNumTicks); final TickFactory tf; if (scale instanceof AbstractScale) { AbstractScale aScale = (AbstractScale) scale; if (aScale.hasUserDefinedFormat()) { tf = new TickFactory(scale); } else if (aScale.isAutoFormat()) { tf = new TickFactory(TickFormatting.autoMode, scale); } else { String format = aScale.getFormatPattern(); if (format.contains("E")) { tf = new TickFactory(TickFormatting.useExponent, scale); } else { tf = new TickFactory(TickFormatting.autoMode, scale); }

sample: 386
buggy_code:  NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities); if (!ConnectivityManager.checkChangePermission(mContext)) { // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get // onLost and onAvailable callbacks when networks move in and out of the background. // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE // can't request networks. nc.addCapability(NET_CAPABILITY_FOREGROUND); } <|startfocus|> <|endfocus|> NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN); NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder); if (VDBG) log("listenForNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri)); return networkRequest;
code_review:  Ditto. 
target code: NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities); if (!ConnectivityManager.checkChangePermission(mContext)) { // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get // onLost and onAvailable callbacks when networks move in and out of the background. // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE // can't request networks. nc.addCapability(NET_CAPABILITY_FOREGROUND); } MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier( networkCapabilities.getNetworkSpecifier()); NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN); NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder); if (VDBG) log("listenForNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri)); return networkRequest;
response: NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities); if (!ConnectivityManager.checkChangePermission(mContext)) { nc.addCapability(NET_CAPABILITY_FOREGROUND); } NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN); NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri)); return networkRequest;

sample: 387
buggy_code:  public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) { checkNotNull(operation, "PendingIntent cannot be null."); if (!hasWifiNetworkListenPermission(networkCapabilities)) { enforceAccessPermission(); } <|startfocus|> <|endfocus|> NetworkRequest networkRequest = new NetworkRequest( new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN); NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation); if (VDBG) log("pendingListenForNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
code_review:  Ditto. 
target code: public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) { checkNotNull(operation, "PendingIntent cannot be null."); if (!hasWifiNetworkListenPermission(networkCapabilities)) { enforceAccessPermission(); } MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier( networkCapabilities.getNetworkSpecifier()); NetworkRequest networkRequest = new NetworkRequest( new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN); NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation); if (VDBG) log("pendingListenForNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
response: public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) { checkNotNull(operation, "PendingIntent cannot be null."); if (!hasWifiNetworkListenPermission(networkCapabilities)) { enforceAccessPermission(); } NetworkRequest networkRequest = new NetworkRequest( new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN ); NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation); if (VDBG) { log("pendingListenForNetwork for " + nri); } mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri)); }

sample: 388
buggy_code: <|startfocus|> public void setNetworkSpecifier(String specifier) { if (TextUtils.isEmpty(specifier)) { mNetworkCapabilities.setNetworkSpecifier(null); } else { mNetworkCapabilities.setNetworkSpecifier(new StringNetworkSpecifier(specifier)); } <|endfocus|> mNetworkAgent.sendNetworkCapabilities(mNetworkCapabilities);
code_review:  Now that setNetworkSpecifier(String) is just a wrapper, can you make this test method take a NetworkSpecifier instead of a String? That is what real NetworkAgents will do. 
target code: public void setNetworkSpecifier(NetworkSpecifier networkSpecifier) { mNetworkCapabilities.setNetworkSpecifier(networkSpecifier); mNetworkAgent.sendNetworkCapabilities(mNetworkCapabilities);
response: public void setNetworkSpecifier(NetworkSpecifier specifier) { if (specifier == null) { mNetworkCapabilities.setNetworkSpecifier(null); } else { mNetworkCapabilities.setNetworkSpecifier(specifier); } mNetworkAgent.sendNetworkCapabilities(mNetworkCapabilities); }

sample: 389
buggy_code:  public void testNetworkSpecifier() { NetworkRequest rEmpty1 = newWifiRequestBuilder().build(); NetworkRequest rEmpty2 = newWifiRequestBuilder().setNetworkSpecifier((String) null).build(); NetworkRequest rEmpty3 = newWifiRequestBuilder().setNetworkSpecifier("").build(); NetworkRequest rEmpty4 = newWifiRequestBuilder().setNetworkSpecifier( (NetworkSpecifier) null).build(); NetworkRequest rFoo = newWifiRequestBuilder().setNetworkSpecifier("foo").build(); <|startfocus|> NetworkRequest rBar = newWifiRequestBuilder().setNetworkSpecifier("bar").build(); <|endfocus|> TestNetworkCallback cEmpty1 = new TestNetworkCallback(); TestNetworkCallback cEmpty2 = new TestNetworkCallback(); TestNetworkCallback cEmpty3 = new TestNetworkCallback(); TestNetworkCallback cEmpty4 = new TestNetworkCallback(); TestNetworkCallback cFoo = new TestNetworkCallback(); TestNetworkCallback cBar = new TestNetworkCallback(); TestNetworkCallback[] emptyCallbacks = new TestNetworkCallback[] { cEmpty1, cEmpty2, cEmpty3 }; mCm.registerNetworkCallback(rEmpty1, cEmpty1); mCm.registerNetworkCallback(rEmpty2, cEmpty2); mCm.registerNetworkCallback(rEmpty3, cEmpty3);
code_review:  Can you use a StringNetworkSpecifier for this one, so you can test both the string setter (with "foo") and the NetworkSpecifier setter (here)? 
target code: public void testNetworkSpecifier() { NetworkRequest rEmpty1 = newWifiRequestBuilder().build(); NetworkRequest rEmpty2 = newWifiRequestBuilder().setNetworkSpecifier((String) null).build(); NetworkRequest rEmpty3 = newWifiRequestBuilder().setNetworkSpecifier("").build(); NetworkRequest rEmpty4 = newWifiRequestBuilder().setNetworkSpecifier( (NetworkSpecifier) null).build(); NetworkRequest rFoo = newWifiRequestBuilder().setNetworkSpecifier("foo").build(); NetworkRequest rBar = newWifiRequestBuilder().setNetworkSpecifier( new StringNetworkSpecifier("bar")).build(); TestNetworkCallback cEmpty1 = new TestNetworkCallback(); TestNetworkCallback cEmpty2 = new TestNetworkCallback(); TestNetworkCallback cEmpty3 = new TestNetworkCallback(); TestNetworkCallback cEmpty4 = new TestNetworkCallback(); TestNetworkCallback cFoo = new TestNetworkCallback(); TestNetworkCallback cBar = new TestNetworkCallback(); TestNetworkCallback[] emptyCallbacks = new TestNetworkCallback[] { cEmpty1, cEmpty2, cEmpty3 }; mCm.registerNetworkCallback(rEmpty1, cEmpty1); mCm.registerNetworkCallback(rEmpty2, cEmpty2); mCm.registerNetworkCallback(rEmpty3, cEmpty3);
response: public void testNetworkSpecifier() { NetworkRequest rEmpty1 = newWifiRequestBuilder().build(); NetworkRequest rEmpty2 = newWifiRequestBuilder().setNetworkSpecifier((String) null).build(); NetworkRequest rEmpty3 = newWifiRequestBuilder().setNetworkSpecifier("").build(); NetworkRequest rEmpty4 = newWifiRequestBuilder().setNetworkSpecifier((NetworkSpecifier) null).build(); NetworkRequest rFoo = newWifiRequestBuilder().setNetworkSpecifier("foo").build(); NetworkRequest rBar = newWifiRequestBuilder().setNetworkSpecifier(new StringNetworkSpecifier("bar")).build(); TestNetworkCallback cEmpty1 = new TestNetworkCallback(); TestNetworkCallback cEmpty2 = new TestNetworkCallback(); TestNetworkCallback cEmpty3 = new TestNetworkCallback(); TestNetworkCallback cEmpty4 = new TestNetworkCallback(); TestNetworkCallback cFoo = new TestNetworkCallback(); TestNetworkCallback cBar = new TestNetworkCallback(); TestNetworkCallback[] emptyCallbacks = new TestNetworkCallback[] { cEmpty1, cEmpty2, cEmpty3 }; mCm.registerNetworkCallback(rEmpty1, cEmpty1); mCm.registerNetworkCallback(rEmpty2, cEmpty2); mCm.registerNetworkCallback(rEmpty3, cEmpty3); mCm.registerNetworkCallback(rEmpty4, cEmpty4); mCm.registerNetworkCallback(rFoo, cFoo); mCm.registerNetworkCallback(rBar, cBar); }

sample: 390
buggy_code:  mCm.registerNetworkCallback(rEmpty3, cEmpty3); mCm.registerNetworkCallback(rEmpty4, cEmpty4); mCm.registerNetworkCallback(rFoo, cFoo); mCm.registerNetworkCallback(rBar, cBar); mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI); mWiFiNetworkAgent.connect(false); cEmpty1.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty2.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty3.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty4.expectAvailableCallbacks(mWiFiNetworkAgent); assertNoCallbacks(cFoo, cBar); <|startfocus|> mWiFiNetworkAgent.setNetworkSpecifier("foo"); <|endfocus|> cFoo.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cFoo.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cFoo.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier("bar"); cFoo.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); cBar.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); }
code_review:  Use StringNetworkSpecifier. 
target code: mCm.registerNetworkCallback(rEmpty3, cEmpty3); mCm.registerNetworkCallback(rEmpty4, cEmpty4); mCm.registerNetworkCallback(rFoo, cFoo); mCm.registerNetworkCallback(rBar, cBar); mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI); mWiFiNetworkAgent.connect(false); cEmpty1.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty2.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty3.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty4.expectAvailableCallbacks(mWiFiNetworkAgent); assertNoCallbacks(cFoo, cBar); mWiFiNetworkAgent.setNetworkSpecifier(new StringNetworkSpecifier("foo")); cFoo.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cFoo.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cFoo.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier("bar"); cFoo.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); cBar.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); }
response: mCm.registerNetworkCallback(rEmpty3, cEmpty3); mCm.registerNetworkCallback(rEmpty4, cEmpty4); mCm.registerNetworkCallback(rFoo, cFoo); mCm.registerNetworkCallback(rBar, cBar); mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI); mWiFiNetworkAgent.connect(false); cEmpty1.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty2.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty3.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty4.expectAvailableCallbacks(mWiFiNetworkAgent); assertNoCallbacks(cFoo, cBar); mWiFiNetworkAgent.setNetworkSpecifier("foo"); cFoo.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c : emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cFoo.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cFoo.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier("bar"); cFoo.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); cBar.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c : emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); }

sample: 391
buggy_code:  cEmpty2.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty3.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty4.expectAvailableCallbacks(mWiFiNetworkAgent); assertNoCallbacks(cFoo, cBar); mWiFiNetworkAgent.setNetworkSpecifier("foo"); cFoo.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cFoo.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cFoo.assertNoCallback(); <|startfocus|> mWiFiNetworkAgent.setNetworkSpecifier("bar"); <|endfocus|> cFoo.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); cBar.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cBar.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cBar.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier(null); cBar.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } assertNoCallbacks(cEmpty1, cEmpty2, cEmpty3, cFoo, cBar);
code_review:  Use StringNetworkSpecifier. 
target code: cEmpty2.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty3.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty4.expectAvailableCallbacks(mWiFiNetworkAgent); assertNoCallbacks(cFoo, cBar); mWiFiNetworkAgent.setNetworkSpecifier("foo"); cFoo.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cFoo.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cFoo.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier(new StringNetworkSpecifier("bar")); cFoo.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); cBar.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cBar.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cBar.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier(null); cBar.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); for (TestNetworkCallback c: emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } assertNoCallbacks(cEmpty1, cEmpty2, cEmpty3, cFoo, cBar);
response: cEmpty2.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty3.expectAvailableCallbacks(mWiFiNetworkAgent); cEmpty4.expectAvailableCallbacks(mWiFiNetworkAgent); assertNoCallbacks(cFoo, cBar); mWiFiNetworkAgent.setNetworkSpecifier("foo"); cFoo.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c : emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cFoo.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cFoo.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier("bar"); cFoo.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); cBar.expectAvailableCallbacks(mWiFiNetworkAgent); for (TestNetworkCallback c : emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } cBar.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); cBar.assertNoCallback(); mWiFiNetworkAgent.setNetworkSpecifier(null); cBar.expectCallback(CallbackState.LOST, mWiFiNetworkAgent); for (TestNetworkCallback c : emptyCallbacks) { c.expectCallback(CallbackState.NETWORK_CAPABILITIES, mWiFiNetworkAgent); } assertNoCallbacks(cEmpty1, cEmpty2, cEmpty3, cFoo, cBar);

sample: 392
buggy_code:  }; class ParcelableSpecifier extends NonParcelableSpecifier implements Parcelable { @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel p, int flags) {} } NetworkRequest.Builder builder; builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET); try { builder.setNetworkSpecifier(new NonParcelableSpecifier()); Parcel parcelW = Parcel.obtain(); builder.build().writeToParcel(parcelW, 0); <|startfocus|> fail("Non-parcelable specifier did not throw exception"); <|endfocus|> } catch (Exception e) { // expected }
code_review:  What is this code testing exactly? That build() throws? That writeToParcel throws? It seems that here we should be testing that both non-Parcelable and non-framework Parcelable specifiers fail when used. 
target code: }; class ParcelableSpecifier extends NonParcelableSpecifier implements Parcelable { @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel p, int flags) {} } NetworkRequest.Builder builder; builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET); try { builder.setNetworkSpecifier(new NonParcelableSpecifier()); Parcel parcelW = Parcel.obtain(); builder.build().writeToParcel(parcelW, 0); fail("Parceling a non-parcelable specifier did not throw an exception"); } catch (Exception e) { // expected }
response: import org.bouncycastle.crypto.generators.BCrypt; import org.bouncycastle.util.Arrays; public class HashedPassword { private static final String ALGORITHM = "bcrypt"; private static SecureRandom secureRandom = new SecureRandom(); private static Base64 codec = new Base64(-1); public static HashedPassword decode(String encoded) { Preconditions.checkState(encoded.startsWith(ALGORITHM + ":")); String[] fields = encoded.split(":"); Preconditions.checkState(fields.length == 4); int cost = Integer.parseInt(fields[1]); return new HashedPassword(codec.decodeBase64(fields[3]), codec.decodeBase64(fields[2]), cost); } private static byte[] hashPassword(String password, byte[] salt, int cost) { byte pwBytes[] = password.getBytes(StandardCharsets.UTF_8); // hashing logic } } import org.apache.harmony.jpda.tests.share.JPDADebuggeeSynchronizer; public class BreakpointOnCatchTest extends JDWPEventTestCase { @Override protected String getDebuggeeClassName() { return BreakpointOnCatchDebuggee.class.getName(); } public void testBreakpointOnCatch() { logWriter.println("testBreakpointOnCatch started"); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY); long classID = getClassIDBySignature(getDebuggeeClassSignature()); long methodID = getMethodID(classID, BreakpointOnCatchDebuggee.BREAKPOINT_METHOD_NAME); logWriter.println("Install breakpoint in " + BreakpointOnCatchDebuggee.BREAKPOINT_METHOD_NAME); // breakpoint installation logic } } class ParcelableSpecifier extends NonParcelableSpecifier implements Parcelable { @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel p, int flags) { // parcel writing logic } } NetworkRequest.Builder builder; builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET); try { builder.setNetworkSpecifier(new NonParcelableSpecifier()); Parcel parcelW = Parcel.obtain(); builder.build().writeToParcel(parcelW, 0); fail("Non-parcelable specifier did not throw exception"); } catch (Exception e) { // expected }

sample: 393
buggy_code:  private int phoneIdForRequest(NetworkRequest netRequest) { NetworkSpecifier specifier = netRequest.networkCapabilities.getNetworkSpecifier(); int subId; if (specifier == null) { subId = mDefaultDataSubscription; } else if (specifier instanceof StringNetworkSpecifier) { <|startfocus|> subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier); <|endfocus|> } else { subId = INVALID_SUBSCRIPTION_ID; } int phoneId = INVALID_PHONE_INDEX; if (subId == INVALID_SUBSCRIPTION_ID) return phoneId; for (int i = 0 ; i < mNumPhones; i++) { if (mPhoneSubscriptions[i] == subId) { phoneId = i; break; } } return phoneId;
code_review:  please catch the NumberFormatException and use INVALID. yeah, I know you didn't introduce this, but while we're here. 
target code: private int phoneIdForRequest(NetworkRequest netRequest) { NetworkSpecifier specifier = netRequest.networkCapabilities.getNetworkSpecifier(); int subId; if (specifier == null) { subId = mDefaultDataSubscription; } else if (specifier instanceof StringNetworkSpecifier) { try { subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier); } catch (NumberFormatException e) { Rlog.e(LOG_TAG, "NumberFormatException on " + ((StringNetworkSpecifier) specifier).specifier); subId = INVALID_SUBSCRIPTION_ID; } } else { subId = INVALID_SUBSCRIPTION_ID; } int phoneId = INVALID_PHONE_INDEX; if (subId == INVALID_SUBSCRIPTION_ID) return phoneId; for (int i = 0 ; i < mNumPhones; i++) { if (mPhoneSubscriptions[i] == subId) { phoneId = i; break; } } return phoneId;
response: private int phoneIdForRequest(NetworkRequest netRequest) { NetworkSpecifier specifier = netRequest.networkCapabilities.getNetworkSpecifier(); int subId; if (specifier == null) { subId = mDefaultDataSubscription; } else if (specifier instanceof StringNetworkSpecifier) { try { subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier); } catch (NumberFormatException e) { subId = INVALID_SUBSCRIPTION_ID; } } else { subId = INVALID_SUBSCRIPTION_ID; } int phoneId = INVALID_PHONE_INDEX; if (subId == INVALID_SUBSCRIPTION_ID) { return phoneId; } for (int i = 0; i < mNumPhones; i++) { if (mPhoneSubscriptions[i] == subId) { phoneId = i; break; } } return phoneId; }

sample: 394
buggy_code:  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; <|startfocus|> import android.net.wifi.aware.WifiAwareNetworkSpecifier; <|endfocus|> /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of * subclasses of this class via other APIs. */ public abstract class NetworkSpecifier { public NetworkSpecifier() {} /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. * * @hide */ public abstract boolean satisfiedBy(NetworkSpecifier other); } 
code_review:  ? 
target code: * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net; /** * Describes specific properties of a network for use in a {@link NetworkRequest}. * * Applications cannot instantiate this class by themselves, but can obtain instances of * subclasses of this class via other APIs. */ public abstract class NetworkSpecifier { public NetworkSpecifier() {} /** * Returns true if a request with this {@link NetworkSpecifier} is satisfied by a network * with the given NetworkSpecifier. * * @hide */ public abstract boolean satisfiedBy(NetworkSpecifier other); }
response: package android.net; import android.net.wifi.aware.WifiAwareNetworkSpecifier; public abstract class NetworkSpecifier { public NetworkSpecifier() {} public abstract boolean satisfiedBy(NetworkSpecifier other); }

sample: 395
buggy_code:  public void resize(int newSize) { <|startfocus|> int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); <|endfocus|> }
code_review:  Int 
target code: public void resize(int newSize) { Preconditions.checkArgumentNonnegative(newSize); if (newSize <= mValues.length) { Arrays.fill(mValues, newSize, mValues.length, 0); } else { ensureCapacity(newSize - mSize); }
response: public void resize(int newSize) { int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); } }

sample: 396
buggy_code:  public void resize(int newSize) { int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); <|startfocus|> } <|endfocus|>
code_review:  I don't know why I'm confused, but I think these operands should be reversed, no? (and in the fill(...) below) 
target code: public void resize(int newSize) { int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); } mSize = newSize;
response: public void resize(int newSize) { int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize > oldSize) { Arrays.fill(mValues, oldSize, newSize, 0); } }

sample: 397
buggy_code:  public void resize(int newSize) { // TODO throw on negative Size int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); <|startfocus|> } <|endfocus|>
code_review:  reverse? 
target code: public void resize(int newSize) { // TODO throw on negative Size int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); } mSize = newSize;
response: public void resize(int newSize) { // Throw on negative size if (newSize < 0) { throw new IllegalArgumentException("Size cannot be negative"); } int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); } }

sample: 398
buggy_code:  public void resize(int newSize) { // TODO throw on negative Size int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); <|startfocus|> } <|endfocus|>
code_review:  Same here: reverse? 
target code: public void resize(int newSize) { // TODO throw on negative Size int oldSize = mSize; mSize = newSize; ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0); } mSize = newSize;
response: // limitations under the License. package com.google.gerrit.server.query.doc; import com.google.common.collect.Lists; import com.google.gerrit.extensions.restapi.RestReadView; import com.google.gerrit.extensions.restapi.TopLevelResource; import com.google.gerrit.server.query.QueryParseException; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import org.kohsuke.args4j.Option; import java.util.List; public class QueryDocs implements RestReadView<TopLevelResource> { private final DocQueryProcessor imp; public static class DocResult { public String title; public String url; public String content; } @Option(name = "--query", aliases = {"-q"}, metaVar = "QUERY", multiValued = true, usage = "Query string") private List<String> queries; @Inject QueryDocs(DocQueryProcessor imp) { this.imp = imp; } public void addQuery(String query) { if (queries == null) { queries = Lists.newArrayList(); } queries.add(query); } @Override public void apply(TopLevelResource resource) throws QueryParseException, OrmException { // Implementation of apply method } }

sample: 399
buggy_code:  // changes network state. http://b/29964605 enforceMeteredApnPolicy(networkCapabilities); } ensureRequestableCapabilities(networkCapabilities); if (timeoutMs < 0) { throw new IllegalArgumentException("Bad timeout specified"); } if (networkCapabilities.getNetworkSpecifier() instanceof MatchAllNetworkSpecifier) { throw new IllegalArgumentException("NetworkRequest with MatchAllNetworkSpecifier"); } <|startfocus|> if (networkCapabilities.getNetworkSpecifier() instanceof NetworkSpecifier.UidConsumer) { ((NetworkSpecifier.UidConsumer) networkCapabilities.getNetworkSpecifier()) .setRequestorUid(Binder.getCallingUid()); } <|endfocus|> NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type); NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder); if (DBG) log("requestNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri)); if (timeoutMs > 0) { mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs); } return networkRequest;
code_review:  I'm not a fan of making NetworkSpecifiers mutable. How about setting the UID inside WifiAwareNetworkSpecifier, and just enforcing it here? Something like something like: NetworkSpecifier ns = networkCapabilities.getNetworkSpecifier(); if (ns != null && ns.hasUid() && ns.getUid() != Binder.getCallingUid()) { throw new SecurityException(...); } and making the WifiAwareNetworkSpecifier constructor take a UID? (The manager can just get one the UID via Process.myUid()) In the base NetworkSpecifier class, hasUid() would just return false and getUid() would throw UnsupportedOperationException. 
target code: // changes network state. http://b/29964605 enforceMeteredApnPolicy(networkCapabilities); } ensureRequestableCapabilities(networkCapabilities); if (timeoutMs < 0) { throw new IllegalArgumentException("Bad timeout specified"); } if (networkCapabilities.getNetworkSpecifier() instanceof MatchAllNetworkSpecifier) { throw new IllegalArgumentException("NetworkRequest with MatchAllNetworkSpecifier"); } NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type); NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder); if (DBG) log("requestNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri)); if (timeoutMs > 0) { mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs); } return networkRequest;
response: // changes network state. http://b/29964605 enforceMeteredApnPolicy(networkCapabilities); ensureRequestableCapabilities(networkCapabilities); if (timeoutMs < 0) { throw new IllegalArgumentException("Bad timeout specified"); } if (networkCapabilities.getNetworkSpecifier() instanceof MatchAllNetworkSpecifier) { throw new IllegalArgumentException("NetworkRequest with MatchAllNetworkSpecifier"); } if (networkCapabilities.getNetworkSpecifier() instanceof NetworkSpecifier.UidConsumer) { ((NetworkSpecifier.UidConsumer) networkCapabilities.getNetworkSpecifier()) .setRequestorUid(Binder.getCallingUid()); } NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type); NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder); if (DBG) log("requestNetwork for " + nri); mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri)); if (timeoutMs > 0) { mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs); } return networkRequest;

sample: 400
buggy_code:  public static void main(String[] args) { // Set up minint32, maxint32 and some others. int[] xi = new int[8]; xi[0] = 0x80000000; xi[1] = 0x7fffffff; <|startfocus|> xi[2] = -999; <|endfocus|> xi[3] = -13; xi[4] = -1; xi[5] = 0; xi[6] = 1; xi[7] = 999; doitInt(xi); expectEquals32(0x80000000, xi[0]); expectEquals32(0x7fffffff, xi[1]); expectEquals32(999, xi[2]); expectEquals32(13, xi[3]); expectEquals32(1, xi[4]); expectEquals32(0, xi[5]); expectEquals32(1, xi[6]); expectEquals32(999, xi[7]); // Set up minint64, maxint64 and some others. long[] xl = new long[8]; xl[0] = 0x8000000000000000L; xl[1] = 0x7fffffffffffffffL; xl[2] = -999; xl[3] = -13; xl[4] = -1; xl[5] = 0;
code_review:  0x80000001 is also en interesting case. Maybe replace the -999? 
target code: public static void main(String[] args) { // Set up minint32, maxint32 and some others. int[] xi = new int[8]; xi[0] = 0x80000000; xi[1] = 0x7fffffff; xi[2] = 0x80000001; xi[3] = -13; xi[4] = -1; xi[5] = 0; xi[6] = 1; xi[7] = 999; doitInt(xi); expectEquals32(0x80000000, xi[0]); expectEquals32(0x7fffffff, xi[1]); expectEquals32(999, xi[2]); expectEquals32(13, xi[3]); expectEquals32(1, xi[4]); expectEquals32(0, xi[5]); expectEquals32(1, xi[6]); expectEquals32(999, xi[7]); // Set up minint64, maxint64 and some others. long[] xl = new long[8]; xl[0] = 0x8000000000000000L; xl[1] = 0x7fffffffffffffffL; xl[2] = -999; xl[3] = -13; xl[4] = -1; xl[5] = 0;
response: public static void main(String[] args) { // Set up minint32, maxint32 and some others. int[] xi = new int[8]; xi[0] = 0x80000000; xi[1] = 0x7fffffff; xi[2] = -999; xi[3] = -13; xi[4] = -1; xi[5] = 0; xi[6] = 1; xi[7] = 999; doitInt(xi); expectEquals32(0x80000000, xi[0]); expectEquals32(0x7fffffff, xi[1]); expectEquals32(999, xi[2]); expectEquals32(13, xi[3]); expectEquals32(1, xi[4]); expectEquals32(0, xi[5]); expectEquals32(1, xi[6]); expectEquals32(999, xi[7]); // Set up minint64, maxint64 and some others. long[] xl = new long[8]; xl[0] = 0x8000000000000000L; xl[1] = 0x7fffffffffffffffL; xl[2] = -999; xl[3] = -13; xl[4] = -1; xl[5] = 0; xl[6] = 1; xl[7] = 999; }

sample: 401
buggy_code:  try { provider.isSameFile(null, filesSetup.getDataFilePath()); fail(); } catch (NullPointerException expected) {} try { provider.isSameFile(filesSetup.getDataFilePath(), null); fail(); } catch (NullPointerException expected) {} } @Test public void test_getFileStore() throws IOException { try { provider.getFileStore(filesSetup.getDataFilePath()); fail(); } catch (SecurityException expected) { } } <|startfocus|> @Test public void test_getFileStore_NPE() throws IOException { <|endfocus|> try { provider.getFileStore(null); fail(); } catch(SecurityException expected) { } } @Test public void test_isHidden() throws IOException { assertFalse(provider.isHidden(filesSetup.getDataFilePath())); // Files can't be hidden using the "dos" view, which is unsupported since it relies // on a custom xattr, which may or may not be available on all FSs. // // Note that this weirdly asymmetric : setting the hidden attribute uses xattrs to
code_review:  May want to rename. 
target code: try { provider.isSameFile(null, filesSetup.getDataFilePath()); fail(); } catch (NullPointerException expected) {} try { provider.isSameFile(filesSetup.getDataFilePath(), null); fail(); } catch (NullPointerException expected) {} } @Test public void test_getFileStore() throws IOException { try { provider.getFileStore(filesSetup.getDataFilePath()); fail(); } catch (SecurityException expected) { } } try { provider.getFileStore(null); fail(); } catch(SecurityException expected) { } } @Test public void test_isHidden() throws IOException { assertFalse(provider.isHidden(filesSetup.getDataFilePath())); // Files can't be hidden using the "dos" view, which is unsupported since it relies // on a custom xattr, which may or may not be available on all FSs. // // Note that this weirdly asymmetric : setting the hidden attribute uses xattrs to
response: @Test public void test_getFileStore_NPE() throws IOException { try { provider.getFileStore(null); fail(); } catch(SecurityException expected) { } }

sample: 402
buggy_code:  } else { return false; } } @Rpc(description = "request a network") public String connectivityRequestNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } <|startfocus|> @Rpc(description = "request a Wi-Fi Aware network") <|endfocus|> public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId;
code_review:  Request 
target code: } else { return false; } } @Rpc(description = "request a network") public String connectivityRequestNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId;
response: } else { return false; } @Rpc(description = "request a network") public String connectivityRequestNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; }

sample: 403
buggy_code:  mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); <|startfocus|> if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; <|endfocus|> JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } } 
code_review:  More than 80 chars. Move over to next line. 
target code: mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities .getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } }
response: protected void bindZookeeperLockFactory() { ZookeeperLockFactory lockFactory = mock(ZookeeperLockFactory.class); InterProcessSemaphoreMutex lock = mock(InterProcessSemaphoreMutex.class); when(lockFactory.createShared(anyString())).thenReturn(lock); try { doReturn(true).when(lock).acquire(anyLong(), any(TimeUnit.class)); doNothing().when(lock).release(); } catch (Exception e) { throw new RuntimeException(e); } bind(ZookeeperLockFactory.class).toInstance(lockFactory); } public ZookeeperConnectionModule(Class<? extends ZkConnectionAwareWatcher> connWatcherImpl) { this.connWatcherImpl = connWatcherImpl; } Set<Change.Id> visibleChanges = visibleChanges(); Map<String, Ref> result = new HashMap<>(); List<Ref> deferredTags = new ArrayList<>(); for (Ref ref : refs.values()) { Change.Id changeId; Account.Id accountId; if (ref.getName().startsWith(RefNames.REFS_CACHE_AUTOMERGE)) { continue; } else if (showMetadata && ((currAccountId != null && RefNames.isRefsEditOf(ref.getLeaf().getName(), currAccountId)) || (RefNames.isRefsEdit(ref.getLeaf().getName()) && canViewMetadata))) { result.put(ref.getName(), ref); } else if ((changeId = Change.Id.fromRef(ref.getName())) != null) { // code omitted for brevity } } mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; }

sample: 404
buggy_code:  String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); <|startfocus|> networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); <|endfocus|> } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } } 
code_review:  Same as above. 
target code: String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier( WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } }
response: String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } }

sample: 405
buggy_code:  return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); <|startfocus|> networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); <|endfocus|> } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } } @Rpc(description = "Get the extra information about the network state provided by lower network layers.")
code_review:  Same as above. 
target code: return key; } @Rpc(description = "request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier( WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(networkRequest, mNetworkCallback); String key = mNetworkCallback.mId; mNetworkCallbackMap.put(key, mNetworkCallback); return key; } @Rpc(description = "Stop listening for connectivity changes") public void connectivityStopTrackingConnectivityStateChange() { if (mTrackingConnectivityStateChange) { mTrackingConnectivityStateChange = false; mContext.unregisterReceiver(mConnectivityReceiver); } } @Rpc(description = "Get the extra information about the network state provided by lower network layers.")
response: private static String networkTypeToString(int type) { String ret = "unknown"; switch (type) { case DATA_ACCESS_CDMA_IS95A: case DATA_ACCESS_CDMA_IS95B: case DATA_ACCESS_CDMA_1xRTT: ret = "CDMA"; break; case DATA_ACCESS_CDMA_EvDo_0: ret = "EVDO_0"; break; case DATA_ACCESS_CDMA_EvDo_A: ret = "EVDO_A"; break; default: if (DBG) { log("Unknown network type: " + type); } break; } return ret; } private void handleScoConnected(Message msg) { if (msg.arg1 == ScoSocket.STATE_CONNECTED && isHeadsetConnected() && mConnectedSco == null) { if (VDBG) log("Routing audio for outgoing SCO connection"); mConnectedSco = (ScoSocket) msg.obj; mAudioManager.setBluetoothScoOn(true); if (isCellularCallInProgress()) { broadcastAudioStateIntent(BluetoothHeadset.AUDIO_STATE_CONNECTED, mHeadset.getRemoteDevice()); } else if ((mHFScoState == HF_STATE_SCO_VIRTUALCALL_SETUP) || (mHFScoState == HF_STATE_SCO_VIRTUALCALL_TRANSFERRED)) { mHFScoState = HF_STATE_SCO_VIRTUALCALL_ACTIVE; broadcastVirtualCallStateIntent(BluetoothHeadset.VIRTUALCALL_STATE_CONNECTED); } if (DBG) log("mHandler: Updated mHFScoState:" + mHFScoState); } else if (msg.arg1 == ScoSocket.STATE_CONNECTED) { // Handle other cases } } @Rpc(description = "Request a Wi-Fi Aware network") public String connectivityRequestWifiAwareNetwork(@RpcParameter(name = "configJson") JSONObject configJson) throws JSONException { NetworkRequest networkRequest = buildNetworkRequestFromJson(configJson); if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier; JSONObject j = new JSONObject(ns); networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j)); } mNetworkCallback = new NetworkCallback(NetworkCallback.EVENT_ALL); mManager.requestNetwork(network

sample: 406
buggy_code:  public Uri insert(Uri uri, ContentValues values) { if (uri.isPathPrefixMatch(CONTENT_URI)) { // Parse the subId int subId = 0; try { subId = Integer.parseInt(uri.getLastPathSegment()); } catch (NumberFormatException e) { <|startfocus|> Log.d(TAG, "no subId provided, using default."); subId = getDefaultSubId(); <|endfocus|> } Log.d(TAG, "subId=" + subId); // create the new service state ServiceState newSS = new ServiceState(); newSS.setVoiceRegState(values.getAsInteger(VOICE_REG_STATE)); newSS.setDataRegState(values.getAsInteger(DATA_REG_STATE)); newSS.setVoiceOperatorName(values.getAsString(VOICE_OPERATOR_ALPHA_LONG), values.getAsString(VOICE_OPERATOR_ALPHA_SHORT), values.getAsString(VOICE_OPERATOR_NUMERIC)); newSS.setDataOperatorName(values.getAsString(DATA_OPERATOR_ALPHA_LONG), values.getAsString(DATA_OPERATOR_ALPHA_SHORT), values.getAsString(DATA_OPERATOR_NUMERIC)); newSS.setIsManualSelection(values.getAsBoolean(IS_MANUAL_NETWORK_SELECTION));
code_review:  this should never happen, right? insert should happen only from telephony and subId should always be specified. Also, we need to make sure that only system can do an insert. We can use MODIFY_PHONE_STATE or some such permission for it. Can you check how to specify that insert requires a certain permission? 
target code: public Uri insert(Uri uri, ContentValues values) { if (uri.isPathPrefixMatch(CONTENT_URI)) { // Parse the subId int subId = 0; try { subId = Integer.parseInt(uri.getLastPathSegment()); } catch (NumberFormatException e) { Log.d(TAG, "insert: no subId provided in uri"); throw e; } Log.d(TAG, "subId=" + subId); // create the new service state ServiceState newSS = new ServiceState(); newSS.setVoiceRegState(values.getAsInteger(VOICE_REG_STATE)); newSS.setDataRegState(values.getAsInteger(DATA_REG_STATE)); newSS.setVoiceOperatorName(values.getAsString(VOICE_OPERATOR_ALPHA_LONG), values.getAsString(VOICE_OPERATOR_ALPHA_SHORT), values.getAsString(VOICE_OPERATOR_NUMERIC)); newSS.setDataOperatorName(values.getAsString(DATA_OPERATOR_ALPHA_LONG), values.getAsString(DATA_OPERATOR_ALPHA_SHORT), values.getAsString(DATA_OPERATOR_NUMERIC)); newSS.setIsManualSelection(values.getAsBoolean(IS_MANUAL_NETWORK_SELECTION));
response: public Uri insert(Uri uri, ContentValues values) { if (uri.isPathPrefixMatch(CONTENT_URI)) { // Parse the subId int subId = 0; try { subId = Integer.parseInt(uri.getLastPathSegment()); } catch (NumberFormatException e) { Log.d(TAG, "no subId provided, using default."); subId = getDefaultSubId(); } Log.d(TAG, "subId=" + subId); // create the new service state ServiceState newSS = new ServiceState(); newSS.setVoiceRegState(values.getAsInteger(VOICE_REG_STATE)); newSS.setDataRegState(values.getAsInteger(DATA_REG_STATE)); newSS.setVoiceOperatorName(values.getAsString(VOICE_OPERATOR_ALPHA_LONG), values.getAsString(VOICE_OPERATOR_ALPHA_SHORT), values.getAsString(VOICE_OPERATOR_NUMERIC)); newSS.setDataOperatorName(values.getAsString(DATA_OPERATOR_ALPHA_LONG), values.getAsString(DATA_OPERATOR_ALPHA_SHORT), values.getAsString(DATA_OPERATOR_NUMERIC)); newSS.setIsManualSelection(values.getAsBoolean(IS_MANUAL_NETWORK_SELECTION)); // TODO: Check if the insert operation requires a certain permission // TODO: Perform the insert operation // TODO: Return the inserted Uri } return null; }

sample: 407
buggy_code:  private static byte getRandomNonZeroByte() { final byte random = (byte) (new Random()).nextInt(); <|startfocus|> // Don't pick the subnet-router anycast address, since that mind be // to the upstream already. <|endfocus|> return (random != 0) ? random : 0x1;
code_review:  might 
target code: private static byte getRandomNonZeroByte() { final byte random = (byte) (new Random()).nextInt(); // Don't pick the subnet-router anycast address, since that might be // in use on the upstream already. return (random != 0) ? random : 0x1;
response: private static byte getRandomNonZeroByte() { final byte random = (byte) (new Random()).nextInt(); return (random != 0) ? random : 0x1; }

sample: 408
buggy_code:  public boolean processMessage(Message message) { maybeLogMessage(this, message.what); boolean retValue = true; switch (message.what) { case CMD_TETHER_REQUESTED: <|startfocus|> final Mode mode; try { mode = (Mode) message.obj; } catch (ClassCastException e) { Log.e(TAG, "Invalid tethering interface mode given."); break; } <|endfocus|> Log.e(TAG, "CMD_TETHER_REQUESTED with mode " + mode + " when already operating in mode " + mMode); break; case CMD_TETHER_UNREQUESTED: transitionTo(mInitialState); if (DBG) Log.d(TAG, "Untethered (unrequested)" + mIfaceName); break; case CMD_INTERFACE_DOWN: transitionTo(mUnavailableState); if (DBG) Log.d(TAG, "Untethered (ifdown)" + mIfaceName); break; case CMD_TETHER_CONNECTION_CHANGED: if (mMode != Mode.TETHERING) { // Upstream changes are not of interest in our current mode. break; } String newUpstreamIfaceName = (String)(message.obj);
code_review:  Ditto. 
target code: public boolean processMessage(Message message) { maybeLogMessage(this, message.what); boolean retValue = true; switch (message.what) { case CMD_TETHER_REQUESTED: final Mode mode = (Mode) message.obj; Log.e(TAG, "CMD_TETHER_REQUESTED with mode " + mode + " when already operating in mode " + mMode); break; case CMD_TETHER_UNREQUESTED: transitionTo(mInitialState); if (DBG) Log.d(TAG, "Untethered (unrequested)" + mIfaceName); break; case CMD_INTERFACE_DOWN: transitionTo(mUnavailableState); if (DBG) Log.d(TAG, "Untethered (ifdown)" + mIfaceName); break; case CMD_TETHER_CONNECTION_CHANGED: if (mMode != Mode.TETHERING) { // Upstream changes are not of interest in our current mode. break; } String newUpstreamIfaceName = (String)(message.obj);
response: protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.list_7); mPhone = (TextView) findViewById(R.id.phone); getListView().setOnItemSelectedListener(this); Cursor c = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, PEOPLE_PROJECTION, null, null, null); startManagingCursor(c); mColumnHasPhoneNumber = c.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER); mColumnContactId = c.getColumnIndex(ContactsContract.Contacts._ID); ListAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, c, new String[] {ContactsContract.Contacts.DISPLAY_NAME}, new int[] {android.R.id.text1}); setListAdapter(adapter); } public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Cursor groupCursor = managedQuery(Contacts.CONTENT_URI, PEOPLE_PROJECTION, null, null, null); mContactIdColumnIndex = groupCursor.getColumnIndexOrThrow(ContactsContract.Contacts._ID); mAdapter = new MyExpandableListAdapter(groupCursor, this, android.R.layout.simple_expandable_list_item_1, android.R.layout.simple_expandable_list_item_1, new String[] {ContactsContract.Contacts.DISPLAY_NAME}, new int[] {android.R.id.text1}, new String[] {ContactsContract.CommonDataKinds.Phone.NUMBER}, new int[] {android.R.id.text1}); setListAdapter(mAdapter); } public boolean processMessage(Message message) { maybeLogMessage(this, message.what); boolean retValue = true; switch (message.what) { case CMD_TETHER_REQUESTED: final Mode mode; try { mode = (Mode) message.obj; } catch (ClassCastException e) { Log.e(TAG, "Invalid tethering interface mode given."); break; } Log.e(TAG, "CMD_TETHER_REQUESTED with mode " + mode + " when already operating in mode " + mMode); break; case CMD_TETHER_UNREQUESTED: transitionTo(mInitialState); if (DBG) Log.d(TAG, "Untethered (unrequested)" + mIfaceName); break; case CMD_INTERFACE_DOWN: transitionTo(mUnavailableState); if (DBG) Log.d(TAG, "Untethered (ifdown)" + mIfaceName); break;

sample: 409
buggy_code:  a.resize(15); a.set(14, 30); verify(new int[]{1, 2, 0, 0, 0, 20, 10, 0, 0, 0, 0, 0, 0, 0, 30}, a); int[] backingArray = new int[]{1, 2, 3, 4}; a = IntArray.wrap(backingArray); a.set(0, 10); assertEquals(10, backingArray[0]); backingArray[1] = 20; backingArray[2] = 30; verify(backingArray, a); assertEquals(2, a.indexOf(30)); <|startfocus|> <|endfocus|> a.add(50); verify(new int[]{10, 20, 30, 4, 50}, a);
code_review:  You could also add test for shrinking and zeroing behaviour: a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]); 
target code: a.resize(15); a.set(14, 30); verify(new int[]{1, 2, 0, 0, 0, 20, 10, 0, 0, 0, 0, 0, 0, 0, 30}, a); int[] backingArray = new int[]{1, 2, 3, 4}; a = IntArray.wrap(backingArray); a.set(0, 10); assertEquals(10, backingArray[0]); backingArray[1] = 20; backingArray[2] = 30; verify(backingArray, a); assertEquals(2, a.indexOf(30)); a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]); a.add(50); verify(new int[]{10, 20, 30, 4, 50}, a);
response: public void testIntArray() { IntArray a = new IntArray(); a.resize(15); a.set(14, 30); verify(new int[]{1, 2, 0, 0, 0, 20, 10, 0, 0, 0, 0, 0, 0, 0, 30}, a); int[] backingArray = new int[]{1, 2, 3, 4}; a = IntArray.wrap(backingArray); a.set(0, 10); assertEquals(10, backingArray[0]); backingArray[1] = 20; backingArray[2] = 30; verify(backingArray, a); assertEquals(2, a.indexOf(30)); // Test shrinking and zeroing behavior a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]); a.add(50); verify(new int[]{10, 20, 30, 4, 50}, a); } private void verify(int[] expected, IntArray actual) { assertEquals(expected.length, actual.size()); for (int i = 0; i < expected.length; i++) { assertEquals(expected[i], actual.get(i)); } }

sample: 410
buggy_code:  a.resize(15); a.set(14, 30); verify(new long[]{1, 2, 0, 0, 0, 20, 10, 0, 0, 0, 0, 0, 0, 0, 30}, a); long[] backingArray = new long[]{1, 2, 3, 4}; a = LongArray.wrap(backingArray); a.set(0, 10); assertEquals(10, backingArray[0]); backingArray[1] = 20; backingArray[2] = 30; verify(backingArray, a); assertEquals(2, a.indexOf(30)); <|startfocus|> <|endfocus|> a.add(50); verify(new long[]{10, 20, 30, 4, 50}, a);
code_review:  Same shrinking and zeroing test? 
target code: a.resize(15); a.set(14, 30); verify(new long[]{1, 2, 0, 0, 0, 20, 10, 0, 0, 0, 0, 0, 0, 0, 30}, a); long[] backingArray = new long[]{1, 2, 3, 4}; a = LongArray.wrap(backingArray); a.set(0, 10); assertEquals(10, backingArray[0]); backingArray[1] = 20; backingArray[2] = 30; verify(backingArray, a); assertEquals(2, a.indexOf(30)); a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]); a.add(50); verify(new long[]{10, 20, 30, 4, 50}, a);
response: Fixed Code: ```java a.resize(15); a.set(14, 30); verify(new long[]{1, 2, 0, 0, 0, 20, 10, 0, 0, 0, 0, 0, 0, 0, 30}, a); long[] backingArray = new long[]{1, 2, 3, 4}; a = LongArray.wrap(backingArray); a.set(0, 10); assertEquals(10, backingArray[0]); backingArray[1] = 20; backingArray[2] = 30; verify(backingArray, a); assertEquals(2, a.indexOf(30)); a.add(50); verify(new long[]{10, 20, 30, 4, 50}, a); ```

sample: 411
buggy_code:  * @throws ResourceUnavailableException indicating that too many SPIs are currently allocated * for this user * @throws SpiUnavailableException indicating that a particular SPI cannot be reserved */ public SecurityParameterIndex reserveSecurityParameterIndex( int direction, InetAddress remoteAddress) throws ResourceUnavailableException { try { return new SecurityParameterIndex( mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); <|startfocus|> } catch (SpiUnavailableException impossible) { /*because we choose the SPI, there will alwayse be one*/ return null; <|endfocus|> } } /** * Reserve an SPI for traffic bound towards the specified remote address. * * <p>If successful, this SPI is guaranteed available until released by a call to {@link * SecurityParameterIndex#close()}. * * @param direction {@link IpSecTransform#DIRECTION_IN} or {@link IpSecTransform#DIRECTION_OUT} * @param remoteAddress address of the remote. SPIs must be unique for each remoteAddress.
code_review:  unlikely 
target code: * @throws ResourceUnavailableException indicating that too many SPIs are currently allocated * for this user * @throws SpiUnavailableException indicating that a particular SPI cannot be reserved */ public SecurityParameterIndex reserveSecurityParameterIndex( int direction, InetAddress remoteAddress) throws ResourceUnavailableException { try { return new SecurityParameterIndex( mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); } catch (SpiUnavailableException unlikely) { throw new ResourceUnavailableException("No SPIs available"); } } /** * Reserve an SPI for traffic bound towards the specified remote address. * * <p>If successful, this SPI is guaranteed available until released by a call to {@link * SecurityParameterIndex#close()}. * * @param direction {@link IpSecTransform#DIRECTION_IN} or {@link IpSecTransform#DIRECTION_OUT} * @param remoteAddress address of the remote. SPIs must be unique for each remoteAddress.
response: public SecurityParameterIndex reserveSecurityParameterIndex(int direction, InetAddress remoteAddress) throws ResourceUnavailableException { try { return new SecurityParameterIndex(mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); } catch (SpiUnavailableException impossible) { return null; } }

sample: 412
buggy_code:  * @throws ResourceUnavailableException indicating that too many SPIs are currently allocated * for this user * @throws SpiUnavailableException indicating that a particular SPI cannot be reserved */ public SecurityParameterIndex reserveSecurityParameterIndex( int direction, InetAddress remoteAddress) throws ResourceUnavailableException { try { return new SecurityParameterIndex( mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); <|startfocus|> } catch (SpiUnavailableException impossible) { /*because we choose the SPI, there will alwayse be one*/ return null; <|endfocus|> } } /** * Reserve an SPI for traffic bound towards the specified remote address. * * <p>If successful, this SPI is guaranteed available until released by a call to {@link * SecurityParameterIndex#close()}. * * @param direction {@link IpSecTransform#DIRECTION_IN} or {@link IpSecTransform#DIRECTION_OUT} * @param remoteAddress address of the remote. SPIs must be unique for each remoteAddress.
code_review:  throw new ResourceUnavailableException("No free SPIs"); 
target code: * @throws ResourceUnavailableException indicating that too many SPIs are currently allocated * for this user * @throws SpiUnavailableException indicating that a particular SPI cannot be reserved */ public SecurityParameterIndex reserveSecurityParameterIndex( int direction, InetAddress remoteAddress) throws ResourceUnavailableException { try { return new SecurityParameterIndex( mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); } catch (SpiUnavailableException unlikely) { throw new ResourceUnavailableException("No SPIs available"); } } /** * Reserve an SPI for traffic bound towards the specified remote address. * * <p>If successful, this SPI is guaranteed available until released by a call to {@link * SecurityParameterIndex#close()}. * * @param direction {@link IpSecTransform#DIRECTION_IN} or {@link IpSecTransform#DIRECTION_OUT} * @param remoteAddress address of the remote. SPIs must be unique for each remoteAddress.
response: public SecurityParameterIndex reserveSecurityParameterIndex(int direction, InetAddress remoteAddress) throws ResourceUnavailableException { try { return new SecurityParameterIndex(mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); } catch (SpiUnavailableException impossible) { throw new ResourceUnavailableException("No free SPIs"); } }

sample: 413
buggy_code:  } } if (hostName != null) { hostAddr = InetAddress.getByName(hostName); serverSocket = new ServerSocket(port, 0, hostAddr); } else { serverSocket = new ServerSocket(port); } // use as workaround for unspecified behaviour of isAnyLocalAddress() InetAddress iAddress = null; if (hostName != null) { iAddress = serverSocket.getInetAddress(); } else { <|startfocus|> iAddress = InetAddress.getLoopbackAddress(); <|endfocus|> } address = iAddress.getHostName() + ":" + serverSocket.getLocalPort(); return address; } /** * Stops listening for connection on current address. */ @Override public void stopListening() throws IOException { if (serverSocket != null) { serverSocket.close(); } } /** * Accepts transport connection for currently listened address and performs handshaking * for specified timeout. * * @param acceptTimeout timeout for accepting in milliseconds * @param handshakeTimeout timeout for handshaking in milliseconds */ @Override
code_review:  Maybe also add the explanation/rationale from the commit message here too? 
target code: } } if (hostName != null) { hostAddr = InetAddress.getByName(hostName); serverSocket = new ServerSocket(port, 0, hostAddr); } else { serverSocket = new ServerSocket(port); } // use as workaround for unspecified behaviour of isAnyLocalAddress() InetAddress iAddress = null; if (hostName != null) { iAddress = serverSocket.getInetAddress(); } else { iAddress = InetAddress.getLocalHost(); } address = iAddress.getHostName() + ":" + serverSocket.getLocalPort(); return address; } /** * Stops listening for connection on current address. */ @Override public void stopListening() throws IOException { if (serverSocket != null) { serverSocket.close(); } } /** * Accepts transport connection for currently listened address and performs handshaking * for specified timeout. * * @param acceptTimeout timeout for accepting in milliseconds * @param handshakeTimeout timeout for handshaking in milliseconds */ @Override
response: Refactor the Buggy Code: ```java } } if (hostName != null) { hostAddr = InetAddress.getByName(hostName); serverSocket = new ServerSocket(port, 0, hostAddr); } else { serverSocket = new ServerSocket(port); } InetAddress iAddress = null; if (hostName != null) { iAddress = serverSocket.getInetAddress(); } else { iAddress = InetAddress.getLoopbackAddress(); } address = iAddress.getHostName() + ":" + serverSocket.getLocalPort(); return address; } @Override public void stopListening() throws IOException { if (serverSocket != null) { serverSocket.close(); } } @Override public void acceptAndHandshake(int acceptTimeout, int handshakeTimeout) throws IOException { Socket socket = serverSocket.accept(); performHandshake(socket, handshakeTimeout); } ``` Refactored Code: ```java if (hostName != null) { hostAddr = InetAddress.getByName(hostName); serverSocket = new ServerSocket(port, 0, hostAddr); } else { serverSocket = new ServerSocket(port); } InetAddress iAddress = null; if (hostName != null) { iAddress = serverSocket.getInetAddress(); } else { iAddress = InetAddress.getLoopbackAddress(); } address = iAddress.getHostName() + ":" + serverSocket.getLocalPort(); return address; } @Override public void stopListening() throws IOException { if (serverSocket != null) { serverSocket.close(); } } @Override public void acceptAndHandshake(int acceptTimeout, int handshakeTimeout) throws IOException { Socket socket = serverSocket.accept(); performHandshake(socket, handshakeTimeout); } ```

sample: 414
buggy_code:  expectEquals( 8070450532247928832L, geoLongMulLastValue(2147483647L)); expectEquals( 0L, geoLongMulLastValue(-2147483648L)); expectEquals( 8070450532247928832L, geoLongMulLastValue(9223372036854775807L)); expectEquals( 0L, geoLongMulLastValue(-9223372036854775808L)); float[] a = new float[16]; narrowingSubscript(a); for (int i = 0; i < 16; i++) { expectEquals(2.0f, a[i]); } <|startfocus|> xx = new int[2]; yy = new int[469]; reduc(); <|endfocus|> expectEquals(-469, xx[0]); expectEquals(-938, xx[1]); for (int i = 0; i < 469; i++) { expectEquals(2, yy[i]); } System.out.println("passed");
code_review:  do these need to be fields? It took me a bit to figure out that reduc() will update the vectors. Add a comment if they need to be fields. 
target code: expectEquals( 8070450532247928832L, geoLongMulLastValue(2147483647L)); expectEquals( 0L, geoLongMulLastValue(-2147483648L)); expectEquals( 8070450532247928832L, geoLongMulLastValue(9223372036854775807L)); expectEquals( 0L, geoLongMulLastValue(-9223372036854775808L)); float[] a = new float[16]; narrowingSubscript(a); for (int i = 0; i < 16; i++) { expectEquals(2.0f, a[i]); } int[] xx = new int[2]; int[] yy = new int[469]; reduc(xx, yy); expectEquals(-469, xx[0]); expectEquals(-938, xx[1]); for (int i = 0; i < 469; i++) { expectEquals(2, yy[i]); } System.out.println("passed");
response: expectEquals(8070450532247928832L, geoLongMulLastValue(2147483647L)); expectEquals(0L, geoLongMulLastValue(-2147483648L)); expectEquals(8070450532247928832L, geoLongMulLastValue(9223372036854775807L)); expectEquals(0L, geoLongMulLastValue(-9223372036854775808L)); float[] a = new float[16]; narrowingSubscript(a); for (int i = 0; i < 16; i++) { expectEquals(2.0f, a[i]); } int[] xx = new int[2]; int[] yy = new int[469]; reduc(); expectEquals(-469, xx[0]); expectEquals(-938, xx[1]); for (int i = 0; i < 469; i++) { expectEquals(2, yy[i]); } System.out.println("passed");

sample: 415
buggy_code:  mSentSinceLastRecv = 0; putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST); } else { if (VDBG_STALL) log("updateDataStallInfo: NONE"); } } private boolean isPhoneStateIdle() { for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++ ) { Phone phone = PhoneFactory.getPhone(i); if (phone != null && phone.getState() != PhoneConstants.State.IDLE) { <|startfocus|> log("isPhoneStateIdle: Voice call active on sub: " + i); <|endfocus|> return false; } } return true; } private void onDataStallAlarm(int tag) { if (mDataStallAlarmTag != tag) { if (DBG) { log("onDataStallAlarm: ignore, tag=" + tag + " expecting " + mDataStallAlarmTag); } return; } updateDataStallInfo(); int hangWatchdogTrigger = Settings.Global.getInt(mResolver, Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT, NUMBER_SENT_PACKETS_OF_HANG); boolean suspectedStall = DATA_STALL_NOT_SUSPECTED;
code_review:  phone, not sub 
target code: mSentSinceLastRecv = 0; putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST); } else { if (VDBG_STALL) log("updateDataStallInfo: NONE"); } } private boolean isPhoneStateIdle() { for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++ ) { Phone phone = PhoneFactory.getPhone(i); if (phone != null && phone.getState() != PhoneConstants.State.IDLE) { log("isPhoneStateIdle false: Voice call active on phone " + i); return false; } } return true; } private void onDataStallAlarm(int tag) { if (mDataStallAlarmTag != tag) { if (DBG) { log("onDataStallAlarm: ignore, tag=" + tag + " expecting " + mDataStallAlarmTag); } return; } updateDataStallInfo(); int hangWatchdogTrigger = Settings.Global.getInt(mResolver, Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT, NUMBER_SENT_PACKETS_OF_HANG); boolean suspectedStall = DATA_STALL_NOT_SUSPECTED;
response: mSentSinceLastRecv = 0; putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST); } else { if (VDBG_STALL) log("updateDataStallInfo: NONE"); } } private boolean isPhoneStateIdle() { for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++ ) { Phone phone = PhoneFactory.getPhone(i); if (phone != null && phone.getState() != PhoneConstants.State.IDLE) { log("isPhoneStateIdle: Voice call active on phone: " + i); return false; } } return true; } private void onDataStallAlarm(int tag) { if (mDataStallAlarmTag != tag) { if (DBG) { log("onDataStallAlarm: ignore, tag=" + tag + " expecting " + mDataStallAlarmTag); } return; } updateDataStallInfo(); int hangWatchdogTrigger = Settings.Global.getInt(mResolver, Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT, NUMBER_SENT_PACKETS_OF_HANG); boolean suspectedStall = DATA_STALL_NOT_SUSPECTED;

sample: 416
buggy_code:  chosenIface = iface; break; } } } if (chosenIface == null) { Log.e(TAG, "could not find iface of type " + interfaceType); return; } final int result; switch (requestedState) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: result = untether(chosenIface); break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: result = tether(chosenIface, requestedState); break; default: <|startfocus|> result = -1; <|endfocus|> } if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) { Log.e(TAG, "unable start or stop tethering on iface " + chosenIface); return; }
code_review:  Slog.wtf? 
target code: chosenIface = iface; break; } } } if (chosenIface == null) { Log.e(TAG, "could not find iface of type " + interfaceType); return; } final int result; switch (requestedState) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: result = untether(chosenIface); break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: result = tether(chosenIface, requestedState); break; default: Log.wtf(TAG, "Unknown interface state: " + requestedState); return; } if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) { Log.e(TAG, "unable start or stop tethering on iface " + chosenIface); return; }
response: chosenIface = iface; break; } } } if (chosenIface == null) { Log.e(TAG, "could not find iface of type " + interfaceType); return; } final int result; switch (requestedState) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: result = untether(chosenIface); break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: result = tether(chosenIface, requestedState); break; default: result = -1; } if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) { Log.e(TAG, "unable start or stop tethering on iface " + chosenIface); return; }

sample: 417
buggy_code:  // by sending CMD_CLEAR_ERROR if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: mUpstreamWantingIfaces.remove(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who); break; case IControlsTethering.STATE_TETHERED: <|startfocus|> mUpstreamWantingIfaces.add(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who); break; <|endfocus|> case IControlsTethering.STATE_LOCAL_HOTSPOT: mUpstreamWantingIfaces.remove(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who); break; } sendTetherStateChangedBroadcast();
code_review:  It seems strange that when a downstream starts up, we immediately realize that an upstream is required, but we only wait until the CMD_TETHER_MODE_REQUESTED is processed to do other bookkeeping? Should mUpstreamWantingIfaces be updated while processing CMD_TETHER_MODE_[UN]REQUESTED instead of here? I don't think this is harmful since everything is on the same thread, but it seems like it might be easier to read. 
target code: // by sending CMD_CLEAR_ERROR if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: mUpstreamWantingIfaces.remove(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who); break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: mUpstreamWantingIfaces.remove(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who); break; } sendTetherStateChangedBroadcast();
response: // by sending CMD_CLEAR_ERROR if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: mUpstreamWantingIfaces.remove(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who); break; case IControlsTethering.STATE_TETHERED: mUpstreamWantingIfaces.add(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who); break; case IControlsTethering.STATE_LOCAL_HOTSPOT: mUpstreamWantingIfaces.remove(iface); mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who); break; } sendTetherStateChangedBroadcast();

sample: 418
buggy_code:  case CMD_START_TETHERING_ERROR: case CMD_STOP_TETHERING_ERROR: case CMD_SET_DNS_FORWARDERS_ERROR: mLastError = ConnectivityManager.TETHER_ERROR_MASTER_ERROR; transitionTo(mInitialState); break; default: return false; } return true; } } class LocalHotspotState extends State { @Override public void enter() { if (DBG) Log.d(TAG, "Local hotspot " + mIfaceName); setInterfaceState(IControlsTethering.STATE_LOCAL_HOTSPOT); } @Override <|startfocus|> public void exit() { } @Override <|endfocus|> public boolean processMessage(Message message) { maybeLogMessage(this, message.what); switch (message.what) { case CMD_TETHER_REQUESTED: Log.e(TAG, "CMD_TETHER_REQUESTED while in local hotspot mode."); break; case CMD_TETHER_CONNECTION_CHANGED: // Ignored in local hotspot state. break; default: return false; } return true; } } class TetheredState extends State { @Override public void enter() { if (DBG) Log.d(TAG, "Tethered " + mIfaceName);
code_review:  Optional: consider removing. 
target code: case CMD_START_TETHERING_ERROR: case CMD_STOP_TETHERING_ERROR: case CMD_SET_DNS_FORWARDERS_ERROR: mLastError = ConnectivityManager.TETHER_ERROR_MASTER_ERROR; transitionTo(mInitialState); break; default: return false; } return true; } } class LocalHotspotState extends State { @Override public void enter() { if (DBG) Log.d(TAG, "Local hotspot " + mIfaceName); setInterfaceState(IControlsTethering.STATE_LOCAL_HOTSPOT); } @Override public boolean processMessage(Message message) { maybeLogMessage(this, message.what); switch (message.what) { case CMD_TETHER_REQUESTED: Log.e(TAG, "CMD_TETHER_REQUESTED while in local hotspot mode."); break; case CMD_TETHER_CONNECTION_CHANGED: // Ignored in local hotspot state. break; default: return false; } return true; } } class TetheredState extends State { @Override public void enter() { if (DBG) Log.d(TAG, "Tethered " + mIfaceName);
response: case CMD_START_TETHERING_ERROR: case CMD_STOP_TETHERING_ERROR: case CMD_SET_DNS_FORWARDERS_ERROR: mLastError = ConnectivityManager.TETHER_ERROR_MASTER_ERROR; transitionTo(mInitialState); break; default: return false; } return true; } class LocalHotspotState extends State { @Override public void enter() { if (DBG) Log.d(TAG, "Local hotspot " + mIfaceName); setInterfaceState(IControlsTethering.STATE_LOCAL_HOTSPOT); } @Override public void exit() { } @Override public boolean processMessage(Message message) { maybeLogMessage(this, message.what); switch (message.what) { case CMD_TETHER_REQUESTED: Log.e(TAG, "CMD_TETHER_REQUESTED while in local hotspot mode."); break; case CMD_TETHER_CONNECTION_CHANGED: // Ignored in local hotspot state. break; default: return false; } return true; } } class TetheredState extends State { @Override public void enter() { if (DBG) Log.d(TAG, "Tethered " + mIfaceName); }

sample: 419
buggy_code:  private final Object mPublicSync; private final Context mContext; private final ArrayMap<String, TetherState> mTetherStates; private final BroadcastReceiver mStateReceiver; private final INetworkManagementService mNMService; private final INetworkStatsService mStatsService; private final INetworkPolicyManager mPolicyManager; private final Looper mLooper; private final MockableSystemProperties mSystemProperties; private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; <|startfocus|> private final HashSet<String> mIfacesWantingUpstream; <|endfocus|> private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; private boolean mRndisEnabled; // track the RNDIS function enabled state private boolean mUsbTetherRequested; // true if USB tethering should be started // when RNDIS is enabled // True iff WiFi tethering should be started when soft AP is ready. private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) {
code_review:  Just occurred to me: any reason why this keeps track of interface names instead of TISMs? 
target code: private final Object mPublicSync; private final Context mContext; private final ArrayMap<String, TetherState> mTetherStates; private final BroadcastReceiver mStateReceiver; private final INetworkManagementService mNMService; private final INetworkStatsService mStatsService; private final INetworkPolicyManager mPolicyManager; private final Looper mLooper; private final MockableSystemProperties mSystemProperties; private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private final HashSet<TetherInterfaceStateMachine> mForwardedDownstreams; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; private boolean mRndisEnabled; // track the RNDIS function enabled state private boolean mUsbTetherRequested; // true if USB tethering should be started // when RNDIS is enabled // True iff WiFi tethering should be started when soft AP is ready. private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) {
response: private final Object mPublicSync; private final Context mContext; private final ArrayMap<String, TetherState> mTetherStates; private final BroadcastReceiver mStateReceiver; private final INetworkManagementService mNMService; private final INetworkStatsService mStatsService; private final INetworkPolicyManager mPolicyManager; private final Looper mLooper; private final MockableSystemProperties mSystemProperties; private final StateMachine mTetherMasterSM; private final OffloadController mOffloadController; private final UpstreamNetworkMonitor mUpstreamNetworkMonitor; private final HashSet<String> mIfacesWantingUpstream; private volatile TetheringConfiguration mConfig; private String mCurrentUpstreamIface; private Notification.Builder mTetheredNotificationBuilder; private int mLastNotificationId; private boolean mRndisEnabled; private boolean mUsbTetherRequested; private boolean mWifiTetherRequested; public Tethering(Context context, INetworkManagementService nmService, INetworkStatsService statsService, INetworkPolicyManager policyManager, Looper looper, MockableSystemProperties systemProperties) { mPublicSync = new Object(); mContext = context; mTetherStates = new ArrayMap<>(); mStateReceiver = new BroadcastReceiver(); mNMService = nmService; mStatsService = statsService; mPolicyManager = policyManager; mLooper = looper; mSystemProperties = systemProperties; mTetherMasterSM = new StateMachine(); mOffloadController = new OffloadController(); mUpstreamNetworkMonitor = new UpstreamNetworkMonitor(); mIfacesWantingUpstream = new HashSet<>(); mConfig = new TetheringConfiguration(); mCurrentUpstreamIface = null; mTetheredNotificationBuilder = new Notification.Builder(); mLastNotificationId = 0; mRndisEnabled = false; mUsbTetherRequested = false; mWifiTetherRequested = false; }

sample: 420
buggy_code:  if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } int which; switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE; break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE; break; default: <|startfocus|> Log.e(TAG, "Unknown interface state: " + state); <|endfocus|> return; } mTetherMasterSM.sendMessage(which, state, 0, who); sendTetherStateChangedBroadcast();
code_review:  Consider Log.wtf since this is a programming error. 
target code: if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } int which; switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE; break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE; break; default: Log.wtf(TAG, "Unknown interface state: " + state); return; } mTetherMasterSM.sendMessage(which, state, 0, who); sendTetherStateChangedBroadcast();
response: if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } int which; switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE; break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE; break; default: Log.wtf(TAG, "Unknown interface state: " + state); return; } mTetherMasterSM.sendMessage(which, state, 0, who); sendTetherStateChangedBroadcast();

sample: 421
buggy_code:  capabilities |= PhoneAccount.CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE; } if (mIsVideoCapable && isCarrierEmergencyVideoCallsAllowed()) { capabilities |= PhoneAccount.CAPABILITY_EMERGENCY_VIDEO_CALLING; } mIsVideoPauseSupported = isCarrierVideoPauseSupported(); Bundle phoneAccountExtras = new Bundle(); if (isCarrierInstantLetteringSupported()) { capabilities |= PhoneAccount.CAPABILITY_CALL_SUBJECT; phoneAccountExtras = getPhoneAccountExtras(phoneAccountExtras); } phoneAccountExtras.putInt(PhoneAccount.EXTRA_SORT_ORDER, slotId); <|startfocus|> mIsMergeCallSupported = isCarrierMergeCallSupported(); <|endfocus|> mIsVideoConferencingSupported = isCarrierVideoConferencingSupported(); mIsMergeOfWifiCallsAllowedWhenVoWifiOff = isCarrierMergeOfWifiCallsAllowedWhenVoWifiOff(); if (isEmergency && mContext.getResources().getBoolean( R.bool.config_emergency_account_emergency_calls_only)) { capabilities |= PhoneAccount.CAPABILITY_EMERGENCY_CALLS_ONLY; } if (icon == null) { // TODO: Switch to using Icon.createWithResource() once that supports tinting. Resources res = mContext.getResources(); Drawable drawable = res.getDrawable(DEFAULT_SIM_ICON, null);
code_review:  Suggest using putString. This doesn't constrain other potential users to mapping to an int. 
target code: capabilities |= PhoneAccount.CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE; } if (mIsVideoCapable && isCarrierEmergencyVideoCallsAllowed()) { capabilities |= PhoneAccount.CAPABILITY_EMERGENCY_VIDEO_CALLING; } mIsVideoPauseSupported = isCarrierVideoPauseSupported(); Bundle phoneAccountExtras = new Bundle(); if (isCarrierInstantLetteringSupported()) { capabilities |= PhoneAccount.CAPABILITY_CALL_SUBJECT; phoneAccountExtras = getPhoneAccountExtras(phoneAccountExtras); } phoneAccountExtras.putInt(PhoneAccount.EXTRA_SORT_ORDER, slotId); mIsMergeCallSupported = isCarrierMergeCallSupported(); mIsMergeImsCallSupported = isCarrierMergeImsCallSupported(); mIsVideoConferencingSupported = isCarrierVideoConferencingSupported(); mIsMergeOfWifiCallsAllowedWhenVoWifiOff = isCarrierMergeOfWifiCallsAllowedWhenVoWifiOff(); if (isEmergency && mContext.getResources().getBoolean( R.bool.config_emergency_account_emergency_calls_only)) { capabilities |= PhoneAccount.CAPABILITY_EMERGENCY_CALLS_ONLY; } if (icon == null) { // TODO: Switch to using Icon.createWithResource() once that supports tinting. Resources res = mContext.getResources(); Drawable drawable = res.getDrawable(DEFAULT_SIM_ICON, null);
response: capabilities |= PhoneAccount.CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE; if (mIsVideoCapable && isCarrierEmergencyVideoCallsAllowed()) { capabilities |= PhoneAccount.CAPABILITY_EMERGENCY_VIDEO_CALLING; } mIsVideoPauseSupported = isCarrierVideoPauseSupported(); Bundle phoneAccountExtras = new Bundle(); if (isCarrierInstantLetteringSupported()) { capabilities |= PhoneAccount.CAPABILITY_CALL_SUBJECT; phoneAccountExtras = getPhoneAccountExtras(phoneAccountExtras); } phoneAccountExtras.putInt(PhoneAccount.EXTRA_SORT_ORDER, slotId); mIsMergeCallSupported = isCarrierMergeCallSupported(); mIsVideoConferencingSupported = isCarrierVideoConferencingSupported(); mIsMergeOfWifiCallsAllowedWhenVoWifiOff = isCarrierMergeOfWifiCallsAllowedWhenVoWifiOff(); if (isEmergency && mContext.getResources().getBoolean(R.bool.config_emergency_account_emergency_calls_only)) { capabilities |= PhoneAccount.CAPABILITY_EMERGENCY_CALLS_ONLY; } if (icon == null) { Resources res = mContext.getResources(); Drawable drawable = res.getDrawable(DEFAULT_SIM_ICON, null); }

sample: 422
buggy_code:  for (Map.Entry<Class<? extends UnitTest>, Integer> entry : allUnitTests.entrySet()) { int testApiVersion = entry.getValue(); // Only add test if test API version is not greater than build API version. if (testApiVersion <= thisApiVersion) { validUnitTests.add(entry.getKey()); } } return validUnitTests; } @Parameter(0) <|startfocus|> public Class<? extends com.android.rs.unit_test.UnitTest> mTestClass; <|endfocus|> @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); Assert.assertTrue(test.getSuccess()); } } 
code_review:  Can this just be "com.android.rs.unit_test.UnitTest"? 
target code: for (Map.Entry<Class<? extends UnitTest>, Integer> entry : allUnitTests.entrySet()) { int testApiVersion = entry.getValue(); // Only add test if test API version is not greater than build API version. if (testApiVersion <= thisApiVersion) { validUnitTests.add(entry.getKey()); } } return validUnitTests; } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); Assert.assertTrue(test.getSuccess()); } }
response: for (Map.Entry<Class<? extends UnitTest>, Integer> entry : allUnitTests.entrySet()) { int testApiVersion = entry.getValue(); // Only add test if test API version is not greater than build API version. if (testApiVersion <= thisApiVersion) { validUnitTests.add(entry.getKey()); } } return validUnitTests; } @Parameter(0) public Class<? extends com.android.rs.unit_test.UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); Assert.assertTrue(test.getSuccess()); }

sample: 423
buggy_code:  private static void allocateReachableObjects(ArrayList<MockClass> reachableObjs) { <|startfocus|> for(int i = 0; i < reachableObjNum; i++) { <|endfocus|> reachableObjs.add(new MockClass(true)); }
code_review:  Nit: space between `for` and `(`. 
target code: private static void allocateReachableObjects(ArrayList<MockClass> reachableObjs) { for (int i = 0; i < reachableObjNum; i++) { reachableObjs.add(new MockClass(true)); }
response: private static void allocateReachableObjects(ArrayList<MockClass> reachableObjs) { for (int i = 0; i < reachableObjNum; i++) { reachableObjs.add(new MockClass(true)); } }

sample: 424
buggy_code:  private static void allocateUnreachableObjects() { <|startfocus|> for(int i = 0; i < unreachableObjNum; i++) { <|endfocus|> new MockClass(false); }
code_review:  Nit: indentation is off. 
target code: private static void allocateUnreachableObjects() { for (int i = 0; i < unreachableObjNum; i++) { new MockClass(false); }
response: private static void allocateUnreachableObjects() { for(int i = 0; i < unreachableObjNum; i++) { new MockClass(false); } }

sample: 425
buggy_code:  private static void allocateUnreachableObjects() { <|startfocus|> for(int i = 0; i < unreachableObjNum; i++) { <|endfocus|> new MockClass(false); }
code_review:  Nit: space between `for` and `(`. 
target code: private static void allocateUnreachableObjects() { for (int i = 0; i < unreachableObjNum; i++) { new MockClass(false); }
response: private static void allocateUnreachableObjects() { for (int i = 0; i < unreachableObjNum; i++) { new MockClass(false); } }

sample: 426
buggy_code:  } if (!mBinaryTestProfilingLibraryPath.isEmpty()) { jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath)); CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH); } <|startfocus|> if (mBinaryTestType.equals(BINARY_TEST_TYPE_HAL_HIDL_GTEST)) { CLog.i("Set flags to stop the framework and native servers for %s", BINARY_TEST_TYPE_HAL_HIDL_GTEST); mBinaryTestStopNativeServers = true; } <|endfocus|> if (mBinaryTestDisableFramework) { jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework); CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK); } if (mBinaryTestStopNativeServers) { jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers); CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS); } if (!mHalHidlReplayTestTracePaths.isEmpty()) { jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
code_review:  perhaps this as well? 
target code: } if (!mBinaryTestProfilingLibraryPath.isEmpty()) { jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath)); CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH); } if (mBinaryTestDisableFramework) { jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework); CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK); } if (mBinaryTestStopNativeServers) { jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers); CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS); } if (!mHalHidlReplayTestTracePaths.isEmpty()) { jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
response: private void checkType(int columnIndex, Type expectedType) { ColumnSchema columnSchema = schema.getColumnByIndex(columnIndex); Type columnType = columnSchema.getType(); if (!columnType.equals(expectedType)) { throw new IllegalArgumentException("Column (name: " + columnSchema.getName() + ", index: " + columnIndex +") is of type " + columnType.getName() + " but was requested as a type " + expectedType.getName()); } } public Integer abs(Integer self) { return Integer.valueOf(Math.abs(self.intValue())); } public Integer floor(Double self) { return Integer.valueOf((int)Math.floor(self.doubleValue())); } public Integer floor(Integer self) { return self; } if (!mBinaryTestProfilingLibraryPath.isEmpty()) { jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath)); CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH); } if (mBinaryTestType.equals(BINARY_TEST_TYPE_HAL_HIDL_GTEST)) { CLog.i("Set flags to stop the framework and native servers for %s", BINARY_TEST_TYPE_HAL_HIDL_GTEST); mBinaryTestStopNativeServers = true; } if (mBinaryTestDisableFramework) { jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework); CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK); } if (mBinaryTestStopNativeServers) { jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers); CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS); } if (!mHalHidlReplayTestTracePaths.isEmpty()) { jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths)); }

sample: 427
buggy_code: import android.util.Log; import java.util.Arrays; import java.util.Objects; /** * Network specifier object used to request a Wi-Fi Aware network. Apps do not create these objects * directly but obtain them using * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} or * {@link DiscoverySession#createNetworkSpecifierOpen(PeerHandle)} or their secure (Passphrase) * versions. * * @hide */ <|startfocus|> public final class WifiAwareNetworkSpecifier extends NetworkSpecifier implements Parcelable, NetworkSpecifier.UidContainer { <|endfocus|> /** * TYPE: in band, specific peer: role, client_id, session_id, peer_id, pmk/passphrase optional * @hide */ public static final int NETWORK_SPECIFIER_TYPE_IB = 0; /** * TYPE: in band, any peer: role, client_id, session_id, pmk/passphrase optional * [only permitted for RESPONDER] * @hide */ public static final int NETWORK_SPECIFIER_TYPE_IB_ANY_PEER = 1; /** * TYPE: out-of-band: role, client_id, peer_mac, pmk/passphrase optional
code_review:  Is this interface really needed ? What does it bring ? Since is it not on the base NetworkSpecifier class, the caller will always have to know the object is of type WifiAwareNetworkSpecifier to be able to see getUid() to see it anyway. 
target code: import android.util.Log; import java.util.Arrays; import java.util.Objects; /** * Network specifier object used to request a Wi-Fi Aware network. Apps do not create these objects * directly but obtain them using * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} or * {@link DiscoverySession#createNetworkSpecifierOpen(PeerHandle)} or their secure (Passphrase) * versions. * * @hide */ public final class WifiAwareNetworkSpecifier extends NetworkSpecifier implements Parcelable { /** * TYPE: in band, specific peer: role, client_id, session_id, peer_id, pmk/passphrase optional * @hide */ public static final int NETWORK_SPECIFIER_TYPE_IB = 0; /** * TYPE: in band, any peer: role, client_id, session_id, pmk/passphrase optional * [only permitted for RESPONDER] * @hide */ public static final int NETWORK_SPECIFIER_TYPE_IB_ANY_PEER = 1; /** * TYPE: out-of-band: role, client_id, peer_mac, pmk/passphrase optional
response: import android.util.Log; import java.util.Arrays; import java.util.Objects; /** * Network specifier object used to request a Wi-Fi Aware network. Apps do not create these objects * directly but obtain them using * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} or * {@link DiscoverySession#createNetworkSpecifierOpen(PeerHandle)} or their secure (Passphrase) * versions. * * @hide */ public final class WifiAwareNetworkSpecifier extends NetworkSpecifier implements Parcelable, NetworkSpecifier.UidContainer { /** * TYPE: in band, specific peer: role, client_id, session_id, peer_id, pmk/passphrase optional * @hide */ public static final int NETWORK_SPECIFIER_TYPE_IB = 0; /** * TYPE: in band, any peer: role, client_id, session_id, pmk/passphrase optional * [only permitted for RESPONDER] * @hide */ public static final int NETWORK_SPECIFIER_TYPE_IB_ANY_PEER = 1; /** * TYPE: out-of-band: role, client_id, peer_mac, pmk/passphrase optional * @hide */ public static final int NETWORK_SPECIFIER_TYPE_OOB = 2; /** * TYPE: out-of-band: role, client_id, pmk/passphrase optional * @hide */ public static final int NETWORK_SPECIFIER_TYPE_OOB_ANY_PEER = 3; /** * TYPE: out-of-band: role, client_id, pmk/passphrase optional * @hide */ public static final int NETWORK_SPECIFIER_TYPE_OOB_ANY_PEER_OOB = 4; private static final String TAG = "WifiAwareNetworkSpecifier"; private final int mType; private final int mRole; private final int mClientId; private final int mSessionId; private final byte[] mPeerMac; private final byte[] mPmk; private final String mPassphrase; private final int mUid; private WifiAwareNetworkSpecifier(int type, int role, int clientId, int sessionId, byte[] peerMac, byte[] pmk, String passphrase, int uid) { mType = type; mRole = role; mClientId = clientId; mSessionId = sessionId; mPeerMac = peerMac;

sample: 428
buggy_code:  mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null); return; } result_items = checkIndexOutofBounds(bdaddr, items, startItem, endItem); /* check for index out of bound errors */ if (result_items == null) { Log.w(TAG, "result_items is null."); mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null); return; } FolderItemsData folderDataNative = new FolderItemsData(result_items.size()); <|startfocus|> /* variables to temperorily add attrs */ <|endfocus|> ArrayList<String> attrArray = new ArrayList<String>(); ArrayList<Integer> attrId = new ArrayList<Integer>(); for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) { // get the queue id long qid = result_items.get(itemIndex).getQueueId(); byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array(); // get the array of uid from 2d to array 1D array for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
code_review:  typo 
target code: mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null); return; } result_items = checkIndexOutofBounds(bdaddr, items, startItem, endItem); /* check for index out of bound errors */ if (result_items == null) { Log.w(TAG, "result_items is null."); mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null); return; } FolderItemsData folderDataNative = new FolderItemsData(result_items.size()); /* variables to accumulate attrs */ ArrayList<String> attrArray = new ArrayList<String>(); ArrayList<Integer> attrId = new ArrayList<Integer>(); for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) { // get the queue id long qid = result_items.get(itemIndex).getQueueId(); byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array(); // get the array of uid from 2d to array 1D array for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
response: mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null); return; } result_items = checkIndexOutOfBounds(bdaddr, items, startItem, endItem); if (result_items == null) { Log.w(TAG, "result_items is null."); mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null); return; } FolderItemsData folderDataNative = new FolderItemsData(result_items.size()); ArrayList<String> attrArray = new ArrayList<String>(); ArrayList<Integer> attrId = new ArrayList<Integer>(); for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) { long qid = result_items.get(itemIndex).getQueueId(); byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array(); for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) { // process uid array } }

sample: 429
buggy_code:  String value = null; int attribId = isAllAttribRequested ? (idx + 1) : folderItemsReqObj.mAttrIDs[idx]; if (attribId >= AvrcpConstants.ATTRID_TITLE && attribId <= AvrcpConstants.ATTRID_PLAY_TIME) { value = getAttrValue(attribId, result_items, itemIndex); if (value != null) { attrArray.add(value); attrId.add(attribId); attrCnt++; } } else { <|startfocus|> Log.w(TAG, "invalid attributed id is requested: " + attribId); <|endfocus|> } } /* add num attr actually received from media player for a particular item */ folderDataNative.mAttributesNum[itemIndex] = attrCnt; } } /* copy filtered attr ids and attr values to response parameters */ if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) { folderDataNative.mAttrIds = new int[attrId.size()]; for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
code_review:  "attribute"? 
target code: String value = null; int attribId = isAllAttribRequested ? (idx + 1) : folderItemsReqObj.mAttrIDs[idx]; if (attribId >= AvrcpConstants.ATTRID_TITLE && attribId <= AvrcpConstants.ATTRID_PLAY_TIME) { value = getAttrValue(attribId, result_items, itemIndex); if (value != null) { attrArray.add(value); attrId.add(attribId); attrCnt++; } } else { Log.w(TAG, "invalid attribute id is requested: " + attribId); } } /* add num attr actually received from media player for a particular item */ folderDataNative.mAttributesNum[itemIndex] = attrCnt; } } /* copy filtered attr ids and attr values to response parameters */ if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) { folderDataNative.mAttrIds = new int[attrId.size()]; for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
response: String value = null; int attribId = isAllAttribRequested ? (idx + 1) : folderItemsReqObj.mAttrIDs[idx]; if (attribId >= AvrcpConstants.ATTRID_TITLE && attribId <= AvrcpConstants.ATTRID_PLAY_TIME) { value = getAttrValue(attribId, result_items, itemIndex); if (value != null) { attrArray.add(value); attrId.add(attribId); attrCnt++; } } else { Log.w(TAG, "invalid attribute id is requested: " + attribId); } } folderDataNative.mAttributesNum[itemIndex] = attrCnt; } } if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) { folderDataNative.mAttrIds = new int[attrId.size()]; for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex); }

sample: 430
buggy_code:  if (oldLp != null && newLp.isIdenticalDnses(oldLp)) { return; // no updating necessary } Collection<InetAddress> dnses = newLp.getDnsServers(); if (DBG) log("Setting DNS servers for network " + netId + " to " + dnses); try { mNetd.setDnsConfigurationForNetwork( netId, NetworkUtils.makeStrings(dnses), newLp.getDomains()); } catch (Exception e) { loge("Exception in setDnsConfigurationForNetwork: " + e); <|startfocus|> } <|endfocus|> flushVmDnsCache();
code_review:  Is it relevant to log the error ? 
target code: if (oldLp != null && newLp.isIdenticalDnses(oldLp)) { return; // no updating necessary } Collection<InetAddress> dnses = newLp.getDnsServers(); if (DBG) log("Setting DNS servers for network " + netId + " to " + dnses); try { mNetd.setDnsConfigurationForNetwork( netId, NetworkUtils.makeStrings(dnses), newLp.getDomains()); } catch (Exception e) { loge("Exception in setDnsConfigurationForNetwork: " + e); } final NetworkAgentInfo defaultNai = getDefaultNetwork(); if (defaultNai != null && defaultNai.network.netId == netId) { setDefaultDnsSystemProperties(dnses); } flushVmDnsCache();
response: if (oldLp != null && newLp.isIdenticalDnses(oldLp)) { return; // no updating necessary } Collection<InetAddress> dnses = newLp.getDnsServers(); if (DBG) { log("Setting DNS servers for network " + netId + " to " + dnses); } try { mNetd.setDnsConfigurationForNetwork(netId, NetworkUtils.makeStrings(dnses), newLp.getDomains()); } catch (Exception e) { loge("Exception in setDnsConfigurationForNetwork: " + e); } flushVmDnsCache();

sample: 431
buggy_code:  /** * The URL used for fallback HTTP captive portal detection when previous HTTP * and HTTPS captive portal detection attemps did not return a conclusive answer. * * @hide */ public static final String CAPTIVE_PORTAL_FALLBACK_URL = "captive_portal_fallback_url"; /** <|startfocus|> * A comma-separated list of URLs used for captive portal detection in addition to the * fallback HTTP url associated with CAPTIVE_PORTAL_FALLBACK_URL. <|endfocus|> * * @hide */ public static final String CAPTIVE_PORTAL_OTHER_FALLBACK_URLS = "captive_portal_other_fallback_urls"; /** * Whether to use HTTPS for network validation. This is enabled by default and the setting * needs to be set to 0 to disable it. This setting is a misnomer because captive portals * don't actually use HTTPS, but it's consistent with the other settings. * * @hide */ public static final String CAPTIVE_PORTAL_USE_HTTPS = "captive_portal_use_https"; /**
code_review:  So this implies there can be no commas within one of these test URLs. That seems fine, but I wonder if there's a separate way to have a String[] variable and push its contents such that there aren't delimiter issues. 
target code: /** * The URL used for fallback HTTP captive portal detection when previous HTTP * and HTTPS captive portal detection attemps did not return a conclusive answer. * * @hide */ public static final String CAPTIVE_PORTAL_FALLBACK_URL = "captive_portal_fallback_url"; /** * A "|" separated list of URLs used for captive portal detection in addition to the * fallback HTTP url associated with the CAPTIVE_PORTAL_FALLBACK_URL settings. * * @hide */ public static final String CAPTIVE_PORTAL_OTHER_FALLBACK_URLS = "captive_portal_other_fallback_urls"; /** * Whether to use HTTPS for network validation. This is enabled by default and the setting * needs to be set to 0 to disable it. This setting is a misnomer because captive portals * don't actually use HTTPS, but it's consistent with the other settings. * * @hide */ public static final String CAPTIVE_PORTAL_USE_HTTPS = "captive_portal_use_https"; /**
response: public static final String CAPTIVE_PORTAL_FALLBACK_URL = "captive_portal_fallback_url"; public static final String CAPTIVE_PORTAL_OTHER_FALLBACK_URLS = "captive_portal_other_fallback_urls"; public static final String CAPTIVE_PORTAL_USE_HTTPS = "captive_portal_use_https";

sample: 432
buggy_code:  private URL[] makeCaptivePortalFallbackUrls(Context context) { <|startfocus|> String firstUrl = getCaptivePortalFallbackUrl(context); <|endfocus|> String joinedUrls = firstUrl + "," + getSetting(context, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS); List<URL> urls = new ArrayList<>(); for (String s : joinedUrls.split(",")) { URL u = makeURL(s); if (u == null) { continue; } urls.add(u); } if (urls.isEmpty()) { Log.e(TAG, String.format("could not create any url from %s", joinedUrls)); } return urls.toArray(new URL[urls.size()]);
code_review:  Does it make sense to keep getCaptivePortalFallbackUrl() at this point? If anything I would expect getCaptivePortalFallbackUrl() to be implemented in terms of getCaptivePortalFallbackUrls() 
target code: private URL[] makeCaptivePortalFallbackUrls(Context context) { String firstUrl = getSetting(context, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, DEFAULT_FALLBACK_URL); String joinedUrls = firstUrl + "," + getSetting(context, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS); List<URL> urls = new ArrayList<>(); for (String s : joinedUrls.split(",")) { URL u = makeURL(s); if (u == null) { continue; } urls.add(u); } if (urls.isEmpty()) { Log.e(TAG, String.format("could not create any url from %s", joinedUrls)); } return urls.toArray(new URL[urls.size()]);
response: private URL[] makeCaptivePortalFallbackUrls(Context context) { String firstUrl = getSetting(context, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, DEFAULT_FALLBACK_URL); String joinedUrls = firstUrl + "," + getSetting(context, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS); List<URL> urls = new ArrayList<>(); for (String s : joinedUrls.split(",")) { URL u = makeURL(s); if (u == null) { continue; } urls.add(u); } if (urls.isEmpty()) { Log.e(TAG, String.format("could not create any url from %s", joinedUrls)); } return urls.toArray(new URL[urls.size()]); }

sample: 433
buggy_code:  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. */ package java.util; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier; <|startfocus|> // Android-changed: removed Value-Based paragraph. <|endfocus|> /** * A container object which may or may not contain a non-null value. * If a value is present, {@code isPresent()} will return {@code true} and * {@code get()} will return the value. * * <p>Additional methods that depend on the presence or absence of a contained * value are provided, such as {@link #orElse(java.lang.Object) orElse()} * (return a default value if value not present) and * {@link #ifPresent(java.util.function.Consumer) ifPresent()} (execute a block
code_review:  nit: The removed paragraph actually used the spellings "ValueBased" (in the link target) and "value-based" (in the link text), so either of those two spellings would have been slightly preferable ("removed paragraph about value-based class semantics"). But this works too. 
target code: * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. */ package java.util; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier; // Android-changed: removed ValueBased paragraph. /** * A container object which may or may not contain a non-null value. * If a value is present, {@code isPresent()} will return {@code true} and * {@code get()} will return the value. * * <p>Additional methods that depend on the presence or absence of a contained * value are provided, such as {@link #orElse(java.lang.Object) orElse()} * (return a default value if value not present) and * {@link #ifPresent(java.util.function.Consumer) ifPresent()} (execute a block
response: import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.CommentRange; import com.google.gerrit.reviewdb.client.Patch; import com.google.gerrit.reviewdb.client.PatchLineComment; import com.google.gerrit.reviewdb.client.PatchSet; import com.google.gerrit.reviewdb.client.RevId; import com.google.gwtorm.client.Column; import java.sql.Timestamp; import java.util.ArrayList; import java.util.List; import javax.annotation.concurrent.Immutable; /** * Holds the raw data of a RevisionNote. * It is intended for (de)serialization to JSON only. */ class RevisionNoteData { static class Identity { int id; Identity(Account.Id id) { this.id = id.get(); } Account.Id export() { return new Account.Id(id); } } static class CommentKey { String uuid; PatchKey patchKey; CommentKey(PatchLineComment.Key k) { uuid = k.get(); patchKey = new PatchKey(k.getParentKey()); } PatchLineComment.Key export() { return new PatchLineComment.Key(patchKey.export(), uuid); } } } // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.api; import com.google.gerrit.extensions.api.changes.Changes; import com.google.gerrit.extensions.api.projects.Projects; import com.google.gerrit.extensions.restapi.NotImplementedException; public interface GerritApi { public Changes changes(); public Projects projects(); /** * A default implementation which allows source compatibility when adding new methods to the interface. */ public class NotImplementedGerritApi implements GerritApi { @Override public Changes changes() { throw new NotImplementedException(); } @Override public Projects projects() { throw new NotImplementedException(); } } } // Android-changed: removed Value-Based paragraph. import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier; /** * A container object which may or may not contain a non-null value. * If a value is present, {@code isPresent()} will return {@code true} and * {@code get()} will return the value. * * <p>

sample: 434
buggy_code:  * supported on this device. * * @param secondaryPhy Secondary advertising physical channel, can only be * one of {@link BluetoothDevice#PHY_LE_1M}, * {@link BluetoothDevice#PHY_LE_2M} or * {@link BluetoothDevice#PHY_LE_CODED}. * @throws IllegalArgumentException If the secondaryPhy is invalid. */ public Builder setSecondaryPhy(int secondaryPhy) { if (secondaryPhy != BluetoothDevice.PHY_LE_1M && <|startfocus|> secondaryPhy !=BluetoothDevice.PHY_LE_2M && <|endfocus|> secondaryPhy != BluetoothDevice.PHY_LE_CODED) { throw new IllegalArgumentException("bad secondaryPhy " + secondaryPhy); } this.secondaryPhy = secondaryPhy; return this; } /** * Set advertising interval. * * @param interval Bluetooth LE Advertising interval, in 0.625ms unit. Valid * range is from 160 (100ms) to 16777215 (10,485.759375 s). * Recommended values are: * {@link AdvertisingSetParameters#INTERVAL_LOW}, * {@link AdvertisingSetParameters#INTERVAL_MEDIUM}, or
code_review:  Missing space 
target code: * supported on this device. * * @param secondaryPhy Secondary advertising physical channel, can only be * one of {@link BluetoothDevice#PHY_LE_1M}, * {@link BluetoothDevice#PHY_LE_2M} or * {@link BluetoothDevice#PHY_LE_CODED}. * @throws IllegalArgumentException If the secondaryPhy is invalid. */ public Builder setSecondaryPhy(int secondaryPhy) { if (secondaryPhy != BluetoothDevice.PHY_LE_1M && secondaryPhy != BluetoothDevice.PHY_LE_2M && secondaryPhy != BluetoothDevice.PHY_LE_CODED) { throw new IllegalArgumentException("bad secondaryPhy " + secondaryPhy); } this.secondaryPhy = secondaryPhy; return this; } /** * Set advertising interval. * * @param interval Bluetooth LE Advertising interval, in 0.625ms unit. Valid * range is from 160 (100ms) to 16777215 (10,485.759375 s). * Recommended values are: * {@link AdvertisingSetParameters#INTERVAL_LOW}, * {@link AdvertisingSetParameters#INTERVAL_MEDIUM}, or
response: public Builder setSecondaryPhy(int secondaryPhy) { if (secondaryPhy != BluetoothDevice.PHY_LE_1M && secondaryPhy != BluetoothDevice.PHY_LE_2M && secondaryPhy != BluetoothDevice.PHY_LE_CODED) { throw new IllegalArgumentException("bad secondaryPhy " + secondaryPhy); } this.secondaryPhy = secondaryPhy; return this; } public Builder setAdvertisingInterval(int interval) { if (interval < AdvertisingSetParameters.INTERVAL_LOW || interval > AdvertisingSetParameters.INTERVAL_HIGH) { throw new IllegalArgumentException("Invalid advertising interval: " + interval); } this.interval = interval; return this; }

sample: 435
buggy_code:  public String getDisplayName(boolean daylightTime, int style, Locale locale) { <|startfocus|> // Android-changed: implement using android.icu.text.TimeZoneNames <|endfocus|> TimeZoneNames.NameType nameType; switch (style) { case SHORT: nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD; break; case LONG: nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD; break; default: throw new IllegalArgumentException("Illegal style: " + style); } long now = System.currentTimeMillis(); String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID()); if (canonicalID != null) { TimeZoneNames names = TimeZoneNames.getInstance(locale); String displayName = names.getDisplayName(canonicalID, nameType, now); if (displayName != null) { return displayName; } } // We get here if this is a custom timezone or ICU doesn't have name data for the specific // style and locale. int offsetMillis = getRawOffset();
code_review:  should be BEGIN Android-changed / END Android-changed per go/libcore-patch-style 
target code: public String getDisplayName(boolean daylightTime, int style, Locale locale) { // BEGIN Android-changed: implement using android.icu.text.TimeZoneNames TimeZoneNames.NameType nameType; switch (style) { case SHORT: nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD; break; case LONG: nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD; break; default: throw new IllegalArgumentException("Illegal style: " + style); } long now = System.currentTimeMillis(); String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID()); if (canonicalID != null) { TimeZoneNames names = TimeZoneNames.getInstance(locale); String displayName = names.getDisplayName(canonicalID, nameType, now); if (displayName != null) { return displayName; } } // We get here if this is a custom timezone or ICU doesn't have name data for the specific // style and locale. int offsetMillis = getRawOffset();
response: private String getDisplayName(boolean daylightTime, int style, Locale locale) { // BEGIN Android-changed: implement using android.icu.text.TimeZoneNames TimeZoneNames.NameType nameType; switch (style) { case SHORT: nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD; break; case LONG: nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD; break; default: throw new IllegalArgumentException("Illegal style: " + style); } long now = System.currentTimeMillis(); String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID()); if (canonicalID != null) { TimeZoneNames names = TimeZoneNames.getInstance(locale); String displayName = names.getDisplayName(canonicalID, nameType, now); if (displayName != null) { return displayName; } } // We get here if this is a custom timezone or ICU doesn't have name data for the specific // style and locale. int offsetMillis = getRawOffset(); // END Android-changed }

sample: 436
buggy_code:  // Android-changed: implement using android.icu.text.TimeZoneNames TimeZoneNames.NameType nameType; switch (style) { case SHORT: nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD; break; case LONG: nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD; break; default: throw new IllegalArgumentException("Illegal style: " + style); } <|startfocus|> long now = System.currentTimeMillis(); <|endfocus|> String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID()); if (canonicalID != null) { TimeZoneNames names = TimeZoneNames.getInstance(locale); String displayName = names.getDisplayName(canonicalID, nameType, now); if (displayName != null) { return displayName; } } // We get here if this is a custom timezone or ICU doesn't have name data for the specific // style and locale. int offsetMillis = getRawOffset(); if (daylightTime) { offsetMillis += getDSTSavings(); }
code_review:  nit: move this to after line 403? (No point in doing this in the case where canonicalID == 0) 
target code: // Android-changed: implement using android.icu.text.TimeZoneNames TimeZoneNames.NameType nameType; switch (style) { case SHORT: nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD; break; case LONG: nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD; break; default: throw new IllegalArgumentException("Illegal style: " + style); } String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID()); if (canonicalID != null) { TimeZoneNames names = TimeZoneNames.getInstance(locale); String displayName = names.getDisplayName(canonicalID, nameType, now); if (displayName != null) { return displayName; } } // We get here if this is a custom timezone or ICU doesn't have name data for the specific // style and locale. int offsetMillis = getRawOffset(); if (daylightTime) { offsetMillis += getDSTSavings(); }
response: private static class TestCase { AccessCheckInput input; String project; int want; TestCase(String mail, String project, String ref, int want) { this.input = new AccessCheckInput(mail, ref); this.project = project; this.want = want; } } @Test public void accessible() throws Exception { List<TestCase> inputs = ImmutableList.of( new TestCase(user.email, normalProject.get(), null, 200), new TestCase(user.email, secretProject.get(), null, 403), new TestCase(user.email, secretRefProject.get(), "refs/heads/secret/master", 403), new TestCase(privilegedUser.email, secretRefProject.get(), "refs/heads/secret/master", 200), new TestCase(privilegedUser.email, normalProject.get(), null, 200), new TestCase(privilegedUser.email, secretProject.get(), null, 200) ); for (TestCase tc : inputs) { String in = newGson().toJson(tc.input); AccessCheckInfo info = null; try { // Perform access check } catch (Exception e) { // Handle exception } } } ReviewInput in = new ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Not-A-Label", 5); exception.expect(BadRequestException.class); exception.expectMessage("label \"Not-A-Label\" is not a configured label"); revision.review(in); @Test public void voteOnBehalfOfInvalidLabelIgnoredWithoutStrictLabels() throws Exception { allowCodeReviewOnBehalfOf(); PushOneCommit.Result r = createChange(); RevisionApi revision = gApi.changes().id(r.getChangeId()).current(); ReviewInput in = new ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Code-Review", 1); in.label("Not-A-Label", 5); revision.review(in); assertThat(gApi.changes().id(r.getChangeId()).get().labels).doesNotContainKey("Not-A-Label"); } @Test public void voteOnBehalfOfLabelNotPermitted() throws Exception { ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); LabelType verified = Util.verified(); // Perform test } private static boolean isCorrelated(SelectStmt subqueryStmt) { if

sample: 437
buggy_code:  boolean isRingerAudible = isVolumeOverZero && shouldRingForContact && isRingtonePresent; // Acquire audio focus under any of the following conditions: // 1. Should ring for contact and there's an HFP device attached // 2. Volume is over zero, we should ring for the contact, and there's a audible ringtone // present. boolean shouldAcquireAudioFocus = <|startfocus|> (isVolumeOverZero && shouldRingForContact && isRingtonePresent) || (isHfpDeviceAttached && shouldRingForContact); <|endfocus|> // Don't do call waiting operations or vibration unless these are false. boolean isTheaterModeOn = mSystemSettingsUtil.isTheaterModeOn(mContext); boolean letDialerHandleRinging = mInCallController.doesConnectedDialerSupportRinging(); boolean endEarly = isTheaterModeOn || letDialerHandleRinging; if (endEarly) { if (letDialerHandleRinging) { Log.addEvent(foregroundCall, LogUtils.Events.SKIP_RINGING); } return shouldAcquireAudioFocus;
code_review:  IsRingerAudible? 
target code: boolean isRingerAudible = isVolumeOverZero && shouldRingForContact && isRingtonePresent; // Acquire audio focus under any of the following conditions: // 1. Should ring for contact and there's an HFP device attached // 2. Volume is over zero, we should ring for the contact, and there's a audible ringtone // present. boolean shouldAcquireAudioFocus = isRingerAudible || (isHfpDeviceAttached && shouldRingForContact) || isSelfManaged; // Don't do call waiting operations or vibration unless these are false. boolean isTheaterModeOn = mSystemSettingsUtil.isTheaterModeOn(mContext); boolean letDialerHandleRinging = mInCallController.doesConnectedDialerSupportRinging(); boolean endEarly = isTheaterModeOn || letDialerHandleRinging; if (endEarly) { if (letDialerHandleRinging) { Log.addEvent(foregroundCall, LogUtils.Events.SKIP_RINGING); } return shouldAcquireAudioFocus;
response: boolean isRingerAudible = isVolumeOverZero && shouldRingForContact && isRingtonePresent; boolean shouldAcquireAudioFocus = (isVolumeOverZero && shouldRingForContact && isRingtonePresent) || (isHfpDeviceAttached && shouldRingForContact); boolean isTheaterModeOn = mSystemSettingsUtil.isTheaterModeOn(mContext); boolean letDialerHandleRinging = mInCallController.doesConnectedDialerSupportRinging(); boolean endEarly = isTheaterModeOn || letDialerHandleRinging; if (endEarly) { if (letDialerHandleRinging) { Log.addEvent(foregroundCall, LogUtils.Events.SKIP_RINGING); } return shouldAcquireAudioFocus; }

sample: 438
buggy_code:  Log.addEvent(foregroundCall, LogUtils.Events.START_RINGER); // Because we wait until a contact info query to complete before processing a // call (for the purposes of direct-to-voicemail), the information about custom // ringtones should be available by the time this code executes. We can safely // request the custom ringtone from the call and expect it to be current. mRingtonePlayer.play(mRingtoneFactory, foregroundCall); } else { <|startfocus|> Log.i(this, "startRinging: skipping because ringer would not be audible."); <|endfocus|> } if (shouldVibrate(mContext, foregroundCall) && !mIsVibrating && shouldRingForContact) { mVibratingCall = foregroundCall; mVibrator.vibrate(VIBRATION_PATTERN, VIBRATION_PATTERN_REPEAT, VIBRATION_ATTRIBUTES); mIsVibrating = true; } else if (mIsVibrating) { Log.addEvent(foregroundCall, LogUtils.Events.SKIP_VIBRATION, "already vibrating"); } return shouldAcquireAudioFocus;
code_review:  Would it help for debugging to list isVolumeOverZero, shouldRingForContact, and isRingtonePresent? 
target code: Log.addEvent(foregroundCall, LogUtils.Events.START_RINGER); // Because we wait until a contact info query to complete before processing a // call (for the purposes of direct-to-voicemail), the information about custom // ringtones should be available by the time this code executes. We can safely // request the custom ringtone from the call and expect it to be current. mRingtonePlayer.play(mRingtoneFactory, foregroundCall); } else { Log.i(this, "startRinging: skipping because ringer would not be audible. " + "isVolumeOverZero=%s, shouldRingForContact=%s, isRingtonePresent=%s", isVolumeOverZero, shouldRingForContact, isRingtonePresent); } if (shouldVibrate(mContext, foregroundCall) && !mIsVibrating && shouldRingForContact) { mVibratingCall = foregroundCall; mVibrator.vibrate(VIBRATION_PATTERN, VIBRATION_PATTERN_REPEAT, VIBRATION_ATTRIBUTES); mIsVibrating = true; } else if (mIsVibrating) { Log.addEvent(foregroundCall, LogUtils.Events.SKIP_VIBRATION, "already vibrating"); } return shouldAcquireAudioFocus;
response: Log.addEvent(foregroundCall, LogUtils.Events.START_RINGER); if (isVolumeOverZero && shouldRingForContact && isRingtonePresent) { mRingtonePlayer.play(mRingtoneFactory, foregroundCall); } else { Log.i(this, "startRinging: skipping because ringer would not be audible."); } if (shouldVibrate(mContext, foregroundCall) && !mIsVibrating && shouldRingForContact) { mVibratingCall = foregroundCall; mVibrator.vibrate(VIBRATION_PATTERN, VIBRATION_PATTERN_REPEAT, VIBRATION_ATTRIBUTES); mIsVibrating = true; } else if (mIsVibrating) { Log.addEvent(foregroundCall, LogUtils.Events.SKIP_VIBRATION, "already vibrating"); } return shouldAcquireAudioFocus;

sample: 439
buggy_code:  private URL nextFallbackUrl() { if (mCaptivePortalFallbackUrls.length == 0) { return null; } <|startfocus|> int idx = Math.abs(mNextFallbackUrl) % mCaptivePortalFallbackUrls.length; mNextFallbackUrl += new Random().nextInt(); // randomely change url without memory. <|endfocus|> return mCaptivePortalFallbackUrls[idx];
code_review:  This has a slightly funky name. It's more like mNextFallbackUrlSeed or something. I'm not good at naming. 
target code: private URL nextFallbackUrl() { if (mCaptivePortalFallbackUrls.length == 0) { return null; } int idx = Math.abs(mNextFallbackUrlIndex) % mCaptivePortalFallbackUrls.length; mNextFallbackUrlIndex += new Random().nextInt(); // randomely change url without memory. return mCaptivePortalFallbackUrls[idx];
response: private URL nextFallbackUrl() { if (mCaptivePortalFallbackUrls.length == 0) { return null; } int seed = Math.abs(mNextFallbackUrl) % mCaptivePortalFallbackUrls.length; mNextFallbackUrl += new Random().nextInt(); // randomly change seed without memory. return mCaptivePortalFallbackUrls[seed]; }

sample: 440
buggy_code:  when(mFakeCallsManager.hasOngoingCalls()).thenReturn(true); assertTrue(mTSIBinder.isInCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testNotIsInCall() throws Exception { when(mFakeCallsManager.hasOngoingCalls()).thenReturn(false); assertFalse(mTSIBinder.isInCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testIsInCallFail() throws Exception { doThrow(new SecurityException()).when(mContext).enforceCallingOrSelfPermission( anyString(), any()); try { <|startfocus|> mTSIBinder.isInCall("blah"); <|endfocus|> } catch (SecurityException e) { // desired result } verify(mFakeCallsManager, never()).hasOngoingCalls(); } @SmallTest public void testIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(true); assertTrue(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testNotIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(false); assertFalse(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest
code_review:  Also put a fail() line after isInCall to make sure that it throws the exception 
target code: when(mFakeCallsManager.hasOngoingCalls()).thenReturn(true); assertTrue(mTSIBinder.isInCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testNotIsInCall() throws Exception { when(mFakeCallsManager.hasOngoingCalls()).thenReturn(false); assertFalse(mTSIBinder.isInCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testIsInCallFail() throws Exception { doThrow(new SecurityException()).when(mContext).enforceCallingOrSelfPermission( anyString(), any()); try { mTSIBinder.isInCall("blah"); fail(); } catch (SecurityException e) { // desired result } verify(mFakeCallsManager, never()).hasOngoingCalls(); } @SmallTest public void testIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(true); assertTrue(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testNotIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(false); assertFalse(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest
response: private void testIsInCallFail() throws Exception { doThrow(new SecurityException()).when(mContext).enforceCallingOrSelfPermission(anyString(), any()); try { mTSIBinder.isInCall("blah"); fail("Should throw SecurityException"); } catch (SecurityException expected) { // desired result } verify(mFakeCallsManager, never()).hasOngoingCalls(); }

sample: 441
buggy_code:  assertTrue(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testNotIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(false); assertFalse(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testIsInManagedCallFail() throws Exception { doThrow(new SecurityException()).when(mContext).enforceCallingOrSelfPermission( anyString(), any()); try { <|startfocus|> mTSIBinder.isInManagedCall("blah"); <|endfocus|> } catch (SecurityException e) { // desired result } verify(mFakeCallsManager, never()).hasOngoingCalls(); } /** * Register phone accounts for the supplied PhoneAccountHandles to make them * visible to all users (via the isVisibleToCaller method in TelecomServiceImpl. * @param handles the handles for which phone accounts should be created for. */ private void makeAccountsVisibleToAllUsers(PhoneAccountHandle... handles) { for (PhoneAccountHandle ph : handles) { when(mFakePhoneAccountRegistrar.getPhoneAccountUnchecked(eq(ph))).thenReturn(
code_review:  Same as above 
target code: assertTrue(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testNotIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(false); assertFalse(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testIsInManagedCallFail() throws Exception { doThrow(new SecurityException()).when(mContext).enforceCallingOrSelfPermission( anyString(), any()); try { mTSIBinder.isInManagedCall("blah"); fail(); } catch (SecurityException e) { // desired result } verify(mFakeCallsManager, never()).hasOngoingCalls(); } /** * Register phone accounts for the supplied PhoneAccountHandles to make them * visible to all users (via the isVisibleToCaller method in TelecomServiceImpl. * @param handles the handles for which phone accounts should be created for. */ private void makeAccountsVisibleToAllUsers(PhoneAccountHandle... handles) { for (PhoneAccountHandle ph : handles) { when(mFakePhoneAccountRegistrar.getPhoneAccountUnchecked(eq(ph))).thenReturn(
response: mGotCountryCode = false; pollStateDone(); break; default: pollingContext[0]++; cm.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR_CDMA, pollingContext)); pollingContext[0]++; cm.getRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION_CDMA, pollingContext)); pollingContext[0]++; cm.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE_CDMA, pollingContext)); break; } private static String networkTypeToString(int type) { String ret = "unknown"; switch (type) { case DATA_ACCESS_CDMA_IS95A: case DATA_ACCESS_CDMA_IS95B: case DATA_ACCESS_CDMA_1xRTT: ret = "CDMA"; break; case DATA_ACCESS_CDMA_EvDo_0: ret = "EVDO_0"; break; } mIncomingSco = createScoSocket(); mIncomingSco.accept(); break; case SCO_CONNECTED: if (msg.arg1 == ScoSocket.STATE_CONNECTED && isHeadsetConnected() && mConnectedSco == null) { if (VDBG) log("Routing audio for outgoing SCO conection"); mConnectedSco = (ScoSocket)msg.obj; mAudioManager.setBluetoothScoOn(true); if (isCellularCallInProgress()) { broadcastAudioStateIntent(BluetoothHeadset.AUDIO_STATE_CONNECTED, mHeadset.getRemoteDevice()); } else if ((mHFScoState == HF_STATE_SCO_VIRTUALCALL_SETUP) || (mHFScoState == HF_STATE_SCO_VIRTUALCALL_TRANSFERRED)) { mHFScoState = HF_STATE_SCO_VIRTUALCALL_ACTIVE; broadcastVirtualCallStateIntent(BluetoothHeadset.VIRTUALCALL_STATE_CONNECTED); } if (DBG) log("mHandler: Updated mHFScoState:"+ mHFScoState); } else if (msg.arg1 == ScoSocket.STATE_CONNECTED) { assertTrue(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); @SmallTest public void testNotIsInManagedCall() throws Exception { when(mFakeCallsManager.hasOngoingManagedCalls()).thenReturn(false); assertFalse(mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE)); } @SmallTest public void testIsInManagedCallFail() throws Exception { doThrow(new SecurityException()).when(mContext).enforceCallingOrSelfPermission(anyString(), any()); try { mTSIBinder.isInManagedCall("blah"); } catch (SecurityException e

sample: 442
buggy_code:  for (int i = 0; i <= 255; ++i) { s.setTrafficClass(i); // b/30909505 // Linux does not set ECN bits for IP_TOS, but sets for IPV6_TCLASS. We should // accept either output. int actual = s.getTrafficClass(); assertTrue(i == actual || // IPV6_TCLASS <|startfocus|> (((i & ~INET_ECN_MASK) == (actual & ~INET_ECN_MASK)) && ((actual & INET_ECN_MASK) == 0))); // IP_TOS <|endfocus|> } } } public void testReadAfterClose() throws Exception { MockServer server = new MockServer(); server.enqueue(new byte[]{5, 3}, 0); Socket socket = new Socket("localhost", server.port); InputStream in = socket.getInputStream(); assertEquals(5, in.read()); assertEquals(3, in.read()); assertEquals(-1, in.read()); assertEquals(-1, in.read()); socket.close(); in.close(); /* * Rather astonishingly, read() doesn't throw even though the stream is
code_review:  How about the following (seems simpler / more readable): (actual == i) // IPV6_TCLASS || (actual == (i & ~INET_ECN_MASK)); // IP_TOS: ECN bits should be 0 Also, it'd be nice include a the expected / observed values in the failure message. 
target code: for (int i = 0; i <= 255; ++i) { s.setTrafficClass(i); // b/30909505 // Linux does not set ECN bits for IP_TOS, but sets for IPV6_TCLASS. We should // accept either output. int actual = s.getTrafficClass(); assertTrue(i == actual || // IPV6_TCLASS (actual == (i & ~INET_ECN_MASK)); // IP_TOS: ECN bits should be 0 } } } public void testReadAfterClose() throws Exception { MockServer server = new MockServer(); server.enqueue(new byte[]{5, 3}, 0); Socket socket = new Socket("localhost", server.port); InputStream in = socket.getInputStream(); assertEquals(5, in.read()); assertEquals(3, in.read()); assertEquals(-1, in.read()); assertEquals(-1, in.read()); socket.close(); in.close(); /* * Rather astonishingly, read() doesn't throw even though the stream is
response: public void test_SystemProperties() { Properties originalProperties = System.getProperties(); try { Properties testProperties = new Properties(); testProperties.put("testIncInt", "notInt"); System.setProperties(testProperties); assertNull("returned incorrect default Integer", Integer.getInteger("testIncInt")); assertEquals(new Integer(4), Integer.getInteger("testIncInt", 4)); assertEquals(new Integer(4), Integer.getInteger("testIncInt", new Integer(4))); } finally { System.setProperties(originalProperties); } } for (int i = 0; i <= 255; ++i) { s.setTrafficClass(i); int actual = s.getTrafficClass(); assertTrue(actual == i || (((i & ~INET_ECN_MASK) == (actual & ~INET_ECN_MASK)) && ((actual & INET_ECN_MASK) == 0))); } public void testReadAfterClose() throws Exception { MockServer server = new MockServer(); server.enqueue(new byte[]{5, 3}, 0); Socket socket = new Socket("localhost", server.port); InputStream in = socket.getInputStream(); assertEquals(5, in.read()); assertEquals(3, in.read()); assertEquals(-1, in.read()); assertEquals(-1, in.read()); socket.close(); in.close(); }

sample: 443
buggy_code:  } } } } private void connectToAddress(InetAddress address, int port, int timeout) throws IOException { if (address.isAnyLocalAddress()) { doConnect(InetAddress.getLocalHost(), port, timeout); } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } <|startfocus|> // Android-removed: alternative implementation <|endfocus|> /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT:
code_review:  how about: implement setOption() on top of setSocketOption() which is more informative when only extracting this comment without having the source code (I'm generating an overview of change descriptions of all of the changes we have). Perhaps you can also say *why* we have the different implementation? 
target code: } } } } private void connectToAddress(InetAddress address, int port, int timeout) throws IOException { if (address.isAnyLocalAddress()) { doConnect(InetAddress.getLocalHost(), port, timeout); } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: Logic dealing with value type moved to socketSetOption. /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT:
response: } } } } private void connectToAddress(InetAddress address, int port, int timeout) throws IOException { if (address.isAnyLocalAddress()) { doConnect(InetAddress.getLocalHost(), port, timeout); } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: */ }

sample: 444
buggy_code:  if (address.isAnyLocalAddress()) { doConnect(InetAddress.getLocalHost(), port, timeout); } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { <|startfocus|> // check type safety b4 going native. These should never <|endfocus|> * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT");
code_review:  keep /* 
target code: if (address.isAnyLocalAddress()) { doConnect(InetAddress.getLocalHost(), port, timeout); } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { /* check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT");
response: if (address.isAnyLocalAddress()) { doConnect(InetAddress.getLocalHost(), port, timeout); } else { doConnect(address, port, timeout); } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } boolean on = true; switch (opt) { case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) { throw new SocketException("Bad parameter for option"); } if (val instanceof Boolean) { on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) { throw new SocketException("Bad parameter for SO_TIMEOUT"); } break; default: throw new SocketException("Unrecognized socket option"); } // Set the socket option try { socket.setOption(opt, val); } catch (SocketException e) { throw new SocketException("Error setting socket option: " + e.getMessage()); } }

sample: 445
buggy_code:  } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). <|startfocus|> // <|endfocus|> case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT"); int tmp = ((Integer) val).intValue(); if (tmp < 0) throw new IllegalArgumentException("timeout < 0");
code_review:  should be * 
target code: } else { doConnect(address, port, timeout); } } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). * case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT"); int tmp = ((Integer) val).intValue(); if (tmp < 0) throw new IllegalArgumentException("timeout < 0");
response: } else { doConnect(address, port, timeout); } public void setOption(int opt, Object val) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // <|startfocus|> // <|endfocus|> case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) { throw new SocketException("Bad parameter for option"); } if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) { throw new SocketException("Bad parameter for SO_TIMEOUT"); } int tmp = ((Integer) val).intValue(); if (tmp < 0) { throw new IllegalArgumentException("timeout < 0"); } // <|startfocus|> // <|endfocus|> break; default: throw new SocketException("Option not supported"); } // <|startfocus|> // <|endfocus|> }

sample: 446
buggy_code:  } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { <|startfocus|> // true only if disabling - enabling should be Integer <|endfocus|> on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT"); int tmp = ((Integer) val).intValue(); if (tmp < 0) throw new IllegalArgumentException("timeout < 0"); timeout = tmp; break; case IP_TOS: if (val == null || !(val instanceof Integer)) { throw new SocketException("bad argument for IP_TOS"); }
code_review:  Suggest /* true if disabling - enabling should be Integer * but I'm ambivalent in this case 
target code: } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { /* true only if disabling - enabling should be Integer * on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT"); int tmp = ((Integer) val).intValue(); if (tmp < 0) throw new IllegalArgumentException("timeout < 0"); timeout = tmp; break; case IP_TOS: if (val == null || !(val instanceof Integer)) { throw new SocketException("bad argument for IP_TOS"); }
response: } // Android-removed: alternative implementation /* boolean on = true; switch (opt) { // check type safety b4 going native. These should never * fail, since only java.Socket* has access to * PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) throw new SocketException("Bad parameter for option"); if (val instanceof Boolean) { // true only if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) throw new SocketException("Bad parameter for SO_TIMEOUT"); int tmp = ((Integer) val).intValue(); if (tmp < 0) throw new IllegalArgumentException("timeout < 0"); timeout = tmp; break; case IP_TOS: if (val == null || !(val instanceof Integer)) { throw new SocketException("bad argument for IP_TOS"); } */ boolean on = true; switch (opt) { // check type safety b4 going native. These should never fail, since only java.Socket* has access to PlainSocketImpl.setOption(). // case SO_LINGER: if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean))) { throw new SocketException("Bad parameter for option"); } if (val instanceof Boolean) { // true if disabling - enabling should be Integer on = false; } break; case SO_TIMEOUT: if (val == null || (!(val instanceof Integer))) { throw new SocketException("Bad parameter for SO_TIMEOUT"); } int tmp = ((Integer) val).intValue(); if (tmp < 0) { throw new IllegalArgumentException("timeout < 0"); } timeout = tmp; break; case IP_TOS: if (val == null || !(val instanceof Integer)) { throw new SocketException("bad argument for IP_TOS"); } }

sample: 447
buggy_code:  break; default: throw new SocketException("unrecognized TCP option: " + opt); } socketSetOption(opt, on, val); */ if (opt == SO_TIMEOUT) { timeout = (Integer) val; } socketSetOption(opt, val); } public Object getOption(int opt) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } if (opt == SO_TIMEOUT) { return new Integer(timeout); } <|startfocus|> // Android-removed: alternative implementation <|endfocus|> /* int ret = 0; // * The native socketGetOption() knows about 3 options. * The 32 bit value it returns will be interpreted according * to what we're asking. A return of -1 means it understands * the option but its turned off. It will raise a SocketException * if "opt" isn't one it understands. // switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE:
code_review:  same here. Please make your change summaries as informative as possible for someone who only reads that summary without seeing the code change. 
target code: break; default: throw new SocketException("unrecognized TCP option: " + opt); } socketSetOption(opt, on, val); */ if (opt == SO_TIMEOUT) { timeout = (Integer) val; } socketSetOption(opt, val); } public Object getOption(int opt) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } if (opt == SO_TIMEOUT) { return new Integer(timeout); } // Android-removed: Logic dealing with value type moved to socketGetOption. /* int ret = 0; // * The native socketGetOption() knows about 3 options. * The 32 bit value it returns will be interpreted according * to what we're asking. A return of -1 means it understands * the option but its turned off. It will raise a SocketException * if "opt" isn't one it understands. // switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE:
response: Refactored Code: ```java break; default: throw new SocketException("unrecognized TCP option: " + opt); } socketSetOption(opt, on, val); if (opt == SO_TIMEOUT) { timeout = (Integer) val; } socketSetOption(opt, val); public Object getOption(int opt) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } if (opt == SO_TIMEOUT) { return new Integer(timeout); } // Android-removed: alternative implementation /* int ret = 0; // The native socketGetOption() knows about 3 options. // The 32 bit value it returns will be interpreted according // to what we're asking. A return of -1 means it understands // the option but its turned off. It will raise a SocketException // if "opt" isn't one it understands. switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE: ... } */ } ``` Summary of Changes: - Removed the commented out code block that was marked as "Android-removed: alternative implementation".

sample: 448
buggy_code:  throw new SocketException("unrecognized TCP option: " + opt); } socketSetOption(opt, on, val); */ if (opt == SO_TIMEOUT) { timeout = (Integer) val; } socketSetOption(opt, val); } public Object getOption(int opt) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } if (opt == SO_TIMEOUT) { return new Integer(timeout); } // Android-removed: alternative implementation /* int ret = 0; <|startfocus|> // <|endfocus|> * The native socketGetOption() knows about 3 options. * The 32 bit value it returns will be interpreted according * to what we're asking. A return of -1 means it understands * the option but its turned off. It will raise a SocketException * if "opt" isn't one it understands. // switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE:
code_review:  Leave this line unchanged "/*", per style guide 
target code: throw new SocketException("unrecognized TCP option: " + opt); } socketSetOption(opt, on, val); */ if (opt == SO_TIMEOUT) { timeout = (Integer) val; } socketSetOption(opt, val); } public Object getOption(int opt) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } if (opt == SO_TIMEOUT) { return new Integer(timeout); } // Android-removed: alternative implementation /* int ret = 0; /* * The native socketGetOption() knows about 3 options. * The 32 bit value it returns will be interpreted according * to what we're asking. A return of -1 means it understands * the option but its turned off. It will raise a SocketException * if "opt" isn't one it understands. // switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE:
response: throw new SocketException("unrecognized TCP option: " + opt); } socketSetOption(opt, on, val); if (opt == SO_TIMEOUT) { timeout = (Integer) val; } socketSetOption(opt, val); } public Object getOption(int opt) throws SocketException { if (isClosedOrPending()) { throw new SocketException("Socket Closed"); } if (opt == SO_TIMEOUT) { return new Integer(timeout); } int ret = 0; switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE:

sample: 449
buggy_code:  } if (opt == SO_TIMEOUT) { return new Integer(timeout); } // Android-removed: alternative implementation /* int ret = 0; // * The native socketGetOption() knows about 3 options. * The 32 bit value it returns will be interpreted according * to what we're asking. A return of -1 means it understands * the option but its turned off. It will raise a SocketException * if "opt" isn't one it understands. <|startfocus|> // <|endfocus|> switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_LINGER: ret = socketGetOption(opt, null); return (ret == -1) ? Boolean.FALSE: (Object)(new Integer(ret)); case SO_REUSEADDR: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_BINDADDR: InetAddressContainer in = new InetAddressContainer();
code_review:  Per style guide, this should just be "*" rather than "*/" or "//". 
target code: } if (opt == SO_TIMEOUT) { return new Integer(timeout); } // Android-removed: alternative implementation /* int ret = 0; // * The native socketGetOption() knows about 3 options. * The 32 bit value it returns will be interpreted according * to what we're asking. A return of -1 means it understands * the option but its turned off. It will raise a SocketException * if "opt" isn't one it understands. * switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_LINGER: ret = socketGetOption(opt, null); return (ret == -1) ? Boolean.FALSE: (Object)(new Integer(ret)); case SO_REUSEADDR: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_BINDADDR: InetAddressContainer in = new InetAddressContainer();
response: } if (opt == SO_TIMEOUT) { return new Integer(timeout); } int ret = 0; switch (opt) { case TCP_NODELAY: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_OOBINLINE: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_LINGER: ret = socketGetOption(opt, null); return (ret == -1) ? Boolean.FALSE : (Object)(new Integer(ret)); case SO_REUSEADDR: ret = socketGetOption(opt, null); return Boolean.valueOf(ret != -1); case SO_BINDADDR: InetAddressContainer in = new InetAddressContainer(); // ... break; default: throw new SocketException("Unknown socket option: " + opt); }

sample: 450
buggy_code:  } abstract void socketCreate(boolean isServer) throws IOException; abstract void socketConnect(InetAddress address, int port, int timeout) throws IOException; abstract void socketBind(InetAddress address, int port) throws IOException; abstract void socketListen(int count) throws IOException; abstract void socketAccept(SocketImpl s) throws IOException; abstract int socketAvailable() throws IOException; abstract void socketClose0(boolean useDeferredClose) throws IOException; abstract void socketShutdown(int howto) throws IOException; <|startfocus|> // Android-changed: Method signature changed. <|endfocus|> abstract void socketSetOption(int cmd, Object value) throws SocketException; abstract Object socketGetOption(int opt) throws SocketException; abstract void socketSendUrgentData(int data) throws IOException; public final static int SHUT_RD = 0; public final static int SHUT_WR = 1; } 
code_review:  Should be informative to someone who doesn't see the code change. How about: // Android-changed: socket{Get,Set}Option work directly with Object values 
target code: } abstract void socketCreate(boolean isServer) throws IOException; abstract void socketConnect(InetAddress address, int port, int timeout) throws IOException; abstract void socketBind(InetAddress address, int port) throws IOException; abstract void socketListen(int count) throws IOException; abstract void socketAccept(SocketImpl s) throws IOException; abstract int socketAvailable() throws IOException; abstract void socketClose0(boolean useDeferredClose) throws IOException; abstract void socketShutdown(int howto) throws IOException; // Android-changed: Method signature changed, socket{Get,Set}Option work directly with Object // values. abstract void socketSetOption(int cmd, Object value) throws SocketException; abstract Object socketGetOption(int opt) throws SocketException; abstract void socketSendUrgentData(int data) throws IOException; public final static int SHUT_RD = 0; public final static int SHUT_WR = 1; }
response: abstract void socketCreate(boolean isServer) throws IOException; abstract void socketConnect(InetAddress address, int port, int timeout) throws IOException; abstract void socketBind(InetAddress address, int port) throws IOException; abstract void socketListen(int count) throws IOException; abstract void socketAccept(SocketImpl s) throws IOException; abstract int socketAvailable() throws IOException; abstract void socketClose0(boolean useDeferredClose) throws IOException; abstract void socketShutdown(int howto) throws IOException; // Android-changed: Method signature changed. abstract void socketSetOption(int cmd, Object value) throws SocketException; abstract Object socketGetOption(int opt) throws SocketException; abstract void socketSendUrgentData(int data) throws IOException; public final static int SHUT_RD = 0; public final static int SHUT_WR = 1; }

sample: 451
buggy_code:  public static void main(String[] args) { <|startfocus|> System.out.println("" + test()); <|endfocus|>
code_review:  Maybe explain this concatenation? 
target code: public static void main(String[] args) { System.out.println(test());
response: public static void main(String[] args) { System.out.println(test()); }

sample: 452
buggy_code:  * @see #checkAccess() * @see #getThreadGroup() * @see #MAX_PRIORITY * @see #MIN_PRIORITY * @see ThreadGroup#getMaxPriority() */ public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) { // Android-changed: Improve exception message when the new priority // is out of bounds. <|startfocus|> throw new IllegalArgumentException("Priority out of range: " + priority); <|endfocus|> } if((g = getThreadGroup()) != null) { if (newPriority > g.getMaxPriority()) { newPriority = g.getMaxPriority(); } synchronized(this) { this.priority = newPriority; if (isAlive()) { nativeSetPriority(newPriority); } } } } /** * Returns this thread's priority. * * @return this thread's priority. * @see #setPriority */ public final int getPriority() { return priority; } /**
code_review:  newPriority? 
target code: * @see #checkAccess() * @see #getThreadGroup() * @see #MAX_PRIORITY * @see #MIN_PRIORITY * @see ThreadGroup#getMaxPriority() */ public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) { // Android-changed: Improve exception message when the new priority // is out of bounds. throw new IllegalArgumentException("Priority out of range: " + newPriority); } if((g = getThreadGroup()) != null) { if (newPriority > g.getMaxPriority()) { newPriority = g.getMaxPriority(); } synchronized(this) { this.priority = newPriority; if (isAlive()) { nativeSetPriority(newPriority); } } } } /** * Returns this thread's priority. * * @return this thread's priority. * @see #setPriority */ public final int getPriority() { return priority; } /**
response: public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) { throw new IllegalArgumentException("Priority out of range: " + newPriority); } if ((g = getThreadGroup()) != null) { if (newPriority > g.getMaxPriority()) { newPriority = g.getMaxPriority(); } synchronized (this) { this.priority = newPriority; if (isAlive()) { nativeSetPriority(newPriority); } } } } public final int getPriority() { return priority; }

sample: 453
buggy_code:  private static void DisableReporting() { <|startfocus|> if (DoDisableReporting == null) { <|endfocus|> return; } try { DoDisableReporting.invoke(null); } catch (Exception e) { throw new Error("Unable to disable reporting!"); }
code_review:  Field names should start lower-case. 
target code: private static void DisableReporting() { if (doDisableReporting == null) { return; } try { DoDisableReporting.invoke(null); } catch (Exception e) { throw new Error("Unable to disable reporting!"); }
response: private static void disableReporting() { if (doDisableReporting == null) { return; } try { doDisableReporting.invoke(null); } catch (Exception e) { throw new Error("Unable to disable reporting!"); } }

sample: 454
buggy_code:  private static void ensureTestWatcherInitialized() { try { // Make sure the TestWatcher class can be found from the Object <init> function. addToBootClassLoader(LISTENER_LOCATION); // Load TestWatcher from the bootclassloader and make sure it is initialized. Class<?> testwatcher_class = Class.forName("art.test.TestWatcher", true, null); <|startfocus|> // Bind the native functions of testwatcher_class. DoEnableReporting = testwatcher_class.getDeclaredMethod("EnableReporting"); DoDisableReporting = testwatcher_class.getDeclaredMethod("DisableReporting"); <|endfocus|> } catch (Exception e) { throw new Error("Exception while making testwatcher", e); }
code_review:  Stale? 
target code: private static void ensureTestWatcherInitialized() { try { // Make sure the TestWatcher class can be found from the Object <init> function. addToBootClassLoader(LISTENER_LOCATION); // Load TestWatcher from the bootclassloader and make sure it is initialized. Class<?> testwatcher_class = Class.forName("art.test.TestWatcher", true, null); doEnableReporting = testwatcher_class.getDeclaredMethod("EnableReporting"); doDisableReporting = testwatcher_class.getDeclaredMethod("DisableReporting"); } catch (Exception e) { throw new Error("Exception while making testwatcher", e); }
response: private static void ensureTestWatcherInitialized() { try { addToBootClassLoader(LISTENER_LOCATION); Class<?> testwatcher_class = Class.forName("art.test.TestWatcher", true, null); DoEnableReporting = testwatcher_class.getDeclaredMethod("EnableReporting"); DoDisableReporting = testwatcher_class.getDeclaredMethod("DisableReporting"); } catch (Exception e) { throw new Error("Exception while making testwatcher", e); } }

sample: 455
buggy_code:  /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none <|startfocus|> public static void SimdMulAdd(int[] array1, int[] array2) { <|endfocus|> for (int j = 0; j < 100; j++) { array2[j] += 12345*array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none //
code_review:  thanks for this idea, I am using the same for the halving add idiom! 
target code: /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345*array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none //
response: /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none

sample: 456
buggy_code:  /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { <|startfocus|> array2[j] += 12345*array1[j]; <|endfocus|> } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (after)
code_review:  here and below, { should be at same line as function def 
target code: /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (after)
response: Fixed Code: ```java public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } public static void SimdMulSub(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] -= 12345 * array1[j]; } } ```

sample: 457
buggy_code:  // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { <|startfocus|> array2[j] += 12345*array1[j]; <|endfocus|> } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none
code_review:  spaces around operators 
target code: // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none
response: // CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) // CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none // CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } // CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) // CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none // CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none // CHECK-DAG: VecSub loop:<<Loop>> outer_loop:none // CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (after) // CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none

sample: 458
buggy_code:  handleRadioProxyExceptionForRR(rr, "setSimCardPower", e); } } } @Override public void setCarrierInfoForImsiEncryption(PublicKey publicKey, String keyIdentifier, Message result) { IRadio radioProxy = getRadioProxy(result); if (radioProxy != null) { android.hardware.radio.V1_1.IRadio radioProxy11 = android.hardware.radio.V1_1.IRadio.castFrom(radioProxy); if (radioProxy11 == null) { <|startfocus|> AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED)); result.sendToTarget(); <|endfocus|> } else { RILRequest rr = obtainRequest(RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, result, mRILDefaultWorkSource); if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)); try { radioProxy11.setCarrierInfoForImsiEncryption( rr.mSerial, publicKeyToArrayList(publicKey), keyIdentifier); } catch (RemoteException | RuntimeException e) { handleRadioProxyExceptionForRR(rr, "setCarrierInfoForImsiEncryption", e); } } } } @Override
code_review:  if result != null 
target code: handleRadioProxyExceptionForRR(rr, "setSimCardPower", e); } } } @Override public void setCarrierInfoForImsiEncryption(PublicKey publicKey, String keyIdentifier, Message result) { IRadio radioProxy = getRadioProxy(result); if (radioProxy != null) { android.hardware.radio.V1_1.IRadio radioProxy11 = android.hardware.radio.V1_1.IRadio.castFrom(radioProxy); if (radioProxy11 == null) { if (result != null) { AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED)); result.sendToTarget(); } } else { RILRequest rr = obtainRequest(RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, result, mRILDefaultWorkSource); if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)); try { radioProxy11.setCarrierInfoForImsiEncryption( rr.mSerial, publicKeyToArrayList(publicKey), keyIdentifier); } catch (RemoteException | RuntimeException e) { handleRadioProxyExceptionForRR(rr, "setCarrierInfoForImsiEncryption", e); } } } } @Override
response: private void handleRadioProxyExceptionForRR(RILRequest rr, String methodName, Exception e) { if (rr != null && rr.result != null) { AsyncResult.forMessage(rr.result, null, CommandException.fromException(e)); rr.result.sendToTarget(); } } @Override public void setCarrierInfoForImsiEncryption(PublicKey publicKey, String keyIdentifier, Message result) { IRadio radioProxy = getRadioProxy(result); if (radioProxy != null) { android.hardware.radio.V1_1.IRadio radioProxy11 = android.hardware.radio.V1_1.IRadio.castFrom(radioProxy); if (radioProxy11 == null) { AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED)); result.sendToTarget(); } else { RILRequest rr = obtainRequest(RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, result, mRILDefaultWorkSource); if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)); try { radioProxy11.setCarrierInfoForImsiEncryption(rr.mSerial, publicKeyToArrayList(publicKey), keyIdentifier); } catch (RemoteException | RuntimeException e) { handleRadioProxyExceptionForRR(rr, "setCarrierInfoForImsiEncryption", e); } } } }

sample: 459
buggy_code:  if (DBG) { log("reportNetworkConnectivity(" + nai.network.netId + ", " + hasConnectivity + ") by " + uid); } synchronized (nai) { // Validating a network that has not yet connected could result in a call to // rematchNetworkAndRequests() which is not meant to work on such networks. if (!nai.everConnected) return; if (isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, false)) return; nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid); <|startfocus|> } <|endfocus|>
code_review:  Is there a compelling reason to extend the arg2 naming scheme into this method? I'd prefer to use a descriptive name for as long as possible (until sendMessage) 
target code: if (DBG) { log("reportNetworkConnectivity(" + nai.network.netId + ", " + hasConnectivity + ") by " + uid); } synchronized (nai) { // Validating a network that has not yet connected could result in a call to // rematchNetworkAndRequests() which is not meant to work on such networks. if (!nai.everConnected) return; if (isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, false)) return; nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid); } LinkProperties lp = getLinkProperties(nai); if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) { return; } nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid);
response: if (DBG) { log("reportNetworkConnectivity(" + nai.network.netId + ", " + hasConnectivity + ") by " + uid); } synchronized (nai) { // Validating a network that has not yet connected could result in a call to // rematchNetworkAndRequests() which is not meant to work on such networks. if (!nai.everConnected) { return; } if (isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, false)) { return; } nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid); }

sample: 460
buggy_code:  if (items == null) { Log.i(TAG, "null queue from " + mediaController.getPackageName() + ", constructing current-item list"); MediaMetadata metadata = mediaController.getMetadata(); // Because we are database-unaware, we can just number the item here whatever we want // because they have to re-poll it every time. MediaSession.QueueItem current = getCurrentQueueItem(mediaController, 1); items = new ArrayList<MediaSession.QueueItem>(); items.add(current); <|startfocus|> return items; <|endfocus|> } mNowPlayingList = items; return items; } /* Constructs a queue item representing the current playing metadata from an * active controller with queue id |qid|. */ private MediaSession.QueueItem getCurrentQueueItem(MediaController controller, long qid) { MediaMetadata metadata = controller.getMetadata(); if (metadata == null) { Log.w(TAG, "Controller has no metadata!? Making an empty one"); metadata = (new MediaMetadata.Builder()).build(); } MediaDescription.Builder bob = new MediaDescription.Builder();
code_review:  Just to make sure, are we handling the case where remote will ask the getItemAttr with this QueueID (0000001)? 
target code: if (items == null) { Log.i(TAG, "null queue from " + mediaController.getPackageName() + ", constructing current-item list"); MediaMetadata metadata = mediaController.getMetadata(); // Because we are database-unaware, we can just number the item here whatever we want // because they have to re-poll it every time. MediaSession.QueueItem current = getCurrentQueueItem(mediaController, 1); items = new ArrayList<MediaSession.QueueItem>(); items.add(current); } mNowPlayingList = items; return items; } /* Constructs a queue item representing the current playing metadata from an * active controller with queue id |qid|. */ private MediaSession.QueueItem getCurrentQueueItem(MediaController controller, long qid) { MediaMetadata metadata = controller.getMetadata(); if (metadata == null) { Log.w(TAG, "Controller has no metadata!? Making an empty one"); metadata = (new MediaMetadata.Builder()).build(); } MediaDescription.Builder bob = new MediaDescription.Builder();
response: if (items == null) { Log.i(TAG, "null queue from " + mediaController.getPackageName() + ", constructing current-item list"); MediaMetadata metadata = mediaController.getMetadata(); MediaSession.QueueItem current = getCurrentQueueItem(mediaController, 1); items = new ArrayList<MediaSession.QueueItem>(); items.add(current); return items; } mNowPlayingList = items; return items; private MediaSession.QueueItem getCurrentQueueItem(MediaController controller, long qid) { MediaMetadata metadata = controller.getMetadata(); if (metadata == null) { Log.w(TAG, "Controller has no metadata!? Making an empty one"); metadata = (new MediaMetadata.Builder()).build(); } MediaDescription.Builder bob = new MediaDescription.Builder(); // rest of the code }

sample: 461
buggy_code:  if (mediaController == null) { Log.e(TAG, "mediaController = null, sending no available players response"); mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null); return; } // We don't have the cached list, fetch it from Media Controller items = mediaController.getQueue(); if (items == null) { <|startfocus|> // We're presenting a queue with only 1 item (the current one) mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, 1); <|endfocus|> } // Cache the response for later mNowPlayingList = items; mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
code_review:  Should we check for a case, where no track is currently selected. Then, we don't have even the current song and getTotalNumOfItems should return 0? 
target code: if (mediaController == null) { Log.e(TAG, "mediaController = null, sending no available players response"); mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null); return; } // We don't have the cached list, fetch it from Media Controller items = mediaController.getQueue(); if (items == null) { // We may be presenting a queue with only 1 item (the current one) int count = mediaController.getMetadata() != null ? 1 : 0; mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, count); } // Cache the response for later mNowPlayingList = items; mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
response: if (mediaController == null) { Log.e(TAG, "mediaController = null, sending no available players response"); mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null); return; } // We don't have the cached list, fetch it from Media Controller items = mediaController.getQueue(); if (items == null) { mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, 1); } // Cache the response for later mNowPlayingList = items; mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());

sample: 462
buggy_code:  if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { <|startfocus|> if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { <|endfocus|> return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } }
code_review:  Please wrap lines to 100 characters: https://source.android.com/source/code-style#limit-line-length 
target code: if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } }
response: if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } wifiConfiguration.preSharedKey = password.matches("[0-9A-Fa-f]{64}") ? password : '"' + password + '"'; }

sample: 463
buggy_code:  private void getNumSlots(APDU apdu) { p1p2Unused(apdu); //dataUnused(apdu); // TODO(ascull): how to handle the cases of APDU properly? prepareToSend(apdu, (short) 4); final byte buffer[] = apdu.getBuffer(); <|startfocus|> buffer[(short) 0] = 0; buffer[(short) 1] = 0; <|endfocus|> Util.setShort(buffer, (short) 2, mSlots.getNumSlots()); apdu.sendBytes((short) 0, (byte) 4);
code_review:  nit: Util.setShort(buffer, (short) 0, (short) 0); ? 
target code: private void getNumSlots(APDU apdu) { p1p2Unused(apdu); //dataUnused(apdu); // TODO(ascull): how to handle the cases of APDU properly? prepareToSend(apdu, (short) 4); final byte buffer[] = apdu.getBuffer(); Util.setShort(buffer, (short) 0, (short) 0); Util.setShort(buffer, (short) 2, mSlots.getNumSlots()); apdu.sendBytes((short) 0, (byte) 4);
response: private void getNumSlots(APDU apdu) { p1p2Unused(apdu); prepareToSend(apdu, (short) 4); final byte buffer[] = apdu.getBuffer(); buffer[(short) 0] = 0; buffer[(short) 1] = 0; Util.setShort(buffer, (short) 2, mSlots.getNumSlots()); apdu.sendBytes((short) 0, (byte) 4); }

sample: 464
buggy_code:  @Override public void onPullExternalCall() { if ((getConnectionProperties() & Connection.PROPERTY_IS_EXTERNAL_CALL) != Connection.PROPERTY_IS_EXTERNAL_CALL) { Log.w(this, "onPullExternalCall - cannot pull non-external call"); return; } if (mOriginalConnection != null) { mOriginalConnection.pullExternalCall(); } } @Override public void onStartRtt(RttTextStream textStream) { if (isImsConnection()) { <|startfocus|> ImsPhone imsPhone = (ImsPhone) getPhone(); imsPhone.sendRttModifyRequest(textStream); <|endfocus|> } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { if (!isImsConnection()) { Log.w(this, "handleRttUpgradeResponse - not in IMS, so RTT cannot be enabled."); return; } ImsPhone imsPhone = (ImsPhone) getPhone();
code_review:  Just curious, is there a reason why you go through ImsPhone --> ImsPhoneCallTracker --> ImsCall to do this? The TelephonyConnection's mOriginalConnection is technically the ImsPhoneConnection. So you can just go: (ImsPhoneConnection) mOriginalConnection.getImsCall().blahBlargStuff(textStream). This would remove the need to check for foreground call in ImsPhoneCallTracker. 
target code: @Override public void onPullExternalCall() { if ((getConnectionProperties() & Connection.PROPERTY_IS_EXTERNAL_CALL) != Connection.PROPERTY_IS_EXTERNAL_CALL) { Log.w(this, "onPullExternalCall - cannot pull non-external call"); return; } if (mOriginalConnection != null) { mOriginalConnection.pullExternalCall(); } } @Override public void onStartRtt(RttTextStream textStream) { if (isImsConnection()) { ImsPhoneConnection originalConnection = (ImsPhoneConnection) mOriginalConnection; originalConnection.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { if (!isImsConnection()) { Log.w(this, "handleRttUpgradeResponse - not in IMS, so RTT cannot be enabled."); return; } ImsPhone imsPhone = (ImsPhone) getPhone();
response: @Override public void onPullExternalCall() { if ((getConnectionProperties() & Connection.PROPERTY_IS_EXTERNAL_CALL) != Connection.PROPERTY_IS_EXTERNAL_CALL) { Log.w(this, "onPullExternalCall - cannot pull non-external call"); return; } if (mOriginalConnection != null) { mOriginalConnection.pullExternalCall(); } } @Override public void onStartRtt(RttTextStream textStream) { if (isImsConnection()) { ImsPhone imsPhone = (ImsPhone) getPhone(); imsPhone.sendRttModifyRequest(textStream); } else { Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled."); } } @Override public void onStopRtt() { // This is not supported by carriers/vendor yet. No-op for now. } @Override public void handleRttUpgradeResponse(RttTextStream textStream) { if (!isImsConnection()) { Log.w(this, "handleRttUpgradeResponse - not in IMS, so RTT cannot be enabled."); return; } ImsPhone imsPhone = (ImsPhone) getPhone(); imsPhone.getForegroundCall().getImsCall().blahBlargStuff(textStream); }

sample: 465
buggy_code:  private Attribute sourceDebugExtension(DirectClassFile cf, int offset, int length, ParseObserver observer) { ByteArray bytes = cf.getBytes().slice(offset, offset + length); CstString smapString = new CstString(bytes); Attribute result = new AttSourceDebugExtension(smapString); if (observer != null) { String decoded = smapString.getString(); observer.parsed(bytes, offset, length, "sourceDebugExtension: " + decoded); } <|startfocus|> return result; <|endfocus|>
code_review:  I haven't looked too closely at what this is supposed to be, but you're sure that this will be well formed UTF-8 ? 
target code: private Attribute sourceDebugExtension(DirectClassFile cf, int offset, int length, ParseObserver observer) { ByteArray bytes = cf.getBytes().slice(offset, offset + length); CstString smapString = new CstString(bytes); Attribute result = new AttSourceDebugExtension(smapString); if (observer != null) { String decoded = smapString.getString(); observer.parsed(bytes, offset, length, "sourceDebugExtension: " + decoded); } return result;
response: private Attribute sourceDebugExtension(DirectClassFile cf, int offset, int length, ParseObserver observer) { ByteArray bytes = cf.getBytes().slice(offset, offset + length); CstString smapString = new CstString(bytes); Attribute result = new AttSourceDebugExtension(smapString); if (observer != null) { String decoded = smapString.getString(); observer.parsed(bytes, offset, length, "sourceDebugExtension: " + decoded); } return result; }

sample: 466
buggy_code: import com.android.dx.rop.cst.CstMethodRef; import com.android.dx.rop.cst.CstNat; import com.android.dx.rop.cst.CstType; import com.android.dx.rop.type.StdTypeList; import com.android.dx.rop.type.Type; import com.android.dx.rop.type.TypeList; import com.android.dx.util.Warning; import java.util.ArrayList; /** * Utility methods that translate various classfile attributes * into forms suitable for use in creating {@code dex} files. */ /*package*/ class AttributeTranslator { <|startfocus|> <|endfocus|> /** * This class is uninstantiable. */ private AttributeTranslator() { // This space intentionally left blank. } /** * Gets the list of thrown exceptions for a given method. * * @param method {@code non-null;} the method in question * @return {@code non-null;} the list of thrown exceptions */ public static TypeList getExceptions(Method method) { AttributeList attribs = method.getAttributes(); AttExceptions exceptions = (AttExceptions) attribs.findFirst(AttExceptions.ATTRIBUTE_NAME); if (exceptions == null) {
code_review:  unnecessary delta 
target code: import com.android.dx.rop.cst.CstMethodRef; import com.android.dx.rop.cst.CstNat; import com.android.dx.rop.cst.CstType; import com.android.dx.rop.type.StdTypeList; import com.android.dx.rop.type.Type; import com.android.dx.rop.type.TypeList; import com.android.dx.util.Warning; import java.util.ArrayList; /** * Utility methods that translate various classfile attributes * into forms suitable for use in creating {@code dex} files. */ /*package*/ class AttributeTranslator { /** * This class is uninstantiable. */ private AttributeTranslator() { // This space intentionally left blank. } /** * Gets the list of thrown exceptions for a given method. * * @param method {@code non-null;} the method in question * @return {@code non-null;} the list of thrown exceptions */ public static TypeList getExceptions(Method method) { AttributeList attribs = method.getAttributes(); AttExceptions exceptions = (AttExceptions) attribs.findFirst(AttExceptions.ATTRIBUTE_NAME); if (exceptions == null) {
response: import com.android.dx.rop.cst.CstMethodRef; import com.android.dx.rop.cst.CstNat; import com.android.dx.rop.cst.CstType; import com.android.dx.rop.type.StdTypeList; import com.android.dx.rop.type.Type; import com.android.dx.rop.type.TypeList; import com.android.dx.util.Warning; import java.util.ArrayList; /*package*/ class AttributeTranslator { private AttributeTranslator() { // This space intentionally left blank. } public static TypeList getExceptions(Method method) { AttributeList attribs = method.getAttributes(); AttExceptions exceptions = (AttExceptions) attribs.findFirst(AttExceptions.ATTRIBUTE_NAME); if (exceptions == null) { return StdTypeList.EMPTY; } else { return exceptions.getExceptions(); } } }

sample: 467
buggy_code:  public static long $opt$noinline$mulNeg(long left, long right) { if (doThrow) throw new Error(); return - (left * right); } /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none <|startfocus|> // <|endfocus|> /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } 
code_review:  don't we need vectorizer support for this first? Is a patch missing? 
target code: public static long $opt$noinline$mulNeg(long left, long right) { if (doThrow) throw new Error(); return - (left * right); } /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } }
response: public static long $opt$noinline$mulNeg(long left, long right) { if (doThrow) throw new Error(); return - (left * right); } public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } }

sample: 468
buggy_code:  private static void throttle(byte[] bArray, short bOff, short failureCount) { short highWord = 0; short lowWord = 0; <|startfocus|> final short thritySecondsInMilliseconds = 0x7530; // = 1000 * 30 <|endfocus|> if (failureCount == 0) { // 0s } else if (failureCount > 0 && failureCount <= 10) { if (failureCount % 5 == 0) { // 30s lowWord = thritySecondsInMilliseconds; } else { // 0s } } else if (failureCount < 30) { // 30s lowWord = thritySecondsInMilliseconds; } else if (failureCount < 140) { // 30 * (2^((x - 30)/10)) final short shift = (short) ((short) (failureCount - 30) / 10); highWord = (short) (thritySecondsInMilliseconds >> (16 - shift)); lowWord = (short) (thritySecondsInMilliseconds << shift); } else { // 1 day in ms = 1000 * 60 * 60 * 24 = 0x526 5C00 highWord = 0x0526;
code_review:  nit: s/thrity/thirty/g 
target code: private static void throttle(byte[] bArray, short bOff, short failureCount) { short highWord = 0; short lowWord = 0; final short thirtySecondsInMilliseconds = 0x7530; // = 1000 * 30 if (failureCount == 0) { // 0s } else if (failureCount > 0 && failureCount <= 10) { if (failureCount % 5 == 0) { // 30s lowWord = thritySecondsInMilliseconds; } else { // 0s } } else if (failureCount < 30) { // 30s lowWord = thritySecondsInMilliseconds; } else if (failureCount < 140) { // 30 * (2^((x - 30)/10)) final short shift = (short) ((short) (failureCount - 30) / 10); highWord = (short) (thritySecondsInMilliseconds >> (16 - shift)); lowWord = (short) (thritySecondsInMilliseconds << shift); } else { // 1 day in ms = 1000 * 60 * 60 * 24 = 0x526 5C00 highWord = 0x0526;
response: private static void throttle(byte[] bArray, short bOff, short failureCount) { short highWord = 0; short lowWord = 0; final short thirtySecondsInMilliseconds = 0x7530; // = 1000 * 30 if (failureCount == 0) { // 0s } else if (failureCount > 0 && failureCount <= 10) { if (failureCount % 5 == 0) { // 30s lowWord = thirtySecondsInMilliseconds; } else { // 0s } } else if (failureCount < 30) { // 30s lowWord = thirtySecondsInMilliseconds; } else if (failureCount < 140) { // 30 * (2^((x - 30)/10)) final short shift = (short) ((short) (failureCount - 30) / 10); highWord = (short) (thirtySecondsInMilliseconds >> (16 - shift)); lowWord = (short) (thirtySecondsInMilliseconds << shift); } else { // 1 day in ms = 1000 * 60 * 60 * 24 = 0x5265C00 highWord = 0x0526; } }

sample: 469
buggy_code:  IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication( IpSecTransform.DIRECTION_IN, new IpSecAlgorithm( IpSecAlgorithm.AUTH_HMAC_SHA256, AUTH_KEY, CRYPT_KEY.length * 8)) .buildTransportModeTransform(local); // Hack to ensure the socket doesn't block indefinitely on failure DatagramSocket localSocket = new DatagramSocket(8888); localSocket.setSoTimeout(500); <|startfocus|> FileDescriptor udpSocket = ParcelFileDescriptor.fromDatagramSocket(localSocket).getFileDescriptor(); <|endfocus|> mISM.applyTransportModeTransform(udpSocket, transform); byte[] data = new String("Best test data ever!").getBytes("UTF-8"); byte[] in = new byte[data.length]; Os.sendto(udpSocket, data, 0, data.length, 0, local, 8888); Os.read(udpSocket, in, 0, in.length); assertTrue("Encapsulated data did not match.", Arrays.equals(data, in)); mISM.removeTransportModeTransform(udpSocket, transform); Os.close(udpSocket); transform.close(); } } 
code_review:  I think you need to keep a reference to the FileDescriptor. Otherwise its finalizer will get called and the fd will silently be set to -1. 
target code: IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication( IpSecTransform.DIRECTION_IN, new IpSecAlgorithm( IpSecAlgorithm.AUTH_HMAC_SHA256, AUTH_KEY, CRYPT_KEY.length * 8)) .buildTransportModeTransform(local); // Hack to ensure the socket doesn't block indefinitely on failure DatagramSocket localSocket = new DatagramSocket(8888); localSocket.setSoTimeout(500); mISM.applyTransportModeTransform(udpSocket, transform); byte[] data = new String("Best test data ever!").getBytes("UTF-8"); byte[] in = new byte[data.length]; Os.sendto(udpSocket, data, 0, data.length, 0, local, 8888); Os.read(udpSocket, in, 0, in.length); assertTrue("Encapsulated data did not match.", Arrays.equals(data, in)); mISM.removeTransportModeTransform(udpSocket, transform); Os.close(udpSocket); transform.close(); } }
response: IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY)) .setAuthentication(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, AUTH_KEY, CRYPT_KEY.length * 8)) .buildTransportModeTransform(local); // Hack to ensure the socket doesn't block indefinitely on failure DatagramSocket localSocket = new DatagramSocket(8888); localSocket.setSoTimeout(500); FileDescriptor udpSocket = ParcelFileDescriptor.fromDatagramSocket(localSocket).getFileDescriptor(); mISM.applyTransportModeTransform(udpSocket, transform); byte[] data = new String("Best test data ever!").getBytes("UTF-8"); byte[] in = new byte[data.length]; Os.sendto(udpSocket, data, 0, data.length, 0, local, 8888); Os.read(udpSocket, in, 0, in.length); assertTrue("Encapsulated data did not match.", Arrays.equals(data, in)); mISM.removeTransportModeTransform(udpSocket, transform); Os.close(udpSocket); transform.close(); }

sample: 470
buggy_code:  if (mEnableTerminal != null) { updateSwitchPreference(mEnableTerminal, context.getPackageManager().getApplicationEnabledSetting(TERMINAL_APP_PACKAGE) == PackageManager.COMPONENT_ENABLED_STATE_ENABLED); } updateSwitchPreference(mBugreportInPower, Settings.Secure.getInt(cr, Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0); updateSwitchPreference(mKeepScreenOn, Settings.Global.getInt(cr, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0) != 0); <|startfocus|> updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false)); <|endfocus|> updateSwitchPreference(mDebugViewAttributes, Settings.Global.getInt(cr, Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0); updateSwitchPreference(mForceAllowOnExternal, Settings.Global.getInt(cr, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, 0) != 0); updateHdcpValues(); updatePasswordSummary(); updateDebuggerOptions(); updateMockLocation(); updateStrictModeVisualOptions(); updatePointerLocationOptions(); updateShowTouchesOptions(); updateFlingerOptions(); updateHardwareUiOptions(); updateMsaaOptions(); updateTrackFrameTimeOptions(); updateShowNonRectClipOptions(); updateShowHwScreenUpdatesOptions(); updateShowHwLayersUpdatesOptions(); updateDebugHwOverdrawOptions();
code_review:  long lines 
target code: if (mEnableTerminal != null) { updateSwitchPreference(mEnableTerminal, context.getPackageManager().getApplicationEnabledSetting(TERMINAL_APP_PACKAGE) == PackageManager.COMPONENT_ENABLED_STATE_ENABLED); } updateSwitchPreference(mBugreportInPower, Settings.Secure.getInt(cr, Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0); updateSwitchPreference(mKeepScreenOn, Settings.Global.getInt(cr, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0) != 0); updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean( BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false)); updateSwitchPreference(mDebugViewAttributes, Settings.Global.getInt(cr, Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0); updateSwitchPreference(mForceAllowOnExternal, Settings.Global.getInt(cr, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, 0) != 0); updateHdcpValues(); updatePasswordSummary(); updateDebuggerOptions(); updateMockLocation(); updateStrictModeVisualOptions(); updatePointerLocationOptions(); updateShowTouchesOptions(); updateFlingerOptions(); updateHardwareUiOptions(); updateMsaaOptions(); updateTrackFrameTimeOptions(); updateShowNonRectClipOptions(); updateShowHwScreenUpdatesOptions(); updateShowHwLayersUpdatesOptions(); updateDebugHwOverdrawOptions();
response: Refactored Code: ```java if (mEnableTerminal != null) { updateSwitchPreference(mEnableTerminal, context.getPackageManager().getApplicationEnabledSetting(TERMINAL_APP_PACKAGE) == PackageManager.COMPONENT_ENABLED_STATE_ENABLED); } updateSwitchPreference(mBugreportInPower, Settings.Secure.getInt(cr, Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0); updateSwitchPreference(mKeepScreenOn, Settings.Global.getInt(cr, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0) != 0); updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false)); updateSwitchPreference(mDebugViewAttributes, Settings.Global.getInt(cr, Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0); updateSwitchPreference(mForceAllowOnExternal, Settings.Global.getInt(cr, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, 0) != 0); updateHdcpValues(); updatePasswordSummary(); updateDebuggerOptions(); updateMockLocation(); updateStrictModeVisualOptions(); updatePointerLocationOptions(); updateShowTouchesOptions(); updateFlingerOptions(); updateHardwareUiOptions(); updateMsaaOptions(); updateTrackFrameTimeOptions(); updateShowNonRectClipOptions(); updateShowHwScreenUpdatesOptions(); updateShowHwLayersUpdatesOptions(); updateDebugHwOverdrawOptions(); ``` Note: The code has been refactored to remove long lines.

sample: 471
buggy_code:  // Check that this is a valid device address (i.e. not broadcast). if ((val[0] & 0x01) != 0) { // Invalid since this is a broadcast address. errorLog("Invalid device address=" + Utils.getAddressStringFromByte(val) + ". Ignore this address."); break; } mAddress = val; <|startfocus|> debugLog("Address is:" + Utils.getAddressStringFromByte(mAddress)); intent = new Intent(BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED); intent.putExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR, Utils.getAddressStringFromByte(mAddress)); <|endfocus|> intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); mService.sendBroadcastAsUser( intent, UserHandle.ALL, mService.BLUETOOTH_PERM); break; case AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE: mBluetoothClass = Utils.byteArrayToInt(val, 0); debugLog("BT Class:" + mBluetoothClass); break; case AbstractionLayer.BT_PROPERTY_ADAPTER_SCAN_MODE: int mode = Utils.byteArrayToInt(val, 0);
code_review:  Consider using a String variable to store the address string so that this method only needs to be called once. 
target code: // Check that this is a valid device address (i.e. not broadcast). if ((val[0] & 0x01) != 0) { // Invalid since this is a broadcast address. errorLog("Invalid device address=" + Utils.getAddressStringFromByte(val) + ". Ignore this address."); break; } mAddress = val; String address = Utils.getAddressStringFromByte(mAddress); debugLog("Address is:" + address); intent = new Intent(BluetoothAdapter.ACTION_BD_ADDR_CHANGED); intent.putExtra(BluetoothAdapter.EXTRA_BD_ADDR, address); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); mService.sendBroadcastAsUser( intent, UserHandle.ALL, mService.BLUETOOTH_PERM); break; case AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE: mBluetoothClass = Utils.byteArrayToInt(val, 0); debugLog("BT Class:" + mBluetoothClass); break; case AbstractionLayer.BT_PROPERTY_ADAPTER_SCAN_MODE: int mode = Utils.byteArrayToInt(val, 0);
response: // Check that this is a valid device address (i.e. not broadcast). if ((val[0] & 0x01) != 0) { // Invalid since this is a broadcast address. String addressString = Utils.getAddressStringFromByte(val); errorLog("Invalid device address=" + addressString + ". Ignore this address."); break; } mAddress = val; debugLog("Address is:" + Utils.getAddressStringFromByte(mAddress)); intent = new Intent(BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED); intent.putExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR, Utils.getAddressStringFromByte(mAddress)); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); mService.sendBroadcastAsUser(intent, UserHandle.ALL, mService.BLUETOOTH_PERM); break; case AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE: mBluetoothClass = Utils.byteArrayToInt(val, 0); debugLog("BT Class:" + mBluetoothClass); break; case AbstractionLayer.BT_PROPERTY_ADAPTER_SCAN_MODE: int mode = Utils.byteArrayToInt(val, 0);

sample: 472
buggy_code:  * This extra represents the previous connection state. */ public static final String EXTRA_PREVIOUS_CONNECTION_STATE = "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ <|startfocus|> public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; <|endfocus|> /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be
code_review:  Unclear - please rewrite. 
target code: * This extra represents the previous connection state. */ public static final String EXTRA_PREVIOUS_CONNECTION_STATE = "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ public static final String ACTION_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be
response: public static final String EXTRA_PREVIOUS_CONNECTION_STATE = "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR";

sample: 473
buggy_code:  /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ <|startfocus|> public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; <|endfocus|> /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection
code_review:  A system-wide broadcast is an overkill for what we need. The broadcast should be used when multiple receivers are registered for the broadcast. In this case, the receiver is internal in the Bluetooth module and maybe a more internal method should be adopted. 
target code: /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ public static final String ACTION_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection
response: /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifies Bluetooth BD (mac) address updated event. * @hide */ public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * This extra represents the BD Address. * @hide */ public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; /** * Broadcast Action: The notifies Bluetooth ACL connected event. * This will be used by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state is in STATE_BLE_ON. * This denotes GATT connection. * @hide */ public static final String ACTION_BT_ACL_CONNECTED = "android.bluetooth.adapter.action.BT_ACL_CONNECTED";

sample: 474
buggy_code:  */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ <|startfocus|> public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; <|endfocus|> /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which
code_review:  Bluetooth address (?) 
target code: */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BD_ADDR = "android.bluetooth.adapter.extra.BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which
response: @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; public static final String ACTION_ACL_CONNECTED_BLE = "android.bluetooth.adapter.action.ACL_CONNECTED_BLE";

sample: 475
buggy_code:  /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ <|startfocus|> public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; <|endfocus|> /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which * works in Bluetooth state STATE_ON * @hide */ public static final String ACTION_BLE_ACL_CONNECTED =
code_review:  Use either BT_ADDR or BD_ADDR, as similar to LOCAL_NAME 
target code: /** * Broadcast Action: The notifys Bluetooth BD (mac) address * updated event. * * @hide */ public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BD_ADDR = "android.bluetooth.adapter.extra.BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which * works in Bluetooth state STATE_ON * @hide */ public static final String ACTION_BLE_ACL_CONNECTED =
response: /** * Broadcast Action: The notifies Bluetooth BD (mac) address updated event. * * @hide */ public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED"; /** * Extra used by {@link #ACTION_BT_BD_ADDR_CHANGED} * * This extra represents the BD Address. * * @hide */ public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR"; /** * Broadcast Action: The notifies Bluetooth ACL connected event. This will be * used by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state is STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON. * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which * works in Bluetooth state STATE_ON * * @hide */ public static final String ACTION_BLE_ACL_CONNECTED = ...

sample: 476
buggy_code:  String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME); if (DBG) Slog.d(TAG, "Bluetooth Adapter name changed to " + newName); if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR); if (newAddress != null) { <|startfocus|> if (DBG) Slog.d(TAG, "Bluetooth Adapter BD Address changed to " + newAddress); <|endfocus|> storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter BD Address parameter found"); } }
code_review:  Is this needed as part of the log message? 
target code: String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME); if (DBG) Slog.d(TAG, "Bluetooth Adapter name changed to " + newName); if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter BD Address parameter found"); } }
response: String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME); if (DBG) Slog.d(TAG, "Bluetooth Adapter name changed to " + newName); if (newName != null) { storeNameAndAddress(newName, null); } else if (BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter BD Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter BD Address parameter found"); } }

sample: 477
buggy_code:  if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter BD Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { <|startfocus|> if (DBG) Slog.e(TAG, "No Bluetooth Adapter BD Address parameter found"); <|endfocus|> } }
code_review:  Same comment as above. 
target code: if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter BD Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found"); } }
response: if (newName != null) { storeNameAndAddress(newName, null); } else if (BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter BD Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter BD Address parameter found"); } }

sample: 478
buggy_code:  public void testAospServiceContexts() throws Exception { /* obtain service_contexts file from running device */ deviceSvcFile = File.createTempFile("service_contexts", ".tmp"); deviceSvcFile.deleteOnExit(); mDevice.pullFile("/service_contexts", deviceSvcFile); /* retrieve the AOSP service_contexts file from jar */ aospSvcFile = copyResourceToTempFile("/general_service_contexts"); <|startfocus|> /* retrieve NMR1 AOSP service_contexts file from jar */ if (!isFileStartsWith(aospSvcFile, deviceSvcFile)) { <|endfocus|> aospSvcFile = copyResourceToTempFile("/ab3857191_service_contexts"); assertFileStartsWith(aospSvcFile, deviceSvcFile); } } /** * Tests that the file_contexts.bin file on the device is valid. * * @throws Exception */ @CddTest(requirement="9.7") public void testValidFileContexts() throws Exception { /* retrieve the checkfc executable from jar */ checkFc = copyResourceToTempFile("/checkfc"); checkFc.setExecutable(true); /* obtain file_contexts.bin file from running device */
code_review:  fix indention 
target code: public void testAospServiceContexts() throws Exception { /* obtain service_contexts file from running device */ deviceSvcFile = File.createTempFile("service_contexts", ".tmp"); deviceSvcFile.deleteOnExit(); mDevice.pullFile("/service_contexts", deviceSvcFile); /* retrieve the AOSP service_contexts file from jar */ aospSvcFile = copyResourceToTempFile("/general_service_contexts"); /* retrieve NMR1 AOSP service_contexts file from jar */ if (!isFileStartsWith(aospSvcFile, deviceSvcFile)) { aospSvcFile = copyResourceToTempFile("/ab3857191_service_contexts"); assertFileStartsWith(aospSvcFile, deviceSvcFile); } } /** * Tests that the file_contexts.bin file on the device is valid. * * @throws Exception */ @CddTest(requirement="9.7") public void testValidFileContexts() throws Exception { /* retrieve the checkfc executable from jar */ checkFc = copyResourceToTempFile("/checkfc"); checkFc.setExecutable(true); /* obtain file_contexts.bin file from running device */
response: public void testAospServiceContexts() throws Exception { /* obtain service_contexts file from running device */ deviceSvcFile = File.createTempFile("service_contexts", ".tmp"); deviceSvcFile.deleteOnExit(); mDevice.pullFile("/service_contexts", deviceSvcFile); /* retrieve the AOSP service_contexts file from jar */ aospSvcFile = copyResourceToTempFile("/general_service_contexts"); /* retrieve NMR1 AOSP service_contexts file from jar */ if (!isFileStartsWith(aospSvcFile, deviceSvcFile)) { aospSvcFile = copyResourceToTempFile("/ab3857191_service_contexts"); assertFileStartsWith(aospSvcFile, deviceSvcFile); } } /** * Tests that the file_contexts.bin file on the device is valid. * * @throws Exception */ @CddTest(requirement="9.7") public void testValidFileContexts() throws Exception { /* retrieve the checkfc executable from jar */ checkFc = copyResourceToTempFile("/checkfc"); checkFc.setExecutable(true); /* obtain file_contexts.bin file from running device */ // ... }

sample: 479
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package art; import java.util.Base64; public class Test985 { static class Transform { private void Start() { System.out.println("hello - private"); } private void Finish() { System.out.println("goodbye - private"); } public void sayHi(Runnable r) { System.out.println("Pre Start private method call"); Start();
code_review:  2017? 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package art; import java.util.Base64; public class Test985 { static class Transform { private void Start() { System.out.println("hello - private"); } private void Finish() { System.out.println("goodbye - private"); } public void sayHi(Runnable r) { System.out.println("Pre Start private method call"); Start();
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package art; import java.util.Base64; public class Test985 { static class Transform { private void Start() { System.out.println("hello - private"); } private void Finish() { System.out.println("goodbye - private"); } public void sayHi(Runnable r) { System.out.println("Pre Start private method call"); Start(); r.run(); Finish(); } } public static void main(String[] args) { Transform t = new Transform(); t.sayHi(() -> System.out.println("Hello, world!")); } }

sample: 480
buggy_code:  byte result = Consts.READ_WRONG_KEY; if (Util.arrayCompare( keyBuffer, keyOffset, mKey, (short) 0, Consts.SLOT_KEY_BYTES) == 0) { return Consts.READ_SUCCESS; } JCSystem.beginTransaction(); if (result == Consts.READ_WRONG_KEY) { if (mFailureCount != 0x7fff) { mFailureCount += 1; } if (throttle(sRemainingBackoff, (short) 0, mFailureCount)) { //mBackoffTimer.startTimer( // sRemainingBackoff, (short) 0, DSTimer.DST_POWEROFFMODE_FALLBACK); } Util.arrayCopyNonAtomic( sRemainingBackoff, (short) 0, outBuffer, outOffset, (byte) 4); <|startfocus|> } else { // This attempt was successful so reset the failures mFailureCount = 0; //mBackoffTimer.stopTimer(); Util.arrayCopyNonAtomic( mValue, (short) 0, outBuffer, outOffset, Consts.SLOT_VALUE_BYTES); <|endfocus|> } JCSystem.commitTransaction(); return result;
code_review:  To reduce the (already likely negligible) possibility that an attacker can tell the difference between success and failure and quickly cut power, I'd do no work inside the transaction other than checking result and writing mFailureCount. Util.arrayCompare should be constant-time so this is already an incredibly narrow needle to thread, but we may as well make it as narrow as possible. 
target code: byte result = Consts.READ_WRONG_KEY; if (Util.arrayCompare( keyBuffer, keyOffset, mKey, (short) 0, Consts.SLOT_KEY_BYTES) == 0) { return Consts.READ_SUCCESS; } JCSystem.beginTransaction(); if (result == Consts.READ_WRONG_KEY) { if (mFailureCount != 0x7fff) { mFailureCount += 1; } if (throttle(sRemainingBackoff, (short) 0, mFailureCount)) { //mBackoffTimer.startTimer( // sRemainingBackoff, (short) 0, DSTimer.DST_POWEROFFMODE_FALLBACK); } Util.arrayCopyNonAtomic( sRemainingBackoff, (short) 0, outBuffer, outOffset, (byte) 4); return Consts.SW_WRONG_KEY; } JCSystem.commitTransaction(); return result;
response: byte result = Consts.READ_WRONG_KEY; if (Util.arrayCompare(keyBuffer, keyOffset, mKey, (short) 0, Consts.SLOT_KEY_BYTES) == 0) { return Consts.READ_SUCCESS; } JCSystem.beginTransaction(); if (result == Consts.READ_WRONG_KEY) { if (mFailureCount != 0x7fff) { mFailureCount += 1; } if (throttle(sRemainingBackoff, (short) 0, mFailureCount)) { //mBackoffTimer.startTimer( // sRemainingBackoff, (short) 0, DSTimer.DST_POWEROFFMODE_FALLBACK); } Util.arrayCopyNonAtomic(sRemainingBackoff, (short) 0, outBuffer, outOffset, (byte) 4); } else { mFailureCount = 0; //mBackoffTimer.stopTimer(); Util.arrayCopyNonAtomic(mValue, (short) 0, outBuffer, outOffset, Consts.SLOT_VALUE_BYTES); } JCSystem.commitTransaction(); return result;

sample: 481
buggy_code:  /// CHECK-NOT: InstanceFieldSet /// CHECK-NOT: ConstructorFence /// CHECK-NOT: InstanceFieldGet // Make sure the constructor fence gets eliminated when the allocation is eliminated. static double calcCircleArea(double radius) { return new Circle(radius).getArea(); } /// CHECK-START: double Main.calcEllipseArea(double, double) load_store_elimination (before) /// CHECK: NewInstance /// CHECK: InstanceFieldSet <|startfocus|> /* // TODO: The super constructor fence should not be eliminated already. // CHECK: ConstructorFence */ <|endfocus|> /// CHECK: InstanceFieldSet /// CHECK: ConstructorFence /// CHECK: InstanceFieldGet /// CHECK: InstanceFieldGet /// CHECK-START: double Main.calcEllipseArea(double, double) load_store_elimination (after) /// CHECK-NOT: NewInstance /// CHECK-NOT: InstanceFieldSet /// CHECK-NOT: ConstructorFence /// CHECK-NOT: InstanceFieldGet // Multiple constructor fences can accumulate through inheritance, make sure // they are all eliminated when the allocation is eliminated. static double calcEllipseArea(double vertex, double covertex) {
code_review:  No other pass is allowed to merge the two fences if the reference does not escape in between? 
target code: /// CHECK-NOT: InstanceFieldSet /// CHECK-NOT: ConstructorFence /// CHECK-NOT: InstanceFieldGet // Make sure the constructor fence gets eliminated when the allocation is eliminated. static double calcCircleArea(double radius) { return new Circle(radius).getArea(); } /// CHECK-START: double Main.calcEllipseArea(double, double) load_store_elimination (before) /// CHECK: NewInstance /// CHECK: InstanceFieldSet /// CHECK: InstanceFieldSet /// CHECK: ConstructorFence /// CHECK: InstanceFieldGet /// CHECK: InstanceFieldGet /// CHECK-START: double Main.calcEllipseArea(double, double) load_store_elimination (after) /// CHECK-NOT: NewInstance /// CHECK-NOT: InstanceFieldSet /// CHECK-NOT: ConstructorFence /// CHECK-NOT: InstanceFieldGet // Multiple constructor fences can accumulate through inheritance, make sure // they are all eliminated when the allocation is eliminated. static double calcEllipseArea(double vertex, double covertex) {
response: /// CHECK-NOT: InstanceFieldSet /// CHECK-NOT: ConstructorFence /// CHECK-NOT: InstanceFieldGet static double calcCircleArea(double radius) { return new Circle(radius).getArea(); } /// CHECK-START: double Main.calcEllipseArea(double, double) load_store_elimination (before) /// CHECK: NewInstance /// CHECK: InstanceFieldSet /* // TODO: The super constructor fence should not be eliminated already. // CHECK: ConstructorFence */ /// CHECK: InstanceFieldSet /// CHECK: ConstructorFence /// CHECK: InstanceFieldGet /// CHECK: InstanceFieldGet /// CHECK-START: double Main.calcEllipseArea(double, double) load_store_elimination (after) /// CHECK-NOT: NewInstance /// CHECK-NOT: InstanceFieldSet /// CHECK-NOT: ConstructorFence /// CHECK-NOT: InstanceFieldGet // Multiple constructor fences can accumulate through inheritance, make sure // they are all eliminated when the allocation is eliminated. static double calcEllipseArea(double vertex, double covertex) { return new Ellipse(vertex, covertex).getArea(); }

sample: 482
buggy_code:  static double calcEllipseArea(double vertex, double covertex) { return new Ellipse(vertex, covertex).getArea(); } /// CHECK-START: double Main.calcCircleAreaOrCircumference(double, boolean) load_store_elimination (before) /// CHECK: NewInstance /// CHECK: InstanceFieldSet /// CHECK: ConstructorFence /// CHECK: InstanceFieldGet /// CHECK-START: double Main.calcCircleAreaOrCircumference(double, boolean) load_store_elimination (after) /// CHECK: NewInstance /// CHECK-NOT: ConstructorFence <|startfocus|> static double someResult; <|endfocus|> // // The object allocation will not be eliminated by LSE because of aliased stores. // However the object is still a singleton, so it never escapes the current thread. // There should not be a constructor fence here after LSE. static double calcCircleAreaOrCircumference(double radius, boolean area_or_circumference) { CalcCircleAreaOrCircumference calc = new CalcCircleAreaOrCircumference( area_or_circumference ? CalcCircleAreaOrCircumference.TYPE_AREA : CalcCircleAreaOrCircumference.TYPE_CIRCUMFERENCE); if (area_or_circumference) { // Area
code_review:  Why is this here? It's separating the CHECKer statements above from the method below. 
target code: static double calcEllipseArea(double vertex, double covertex) { return new Ellipse(vertex, covertex).getArea(); } /// CHECK-START: double Main.calcCircleAreaOrCircumference(double, boolean) load_store_elimination (before) /// CHECK: NewInstance /// CHECK: InstanceFieldSet /// CHECK: ConstructorFence /// CHECK: InstanceFieldGet /// CHECK-START: double Main.calcCircleAreaOrCircumference(double, boolean) load_store_elimination (after) /// CHECK: NewInstance /// CHECK-NOT: ConstructorFence // // The object allocation will not be eliminated by LSE because of aliased stores. // However the object is still a singleton, so it never escapes the current thread. // There should not be a constructor fence here after LSE. static double calcCircleAreaOrCircumference(double radius, boolean area_or_circumference) { CalcCircleAreaOrCircumference calc = new CalcCircleAreaOrCircumference( area_or_circumference ? CalcCircleAreaOrCircumference.TYPE_AREA : CalcCircleAreaOrCircumference.TYPE_CIRCUMFERENCE); if (area_or_circumference) { // Area
response: static double calcEllipseArea(double vertex, double covertex) { return new Ellipse(vertex, covertex).getArea(); } static double someResult; static double calcCircleAreaOrCircumference(double radius, boolean area_or_circumference) { CalcCircleAreaOrCircumference calc = new CalcCircleAreaOrCircumference( area_or_circumference ? CalcCircleAreaOrCircumference.TYPE_AREA : CalcCircleAreaOrCircumference.TYPE_CIRCUMFERENCE ); if (area_or_circumference) { // Area someResult = calc.calculateArea(radius); } else { // Circumference someResult = calc.calculateCircumference(radius); } return someResult; }

sample: 483
buggy_code:  /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none <|startfocus|> /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none <|endfocus|> public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none
code_review:  make new section with CHECK-NOT VecMul CHECK-NOT VecAdd to ensure it is replaced (and not put next to it) 
target code: /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none // /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-NOT: VecMull /// CHECK-NOT: VecAdd public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none
response: /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none /// CHECK-DAG: VecAdd loop:<<Loop>> outer_loop:none /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-NOT: VecMul /// CHECK-NOT: VecAdd /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none public static void SimdMulAdd(int[] array1, int[] array2) { for (int j = 0; j < 100; j++) { array2[j] += 12345 * array1[j]; } } /// CHECK-START-ARM64: void Main.SimdMulSub(int[], int[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: Phi loop:<<Loop:B\d+>> outer_loop:none /// CHECK-DAG: VecMul loop:<<Loop>> outer_loop:none

sample: 484
buggy_code: <|startfocus|> * Copyright (C) 2015 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except * in compliance with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software distributed under the License * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express * or implied. See the License for the specific language governing permissions and limitations under * the License. */ package com.android.rs.test; import android.content.Context; import android.renderscript.Allocation; import android.renderscript.Element; import android.renderscript.RenderScript; import android.renderscript.RSIllegalArgumentException; import android.renderscript.ScriptIntrinsicBlur; import android.renderscript.Type; import android.util.Log; public class UT_blur_validation extends UnitTest { private static final int ARRAY_SIZE = 256; private static final String TAG = "ScriptIntrinsicBlur validation"; 
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except * in compliance with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software distributed under the License * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express * or implied. See the License for the specific language governing permissions and limitations under * the License. */ package com.android.rs.test; import android.content.Context; import android.renderscript.Allocation; import android.renderscript.Element; import android.renderscript.RenderScript; import android.renderscript.RSIllegalArgumentException; import android.renderscript.ScriptIntrinsicBlur; import android.renderscript.Type; import android.util.Log; public class UT_blur_validation extends UnitTest { private static final int ARRAY_SIZE = 256; private static final String TAG = "ScriptIntrinsicBlur validation";
response: * Copyright (C) 2017 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. package com.android.rs.test; import android.content.Context; import android.renderscript.Allocation; import android.renderscript.Element; import android.renderscript.RenderScript; import android.renderscript.RSIllegalArgumentException; import android.renderscript.ScriptIntrinsicBlur; import android.renderscript.Type; import android.util.Log; public class UT_blur_validation extends UnitTest { private static final int ARRAY_SIZE = 256; private static final String TAG = "ScriptIntrinsicBlur validation"; }

sample: 485
buggy_code:  output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); passTest(); return; } Log.e(TAG, "setting 1d output does not trigger exception"); pRS.finish(); input1D.destroy(); input2D.destroy(); output1D.destroy(); output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); failTest(); return; } Log.e(TAG, "setting 1d input does not trigger exception"); <|startfocus|> pRS.finish(); input1D.destroy(); input2D.destroy(); output1D.destroy(); output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); <|endfocus|> failTest();
code_review:  It would be nice to have the destroy() calls in another method. Makes it more obvious what is tested. 
target code: output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); passTest(); return; } Log.e(TAG, "setting 1d output does not trigger exception"); pRS.finish(); input1D.destroy(); input2D.destroy(); output1D.destroy(); output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); failTest(); return; } Log.e(TAG, "setting 1d input does not trigger exception"); cleanup(); failTest();
response: public void destroyResources() { pRS.finish(); input1D.destroy(); input2D.destroy(); output1D.destroy(); output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); } public void testDestroy() { output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); passTest(); } public void testFailDestroy() { pRS.finish(); input1D.destroy(); input2D.destroy(); output1D.destroy(); output2D.destroy(); scriptBlur.destroy(); pRS.destroy(); failTest(); } // Usage if (condition) { destroyResources(); testDestroy(); } else { Log.e(TAG, "setting 1d input does not trigger exception"); destroyResources(); testFailDestroy(); }

sample: 486
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package art; import java.lang.reflect.Method; import java.util.HashMap; public class Test986 { static { // NB This is called before any setup is done so we don't need to worry about getting bind // events. Main.bindAgentJNIForClass(Test986.class); } private static final HashMap<Method, String> SymbolMap = new HashMap<>(); 
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package art; import java.lang.reflect.Method; import java.util.HashMap; public class Test986 { static { // NB This is called before any setup is done so we don't need to worry about getting bind // events. Main.bindAgentJNIForClass(Test986.class); } private static final HashMap<Method, String> SymbolMap = new HashMap<>();
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package art; import java.lang.reflect.Method; import java.util.HashMap; public class Test986 { static { // NB This is called before any setup is done so we don't need to worry about getting bind // events. Main.bindAgentJNIForClass(Test986.class); } private static final HashMap<Method, String> SymbolMap = new HashMap<>(); }

sample: 487
buggy_code:  ProcessBuilder pb1 = new ProcessBuilder(checkFc.getAbsolutePath(), "-c", aospFcFile.getAbsolutePath(), deviceFcFile.getAbsolutePath()); pb1.redirectOutput(ProcessBuilder.Redirect.PIPE); pb1.redirectErrorStream(true); Process p1 = pb1.start(); p1.waitFor(); BufferedReader result1 = new BufferedReader(new InputStreamReader(p1.getInputStream())); String line1 = result1.readLine(); assertTrue("The file_contexts.bin file did not include the AOSP entries:\n" <|startfocus|> + line1 + "\n", line1.equals("equal") || line1.equals("subset")); <|endfocus|> } } /** * Tests that the property_contexts file on the device contains * the standard AOSP entries. * * @throws Exception */ @CddTest(requirement="9.7") public void testAospPropertyContexts() throws Exception { /* obtain property_contexts file from running device */ devicePcFile = File.createTempFile("property_contexts", ".tmp"); devicePcFile.deleteOnExit();
code_review:  This is essentially a duplicate of lines 325-336. Can we move this to it's own function and avoid the duplication? 
target code: ProcessBuilder pb1 = new ProcessBuilder(checkFc.getAbsolutePath(), "-c", aospFcFile.getAbsolutePath(), deviceFcFile.getAbsolutePath()); pb1.redirectOutput(ProcessBuilder.Redirect.PIPE); pb1.redirectErrorStream(true); Process p1 = pb1.start(); p1.waitFor(); BufferedReader result1 = new BufferedReader(new InputStreamReader(p1.getInputStream())); String line1 = result1.readLine(); assertTrue("The file_contexts.bin file did not include the AOSP entries:\n" + line + "\n", line.equals("equal") || line.equals("subset")); } } /** * Tests that the property_contexts file on the device contains * the standard AOSP entries. * * @throws Exception */ @CddTest(requirement="9.7") public void testAospPropertyContexts() throws Exception { /* obtain property_contexts file from running device */ devicePcFile = File.createTempFile("property_contexts", ".tmp"); devicePcFile.deleteOnExit();
response: private static TDescribeDbResult describeDbExtended(Db db) { TDescribeDbResult descResult = new TDescribeDbResult(); org.apache.hadoop.hive.metastore.api.Database msDb = db.getMetaStoreDb(); String ownerName = null; PrincipalType ownerType = null; Map<String, String> params = null; PrincipalPrivilegeSet privileges = null; if (msDb != null) { location = msDb.getLocationUri(); comment = msDb.getDescription(); ownerName = msDb.getOwnerName(); ownerType = msDb.getOwnerType(); params = msDb.getParameters(); privileges = msDb.getPrivileges(); } TColumnValue dbNameCol = new TColumnValue(); dbNameCol.setString_val(db.getName()); TColumnValue dbLocationCol = new TColumnValue(); dbLocationCol.setString_val(Objects.toString(location, "")); TColumnValue commentCol = new TColumnValue(); commentCol.setString_val(Objects.toString(comment, "")); descResult.results.add(dbNameCol); descResult.results.add(dbLocationCol); descResult.results.add(commentCol); return descResult; } if (revisionDelta != null) { Map<EStructuralFeature, CDOFeatureDelta> featureDeltas = revisionDelta.getFeatureDeltaMap(); featureDeltas.remove(featureDelta.getFeature()); if (featureDeltas.isEmpty()) { cleanRevisions.remove(object); revisionDeltas.remove(id); lastSavepoint.getDirtyObjects().remove(id); if (lastSavepoint.getReattachedObjects().containsKey(id)) { lastSavepoint.getReattachedObjects().remove(id); lastSavepoint.getDetachedObjects().remove(id); } lastSavepoint.getDirtyObjects().remove(id); object.cdoInternalSetRevision(cleanRevision); changeState(object, CDOState.CLEAN); } } if (revisionDeltas.isEmpty()) { transaction.setDirty(false); } CDOTransactionHandler1[] handlers = transaction.getTransactionHandlers1(); for (int i = 0; i < handlers.length; i++) { CDOTransactionHandler1 handler = handlers[i]; if (handler instanceof WithUndo) { WithUndo withUndo = (WithUndo) handler; withUndo.undoingObject(transaction, object, featureDelta); } } return result; import org.apache.hadoop.hbase.Cluster

sample: 488
buggy_code:  BufferedWriter writer = new BufferedWriter(new FileWriter(sourceList.getAbsolutePath())); for (String f : files) { writer.write(f); writer.write('\n'); } writer.close(); commandLine.add('@' + sourceList.getAbsolutePath()); } @Override @Nonnull public AndroidToolchain setAndroidMinApiLevel(@Nonnull String minApiLevel) throws Exception { this.minApiLevel = minApiLevel; return this; } <|startfocus|> abstract boolean isDesugarEnabled(); <|endfocus|> } 
code_review:  nit protected ? 
target code: BufferedWriter writer = new BufferedWriter(new FileWriter(sourceList.getAbsolutePath())); for (String f : files) { writer.write(f); writer.write('\n'); } writer.close(); commandLine.add('@' + sourceList.getAbsolutePath()); } @Override @Nonnull public AndroidToolchain setAndroidMinApiLevel(@Nonnull String minApiLevel) throws Exception { this.minApiLevel = minApiLevel; return this; } protected abstract boolean isDesugarEnabled(); }
response: protected BufferedWriter writer = new BufferedWriter(new FileWriter(sourceList.getAbsolutePath())); for (String f : files) { writer.write(f); writer.write('\n'); } writer.close(); commandLine.add('@' + sourceList.getAbsolutePath()); } @Override @Nonnull public AndroidToolchain setAndroidMinApiLevel(@Nonnull String minApiLevel) throws Exception { this.minApiLevel = minApiLevel; return this; } abstract boolean isDesugarEnabled();

sample: 489
buggy_code:  public void run() { RenderScript pRS = RenderScript.create(mCtx); final int width = 100; final int height = 100; <|startfocus|> Allocation input1D = Allocation.createSized(pRS, Element.U8(pRS), width * height, Allocation.USAGE_SCRIPT); <|endfocus|> final Allocation output1D = Allocation.createTyped(pRS, input1D.getType()); Type.Builder typeBuilder = new Type.Builder(pRS, Element.U8(pRS)); typeBuilder.setX(width); typeBuilder.setY(height); Type ty = typeBuilder.create(); final Allocation input2D = Allocation.createTyped(pRS, ty); final Allocation output2D = Allocation.createTyped(pRS, ty); ScriptIntrinsicBlur scriptBlur = ScriptIntrinsicBlur.create(pRS, Element.U8(pRS)); scriptBlur.setRadius(25f); boolean failed = false; try { scriptBlur.setInput(input1D); } catch (RSIllegalArgumentException e) { scriptBlur.setInput(input2D); try { scriptBlur.forEach(output1D); } catch (RSIllegalArgumentException e1) { scriptBlur.forEach(output2D);
code_review:  You need to remove "Allocation " here and elsewhere. 
target code: public void run() { RenderScript pRS = RenderScript.create(mCtx); final int width = 100; final int height = 100; input1D = Allocation.createSized(RS, Element.U8(RS), width * height, Allocation.USAGE_SCRIPT); final Allocation output1D = Allocation.createTyped(pRS, input1D.getType()); Type.Builder typeBuilder = new Type.Builder(pRS, Element.U8(pRS)); typeBuilder.setX(width); typeBuilder.setY(height); Type ty = typeBuilder.create(); final Allocation input2D = Allocation.createTyped(pRS, ty); final Allocation output2D = Allocation.createTyped(pRS, ty); ScriptIntrinsicBlur scriptBlur = ScriptIntrinsicBlur.create(pRS, Element.U8(pRS)); scriptBlur.setRadius(25f); boolean failed = false; try { scriptBlur.setInput(input1D); } catch (RSIllegalArgumentException e) { scriptBlur.setInput(input2D); try { scriptBlur.forEach(output1D); } catch (RSIllegalArgumentException e1) { scriptBlur.forEach(output2D);
response: public void run() { RenderScript pRS = RenderScript.create(mCtx); final int width = 100; final int height = 100; Allocation input1D = Allocation.createSized(pRS, Element.U8(pRS), width * height, Allocation.USAGE_SCRIPT); final Allocation output1D = Allocation.createTyped(pRS, input1D.getType()); Type.Builder typeBuilder = new Type.Builder(pRS, Element.U8(pRS)); typeBuilder.setX(width); typeBuilder.setY(height); Type ty = typeBuilder.create(); final Allocation input2D = Allocation.createTyped(pRS, ty); final Allocation output2D = Allocation.createTyped(pRS, ty); ScriptIntrinsicBlur scriptBlur = ScriptIntrinsicBlur.create(pRS, Element.U8(pRS)); scriptBlur.setRadius(25f); boolean failed = false; try { scriptBlur.setInput(input1D); } catch (RSIllegalArgumentException e) { scriptBlur.setInput(input2D); try { scriptBlur.forEach(output1D); } catch (RSIllegalArgumentException e1) { scriptBlur.forEach(output2D); } } }

sample: 490
buggy_code:  * the License. */ package com.android.rs.test_compat; import android.content.Context; import android.content.res.Resources; import android.support.v8.renderscript.Allocation; import android.support.v8.renderscript.Element; import android.support.v8.renderscript.RenderScript; import android.support.v8.renderscript.RSIllegalArgumentException; import android.support.v8.renderscript.ScriptIntrinsicBlur; import android.support.v8.renderscript.Type; import android.util.Log; public class UT_blur_validation extends UnitTest { <|startfocus|> private static final int ARRAY_SIZE = 256; <|endfocus|> private static final String TAG = "ScriptIntrinsicBlur validation"; protected UT_blur_validation(RSTestCore rstc, Resources res, Context ctx) { super(rstc, TAG, ctx); } public void run() { RenderScript pRS = RenderScript.create(mCtx); final int width = 100; final int height = 100; Allocation input1D = Allocation.createSized(pRS, Element.U8(pRS), width * height, Allocation.USAGE_SCRIPT); final Allocation output1D = Allocation.createTyped(pRS, input1D.getType()); 
code_review:  Is this variable used/needed? 
target code: * the License. */ package com.android.rs.test_compat; import android.content.Context; import android.content.res.Resources; import android.support.v8.renderscript.Allocation; import android.support.v8.renderscript.Element; import android.support.v8.renderscript.RenderScript; import android.support.v8.renderscript.RSIllegalArgumentException; import android.support.v8.renderscript.ScriptIntrinsicBlur; import android.support.v8.renderscript.Type; import android.util.Log; public class UT_blur_validation extends UnitTest { private static final String TAG = "ScriptIntrinsicBlur validation"; protected UT_blur_validation(RSTestCore rstc, Resources res, Context ctx) { super(rstc, TAG, ctx); } public void run() { RenderScript pRS = RenderScript.create(mCtx); final int width = 100; final int height = 100; Allocation input1D = Allocation.createSized(pRS, Element.U8(pRS), width * height, Allocation.USAGE_SCRIPT); final Allocation output1D = Allocation.createTyped(pRS, input1D.getType());
response: package com.android.rs.test_compat; import android.content.Context; import android.content.res.Resources; import android.support.v8.renderscript.Allocation; import android.support.v8.renderscript.Element; import android.support.v8.renderscript.RenderScript; import android.support.v8.renderscript.RSIllegalArgumentException; import android.support.v8.renderscript.ScriptIntrinsicBlur; import android.support.v8.renderscript.Type; import android.util.Log; public class UT_blur_validation extends UnitTest { private static final String TAG = "ScriptIntrinsicBlur validation"; protected UT_blur_validation(RSTestCore rstc, Resources res, Context ctx) { super(rstc, TAG, ctx); } public void run() { RenderScript pRS = RenderScript.create(mCtx); final int width = 100; final int height = 100; Allocation input1D = Allocation.createSized(pRS, Element.U8(pRS), width * height, Allocation.USAGE_SCRIPT); final Allocation output1D = Allocation.createTyped(pRS, input1D.getType()); } }

sample: 491
buggy_code:  public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); if ((bondState != BluetoothDevice.BOND_NONE) && (bondState != BluetoothDevice.BOND_BONDED)) { return; } } else if (action.equals(ACTION_DISMISS_PAIRING)) { <|startfocus|> Log.d(TAG, "Noitifaction cancel for " + mDevice.getAddress() + " (" + <|endfocus|> mDevice.getName() + ")"); } else { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); Log.d(TAG, "Dismiss pairing for " + mDevice.getAddress() + " (" + mDevice.getName() + "), BondState: " + bondState); } stopForeground(true); stopSelf();
code_review:  Notification cancelled ? 
target code: public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); if ((bondState != BluetoothDevice.BOND_NONE) && (bondState != BluetoothDevice.BOND_BONDED)) { return; } } else if (action.equals(ACTION_DISMISS_PAIRING)) { Log.d(TAG, "Notification cancel " + mDevice.getAddress() + " (" + mDevice.getName() + ")"); } else { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); Log.d(TAG, "Dismiss pairing for " + mDevice.getAddress() + " (" + mDevice.getName() + "), BondState: " + bondState); } stopForeground(true); stopSelf();
response: public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); if ((bondState != BluetoothDevice.BOND_NONE) && (bondState != BluetoothDevice.BOND_BONDED)) { return; } } else if (action.equals(ACTION_DISMISS_PAIRING)) { Log.d(TAG, "Notification cancel for " + mDevice.getAddress() + " (" + mDevice.getName() + ")"); } else { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); Log.d(TAG, "Dismiss pairing for " + mDevice.getAddress() + " (" + mDevice.getName() + "), BondState: " + bondState); } stopForeground(true); stopSelf(); }

sample: 492
buggy_code:  public void sendUssd(String ussdMessage) throws ImsException { logi("sendUssd :: ussdMessage=" + ussdMessage); synchronized(mLockObj) { if (mSession == null) { loge("sendUssd :: "); throw new ImsException("No call session", ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED); } mSession.sendUssd(ussdMessage); } } /** <|startfocus|> * TODO: Delete this method and replace it with a thread that listens to the opened pipe. */ public void sendRttMessage(String rttMessage) { } /** <|endfocus|> * Sends a user-requested RTT upgrade request. */ public void sendRttModifyRequest() { logi("sendRttModifyRequest"); synchronized(mLockObj) { if (mSession == null) { loge("sendRttModifyRequest::no session"); } if (mCallProfile.mMediaProfile.isRttCall()) { logi("sendRttModifyRequest::Already RTT call, ignoring."); return; } // Make a copy of the current ImsCallProfile and modify it to enable RTT Parcel p = Parcel.obtain();
code_review:  Is this needed? 
target code: public void sendUssd(String ussdMessage) throws ImsException { logi("sendUssd :: ussdMessage=" + ussdMessage); synchronized(mLockObj) { if (mSession == null) { loge("sendUssd :: "); throw new ImsException("No call session", ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED); } mSession.sendUssd(ussdMessage); } } /** * Sends a user-requested RTT upgrade request. */ public void sendRttModifyRequest() { logi("sendRttModifyRequest"); synchronized(mLockObj) { if (mSession == null) { loge("sendRttModifyRequest::no session"); } if (mCallProfile.mMediaProfile.isRttCall()) { logi("sendRttModifyRequest::Already RTT call, ignoring."); return; } // Make a copy of the current ImsCallProfile and modify it to enable RTT Parcel p = Parcel.obtain();
response: public void sendUssd(String ussdMessage) throws ImsException { logi("sendUssd :: ussdMessage=" + ussdMessage); synchronized(mLockObj) { if (mSession == null) { loge("sendUssd :: "); throw new ImsException("No call session", ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED); } mSession.sendUssd(ussdMessage); } } public void sendRttMessage(String rttMessage) { } public void sendRttModifyRequest() { logi("sendRttModifyRequest"); synchronized(mLockObj) { if (mSession == null) { loge("sendRttModifyRequest::no session"); } if (mCallProfile.mMediaProfile.isRttCall()) { logi("sendRttModifyRequest::Already RTT call, ignoring."); return; } Parcel p = Parcel.obtain(); // Modify the ImsCallProfile to enable RTT ImsCallProfile modifiedProfile = new ImsCallProfile(mCallProfile); modifiedProfile.mMediaProfile.setRttCall(true); p.writeParcelable(modifiedProfile, 0); try { mSession.sendRttModifyRequest(p); } catch (RemoteException e) { loge("sendRttModifyRequest::RemoteException: " + e); } p.recycle(); } }

sample: 493
buggy_code: <|startfocus|> public static List<TimeZone> getTimeZonesWithUniqueOffsets(String country) { <|endfocus|> synchronized(sLastUniqueLockObj) { if ((country != null) && country.equals(sLastUniqueCountry)) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets(" + country + "): return cached version"); } return sLastUniqueZoneOffsets; } } Collection<TimeZone> zones = getTimeZones(country); ArrayList<TimeZone> uniqueTimeZones = new ArrayList<>(); for (TimeZone zone : zones) { // See if we already have this offset, // Using slow but space efficient and these are small. boolean found = false; for (int i = 0; i < uniqueTimeZones.size(); i++) { if (uniqueTimeZones.get(i).getRawOffset() == zone.getRawOffset()) { found = true; break; } } if (!found) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets: add unique offset=" +
code_review:  so you're switching what this returns? :( I think we need to be consistent, esp given the function names don't provide any hints 
target code: public static List<String> getTimeZoneIdsWithUniqueOffsets(String country) { synchronized(sLastUniqueLockObj) { if ((country != null) && country.equals(sLastUniqueCountry)) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets(" + country + "): return cached version"); } return sLastUniqueZoneOffsets; } } Collection<TimeZone> zones = getTimeZones(country); ArrayList<TimeZone> uniqueTimeZones = new ArrayList<>(); for (TimeZone zone : zones) { // See if we already have this offset, // Using slow but space efficient and these are small. boolean found = false; for (int i = 0; i < uniqueTimeZones.size(); i++) { if (uniqueTimeZones.get(i).getRawOffset() == zone.getRawOffset()) { found = true; break; } } if (!found) { if (DBG) { Log.d(TAG, "getTimeZonesWithUniqueOffsets: add unique offset=" +
response: public static List<TimeZone> getUniqueOffsetTimeZones(String country) { synchronized (sLastUniqueLockObj) { if (country != null && country.equals(sLastUniqueCountry)) { if (DBG) { Log.d(TAG, "getUniqueOffsetTimeZones(" + country + "): return cached version"); } return sLastUniqueZoneOffsets; } } Collection<TimeZone> zones = getTimeZones(country); ArrayList<TimeZone> uniqueTimeZones = new ArrayList<>(); for (TimeZone zone : zones) { boolean found = false; for (int i = 0; i < uniqueTimeZones.size(); i++) { if (uniqueTimeZones.get(i).getRawOffset() == zone.getRawOffset()) { found = true; break; } } if (!found) { if (DBG) { Log.d(TAG, "getUniqueOffsetTimeZones: add unique offset=" + zone.getRawOffset()); } uniqueTimeZones.add(zone); } } synchronized (sLastUniqueLockObj) { sLastUniqueCountry = country; sLastUniqueZoneOffsets = uniqueTimeZones; } return uniqueTimeZones; }

sample: 494
buggy_code:  return mgr.isVolteProvisioned(); } } return true; } /** * Indicates whether VoLTE is provisioned on this slot. */ public boolean isVolteProvisionedOnDeviceForSlot() { if (getBooleanCarrierConfigForSlot( CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { return isVolteProvisioned(); } return true; } /** * Indicates whether VoWifi is provisioned on device. * <|startfocus|> * When CarrierConfig KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL is true, and VoLTE is not <|endfocus|> * provisioned on device, this method returns false. * * @deprecated Does not support MSIM devices. Please use * {@link #isWfcProvisionedOnDeviceForSlot()} instead. */ public static boolean isWfcProvisionedOnDevice(Context context) { if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) { if (!isVolteProvisionedOnDevice(context)) { return false; } } if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
code_review:  KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL? 
target code: return mgr.isVolteProvisioned(); } } return true; } /** * Indicates whether VoLTE is provisioned on this slot. */ public boolean isVolteProvisionedOnDeviceForSlot() { if (getBooleanCarrierConfigForSlot( CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { return isVolteProvisioned(); } return true; } /** * Indicates whether VoWifi is provisioned on device. * * When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is not * provisioned on device, this method returns false. * * @deprecated Does not support MSIM devices. Please use * {@link #isWfcProvisionedOnDeviceForSlot()} instead. */ public static boolean isWfcProvisionedOnDevice(Context context) { if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) { if (!isVolteProvisionedOnDevice(context)) { return false; } } if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
response: return mgr.isVolteProvisioned(); } } return true; } public boolean isVolteProvisionedOnDeviceForSlot() { if (getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { return isVolteProvisioned(); } return true; } public static boolean isWfcProvisionedOnDevice(Context context) { if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) { if (!isVolteProvisionedOnDevice(context)) { return false; } } if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { return true; } return false; }

sample: 495
buggy_code:  return false; } } if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { ImsManager mgr = ImsManager.getInstance(context, SubscriptionManager.getDefaultVoicePhoneId()); if (mgr != null) { return mgr.isWfcProvisioned(); } } return true; } /** * Indicates whether VoWifi is provisioned on slot. * <|startfocus|> * When CarrierConfig KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL is true, and VoLTE is not <|endfocus|> * provisioned on device, this method returns false. */ public boolean isWfcProvisionedOnDeviceForSlot() { if (getBooleanCarrierConfigForSlot( CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) { if (!isVolteProvisionedOnDeviceForSlot()) { return false; } } if (getBooleanCarrierConfigForSlot( CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { return isWfcProvisioned(); } return true; } /** * Indicates whether VT is provisioned on device * * @deprecated Does not support MSIM devices. Please use
code_review:  same as above 
target code: return false; } } if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { ImsManager mgr = ImsManager.getInstance(context, SubscriptionManager.getDefaultVoicePhoneId()); if (mgr != null) { return mgr.isWfcProvisioned(); } } return true; } /** * Indicates whether VoWifi is provisioned on slot. * * When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is not * provisioned on device, this method returns false. */ public boolean isWfcProvisionedOnDeviceForSlot() { if (getBooleanCarrierConfigForSlot( CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) { if (!isVolteProvisionedOnDeviceForSlot()) { return false; } } if (getBooleanCarrierConfigForSlot( CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { return isWfcProvisioned(); } return true; } /** * Indicates whether VT is provisioned on device * * @deprecated Does not support MSIM devices. Please use
response: mGotCountryCode = false; pollStateDone(); break; default: pollingContext[0]++; cm.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR_CDMA, pollingContext)); pollingContext[0]++; cm.getRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION_CDMA, pollingContext)); pollingContext[0]++; cm.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE_CDMA, pollingContext)); break; } private static String networkTypeToString(int type) { String ret = "unknown"; switch (type) { case DATA_ACCESS_CDMA_IS95A: case DATA_ACCESS_CDMA_IS95B: case DATA_ACCESS_CDMA_1xRTT: ret = "CDMA"; break; case DATA_ACCESS_CDMA_EvDo_0: ret = "EVDO_0"; break; } mIncomingSco = createScoSocket(); mIncomingSco.accept(); break; case SCO_CONNECTED: if (msg.arg1 == ScoSocket.STATE_CONNECTED && isHeadsetConnected() && mConnectedSco == null) { if (VDBG) log("Routing audio for outgoing SCO conection"); mConnectedSco = (ScoSocket)msg.obj; mAudioManager.setBluetoothScoOn(true); if (isCellularCallInProgress()) { broadcastAudioStateIntent(BluetoothHeadset.AUDIO_STATE_CONNECTED, mHeadset.getRemoteDevice()); } else if ((mHFScoState == HF_STATE_SCO_VIRTUALCALL_SETUP) || (mHFScoState == HF_STATE_SCO_VIRTUALCALL_TRANSFERRED)) { mHFScoState = HF_STATE_SCO_VIRTUALCALL_ACTIVE; broadcastVirtualCallStateIntent(BluetoothHeadset.VIRTUALCALL_STATE_CONNECTED); } if (DBG) log("mHandler: Updated mHFScoState:"+ mHFScoState); } else if (msg.arg1 == ScoSocket.STATE_CONNECTED) { return false; } if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) { ImsManager mgr = ImsManager.getInstance(context, SubscriptionManager.getDefaultVoicePhoneId()); if (mgr != null) { return mgr.isWfcProvisioned(); } } return true; } public boolean isWfcProvisionedOnDeviceForSlot() { if (getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) { if (!isVolteProvision

sample: 496
buggy_code:  private void sendTetherStateChangedBroadcast() { if (!getConnectivityManager().isTetheringSupported()) return; <|startfocus|> final ArrayList<String> availableList = new ArrayList<String>(); final ArrayList<String> tetherList = new ArrayList<String>(); final ArrayList<String> hotspotList = new ArrayList<String>(); final ArrayList<String> erroredList = new ArrayList<String>(); <|endfocus|> boolean wifiTethered = false; boolean usbTethered = false; boolean bluetoothTethered = false; final TetheringConfiguration cfg = mConfig; synchronized (mPublicSync) { for (int i = 0; i < mTetherStates.size(); i++) { TetherState tetherState = mTetherStates.valueAt(i); String iface = mTetherStates.keyAt(i); if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) { erroredList.add(iface); } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) { availableList.add(iface); } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_HOTSPOT) { hotspotList.add(iface);
code_review:  Optional: change to just "ArrayList<>()" 
target code: private void sendTetherStateChangedBroadcast() { if (!getConnectivityManager().isTetheringSupported()) return; ArrayList<String> availableList = new ArrayList<String>(); ArrayList<String> activeList = new ArrayList<String>(); ArrayList<String> erroredList = new ArrayList<String>(); boolean wifiTethered = false; boolean usbTethered = false; boolean bluetoothTethered = false; final TetheringConfiguration cfg = mConfig; synchronized (mPublicSync) { for (int i = 0; i < mTetherStates.size(); i++) { TetherState tetherState = mTetherStates.valueAt(i); String iface = mTetherStates.keyAt(i); if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) { erroredList.add(iface); } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) { availableList.add(iface); } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_HOTSPOT) { hotspotList.add(iface);
response: private void sendTetherStateChangedBroadcast() { if (!getConnectivityManager().isTetheringSupported()) return; final ArrayList<String> availableList = new ArrayList<>(); final ArrayList<String> tetherList = new ArrayList<>(); final ArrayList<String> hotspotList = new ArrayList<>(); final ArrayList<String> erroredList = new ArrayList<>(); boolean wifiTethered = false; boolean usbTethered = false; boolean bluetoothTethered = false; final TetheringConfiguration cfg = mConfig; synchronized (mPublicSync) { for (int i = 0; i < mTetherStates.size(); i++) { TetherState tetherState = mTetherStates.valueAt(i); String iface = mTetherStates.keyAt(i); if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) { erroredList.add(iface); } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) { availableList.add(iface); } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_HOTSPOT) { hotspotList.add(iface); } } } // Rest of the code... }

sample: 497
buggy_code: import android.telephony.CarrierConfigManager; import android.os.Message; import android.os.Messenger; import com.android.internal.util.AsyncChannel; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.ArgumentCaptor; import java.util.List; @RunWith(AndroidJUnit4.class) @SmallTest public class NsdManagerTest { @Mock Context mContext; @Mock INsdManager mService; MockServiceHandler mServiceHandler; <|startfocus|> long mTimeoutMs = 100; <|endfocus|> @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); mServiceHandler = spy(MockServiceHandler.make(mContext)); when(mService.getMessenger()).thenReturn(new Messenger(mServiceHandler)); } @Test public void testResolveService() { NsdManager manager = makeManager(); NsdServiceInfo request = new NsdServiceInfo("a name", "a type"); NsdServiceInfo reply = new NsdServiceInfo("resolved name", "resolved type"); NsdManager.ResolveListener listener = mock(NsdManager.ResolveListener.class); manager.resolveService(request, listener);
code_review:  Consider static final. 
target code: import android.telephony.CarrierConfigManager; import android.os.Message; import android.os.Messenger; import com.android.internal.util.AsyncChannel; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.ArgumentCaptor; import java.util.List; @RunWith(AndroidJUnit4.class) @SmallTest public class NsdManagerTest { @Mock Context mContext; @Mock INsdManager mService; MockServiceHandler mServiceHandler; long mTimeoutMs = 100; // non-final so that tests can adjust the value. @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); mServiceHandler = spy(MockServiceHandler.make(mContext)); when(mService.getMessenger()).thenReturn(new Messenger(mServiceHandler)); } @Test public void testResolveService() { NsdManager manager = makeManager(); NsdServiceInfo request = new NsdServiceInfo("a name", "a type"); NsdServiceInfo reply = new NsdServiceInfo("resolved name", "resolved type"); NsdManager.ResolveListener listener = mock(NsdManager.ResolveListener.class); manager.resolveService(request, listener);
response: import android.telephony.CarrierConfigManager; import android.os.Message; import android.os.Messenger; import com.android.internal.util.AsyncChannel; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.ArgumentCaptor; import java.util.List; @RunWith(AndroidJUnit4.class) @SmallTest public class NsdManagerTest { @Mock Context mContext; @Mock INsdManager mService; MockServiceHandler mServiceHandler; private static final long TIMEOUT_MS = 100; @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); mServiceHandler = spy(MockServiceHandler.make(mContext)); when(mService.getMessenger()).thenReturn(new Messenger(mServiceHandler)); } @Test public void testResolveService() { NsdManager manager = makeManager(); NsdServiceInfo request = new NsdServiceInfo("a name", "a type"); NsdServiceInfo reply = new NsdServiceInfo("resolved name", "resolved type"); NsdManager.ResolveListener listener = mock(NsdManager.ResolveListener.class); manager.resolveService(request, listener); } }

sample: 498
buggy_code:  public void testResolveService() { NsdManager manager = makeManager(); <|startfocus|> NsdServiceInfo request = new NsdServiceInfo("a name", "a type"); NsdServiceInfo reply = new NsdServiceInfo("resolved name", "resolved type"); <|endfocus|> NsdManager.ResolveListener listener = mock(NsdManager.ResolveListener.class); manager.resolveService(request, listener); int key1 = verifyRequest(NsdManager.RESOLVE_SERVICE); int err = 33; sendResponse(NsdManager.RESOLVE_SERVICE_FAILED, err, key1, null); verify(listener, timeout(mTimeoutMs).times(1)).onResolveFailed(request, err); manager.resolveService(request, listener); int key2 = verifyRequest(NsdManager.RESOLVE_SERVICE); sendResponse(NsdManager.RESOLVE_SERVICE_SUCCEEDED, 0, key2, reply); verify(listener, timeout(mTimeoutMs).times(1)).onServiceResolved(reply);
code_review:  Nit: is this a realistic name? Can these names contain spaces? 
target code: public void testResolveService() { NsdManager manager = makeManager(); NsdServiceInfo request = new NsdServiceInfo("a_name", "a_type"); NsdServiceInfo reply = new NsdServiceInfo("resolved_name", "resolved_type"); NsdManager.ResolveListener listener = mock(NsdManager.ResolveListener.class); manager.resolveService(request, listener); int key1 = verifyRequest(NsdManager.RESOLVE_SERVICE); int err = 33; sendResponse(NsdManager.RESOLVE_SERVICE_FAILED, err, key1, null); verify(listener, timeout(mTimeoutMs).times(1)).onResolveFailed(request, err); manager.resolveService(request, listener); int key2 = verifyRequest(NsdManager.RESOLVE_SERVICE); sendResponse(NsdManager.RESOLVE_SERVICE_SUCCEEDED, 0, key2, reply); verify(listener, timeout(mTimeoutMs).times(1)).onServiceResolved(reply);
response: public void testResolveService() { NsdManager manager = makeManager(); NsdServiceInfo request = new NsdServiceInfo("a name", "a type"); NsdServiceInfo reply = new NsdServiceInfo("resolved name", "resolved type"); NsdManager.ResolveListener listener = mock(NsdManager.ResolveListener.class); manager.resolveService(request, listener); int key1 = verifyRequest(NsdManager.RESOLVE_SERVICE); int err = 33; sendResponse(NsdManager.RESOLVE_SERVICE_FAILED, err, key1, null); verify(listener, timeout(mTimeoutMs).times(1)).onResolveFailed(request, err); manager.resolveService(request, listener); int key2 = verifyRequest(NsdManager.RESOLVE_SERVICE); sendResponse(NsdManager.RESOLVE_SERVICE_SUCCEEDED, 0, key2, reply); verify(listener, timeout(mTimeoutMs).times(1)).onServiceResolved(reply); }

sample: 499
buggy_code: <|startfocus|> public static MockServiceHandler make(Context context) { <|endfocus|> HandlerThread t = new HandlerThread("mock-service-handler"); t.start(); return new MockServiceHandler(t.getLooper(), context);
code_review:  This type of method is usually called "create" or "from". 
target code: public static MockServiceHandler create(Context context) { HandlerThread t = new HandlerThread("mock-service-handler"); t.start(); return new MockServiceHandler(t.getLooper(), context);
response: public static MockServiceHandler create(Context context) { HandlerThread t = new HandlerThread("mock-service-handler"); t.start(); return new MockServiceHandler(t.getLooper(), context); }

sample: 500
buggy_code:  mConnected.countDown(); return; case AsyncChannel.CMD_CHANNEL_DISCONNECTED: Log.e(TAG, "Channel lost"); return; default: break; } final NsdServiceInfo ns = getNsdService(key); final Object listener = getListener(key); if (listener == null) { <|startfocus|> // Expected for replies/timouts to resolveService() if (what != RESOLVE_SERVICE_SUCCEEDED || what != RESOLVE_SERVICE_FAILED || what != RESOLVE_SERVICE_TIMEOUT) { Log.d(TAG, "Stale key " + key); } <|endfocus|> return; } if (DBG) { Log.d(TAG, "received " + nameOf(what) + " for key " + key + ", service " + ns); } switch (what) { case DISCOVER_SERVICES_STARTED: String s = getNsdServiceInfoType((NsdServiceInfo) message.obj); ((DiscoveryListener) listener).onDiscoveryStarted(s); break; case DISCOVER_SERVICES_FAILED: removeListener(key); ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1); break; case SERVICE_FOUND:
code_review:  is this if statement always true? 
target code: mConnected.countDown(); return; case AsyncChannel.CMD_CHANNEL_DISCONNECTED: Log.e(TAG, "Channel lost"); return; default: break; } final NsdServiceInfo ns = getNsdService(key); final Object listener = getListener(key); if (listener == null) { // Another message associated with that key notified the listener first. // This is expected for replies and timeouts to resolveService(). return; } if (DBG) { Log.d(TAG, "received " + nameOf(what) + " for key " + key + ", service " + ns); } switch (what) { case DISCOVER_SERVICES_STARTED: String s = getNsdServiceInfoType((NsdServiceInfo) message.obj); ((DiscoveryListener) listener).onDiscoveryStarted(s); break; case DISCOVER_SERVICES_FAILED: removeListener(key); ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1); break; case SERVICE_FOUND:
response: mConnected.countDown(); return; case AsyncChannel.CMD_CHANNEL_DISCONNECTED: Log.e(TAG, "Channel lost"); return; default: break; } final NsdServiceInfo ns = getNsdService(key); final Object listener = getListener(key); if (listener == null) { if (what != RESOLVE_SERVICE_SUCCEEDED || what != RESOLVE_SERVICE_FAILED || what != RESOLVE_SERVICE_TIMEOUT) { Log.d(TAG, "Stale key " + key); } return; } if (DBG) { Log.d(TAG, "received " + nameOf(what) + " for key " + key + ", service " + ns); } switch (what) { case DISCOVER_SERVICES_STARTED: String s = getNsdServiceInfoType((NsdServiceInfo) message.obj); ((DiscoveryListener) listener).onDiscoveryStarted(s); break; case DISCOVER_SERVICES_FAILED: removeListener(key); ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1); break; case SERVICE_FOUND:

sample: 501
buggy_code:  * * This extra represents the previous connection state. */ public static final String EXTRA_PREVIOUS_CONNECTION_STATE = "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** <|startfocus|> * Intent used to broadcast the change in MAC address of the * local Bluetooth adapter. <|endfocus|> * <p>Always contains the extra field {@link * #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local * Bluetooth MAC address. *
code_review:  "in the Bluetooth address" 
target code: * * This extra represents the previous connection state. */ public static final String EXTRA_PREVIOUS_CONNECTION_STATE = "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Intent used to broadcast the change in the Bluetooth address * of the local Bluetooth adapter. * <p>Always contains the extra field {@link * #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local * Bluetooth MAC address. *
response: public static final String EXTRA_PREVIOUS_CONNECTION_STATE = "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED";

sample: 502
buggy_code:  "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Intent used to broadcast the change in MAC address of the * local Bluetooth adapter. * <p>Always contains the extra field {@link <|startfocus|> * #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. <|endfocus|> * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local * Bluetooth MAC address. * * @hide */ public static final String EXTRA_BLUETOOTH_ADDRESS = "android.bluetooth.adapter.extra.BLUETOOTH_ADDRESS"; 
code_review:  Bluetooth 
target code: "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Intent used to broadcast the change in MAC address of the * local Bluetooth adapter. * <p>Always contains the extra field {@link * #EXTRA_BLUETOOTH_ADDRESS} containing the Bluetooth address. * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local * Bluetooth MAC address. * * @hide */ public static final String EXTRA_BLUETOOTH_ADDRESS = "android.bluetooth.adapter.extra.BLUETOOTH_ADDRESS";
response: "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE"; /** * Broadcast Action: The Bluetooth adapter state has changed in LE only mode. * @hide */ @SystemApi public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Intent used to broadcast the change in MAC address of the * local Bluetooth adapter. * <p>Always contains the extra field {@link #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local * Bluetooth MAC address. * * @hide */ public static final String EXTRA_BLUETOOTH_ADDRESS = "android.bluetooth.adapter.extra.BLUETOOTH_ADDRESS";

sample: 503
buggy_code:  * <p>Always contains the extra field {@link * #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local <|startfocus|> * Bluetooth MAC address. <|endfocus|> * * @hide */ public static final String EXTRA_BLUETOOTH_ADDRESS = "android.bluetooth.adapter.extra.BLUETOOTH_ADDRESS"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which
code_review:  Not needed 
target code: * <p>Always contains the extra field {@link * #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local * Bluetooth address. * * @hide */ public static final String EXTRA_BLUETOOTH_ADDRESS = "android.bluetooth.adapter.extra.BLUETOOTH_ADDRESS"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection * as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which
response: /** * <p>Always contains the extra field {@link * #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address. * * Note: only system level processes are allowed to send this defined broadcast. * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BLUETOOTH_ADDRESS_CHANGED} intent to store the local Bluetooth MAC address. * * @hide */ public static final String EXTRA_BLUETOOTH_ADDRESS = "android.bluetooth.adapter.extra.BLUETOOTH_ADDRESS"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be by BLE Always on enabled application to know the ACL_CONNECTED event when Bluetooth state in STATE_BLE_ON. This denotes GATT connection as Bluetooth LE is the only feature available in STATE_BLE_ON * * This is counterpart of {@link BluetoothDevice#ACTION_ACL_CONNECTED} which */

sample: 504
buggy_code:  String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME); if (DBG) Slog.d(TAG, "Bluetooth Adapter name changed to " + newName); if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS); if (newAddress != null) { <|startfocus|> if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress); <|endfocus|> storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found"); } }
code_review:  "MAC" not needed. 
target code: String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME); if (DBG) Slog.d(TAG, "Bluetooth Adapter name changed to " + newName); if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found"); } }
response: String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME); if (DBG) Slog.d(TAG, "Bluetooth Adapter name changed to " + newName); if (newName != null) { storeNameAndAddress(newName, null); } else if (BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter Address parameter found"); } }

sample: 505
buggy_code:  if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { <|startfocus|> if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found"); <|endfocus|> } }
code_review:  Same comment as above. 
target code: if (newName != null) { storeNameAndAddress(newName, null); } } else if (BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter address parameter found"); } }
response: if (newName != null) { storeNameAndAddress(newName, null); } else if (BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED.equals(action)) { String newAddress = intent.getStringExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS); if (newAddress != null) { if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress); storeNameAndAddress(null, newAddress); } else { if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found"); } }

sample: 506
buggy_code:  mErrorRecoveryRetryCounter = 0; mContentResolver = context.getContentResolver(); // Observe BLE scan only mode settings change. registerForBleScanModeChange(); mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>(); mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>(); IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); <|startfocus|> IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED); filter2.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter2); <|endfocus|> loadStoredNameAndAddress(); if (isBluetoothPersistedStateOn()) { if (DBG) Slog.d(TAG, "Startup: Bluetooth persisted state is ON."); mEnableExternal = true; } String airplaneModeRadios = Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS); if (airplaneModeRadios == null || airplaneModeRadios.contains(Settings.Global.RADIO_BLUETOOTH)) { mContentResolver.registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver); } 
code_review:  You can reuse the "filter" variable here: filter = new IntentFilter(...); ... 
target code: mErrorRecoveryRetryCounter = 0; mContentResolver = context.getContentResolver(); // Observe BLE scan only mode settings change. registerForBleScanModeChange(); mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>(); mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>(); IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); filter = new IntentFilter(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); loadStoredNameAndAddress(); if (isBluetoothPersistedStateOn()) { if (DBG) Slog.d(TAG, "Startup: Bluetooth persisted state is ON."); mEnableExternal = true; } String airplaneModeRadios = Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS); if (airplaneModeRadios == null || airplaneModeRadios.contains(Settings.Global.RADIO_BLUETOOTH)) { mContentResolver.registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver); }
response: mErrorRecoveryRetryCounter = 0; mContentResolver = context.getContentResolver(); // Observe BLE scan only mode settings change. registerForBleScanModeChange(); mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>(); mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>(); IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); filter = new IntentFilter(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); loadStoredNameAndAddress(); if (isBluetoothPersistedStateOn()) { if (DBG) Slog.d(TAG, "Startup: Bluetooth persisted state is ON."); mEnableExternal = true; } String airplaneModeRadios = Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS); if (airplaneModeRadios == null || airplaneModeRadios.contains(Settings.Global.RADIO_BLUETOOTH)) { mContentResolver.registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver ); }

sample: 507
buggy_code:  "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Intent used to broadcast the change in MAC address of the * local Bluetooth adapter. * <p>Always contains the extra field {@link #EXTRA_BD_ADDR} * containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast * * @hide */ <|startfocus|> public static final String ACTION_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BD_ADDR_CHANGED"; <|endfocus|> /** * Used as a String extra field in {@link * #ACTION_BD_ADDR_CHANGED} intent to store the local Bluetooth * MAC address. * * @hide */ public static final String EXTRA_BD_ADDR = "android.bluetooth.adapter.extra.BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection
code_review:  My preference is to move away from the obsoleted "BD" acronym and replace it with, say, "BT" or "BLUETOOTH" in the names. Same comment applies to the rest of the changes. 
target code: "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; /** * Intent used to broadcast the change in MAC address of the * local Bluetooth adapter. * <p>Always contains the extra field {@link #EXTRA_BD_ADDR} * containing the MAC address. * * Note: only system level processes are allowed to send this * defined broadcast * * @hide */ public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; /** * Used as a String extra field in {@link * #ACTION_BD_ADDR_CHANGED} intent to store the local Bluetooth * MAC address. * * @hide */ public static final String EXTRA_BD_ADDR = "android.bluetooth.adapter.extra.BD_ADDR"; /** * Broadcast Action: The notifys Bluetooth ACL connected event. This will be * by BLE Always on enabled application to know the ACL_CONNECTED event * when Bluetooth state in STATE_BLE_ON. This denotes GATT connection
response: public static final String ACTION_BLE_STATE_CHANGED = "android.bluetooth.adapter.action.BLE_STATE_CHANGED"; public static final String ACTION_BT_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_ADDR_CHANGED"; public static final String EXTRA_BT_ADDR = "android.bluetooth.adapter.extra.BT_ADDR"; public static final String ACTION_ACL_CONNECTED = "android.bluetooth.adapter.action.ACL_CONNECTED";

sample: 508
buggy_code:  Log.d(TAG, "Notification cancel " + mDevice.getAddress() + " (" + mDevice.getName() + ")"); mDevice.cancelPairingUserInput(); } else { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); Log.d(TAG, "Dismiss pairing for " + mDevice.getAddress() + " (" + mDevice.getName() + "), BondState: " + bondState); } stopForeground(true); stopSelf(); } }; <|startfocus|> @Override public void onCreate() { } <|endfocus|> @Override public int onStartCommand(Intent intent, int flags, int startId) { if (intent == null) { Log.e(TAG, "Can't start: null intent!"); stopSelf(); return START_NOT_STICKY; } Resources res = getResources(); Notification.Builder builder = new Notification.Builder(this) .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth) .setTicker(res.getString(R.string.bluetooth_notif_ticker)); PendingIntent pairIntent = PendingIntent.getActivity(this, 0,
code_review:  The tabbing here looks a little strange. 
target code: Log.d(TAG, "Notification cancel " + mDevice.getAddress() + " (" + mDevice.getName() + ")"); mDevice.cancelPairingUserInput(); } else { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); Log.d(TAG, "Dismiss pairing for " + mDevice.getAddress() + " (" + mDevice.getName() + "), BondState: " + bondState); } stopForeground(true); stopSelf(); } }; @Override public void onCreate() { } @Override public int onStartCommand(Intent intent, int flags, int startId) { if (intent == null) { Log.e(TAG, "Can't start: null intent!"); stopSelf(); return START_NOT_STICKY; } Resources res = getResources(); Notification.Builder builder = new Notification.Builder(this) .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth) .setTicker(res.getString(R.string.bluetooth_notif_ticker)); PendingIntent pairIntent = PendingIntent.getActivity(this, 0,
response: private boolean findMinAbs(RenderScript RS, float[] inputArray, String testName, ReduceFindMinAbs reduction) { final long javaTimeStart = java.lang.System.currentTimeMillis(); final float javaResult = findMinAbs(inputArray); final long javaTimeEnd = java.lang.System.currentTimeMillis(); final long rsTimeStart = java.lang.System.currentTimeMillis(); Allocation inputAllocation = Allocation.createSized(RS, Element.F32(RS), inputArray.length); final long copyTimeStart = java.lang.System.currentTimeMillis(); inputAllocation.copyFrom(inputArray); final long kernelTimeStart = java.lang.System.currentTimeMillis(); } private boolean findMinMat(RenderScript RS, int seed, int[] inputSize, int matSize, Element matElement, ReduceFindMinMat reduction) { final int length = inputSize[0]; final int matSizeSquared = matSize * matSize; final float[] inputArray = createInputArrayFloat(matSizeSquared * length, seed); final long javaTimeStart = java.lang.System.currentTimeMillis(); final float[] javaResult = findMinMat(inputArray, matSize); final long javaTimeEnd = java.lang.System.currentTimeMillis(); } boolean run(RenderScript RS, ScriptC_reduce s, int seed, int[] size); } @Override public void onCreate() { } @Override public int onStartCommand(Intent intent, int flags, int startId) { if (intent == null) { Log.e(TAG, "Can't start: null intent!"); stopSelf(); return START_NOT_STICKY; } Resources res = getResources(); Notification.Builder builder = new Notification.Builder(this) .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth) .setTicker(res.getString(R.string.bluetooth_notif_ticker)); PendingIntent pairIntent = PendingIntent.getActivity(this, 0,

sample: 509
buggy_code:  } /** * This method can assume EXTENDED_YEAR has been set. * @param millis milliseconds of the date fields (local midnight millis) * @param millisInDay milliseconds of the time fields; may be out * or range. * @return total zone offset (raw + DST) for the given moment <|startfocus|> * @deprecated This method suffers from a potential integer overflow and may be removed in a * future release. Overriding this method in subclasses will not have the desired effect. * See ICU ticket #11632. <|endfocus|> */ protected int computeZoneOffset(long millis, int millisInDay) { int[] offsets = new int[2]; long wall = millis + millisInDay; if (zone instanceof BasicTimeZone) { int duplicatedTimeOpt = (repeatedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_FORMER : BasicTimeZone.LOCAL_LATTER; int nonExistingTimeOpt = (skippedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_LATTER : BasicTimeZone.LOCAL_FORMER;
code_review:  Ok for now, but the plan in public ICU is to still call the old version if millisInDay fits into an int. 
target code: } /** * This method can assume EXTENDED_YEAR has been set. * @param millis milliseconds of the date fields (local midnight millis) * @param millisInDay milliseconds of the time fields; may be out * or range. * @return total zone offset (raw + DST) for the given moment * @deprecated This method suffers from a potential integer overflow and may be removed or * changed in a future release. See <a href="http://bugs.icu-project.org/trac/ticket/11632"> * ICU ticket #11632</a> for details. */ protected int computeZoneOffset(long millis, int millisInDay) { int[] offsets = new int[2]; long wall = millis + millisInDay; if (zone instanceof BasicTimeZone) { int duplicatedTimeOpt = (repeatedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_FORMER : BasicTimeZone.LOCAL_LATTER; int nonExistingTimeOpt = (skippedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_LATTER : BasicTimeZone.LOCAL_FORMER;
response: public class MyClass { public boolean processLine(String line, ErrorParserManager eoParser) { Matcher matcher = pattern.matcher(line); if (!matcher.matches()) { return false; } IFile fileName = eoParser.findFileName(matcher.group(1)); if (fileName != null) { int lineNumber = Integer.parseInt(matcher.group(2)); String description = matcher.group(4); int severity = Severity.findSeverityCode(matcher.group(3)); ProblemMarkerInfo info = new ProblemMarkerInfo(fileName, lineNumber, description, severity, null); eoParser.addProblemMarker(info); return true; } return false; } } public class CASTSimpleDeclSpecifier extends CASTBaseDeclSpecifier implements ICASTSimpleDeclSpecifier { private int simpleType; private boolean isSigned; private boolean isUnsigned; private boolean isShort; private boolean isLong; private boolean longlong; private boolean complex; private boolean imaginary; private IASTExpression fDeclTypeExpression; @Override public CASTSimpleDeclSpecifier copy() { return copy(CopyStyle.withoutLocations); } @Override public CASTSimpleDeclSpecifier copy(CopyStyle style) { CASTSimpleDeclSpecifier copy = new CASTSimpleDeclSpecifier(); return copy(copy, style); } protected <T extends CASTSimpleDeclSpecifier> T copy(T copy, CopyStyle style) { CASTSimpleDeclSpecifier target = copy; // Copy properties from this to target target.simpleType = this.simpleType; target.isSigned = this.isSigned; target.isUnsigned = this.isUnsigned; target.isShort = this.isShort; target.isLong = this.isLong; target.longlong = this.longlong; target.complex = this.complex; target.imaginary = this.imaginary; target.fDeclTypeExpression = this.fDeclTypeExpression; return copy; } } public class MyClass { static ICPPASTFunctionDefinition createFunctionSignatureWithEmptyBody(IASTDeclSpecifier newDeclSpec, IASTFunctionDeclarator newFuncDecl, IASTFunctionDefinition oldDefinition) { ICPPASTFunctionDefinition newFunc = null; newFuncDecl = adjustParamNames(newFuncDecl, oldDefinition); if (oldDefinition instanceof ICPPASTFunctionWithTryBlock)

sample: 510
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ public class Main { public static void main(String[] args) { System.loadLibrary(args[0]); testGetFieldId(TestClass.class, "intField", "I"); testGetFieldId(TestClass.class, "intField", "int"); testGetFieldId(TestClass.class, "intField", "Lint;"); testGetFieldId(TestClass.class, "stringField", "I");
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ public class Main { public static void main(String[] args) { System.loadLibrary(args[0]); testGetFieldId(TestClass.class, "intField", "I"); testGetFieldId(TestClass.class, "intField", "int"); testGetFieldId(TestClass.class, "intField", "Lint;"); testGetFieldId(TestClass.class, "stringField", "I");
response: * Copyright (C) 2017 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. public class Main { public static void main(String[] args) { System.loadLibrary(args[0]); testGetFieldId(TestClass.class, "intField", "I"); testGetFieldId(TestClass.class, "intField", "int"); testGetFieldId(TestClass.class, "intField", "Lint;"); testGetFieldId(TestClass.class, "stringField", "I"); } }

sample: 511
buggy_code:  * <tr><td>Android 7.0 (Nougat)</td> * <td><a href="http://site.icu-project.org/download/56">ICU 56.1</a></td> * <td><a href="http://cldr.unicode.org/index/downloads/cldr-28">CLDR 28</a></td> * <td><a href="http://www.unicode.org/versions/Unicode8.0.0/">Unicode 8.0</a></td></tr> <|startfocus|> * <tr><td>Android (TBD)</td> <|endfocus|> * <td><a href="http://site.icu-project.org/download/58">ICU 58.2</a></td> * <td><a href="http://cldr.unicode.org/index/downloads/cldr-30">CLDR 30.0.3</a></td> * <td><a href="http://www.unicode.org/versions/Unicode9.0.0/">Unicode 9.0</a></td></tr> * </table> * * <a name="default_locale"></a><h4>Be wary of the default locale</h3> * <p>Note that there are many convenience methods that automatically use the default locale, but
code_review:  just say "Android O" ? That's what it's called in the developer preview. 
target code: * <tr><td>Android 7.0 (Nougat)</td> * <td><a href="http://site.icu-project.org/download/56">ICU 56.1</a></td> * <td><a href="http://cldr.unicode.org/index/downloads/cldr-28">CLDR 28</a></td> * <td><a href="http://www.unicode.org/versions/Unicode8.0.0/">Unicode 8.0</a></td></tr> * <tr><td>Android O</td> * <td><a href="http://site.icu-project.org/download/58">ICU 58.2</a></td> * <td><a href="http://cldr.unicode.org/index/downloads/cldr-30">CLDR 30.0.3</a></td> * <td><a href="http://www.unicode.org/versions/Unicode9.0.0/">Unicode 9.0</a></td></tr> * </table> * * <a name="default_locale"></a><h4>Be wary of the default locale</h3> * <p>Note that there are many convenience methods that automatically use the default locale, but
response: <tr><td>Android (TBD)</td> <td><a href="http://site.icu-project.org/download/58">ICU 58.2</a></td> <td><a href="http://cldr.unicode.org/index/downloads/cldr-30">CLDR 30.0.3</a></td> <td><a href="http://www.unicode.org/versions/Unicode9.0.0/">Unicode 9.0</a></td></tr>

sample: 512
buggy_code:  // Disable native bind notify for now to avoid infinite loops. setNativeBindNotify(false); String transSym = SymbolMap.getOrDefault(method, nativeSym); System.out.println(method + " = " + nativeSym + " -> " + transSym); setNativeBindNotify(true); return transSym; } public static void doTest() throws Exception { Method say_hi_method = Transform.class.getDeclaredMethod("sayHi"); <|startfocus|> // Test we will autobind normally. <|endfocus|> Transform.sayHi2(); // Test we can get in the middle of autobind setNativeTransform(say_hi_method, "NoReallySayGoodbye"); Transform.sayHi(); // Test we can get in between manual bind. setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2"); rebindTransformClass(); Transform.sayHi(); // Test we can get rid of transform removeNativeTransform(say_hi_method); rebindTransformClass(); Transform.sayHi(); Main.bindAgentJNIForClass(Main.class); Main.bindAgentJNIForClass(Test986.class); } // Functions called from native code.
code_review:  That isn't necessary, 987 will test this. 
target code: // Disable native bind notify for now to avoid infinite loops. setNativeBindNotify(false); String transSym = SymbolMap.getOrDefault(method, nativeSym); System.out.println(method + " = " + nativeSym + " -> " + transSym); setNativeBindNotify(true); return transSym; } public static void doTest() throws Exception { Method say_hi_method = Transform.class.getDeclaredMethod("sayHi"); // Test we will bind fine if we make no changes. Transform.sayHi2(); // Test we can get in the middle of autobind setNativeTransform(say_hi_method, "NoReallySayGoodbye"); Transform.sayHi(); // Test we can get in between manual bind. setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2"); rebindTransformClass(); Transform.sayHi(); // Test we can get rid of transform removeNativeTransform(say_hi_method); rebindTransformClass(); Transform.sayHi(); Main.bindAgentJNIForClass(Main.class); Main.bindAgentJNIForClass(Test986.class); } // Functions called from native code.
response: // Disable native bind notify for now to avoid infinite loops. setNativeBindNotify(false); String transSym = SymbolMap.getOrDefault(method, nativeSym); setNativeBindNotify(true); return transSym; } public static void doTest() throws Exception { Method say_hi_method = Transform.class.getDeclaredMethod("sayHi"); Transform.sayHi2(); setNativeTransform(say_hi_method, "NoReallySayGoodbye"); Transform.sayHi(); setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2"); rebindTransformClass(); Transform.sayHi(); removeNativeTransform(say_hi_method); rebindTransformClass(); Transform.sayHi(); Main.bindAgentJNIForClass(Main.class); Main.bindAgentJNIForClass(Test986.class); } // Functions called from native code.

sample: 513
buggy_code:  // Test we can get in the middle of autobind setNativeTransform(say_hi_method, "NoReallySayGoodbye"); Transform.sayHi(); // Test we can get in between manual bind. setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2"); rebindTransformClass(); Transform.sayHi(); // Test we can get rid of transform removeNativeTransform(say_hi_method); rebindTransformClass(); Transform.sayHi(); <|startfocus|> Main.bindAgentJNIForClass(Main.class); Main.bindAgentJNIForClass(Test986.class); <|endfocus|> } // Functions called from native code. public static void doSayHi() { System.out.println("Hello"); } public static void doSayHi2() { System.out.println("Hello - 2"); } public static void doSayBye() { System.out.println("Bye"); } private static native void setNativeBindNotify(boolean enable); private static native void setupNativeBindNotify(); private static void rebindTransformClass() { rebindTransformClass(Transform.class); } private static native void rebindTransformClass(Class<?> trans); } 
code_review:  Remove? 
target code: // Test we can get in the middle of autobind setNativeTransform(say_hi_method, "NoReallySayGoodbye"); Transform.sayHi(); // Test we can get in between manual bind. setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2"); rebindTransformClass(); Transform.sayHi(); // Test we can get rid of transform removeNativeTransform(say_hi_method); rebindTransformClass(); Transform.sayHi(); } // Functions called from native code. public static void doSayHi() { System.out.println("Hello"); } public static void doSayHi2() { System.out.println("Hello - 2"); } public static void doSayBye() { System.out.println("Bye"); } private static native void setNativeBindNotify(boolean enable); private static native void setupNativeBindNotify(); private static void rebindTransformClass() { rebindTransformClass(Transform.class); } private static native void rebindTransformClass(Class<?> trans); }
response: package com.android.internal.telephony; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.BroadcastReceiver; import com.android.internal.telephony.CallForwardInfo; import com.android.internal.telephony.gsm.CommandException; import com.android.internal.telephony.gsm.NetworkInfo; import com.android.internal.telephony.gsm.PDPContextState; import com.android.internal.telephony.IccUtils; import com.android.internal.telephony.gsm.SmsResponse; import com.android.internal.telephony.gsm.SuppServiceNotification; import android.os.Parcel; import java.io.IOException; import android.os.Message; import android.os.Handler; import android.net.LocalSocketAddress; import android.net.LocalSocket; import com.android.internal.os.HandlerThread; import android.os.HandlerInterface; import java.util.ArrayList; import java.util.Collections; import java.io.InputStream; import android.telephony.PhoneNumberUtils; import android.telephony.gsm.SmsManager; public class PhoneSubInfo { private Phone mPhone; private Context mContext; public PhoneSubInfo(Phone phone) { mPhone = phone; mContext = phone.getContext(); } } public class Main { public static void bindAgentJNIForClass(Class<?> cls) { // implementation } } public class Test986 { // implementation }

sample: 514
buggy_code: <|startfocus|> private void ensureValidNetworkSpecifier(NetworkSpecifier nc) { MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(nc); if (nc != null) { nc.assertValidFromUid(Binder.getCallingUid()); <|endfocus|> }
code_review:  Nit: "nc" -> "ns". 
target code: private void ensureValidNetworkSpecifier(NetworkCapabilities nc) { if (nc == null) { return; }
response: private void ensureValidNetworkSpecifier(NetworkSpecifier ns) { MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(ns); if (ns != null) { ns.assertValidFromUid(Binder.getCallingUid()); } }

sample: 515
buggy_code: <|startfocus|> * Copyright (C) 2009 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.cts; import static com.android.server.NetworkManagementSocketTagger.resetKernelUidStats; import java.net.ServerSocket; import android.net.TrafficStats; import android.os.Process; import android.test.AndroidTestCase; import android.util.Log; import android.net.LocalSocket; import java.io.File; import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter;
code_review:  17 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.cts; import static com.android.server.NetworkManagementSocketTagger.resetKernelUidStats; import java.net.ServerSocket; import android.net.TrafficStats; import android.os.Process; import android.test.AndroidTestCase; import android.util.Log; import android.net.LocalSocket; import java.io.File; import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter;
response: /* * Copyright (C) 2009 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.net.cts; import static com.android.server.NetworkManagementSocketTagger.resetKernelUidStats; import java.net.ServerSocket; import android.net.TrafficStats; import android.os.Process; import android.test.AndroidTestCase; import android.util.Log; import android.net.LocalSocket; import java.io.File; import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import static com.android.server.NetworkManagementSocketTagger.resetKernelUidStats; import java.net.ServerSocket; import android.net.TrafficStats; import android.os.Process; import android.test.AndroidTestCase; import android.util.Log; import android.net.LocalSocket; import java.io.File; import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter;

sample: 516
buggy_code:  String line; Pattern ctrlDataPattern = Pattern.compile(PATTERN); while((line = qtaguidReader.readLine()) != null) { Matcher refCountMatcher = ctrlDataPattern.matcher(line); if(refCountMatcher.matches()) { if (refCountMatcher.group(TAG_INDEX).contains(Long.toHexString(fullTag)) && refCountMatcher.group(UID_INDEX).contains(Integer.toString(uid))) { refcnt_res = Integer.parseInt(refCountMatcher.group(REFCNT_INDEX)); Log.d(TAG, "result refcnt:" + refcnt_res); break; } } } <|startfocus|> qtaguidReader.close(); } catch (FileNotFoundException e) { fail("Not able to access qtaguid/ctrl: "+e); } catch (IOException e) { fail("file read error"); <|endfocus|> } return refcnt_res;
code_review:  replace tabs with spaces 
target code: String line; Pattern ctrlDataPattern = Pattern.compile(PATTERN); while((line = qtaguidReader.readLine()) != null) { Matcher refCountMatcher = ctrlDataPattern.matcher(line); if(refCountMatcher.matches()) { if (refCountMatcher.group(TAG_INDEX).contains(Long.toHexString(fullTag)) && refCountMatcher.group(UID_INDEX).contains(Integer.toString(uid))) { refcnt_res = Integer.parseInt(refCountMatcher.group(REFCNT_INDEX)); Log.d(TAG, "result refcnt:" + refcnt_res); break; } } } } return refcnt_res;
response: String line; Pattern ctrlDataPattern = Pattern.compile(PATTERN); while((line = qtaguidReader.readLine()) != null) { Matcher refCountMatcher = ctrlDataPattern.matcher(line); if(refCountMatcher.matches()) { if (refCountMatcher.group(TAG_INDEX).contains(Long.toHexString(fullTag)) && refCountMatcher.group(UID_INDEX).contains(Integer.toString(uid))) { refcnt_res = Integer.parseInt(refCountMatcher.group(REFCNT_INDEX)); Log.d(TAG, "result refcnt:" + refcnt_res); break; } } } qtaguidReader.close(); } catch (FileNotFoundException e) { fail("Not able to access qtaguid/ctrl: "+e); } catch (IOException e) { fail("file read error"); } return refcnt_res;

sample: 517
buggy_code:  if (refCountMatcher.group(TAG_INDEX).contains(Long.toHexString(fullTag)) && refCountMatcher.group(UID_INDEX).contains(Integer.toString(uid))) { refcnt_res = Integer.parseInt(refCountMatcher.group(REFCNT_INDEX)); Log.d(TAG, "result refcnt:" + refcnt_res); break; } } } qtaguidReader.close(); } catch (FileNotFoundException e) { fail("Not able to access qtaguid/ctrl: "+e); } catch (IOException e) { fail("file read error"); <|startfocus|> } <|endfocus|> return refcnt_res;
code_review:  Consider letting the error bubble up 
target code: if (refCountMatcher.group(TAG_INDEX).contains(Long.toHexString(fullTag)) && refCountMatcher.group(UID_INDEX).contains(Integer.toString(uid))) { refcnt_res = Integer.parseInt(refCountMatcher.group(REFCNT_INDEX)); Log.d(TAG, "result refcnt:" + refcnt_res); break; } } } qtaguidReader.close(); } catch (FileNotFoundException e) { fail("Not able to access qtaguid/ctrl: "+e); } catch (IOException e) { fail("file read error"); } qtaguidReader.close(); return refcnt_res;
response: if (refCountMatcher.group(TAG_INDEX).contains(Long.toHexString(fullTag)) && refCountMatcher.group(UID_INDEX).contains(Integer.toString(uid))) { refcnt_res = Integer.parseInt(refCountMatcher.group(REFCNT_INDEX)); Log.d(TAG, "result refcnt:" + refcnt_res); break; } } qtaguidReader.close(); } catch (FileNotFoundException e) { fail("Not able to access qtaguid/ctrl: "+e); } catch (IOException e) { fail("file read error"); throw e; } return refcnt_res;

sample: 518
buggy_code:  public boolean imsIsEnhanced4gLteModeSettingEnabledByPlatform() { <|startfocus|> return ImsManager.isVolteEnabledByPlatformForSlot(); <|endfocus|>
code_review:  Should we use mImsManager? 
target code: public boolean imsIsEnhanced4gLteModeSettingEnabledByPlatform() { return mImsManager.isVolteEnabledByPlatformForSlot();
response: public boolean imsIsEnhanced4gLteModeSettingEnabledByPlatform() { return mImsManager.isVolteEnabledByPlatformForSlot(); }

sample: 519
buggy_code:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.internal.util; import android.annotation.Nullable; import libcore.util.Objects; import java.nio.ByteBuffer; import java.util.Arrays; import java.util.UUID; /** <|startfocus|> * A utility class for handling unsigned integers and unsigned arithmetics, as well as sugar methods * for ByteBuffer. Useful for networking and packet manipulations. <|endfocus|> * {@hide} */ public final class BitUtils { private BitUtils() {} public static boolean maskedEquals(long a, long b, long mask) { return (a & mask) == (b & mask); } public static boolean maskedEquals(byte a, byte b, byte mask) { return (a & mask) == (b & mask); } public static boolean maskedEquals(byte[] a, byte[] b, @Nullable byte[] mask) { if (a == null || b == null) return a == b;
code_review:  "syntactic sugar", perhaps? 
target code: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.internal.util; import android.annotation.Nullable; import libcore.util.Objects; import java.nio.ByteBuffer; import java.util.Arrays; import java.util.UUID; /** * A utility class for handling unsigned integers and unsigned arithmetics, as well as syntactic * sugar methods for ByteBuffer. Useful for networking and packet manipulations. * {@hide} */ public final class BitUtils { private BitUtils() {} public static boolean maskedEquals(long a, long b, long mask) { return (a & mask) == (b & mask); } public static boolean maskedEquals(byte a, byte b, byte mask) { return (a & mask) == (b & mask); } public static boolean maskedEquals(byte[] a, byte[] b, @Nullable byte[] mask) { if (a == null || b == null) return a == b;
response: private static BufferedImage getSvgImage(@NotNull String path, StringBuilder errorLog) { String xmlFileContent = generateVectorXml(new File(path), errorLog); BufferedImage image = VdPreview.getPreviewFromVectorXml(SVG_PREVIEW_WIDTH, 0.0f, xmlFileContent, errorLog); if (image == null) { image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); errorLog.insert(0, ERROR_MESSAGE_EMPTY_PREVIEW_IMAGE + "\n"); } return image; } protected void configure() { cache(CACHE_NAME, String.class, ProjectState.class).loader(Loader.class); cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {}) .maximumWeight(1) .loader(Lister.class); bind(ProjectCacheImpl.class); bind(ProjectCache.class).to(ProjectCacheImpl.class); install(new LifecycleModule() { @Override protected void configure() { listener().to(ProjectCacheWarmer.class); listener().to(ProjectCacheClock.class); } }); } assertEquals(true, NetworkSecurityPolicy.isCleartextTrafficPermitted()); public void testCleartextTrafficPolicyWithFtpURLConnection() throws Exception { NetworkSecurityPolicy.setCleartextTrafficPermitted(true); byte[] serverReplyOnConnect = "220\r\n".getBytes("US-ASCII"); try (CapturingServerSocket server = new CapturingServerSocket(serverReplyOnConnect)) { URL url = new URL("ftp://localhost:" + server.getPort() + "/test.txt"); try { url.openConnection().getContent(); fail(); } catch (IOException expected) { } assertDataTransmittedByClient(server); } NetworkSecurityPolicy.setCleartextTrafficPermitted(false); try (CapturingServerSocket server = new CapturingServerSocket(serverReplyOnConnect)) { URL url = new URL("ftp://localhost:" + server.getPort() + "/test.txt"); try { url.openConnection().getContent(); fail(); } catch (IOException expected) { } } } /** * A utility class for handling unsigned integers and unsigned arithmetics, as well as sugar methods * for ByteBuffer. Useful for networking and packet manipulations. */ public final class BitUtils { private BitUtils() {} public static boolean maskedEquals(long a,

sample: 520
buggy_code:  } try { // Verification of TestClass.test() used to crash when processing // the final abstract (erroneous) class. Class<?> tc = Class.forName("TestClass"); Method test = tc.getDeclaredMethod("test"); test.invoke(null); System.out.println("UNREACHABLE!"); } catch (InvocationTargetException ite) { if (ite.getCause() instanceof InstantiationError) { System.out.println( <|startfocus|> ite.getCause().getClass().getName() + ": " +ite.getCause().getMessage()); <|endfocus|> } else { ite.printStackTrace(System.out); } } catch (Throwable t) { t.printStackTrace(System.out); }
code_review:  Nit: space after '+'. 
target code: } try { // Verification of TestClass.test() used to crash when processing // the final abstract (erroneous) class. Class<?> tc = Class.forName("TestClass"); Method test = tc.getDeclaredMethod("test"); test.invoke(null); System.out.println("UNREACHABLE!"); } catch (InvocationTargetException ite) { if (ite.getCause() instanceof InstantiationError) { System.out.println( ite.getCause().getClass().getName() + ": " + ite.getCause().getMessage()); } else { ite.printStackTrace(System.out); } } catch (Throwable t) { t.printStackTrace(System.out); }
response: } try { Class<?> tc = Class.forName("TestClass"); Method test = tc.getDeclaredMethod("test"); test.invoke(null); System.out.println("UNREACHABLE!"); } catch (InvocationTargetException ite) { if (ite.getCause() instanceof InstantiationError) { System.out.println(ite.getCause().getClass().getName() + ": " + ite.getCause().getMessage()); } else { ite.printStackTrace(System.out); } } catch (Throwable t) { t.printStackTrace(System.out); }

sample: 521
buggy_code:  } return findPreviousZoneTransitionTime(tz, upperOffset, mid, lower); } /** * Compute the milliseconds in the day from the fields. This is a * value from 0 to 23:59:59.999 inclusive, unless fields are out of * range, in which case it can be an arbitrary value. This value * reflects local zone wall time. <|startfocus|> * @deprecated This method suffers from a potential integer overflow and may be removed in a future * release. Overriding this method in subclasses will not have the desired effect. See ICU * ticket #11632. <|endfocus|> */ protected int computeMillisInDay() { // Do the time portion of the conversion. int millisInDay = 0; // Find the best set of fields specifying the time of day. There // are only two possibilities here; the HOUR_OF_DAY or the // AM_PM and the HOUR. int hourOfDayStamp = stamp[HOUR_OF_DAY]; int hourStamp = Math.max(stamp[HOUR], stamp[AM_PM]);
code_review:  Be on the lookout for doclava or other warnings about the JavaDoc @deprecated not matching a @Deprecated. It wouldn't be hard to add a code-gen processor to do that if we had to. It can be done as a follow-up if it turns out to be needed / desired. 
target code: } return findPreviousZoneTransitionTime(tz, upperOffset, mid, lower); } /** * Compute the milliseconds in the day from the fields. This is a * value from 0 to 23:59:59.999 inclusive, unless fields are out of * range, in which case it can be an arbitrary value. This value * reflects local zone wall time. * @deprecated This method suffers from a potential integer overflow and may be removed in a * future release. Overriding this method in subclasses will not have the desired effect. * See ICU ticket #11632. */ protected int computeMillisInDay() { // Do the time portion of the conversion. int millisInDay = 0; // Find the best set of fields specifying the time of day. There // are only two possibilities here; the HOUR_OF_DAY or the // AM_PM and the HOUR. int hourOfDayStamp = stamp[HOUR_OF_DAY]; int hourStamp = Math.max(stamp[HOUR], stamp[AM_PM]);
response: protected int computeMillisInDay() { int millisInDay = 0; int hourOfDayStamp = stamp[HOUR_OF_DAY]; int hourStamp = Math.max(stamp[HOUR], stamp[AM_PM]); return findPreviousZoneTransitionTime(tz, upperOffset, mid, lower); }

sample: 522
buggy_code:  } return findPreviousZoneTransitionTime(tz, upperOffset, mid, lower); } /** * Compute the milliseconds in the day from the fields. This is a * value from 0 to 23:59:59.999 inclusive, unless fields are out of * range, in which case it can be an arbitrary value. This value * reflects local zone wall time. <|startfocus|> * @deprecated This method suffers from a potential integer overflow and may be removed in a future * release. Overriding this method in subclasses will not have the desired effect. See ICU * ticket #11632. <|endfocus|> */ protected int computeMillisInDay() { // Do the time portion of the conversion. int millisInDay = 0; // Find the best set of fields specifying the time of day. There // are only two possibilities here; the HOUR_OF_DAY or the // AM_PM and the HOUR. int hourOfDayStamp = stamp[HOUR_OF_DAY]; int hourStamp = Math.max(stamp[HOUR], stamp[AM_PM]);
code_review:  NIT: Too long. No big deal, though. 
target code: } return findPreviousZoneTransitionTime(tz, upperOffset, mid, lower); } /** * Compute the milliseconds in the day from the fields. This is a * value from 0 to 23:59:59.999 inclusive, unless fields are out of * range, in which case it can be an arbitrary value. This value * reflects local zone wall time. * @deprecated This method suffers from a potential integer overflow and may be removed in a * future release. Overriding this method in subclasses will not have the desired effect. * See ICU ticket #11632. */ protected int computeMillisInDay() { // Do the time portion of the conversion. int millisInDay = 0; // Find the best set of fields specifying the time of day. There // are only two possibilities here; the HOUR_OF_DAY or the // AM_PM and the HOUR. int hourOfDayStamp = stamp[HOUR_OF_DAY]; int hourStamp = Math.max(stamp[HOUR], stamp[AM_PM]);
response: protected int computeMillisInDay() { int millisInDay = 0; int hourOfDayStamp = stamp[HOUR_OF_DAY]; int hourStamp = Math.max(stamp[HOUR], stamp[AM_PM]); if (hourOfDayStamp >= 0) { millisInDay += fields[HOUR_OF_DAY]; } else if (hourStamp >= 0) { millisInDay += fields[HOUR] + (fields[AM_PM] * 12); } millisInDay *= 60; millisInDay += fields[MINUTE]; millisInDay *= 60; millisInDay += fields[SECOND]; millisInDay *= 1000; millisInDay += fields[MILLISECOND]; return millisInDay; }

sample: 523
buggy_code:  * empty String if no provider was explicitly specified. */ private String verifiedProvider; /** * If verifiedPublicKey is not null, result of the verification using * verifiedPublicKey and verifiedProvider. If true, verification was * successful, if false, it failed. */ private boolean verificationResult; /** * Default constructor. */ public X509CertImpl() { } <|startfocus|> // BEGIN Android-added: Needed To retain original encoded form in PKCS7. <|endfocus|> /** * Unmarshals a certificate from its encoded form, parsing the * encoded bytes. This form of constructor is used by agents which * need to examine and use certificate contents. That is, this is * one of the more commonly used constructors. Note that the buffer * must include only a certificate, and no "garbage" may be left at * the end. If you need to ignore data at the end of a certificate, * use another constructor. * * @param certData the encoded bytes, with no trailing padding.
code_review:  That doesn't look right, this constructor exits upstream? You probably meant to document the other constructor around line 323? Also, wording nit: (here and below) "Needed To" / "Needed for" is redundant. It could be worth saying "Constructor to" or similar, since when looking at the diff spreadsheet, it's good for the comments to be meaningful without needing to see the code. E.g. in this particular case, "Android-added: Constructor to retain original encoded form for PKCS7." or "Android-added: Constructor to retain original encoded form, for internal use." or so. 
target code: * empty String if no provider was explicitly specified. */ private String verifiedProvider; /** * If verifiedPublicKey is not null, result of the verification using * verifiedPublicKey and verifiedProvider. If true, verification was * successful, if false, it failed. */ private boolean verificationResult; /** * Default constructor. */ public X509CertImpl() { } /** * Unmarshals a certificate from its encoded form, parsing the * encoded bytes. This form of constructor is used by agents which * need to examine and use certificate contents. That is, this is * one of the more commonly used constructors. Note that the buffer * must include only a certificate, and no "garbage" may be left at * the end. If you need to ignore data at the end of a certificate, * use another constructor. * * @param certData the encoded bytes, with no trailing padding.
response: private String verifiedProvider; private boolean verificationResult; public X509CertImpl() { } // BEGIN Android-added: Constructor to retain original encoded form in PKCS7. public X509CertImpl(byte[] certData) { // Implementation here } // END Android-added

sample: 524
buggy_code:  * * @param certData the encoded bytes, with no trailing padding. * @exception CertificateException on parsing and initialization errors. */ public X509CertImpl(byte[] certData) throws CertificateException { try { parse(new DerValue(certData)); } catch (IOException e) { signedCert = null; throw new CertificateException("Unable to initialize, " + e, e); } } // END Android-added: Needed To retain original encoded form in PKCS7. <|startfocus|> // BEGIN Android-removed <|endfocus|> /* /** * unmarshals an X.509 certificate from an input stream. If the * certificate is RFC1421 hex-encoded, then it must begin with * the line X509Factory.BEGIN_CERT and end with the line * X509Factory.END_CERT. * * @param in an input stream holding at least one certificate that may * be either DER-encoded or RFC1421 hex-encoded version of the * DER-encoded certificate. * @exception CertificateException on parsing and initialization errors. *
code_review:  Could optionally add a comment, e.g. ": unused code." or similar. (That was the justification given in commit 7b5c7bb3e2ac90c7622a1ce42d4a7d149cc63ad9, which commented this out). 
target code: * * @param certData the encoded bytes, with no trailing padding. * @exception CertificateException on parsing and initialization errors. */ public X509CertImpl(byte[] certData) throws CertificateException { try { parse(new DerValue(certData)); } catch (IOException e) { signedCert = null; throw new CertificateException("Unable to initialize, " + e, e); } } // END Android-added: Needed To retain original encoded form in PKCS7. // BEGIN Android-removed: unused code /* /** * unmarshals an X.509 certificate from an input stream. If the * certificate is RFC1421 hex-encoded, then it must begin with * the line X509Factory.BEGIN_CERT and end with the line * X509Factory.END_CERT. * * @param in an input stream holding at least one certificate that may * be either DER-encoded or RFC1421 hex-encoded version of the * DER-encoded certificate. * @exception CertificateException on parsing and initialization errors. *
response: import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.security.cert.CertificateFactory; import java.io.ByteArrayInputStream; import java.io.IOException; public class X509CertImpl { private X509Certificate signedCert; public X509CertImpl(byte[] certData) throws CertificateException { try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); signedCert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(certData)); } catch (IOException e) { signedCert = null; throw new CertificateException("Unable to initialize, " + e, e); } } }

sample: 525
buggy_code:  public void onRestoreInstanceState(Bundle savedInstanceState) { if (savedInstanceState != null) { super.onRestoreInstanceState(savedInstanceState); DialogState dialogState = mDialogState.valueOf(savedInstanceState.getString(DIALOG_STATE)); String msg = savedInstanceState.getString(DIALOG_MSG_STRING); updateDialog(dialogState, msg); if (dialogState == DialogState.WPS_START) { <|startfocus|> WpsInfo wpsConfig = new WpsInfo(); wpsConfig.setup = mWpsSetup; mWifiManager.startWps(wpsConfig, mWpsListener); <|endfocus|> } }
code_review:  this is repeated at line 187 - 190. Can you refactor them into a method and call it from both places? 
target code: public void onRestoreInstanceState(Bundle savedInstanceState) { if (savedInstanceState != null) { super.onRestoreInstanceState(savedInstanceState); DialogState dialogState = mDialogState.valueOf(savedInstanceState.getString(DIALOG_STATE)); String msg = savedInstanceState.getString(DIALOG_MSG_STRING); updateDialog(dialogState, msg); if (dialogState == DialogState.WPS_START) { startWps(); } }
response: public void onRestoreInstanceState(Bundle savedInstanceState) { if (savedInstanceState != null) { super.onRestoreInstanceState(savedInstanceState); DialogState dialogState = mDialogState.valueOf(savedInstanceState.getString(DIALOG_STATE)); String msg = savedInstanceState.getString(DIALOG_MSG_STRING); updateDialog(dialogState, msg); if (dialogState == DialogState.WPS_START) { startWps(); } } } private void startWps() { WpsInfo wpsConfig = new WpsInfo(); wpsConfig.setup = mWpsSetup; mWifiManager.startWps(wpsConfig, mWpsListener); }

sample: 526
buggy_code: import java.util.Arrays; import java.nio.ByteBuffer; import javax.obex.ServerRequestHandler; import javax.obex.ResponseCodes; import javax.obex.ApplicationParameter; import javax.obex.Operation; import javax.obex.HeaderSet; public class BluetoothPbapObexServer extends ServerRequestHandler { private static final String TAG = "BluetoothPbapObexServer"; private static final boolean D = BluetoothPbapService.DEBUG; private static final boolean V = BluetoothPbapService.VERBOSE; private static final int UUID_LENGTH = 16; <|startfocus|> public static final int INVALID_VALUE_PARAMETER = -1; <|endfocus|> // The length of suffix of vcard name - ".vcf" is 5 private static final int VCARD_NAME_SUFFIX_LENGTH = 5; // 128 bit UUID for PBAP private static final byte[] PBAP_TARGET = new byte[] { 0x79, 0x61, 0x35, (byte)0xf0, (byte)0xf0, (byte)0xc5, 0x11, (byte)0xd8, 0x09, 0x66, 0x08, 0x00, 0x20, 0x0c, (byte)0x9a, 0x66 }; 
code_review:  long? (used as a long below) 
target code: import java.util.Arrays; import java.nio.ByteBuffer; import javax.obex.ServerRequestHandler; import javax.obex.ResponseCodes; import javax.obex.ApplicationParameter; import javax.obex.Operation; import javax.obex.HeaderSet; public class BluetoothPbapObexServer extends ServerRequestHandler { private static final String TAG = "BluetoothPbapObexServer"; private static final boolean D = BluetoothPbapService.DEBUG; private static final boolean V = BluetoothPbapService.VERBOSE; private static final int UUID_LENGTH = 16; public static final long INVALID_VALUE_PARAMETER = -1; // The length of suffix of vcard name - ".vcf" is 5 private static final int VCARD_NAME_SUFFIX_LENGTH = 5; // 128 bit UUID for PBAP private static final byte[] PBAP_TARGET = new byte[] { 0x79, 0x61, 0x35, (byte)0xf0, (byte)0xf0, (byte)0xc5, 0x11, (byte)0xd8, 0x09, 0x66, 0x08, 0x00, 0x20, 0x0c, (byte)0x9a, 0x66 };
response: import java.util.Arrays; import java.nio.ByteBuffer; import javax.obex.ServerRequestHandler; import javax.obex.ResponseCodes; import javax.obex.ApplicationParameter; import javax.obex.Operation; import javax.obex.HeaderSet; public class BluetoothPbapObexServer extends ServerRequestHandler { private static final String TAG = "BluetoothPbapObexServer"; private static final boolean D = BluetoothPbapService.DEBUG; private static final boolean V = BluetoothPbapService.VERBOSE; private static final int UUID_LENGTH = 16; public static final int INVALID_VALUE_PARAMETER = -1; private static final int VCARD_NAME_SUFFIX_LENGTH = 5; private static final byte[] PBAP_TARGET = new byte[] { 0x79, 0x61, 0x35, (byte)0xf0, (byte)0xf0, (byte)0xc5, 0x11, (byte)0xd8, 0x09, 0x66, 0x08, 0x00, 0x20, 0x0c, (byte)0x9a, 0x66 }; }

sample: 527
buggy_code:  pushResult = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; } if (!closeStream(outputStream, op)) { pushResult = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; } return pushResult; } private final int handleAppParaForResponse( AppParamValue appParamValue, int size, HeaderSet reply, Operation op, String name) { byte[] misnum = new byte[1]; ApplicationParameter ap = new ApplicationParameter(); <|startfocus|> long folderVersionCounterbitMask = 0x0008; long databaseIdentifierBitMask = 0x0004; <|endfocus|> boolean needSendCallHistoryVersionCounters = false; if (isNameMatchTarget(name, MCH) || isNameMatchTarget(name, ICH) || isNameMatchTarget(name, OCH) || isNameMatchTarget(name, CCH)) needSendCallHistoryVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask); boolean needSendPhonebookVersionCounters = false; if (isNameMatchTarget(name, PB)) needSendPhonebookVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask); // In such case, PCE only want the number of index. // So response not contain any Body header. if (mNeedPhonebookSize) {
code_review:  These should be constants defined somewhere else, probably above. 
target code: pushResult = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; } if (!closeStream(outputStream, op)) { pushResult = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; } return pushResult; } private final int handleAppParaForResponse( AppParamValue appParamValue, int size, HeaderSet reply, Operation op, String name) { byte[] misnum = new byte[1]; ApplicationParameter ap = new ApplicationParameter(); boolean needSendCallHistoryVersionCounters = false; if (isNameMatchTarget(name, MCH) || isNameMatchTarget(name, ICH) || isNameMatchTarget(name, OCH) || isNameMatchTarget(name, CCH)) needSendCallHistoryVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask); boolean needSendPhonebookVersionCounters = false; if (isNameMatchTarget(name, PB)) needSendPhonebookVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask); // In such case, PCE only want the number of index. // So response not contain any Body header. if (mNeedPhonebookSize) {
response: public String getShortName() { return EndpointBundle.message("api.namespace.short.name"); } public static int getMaxHttpConnectionsPerHost() { return getSystemPropertyAndParseInt(MAX_HTTP_HOST_CONNECTIONS_PROPERTY, MAX_HTTP_HOST_CONNECTIONS_DEFAULT); } private final int handleAppParaForResponse(AppParamValue appParamValue, int size, HeaderSet reply, Operation op, String name) { byte[] misnum = new byte[1]; ApplicationParameter ap = new ApplicationParameter(); long folderVersionCounterbitMask = 0x0008; long databaseIdentifierBitMask = 0x0004; boolean needSendCallHistoryVersionCounters = false; if (isNameMatchTarget(name, MCH) || isNameMatchTarget(name, ICH) || isNameMatchTarget(name, OCH) || isNameMatchTarget(name, CCH)) { needSendCallHistoryVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask); } boolean needSendPhonebookVersionCounters = false; if (isNameMatchTarget(name, PB)) { needSendPhonebookVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask); } if (mNeedPhonebookSize) { // ... } } interface ComponentVersionReader { ComponentVersionReader GRADLE = new GradleVersionReader(); ComponentVersionReader ANDROID_GRADLE_PLUGIN = new AndroidGradlePluginVersionReader(); boolean appliesTo(@NotNull Module module); String getVersion(@NotNull Module module); }

sample: 528
buggy_code:  boolean status = sdpManager.removeSdpRecord(mSdpHandle); Log.d(TAG, "RemoveSDPrecord returns " + status); mSdpHandle = -1; } mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord( "OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES); <|startfocus|> // Here we might have changed crucial data, hence reset DB // identifier <|endfocus|> updateDbIdentifier(); if (DEBUG) Log.d(TAG, "PBAP server with handle:" + mSdpHandle); }
code_review:  nit: format 
target code: boolean status = sdpManager.removeSdpRecord(mSdpHandle); Log.d(TAG, "RemoveSDPrecord returns " + status); mSdpHandle = -1; } mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord( "OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES); /* Here we might have changed crucial data, hence reset DB identifier */ updateDbIdentifier(); if (DEBUG) Log.d(TAG, "PBAP server with handle:" + mSdpHandle); }
response: boolean status = sdpManager.removeSdpRecord(mSdpHandle); Log.d(TAG, "RemoveSDPrecord returns " + status); mSdpHandle = -1; } mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord( "OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES); // Here we might have changed crucial data, hence reset DB identifier updateDbIdentifier(); if (DEBUG) Log.d(TAG, "PBAP server with handle:" + mSdpHandle);

sample: 529
buggy_code:  intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName()); mIsWaitingAuthorization = true; sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM); if (VERBOSE) Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName); // In case car kit time out and try to use HFP for // phonebook // access, while UI still there waiting for user to // confirm mSessionStatusHandler.sendMessageDelayed( mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE); <|startfocus|> // We will continue the process when we receive // BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. <|endfocus|> } return true;
code_review:  nit: format 
target code: intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName()); mIsWaitingAuthorization = true; sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM); if (VERBOSE) Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName); // In case car kit time out and try to use HFP for // phonebook // access, while UI still there waiting for user to // confirm mSessionStatusHandler.sendMessageDelayed( mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE); /* We will continue the process when we receive * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */ } return true;
response: import android.bluetooth.BluetoothDevice; import android.content.Intent; import android.util.Log; intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName()); mIsWaitingAuthorization = true; sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM); if (VERBOSE) { Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName); } mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE); // We will continue the process when we receive BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. return true;

sample: 530
buggy_code:  + startPointId; } String selection; if (typeSelection == null) { selection = recordSelection; } else { selection = "(" + typeSelection + ") AND (" + recordSelection + ")"; } if (V) Log.v(TAG, "Call log query selection is: " + selection); <|startfocus|> /*return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody, pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop);*/ <|endfocus|> return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody, pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop, vcardselect); } final int composeAndSendPhonebookVcards(Operation op, final int startPoint, final int endPoint, final boolean vcardType21, String ownerVCard, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] vcardselector, String vcardselectorop, boolean vcardselect) { if (startPoint < 1 || startPoint > endPoint) { Log.e(TAG, "internal error: startPoint or endPoint is not correct."); return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; } 
code_review:  ? 
target code: + startPointId; } String selection; if (typeSelection == null) { selection = recordSelection; } else { selection = "(" + typeSelection + ") AND (" + recordSelection + ")"; } if (V) Log.v(TAG, "Call log query selection is: " + selection); return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody, pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop, vcardselect); } final int composeAndSendPhonebookVcards(Operation op, final int startPoint, final int endPoint, final boolean vcardType21, String ownerVCard, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] vcardselector, String vcardselectorop, boolean vcardselect) { if (startPoint < 1 || startPoint > endPoint) { Log.e(TAG, "internal error: startPoint or endPoint is not correct."); return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; }
response: + startPointId; String selection; if (typeSelection == null) { selection = recordSelection; } else { selection = "(" + typeSelection + ") AND (" + recordSelection + ")"; } if (V) Log.v(TAG, "Call log query selection is: " + selection); return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody, pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop, vcardselect); } final int composeAndSendPhonebookVcards(Operation op, final int startPoint, final int endPoint, final boolean vcardType21, String ownerVCard, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] vcardselector, String vcardselectorop, boolean vcardselect) { if (startPoint < 1 || startPoint > endPoint) { Log.e(TAG, "internal error: startPoint or endPoint is not correct."); return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR; }

sample: 531
buggy_code:  public String onValueReceived( String rawValue, int type, String label, boolean isPrimary) { <|startfocus|> // 'p' and 'w' are the standard characters for pause and // wait // (see RFC 3601) // so use those when exporting phone numbers via vCard. <|endfocus|> String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p') .replace(PhoneNumberUtils.WAIT, 'w'); return numberWithControlSequence;
code_review:  nit: it looks like clang reformatted this comment 
target code: public String onValueReceived( String rawValue, int type, String label, boolean isPrimary) { /* 'p' and 'w' are the standard characters for pause and wait * (see RFC 3601) so use those when exporting phone numbers via vCard.*/ String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p') .replace(PhoneNumberUtils.WAIT, 'w'); return numberWithControlSequence;
response: public String onValueReceived(String rawValue, int type, String label, boolean isPrimary) { String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p') .replace(PhoneNumberUtils.WAIT, 'w'); return numberWithControlSequence; }

sample: 532
buggy_code:  public String onValueReceived( String rawValue, int type, String label, boolean isPrimary) { <|startfocus|> // 'p' and 'w' are the standard characters for pause and // wait // (see RFC 3601) // so use those when exporting phone numbers via vCard. <|endfocus|> String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p') .replace(PhoneNumberUtils.WAIT, 'w'); return numberWithControlSequence;
code_review:  nit: reformat 
target code: public String onValueReceived( String rawValue, int type, String label, boolean isPrimary) { /* 'p' and 'w' are the standard characters for pause and wait * (see RFC 3601) so use those when exporting phone numbers via vCard.*/ String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p') .replace(PhoneNumberUtils.WAIT, 'w'); return numberWithControlSequence;
response: public String onValueReceived(String rawValue, int type, String label, boolean isPrimary) { // 'p' and 'w' are the standard characters for pause and wait // (see RFC 3601) // so use those when exporting phone numbers via vCard. String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p') .replace(PhoneNumberUtils.WAIT, 'w'); return numberWithControlSequence; }

sample: 533
buggy_code:  private boolean checkprop(String vcard, String prop) { String lines[] = vcard.split(SEPARATOR); boolean isPresent = false; for (String line : lines) { if (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("=")) { String currentProp = line.split("[;:]")[0]; if (prop.equals(currentProp)) { <|startfocus|> Log.e(TAG, "bit.prop.equals current prop :" + prop); <|endfocus|> isPresent = true; return isPresent; } } } return isPresent;
code_review:  Is this an error? 
target code: private boolean checkprop(String vcard, String prop) { String lines[] = vcard.split(SEPARATOR); boolean isPresent = false; for (String line : lines) { if (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("=")) { String currentProp = line.split("[;:]")[0]; if (prop.equals(currentProp)) { Log.d(TAG, "bit.prop.equals current prop :" + prop); isPresent = true; return isPresent; } } } return isPresent;
response: private boolean checkprop(String vcard, String prop) { String lines[] = vcard.split(SEPARATOR); boolean isPresent = false; for (String line : lines) { if (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("=")) { String currentProp = line.split("[;:]")[0]; if (prop.equals(currentProp)) { Log.e(TAG, "bit.prop.equals current prop :" + prop); isPresent = true; return isPresent; } } } return isPresent; }

sample: 534
buggy_code:  private boolean CheckVcardSelector(String vcard, String vcardselectorop) { boolean selectedIn = true; for (PropertyMask bit : PropertyMask.values()) { if (checkbit(bit.pos, selector)) { <|startfocus|> Log.e(TAG, "checking for prop :" + bit.prop); <|endfocus|> if (vcardselectorop.equals("0")) { if (checkprop(vcard, bit.prop)) { Log.e(TAG, "bit.prop.equals current prop :" + bit.prop); selectedIn = true; break; } else { selectedIn = false; } } else if (vcardselectorop.equals("1")) { if (!checkprop(vcard, bit.prop)) { Log.e(TAG, "bit.prop.notequals current prop" + bit.prop); selectedIn = false; return selectedIn; } else { selectedIn = true; } } } } return selectedIn;
code_review:  Is this an error? 
target code: private boolean CheckVcardSelector(String vcard, String vcardselectorop) { boolean selectedIn = true; for (PropertyMask bit : PropertyMask.values()) { if (checkbit(bit.pos, selector)) { Log.d(TAG, "checking for prop :" + bit.prop); if (vcardselectorop.equals("0")) { if (checkprop(vcard, bit.prop)) { Log.e(TAG, "bit.prop.equals current prop :" + bit.prop); selectedIn = true; break; } else { selectedIn = false; } } else if (vcardselectorop.equals("1")) { if (!checkprop(vcard, bit.prop)) { Log.e(TAG, "bit.prop.notequals current prop" + bit.prop); selectedIn = false; return selectedIn; } else { selectedIn = true; } } } } return selectedIn;
response: private boolean checkVcardSelector(String vcard, String vcardSelectorOp) { boolean selectedIn = true; for (PropertyMask bit : PropertyMask.values()) { if (checkBit(bit.pos, selector)) { if (vcardSelectorOp.equals("0")) { if (checkProp(vcard, bit.prop)) { selectedIn = true; break; } else { selectedIn = false; } } else if (vcardSelectorOp.equals("1")) { if (!checkProp(vcard, bit.prop)) { selectedIn = false; return selectedIn; } else { selectedIn = true; } } } } return selectedIn; }

sample: 535
buggy_code:  private boolean CheckVcardSelector(String vcard, String vcardselectorop) { boolean selectedIn = true; for (PropertyMask bit : PropertyMask.values()) { if (checkbit(bit.pos, selector)) { Log.e(TAG, "checking for prop :" + bit.prop); if (vcardselectorop.equals("0")) { if (checkprop(vcard, bit.prop)) { <|startfocus|> Log.e(TAG, "bit.prop.equals current prop :" + bit.prop); <|endfocus|> selectedIn = true; break; } else { selectedIn = false; } } else if (vcardselectorop.equals("1")) { if (!checkprop(vcard, bit.prop)) { Log.e(TAG, "bit.prop.notequals current prop" + bit.prop); selectedIn = false; return selectedIn; } else { selectedIn = true; } } } } return selectedIn;
code_review:  Is this an error? 
target code: private boolean CheckVcardSelector(String vcard, String vcardselectorop) { boolean selectedIn = true; for (PropertyMask bit : PropertyMask.values()) { if (checkbit(bit.pos, selector)) { Log.e(TAG, "checking for prop :" + bit.prop); if (vcardselectorop.equals("0")) { if (checkprop(vcard, bit.prop)) { Log.d(TAG, "bit.prop.equals current prop :" + bit.prop); selectedIn = true; break; } else { selectedIn = false; } } else if (vcardselectorop.equals("1")) { if (!checkprop(vcard, bit.prop)) { Log.e(TAG, "bit.prop.notequals current prop" + bit.prop); selectedIn = false; return selectedIn; } else { selectedIn = true; } } } } return selectedIn;
response: private boolean checkVcardSelector(String vcard, String vcardSelectorOp) { boolean selectedIn = true; for (PropertyMask bit : PropertyMask.values()) { if (checkBit(bit.pos, selector)) { Log.e(TAG, "checking for prop :" + bit.prop); if (vcardSelectorOp.equals("0")) { if (checkProp(vcard, bit.prop)) { Log.e(TAG, "bit.prop.equals current prop :" + bit.prop); selectedIn = true; break; } else { selectedIn = false; } } else if (vcardSelectorOp.equals("1")) { if (!checkProp(vcard, bit.prop)) { Log.e(TAG, "bit.prop.notequals current prop" + bit.prop); selectedIn = false; return selectedIn; } else { selectedIn = true; } } } } return selectedIn; }

sample: 536
buggy_code:  boolean status = sdpManager.removeSdpRecord(mSdpHandle); Log.d(TAG, "RemoveSDPrecord returns " + status); mSdpHandle = -1; } mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord( "OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES); <|startfocus|> // fetch DbIdentifier to check if significant change has happened to Db getPbapDbParams(); <|endfocus|> if (DEBUG) Log.d(TAG, "PBAP server with handle:" + mSdpHandle); }
code_review:  ERROR: /usr/local/google/buildbot/src/android/master/packages/apps/Bluetooth/src/com/android/bluetooth/pbap/BluetoothPbapService.java:965.13: The method getPbapDbParams() is undefined for the type BluetoothPbapService 
target code: boolean status = sdpManager.removeSdpRecord(mSdpHandle); Log.d(TAG, "RemoveSDPrecord returns " + status); mSdpHandle = -1; } mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord( "OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES); // fetch Pbap Params to check if significant change has happened to Database BluetoothPbapUtils.fetchPbapParams(mContext); if (DEBUG) Log.d(TAG, "PBAP server with handle:" + mSdpHandle); }
response: boolean status = sdpManager.removeSdpRecord(mSdpHandle); Log.d(TAG, "RemoveSDPrecord returns " + status); mSdpHandle = -1; mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord( "OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES); getPbapDbParams(); if (DEBUG) { Log.d(TAG, "PBAP server with handle:" + mSdpHandle); }

sample: 537
buggy_code:  private boolean initialize() { Log.d(TAG, "Start initialize()"); mPMCStatusLogger = new PMCStatusLogger(TAG + ".log", TAG); // Check if any Bluetooth devices are connected ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>(); Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices(); <|startfocus|> if (bondedDevices == null) return false; <|endfocus|> for (BluetoothDevice bd : bondedDevices) { if (bd.isConnected()) { results.add(bd); } } if (results.isEmpty()) { Log.e(TAG, "No device is connected"); return false; } Log.d(TAG, "Finish initialize()"); return true;
code_review:  Few lines below you print "No device is connected" log message. For consistency, the same (or similar - as appropriate) log message should be printed here as well. Alternatively, use this "if" check outside the "for" loop. 
target code: private boolean initialize() { Log.d(TAG, "Start initialize()"); mPMCStatusLogger = new PMCStatusLogger(TAG + ".log", TAG); // Check if any Bluetooth devices are connected ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>(); Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices(); if (bondedDevices == null) { Log.e(TAG, "Bonded devices list is null"); return false; } for (BluetoothDevice bd : bondedDevices) { if (bd.isConnected()) { results.add(bd); } } if (results.isEmpty()) { Log.e(TAG, "No device is connected"); return false; } Log.d(TAG, "Finish initialize()"); return true;
response: private boolean initialize() { Log.d(TAG, "Start initialize()"); mPMCStatusLogger = new PMCStatusLogger(TAG + ".log", TAG); // Check if any Bluetooth devices are connected ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>(); Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices(); if (bondedDevices == null) { Log.e(TAG, "No device is connected"); return false; } for (BluetoothDevice bd : bondedDevices) { if (bd.isConnected()) { results.add(bd); } } if (results.isEmpty()) { Log.e(TAG, "No device is connected"); return false; } Log.d(TAG, "Finish initialize()"); return true; }

sample: 538
buggy_code:  private boolean initialize() { Log.d(TAG, "Start initialize()"); mPMCStatusLogger = new PMCStatusLogger(TAG + ".log", TAG); // Check if any BT devices are connected ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>(); <|startfocus|> for (BluetoothDevice bd : mBluetoothAdapter.getBondedDevices()) { <|endfocus|> if (bd.isConnected()) { results.add(bd); } } if (results.isEmpty()) { Log.e(TAG, "No device is connected"); return false; } Log.d(TAG, "Finish initialize()"); return true;
code_review:  Could the getBondedDevices() return value be null? If "yes", then you need to consider that. 
target code: private boolean initialize() { Log.d(TAG, "Start initialize()"); mPMCStatusLogger = new PMCStatusLogger(TAG + ".log", TAG); // Check if any BT devices are connected ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>(); Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices(); if (bondedDevices == null) return false; for (BluetoothDevice bd : bondedDevices) { if (bd.isConnected()) { results.add(bd); } } if (results.isEmpty()) { Log.e(TAG, "No device is connected"); return false; } Log.d(TAG, "Finish initialize()"); return true;
response: private boolean initialize() { Log.d(TAG, "Start initialize()"); mPMCStatusLogger = new PMCStatusLogger(TAG + ".log", TAG); // Check if any BT devices are connected ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>(); BluetoothDevice[] bondedDevices = mBluetoothAdapter.getBondedDevices(); if (bondedDevices != null) { for (BluetoothDevice bd : bondedDevices) { if (bd.isConnected()) { results.add(bd); } } } if (results.isEmpty()) { Log.e(TAG, "No device is connected"); return false; } Log.d(TAG, "Finish initialize()"); return true; }

sample: 539
buggy_code:  boolean bt_off_mute = false; Bundle extras = intent.getExtras(); if (extras == null) { Log.e(TAG, "No parameters specified"); return; } // Always initialize() if (!initialize()) { mPMCStatusLogger.logStatus("initialize() Failed"); return; } // Check if it is baseline BT is on but not stream if (extras.containsKey("BT_ON_NotPlay")) { <|startfocus|> Log.v(TAG, "NotPlay is specified for baseline case of only BT on"); <|endfocus|> // Do nothing further mPMCStatusLogger.logStatus("READY"); mPMCStatusLogger.logStatus("SUCCEED"); return; } if (!extras.containsKey("PlayTime")) { Log.e(TAG, "No Play Time specified"); return; } tmpStr = extras.getString("PlayTime"); Log.d(TAG, "Play Time = " + tmpStr); playTime = Integer.valueOf(tmpStr); if (!extras.containsKey("MusicURL")) { Log.e(TAG, "No Music URL specified"); return; }
code_review:  BT -> Bluetooth Same applies to the rest of the CL below (when using BT in comments). 
target code: boolean bt_off_mute = false; Bundle extras = intent.getExtras(); if (extras == null) { Log.e(TAG, "No parameters specified"); return; } // Always initialize() if (!initialize()) { mPMCStatusLogger.logStatus("initialize() Failed"); return; } // Check if it is baseline BT is on but not stream if (extras.containsKey("BT_ON_NotPlay")) { Log.v(TAG, "NotPlay is specified for baseline case that only Bluetooth is on"); // Do nothing further mPMCStatusLogger.logStatus("READY"); mPMCStatusLogger.logStatus("SUCCEED"); return; } if (!extras.containsKey("PlayTime")) { Log.e(TAG, "No Play Time specified"); return; } tmpStr = extras.getString("PlayTime"); Log.d(TAG, "Play Time = " + tmpStr); playTime = Integer.valueOf(tmpStr); if (!extras.containsKey("MusicURL")) { Log.e(TAG, "No Music URL specified"); return; }
response: boolean bluetoothOffMute = false; Bundle extras = intent.getExtras(); if (extras == null) { Log.e(TAG, "No parameters specified"); return; } // Always initialize() if (!initialize()) { mPMCStatusLogger.logStatus("initialize() Failed"); return; } // Check if it is baseline Bluetooth is on but not streaming if (extras.containsKey("BT_ON_NotPlay")) { Log.v(TAG, "NotPlay is specified for baseline case of only Bluetooth on"); // Do nothing further mPMCStatusLogger.logStatus("READY"); mPMCStatusLogger.logStatus("SUCCEED"); return; } if (!extras.containsKey("PlayTime")) { Log.e(TAG, "No Play Time specified"); return; } String playTimeStr = extras.getString("PlayTime"); Log.d(TAG, "Play Time = " + playTimeStr); int playTime = Integer.valueOf(playTimeStr); if (!extras.containsKey("MusicURL")) { Log.e(TAG, "No Music URL specified"); return; }

sample: 540
buggy_code:  Log.e(TAG, "No Play Time specified"); return; } tmpStr = extras.getString("PlayTime"); Log.d(TAG, "Play Time = " + tmpStr); playTime = Integer.valueOf(tmpStr); if (!extras.containsKey("MusicURL")) { Log.e(TAG, "No Music URL specified"); return; } musicUrl = extras.getString("MusicURL"); Log.d(TAG, "Music URL = " + musicUrl); <|startfocus|> // playTime and musicUrl are necessory <|endfocus|> if (playTime == 0 || musicUrl.isEmpty() || musicUrl == null) { Log.d(TAG, "Invalid paramters"); return; } // Check if it is the baseline for BT off but streaming with speakers muted if (extras.containsKey("BT_OFF_Mute")) { Log.v(TAG, "Mute is specified for BT off baseline case"); bt_off_mute = true; } else { if (!extras.containsKey("CodecType")) { Log.e(TAG, "No Codec Type specified"); return; }
code_review:  typo 
target code: Log.e(TAG, "No Play Time specified"); return; } tmpStr = extras.getString("PlayTime"); Log.d(TAG, "Play Time = " + tmpStr); playTime = Integer.valueOf(tmpStr); if (!extras.containsKey("MusicURL")) { Log.e(TAG, "No Music URL specified"); return; } musicUrl = extras.getString("MusicURL"); Log.d(TAG, "Music URL = " + musicUrl); // playTime and musicUrl are necessary if (playTime == 0 || musicUrl.isEmpty() || musicUrl == null) { Log.d(TAG, "Invalid paramters"); return; } // Check if it is the baseline for BT off but streaming with speakers muted if (extras.containsKey("BT_OFF_Mute")) { Log.v(TAG, "Mute is specified for BT off baseline case"); bt_off_mute = true; } else { if (!extras.containsKey("CodecType")) { Log.e(TAG, "No Codec Type specified"); return; }
response: Log.e(TAG, "No Play Time specified"); return; } tmpStr = extras.getString("PlayTime"); Log.d(TAG, "Play Time = " + tmpStr); playTime = Integer.valueOf(tmpStr); if (!extras.containsKey("MusicURL")) { Log.e(TAG, "No Music URL specified"); return; } musicUrl = extras.getString("MusicURL"); Log.d(TAG, "Music URL = " + musicUrl); // playTime and musicUrl are necessary if (playTime == 0 || musicUrl.isEmpty() || musicUrl == null) { Log.d(TAG, "Invalid parameters"); return; } // Check if it is the baseline for BT off but streaming with speakers muted if (extras.containsKey("BT_OFF_Mute")) { Log.v(TAG, "Mute is specified for BT off baseline case"); bt_off_mute = true; } else { if (!extras.containsKey("CodecType")) { Log.e(TAG, "No Codec Type specified"); return; }

sample: 541
buggy_code:  public void testClientsCanConnect() { NsdService service = makeService(); NsdManager client1 = connectClient(service); NsdManager client2 = connectClient(service); <|startfocus|> // disconnect client1 // disconnect client2 <|endfocus|>
code_review:  should these comments be marked TODO here as well as above? 
target code: public void testClientsCanConnect() { NsdService service = makeService(); NsdManager client1 = connectClient(service); NsdManager client2 = connectClient(service); // TODO: disconnect client1 // TODO: disconnect client2
response: public void testClientsCanConnect() { NsdService service = makeService(); NsdManager client1 = connectClient(service); NsdManager client2 = connectClient(service); // TODO: disconnect client1 // TODO: disconnect client2 }

sample: 542
buggy_code:  } public MockPrintStream(OutputStream os) { super(os); } @Override public void clearError() { super.clearError(); } @Override public void setError() { super.setError(); } } /** * {@link java.io.PrintStream#PrintStream(String)} */ public void test_Constructor_Ljava_lang_String() throws IOException { PrintStream os = new PrintStream(testFilePath); os.print(UNICODE_STRING); os.close(); <|startfocus|> assertFileContents(UNICODE_STRING.getBytes(), testFile); <|endfocus|> } /** * {@link java.io.PrintStream#PrintStream(String, String)} */ public void test_Constructor_Ljava_lang_String_Ljava_lang_String() throws Exception { // Test that a bogus charset is mentioned in the exception try { new PrintStream(testFilePath, "Bogus"); fail("Exception expected"); } catch (UnsupportedEncodingException e) { assertNotNull(e.getMessage()); } { PrintStream os = new PrintStream(testFilePath, "utf-8"); os.print(UNICODE_STRING); os.close();
code_review:  Think this should be explicit, if only by providing Charset.defaultCharset() as the argument. On Android defaultCharset() is guaranteed to be UTF-8, but using defaultCharset() is nicely self-documenting. 
target code: } public MockPrintStream(OutputStream os) { super(os); } @Override public void clearError() { super.clearError(); } @Override public void setError() { super.setError(); } } /** * {@link java.io.PrintStream#PrintStream(String)} */ public void test_Constructor_Ljava_lang_String() throws IOException { PrintStream os = new PrintStream(testFilePath); os.print(UNICODE_STRING); os.close(); assertFileContents(UNICODE_STRING.getBytes(Charset.defaultCharset()), testFile); } /** * {@link java.io.PrintStream#PrintStream(String, String)} */ public void test_Constructor_Ljava_lang_String_Ljava_lang_String() throws Exception { // Test that a bogus charset is mentioned in the exception try { new PrintStream(testFilePath, "Bogus"); fail("Exception expected"); } catch (UnsupportedEncodingException e) { assertNotNull(e.getMessage()); } { PrintStream os = new PrintStream(testFilePath, "utf-8"); os.print(UNICODE_STRING); os.close();
response: } public MockPrintStream(OutputStream os) { super(os); } @Override public void clearError() { super.clearError(); } @Override public void setError() { super.setError(); } } /** * {@link java.io.PrintStream#PrintStream(String)} */ public void test_Constructor_Ljava_lang_String() throws IOException { PrintStream os = new PrintStream(testFilePath); os.print(UNICODE_STRING); os.close(); assertFileContents(UNICODE_STRING.getBytes(), testFile); } /** * {@link java.io.PrintStream#PrintStream(String, String)} */ public void test_Constructor_Ljava_lang_String_Ljava_lang_String() throws Exception { // Test that a bogus charset is mentioned in the exception try { new PrintStream(testFilePath, "Bogus"); fail("Exception expected"); } catch (UnsupportedEncodingException e) { assertNotNull(e.getMessage()); } { PrintStream os = new PrintStream(testFilePath, Charset.defaultCharset().name()); os.print(UNICODE_STRING); os.close();

sample: 543
buggy_code:  public void test_ConstructorLjava_io_OutputStreamZLjava_lang_String() throws Exception { try { new PrintStream(new ByteArrayOutputStream(), false, "%Illegal_name!"); fail("Expected UnsupportedEncodingException"); } catch (UnsupportedEncodingException e) { // expected } { ByteArrayOutputStream bos = new ByteArrayOutputStream(); <|startfocus|> PrintStream printStream = new PrintStream(bos, true, "utf-8"); <|endfocus|> printStream.print(UNICODE_STRING); printStream.close(); assertByteArraysEqual(UNICODE_STRING.getBytes(StandardCharsets.UTF_8), bos.toByteArray()); } { ByteArrayOutputStream bos = new ByteArrayOutputStream(); PrintStream printStream = new PrintStream(bos, true, "utf-16"); printStream.print(UNICODE_STRING); printStream.close(); assertByteArraysEqual(UNICODE_STRING.getBytes(StandardCharsets.UTF_16), bos.toByteArray()); }
code_review:  Suggestion: true /* autoFlush */ because I had to go look it up. YMMV, up to you given the general readability of the existing code. Looks like we don't have any tests for autoFlush=false either, FWIW. We probably have some implicit tests (like this one) for autoflush = true. 
target code: public void test_ConstructorLjava_io_OutputStreamZLjava_lang_String() throws Exception { try { new PrintStream(new ByteArrayOutputStream(), false, "%Illegal_name!"); fail("Expected UnsupportedEncodingException"); } catch (UnsupportedEncodingException e) { // expected } { ByteArrayOutputStream bos = new ByteArrayOutputStream(); PrintStream printStream = new PrintStream(bos, true /* autoFlush */, "utf-8"); printStream.print(UNICODE_STRING); printStream.close(); assertByteArraysEqual(UNICODE_STRING.getBytes(StandardCharsets.UTF_8), bos.toByteArray()); } { ByteArrayOutputStream bos = new ByteArrayOutputStream(); PrintStream printStream = new PrintStream(bos, true, "utf-16"); printStream.print(UNICODE_STRING); printStream.close(); assertByteArraysEqual(UNICODE_STRING.getBytes(StandardCharsets.UTF_16), bos.toByteArray()); }
response: import org.apache.lucene.index.Term; import org.apache.lucene.search.Query; import org.apache.lucene.store.Directory; import java.io.IOException; /** * Writer that optionally flushes/commits after every write. */ public class AutoCommitWriter extends IndexWriter { private boolean autoCommit; AutoCommitWriter(Directory dir, IndexWriterConfig config) throws IOException { this(dir, config, false); } AutoCommitWriter(Directory dir, IndexWriterConfig config, boolean autoCommit) throws IOException { super(dir, config); setAutoCommit(autoCommit); } /** * This method will override Gerrit configuration index.name.commitWithin * until next Gerrit restart (or reconfiguration through this method). * * @param enable auto commit */ public void setAutoCommit(boolean enable) { this.autoCommit = enable; } @Override public void addDocument(Iterable<? extends IndexableField> doc) throws IOException { super.addDocument(doc); autoFlush(); } @Override public void addDocuments(Iterable<? extends Iterable<? extends IndexableField>> docs) throws IOException { super.addDocuments(docs); autoFlush(); } @Override public void updateDocuments(Term delTerm, Iterable<? extends Iterable<? extends IndexableField>> docs) throws IOException { super.updateDocuments(delTerm, docs); } } package org.eclipse.mylyn.wikitext.asciidoc; import java.util.Map; import org.eclipse.mylyn.wikitext.parser.markup.MarkupLanguageConfiguration; /** * Extended configuration for the AsciiDoc markup language * * @author Jeremie Bresson * @since 3.0.0 */ public class AsciiDocMarkupLanguageConfiguration extends MarkupLanguageConfiguration { private Map<String, String> initialAttributes = Collections.emptyMap(); public Map<String, String> getInitialAttributes() { return initialAttributes; } public void setInitialAttributes(Map<String, String> initialAttributes) { this.initialAttributes = initialAttributes; } } // The count should be one for the first rule. verify(firstRule, times(1)).rewritePre(any(), any()); verify(secondRule, times(0)).rewritePre(any(), any()); verify(thirdRule, times(0)).rewritePre(any(), any()); // Case 3: a mixture of returning true/false. // Iteration1:

sample: 544
buggy_code:  confirmConfiguration(); return; } // Thread-unsafe access to mApfFilter but just used for debugging. final ApfFilter apfFilter = mApfFilter; final ProvisioningConfiguration provisioningConfig = mConfiguration; IndentingPrintWriter pw = new IndentingPrintWriter(writer, " "); pw.println(mTag + " APF dump:"); pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { <|startfocus|> if (provisioningConfig != null) { pw.println("No active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities); } else { pw.println("N/A -- no ProvisioningConfiguration available"); } <|endfocus|> } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println();
code_review:  you can use Object.toString() to manage null refs for you and fold both branches into something like: pw.pringln("No active ApfFilter. Capabilities: " + Objects.toString(provisioningConfig.mApfCapabilities); 
target code: confirmConfiguration(); return; } // Thread-unsafe access to mApfFilter but just used for debugging. final ApfFilter apfFilter = mApfFilter; final ProvisioningConfiguration provisioningConfig = mConfiguration; IndentingPrintWriter pw = new IndentingPrintWriter(writer, " "); pw.println(mTag + " APF dump:"); pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { pw.print("No active ApfFilter"); pw.println((provisioningConfig != null) ? "; provisioned capabilities: " + provisioningConfig.mApfCapabilities : ""); } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println();
response: confirmConfiguration(); return; // Thread-unsafe access to mApfFilter but just used for debugging. final ApfFilter apfFilter = mApfFilter; final ProvisioningConfiguration provisioningConfig = mConfiguration; IndentingPrintWriter pw = new IndentingPrintWriter(writer, " "); pw.println(mTag + " APF dump:"); pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { pw.println("No active ApfFilter. Capabilities: " + Objects.toString(provisioningConfig.mApfCapabilities)); } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println();

sample: 545
buggy_code:  return; } // Thread-unsafe access to mApfFilter but just used for debugging. final ApfFilter apfFilter = mApfFilter; final ProvisioningConfiguration provisioningConfig = mConfiguration; IndentingPrintWriter pw = new IndentingPrintWriter(writer, " "); pw.println(mTag + " APF dump:"); pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { <|startfocus|> if (provisioningConfig != null) { pw.println("No active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities); } else { pw.println("N/A -- no ProvisioningConfiguration available"); } <|endfocus|> } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println();
code_review:  line too long. 
target code: return; } // Thread-unsafe access to mApfFilter but just used for debugging. final ApfFilter apfFilter = mApfFilter; final ProvisioningConfiguration provisioningConfig = mConfiguration; IndentingPrintWriter pw = new IndentingPrintWriter(writer, " "); pw.println(mTag + " APF dump:"); pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { pw.print("No active ApfFilter"); pw.println((provisioningConfig != null) ? "; provisioned capabilities: " + provisioningConfig.mApfCapabilities : ""); } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println();
response: final ApfFilter apfFilter = mApfFilter; final ProvisioningConfiguration provisioningConfig = mConfiguration; IndentingPrintWriter pw = new IndentingPrintWriter(writer, " "); pw.println(mTag + " APF dump:"); pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { if (provisioningConfig != null) { pw.println("No active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities); } else { pw.println("N/A -- no ProvisioningConfiguration available"); } } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println();

sample: 546
buggy_code:  pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { if (provisioningConfig != null) { pw.println("No active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities); } else { pw.println("N/A -- no ProvisioningConfiguration available"); } } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); <|startfocus|> pw.println((provisioningConfig != null) ? provisioningConfig : "N/A"); <|endfocus|> pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println(); pw.println(mTag + " connectivity packet log:"); pw.println(); pw.println("Debug with python and scapy via:"); pw.println("shell$ python"); pw.println(">>> from scapy import all as scapy");
code_review:  Consider using Objects.toString(). 
target code: pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { if (provisioningConfig != null) { pw.println("No active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities); } else { pw.println("N/A -- no ProvisioningConfiguration available"); } } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println(Objects.toString(provisioningConfig, "N/A")); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println(); pw.println(mTag + " connectivity packet log:"); pw.println(); pw.println("Debug with python and scapy via:"); pw.println("shell$ python"); pw.println(">>> from scapy import all as scapy");
response: pw.increaseIndent(); if (apfFilter != null) { apfFilter.dump(pw); } else { if (provisioningConfig != null) { pw.println("No active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities); } else { pw.println("N/A -- no ProvisioningConfiguration available"); } } pw.decreaseIndent(); pw.println(); pw.println(mTag + " current ProvisioningConfiguration:"); pw.increaseIndent(); pw.println(Objects.toString(provisioningConfig, "N/A")); pw.decreaseIndent(); pw.println(); pw.println(mTag + " StateMachine dump:"); pw.increaseIndent(); mLocalLog.readOnlyLocalLog().dump(fd, pw, args); pw.decreaseIndent(); pw.println(); pw.println(mTag + " connectivity packet log:"); pw.println(); pw.println("Debug with python and scapy via:"); pw.println("shell$ python"); pw.println(">>> from scapy import all as scapy");

sample: 547
buggy_code:  private int putListener(Object listener, NsdServiceInfo s) { checkListener(listener); final int key; synchronized (mMapLock) { int valueIndex = mListenerMap.indexOfValue(listener); checkArgument(valueIndex == -1, "listener already in use"); <|startfocus|> key = Math.abs(mListenerKey++); <|endfocus|> mListenerMap.put(key, listener); mServiceMap.put(key, s); } return key;
code_review:  I think the old code also tried to make sure key couldn't be equal to zero. (a) is that true and if so (b) should be check that here too? It's not immediately clear to me why zero is invalid. 
target code: private int putListener(Object listener, NsdServiceInfo s) { checkListener(listener); final int key; synchronized (mMapLock) { int valueIndex = mListenerMap.indexOfValue(listener); checkArgument(valueIndex == -1, "listener already in use"); key = nextListenerKey(); mListenerMap.put(key, listener); mServiceMap.put(key, s); } return key;
response: private int putListener(Object listener, NsdServiceInfo s) { checkListener(listener); final int key; synchronized (mMapLock) { int valueIndex = mListenerMap.indexOfValue(listener); checkArgument(valueIndex == -1, "listener already in use"); key = Math.abs(mListenerKey++); mListenerMap.put(key, listener); mServiceMap.put(key, s); } return key; }

sample: 548
buggy_code:  public void onOwnAddressRead(AdvertisingSet advertisingSet, int addressType, String address) { Log.d("onOwnAddressRead" + mEventType + " " + setIndex); Bundle results = new Bundle(); <|startfocus|> results.putInt("set_id", setIndex); <|endfocus|> results.putInt("addressType", addressType); results.putString("address", address); mEventFacade.postEvent(mEventType + setIndex + "onOwnAddressRead", results);
code_review:  nit: let's not mix camel and snake case 
target code: public void onOwnAddressRead(AdvertisingSet advertisingSet, int addressType, String address) { Log.d("onOwnAddressRead" + mEventType + " " + setIndex); Bundle results = new Bundle(); results.putInt("setId", setIndex); results.putInt("addressType", addressType); results.putString("address", address); mEventFacade.postEvent(mEventType + setIndex + "onOwnAddressRead", results);
response: import org.apache.impala.catalog.AggregateFunction; import org.apache.impala.catalog.Type; import org.apache.impala.common.AnalysisException; import org.apache.impala.common.InternalException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; /** * Encapsulates all the information needed to compute a list of aggregate functions with * compatible grouping including their distributed execution. * A mix of distinct and non-distinct aggregation functions is allowed as long as all * distinct functions have the same distinct expressions. * * Execution is modeled as a tree of AggregateInfo objects which express the local and * merging aggregate computations. The tree structure looks as follows: * - for non-distinct aggregation: * - aggInfo: contains the original aggregation functions and grouping exprs * - aggInfo.mergeAggInfo: contains the merging aggregation functions (grouping * exprs are identical) * - for distinct aggregation (also see createDistinctAggInfo()): */ public NetlinkSocketAddress(int nlPortId) { this(nlPortId, 0); } protected String handleSetTestResultCmd(final String request) { String response = RESPONSE_OK; StringTokenizer tokenizer = new StringTokenizer(request, " "); String testName = ""; SensorTestResult result = SensorTestResult.FAIL; String message = ""; try { tokenizer.nextToken(); /* SET */ tokenizer.nextToken(); /* TEST */ tokenizer.nextToken(); /* RESULT */ testName = tokenizer.nextToken(); final String resultToken = tokenizer.nextToken(); if (resultToken.equals("PASS")) { result = SensorTestResult.PASS; ++mCountPassed; message = "Test PASSED"; String logMessage = ""; while (tokenizer.hasMoreTokens()) { logMessage += tokenizer.nextToken() + " "; } Log.i(TAG, logMessage); response = RESPONSE_OK; } else if (resultToken.equals("FAIL")) { result = SensorTestResult.FAIL; ++mCountFailed; message = "Test FAILED"; while (tokenizer.hasMoreTokens()) { message += " " + tokenizer.nextToken(); } response = RESPONSE_OK; } } catch (Exception e) { // Handle exception } return response; } public void onOwnAddressRead(AdvertisingSet advertisingSet, int addressType

sample: 549
buggy_code:  public void run() { <|startfocus|> byte[] annotatedDexContent = Base64.getDecoder().decode(base64DexWithExtensionClass); InMemoryDexClassLoader classLoader = new InMemoryDexClassLoader(ByteBuffer.wrap(annotatedDexContent), ClassLoader.getSystemClassLoader()); <|endfocus|> Class<?> klass = null; try { klass = classLoader.loadClass(classWithSourceDebugExtension); } catch (ClassNotFoundException e) { logWriter.println("--> Debuggee: Could not find class " + classWithSourceDebugExtension); } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("--> Debuggee: SourceDebugExtensionDebuggee..."); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
code_review:  The downside of this is that we no longer can run this test against java (which I continue to use for reference from time to time). It would be nice to keep the java compatibility in some way (in a separate CL) 
target code: public void run() { ClassLoader classLoader = null; if (System.getProperty("java.vendor").contains("Android")) { classLoader = getClassLoaderInitializedWithDexFile(); } else { classLoader = getClassLoaderInitializedWithClassFile(); } Class<?> klass = null; try { klass = classLoader.loadClass(classWithSourceDebugExtension); } catch (ClassNotFoundException e) { logWriter.println("--> Debuggee: Could not find class " + classWithSourceDebugExtension); } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("--> Debuggee: SourceDebugExtensionDebuggee..."); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
response: public void run() { byte[] annotatedDexContent = Base64.getDecoder().decode(base64DexWithExtensionClass); InMemoryDexClassLoader classLoader = new InMemoryDexClassLoader(ByteBuffer.wrap(annotatedDexContent), ClassLoader.getSystemClassLoader()); Class<?> klass = null; try { klass = classLoader.loadClass(classWithSourceDebugExtension); } catch (ClassNotFoundException e) { logWriter.println("--> Debuggee: Could not find class " + classWithSourceDebugExtension); } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("--> Debuggee: SourceDebugExtensionDebuggee..."); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE); }

sample: 550
buggy_code: import android.media.MediaDescription; import android.media.MediaMetadata; import android.media.AudioManager; import android.media.session.MediaSessionManager; import android.os.Bundle; import android.os.Looper; import android.test.AndroidTestCase; import android.util.Log; import java.nio.ByteBuffer; import java.util.List; import java.util.Arrays; import java.util.ArrayList; import static org.mockito.Mockito.isA; import static org.mockito.Mockito.anyInt; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; public class AvrcpTest extends AndroidTestCase { <|startfocus|> @Override public void setUp() { <|endfocus|> if (Looper.myLooper() == null) Looper.prepare(); } public void testCanBuild() { Avrcp a = Avrcp.make(getContext()); } public void testFailedBrowseStart() { Context mockContext = mock(Context.class); AudioManager mockAudioManager = mock(AudioManager.class); PackageManager mockPackageManager = mock(PackageManager.class); when(mockAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)).thenReturn(100); when(mockContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mockAudioManager); 
code_review:  This seems unrelated to the commit message. 
target code: import android.media.MediaDescription; import android.media.MediaMetadata; import android.media.AudioManager; import android.media.session.MediaSessionManager; import android.os.Bundle; import android.os.Looper; import android.test.AndroidTestCase; import android.util.Log; import java.nio.ByteBuffer; import java.util.List; import java.util.Arrays; import java.util.ArrayList; import static org.mockito.Mockito.isA; import static org.mockito.Mockito.anyInt; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; public class AvrcpTest extends AndroidTestCase { public void testCanStart() { if (Looper.myLooper() == null) Looper.prepare(); } public void testCanBuild() { Avrcp a = Avrcp.make(getContext()); } public void testFailedBrowseStart() { Context mockContext = mock(Context.class); AudioManager mockAudioManager = mock(AudioManager.class); PackageManager mockPackageManager = mock(PackageManager.class); when(mockAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)).thenReturn(100); when(mockContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mockAudioManager);
response: import android.media.MediaDescription; import android.media.MediaMetadata; import android.media.AudioManager; import android.media.session.MediaSessionManager; import android.os.Bundle; import android.os.Looper; import android.test.AndroidTestCase; import android.util.Log; import java.nio.ByteBuffer; import java.util.List; import java.util.Arrays; import java.util.ArrayList; import static org.mockito.Mockito.isA; import static org.mockito.Mockito.anyInt; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; public class AvrcpTest extends AndroidTestCase { @Override public void setUp() { if (Looper.myLooper() == null) Looper.prepare(); } public void testCanBuild() { Avrcp a = Avrcp.make(getContext()); } public void testFailedBrowseStart() { Context mockContext = mock(Context.class); AudioManager mockAudioManager = mock(AudioManager.class); PackageManager mockPackageManager = mock(PackageManager.class); when(mockAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)).thenReturn(100); when(mockContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mockAudioManager); } }

sample: 551
buggy_code:  protected void setWifiConfigurationPassword( WifiConfiguration wifiConfiguration, WifiSecurity wifiSecurity, String password) { if (wifiSecurity == WifiSecurity.WEP) { int length = password.length(); // WEP-40, WEP-104, and 256-bit WEP (WEP-232?) <|startfocus|> if ((length == 10 || length == 26 || length == 58) <|endfocus|> && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } }
code_review:  If length == 16 in ASCII is to be supported below, length == 32 also needs to be added here. 
target code: protected void setWifiConfigurationPassword( WifiConfiguration wifiConfiguration, WifiSecurity wifiSecurity, String password) { if (wifiSecurity == WifiSecurity.WEP) { int length = password.length(); // WEP-40, WEP-104, and 256-bit WEP (WEP-232?) if ((length == 10 || length == 26 || length == 32 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } }
response: protected void setWifiConfigurationPassword(WifiConfiguration wifiConfiguration, WifiSecurity wifiSecurity, String password) { if (wifiSecurity == WifiSecurity.WEP) { int length = password.length(); if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } } }

sample: 552
buggy_code:  protected void setWifiConfigurationPassword( WifiConfiguration wifiConfiguration, WifiSecurity wifiSecurity, String password) { if (wifiSecurity == WifiSecurity.WEP) { int length = password.length(); // WEP-40, WEP-104, and 256-bit WEP (WEP-232?) if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; <|startfocus|> } else if (length == 5 || length == 13 || length == 16) { <|endfocus|> wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } }
code_review:  Please explain why 256-bit WEP is excluded in this condition. 
target code: protected void setWifiConfigurationPassword( WifiConfiguration wifiConfiguration, WifiSecurity wifiSecurity, String password) { if (wifiSecurity == WifiSecurity.WEP) { int length = password.length(); // WEP-40, WEP-104, and 256-bit WEP (WEP-232?) if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16 || length == 29) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } }
response: protected void setWifiConfigurationPassword(WifiConfiguration wifiConfiguration, WifiSecurity wifiSecurity, String password) { if (wifiSecurity == WifiSecurity.WEP) { int length = password.length(); if ((length == 10 || length == 26 || length == 58) && password.matches("[0-9A-Fa-f]*")) { wifiConfiguration.wepKeys[0] = password; } else if (length == 5 || length == 13 || length == 16) { wifiConfiguration.wepKeys[0] = '"' + password + '"'; } } else { if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { return; } if (password.matches("[0-9A-Fa-f]{64}")) { wifiConfiguration.preSharedKey = password; } else { wifiConfiguration.preSharedKey = '"' + password + '"'; } } }

sample: 553
buggy_code:  0x8888888877777777L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar2(0x7FFFFFFFFFFFFFFFL, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar2(2L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar3(2L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar4(0L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar4(0xFFFFFFFF00000000L, 5L, 7L)); <|startfocus|> assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar5(0L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar5(0xFFFFFFFF00000000L, 5L, 7L)); <|endfocus|> assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar6(0L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar6(2L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar6(-9000L, 5L, 7L)); 
code_review:  Test also 1, -1, 0x100000000L, Long.MAX_VALUE, Long.MIN_VALUE. 
target code: 0x8888888877777777L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar2(0x7FFFFFFFFFFFFFFFL, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar2(2L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar3(2L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar4(0L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar4(0xFFFFFFFF00000000L, 5L, 7L)); long[] expected_1 = {5L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L}; assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar6(0L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar6(2L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar6(-9000L, 5L, 7L));
response: assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar5(0L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar5(0xFFFFFFFF00000000L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar6(0L, 5L, 7L)); assertEqual(5L, $noinline$LongNonmatCondCst_LongVarVar6(2L, 5L, 7L)); assertEqual(7L, $noinline$LongNonmatCondCst_LongVarVar6(-9000L, 5L, 7L));

sample: 554
buggy_code:  protected SuggestionCursor getCurrentSuggestions() { if (mSearchActivityView.getSuggestions() == null) { return null; } <|startfocus|> return mSearchActivityView.getSuggestions().getResult(); <|endfocus|>
code_review:  Minor comment: though functionally there is no difference, something like import com.android.quicksearchbox.Suggestions; ... Suggestions suggestions = mSearchActivityView.getSuggestions(); if (suggestions == null) { return null; } return suggestions.getResult(); would be preferred. 
target code: protected SuggestionCursor getCurrentSuggestions() { if (mSearchActivityView.getSuggestions() == null) { return null; } return suggestions.getResult();
response: protected SuggestionCursor getCurrentSuggestions() { if (mSearchActivityView.getSuggestions() == null) { return null; } return mSearchActivityView.getSuggestions().getResult(); }

sample: 555
buggy_code:  // Make sure that core apps are optimized according to their own "reason". // If the core apps are not preopted in the B OTA, and REASON_AB_OTA is not speed // (by default is speed-profile) they will be interepreted/JITed. This in itself is // not a problem as we will end up doing profile guided compilation. However, some // core apps may be loaded by system server which doesn't JIT and we need to make <|startfocus|> // sure we don't interpret-only. <|endfocus|> int compilationReason = p.coreApp ? PackageManagerService.REASON_CORE_APP : PackageManagerService.REASON_AB_OTA; mDexoptCommands.addAll(generatePackageDexopts(p, compilationReason)); } for (PackageParser.Package p : others) { // We assume here that there are no core apps left. if (p.coreApp) { throw new IllegalStateException("Found a core app that's not important"); } mDexoptCommands.addAll( generatePackageDexopts(p, PackageManagerService.REASON_FIRST_BOOT)); } completeSize = mDexoptCommands.size(); 
code_review:  this can be misleading (given the name of the old filter). I suggest.. "..we need to make sure we are not interpreting all their code in that process." 
target code: // Make sure that core apps are optimized according to their own "reason". // If the core apps are not preopted in the B OTA, and REASON_AB_OTA is not speed // (by default is speed-profile) they will be interepreted/JITed. This in itself is // not a problem as we will end up doing profile guided compilation. However, some // core apps may be loaded by system server which doesn't JIT and we need to make // sure we are not interpreting all their code in that process. int compilationReason = p.coreApp ? PackageManagerService.REASON_CORE_APP : PackageManagerService.REASON_AB_OTA; mDexoptCommands.addAll(generatePackageDexopts(p, compilationReason)); } for (PackageParser.Package p : others) { // We assume here that there are no core apps left. if (p.coreApp) { throw new IllegalStateException("Found a core app that's not important"); } mDexoptCommands.addAll( generatePackageDexopts(p, PackageManagerService.REASON_FIRST_BOOT)); } completeSize = mDexoptCommands.size();
response: // Make sure that core apps are optimized according to their own "reason". // If the core apps are not preopted in the B OTA, and REASON_AB_OTA is not speed // (by default is speed-profile) they will be interepreted/JITed. This in itself is // not a problem as we will end up doing profile guided compilation. However, some // core apps may be loaded by system server which doesn't JIT and we need to make // sure we don't interpret-only. int compilationReason = p.coreApp ? PackageManagerService.REASON_CORE_APP : PackageManagerService.REASON_AB_OTA; mDexoptCommands.addAll(generatePackageDexopts(p, compilationReason)); for (PackageParser.Package p : others) { // We assume here that there are no core apps left. if (p.coreApp) { throw new IllegalStateException("Found a core app that's not important"); } mDexoptCommands.addAll(generatePackageDexopts(p, PackageManagerService.REASON_FIRST_BOOT)); } completeSize = mDexoptCommands.size();

sample: 556
buggy_code:  classLoader = getClassLoaderInitializedWithDexFile(); } else { classLoader = getClassLoaderInitializedWithClassFile(); } Class<?> klass = null; try { klass = classLoader.loadClass(classWithSourceDebugExtension); } catch (ClassNotFoundException e) { logWriter.println("--> Debuggee: Could not find class " + classWithSourceDebugExtension); } // Create an instance of classWithSourceDebugExtension so the <|startfocus|> // SourceDebugExntension metadata can be reported back to the debugger. <|endfocus|> Object o = null; if (klass != null) { try { o = klass.getConstructor().newInstance(); } catch (Exception e) { logWriter.println("--> Debuggee: Failed to instantiate " + classWithSourceDebugExtension + ": " + e); } } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("--> Debuggee: SourceDebugExtensionDebuggee..."); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
code_review:  SourceDebugExtension 
target code: classLoader = getClassLoaderInitializedWithDexFile(); } else { classLoader = getClassLoaderInitializedWithClassFile(); } Class<?> klass = null; try { klass = classLoader.loadClass(classWithSourceDebugExtension); } catch (ClassNotFoundException e) { logWriter.println("--> Debuggee: Could not find class " + classWithSourceDebugExtension); } // Create an instance of classWithSourceDebugExtension so the // SourceDebugExtension metadata can be reported back to the debugger. Object o = null; if (klass != null) { try { o = klass.getConstructor().newInstance(); } catch (Exception e) { logWriter.println("--> Debuggee: Failed to instantiate " + classWithSourceDebugExtension + ": " + e); } } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("--> Debuggee: SourceDebugExtensionDebuggee..."); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
response: classLoader = getClassLoaderInitializedWithDexFile(); } else { classLoader = getClassLoaderInitializedWithClassFile(); } Class<?> klass = null; try { klass = classLoader.loadClass(classWithSourceDebugExtension); } catch (ClassNotFoundException e) { logWriter.println("--> Debuggee: Could not find class " + classWithSourceDebugExtension); } Object o = null; if (klass != null) { try { o = klass.getConstructor().newInstance(); } catch (Exception e) { logWriter.println("--> Debuggee: Failed to instantiate " + classWithSourceDebugExtension + ": " + e); } } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("--> Debuggee: SourceDebugExtensionDebuggee..."); synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);

sample: 557
buggy_code:  /** * The MBMS middleware should send this when a download of single file has completed or * failed. Mandatory extras are * {@link #EXTRA_RESULT} * {@link #EXTRA_INFO} * {@link #EXTRA_REQUEST} * {@link #EXTRA_TEMP_LIST} * {@link #EXTRA_FINAL_URI} * * TODO: future systemapi */ public static final String ACTION_DOWNLOAD_RESULT_INTERNAL = <|startfocus|> "android.telephony.mbms.ACTION_DOWNLOAD_RESULT_INTERNAL"; <|endfocus|> /** * The MBMS middleware should send this when it wishes to request {@code content://} URIs to * serve as temp files for downloads or when it wishes to resume paused downloads. Mandatory * extras are * {@link #EXTRA_REQUEST} * * Optional extras are * {@link #EXTRA_FD_COUNT} (0 if not present) * {@link #EXTRA_PAUSED_LIST} (empty if not present) * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST =
code_review:  Naming convention for these is (might be easier to clean these up now than later when its hardcoded in the bowels of vendor code): android.telephony.mbms.action.DOWNLOAD_RESULT_INTERNAL Also, suggest: ACTION_DOWNLOAD_COMPLETE 
target code: /** * The MBMS middleware should send this when a download of single file has completed or * failed. Mandatory extras are * {@link #EXTRA_RESULT} * {@link #EXTRA_INFO} * {@link #EXTRA_REQUEST} * {@link #EXTRA_TEMP_LIST} * {@link #EXTRA_FINAL_URI} * * TODO: future systemapi */ public static final String ACTION_DOWNLOAD_RESULT_INTERNAL = "android.telephony.mbms.action.DOWNLOAD_RESULT_INTERNAL"; /** * The MBMS middleware should send this when it wishes to request {@code content://} URIs to * serve as temp files for downloads or when it wishes to resume paused downloads. Mandatory * extras are * {@link #EXTRA_REQUEST} * * Optional extras are * {@link #EXTRA_FD_COUNT} (0 if not present) * {@link #EXTRA_PAUSED_LIST} (empty if not present) * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST =
response: public static final String ACTION_DOWNLOAD_RESULT_INTERNAL = "android.telephony.mbms.action.DOWNLOAD_RESULT_INTERNAL"; public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.action.FILE_DESCRIPTOR_REQUEST";

sample: 558
buggy_code:  * * Optional extras are * {@link #EXTRA_FD_COUNT} (0 if not present) * {@link #EXTRA_PAUSED_LIST} (empty if not present) * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.ACTION_FILE_DESCRIPTOR_REQUEST"; /** <|startfocus|> * The MBMS middleware should send this when it wishes to signal that there may be orphaned * files in the app's filesystem. Mandatory extras are <|endfocus|> * {@link #EXTRA_TEMP_FILES_IN_USE} * * TODO: future systemapi */ public static final String ACTION_CLEANUP = "android.telephony.mbms.ACTION_CLEANUP"; /** * Integer extra indicating the result code of the download. * TODO: put in link to error list * TODO: future systemapi (here and and all extras) */ public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; /** * Extra containing the {@link android.telephony.mbms.FileInfo} for which the download result
code_review:  This is just to cleanup a specified list of temp files, right? Might make more sense to just say The MBMS middleware sends this when it wishes to cleanup temporary files in the app's filesystem. 
target code: * * Optional extras are * {@link #EXTRA_FD_COUNT} (0 if not present) * {@link #EXTRA_PAUSED_LIST} (empty if not present) * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.ACTION_FILE_DESCRIPTOR_REQUEST"; /** * The MBMS middleware should send this when it wishes to clean up temp files in the app's * filesystem. Mandatory extras are: * {@link #EXTRA_TEMP_FILES_IN_USE} * * TODO: future systemapi */ public static final String ACTION_CLEANUP = "android.telephony.mbms.ACTION_CLEANUP"; /** * Integer extra indicating the result code of the download. * TODO: put in link to error list * TODO: future systemapi (here and and all extras) */ public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; /** * Extra containing the {@link android.telephony.mbms.FileInfo} for which the download result
response: /** * Optional extras are: * - EXTRA_FD_COUNT (0 if not present) * - EXTRA_PAUSED_LIST (empty if not present) * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.ACTION_FILE_DESCRIPTOR_REQUEST"; /** * The MBMS middleware should send this when it wishes to signal that there may be orphaned * files in the app's filesystem. Mandatory extras are: * - EXTRA_TEMP_FILES_IN_USE * * TODO: future systemapi */ public static final String ACTION_CLEANUP = "android.telephony.mbms.ACTION_CLEANUP"; /** * Integer extra indicating the result code of the download. * * TODO: put in link to error list * TODO: future systemapi (here and all extras) */ public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; /** * Extra containing the FileInfo for which the download result */ public static final String EXTRA_FILE_INFO = "android.telephony.mbms.EXTRA_FILE_INFO";

sample: 559
buggy_code:  * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.ACTION_FILE_DESCRIPTOR_REQUEST"; /** * The MBMS middleware should send this when it wishes to signal that there may be orphaned * files in the app's filesystem. Mandatory extras are * {@link #EXTRA_TEMP_FILES_IN_USE} * * TODO: future systemapi */ public static final String ACTION_CLEANUP = <|startfocus|> "android.telephony.mbms.ACTION_CLEANUP"; <|endfocus|> /** * Integer extra indicating the result code of the download. * TODO: put in link to error list * TODO: future systemapi (here and and all extras) */ public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; /** * Extra containing the {@link android.telephony.mbms.FileInfo} for which the download result * is for. Must not be null. */ public static final String EXTRA_INFO = "android.telephony.mbms.EXTRA_INFO"; /**
code_review:  .action.CLEANUP_TEMP_FILES 
target code: * * TODO: future systemapi */ public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.ACTION_FILE_DESCRIPTOR_REQUEST"; /** * The MBMS middleware should send this when it wishes to signal that there may be orphaned * files in the app's filesystem. Mandatory extras are * {@link #EXTRA_TEMP_FILES_IN_USE} * * TODO: future systemapi */ public static final String ACTION_CLEANUP = "android.telephony.mbms.action.CLEANUP"; /** * Integer extra indicating the result code of the download. * TODO: put in link to error list * TODO: future systemapi (here and and all extras) */ public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; /** * Extra containing the {@link android.telephony.mbms.FileInfo} for which the download result * is for. Must not be null. */ public static final String EXTRA_INFO = "android.telephony.mbms.EXTRA_INFO"; /**
response: public static final String ACTION_FILE_DESCRIPTOR_REQUEST = "android.telephony.mbms.ACTION_FILE_DESCRIPTOR_REQUEST"; public static final String ACTION_CLEANUP = "android.telephony.mbms.ACTION_CLEANUP"; public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; public static final String EXTRA_INFO = "android.telephony.mbms.EXTRA_INFO";

sample: 560
buggy_code:  * files in the app's filesystem. Mandatory extras are * {@link #EXTRA_TEMP_FILES_IN_USE} * * TODO: future systemapi */ public static final String ACTION_CLEANUP = "android.telephony.mbms.ACTION_CLEANUP"; /** * Integer extra indicating the result code of the download. * TODO: put in link to error list * TODO: future systemapi (here and and all extras) */ <|startfocus|> public static final String EXTRA_RESULT = "android.telephony.mbms.EXTRA_RESULT"; <|endfocus|> /** * Extra containing the {@link android.telephony.mbms.FileInfo} for which the download result * is for. Must not be null. */ public static final String EXTRA_INFO = "android.telephony.mbms.EXTRA_INFO"; /** * Extra containing the {@link DownloadRequest} for which the download result or file * descriptor request is for. Must not be null. */ public static final String EXTRA_REQUEST = "android.telephony.mbms.EXTRA_REQUEST"; /**
code_review:  Convention is: android.telephony.mbms.extra.RESULT 
target code: * files in the app's filesystem. Mandatory extras are * {@link #EXTRA_TEMP_FILES_IN_USE} * * TODO: future systemapi */ public static final String ACTION_CLEANUP = "android.telephony.mbms.ACTION_CLEANUP"; /** * Integer extra indicating the result code of the download. * TODO: put in link to error list * TODO: future systemapi (here and and all extras) */ public static final String EXTRA_RESULT = "android.telephony.mbms.extra.RESULT"; /** * Extra containing the {@link android.telephony.mbms.FileInfo} for which the download result * is for. Must not be null. */ public static final String EXTRA_INFO = "android.telephony.mbms.EXTRA_INFO"; /** * Extra containing the {@link DownloadRequest} for which the download result or file * descriptor request is for. Must not be null. */ public static final String EXTRA_REQUEST = "android.telephony.mbms.EXTRA_REQUEST"; /**
response: public static final String EXTRA_RESULT = "android.telephony.mbms.extra.RESULT";

sample: 561
buggy_code:  * decoded downloaded file resides. Must not be null. */ public static final String EXTRA_FINAL_URI = "android.telephony.mbms.EXTRA_FINAL_URI"; /** * Extra containing an integer indicating the number of temp files requested. */ public static final String EXTRA_FD_COUNT = "android.telephony.mbms.EXTRA_FD_COUNT"; /** * Extra containing a list of {@link Uri}s that the middleware is requesting write access to. */ <|startfocus|> public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.EXTRA_PAUSED_LIST"; <|endfocus|> /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the * response to {@link #ACTION_FILE_DESCRIPTOR_REQUEST}. These are temp files that are meant * to be used for new file downloads. */ public static final String EXTRA_FREE_URI_LIST = "android.telephony.mbms.EXTRA_FREE_URI_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the
code_review:  Extra used with {@link #ACTION_FILE_DESCRIPTOR_REQUEST} 
target code: * decoded downloaded file resides. Must not be null. */ public static final String EXTRA_FINAL_URI = "android.telephony.mbms.EXTRA_FINAL_URI"; /** * Extra containing an integer indicating the number of temp files requested. */ public static final String EXTRA_FD_COUNT = "android.telephony.mbms.EXTRA_FD_COUNT"; /** * Extra containing a list of {@link Uri}s that the middleware is requesting write access to. */ public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.extra.PAUSED_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the * response to {@link #ACTION_FILE_DESCRIPTOR_REQUEST}. These are temp files that are meant * to be used for new file downloads. */ public static final String EXTRA_FREE_URI_LIST = "android.telephony.mbms.EXTRA_FREE_URI_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the
response: public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.EXTRA_PAUSED_LIST";

sample: 562
buggy_code:  * decoded downloaded file resides. Must not be null. */ public static final String EXTRA_FINAL_URI = "android.telephony.mbms.EXTRA_FINAL_URI"; /** * Extra containing an integer indicating the number of temp files requested. */ public static final String EXTRA_FD_COUNT = "android.telephony.mbms.EXTRA_FD_COUNT"; /** * Extra containing a list of {@link Uri}s that the middleware is requesting write access to. */ <|startfocus|> public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.EXTRA_PAUSED_LIST"; <|endfocus|> /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the * response to {@link #ACTION_FILE_DESCRIPTOR_REQUEST}. These are temp files that are meant * to be used for new file downloads. */ public static final String EXTRA_FREE_URI_LIST = "android.telephony.mbms.EXTRA_FREE_URI_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the
code_review:  will resume downloading? 
target code: * decoded downloaded file resides. Must not be null. */ public static final String EXTRA_FINAL_URI = "android.telephony.mbms.EXTRA_FINAL_URI"; /** * Extra containing an integer indicating the number of temp files requested. */ public static final String EXTRA_FD_COUNT = "android.telephony.mbms.EXTRA_FD_COUNT"; /** * Extra containing a list of {@link Uri}s that the middleware is requesting write access to. */ public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.extra.PAUSED_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the * response to {@link #ACTION_FILE_DESCRIPTOR_REQUEST}. These are temp files that are meant * to be used for new file downloads. */ public static final String EXTRA_FREE_URI_LIST = "android.telephony.mbms.EXTRA_FREE_URI_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the
response: public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.EXTRA_PAUSED_LIST";

sample: 563
buggy_code:  * still using. */ public static final String EXTRA_TEMP_FILES_IN_USE = "android.telephony.mbms.EXTRA_TEMP_FILES_IN_USE"; public static final int RESULT_SUCCESSFUL = 1; public static final int RESULT_CANCELLED = 2; public static final int RESULT_EXPIRED = 3; // TODO - more results! private final Context mContext; private int mSubId = INVALID_SUBSCRIPTION_ID; private IMbmsDownloadService mService; <|startfocus|> private final IMbmsDownloadManagerListener mCallback; <|endfocus|> private final String mDownloadAppName; public MbmsDownloadManager(Context context, IMbmsDownloadManagerListener callback, String downloadAppName, int subId) { mContext = context; mCallback = callback; mDownloadAppName = downloadAppName; mSubId = subId; } /** * Create a new MbmsDownloadManager using the system default data subscription ID. * * Note that this call will bind a remote service and that may take a bit. This * may throw an Illegal ArgumentException or RemoteException. * * @hide */
code_review:  Convention is to use "Callback" when there are multiple methods; eg. DownloadManagerCallback 
target code: * still using. */ public static final String EXTRA_TEMP_FILES_IN_USE = "android.telephony.mbms.EXTRA_TEMP_FILES_IN_USE"; public static final int RESULT_SUCCESSFUL = 1; public static final int RESULT_CANCELLED = 2; public static final int RESULT_EXPIRED = 3; // TODO - more results! private final Context mContext; private int mSubId = INVALID_SUBSCRIPTION_ID; private IMbmsDownloadService mService; private final IMbmsDownloadManagerCallback mCallback; private final String mDownloadAppName; public MbmsDownloadManager(Context context, IMbmsDownloadManagerListener callback, String downloadAppName, int subId) { mContext = context; mCallback = callback; mDownloadAppName = downloadAppName; mSubId = subId; } /** * Create a new MbmsDownloadManager using the system default data subscription ID. * * Note that this call will bind a remote service and that may take a bit. This * may throw an Illegal ArgumentException or RemoteException. * * @hide */
response: public static final String EXTRA_TEMP_FILES_IN_USE = "android.telephony.mbms.EXTRA_TEMP_FILES_IN_USE"; public static final int RESULT_SUCCESSFUL = 1; public static final int RESULT_CANCELLED = 2; public static final int RESULT_EXPIRED = 3; private final Context mContext; private int mSubId = INVALID_SUBSCRIPTION_ID; private IMbmsDownloadService mService; private final IMbmsDownloadManagerListener mCallback; private final String mDownloadAppName; public MbmsDownloadManager(Context context, IMbmsDownloadManagerListener callback, String downloadAppName, int subId) { mContext = context; mCallback = callback; mDownloadAppName = downloadAppName; mSubId = subId; } /** * Create a new MbmsDownloadManager using the system default data subscription ID. * * Note that this call will bind a remote service and that may take a bit. This * may throw an Illegal ArgumentException or RemoteException. * * @hide */

sample: 564
buggy_code: <|startfocus|> public MbmsDownloadManager(Context context, IMbmsDownloadManagerListener callback, <|endfocus|> String downloadAppName, int subId) { mContext = context; mCallback = callback; mDownloadAppName = downloadAppName; mSubId = subId;
code_review:  If you envision only using the createManager method, this should be private 
target code: private MbmsDownloadManager(Context context, IMbmsDownloadManagerCallback callback, String downloadAppName, int subId) { mContext = context; mCallback = callback; mDownloadAppName = downloadAppName; mSubId = subId;
response: private void validateFragmentContributions(IBuildEntry binIncludes) { try { Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(PDEProject.getPluginXml(fProject).getContents()); XPath xpath = XPathFactory.newInstance().newXPath(); NodeList list = (NodeList) xpath.evaluate("/plugin/extension[@point='org.eclipse.e4.workbench.model']/fragment/@uri", doc, XPathConstants.NODESET); for (int i = 0; i < list.getLength(); i++) { Node node = list.item(i); validateBinIncludes(binIncludes, node.getNodeValue()); } } catch (Exception e) { e.printStackTrace(); } } private void validateApplicationContributions(IBuildEntry binIncludes) { try { Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(PDEProject.getPluginXml(fProject).getContents()); XPath xpath = XPathFactory.newInstance().newXPath(); Node nodeProduct = (Node) xpath.evaluate("/plugin/extension[@point='org.eclipse.core.runtime.products']/product", doc, XPathConstants.NODE); if (nodeProduct != null) { Node attValue = (Node) xpath.evaluate("property[@name='applicationXMI']/@value", nodeProduct, XPathConstants.NODE); if (attValue != null) { if (attValue.getNodeValue().isEmpty()) { //Error: no URL defined but should already be reported. } else { validateBinIncludes(binIncludes, attValue.getNodeValue()); } } else { validateBinIncludes(binIncludes, "Application.e4xmi"); } } } catch (Exception e) { e.printStackTrace(); } } private IAtsTeamDefinition getTeamDefinition() { if (teamDef == null) { TeamDefinitionDialog ld = new TeamDefinitionDialog("Select Team", "Select Team"); ld.setInput(TeamDefinitions.getTeamReleaseableDefinitions(Active.Active)); int result = ld.open(); if (result == 0) { return (IAtsTeamDefinition) ld.getResult()[0]; } return null; } else { return teamDef; } } private MbmsDownloadManager(Context context, IMbmsDownloadManagerListener callback, String downloadAppName, int subId) { mContext = context; mCallback = callback; mDownloadAppName = downloadAppName; mSubId =

sample: 565
buggy_code: <|startfocus|> public MbmsStreamingManager(Context context, IMbmsStreamingManagerListener listener, String streamingAppName, int subId) { <|endfocus|> mContext = context; mAppName = streamingAppName; mCallbackToApp = listener; mSubId = subId;
code_review:  private if the static are always doing to be used. 
target code: private MbmsStreamingManager(Context context, IMbmsStreamingManagerCallback listener, String streamingAppName, int subscriptionId) { mContext = context; mAppName = streamingAppName; mCallbackToApp = listener; mSubId = subId;
response: private MbmsStreamingManager(Context context, IMbmsStreamingManagerListener listener, String streamingAppName, int subId) { mContext = context; mAppName = streamingAppName; mCallbackToApp = listener; mSubId = subId; }

sample: 566
buggy_code: <|startfocus|> public MbmsStreamingManager(Context context, IMbmsStreamingManagerListener listener, String streamingAppName, int subId) { <|endfocus|> mContext = context; mAppName = streamingAppName; mCallbackToApp = listener; mSubId = subId;
code_review:  subscriptionId (Telephony convention is to use it in full). 
target code: private MbmsStreamingManager(Context context, IMbmsStreamingManagerCallback listener, String streamingAppName, int subscriptionId) { mContext = context; mAppName = streamingAppName; mCallbackToApp = listener; mSubId = subId;
response: public MbmsStreamingManager(Context context, IMbmsStreamingManagerListener listener, String streamingAppName, int subscriptionId) { mContext = context; mAppName = streamingAppName; mCallbackToApp = listener; mSubId = subscriptionId; }

sample: 567
buggy_code:  mBrightnessMode != brightnessMode) { if (DEBUG) Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode); mLastColor = mColor; mColor = color; mMode = mode; mOnMS = onMS; mOffMS = offMS; mBrightnessMode = brightnessMode; <|startfocus|> mInitialized = true; <|endfocus|> Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")"); try { setLight_native(mNativePointer, mId, color, mode, onMS, offMS, brightnessMode); } finally { Trace.traceEnd(Trace.TRACE_TAG_POWER); } }
code_review:  nit: I'd prefer this to be above line 136, in the same order of the if statement. 
target code: mBrightnessMode != brightnessMode) { if (DEBUG) Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode); mLastColor = mColor; mColor = color; mMode = mode; mOnMS = onMS; mOffMS = offMS; mBrightnessMode = brightnessMode; Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")"); try { setLight_native(mNativePointer, mId, color, mode, onMS, offMS, brightnessMode); } finally { Trace.traceEnd(Trace.TRACE_TAG_POWER); } }
response: private final ReviewerState state; private final NotifyHandling notify; private final ListMultimap<RecipientType, Id> accountsToNotify; private final ApprovalsUtil approvalsUtil; private final PatchSetUtil psUtil; private final ReviewerAdded reviewerAdded; private final AccountCache accountCache; private final ChangeResource rsrc; private final AddReviewerSender.Factory addReviewerSenderFactory; private final NotesMigration migration; private final Provider<IdentifiedUser> user; private final Provider<ReviewDb> dbProvider; private final Collection<Address> addedCCsByEmail = new ArrayList<>(); private List<PatchSetApproval> addedReviewers = new ArrayList<>(); private Collection<Account.Id> addedCCs = new ArrayList<>(); private PatchSet patchSet; private Result opResult = null; @Inject PostReviewersOp(ApprovalsUtil approvalsUtil, PatchSetUtil psUtil, ReviewerAdded reviewerAdded, AccountCache accountCache, AddReviewerSender.Factory addReviewerSenderFactory, NotesMigration migration, Provider<IdentifiedUser> user, Provider<ReviewDb> dbProvider, @Assisted ChangeResource rsrc, @Assisted Map<Account.Id, ChangeControl> reviewers, @Assisted Collection<Address> reviewersByEmail) { this.state = rsrc.getReviewerState(); this.notify = rsrc.getNotifyHandling(); this.accountsToNotify = rsrc.getAccountsToNotify(); this.approvalsUtil = approvalsUtil; this.psUtil = psUtil; this.reviewerAdded = reviewerAdded; this.accountCache = accountCache; this.rsrc = rsrc; this.addReviewerSenderFactory = addReviewerSenderFactory; this.migration = migration; this.user = user; this.dbProvider = dbProvider; this.addedCCsByEmail.addAll(reviewersByEmail); this.addedReviewers.addAll(reviewers.values()); }

sample: 568
buggy_code:  public static boolean contactsLoaded = false; private static HashMap<String, ArrayList<String>> email = new HashMap<String, ArrayList<String>>(); private static HashMap<String, ArrayList<String>> phone = new HashMap<String, ArrayList<String>>(); private static HashMap<String, ArrayList<String>> address = new HashMap<String, ArrayList<String>>(); private static HashMap<String, String> name = new HashMap<String, String>(); private static HashSet<String> ContactSet = new HashSet<String>(); <|startfocus|> <|endfocus|> public static boolean hasFilter(byte[] filter) { return filter != null && filter.length > 0; } public static boolean isNameAndNumberOnly(byte[] filter) { // For vcard 2.0: VERSION,N,TEL is mandatory // For vcard 3.0, VERSION,N,FN,TEL is mandatory // So we only need to make sure that no other fields except optionally // NICKNAME is set // Check that an explicit filter is not set. If not, this means // return everything if (!hasFilter(filter)) {
code_review:  I'm not a big fan of having 5 different hash maps. Could we instead create a helper object that can be used to keep track of all this info? 
target code: public static boolean contactsLoaded = false; private static HashMap<String, ArrayList<String>> email = new HashMap<String, ArrayList<String>>(); private static HashMap<String, ArrayList<String>> phone = new HashMap<String, ArrayList<String>>(); private static HashMap<String, ArrayList<String>> address = new HashMap<String, ArrayList<String>>(); private static HashMap<String, String> name = new HashMap<String, String>(); private static HashSet<String> ContactSet = new HashSet<String>(); private static final String TYPE_NAME = "name"; private static final String TYPE_PHONE = "phone"; private static final String TYPE_EMAIL = "email"; private static final String TYPE_ADDRESS = "address"; public static boolean hasFilter(byte[] filter) { return filter != null && filter.length > 0; } public static boolean isNameAndNumberOnly(byte[] filter) { // For vcard 2.0: VERSION,N,TEL is mandatory // For vcard 3.0, VERSION,N,FN,TEL is mandatory // So we only need to make sure that no other fields except optionally // NICKNAME is set // Check that an explicit filter is not set. If not, this means // return everything if (!hasFilter(filter)) {
response: public static boolean contactsLoaded = false; private static ContactInfo contactInfo = new ContactInfo(); public static boolean hasFilter(byte[] filter) { return filter != null && filter.length > 0; } public static boolean isNameAndNumberOnly(byte[] filter) { // For vcard 2.0: VERSION,N,TEL is mandatory // For vcard 3.0, VERSION,N,FN,TEL is mandatory // So we only need to make sure that no other fields except optionally // NICKNAME is set // Check that an explicit filter is not set. If not, this means // return everything if (!hasFilter(filter)) { // implementation } } public class ContactInfo { private HashMap<String, ArrayList<String>> email = new HashMap<String, ArrayList<String>>(); private HashMap<String, ArrayList<String>> phone = new HashMap<String, ArrayList<String>>(); private HashMap<String, ArrayList<String>> address = new HashMap<String, ArrayList<String>>(); private HashMap<String, String> name = new HashMap<String, String>(); private HashSet<String> contactSet = new HashSet<String>(); // getters and setters for the above fields }

sample: 569
buggy_code:  } public NetworkStats readNetworkStatsDetail(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { <|startfocus|> // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the <|endfocus|> // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust =
code_review:  packet 
target code: } public NetworkStats readNetworkStatsDetail(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packet twice, once as a native IPv4 // packet on the stacked interface, and once as translated to an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust =
response: } public NetworkStats readNetworkStatsDetail(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust =

sample: 570
buggy_code:  NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat <|startfocus|> // packets needs to be subtracted for the root UID on the base interface both for tx <|endfocus|> // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L);
code_review:  a native IPv4 packet 
target code: NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packet needs to be subtracted from the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L);
response: NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; synchronized (sStackedIfaces) { final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). } } }

sample: 571
buggy_code:  NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat <|startfocus|> // packets needs to be subtracted for the root UID on the base interface both for tx <|endfocus|> // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L);
code_review:  translated to 
target code: NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packet needs to be subtracted from the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L);
response: NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; synchronized (sStackedIfaces) { final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). } } }

sample: 572
buggy_code:  readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat <|startfocus|> // packets needs to be subtracted for the root UID on the base interface both for tx <|endfocus|> // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) {
code_review:  from 
target code: readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packet needs to be subtracted from the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) {
response: readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; synchronized (sStackedIfaces) { final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { // Adjust the stats for 464xlat traffic on the base interface // both for tx and rx traffic } } }

sample: 573
buggy_code:  readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat <|startfocus|> // packets needs to be subtracted for the root UID on the base interface both for tx <|endfocus|> // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) {
code_review:  packet 
target code: readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // For 464xlat traffic, xt_qtaguid sees every IPv4 packets twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the // base interface. For correct stats accounting on the base interface, every 464xlat // packet needs to be subtracted from the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) {
response: readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; synchronized (sStackedIfaces) { final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { // packet } } }

sample: 574
buggy_code:  for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; <|startfocus|> // TODO: does Entry#operations need to be adjusted too ? <|endfocus|> } } stats.combineValues(adjust); } } // For 464xlat traffic, xt_qtaguid only counts the bytes of the inner IPv4 packet sent on // the stacked interface with prefix "v4-" and drops the IPv6 header size after unwrapping. // To account correctly for on-the-wire traffic, adds the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry);
code_review:  I don't think so, no. That's an app-settable field which has nothing to do with bytes or packets. Also, IIRC it's not interface-specific. 
target code: for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; } } stats.combineValues(adjust); } } // For 464xlat traffic, xt_qtaguid only counts the bytes of the inner IPv4 packet sent on // the stacked interface with prefix "v4-" and drops the IPv6 header size after unwrapping. // To account correctly for on-the-wire traffic, adds the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry);
response: for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; } } stats.combineValues(adjust); for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); }

sample: 575
buggy_code:  adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; // TODO: does Entry#operations need to be adjusted too ? } } stats.combineValues(adjust); } } // For 464xlat traffic, xt_qtaguid only counts the bytes of the inner IPv4 packet sent on // the stacked interface with prefix "v4-" and drops the IPv6 header size after unwrapping. <|startfocus|> // To account correctly for on-the-wire traffic, adds the 20 additional bytes difference <|endfocus|> // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface != null && entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) { entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA; entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA; entry.rxPackets = 0; entry.txPackets = 0; stats.combineValues(entry); } } return stats; } 
code_review:  add 
target code: adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; // TODO: does Entry#operations need to be adjusted too ? } } stats.combineValues(adjust); } } // For 464xlat traffic, xt_qtaguid only counts the bytes of the inner IPv4 packet sent on // the stacked interface with prefix "v4-" and drops the IPv6 header size after unwrapping. // To account correctly for on-the-wire traffic, add the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface != null && entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) { entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA; entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA; entry.rxPackets = 0; entry.txPackets = 0; stats.combineValues(entry); } } return stats; }
response: adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; // TODO: does Entry#operations need to be adjusted too ? stats.combineValues(adjust); // For 464xlat traffic, xt_qtaguid only counts the bytes of the inner IPv4 packet sent on // the stacked interface with prefix "v4-" and drops the IPv6 header size after unwrapping. // To account correctly for on-the-wire traffic, adds the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface != null && entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) { entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA; entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA; entry.rxPackets = 0; entry.txPackets = 0; stats.combineValues(entry); } } return stats;

sample: 576
buggy_code:  private static final String CLATD_INTEFACE_PREFIX = "v4-"; /** Path to {@code /proc/net/xt_qtaguid/iface_stat_all}. */ private final File mStatsXtIfaceAll; /** Path to {@code /proc/net/xt_qtaguid/iface_stat_fmt}. */ private final File mStatsXtIfaceFmt; /** Path to {@code /proc/net/xt_qtaguid/stats}. */ private final File mStatsXtUid; <|startfocus|> // TODO: for testability, do no use a static variable. <|endfocus|> @GuardedBy("sStackedIfaces") private static final ArrayMap<String, String> sStackedIfaces = new ArrayMap<>(); public static void noteStackedIface(String stackedIface, String baseIface) { synchronized (sStackedIfaces) { if (baseIface != null) { sStackedIfaces.put(stackedIface, baseIface); } else { sStackedIfaces.remove(stackedIface); } } } public NetworkStatsFactory() { this(new File("/proc/")); } @VisibleForTesting public NetworkStatsFactory(File procRoot) {
code_review:  "not" 
target code: private static final String CLATD_INTEFACE_PREFIX = "v4-"; /** Path to {@code /proc/net/xt_qtaguid/iface_stat_all}. */ private final File mStatsXtIfaceAll; /** Path to {@code /proc/net/xt_qtaguid/iface_stat_fmt}. */ private final File mStatsXtIfaceFmt; /** Path to {@code /proc/net/xt_qtaguid/stats}. */ private final File mStatsXtUid; // TODO: to improve testability and avoid global state, do no use a static variable. @GuardedBy("sStackedIfaces") private static final ArrayMap<String, String> sStackedIfaces = new ArrayMap<>(); public static void noteStackedIface(String stackedIface, String baseIface) { synchronized (sStackedIfaces) { if (baseIface != null) { sStackedIfaces.put(stackedIface, baseIface); } else { sStackedIfaces.remove(stackedIface); } } } public NetworkStatsFactory() { this(new File("/proc/")); } @VisibleForTesting public NetworkStatsFactory(File procRoot) {
response: private static final String CLATD_INTEFACE_PREFIX = "v4-"; private final File mStatsXtIfaceAll; private final File mStatsXtIfaceFmt; private final File mStatsXtUid; // TODO: for testability, do not use a static variable. @GuardedBy("sStackedIfaces") private static final ArrayMap<String, String> sStackedIfaces = new ArrayMap<>(); public static void noteStackedIface(String stackedIface, String baseIface) { synchronized (sStackedIfaces) { if (baseIface != null) { sStackedIfaces.put(stackedIface, baseIface); } else { sStackedIfaces.remove(stackedIface); } } } public NetworkStatsFactory() { this(new File("/proc/")); } @VisibleForTesting public NetworkStatsFactory(File procRoot) {

sample: 577
buggy_code:  // from root UID on the base interface. NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { <|startfocus|> adjust.txBytes -= entry.txBytes; adjust.txPackets -= entry.txPackets; adjust.rxBytes -= entry.rxBytes; <|endfocus|> adjust.rxPackets -= entry.rxPackets; } } stats.combineValues(adjust); } } // Double sigh, all rx traffic on clat needs to be tweaked to // account for the dropped IPv6 header size post-unwrap. for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface != null && entry.iface.startsWith(CLATD_INTEFACE_PREFIX)) { // Delta between IPv4 header (20b) and IPv6 header (40b) entry.rxBytes = entry.rxPackets * 20;
code_review:  I see that NetworkStats.Entry has an add method (that modifies |operations| as well). Two questions: [1] should it have a subtract() method? [2] should we be fixing up |operations| as well? 
target code: // from root UID on the base interface. NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; } } stats.combineValues(adjust); } } // Double sigh, all rx traffic on clat needs to be tweaked to // account for the dropped IPv6 header size post-unwrap. for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface != null && entry.iface.startsWith(CLATD_INTEFACE_PREFIX)) { // Delta between IPv4 header (20b) and IPv6 header (40b) entry.rxBytes = entry.rxPackets * 20;
response: // from root UID on the base interface. NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.txBytes -= entry.txBytes; adjust.txPackets -= entry.txPackets; adjust.rxBytes -= entry.rxBytes; adjust.rxPackets -= entry.rxPackets; } } stats.combineValues(adjust); // Double sigh, all rx traffic on clat needs to be tweaked to // account for the dropped IPv6 header size post-unwrap. for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface != null && entry.iface.startsWith(CLATD_INTEFACE_PREFIX)) { // Delta between IPv4 header (20b) and IPv6 header (40b) entry.rxBytes = entry.rxPackets * 20; } }

sample: 578
buggy_code:  private void sendNsdStateChangeBroadcast(boolean isEnabled) { final Intent intent = new Intent(NsdManager.ACTION_NSD_STATE_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); <|startfocus|> intent.putExtra(NsdManager.EXTRA_NSD_STATE, enabledMessage(isEnabled)); <|endfocus|> mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
code_review:  This appears to be incorrect. This should send the NSD_STATE_{ENABLED,DISABLED} values (1 and 2), in order to be consistent. Right? 
target code: private void sendNsdStateChangeBroadcast(boolean isEnabled) { final Intent intent = new Intent(NsdManager.ACTION_NSD_STATE_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); int nsdState = isEnabled ? NsdManager.NSD_STATE_ENABLED : NsdManager.NSD_STATE_DISABLED; intent.putExtra(NsdManager.EXTRA_NSD_STATE, nsdState); mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
response: private void sendNsdStateChangeBroadcast(boolean isEnabled) { final Intent intent = new Intent(NsdManager.ACTION_NSD_STATE_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); intent.putExtra(NsdManager.EXTRA_NSD_STATE, isEnabled ? NsdManager.NSD_STATE_ENABLED : NsdManager.NSD_STATE_DISABLED); mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); }

sample: 579
buggy_code:  for (String conscryptAlg : conscryptAlgs) { Provider.Service service = getService(bc, conscryptAlg); if (service != null) { bcClasses.add(service.getClassName()); } } assertTrue(bcClasses.size() > 0); // Sanity check // 3. Determine which IDs in BC point to that set of classes Set<String> shouldBeOverriddenBcIds = new HashSet<>(); <|startfocus|> for (Entry<Object, Object> entry : bc.entrySet()) { String key = (String) entry.getKey(); <|endfocus|> if (key.contains(" ")) { continue; } if (key.startsWith("Alg.Alias.")) { key = key.substring("Alg.Alias.".length()); } Provider.Service service = getService(bc, key); if (bcClasses.contains(service.getClassName())) { shouldBeOverriddenBcIds.add(key); } } // 4. Check each of those IDs to ensure that it's present in Conscrypt Set<String> nonOverriddenIds = new TreeSet<>(); for (String shouldBeOverridenBcId : shouldBeOverriddenBcIds) {
code_review:  is you only ever access the key, why not just loop over bc.keySet() ? 
target code: for (String conscryptAlg : conscryptAlgs) { Provider.Service service = getService(bc, conscryptAlg); if (service != null) { bcClasses.add(service.getClassName()); } } assertTrue(bcClasses.size() > 0); // Sanity check // 3. Determine which IDs in BC point to that set of classes Set<String> shouldBeOverriddenBcIds = new HashSet<>(); for (Object keyObject : bc.keySet()) { String key = (String) keyObject; if (key.contains(" ")) { continue; } if (key.startsWith("Alg.Alias.")) { key = key.substring("Alg.Alias.".length()); } Provider.Service service = getService(bc, key); if (bcClasses.contains(service.getClassName())) { shouldBeOverriddenBcIds.add(key); } } // 4. Check each of those IDs to ensure that it's present in Conscrypt Set<String> nonOverriddenIds = new TreeSet<>(); for (String shouldBeOverridenBcId : shouldBeOverriddenBcIds) {
response: for (String key : bc.keySet()) { if (key.contains(" ")) { continue; } if (key.startsWith("Alg.Alias.")) { key = key.substring("Alg.Alias.".length()); } Provider.Service service = getService(bc, key); if (bcClasses.contains(service.getClassName())) { shouldBeOverriddenBcIds.add(key); } }

sample: 580
buggy_code:  * * This terminates at unescaped AVA separators ("+") or RDN * separators (",", ";"), and removes cosmetic whitespace at the end of * values. */ AVA(Reader in, Map<String, String> keywordMap) throws IOException { this(in, DEFAULT, keywordMap); } /** * Parse an AVA string formatted according to format. <|startfocus|> * * XXX format RFC1779 should only allow RFC1779 syntax but is * actually DEFAULT with RFC1779 keywords. <|endfocus|> */ AVA(Reader in, int format) throws IOException { this(in, format, Collections.<String, String>emptyMap()); } /** * Parse an AVA string formatted according to format. * * @param in Reader containing AVA String * @param format parsing format * @param keywordMap a Map where a keyword String maps to a corresponding * OID String. Each AVA keyword will be mapped to the corresponding OID. * If an entry does not exist, it will fallback to the builtin
code_review:  these three lines (153-155) do not occur upstream. Upon further investigation, they seem to have existed in 7u40 but not in 8u60 so we probably forgot to drop these in the update to 8u60? 
target code: * * This terminates at unescaped AVA separators ("+") or RDN * separators (",", ";"), and removes cosmetic whitespace at the end of * values. */ AVA(Reader in, Map<String, String> keywordMap) throws IOException { this(in, DEFAULT, keywordMap); } /** * Parse an AVA string formatted according to format. */ AVA(Reader in, int format) throws IOException { this(in, format, Collections.<String, String>emptyMap()); } /** * Parse an AVA string formatted according to format. * * @param in Reader containing AVA String * @param format parsing format * @param keywordMap a Map where a keyword String maps to a corresponding * OID String. Each AVA keyword will be mapped to the corresponding OID. * If an entry does not exist, it will fallback to the builtin
response: AVA(Reader in, Map<String, String> keywordMap) throws IOException { this(in, DEFAULT, keywordMap); } AVA(Reader in, int format) throws IOException { this(in, format, Collections.<String, String>emptyMap()); } AVA(Reader in, int format, Map<String, String> keywordMap) throws IOException { // implementation }

sample: 581
buggy_code:  return s; } catch (IOException e) { // should not occur throw new RuntimeException("AVA error: " + e, e); } } private static DerValue parseHexString (Reader in, int format) throws IOException { int c; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte b = 0; int cNdx = 0; while (true) { c = in.read(); if (isTerminator(c, format)) { break; } <|startfocus|> // Android-changed: Skip trailing whitespace. <|endfocus|> if (c == ' ' || c == '\n') { do { if (c != ' ' && c != '\n') { throw new IOException("AVA parse, invalid hex " + "digit: "+ (char)c); } c = in.read(); } while (!isTerminator(c, format)); break; } int cVal = hexDigits.indexOf(Character.toUpperCase((char)c)); if (cVal == -1) { throw new IOException("AVA parse, invalid hex " +
code_review:  should be BEGIN/END, and the comment doesn't seem accurate because this also skips over newlines. The commit message of the CL that introduced this was: "AVA: Support hex-strings that have contain ' ' or an '\n'" so how about: // BEGIN Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' ? 
target code: return s; } catch (IOException e) { // should not occur throw new RuntimeException("AVA error: " + e, e); } } private static DerValue parseHexString (Reader in, int format) throws IOException { int c; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte b = 0; int cNdx = 0; while (true) { c = in.read(); if (isTerminator(c, format)) { break; } // BEGIN Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' if (c == ' ' || c == '\n') { do { if (c != ' ' && c != '\n') { throw new IOException("AVA parse, invalid hex " + "digit: "+ (char)c); } c = in.read(); } while (!isTerminator(c, format)); break; } int cVal = hexDigits.indexOf(Character.toUpperCase((char)c)); if (cVal == -1) { throw new IOException("AVA parse, invalid hex " +
response: return s; } catch (IOException e) { throw new RuntimeException("AVA error: " + e, e); } } private static DerValue parseHexString(Reader in, int format) throws IOException { int c; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte b = 0; int cNdx = 0; while (true) { c = in.read(); if (isTerminator(c, format)) { break; } if (c == ' ' || c == '\n') { do { if (c != ' ' && c != '\n') { throw new IOException("AVA parse, invalid hex digit: " + (char) c); } c = in.read(); } while (!isTerminator(c, format)); break; } int cVal = hexDigits.indexOf(Character.toUpperCase((char) c)); if (cVal == -1) { throw new IOException("AVA parse, invalid hex digit: " + (char) c); } if (cNdx % 2 == 0) { b = (byte) (cVal << 4); } else { b |= (byte) cVal; baos.write(b); } cNdx++; } return new DerValue(baos.toByteArray()); }

sample: 582
buggy_code:  while (true) { c = in.read(); if (isTerminator(c, format)) { break; } // Android-changed: Skip trailing whitespace. if (c == ' ' || c == '\n') { do { if (c != ' ' && c != '\n') { throw new IOException("AVA parse, invalid hex " + "digit: "+ (char)c); } c = in.read(); } while (!isTerminator(c, format)); break; } <|startfocus|> <|endfocus|> int cVal = hexDigits.indexOf(Character.toUpperCase((char)c)); if (cVal == -1) { throw new IOException("AVA parse, invalid hex " + "digit: "+ (char)c); } if ((cNdx % 2) == 1) { b = (byte)((b * 16) + (byte)(cVal)); baos.write(b); } else { b = (byte)(cVal); } cNdx++; } // throw exception if no hex digits
code_review:  Add // END Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' in line 285. 
target code: while (true) { c = in.read(); if (isTerminator(c, format)) { break; } // Android-changed: Skip trailing whitespace. if (c == ' ' || c == '\n') { do { if (c != ' ' && c != '\n') { throw new IOException("AVA parse, invalid hex " + "digit: "+ (char)c); } c = in.read(); } while (!isTerminator(c, format)); break; } // END Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' int cVal = hexDigits.indexOf(Character.toUpperCase((char)c)); if (cVal == -1) { throw new IOException("AVA parse, invalid hex " + "digit: "+ (char)c); } if ((cNdx % 2) == 1) { b = (byte)((b * 16) + (byte)(cVal)); baos.write(b); } else { b = (byte)(cVal); } cNdx++; } // throw exception if no hex digits
response: while (true) { c = in.read(); if (isTerminator(c, format)) { break; } if (c == ' ' || c == '\n') { do { if (c != ' ' && c != '\n') { throw new IOException("AVA parse, invalid hex digit: " + (char)c); } c = in.read(); } while (!isTerminator(c, format)); break; } int cVal = hexDigits.indexOf(Character.toUpperCase((char)c)); if (cVal == -1) { throw new IOException("AVA parse, invalid hex digit: " + (char)c); } if ((cNdx % 2) == 1) { b = (byte)((b * 16) + (byte)(cVal)); baos.write(b); } else { b = (byte)(cVal); } cNdx++; } // throw exception if no hex digits

sample: 583
buggy_code:  temp.append(hexString); embeddedHex.clear(); } do { c = in.read(); } while ((c == '\n') || (c == ' ')); if (c != -1) { throw new IOException("AVA had characters other than " + "whitespace after terminating quote"); } // encode as PrintableString unless value contains // non-PrintableString chars <|startfocus|> // Android-changed: Removed .trim() from .toString calls so they wouldn't remove spaces <|endfocus|> if (this.oid.equals((Object)PKCS9Attribute.EMAIL_ADDRESS_OID) || (this.oid.equals((Object)X500Name.DOMAIN_COMPONENT_OID) && PRESERVE_OLD_DC_ENCODING == false)) { // EmailAddress and DomainComponent must be IA5String return new DerValue(DerValue.tag_IA5String, temp.toString()); } else if (isPrintableString) { return new DerValue(temp.toString()); } else { return new DerValue(DerValue.tag_UTF8String, temp.toString()); } } private DerValue parseString
code_review:  "so they wouldn't remove spaces" is redundant, that's what trim() does. Personally, I'd prefer the line // Android-changed: Do not trim() DerValue strings. on each of the three lines that changed, together with the commented-out upstream code. There are not that many occurences, so I'd rather be specific. 
target code: temp.append(hexString); embeddedHex.clear(); } do { c = in.read(); } while ((c == '\n') || (c == ' ')); if (c != -1) { throw new IOException("AVA had characters other than " + "whitespace after terminating quote"); } // encode as PrintableString unless value contains // non-PrintableString chars if (this.oid.equals((Object)PKCS9Attribute.EMAIL_ADDRESS_OID) || (this.oid.equals((Object)X500Name.DOMAIN_COMPONENT_OID) && PRESERVE_OLD_DC_ENCODING == false)) { // EmailAddress and DomainComponent must be IA5String return new DerValue(DerValue.tag_IA5String, temp.toString()); } else if (isPrintableString) { return new DerValue(temp.toString()); } else { return new DerValue(DerValue.tag_UTF8String, temp.toString()); } } private DerValue parseString
response: temp.append(hexString); embeddedHex.clear(); do { c = in.read(); } while ((c == '\n') || (c == ' ')); if (c != -1) { throw new IOException("AVA had characters other than whitespace after terminating quote"); } // encode as PrintableString unless value contains non-PrintableString chars // Android-changed: Do not trim() DerValue strings. if (this.oid.equals((Object)PKCS9Attribute.EMAIL_ADDRESS_OID) || (this.oid.equals((Object)X500Name.DOMAIN_COMPONENT_OID) && PRESERVE_OLD_DC_ENCODING == false)) { // EmailAddress and DomainComponent must be IA5String return new DerValue(DerValue.tag_IA5String, temp.toString()); } else if (isPrintableString) { return new DerValue(temp.toString()); } else { return new DerValue(DerValue.tag_UTF8String, temp.toString()); }

sample: 584
buggy_code:  * This class is not a general repository for OIDs, or for such string names. * Note that the mappings between algorithm IDs and algorithm names is * not one-to-one. * * * @author David Brownell * @author Amit Kapoor * @author Hemma Prafullchandra */ <|startfocus|> // Android-changed: Parsing mapping as OID even if "OID." prefix isn't specified // Android-changed: Don't clobber existing entries in the AlgorithmId tables // Android-changed: Update algorithm mapping tables for names when OID is used <|endfocus|> public class AlgorithmId implements Serializable, DerEncoder { /** use serialVersionUID from JDK 1.1. for interoperability */ private static final long serialVersionUID = 7205873507486557157L; /** * The object identitifer being used for this algorithm. */ private ObjectIdentifier algid; // The (parsed) parameters private AlgorithmParameters algParams; private boolean constructedFromDer = true; /** * Parameters for this algorithm. These are stored in unparsed * DER-encoded form; subclasses can be made to automaticaly parse
code_review:  The changes are actually quite localized in this file, so can we please keep these comments restricted to the small section where they are relevant, rather than at the top level? From what I can see, the only differences between Android and upstream, other than the ones already documented previously, are: 1.) an added short block of code in getName(): // Try to update the name <-> OID mapping table. synchronized (oidTable) { reinitializeMappingTableLocked(); algName = nameTable.get(algid); } 2.) A modified section towards the end of algOID() , consisting of code that was extracted into the helper method reinitializeMappingTableLocked(), and then modified. 2b) related to 2), eager initialization of nameTable and oidTable at the point where they are declared, whereas upstream initializes nameTable in the explicit static { .. } block. The initialization of nameTable doesn't look like it needs to differ from upstream. So adding these toplevel comments here seems like it needlessly obscures the small areas where these changes have been made, and loses us the chance of reverting the parts that can be reverted. 
target code: * This class is not a general repository for OIDs, or for such string names. * Note that the mappings between algorithm IDs and algorithm names is * not one-to-one. * * * @author David Brownell * @author Amit Kapoor * @author Hemma Prafullchandra */ public class AlgorithmId implements Serializable, DerEncoder { /** use serialVersionUID from JDK 1.1. for interoperability */ private static final long serialVersionUID = 7205873507486557157L; /** * The object identitifer being used for this algorithm. */ private ObjectIdentifier algid; // The (parsed) parameters private AlgorithmParameters algParams; private boolean constructedFromDer = true; /** * Parameters for this algorithm. These are stored in unparsed * DER-encoded form; subclasses can be made to automaticaly parse
response: public class AlgorithmId implements Serializable, DerEncoder { private static final long serialVersionUID = 7205873507486557157L; private ObjectIdentifier algid; private AlgorithmParameters algParams; private boolean constructedFromDer = true; public AlgorithmId(ObjectIdentifier algid) { this.algid = algid; } public ObjectIdentifier getAlgorithmId() { return algid; } public AlgorithmParameters getAlgorithmParameters() { return algParams; } public void setAlgorithmParameters(AlgorithmParameters algParams) { this.algParams = algParams; } public boolean isConstructedFromDer() { return constructedFromDer; } public void setConstructedFromDer(boolean constructedFromDer) { this.constructedFromDer = constructedFromDer; } @Override public void derEncode(OutputStream out) throws IOException { algid.derEncode(out); if (algParams != null) { byte[] encodedParams = algParams.getEncoded(); out.write(encodedParams); } } @Override public void derDecode(InputStream in) throws IOException { algid = new ObjectIdentifier(); algid.derDecode(in); if (in.available() > 0) { byte[] encodedParams = new byte[in.available()]; in.read(encodedParams); algParams = AlgorithmParameters.getInstance(algid.toString()); algParams.init(encodedParams); } } }

sample: 585
buggy_code:  } catch (NoSuchAlgorithmException e) { // BEGIN Android-changed // It was searching for the EC parameters in an internal provider in the deleted package // sun.security.ec before setting them to null. Since EC is in the OpenSSL provider, // there's no need for such fallback. Setting it to null directly. /* * This algorithm parameter type is not supported, so we cannot * parse the parameters. */ algParams = null; return; // END Android-changed <|startfocus|> } <|endfocus|> // Decode (parse) the parameters algParams.init(params.toByteArray()); } /** * Marshal a DER-encoded "AlgorithmID" sequence on the DER stream. */ public final void encode(DerOutputStream out) throws IOException { derEncode(out); } /** * DER encode this object onto an output stream. * Implements the <code>DerEncoder</code> interface. * * @param out * the output stream on which to write the DER encoding. * * @exception IOException on encoding error.
code_review:  Upstream seems to have made the exact same change here as Android (perhaps we upstreamed it), so this Android-changed documentation should go away. Also, upstream has an extra empty line after line 138 that we should also reintroduce, to minimize diffs. 
target code: } catch (NoSuchAlgorithmException e) { // BEGIN Android-changed // It was searching for the EC parameters in an internal provider in the deleted package // sun.security.ec before setting them to null. Since EC is in the OpenSSL provider, // there's no need for such fallback. Setting it to null directly. /* * This algorithm parameter type is not supported, so we cannot * parse the parameters. */ algParams = null; return; // END Android-changed } // Decode (parse) the parameters algParams.init(params.toByteArray()); } /** * Marshal a DER-encoded "AlgorithmID" sequence on the DER stream. */ public final void encode(DerOutputStream out) throws IOException { derEncode(out); } /** * DER encode this object onto an output stream. * Implements the <code>DerEncoder</code> interface. * * @param out * the output stream on which to write the DER encoding. * * @exception IOException on encoding error.
response: } catch (NoSuchAlgorithmException e) { algParams = null; return; } // Decode (parse) the parameters algParams.init(params.toByteArray()); } public final void encode(DerOutputStream out) throws IOException { derEncode(out); } public final void derEncode(DerOutputStream out) throws IOException { // Encode the algorithm parameters if (algParams != null) { algParams.encode(out); } } public final void derDecode(DerInputStream in) throws IOException { // Decode the algorithm parameters if (algParams != null) { algParams.decode(in); } } public final void decode(byte[] encodedParams) throws IOException { // Decode the algorithm parameters from the encoded byte array if (encodedParams != null) { DerInputStream in = new DerInputStream(encodedParams); derDecode(in); } } public final byte[] getEncoded() throws IOException { // Get the encoded byte array of the algorithm parameters DerOutputStream out = new DerOutputStream(); derEncode(out); return out.toByteArray(); }

sample: 586
buggy_code:  private static final String OCSPNOCHECK = ROOT + "." + OCSPNoCheckExtension.NAME; private static final int NetscapeCertType_data[] = { 2, 16, 840, 1, 113730, 1, 1 }; /** Map ObjectIdentifier(oid) -> OIDInfo(info) */ private final static Map<ObjectIdentifier,OIDInfo> oidMap; /** Map String(friendly name) -> OIDInfo(info) */ private final static Map<String,OIDInfo> nameMap; <|startfocus|> // BEGIN Android-changed: Hardcode class names in OIDMap to fix proguard issues <|endfocus|> static { oidMap = new HashMap<ObjectIdentifier,OIDInfo>(); nameMap = new HashMap<String,OIDInfo>(); addInternal(SUB_KEY_IDENTIFIER, PKIXExtensions.SubjectKey_Id, SubjectKeyIdentifierExtension.class); addInternal(KEY_USAGE, PKIXExtensions.KeyUsage_Id, KeyUsageExtension.class); addInternal(PRIVATE_KEY_USAGE, PKIXExtensions.PrivateKeyUsage_Id, PrivateKeyUsageExtension.class); addInternal(SUB_ALT_NAME, PKIXExtensions.SubjectAlternativeName_Id, SubjectAlternativeNameExtension.class); addInternal(ISSUER_ALT_NAME, PKIXExtensions.IssuerAlternativeName_Id, IssuerAlternativeNameExtension.class); addInternal(BASIC_CONSTRAINTS, PKIXExtensions.BasicConstraints_Id,
code_review:  Nit: Isn't it the opposite of hard coding? Upstream has String literals, we refer to .class objects. How about: // BEGIN Android-changed: Specify Class objects rather for oidMap rather than String literals + reflection. 
target code: private static final String OCSPNOCHECK = ROOT + "." + OCSPNoCheckExtension.NAME; private static final int NetscapeCertType_data[] = { 2, 16, 840, 1, 113730, 1, 1 }; /** Map ObjectIdentifier(oid) -> OIDInfo(info) */ private final static Map<ObjectIdentifier,OIDInfo> oidMap; /** Map String(friendly name) -> OIDInfo(info) */ private final static Map<String,OIDInfo> nameMap; // BEGIN Android-changed: Specify Class objects rather for oidMap rather than String // literals + reflection. static { oidMap = new HashMap<ObjectIdentifier,OIDInfo>(); nameMap = new HashMap<String,OIDInfo>(); addInternal(SUB_KEY_IDENTIFIER, PKIXExtensions.SubjectKey_Id, SubjectKeyIdentifierExtension.class); addInternal(KEY_USAGE, PKIXExtensions.KeyUsage_Id, KeyUsageExtension.class); addInternal(PRIVATE_KEY_USAGE, PKIXExtensions.PrivateKeyUsage_Id, PrivateKeyUsageExtension.class); addInternal(SUB_ALT_NAME, PKIXExtensions.SubjectAlternativeName_Id, SubjectAlternativeNameExtension.class); addInternal(ISSUER_ALT_NAME, PKIXExtensions.IssuerAlternativeName_Id, IssuerAlternativeNameExtension.class); addInternal(BASIC_CONSTRAINTS, PKIXExtensions.BasicConstraints_Id,
response: private static final String OCSPNOCHECK = ROOT + "." + OCSPNoCheckExtension.NAME; private static final int NetscapeCertType_data[] = { 2, 16, 840, 1, 113730, 1, 1 }; /** Map ObjectIdentifier(oid) -> OIDInfo(info) */ private final static Map<ObjectIdentifier,OIDInfo> oidMap; /** Map String(friendly name) -> OIDInfo(info) */ private final static Map<String,OIDInfo> nameMap; // BEGIN Android-changed: Specify Class objects rather for oidMap rather than String literals + reflection static { oidMap = new HashMap<ObjectIdentifier,OIDInfo>(); nameMap = new HashMap<String,OIDInfo>(); addInternal(SUB_KEY_IDENTIFIER, PKIXExtensions.SubjectKey_Id, SubjectKeyIdentifierExtension.class); addInternal(KEY_USAGE, PKIXExtensions.KeyUsage_Id, KeyUsageExtension.class); addInternal(PRIVATE_KEY_USAGE, PKIXExtensions.PrivateKeyUsage_Id, PrivateKeyUsageExtension.class); addInternal(SUB_ALT_NAME, PKIXExtensions.SubjectAlternativeName_Id, SubjectAlternativeNameExtension.class); addInternal(ISSUER_ALT_NAME, PKIXExtensions.IssuerAlternativeName_Id, IssuerAlternativeNameExtension.class); addInternal(BASIC_CONSTRAINTS, PKIXExtensions.BasicConstraints_Id, BasicConstraintsExtension.class); addInternal(NAME_CONSTRAINTS, PKIXExtensions.NameConstraints_Id, NameConstraintsExtension.class); addInternal(POLICY_MAPPINGS, PKIXExtensions.PolicyMappings_Id, PolicyMappingsExtension.class); addInternal(POLICY_CONSTRAINTS, PKIXExtensions.PolicyConstraints_Id, PolicyConstraintsExtension.class); addInternal(INHIBIT_ANY_POLICY, PKIXExtensions.InhibitAnyPolicy_Id, InhibitAnyPolicyExtension.class); addInternal(CRL_DISTRIBUTION_POINTS, PKIXExtensions.CRLDistributionPoints_Id, CRLDistributionPointsExtension.class); addInternal(CERTIFICATE_POLICIES, PKIXExtensions.CertificatePolicies_Id, CertificatePoliciesExtension.class); addInternal(EXTENDED_KEY_USAGE, PKIXExtensions.ExtendedKeyUsage_Id, ExtendedKeyUsageExtension.class); addInternal(AUTHORITY_KEY_IDENTIFIER, PKIXExtensions.AuthorityKey_Id, AuthorityKeyIdentifierExtension.class); addInternal(OCSPNOCHECK, PKIXExtensions.OCSPNoCheck_Id, OCSPNoCheckExtension.class);

sample: 587
buggy_code:  SubjectInfoAccessExtension.class); addInternal(AUTH_INFO_ACCESS, PKIXExtensions.AuthInfoAccess_Id, AuthorityInfoAccessExtension.class); addInternal(ISSUING_DIST_POINT, PKIXExtensions.IssuingDistributionPoint_Id, IssuingDistributionPointExtension.class); addInternal(DELTA_CRL_INDICATOR, PKIXExtensions.DeltaCRLIndicator_Id, DeltaCRLIndicatorExtension.class); addInternal(FRESHEST_CRL, PKIXExtensions.FreshestCRL_Id, FreshestCRLExtension.class); addInternal(OCSPNOCHECK, PKIXExtensions.OCSPNoCheck_Id, OCSPNoCheckExtension.class); } <|startfocus|> // END Android-changed: Hardcode class names in OIDMap to fix proguard issues <|endfocus|> /** * Add attributes to the table. For internal use in the static * initializer. */ private static void addInternal(String name, ObjectIdentifier oid, Class clazz) { OIDInfo info = new OIDInfo(name, oid, clazz); oidMap.put(oid, info); nameMap.put(name, info); } /** * Inner class encapsulating the mapping info and Class loading. */ private static class OIDInfo { final ObjectIdentifier oid; final String name; private volatile Class<?> clazz; OIDInfo(String name, ObjectIdentifier oid, Class<?> clazz) {
code_review:  strictly speaking, the changes extend all the way to line 202 ("return clazz;") so this END line probably should be after line 204? 
target code: SubjectInfoAccessExtension.class); addInternal(AUTH_INFO_ACCESS, PKIXExtensions.AuthInfoAccess_Id, AuthorityInfoAccessExtension.class); addInternal(ISSUING_DIST_POINT, PKIXExtensions.IssuingDistributionPoint_Id, IssuingDistributionPointExtension.class); addInternal(DELTA_CRL_INDICATOR, PKIXExtensions.DeltaCRLIndicator_Id, DeltaCRLIndicatorExtension.class); addInternal(FRESHEST_CRL, PKIXExtensions.FreshestCRL_Id, FreshestCRLExtension.class); addInternal(OCSPNOCHECK, PKIXExtensions.OCSPNoCheck_Id, OCSPNoCheckExtension.class); } /** * Add attributes to the table. For internal use in the static * initializer. */ private static void addInternal(String name, ObjectIdentifier oid, Class clazz) { OIDInfo info = new OIDInfo(name, oid, clazz); oidMap.put(oid, info); nameMap.put(name, info); } /** * Inner class encapsulating the mapping info and Class loading. */ private static class OIDInfo { final ObjectIdentifier oid; final String name; private volatile Class<?> clazz; OIDInfo(String name, ObjectIdentifier oid, Class<?> clazz) {
response: // limitations under the License. package net.codemirror.lib; import com.google.gwt.core.client.JavaScriptObject; /** * {line, ch} objects used within CodeMirror. */ public class LineCharacter extends JavaScriptObject { public static LineCharacter create(int line, int ch) { LineCharacter lineCh = createObject().cast(); return lineCh.setLine(line).setCh(ch); } private final native LineCharacter setLine(int line) /*-{ this.line = line; return this; }-*/; public final native LineCharacter setCh(int ch) /*-{ this['ch'] = ch; return this; }-*/; public final native int getLine() /*-{ return this.line; }-*/; public final native int getCh() /*-{ return this.ch; }-*/; protected LineCharacter() { } } private static boolean isWrapped(final SWTBot bot) { return bot.label(1).getText().equals("Wrapped search"); } // limitations under the License. package net.codemirror.lib; import com.google.gwt.core.client.JavaScriptObject; /** * {line, ch} objects used within CodeMirror. */ public class LineCharacter extends JavaScriptObject { public static LineCharacter create(int line, int ch) { LineCharacter lineCh = createObject().cast(); return lineCh.setLine(line).setCh(ch); } private final native LineCharacter setLine(int line) /*-{ this.line = line; return this; }-*/; public final native LineCharacter setCh(int ch) /*-{ this['ch'] = ch; return this; }-*/; public final native int getLine() /*-{ return this.line; }-*/; public final native int getCh() /*-{ return this.ch; }-*/; protected LineCharacter() { } } private static boolean isWrapped(final SWTBot bot) { return bot.label(1).getText().equals("Wrapped search"); } // limitations under the License. package org.eclipse.tracecompass.internal.analysis.os.linux.core.latency; import org.eclipse.jdt.annotation.NonNull; import org.eclipse.tracecompass.datastore.core.interval.IHTIntervalReader; import org.eclipse.tracecompass.datastore.core.serialization.ISafeByteBufferWriter; import org.eclipse.trace

sample: 588
buggy_code:  private AVAComparator() { // empty } static Comparator<AVA> getInstance() { return INSTANCE; } /** * AVA's containing a standard keyword are ordered alphabetically, * followed by AVA's containing an OID keyword, ordered numerically */ public int compare(AVA a1, AVA a2) { boolean a1Has2253 = a1.hasRFC2253Keyword(); boolean a2Has2253 = a2.hasRFC2253Keyword(); <|startfocus|> // BEGIN Android-changed: Keep sort order of RDN from prev impl <|endfocus|> if (a1Has2253) { if (a2Has2253) { return a1.toRFC2253CanonicalString().compareTo (a2.toRFC2253CanonicalString()); } else { return -1; } } else { if (a2Has2253) { return 1; } else { int[] a1Oid = a1.getObjectIdentifier().toIntArray(); int[] a2Oid = a2.getObjectIdentifier().toIntArray(); int pos = 0; int len = (a1Oid.length > a2Oid.length) ? a2Oid.length :
code_review:  what's "prev impl", is this referring to Android L? This block of code doesn't seem to match any OpenJDK version between 7u40 and 8u121-b13. 
target code: private AVAComparator() { // empty } static Comparator<AVA> getInstance() { return INSTANCE; } /** * AVA's containing a standard keyword are ordered alphabetically, * followed by AVA's containing an OID keyword, ordered numerically */ public int compare(AVA a1, AVA a2) { boolean a1Has2253 = a1.hasRFC2253Keyword(); boolean a2Has2253 = a2.hasRFC2253Keyword(); // BEGIN Android-changed: Keep sort order of RDN from Android M if (a1Has2253) { if (a2Has2253) { return a1.toRFC2253CanonicalString().compareTo (a2.toRFC2253CanonicalString()); } else { return -1; } } else { if (a2Has2253) { return 1; } else { int[] a1Oid = a1.getObjectIdentifier().toIntArray(); int[] a2Oid = a2.getObjectIdentifier().toIntArray(); int pos = 0; int len = (a1Oid.length > a2Oid.length) ? a2Oid.length :
response: protected DataSourceProvider(SitePaths site, @GerritServerConfig Config cfg, Context ctx, DataSourceType dst, SecureStore secureStore) { this.site = site; this.cfg = cfg; this.ctx = ctx; this.dst = dst; this.secureStore = secureStore; } load(absolutePath, VMStack.getCallingClassLoader()); void load(String absolutePath, ClassLoader loader) { if (absolutePath == null) { throw new NullPointerException("absolutePath == null"); } else { final File libFile = new File(absolutePath); if (!libFile.exists()) { throw new NullPointerException("absolutePath is not existing"); } else if (!libFile.canRead()) { throw new java.io.IOException("absolutePath is not readable"); } else if (!libFile.canExecute()) { throw new NullPointerException("absolutePath is not executable"); } } String error = doLoad(absolutePath, loader); if (error != null) { throw new UnsatisfiedLinkError(error); } } private AVAComparator() { // empty } static Comparator<AVA> getInstance() { return INSTANCE; } public int compare(AVA a1, AVA a2) { boolean a1Has2253 = a1.hasRFC2253Keyword(); boolean a2Has2253 = a2.hasRFC2253Keyword(); if (a1Has2253) { if (a2Has2253) { return a1.toRFC2253CanonicalString().compareTo(a2.toRFC2253CanonicalString()); } else { return -1; } } else { if (a2Has2253) { return 1; } else { int[] a1Oid = a1.getObjectIdentifier().toIntArray(); int[] a2Oid = a2.getObjectIdentifier().toIntArray(); int pos = 0; int len = (a1Oid.length > a2Oid.length) ? a2Oid.length : a1Oid.length; while (pos < len) { int diff = a1Oid[pos] - a2Oid[pos]; if (diff != 0) { return diff; } pos++; } return a1Oid.length - a2Oid.length; } } }

sample: 589
buggy_code:  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.nfc; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; /** <|startfocus|> * Boot completed receiver. used to diable the application if the device doesn't <|endfocus|> * support NFC when device boots. * */ public class NfcBootCompletedReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } } } } 
code_review:  nit: disable 
target code: * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.nfc; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; /** * Boot completed receiver. used to disable the application if the device doesn't * support NFC when device boots. * */ public class NfcBootCompletedReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } } } }
response: /* * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.nfc; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; /** * Boot completed receiver. used to disable the application if the device doesn't * support NFC when device boots. */ public class NfcBootCompletedReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } } } }

sample: 590
buggy_code:  public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } <|startfocus|> if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { <|endfocus|> PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } }
code_review:  not needed if you just swap the equals test below -- if (Intent.ACTION_BOOT_COMPLETED.equals(action)) { 
target code: public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (Intent.ACTION_BOOT_COMPLETED.equals(action)) { PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } }
response: + (System.currentTimeMillis() - timestamp) + " ms"); } ContentValues updateValues = new ContentValues(); updateValues.put(BluetoothShare.CURRENT_BYTES, position); mContext.getContentResolver().update(contentUri, updateValues, null, null); } } catch (IOException e1) { Log.e(TAG, "Error when receiving file"); /* OBEX Abort packet received from remote device */ if (e1.getMessage().equals("Abort Received")) { status = BluetoothShare.STATUS_CANCELED; } else { status = BluetoothShare.STATUS_OBEX_DATA_ERROR; } else { status = BluetoothShare.STATUS_OBEX_DATA_ERROR; } error = true; } } if (mInterrupted) { if (D) Log.d(TAG, "receiving file interrupted by user."); status = BluetoothShare.STATUS_CANCELED; } else { if (position == fileInfo.mLength) { if (D) Log.d(TAG, "Receiving file completed for " + fileInfo.mFileName); status = BluetoothShare.STATUS_SUCCESS; } else { private boolean isRefsFor(String refName) { return refName.startsWith("refs/for/") || refName.equals("refs/*"); } public OsExecutionGraphProvider(ITmfTrace trace) { super(trace, "LTTng Kernel"); //$NON-NLS-1$ fSystem = new OsSystemModel(); IConfigurationElement[] config = Platform.getExtensionRegistry().getConfigurationElementsFor(TMF_GRAPH_HANDLER_ID); for (IConfigurationElement ce : config) { String elementName = ce.getName(); if (elementName.equals(HANDLER)) { IOsExecutionGraphHandlerBuilder builder; try { builder = (IOsExecutionGraphHandlerBuilder) ce.createExecutableExtension(ATTRIBUTE_CLASS); } catch (CoreException e1) { Activator.getDefault().logWarning("Error create execution graph handler builder", e1); //$NON-NLS-1$ continue; } String priorityStr = ce.getAttribute(ATTRIBUTE_PRIORITY); int priority = DEFAULT_PRIORITY; try { priority = Integer.valueOf(priorityStr); } catch (NumberFormatException e) { // Nothing to do, use default value } ITraceEventHandler handler = builder.createHandler(this, priority); registerHandler(handler); } } } public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (Intent.ACTION_BOOT_COMPLETED

sample: 591
buggy_code:  public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { PackageManager pm = context.getPackageManager(); <|startfocus|> if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC)) { <|endfocus|> pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } }
code_review:  This used to work, but since last year Android Wear has shipped devices that only have FEATURE_NFC_HOST_CARD_EMULATION and not FEATURE_NFC set. See b/28587919 for details. I think you could use the new FEATURE_NFC_ANY feature flag though. 
target code: public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_ANY)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } }
response: public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action == null) { return; } if (action.equals(Intent.ACTION_BOOT_COMPLETED)) { PackageManager pm = context.getPackageManager(); if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_ANY)) { pm.setApplicationEnabledSetting(context.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0); } } }

sample: 592
buggy_code:  NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // Sigh, xt_qtaguid ends up double-counting tx traffic going through // clatd interfaces, so we need to subtract it here. final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); <|startfocus|> // Count up tx (http://b/12249687) and rx (http:/b/33681750) traffic and subtract // from root UID on the base interface. NetworkStats.Entry adjust = <|endfocus|> new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) {
code_review:  I'm going to assume this doesn't compile. 
target code: NetworkStats lastStats) throws IOException { final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats); NetworkStats.Entry entry = null; // for recycling synchronized (sStackedIfaces) { // Sigh, xt_qtaguid ends up double-counting tx traffic going through // clatd interfaces, so we need to subtract it here. final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) {
response: private NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes += entry.rxBytes; adjust.rxPackets += entry.rxPackets; adjust.txBytes += entry.txBytes; adjust.txPackets += entry.txPackets; } } adjust.rxBytes = -adjust.rxBytes; adjust.rxPackets = -adjust.rxPackets; adjust.txBytes = -adjust.txBytes; adjust.txPackets = -adjust.txPackets; stats.combineValues(adjust);

sample: 593
buggy_code:  */ public static native String getOsVersion(); /** * @return hardware id extracted from uname() native call */ public static native String getHardwareId(); /** * @return kernel version extracted from uname() native call */ public static native String getKernelVersion(); /** * @return sysprop ro.boot.avb_version */ public static native String getBootAvbVersion(); /** <|startfocus|> * @return sysprop ro.boot.vbmeta.avb_version <|endfocus|> */ public static native String getBootVbmetaAvbVersion(); } 
code_review:  nit: the fact that this is stored in a sysprop is an implementation detail. Just specify the format of the string (eg X.Y or X.Y.Z or whatever it is) 
target code: */ public static native String getOsVersion(); /** * @return hardware id extracted from uname() native call */ public static native String getHardwareId(); /** * @return kernel version extracted from uname() native call */ public static native String getKernelVersion(); /** * @return sysprop ro.boot.avb_version */ public static native String getBootAvbVersion(); /** * @return libavb version in bootloader. Format is {@code x.y}. */ public static native String getBootVbmetaAvbVersion(); }
response: */ public static native String getOsVersion(); /** * @return hardware id extracted from uname() native call */ public static native String getHardwareId(); /** * @return kernel version extracted from uname() native call */ public static native String getKernelVersion(); /** * @return sysprop ro.boot.avb_version */ public static native String getBootAvbVersion(); /** * @return sysprop ro.boot.vbmeta.avb_version */ public static native String getBootVbmetaAvbVersion();

sample: 594
buggy_code:  private void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) { if (shouldBeInLowPersistenceMode()) { brightnessMode = BRIGHTNESS_MODE_LOW_PERSISTENCE; } else if (brightnessMode == BRIGHTNESS_MODE_LOW_PERSISTENCE) { brightnessMode = mLastBrightnessMode; } <|startfocus|> if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) { <|endfocus|> if (DEBUG) Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode); mInitialized = true; mLastColor = mColor; mColor = color; mMode = mode; mOnMS = onMS; mOffMS = offMS; mBrightnessMode = brightnessMode; Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")"); try {
code_review:  nit: line length should be < 100 characters 
target code: private void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) { if (shouldBeInLowPersistenceMode()) { brightnessMode = BRIGHTNESS_MODE_LOW_PERSISTENCE; } else if (brightnessMode == BRIGHTNESS_MODE_LOW_PERSISTENCE) { brightnessMode = mLastBrightnessMode; } if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) { if (DEBUG) Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode); mInitialized = true; mLastColor = mColor; mColor = color; mMode = mode; mOnMS = onMS; mOffMS = offMS; mBrightnessMode = brightnessMode; Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")"); try {
response: private void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) { if (shouldBeInLowPersistenceMode()) { brightnessMode = BRIGHTNESS_MODE_LOW_PERSISTENCE; } else if (brightnessMode == BRIGHTNESS_MODE_LOW_PERSISTENCE) { brightnessMode = mLastBrightnessMode; } if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) { if (DEBUG) Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode); mInitialized = true; mLastColor = mColor; mColor = color; mMode = mode; mOnMS = onMS; mOffMS = offMS; mBrightnessMode = brightnessMode; Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")"); try { // Code to set the light } finally { Trace.traceEnd(Trace.TRACE_TAG_POWER); } } }

sample: 595
buggy_code:  private int putListener(Object listener, NsdServiceInfo s) { checkListener(listener); final int key; synchronized (mMapLock) { int valueIndex = mListenerMap.indexOfValue(listener); checkArgument(valueIndex == -1, "listener already in use"); <|startfocus|> key = Math.abs(mListenerKey++); <|endfocus|> mListenerMap.put(key, listener); mServiceMap.put(key, s); } return key;
code_review:  Math.abs is surprising enough to deserve a comment? 
target code: private int putListener(Object listener, NsdServiceInfo s) { checkListener(listener); final int key; synchronized (mMapLock) { int valueIndex = mListenerMap.indexOfValue(listener); checkArgument(valueIndex == -1, "listener already in use"); key = nextListenerKey(); mListenerMap.put(key, listener); mServiceMap.put(key, s); } return key;
response: private int putListener(Object listener, NsdServiceInfo s) { checkListener(listener); final int key; synchronized (mMapLock) { int valueIndex = mListenerMap.indexOfValue(listener); checkArgument(valueIndex == -1, "listener already in use"); key = Math.abs(mListenerKey++); mListenerMap.put(key, listener); mServiceMap.put(key, s); } return key; }

sample: 596
buggy_code:  public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subId) { String appKey = appName + subId; if (!mAppCallbacks.containsKey(appKey)) { mAppCallbacks.put(appKey, listener); } else { return MbmsInitializationException.ERROR_ALREADY_INITIALIZED; } <|startfocus|> return 0; <|endfocus|>
code_review:  not an exception? Are you thinking of different error ranges for each call? I was thinking of a common list as I think some/many will be duplicated 
target code: public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subId) { String appKey = appName + subId; if (!mAppCallbacks.containsKey(appKey)) { mAppCallbacks.put(appKey, listener); } else { return MbmsInitializationException.ERROR_ALREADY_INITIALIZED; }
response: public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subId) { String appKey = appName + subId; if (!mAppCallbacks.containsKey(appKey)) { mAppCallbacks.put(appKey, listener); } else { return MbmsInitializationException.ERROR_ALREADY_INITIALIZED; } return 0; }

sample: 597
buggy_code:  @Override public boolean isTrue() throws UiObjectNotFoundException { return device.findObject( new UiSelector().resourceId(Res.GOOGLE_PLAY_INPUT_RES)).exists(); } }); if (inputTextFieldExists) { UiObject inputTextField = device.findObject( new UiSelector().resourceId(Res.GOOGLE_PLAY_INPUT_RES)); inputTextField.clearTextField(); inputTextField.setText(application); device.pressEnter(); } } /** <|startfocus|> * Selects an application listed in the Pl;ay Store. <|endfocus|> */ public static void selectFromGooglePlay(Instrumentation instrumentation, String appDescription) throws Exception { final UiDevice device = UiDevice.getInstance(instrumentation); final String playStore = "Play Store"; final String application = appDescription; boolean isListed = new Wait().until(new Wait.ExpectedCondition() { @Override public boolean isTrue() throws UiObjectNotFoundException { return device.findObject(new UiSelector() .description(application)).exists(); } }); if (isListed) { device.findObject(new UiSelector() .description(application)).clickAndWaitForNewWindow();
code_review:  typo 
target code: @Override public boolean isTrue() throws UiObjectNotFoundException { return device.findObject( new UiSelector().resourceId(Res.GOOGLE_PLAY_INPUT_RES)).exists(); } }); if (inputTextFieldExists) { UiObject inputTextField = device.findObject( new UiSelector().resourceId(Res.GOOGLE_PLAY_INPUT_RES)); inputTextField.clearTextField(); inputTextField.setText(application); device.pressEnter(); } } /** * Selects an application listed in the Play Store. */ public static void selectFromGooglePlay(Instrumentation instrumentation, String appDescription) throws Exception { final UiDevice device = UiDevice.getInstance(instrumentation); final String playStore = "Play Store"; final String application = appDescription; boolean isListed = new Wait().until(new Wait.ExpectedCondition() { @Override public boolean isTrue() throws UiObjectNotFoundException { return device.findObject(new UiSelector() .description(application)).exists(); } }); if (isListed) { device.findObject(new UiSelector() .description(application)).clickAndWaitForNewWindow();
response: @Override public boolean isTrue() throws UiObjectNotFoundException { return device.findObject(new UiSelector().resourceId(Res.GOOGLE_PLAY_INPUT_RES)).exists(); } }); if (inputTextFieldExists) { UiObject inputTextField = device.findObject(new UiSelector().resourceId(Res.GOOGLE_PLAY_INPUT_RES)); inputTextField.clearTextField(); inputTextField.setText(application); device.pressEnter(); } } /** * Selects an application listed in the Play Store. */ public static void selectFromGooglePlay(Instrumentation instrumentation, String appDescription) throws Exception { final UiDevice device = UiDevice.getInstance(instrumentation); final String playStore = "Play Store"; final String application = appDescription; boolean isListed = new Wait().until(new Wait.ExpectedCondition() { @Override public boolean isTrue() throws UiObjectNotFoundException { return device.findObject(new UiSelector().description(application)).exists(); } }); if (isListed) { device.findObject(new UiSelector().description(application)).clickAndWaitForNewWindow(); } }

sample: 598
buggy_code: public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; <|startfocus|> if (thisApiVersion < 21) { Log.w(TAG, "API version is less than 21, no tests running"); <|endfocus|> } Context ctx = InstrumentationRegistry.getTargetContext(); List<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** * Throws RuntimeException if any tests have the same name. */ private static void checkDuplicateNames(List<UnitTest> tests) {
code_review:  Sorry, maybe I'm being a bit too nit-picky here, but since you split 19 into 19 and 21, should this check still be for 19? To put it more simply, can the testing framework run API version 19? 
target code: public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; int minApiVersion = 21; if (thisApiVersion < minApiVersion) { Log.w(TAG, String.format("API version is less than %d, no tests running", minApiVersion)); } Context ctx = InstrumentationRegistry.getTargetContext(); List<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** * Throws RuntimeException if any tests have the same name. */ private static void checkDuplicateNames(List<UnitTest> tests) {
response: public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; if (thisApiVersion < 21) { Log.w(TAG, "API version is less than 21, no tests running"); } Context ctx = InstrumentationRegistry.getTargetContext(); List<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } private static void checkDuplicateNames(List<UnitTest> tests) { // Throws RuntimeException if any tests have the same name } }

sample: 599
buggy_code:  * To run the test, please use command * * adb shell am instrument -w com.android.rs.testforward/android.support.test.runner.AndroidJUnitRunner */ @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); <|startfocus|> Iterable<Class<? extends UnitTest>> unitTestClasses = <|endfocus|> RSUtils.getProperSubclasses(UnitTest.class); List<UnitTest> ret = new ArrayList<>(); for (Class<? extends UnitTest> testClass : unitTestClasses) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); ret.add(test); } return ret; } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT;
code_review:  Nit: For consistency, it might be helpful to make the layout of this "getParams" more similar to BackwardCompatibilityTests's, but it's up to you. 
target code: * To run the test, please use command * * adb shell am instrument -w com.android.rs.testforward/android.support.test.runner.AndroidJUnitRunner */ @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); List<UnitTest> validUnitTests = new ArrayList<>(); Iterable<Class<? extends UnitTest>> testClasses = RSUtils.getProperSubclasses(UnitTest.class); List<UnitTest> ret = new ArrayList<>(); for (Class<? extends UnitTest> testClass : unitTestClasses) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); ret.add(test); } return ret; } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT;
response: @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); Iterable<Class<? extends UnitTest>> unitTestClasses = RSUtils.getProperSubclasses(UnitTest.class); List<UnitTest> ret = new ArrayList<>(); for (Class<? extends UnitTest> testClass : unitTestClasses) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); ret.add(test); } return ret; } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT; // Rest of the test code } }

sample: 600
buggy_code:  */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); Iterable<Class<? extends UnitTest>> unitTestClasses = RSUtils.getProperSubclasses(UnitTest.class); List<UnitTest> ret = new ArrayList<>(); for (Class<? extends UnitTest> testClass : unitTestClasses) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); ret.add(test); } <|startfocus|> return ret; <|endfocus|> } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT; Log.i(TAG, String.format("RenderScript forward compatibility testing (%s) " + "on device %s, API version %d", mTest.toString(), thisDeviceName, thisApiVersion)); mTest.runTest(); switch (mTest.getResult()) { case UT_NOT_STARTED: case UT_RUNNING:
code_review:  In BackwardCompatibilityTest, you check if there are any duplicate names. Do you need to do that here as well? 
target code: */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); Iterable<Class<? extends UnitTest>> unitTestClasses = RSUtils.getProperSubclasses(UnitTest.class); List<UnitTest> ret = new ArrayList<>(); for (Class<? extends UnitTest> testClass : unitTestClasses) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); ret.add(test); } UnitTest.checkDuplicateNames(validUnitTests); return validUnitTests; } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT; Log.i(TAG, String.format("RenderScript forward compatibility testing (%s) " + "on device %s, API version %d", mTest.toString(), thisDeviceName, thisApiVersion)); mTest.runTest(); switch (mTest.getResult()) { case UT_NOT_STARTED: case UT_RUNNING:
response: public GoogleLoginActionButton(AnAction action, Presentation presentation, String place, @NotNull Dimension minimumSize) { super(action, presentation, place, minimumSize); boolean showLoginButton = Boolean.parseBoolean(System.getProperty(SHOW_LOGIN_BUTTON_PROPERTY)); if (!showLoginButton) { setVisible(false); return; } GoogleLogin.getInstance().setLoginMenuItemContribution(this); defaultIcon = IconLoader.getIcon(DEFAULT_AVATAR); updateUi(); } ... : in.range != null ? in.range.endLine : 0; comment = new PatchLineComment( new PatchLineComment.Key( new Patch.Key(ps.getId(), in.path), ChangeUtil.messageUUID(ctx.getDb()) ), line, ctx.getUser().getAccountId(), Url.decode(in.inReplyTo), ctx.getWhen() ); short side; if (in.side == Side.PARENT) { side = in.parent == null ? 0 : (short) -in.parent.shortValue(); } else { side = 1; } comment.setSide(side); comment.setMessage(in.message.trim()); comment.setRange(in.range); comment.setTag(in.tag); setCommentRevId(comment, patchListCache, ctx.getChange(), ps); plcUtil.putComments(ctx.getDb(), ctx.getUpdate(psId), Collections.singleton(comment)); ctx.bumpLastUpdatedOn(false); return true; } } ... private static DbsMetadata getDbsMetadata(Frontend fe, String catalogName, PatternMatcher schemaPatternMatcher, PatternMatcher tablePatternMatcher, PatternMatcher columnPatternMatcher, PatternMatcher fnPatternMatcher, User user) throws ImpalaException { DbsMetadata result = new DbsMetadata(); if (!isEmptyPattern(catalogName)) { return result; } for (Db db: fe.getDbs(schemaPatternMatcher, user)) { if (fnPatternMatcher != PatternMatcher.MATCHER_MATCH_NONE) { List<Function> fns = db.getFunctions(null, fnPatternMatcher); result.functions.add(fns); } else { List<String> tableList = Lists.newArrayList(); List<List<Column>> tablesColumnsList = Lists.newArrayList(); List<String> tableComments = Lists.newArrayList(); List<String> tableTypes = Lists.newArrayList(); ... } } return result; } ... @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception {

sample: 601
buggy_code:  import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; /** * RSTestBackward, functional test for platform RenderScript APIs. * To run the test, please use command * * adb shell am instrument -w com.android.rs.testbackward/android.support.test.runner.AndroidJUnitRunner */ @RunWith(Parameterized.class) public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** <|startfocus|> * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ <|endfocus|> @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; if (thisApiVersion < 19) { Log.w(TAG, "API version is less than 19, no tests running"); } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); 
code_review:  Is there an extra space on this line, or is this intentional? /** * vs /** * 
target code: import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; /** * RSTestBackward, functional test for platform RenderScript APIs. * To run the test, please use command * * adb shell am instrument -w com.android.rs.testbackward/android.support.test.runner.AndroidJUnitRunner */ @RunWith(Parameterized.class) public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; if (thisApiVersion < 19) { Log.w(TAG, "API version is less than 19, no tests running"); } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>();
response: Buggy Code: kage libcore.util; import junit.framework.TestCase; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.nio.charset.StandardCharsets; import java.util.Random; import libcore.util.Base64; import libcore.util.Base64InputStream; public class Base64InputStreamTest extends TestCase { static final String lipsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + "Quisque congue eleifend odio, eu ornare nulla facilisis eget. " + "Integer eget elit diam, sit amet laoreet nibh. Quisque enim " + "urna, pharetra vitae consequat eget, adipiscing eu ante. " + "Aliquam venenatis arcu nec nibh imperdiet tempor. In id dui " + "eget lorem aliquam rutrum vel vitae eros. In placerat ornare " + "pretium. Curabitur non fringilla mi. Fusce ultricies, turpis " + "eu ultrices suscipit, ligula nisi consectetur eros, dapibus " + "aliquet dui sapien a turpis. Donec ultricies varius ligula, " + Fixed Code: kage libcore.util; import junit.framework.TestCase; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.nio.charset.StandardCharsets; import java.util.Random; import libcore.util.Base64; import libcore.util.Base64InputStream; public class Base64InputStreamTest extends TestCase { static final String lipsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + "Quisque congue eleifend odio, eu ornare nulla facilisis eget. " + "Integer eget elit diam, sit amet laoreet nibh. Quisque enim " + "urna, pharetra vitae consequat eget, adipiscing eu ante. " + "Aliquam venenatis arcu nec nibh imperdiet tempor. In id dui " + "eget lorem aliquam rutrum vel vitae eros. In placerat ornare " + "pretium. Curabitur non fringilla mi. Fusce ultricies, turpis " + "eu ultrices suscipit, ligula nisi consectetur eros, dapibus " + "aliquet dui sapien a turpis. Donec ultricies varius ligula, " + Buggy Code: private static Image getImage(IMarker marker

sample: 602
buggy_code: public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; <|startfocus|> if (thisApiVersion < 19) { Log.w(TAG, "API version is less than 19, no tests running"); <|endfocus|> } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** * Throws RuntimeException if any tests have the same name. */ private static void checkDuplicateNames(List<UnitTest> tests) {
code_review:  The other document says 21, but I think 19 is correct. The python code said 19 & 20 might not be available for now; if so, we should change this to 21 for now. 
target code: public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; if (thisApiVersion < 21) { Log.w(TAG, "API version is less than 21, no tests running"); } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** * Throws RuntimeException if any tests have the same name. */ private static void checkDuplicateNames(List<UnitTest> tests) {
response: public class RSBackwardCompatibilityTests { private static final String TAG = "RSBackwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { int thisApiVersion = android.os.Build.VERSION.SDK_INT; if (thisApiVersion < 19) { Log.w(TAG, "API version is less than 19, no tests running"); } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** * Throws RuntimeException if any tests have the same name. */ private static void checkDuplicateNames(List<UnitTest> tests) { // Implementation omitted } }

sample: 603
buggy_code:  } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** <|startfocus|> * Throws RuntimeException if any tests have the same name. */ <|endfocus|> private static void checkDuplicateNames(List<UnitTest> tests) { Set<String> names = new HashSet<>(); for (UnitTest test : tests) { String name = test.toString(); if (names.contains(name)) { throw new RuntimeException("duplicate name: " + name); } names.add(name); } } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT;
code_review:  Ditto 
target code: } Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } /** * Throws RuntimeException if any tests have the same name. */ private static void checkDuplicateNames(List<UnitTest> tests) { Set<String> names = new HashSet<>(); for (UnitTest test : tests) { String name = test.toString(); if (names.contains(name)) { throw new RuntimeException("duplicate name: " + name); } names.add(name); } } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT;
response: Context ctx = InstrumentationRegistry.getTargetContext(); ArrayList<UnitTest> validUnitTests = new ArrayList<>(); for (Class<? extends UnitTest> testClass : RSTests.getTestClassesForCurrentAPIVersion()) { UnitTest test = testClass.getDeclaredConstructor(Context.class).newInstance(ctx); validUnitTests.add(test); } checkDuplicateNames(validUnitTests); return validUnitTests; } private static void checkDuplicateNames(List<UnitTest> tests) { Set<String> names = new HashSet<>(); for (UnitTest test : tests) { String name = test.toString(); if (names.contains(name)) { throw new RuntimeException("duplicate name: " + name); } names.add(name); } } @Parameter(0) public UnitTest mTest; @Test @MediumTest public void testRSUnitTest() throws Exception { String thisDeviceName = android.os.Build.DEVICE; int thisApiVersion = android.os.Build.VERSION.SDK_INT;

sample: 604
buggy_code:  import com.android.rs.unittest.*; import java.util.ArrayList; /** * This class is auto-generated by frameworks/rs/tests/java_api/RSUnitTests/RSUnitTests.py. * To change unit tests version, please run the Python script above. */ public class RSTests { public static Iterable<Class<? extends UnitTest>> getTestClassesForCurrentAPIVersion() { int thisApiVersion = android.os.Build.VERSION.SDK_INT; ArrayList<Class<? extends UnitTest>> validClasses = new ArrayList<>(); <|startfocus|> if (thisApiVersion >= 21) { <|endfocus|> validClasses.add(UT_alloc.class); validClasses.add(UT_array_alloc.class); validClasses.add(UT_array_init.class); validClasses.add(UT_atomic.class); validClasses.add(UT_bitfield.class); validClasses.add(UT_bug_char.class); validClasses.add(UT_check_dims.class); validClasses.add(UT_clamp.class); validClasses.add(UT_clamp_relaxed.class); validClasses.add(UT_constant.class); validClasses.add(UT_convert.class); validClasses.add(UT_convert_relaxed.class); validClasses.add(UT_copy_test.class); validClasses.add(UT_element.class);
code_review:  Should this be 19? 
target code: import com.android.rs.unittest.*; import java.util.ArrayList; /** * This class is auto-generated by frameworks/rs/tests/java_api/RSUnitTests/RSUnitTests.py. * To change unit tests version, please run the Python script above. */ public class RSTests { public static Iterable<Class<? extends UnitTest>> getTestClassesForCurrentAPIVersion() { int thisApiVersion = android.os.Build.VERSION.SDK_INT; ArrayList<Class<? extends UnitTest>> validClasses = new ArrayList<>(); if (thisApiVersion >= 19) { validClasses.add(UT_alloc.class); validClasses.add(UT_array_alloc.class); validClasses.add(UT_array_init.class); validClasses.add(UT_atomic.class); validClasses.add(UT_bitfield.class); validClasses.add(UT_bug_char.class); validClasses.add(UT_check_dims.class); validClasses.add(UT_clamp.class); validClasses.add(UT_clamp_relaxed.class); validClasses.add(UT_constant.class); validClasses.add(UT_convert.class); validClasses.add(UT_convert_relaxed.class); validClasses.add(UT_copy_test.class); validClasses.add(UT_element.class);
response: import com.android.rs.unittest.*; import java.util.ArrayList; /** * This class is auto-generated by frameworks/rs/tests/java_api/RSUnitTests/RSUnitTests.py. * To change unit tests version, please run the Python script above. */ public class RSTests { public static Iterable<Class<? extends UnitTest>> getTestClassesForCurrentAPIVersion() { int thisApiVersion = android.os.Build.VERSION.SDK_INT; ArrayList<Class<? extends UnitTest>> validClasses = new ArrayList<>(); if (thisApiVersion >= 21) { validClasses.add(UT_alloc.class); validClasses.add(UT_array_alloc.class); validClasses.add(UT_array_init.class); validClasses.add(UT_atomic.class); validClasses.add(UT_bitfield.class); validClasses.add(UT_bug_char.class); validClasses.add(UT_check_dims.class); validClasses.add(UT_clamp.class); validClasses.add(UT_clamp_relaxed.class); validClasses.add(UT_constant.class); validClasses.add(UT_convert.class); validClasses.add(UT_convert_relaxed.class); validClasses.add(UT_copy_test.class); validClasses.add(UT_element.class); validClasses.add(UT_foreach.class); validClasses.add(UT_foreach_bounds.class); validClasses.add(UT_foreach_relaxed.class); validClasses.add(UT_foreach_simple.class); validClasses.add(UT_foreach_simple_relaxed.class); validClasses.add(UT_foreach_stride.class); validClasses.add(UT_foreach_stride_relaxed.class); validClasses.add(UT_foreach_types.class); validClasses.add(UT_fp16.class); validClasses.add(UT_fp16_relaxed.class); validClasses.add(UT_fp32.class); validClasses.add(UT_fp32_relaxed.class); validClasses.add(UT_fp64.class); validClasses.add(UT_fp64_relaxed.class); validClasses.add(UT_global.class); validClasses.add(UT_global_relaxed.class); validClasses.add(UT_global_types.class); validClasses.add(UT_half.class); validClasses.add(UT_half_relaxed.class); validClasses.add(UT_image.class); validClasses.add(UT_image_relaxed.class); validClasses.add(UT_image_types.class); validClasses.add(UT_init.class); valid

sample: 605
buggy_code: import android.content.Context; import android.support.test.InstrumentationRegistry; import android.support.test.filters.MediumTest; import android.util.Log; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters; /** * RSTestForward, functional test for platform RenderScript APIs. * To run the test, please use command * * adb shell am instrument -w com.android.rs.testforward/android.support.test.runner.AndroidJUnitRunner <|startfocus|> * <|endfocus|> */ @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext();
code_review:  nit: delete extra line 
target code: import android.content.Context; import android.support.test.InstrumentationRegistry; import android.support.test.filters.MediumTest; import android.util.Log; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters; /** * RSTestForward, functional test for platform RenderScript APIs. * To run the test, please use command * * adb shell am instrument -w com.android.rs.testforward/android.support.test.runner.AndroidJUnitRunner */ @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext();
response: import android.content.Context; import android.support.test.InstrumentationRegistry; import android.support.test.filters.MediumTest; import android.util.Log; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); // Test implementation } }

sample: 606
buggy_code: import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters; /** * RSTestForward, functional test for platform RenderScript APIs. * To run the test, please use command * * adb shell am instrument -w com.android.rs.testforward/android.support.test.runner.AndroidJUnitRunner * */ @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; /** <|startfocus|> * Returns the list of subclasses of UnitTest to run. */ <|endfocus|> @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); switch (test.getResult()) { case UT_NOT_STARTED: case UT_RUNNING:
code_review:  Extra space here? 
target code: import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters; /** * RSTestForward, functional test for platform RenderScript APIs. * To run the test, please use command * * adb shell am instrument -w com.android.rs.testforward/android.support.test.runner.AndroidJUnitRunner * */ @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; /** * Returns the list of subclasses of UnitTest to run. */ @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); switch (test.getResult()) { case UT_NOT_STARTED: case UT_RUNNING:
response: import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class) public class RSForwardCompatibilityTests { private static final String TAG = "RSForwardCompatibilityTests"; @Parameters(name = "{0}") public static Iterable<?> getParams() throws Exception { return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); switch (test.getResult()) { case UT_NOT_STARTED: case UT_RUNNING: // Handle test result break; case UT_SUCCESS: // Handle test success break; case UT_FAILURE: // Handle test failure break; } } }

sample: 607
buggy_code:  return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); switch (test.getResult()) { case UT_NOT_STARTED: case UT_RUNNING: Log.w(TAG, "unexpected unit test result: " + test.getResult().toString()); break; } <|startfocus|> Assert.assertTrue(test.getSuccess()); <|endfocus|> } } 
code_review:  Can you make this block more similar to the equivalent block in RSBackwardCompatibilityTests.java? 
target code: return RSUtils.getProperSubclasses(UnitTest.class); } @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); switch (test.getResult()) { case UT_NOT_STARTED: case UT_RUNNING: Log.w(TAG, "unexpected unit test result: " + test.getResult().toString()); break; } Assert.assertTrue(mTest.getSuccess()); } }
response: return RSUtils.getProperSubclasses(UnitTest.class); @Parameter(0) public Class<? extends UnitTest> mTestClass; @Test @MediumTest public void testRSUnitTest() throws Exception { Context ctx = InstrumentationRegistry.getTargetContext(); UnitTest test = mTestClass.getDeclaredConstructor(Context.class).newInstance(ctx); test.runTest(); switch (test.getResult()) { case UT_NOT_STARTED: case UT_RUNNING: Log.w(TAG, "unexpected unit test result: " + test.getResult().toString()); break; } Assert.assertTrue(test.getSuccess()); }

sample: 608
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.rs.testforward; import com.android.rs.unittest.UnitTest; import android.content.Context; import android.support.test.InstrumentationRegistry; import dalvik.system.DexFile; import java.io.IOException; import java.util.ArrayList; import java.util.Enumeration; public class RSUtils { /** Returns a list of all proper subclasses of the input class */
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.rs.testforward; import com.android.rs.unittest.UnitTest; import android.content.Context; import android.support.test.InstrumentationRegistry; import dalvik.system.DexFile; import java.io.IOException; import java.util.ArrayList; import java.util.Enumeration; public class RSUtils { /** Returns a list of all proper subclasses of the input class */
response: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.rs.testforward; import com.android.rs.unittest.UnitTest; import android.content.Context; import android.support.test.InstrumentationRegistry; import dalvik.system.DexFile; import java.io.IOException; import java.util.ArrayList; import java.util.Enumeration; public class RSUtils { /** Returns a list of all proper subclasses of the input class */ public static ArrayList<Class<?>> getSubClasses(Class<?> parent) { ArrayList<Class<?>> classes = new ArrayList<Class<?>>(); Context context = InstrumentationRegistry.getContext(); String packageName = context.getPackageName(); try { DexFile dexFile = new DexFile(context.getPackageCodePath()); Enumeration<String> entries = dexFile.entries(); while (entries.hasMoreElements()) { String className = entries.nextElement(); try { Class<?> clazz = Class.forName(className); if (parent.isAssignableFrom(clazz)) { classes.add(clazz); } } catch (ClassNotFoundException e) { // Ignore } } } catch (IOException e) { // Ignore } return classes; } }

sample: 609
buggy_code:  MetricsLogger.histogram(context, "ota_stashed_in_MiBs", bytesStashedInMiB); } if (temperatureStart != -1) { MetricsLogger.histogram(context, "ota_temperature_start", temperatureStart); } if (temperatureEnd != -1) { MetricsLogger.histogram(context, "ota_temperature_end", temperatureEnd); } if (temperatureMax != -1) { MetricsLogger.histogram(context, "ota_temperature_max", temperatureMax); } if (errorCode != -1) { <|startfocus|> MetricsLogger.histogram(context, "ota_blockbased_error_code", timeTotal); <|endfocus|> } if (causeCode != -1) { MetricsLogger.histogram(context, "ota_blockbased_cause_code", timeTotal); } } catch (IOException e) { Log.e(TAG, "Failed to read lines in last_install", e); }
code_review:  copy-paste error (and L823) 
target code: MetricsLogger.histogram(context, "ota_stashed_in_MiBs", bytesStashedInMiB); } if (temperatureStart != -1) { MetricsLogger.histogram(context, "ota_temperature_start", temperatureStart); } if (temperatureEnd != -1) { MetricsLogger.histogram(context, "ota_temperature_end", temperatureEnd); } if (temperatureMax != -1) { MetricsLogger.histogram(context, "ota_temperature_max", temperatureMax); } if (errorCode != -1) { MetricsLogger.histogram(context, "ota_non_ab_error_code", errorCode); } if (causeCode != -1) { MetricsLogger.histogram(context, "ota_blockbased_cause_code", timeTotal); } } catch (IOException e) { Log.e(TAG, "Failed to read lines in last_install", e); }
response: MetricsLogger.histogram(context, "ota_stashed_in_MiBs", bytesStashedInMiB); if (temperatureStart != -1) { MetricsLogger.histogram(context, "ota_temperature_start", temperatureStart); } if (temperatureEnd != -1) { MetricsLogger.histogram(context, "ota_temperature_end", temperatureEnd); } if (temperatureMax != -1) { MetricsLogger.histogram(context, "ota_temperature_max", temperatureMax); } if (errorCode != -1) { MetricsLogger.histogram(context, "ota_blockbased_error_code", timeTotal); } if (causeCode != -1) { MetricsLogger.histogram(context, "ota_blockbased_cause_code", timeTotal); } catch (IOException e) { Log.e(TAG, "Failed to read lines in last_install", e); }

sample: 610
buggy_code:  } else if (line.startsWith("source_build")) { sourceVersion = scaled; } else if (line.startsWith("bytes_written")) { bytesWrittenInMiB = (bytesWrittenInMiB == -1) ? scaled : bytesWrittenInMiB + scaled; } else if (line.startsWith("bytes_stashed")) { bytesStashedInMiB = (bytesStashedInMiB == -1) ? scaled : bytesStashedInMiB + scaled; } else if (line.startsWith("temperatureStart")) { temperatureStart = scaled; <|startfocus|> } else if (line.startsWith("temperatureEnd")) { <|endfocus|> temperatureEnd = scaled; } else if (line.startsWith("temperatureMax")) { temperatureMax = scaled; } else if (line.startsWith("error")) { errorCode = scaled; } else if (line.startsWith("cause")) { causeCode = scaled; } } // Don't report data to tron if corresponding entry isn't found in last_install. if (timeTotal != -1) {
code_review:  these three are wrong, aren't they? aren't they written with underscores? 
target code: } else if (line.startsWith("source_build")) { sourceVersion = scaled; } else if (line.startsWith("bytes_written")) { bytesWrittenInMiB = (bytesWrittenInMiB == -1) ? scaled : bytesWrittenInMiB + scaled; } else if (line.startsWith("bytes_stashed")) { bytesStashedInMiB = (bytesStashedInMiB == -1) ? scaled : bytesStashedInMiB + scaled; } else if (line.startsWith("temperatureStart")) { temperatureStart = scaled; } else if (line.startsWith("temperature_end")) { temperatureEnd = scaled; } else if (line.startsWith("temperatureMax")) { temperatureMax = scaled; } else if (line.startsWith("error")) { errorCode = scaled; } else if (line.startsWith("cause")) { causeCode = scaled; } } // Don't report data to tron if corresponding entry isn't found in last_install. if (timeTotal != -1) {
response: } else if (line.startsWith("source_build")) { sourceVersion = scaled; } else if (line.startsWith("bytes_written")) { bytesWrittenInMiB = (bytesWrittenInMiB == -1) ? scaled : bytesWrittenInMiB + scaled; } else if (line.startsWith("bytes_stashed")) { bytesStashedInMiB = (bytesStashedInMiB == -1) ? scaled : bytesStashedInMiB + scaled; } else if (line.startsWith("temperatureStart")) { temperatureStart = scaled; } else if (line.startsWith("temperatureEnd")) { temperatureEnd = scaled; } else if (line.startsWith("temperatureMax")) { temperatureMax = scaled; } else if (line.startsWith("error")) { errorCode = scaled; } else if (line.startsWith("cause")) { causeCode = scaled; } // Don't report data to tron if corresponding entry isn't found in last_install. if (timeTotal != -1) {

sample: 611
buggy_code:  void sendTrackChangeWithId(int trackChangedNT, MediaController mediaController) { if (DEBUG) Log.d(TAG, "sendTrackChangeWithId"); byte[] track; try { <|startfocus|> if (mediaController == null) { mMediaInterface.trackChangedRsp(trackChangedNT, AvrcpConstants.NO_TRACK_SELECTED); return; } <|endfocus|> String mediaId = mediaController.getMetadata().getDescription().getMediaId(); long qid = MediaSession.QueueItem.UNKNOWN_ID; List<MediaSession.QueueItem> items = mNowPlayingList; /* traverse now playing list for current playing item */ for (QueueItem item : items) { if (item.getDescription().getMediaId().equals(mediaId)) { qid = item.getQueueId(); if (DEBUG) Log.d(TAG, "sendTrackChangeWithId: Found matching qid= " + qid); break; } } /* for any item associated with NowPlaying, uid is queueId */ track = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array(); } catch (NullPointerException e) { Log.w(TAG, "NullPointerException getting uid, sending no track selected");
code_review:  "w/" -> "with" (?) 
target code: void sendTrackChangeWithId(int trackChangedNT, MediaController mediaController) { if (DEBUG) Log.d(TAG, "sendTrackChangeWithId"); byte[] track; try { String mediaId = mediaController.getMetadata().getDescription().getMediaId(); long qid = MediaSession.QueueItem.UNKNOWN_ID; List<MediaSession.QueueItem> items = mNowPlayingList; /* traverse now playing list for current playing item */ for (QueueItem item : items) { if (item.getDescription().getMediaId().equals(mediaId)) { qid = item.getQueueId(); if (DEBUG) Log.d(TAG, "sendTrackChangeWithId: Found matching qid= " + qid); break; } } /* for any item associated with NowPlaying, uid is queueId */ track = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array(); } catch (NullPointerException e) { Log.w(TAG, "NullPointerException getting uid, sending no track selected");
response: void sendTrackChangeWithId(int trackChangedNT, MediaController mediaController) { if (DEBUG) Log.d(TAG, "sendTrackChangeWithId"); byte[] track; try { if (mediaController == null) { mMediaInterface.trackChangedRsp(trackChangedNT, AvrcpConstants.NO_TRACK_SELECTED); return; } String mediaId = mediaController.getMetadata().getDescription().getMediaId(); long qid = MediaSession.QueueItem.UNKNOWN_ID; List<MediaSession.QueueItem> items = mNowPlayingList; /* traverse now playing list for current playing item */ for (QueueItem item : items) { if (item.getDescription().getMediaId().equals(mediaId)) { qid = item.getQueueId(); if (DEBUG) Log.d(TAG, "sendTrackChangeWithId: Found matching qid= " + qid); break; } } /* for any item associated with NowPlaying, uid is queueId */ track = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array(); } catch (NullPointerException e) { Log.w(TAG, "NullPointerException getting uid, sending no track selected"); } }

sample: 612
buggy_code:  } else if (!isPlayerAlreadyAddressed(selectedId)) { // register new Media Controller Callback and update the current Ids if (!updateCurrentController(selectedId, mCurrBrowsePlayerID)) { status = AvrcpConstants.RSP_INTERNAL_ERR; Log.e(TAG, "register for new Address player failed: " + mCurrAddrPlayerID); } <|startfocus|> } else { MediaPlayerInfo info = getAddressedPlayerInfo(); Log.i(TAG, "addressed player " + info + "is already focused"); <|endfocus|> } if (DEBUG) Log.d(TAG, "setAddressedPlayer for selectedId: " + selectedId + " , status: " + status); // Sending address player response to remote setAddressedPlayerRspNative(bdaddr, status);
code_review:  Nit: Ids -> IDs 
target code: } else if (!isPlayerAlreadyAddressed(selectedId)) { // register new Media Controller Callback and update the current Ids if (!updateCurrentController(selectedId, mCurrBrowsePlayerID)) { status = AvrcpConstants.RSP_INTERNAL_ERR; Log.e(TAG, "register for new Address player failed: " + mCurrAddrPlayerID); } } if (DEBUG) Log.d(TAG, "setAddressedPlayer for selectedId: " + selectedId + " , status: " + status); // Sending address player response to remote setAddressedPlayerRspNative(bdaddr, status);
response: } else if (!isPlayerAlreadyAddressed(selectedId)) { // register new Media Controller Callback and update the current IDs if (!updateCurrentController(selectedId, mCurrBrowsePlayerID)) { status = AvrcpConstants.RSP_INTERNAL_ERR; Log.e(TAG, "register for new Address player failed: " + mCurrAddrPlayerID); } } else { MediaPlayerInfo info = getAddressedPlayerInfo(); Log.i(TAG, "addressed player " + info + " is already focused"); } if (DEBUG) { Log.d(TAG, "setAddressedPlayer for selectedId: " + selectedId + " , status: " + status); } // Sending address player response to remote setAddressedPlayerRspNative(bdaddr, status);

sample: 613
buggy_code:  mUnbinding = false; mEnable = false; mState = BluetoothAdapter.STATE_OFF; mQuietEnableExternal = false; mEnableExternal = false; mAddress = null; mName = null; mErrorRecoveryRetryCounter = 0; mContentResolver = context.getContentResolver(); // Observe BLE scan only mode settings change. registerForBleScanModeChange(); mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>(); mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>(); IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); <|startfocus|> IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_BD_ADDR_CHANGED); filter2.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter2); <|endfocus|> loadStoredNameAndAddress(); if (isBluetoothPersistedStateOn()) { if (DBG) Slog.d(TAG, "Startup: Bluetooth persisted state is ON."); mEnableExternal = true; } String airplaneModeRadios = Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS); if (airplaneModeRadios == null ||
code_review:  include a reason for enabling here please for the logs. 
target code: mUnbinding = false; mEnable = false; mState = BluetoothAdapter.STATE_OFF; mQuietEnableExternal = false; mEnableExternal = false; mAddress = null; mName = null; mErrorRecoveryRetryCounter = 0; mContentResolver = context.getContentResolver(); // Observe BLE scan only mode settings change. registerForBleScanModeChange(); mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>(); mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>(); IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); filter = new IntentFilter(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); filter = new IntentFilter(Intent.ACTION_SETTING_RESTORED); mContext.registerReceiver(mReceiver, filter); loadStoredNameAndAddress(); if (isBluetoothPersistedStateOn()) { if (DBG) Slog.d(TAG, "Startup: Bluetooth persisted state is ON."); mEnableExternal = true; } String airplaneModeRadios = Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS); if (airplaneModeRadios == null ||
response: mUnbinding = false; mEnable = false; mState = BluetoothAdapter.STATE_OFF; mQuietEnableExternal = false; mEnableExternal = false; mAddress = null; mName = null; mErrorRecoveryRetryCounter = 0; mContentResolver = context.getContentResolver(); // Observe BLE scan only mode settings change. registerForBleScanModeChange(); mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>(); mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>(); IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_BD_ADDR_CHANGED); filter2.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter2); loadStoredNameAndAddress(); if (isBluetoothPersistedStateOn()) { if (DBG) Slog.d(TAG, "Startup: Bluetooth persisted state is ON."); mEnableExternal = true; } String airplaneModeRadios = Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS); if (airplaneModeRadios == null || airplaneModeRadios.contains(Settings.Global.RADIO_BLUETOOTH)) { handleAirplaneModeChange(); }

sample: 614
buggy_code:  protected int adjustDexoptNeeded(int dexoptNeeded) { if (dexoptNeeded == DexFile.NO_DEXOPT_NEEDED) { // Ensure compilation by pretending a compiler filter change on the <|startfocus|> // apk location. <|endfocus|> return -DexFile.DEX2OAT_FOR_FILTER; } return dexoptNeeded;
code_review:  odex 
target code: protected int adjustDexoptNeeded(int dexoptNeeded) { if (dexoptNeeded == DexFile.NO_DEXOPT_NEEDED) { // Ensure compilation by pretending a compiler filter change on the // apk/odex location (the reason for the '-'. A positive value means // the 'oat' location). return -DexFile.DEX2OAT_FOR_FILTER; } return dexoptNeeded;
response: protected int adjustDexoptNeeded(int dexoptNeeded) { if (dexoptNeeded == DexFile.NO_DEXOPT_NEEDED) { return -DexFile.DEX2OAT_FOR_FILTER; } return dexoptNeeded; }

sample: 615
buggy_code:  private static final int CRASH_LOG_MAX_SIZE = 100; private static final String REASON_AIRPLANE_MODE = "airplane mode"; private static final String REASON_RESTARTED = "automatic restart"; private static final String REASON_START_CRASH = "turn-on crash"; private static final String REASON_SYSTEM_BOOT = "system boot"; private static final String REASON_UNEXPECTED = "unexpected crash"; private static final String REASON_USER_SWITCH = "user switch"; <|startfocus|> private static final String REASON_SYSTEM_RESTORE = "restore BluetoothOn setting"; <|endfocus|> private static final int TIMEOUT_BIND_MS = 3000; //Maximum msec to wait for a bind //Maximum msec to wait for service restart private static final int SERVICE_RESTART_TIME_MS = 200; //Maximum msec to wait for restart due to error private static final int ERROR_RESTART_TIME_MS = 3000; //Maximum msec to delay MESSAGE_USER_SWITCHED private static final int USER_SWITCHED_TIME_MS = 200; // Delay for the addProxy function in msec private static final int ADD_PROXY_DELAY_MS = 100; 
code_review:  "restored user setting" would be more clear. 
target code: private static final int CRASH_LOG_MAX_SIZE = 100; private static final String REASON_AIRPLANE_MODE = "airplane mode"; private static final String REASON_RESTARTED = "automatic restart"; private static final String REASON_START_CRASH = "turn-on crash"; private static final String REASON_SYSTEM_BOOT = "system boot"; private static final String REASON_UNEXPECTED = "unexpected crash"; private static final String REASON_USER_SWITCH = "user switch"; private static final int TIMEOUT_BIND_MS = 3000; //Maximum msec to wait for a bind //Maximum msec to wait for service restart private static final int SERVICE_RESTART_TIME_MS = 200; //Maximum msec to wait for restart due to error private static final int ERROR_RESTART_TIME_MS = 3000; //Maximum msec to delay MESSAGE_USER_SWITCHED private static final int USER_SWITCHED_TIME_MS = 200; // Delay for the addProxy function in msec private static final int ADD_PROXY_DELAY_MS = 100;
response: private static final int CRASH_LOG_MAX_SIZE = 100; private static final String REASON_AIRPLANE_MODE = "airplane mode"; private static final String REASON_RESTARTED = "automatic restart"; private static final String REASON_START_CRASH = "turn-on crash"; private static final String REASON_SYSTEM_BOOT = "system boot"; private static final String REASON_UNEXPECTED = "unexpected crash"; private static final String REASON_USER_SWITCH = "user switch"; private static final String REASON_SYSTEM_RESTORE = "restored user setting"; private static final int TIMEOUT_BIND_MS = 3000; private static final int SERVICE_RESTART_TIME_MS = 200; private static final int ERROR_RESTART_TIME_MS = 3000; private static final int USER_SWITCHED_TIME_MS = 200; private static final int ADD_PROXY_DELAY_MS = 100;

sample: 616
buggy_code:  /// CHECK-DAG: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK-DAG: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkIntCase(int[]) disassembly (after) /// CHECK: IntermediateAddressIndex <|startfocus|> /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #2 <|endfocus|> public static void checkIntCase(int[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: <<Array:l\d+>> ParameterValue /// CHECK-DAG: <<Const5:i\d+>> IntConstant 5 /// CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<Const5>>] // -------------- Loop /// CHECK-DAG: <<Index:i\d+>> Phi
code_review:  identation 
target code: /// CHECK-DAG: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK-DAG: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkIntCase(int[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #2 public static void checkIntCase(int[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: <<Array:l\d+>> ParameterValue /// CHECK-DAG: <<Const5:i\d+>> IntConstant 5 /// CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<Const5>>] // -------------- Loop /// CHECK-DAG: <<Index:i\d+>> Phi
response: /// CHECK-DAG: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK-DAG: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkIntCase(int[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #2 public static void checkIntCase(int[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) instruction_simplifier_arm64 (before) /// CHECK-DAG: <<Array:l\d+>> ParameterValue /// CHECK-DAG: <<Const5:i\d+>> IntConstant 5 /// CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<Const5>>] // -------------- Loop /// CHECK-DAG: <<Index:i\d+>> Phi

sample: 617
buggy_code:  /// CHECK-DAG: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK-DAG: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, #0x{{[0-9a-fA-F]+}} /// CHECK: VecLoad <|startfocus|> /// CHECK-NEXT: ldr q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] <|endfocus|> /// CHECK: VecStore /// CHECK-NEXT: str q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] public static void checkByteCase(byte[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } 
code_review:  indentation 
target code: /// CHECK-DAG: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK-DAG: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, #0x{{[0-9a-fA-F]+}} /// CHECK: VecLoad /// CHECK-NEXT: ldr q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] /// CHECK: VecStore /// CHECK-NEXT: str q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] public static void checkByteCase(byte[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } }
response: /// CHECK-DAG: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK-DAG: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, #0x{{[0-9a-fA-F]+}} /// CHECK: VecLoad /// CHECK-NEXT: ldr q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] /// CHECK: VecStore /// CHECK-NEXT: str q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] public static void checkByteCase(byte[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } }

sample: 618
buggy_code:  /// CHECK: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkIntCase(int[]) disassembly (after) <|startfocus|> /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #{{[0-9]}} <|endfocus|> public static void checkIntCase(int[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) instruction_simplifier_arm64 (before) /// CHECK: <<Array:l\d+>> ParameterValue /// CHECK: <<Const5:i\d+>> IntConstant 5 /// CHECK: <<Repl:d\d+>> VecReplicateScalar [<<Const5>>] // -------------- Loop /// CHECK: <<Index:i\d+>> Phi /// CHECK: If
code_review:  Must be 2. 
target code: /// CHECK: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkIntCase(int[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #2 public static void checkIntCase(int[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) instruction_simplifier_arm64 (before) /// CHECK: <<Array:l\d+>> ParameterValue /// CHECK: <<Const5:i\d+>> IntConstant 5 /// CHECK: <<Repl:d\d+>> VecReplicateScalar [<<Const5>>] // -------------- Loop /// CHECK: <<Index:i\d+>> Phi /// CHECK: If
response: /// CHECK: <<Add:d\d+>> VecAdd [<<Load>>,<<Repl>>] /// CHECK-NOT: IntermediateAddress /// CHECK: VecStore [<<Array>>,<<Address1>>,<<Add>>] /// CHECK-START-ARM64: void Main.checkIntCase(int[]) disassembly (after) /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #{{[0-9]}} public static void checkIntCase(int[] a) { for (int i = 0; i < 128; i++) { a[i] += 5; } } /// CHECK-START-ARM64: void Main.checkByteCase(byte[]) instruction_simplifier_arm64 (before) /// CHECK: <<Array:l\d+>> ParameterValue /// CHECK: <<Const5:i\d+>> IntConstant 5 /// CHECK: <<Repl:d\d+>> VecReplicateScalar [<<Const5>>] // -------------- Loop /// CHECK: <<Index:i\d+>> Phi /// CHECK: If

sample: 619
buggy_code:  public static void checkInt2Float(int[] a, float[] b) { for (int i = 0; i < 128; i++) { <|startfocus|> b[i] = (float)a[i]; <|endfocus|> }
code_review:  2 
target code: public static void checkInt2Float(int[] a, float[] b) { for (int i = 0; i < 128; i++) { b[i] = (float) a[i]; }
response: public static void checkInt2Float(int[] a, float[] b) { for (int i = 0; i < 128; i++) { b[i] = (float)a[i]; } }

sample: 620
buggy_code:  public static void checkInt2Float(int[] a, float[] b) { for (int i = 0; i < 128; i++) { <|startfocus|> b[i] = (float)a[i]; <|endfocus|> }
code_review:  space after this cast (also below) 
target code: public static void checkInt2Float(int[] a, float[] b) { for (int i = 0; i < 128; i++) { b[i] = (float) a[i]; }
response: public static void checkInt2Float(int[] a, float[] b) { for (int i = 0; i < 128; i++) { b[i] = (float) a[i]; } }

sample: 621
buggy_code:  public static int calcArraySum(int[] a, byte[] b, float[] c) { int sum = 0; for (int i = 0; i < 128; i++) { <|startfocus|> sum += a[i] + b[i] + (int)c[i]; <|endfocus|> } return sum;
code_review:  Missing checker statements for this method? 
target code: public static int calcArraySum(int[] a, byte[] b, float[] c) { int sum = 0; for (int i = 0; i < 128; i++) { sum += a[i] + b[i] + (int) c[i]; } return sum;
response: public static int calcArraySum(int[] a, byte[] b, float[] c) { int sum = 0; for (int i = 0; i < 128; i++) { sum += a[i] + b[i] + (int)c[i]; } return sum; }

sample: 622
buggy_code:  * Agreement between Taligent and Sun. This technology is protected * by multiple US and International patents. * * This notice and attribution to Taligent may not be removed. * Taligent is a registered trademark of Taligent, Inc. * */ package java.awt.font; import java.io.InvalidObjectException; import java.text.AttributedCharacterIterator.Attribute; import java.util.Map; import java.util.HashMap; <|startfocus|> // Android-removed: List of classes for use with attribute keys; "Summary of attributes" section. <|endfocus|> /** * The <code>TextAttribute</code> class defines attribute keys and * attribute values used for text rendering. * <p> * <code>TextAttribute</code> instances are used as attribute keys to * identify attributes in classes handling text attributes. Other * constants defined in this class can be used as attribute values. * <p> * For each text attribute, the documentation provides: * <UL> * <LI>the type of its value, * <LI>the relevant predefined constants, if any
code_review:  because....X. 
target code: * Agreement between Taligent and Sun. This technology is protected * by multiple US and International patents. * * This notice and attribution to Taligent may not be removed. * Taligent is a registered trademark of Taligent, Inc. * */ package java.awt.font; import java.io.InvalidObjectException; import java.text.AttributedCharacterIterator.Attribute; import java.util.Map; import java.util.HashMap; // Android-removed: List of classes for use with attribute keys; Android doesn't have those. // Android-removed: "Summary of attributes" section. Android doesn't have the referenced classes. /** * The <code>TextAttribute</code> class defines attribute keys and * attribute values used for text rendering. * <p> * <code>TextAttribute</code> instances are used as attribute keys to * identify attributes in classes handling text attributes. Other * constants defined in this class can be used as attribute values. * <p> * For each text attribute, the documentation provides: * <UL> * <LI>the type of its value, * <LI>the relevant predefined constants, if any
response: package java.awt.font; import java.io.InvalidObjectException; import java.text.AttributedCharacterIterator.Attribute; import java.util.Map; import java.util.HashMap; public class TextAttribute { // Android-removed: List of classes for use with attribute keys; "Summary of attributes" section. public static final Attribute FAMILY = new Attribute("family"); public static final Attribute WEIGHT = new Attribute("weight"); public static final Attribute WIDTH = new Attribute("width"); public static final Attribute POSTURE = new Attribute("posture"); public static final Attribute SIZE = new Attribute("size"); public static final Attribute TRANSFORM = new Attribute("transform"); public static final Attribute SUPERSCRIPT = new Attribute("superscript"); public static final Attribute FONT = new Attribute("font"); public static final Attribute CHAR_REPLACEMENT = new Attribute("char_replacement"); public static final Attribute FOREGROUND = new Attribute("foreground"); public static final Attribute BACKGROUND = new Attribute("background"); public static final Attribute UNDERLINE = new Attribute("underline"); public static final Attribute STRIKETHROUGH = new Attribute("strikethrough"); public static final Attribute RUN_DIRECTION = new Attribute("run_direction"); public static final Attribute BIDI_EMBEDDING = new Attribute("bidi_embedding"); public static final Attribute JUSTIFICATION = new Attribute("justification"); public static final Attribute INPUT_METHOD_HIGHLIGHT = new Attribute("input_method_highlight"); public static final Attribute INPUT_METHOD_UNDERLINE = new Attribute("input_method_underline"); public static final Attribute SWAP_COLORS = new Attribute("swap_colors"); public static final Attribute NUMERIC_SHAPING = new Attribute("numeric_shaping"); public static final Attribute KERNING = new Attribute("kerning"); public static final Attribute LIGATURES = new Attribute("ligatures"); public static final Attribute TRACKING = new Attribute("tracking"); public static final Attribute BASELINE_TRANSFORM = new Attribute("baseline_transform"); public static final Attribute BASELINE_OFFSET = new Attribute("baseline_offset"); public static final Attribute STRIKETHROUGH_POSITION = new Attribute("strikethrough_position"); public static final Attribute STRIKETHROUGH_THICKNESS = new Attribute("strikethrough_thickness"); public static final Attribute UNDERLINE_POSITION = new Attribute("underline_position"); public static final Attribute UNDERLINE_THICKNESS = new Attribute("underline_thickness"); public

sample: 623
buggy_code:  if (instance != null) { return instance; } else { throw new InvalidObjectException("unknown attribute name"); } } // Serialization compatibility with Java 2 platform v1.2. // 1.2 will throw an InvalidObjectException if ever asked to // deserialize INPUT_METHOD_UNDERLINE. // This shouldn't happen in real life. static final long serialVersionUID = 7744112784117861702L; // // For use with Font. // <|startfocus|> // Android-removed: links to font names from documentation. <|endfocus|> /** * Attribute key for the font name. Values are instances of * <b><code>String</code></b>. The default value is * <code>"Default"</code>, which causes the platform default font * family to be used. * * <p> The <code>Font</code> class defines constants for the logical * font names. * * <p>This defines the value passed as <code>name</code> to the * <code>Font</code> constructor. Both logical and physical
code_review:  s/font names/java.awk.Font constants not present on Android/ 
target code: if (instance != null) { return instance; } else { throw new InvalidObjectException("unknown attribute name"); } } // Serialization compatibility with Java 2 platform v1.2. // 1.2 will throw an InvalidObjectException if ever asked to // deserialize INPUT_METHOD_UNDERLINE. // This shouldn't happen in real life. static final long serialVersionUID = 7744112784117861702L; // // For use with Font. // // Android-removed: Don't link to java.awt.Font class, it doesn't exist on Android. /** * Attribute key for the font name. Values are instances of * <b><code>String</code></b>. The default value is * <code>"Default"</code>, which causes the platform default font * family to be used. * * <p> The <code>Font</code> class defines constants for the logical * font names. * * <p>This defines the value passed as <code>name</code> to the * <code>Font</code> constructor. Both logical and physical
response: private static void updateChildrenFonts(CTabFolder folder, Font font) { for (CTabItem item : folder.getItems()) { Font itemFont = item.getFont(); if (itemFont != null && !itemFont.equals(font)) { item.setFont(font); } } } private static Label createErrorLabel(Composite parent) { final Label label = new Label(parent, SWT.WRAP); Color color = new Color(parent.getDisplay(), 0xe7, 0x4c, 0x3c); label.setForeground(color); final FontDescriptor fd = FontDescriptor.createFrom(parent.getFont()); fd.setHeight(9); Font font = fd.createFont(parent.getDisplay()); label.setFont(font); label.addDisposeListener(e -> { color.dispose(); fd.destroyFont(font); }); return label; } myPropertiesTable.getDefaultRenderer(String.class))); myPropertiesTable.setDefaultRenderer(Integer.class, new DelegatingCellRenderer(myModule, myConfiguration, myPropertiesTable.getDefaultRenderer(Integer.class))); myPropertiesTable.setDefaultRenderer(Boolean.class, new DelegatingCellRenderer(myModule, myConfiguration, myPropertiesTable.getDefaultRenderer(Boolean.class))); myPropertiesTable.setDefaultRenderer(StyleWrapper.class, new DelegatingCellRenderer(myModule, myConfiguration, false, styleEditor)); myPropertiesTable.setDefaultRenderer(TableLabel.class, new DefaultTableCellRenderer() { @Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column); this.setFont(labelFont); return this; } }); final ColorRendererEditor editor = new ColorRendererEditor(myModule, myConfiguration, myPropertiesTable); myPropertiesTable.setDefaultEditor(Color.class, editor);

sample: 624
buggy_code:  * and the rendering system might not render text at these sizes. * Negative sizes are illegal and result in the default size. * * <p>Note that the appearance and metrics of a 12pt font with a * 2x transform might be different than that of a 24 point font * with no transform. */ public static final TextAttribute SIZE = new TextAttribute("size"); <|startfocus|> // Android-removed: Sections of documentation about TransformAttribute. <|endfocus|> /** * Attribute key for the transform of a font. Values are * instances of <b><code>TransformAttribute</code></b>. The * default value is <code>TransformAttribute.IDENTITY</code>. * * <p>The primary intent is to support scaling and skewing, though * other effects are possible.</p> * * <p>Some transforms will cause the baseline to be rotated and/or * shifted. The text and the baseline are transformed together so * that the text follows the new baseline. For example, with text
code_review:  TransformAttribute >class that is not present on Android<. 
target code: * and the rendering system might not render text at these sizes. * Negative sizes are illegal and result in the default size. * * <p>Note that the appearance and metrics of a 12pt font with a * 2x transform might be different than that of a 24 point font * with no transform. */ public static final TextAttribute SIZE = new TextAttribute("size"); // Android-removed: References to classes that don't exist on Android. // These classes were AffineTransform, Font, and TransformAttribute. /** * Attribute key for the transform of a font. Values are * instances of <b><code>TransformAttribute</code></b>. The * default value is <code>TransformAttribute.IDENTITY</code>. * * <p>The primary intent is to support scaling and skewing, though * other effects are possible.</p> * * <p>Some transforms will cause the baseline to be rotated and/or * shifted. The text and the baseline are transformed together so * that the text follows the new baseline. For example, with text
response: public static final TextAttribute SIZE = new TextAttribute("size"); public static final TextAttribute TRANSFORM = new TextAttribute("transform", TransformAttribute.IDENTITY); /** * Attribute key for the transform of a font. Values are * instances of <b><code>TransformAttribute</code></b>. The * default value is <code>TransformAttribute.IDENTITY</code>. * * <p>The primary intent is to support scaling and skewing, though * other effects are possible.</p> * * <p>Some transforms will cause the baseline to be rotated and/or * shifted. The text and the baseline are transformed together so * that the text follows the new baseline. For example, with text * that is not present on Android.</p> */

sample: 625
buggy_code:  * and descent can never become negative, however. */ public static final TextAttribute SUPERSCRIPT = new TextAttribute("superscript"); /** * Standard superscript. * @see #SUPERSCRIPT */ public static final Integer SUPERSCRIPT_SUPER = Integer.valueOf(1); /** * Standard subscript. * @see #SUPERSCRIPT */ public static final Integer SUPERSCRIPT_SUB = Integer.valueOf(-1); <|startfocus|> // Android-removed: Documentation sections about java.awt.Font. <|endfocus|> /** * Attribute key used to provide the font to use to render text. * * The default * value is null, indicating that normal resolution of a * <code>Font</code> from attributes should be performed. * * <p><code>TextLayout</code> and * <code>AttributedCharacterIterator</code> work in terms of * <code>Maps</code> of <code>TextAttributes</code>. Normally, * all the attributes are examined and used to select and * configure a <code>Font</code> instance. If a <code>FONT</code>
code_review:  ... not present on Android. 
target code: * and descent can never become negative, however. */ public static final TextAttribute SUPERSCRIPT = new TextAttribute("superscript"); /** * Standard superscript. * @see #SUPERSCRIPT */ public static final Integer SUPERSCRIPT_SUPER = Integer.valueOf(1); /** * Standard subscript. * @see #SUPERSCRIPT */ public static final Integer SUPERSCRIPT_SUB = Integer.valueOf(-1); // Android-removed: Don't link to java.awt.Font class, it doesn't exist on Android. /** * Attribute key used to provide the font to use to render text. * * The default * value is null, indicating that normal resolution of a * <code>Font</code> from attributes should be performed. * * <p><code>TextLayout</code> and * <code>AttributedCharacterIterator</code> work in terms of * <code>Maps</code> of <code>TextAttributes</code>. Normally, * all the attributes are examined and used to select and * configure a <code>Font</code> instance. If a <code>FONT</code>
response: public static final TextAttribute SUPERSCRIPT = new TextAttribute("superscript"); public static final Integer SUPERSCRIPT_SUPER = Integer.valueOf(1); public static final Integer SUPERSCRIPT_SUB = Integer.valueOf(-1); public static final String FONT = "font"; public static final String FAMILY = "family"; public static final String WEIGHT = "weight"; public static final String WIDTH = "width"; public static final String POSTURE = "posture"; public static final String SIZE = "size"; public static final String TRANSFORM = "transform"; public static final String SUPERSCRIPT = "superscript"; public static final String FONT_RENDER_CONTEXT = "font_render_context"; public static final String CHAR_REPLACEMENT = "char_replacement"; public static final String FOREGROUND = "foreground"; public static final String BACKGROUND = "background"; public static final String UNDERLINE = "underline"; public static final String STRIKETHROUGH = "strikethrough"; public static final String RUN_DIRECTION = "run_direction"; public static final String BIDI_EMBEDDING = "bidi_embedding"; public static final String JUSTIFICATION = "justification"; public static final String INPUT_METHOD_HIGHLIGHT = "input_method_highlight"; public static final String INPUT_METHOD_UNDERLINE = "input_method_underline"; public static final String SWAP_COLORS = "swap_colors"; public static final String NUMERIC_SHAPING = "numeric_shaping"; public static final String KERNING = "kerning"; public static final String LIGATURES = "ligatures"; public static final String TRACKING = "tracking"; public static final String BASELINE_TRANSFORM = "baseline_transform"; public static final String CUSTOM = "custom";

sample: 626
buggy_code:  * default value for <code>JUSTIFICATION</code>. * @see #JUSTIFICATION */ public static final Float JUSTIFICATION_FULL = Float.valueOf(1.0f); /** * Do not allow the line to be justified. * @see #JUSTIFICATION */ public static final Float JUSTIFICATION_NONE = Float.valueOf(0.0f); // // For use by input method. // <|startfocus|> // Android-removed: Documentation sections about java.awt.im.InputMethodHighlight <|endfocus|> /** * Attribute key for input method highlight styles. * * The default value is <code>null</code>, * which means that input method styles should not be applied * before rendering. * * @see java.text.Annotation */ public static final TextAttribute INPUT_METHOD_HIGHLIGHT = new TextAttribute("input method highlight"); /** * Attribute key for input method underlines. Values * are instances of <b><code>Integer</code></b>. The default * value is <code>-1</code>, which means no underline. *
code_review:  As above. 
target code: * default value for <code>JUSTIFICATION</code>. * @see #JUSTIFICATION */ public static final Float JUSTIFICATION_FULL = Float.valueOf(1.0f); /** * Do not allow the line to be justified. * @see #JUSTIFICATION */ public static final Float JUSTIFICATION_NONE = Float.valueOf(0.0f); // // For use by input method. // // Android-removed: References to java.awt.im.InputMethodHighlight (doesn't exist on Android). /** * Attribute key for input method highlight styles. * * The default value is <code>null</code>, * which means that input method styles should not be applied * before rendering. * * @see java.text.Annotation */ public static final TextAttribute INPUT_METHOD_HIGHLIGHT = new TextAttribute("input method highlight"); /** * Attribute key for input method underlines. Values * are instances of <b><code>Integer</code></b>. The default * value is <code>-1</code>, which means no underline. *
response: Fixed Code: ```java public static final Float JUSTIFICATION_FULL = Float.valueOf(1.0f); public static final Float JUSTIFICATION_NONE = Float.valueOf(0.0f); public static final TextAttribute INPUT_METHOD_HIGHLIGHT = new TextAttribute("input method highlight"); ```

sample: 627
buggy_code:  mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE); if (mEnable && mBluetooth != null) { waitForOnOff(true, false); mEnable = false; handleDisable(); waitForOnOff(false, false); } else { mEnable = false; handleDisable(); } break; case MESSAGE_RESTORE_ON_SETTING: try { if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { <|startfocus|> if (DBG) Slog.d(TAG, "Restore to disable Bluetooth"); <|endfocus|> disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore to enable Bluetooth"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting",e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER:
code_review:  Restoring Bluetooth state to disabled 
target code: mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE); if (mEnable && mBluetooth != null) { waitForOnOff(true, false); mEnable = false; handleDisable(); waitForOnOff(false, false); } else { mEnable = false; handleDisable(); } break; case MESSAGE_RESTORE_ON_SETTING: try { if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to disabled"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore to enable Bluetooth"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting",e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER:
response: mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE); if (mEnable && mBluetooth != null) { waitForOnOff(true, false); mEnable = false; handleDisable(); waitForOnOff(false, false); } else { mEnable = false; handleDisable(); } break; case MESSAGE_RESTORE_ON_SETTING: try { if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore to disable Bluetooth"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore to enable Bluetooth"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting",e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; }

sample: 628
buggy_code:  } else { mEnable = false; handleDisable(); } break; case MESSAGE_RESTORE_ON_SETTING: try { if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore to disable Bluetooth"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { <|startfocus|> if (DBG) Slog.d(TAG, "Restore to enable Bluetooth"); <|endfocus|> enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting",e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; } case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK: {
code_review:  Restoring Bluetooth state to enabled 
target code: } else { mEnable = false; handleDisable(); } break; case MESSAGE_RESTORE_ON_SETTING: try { if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore to disable Bluetooth"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to enabled"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting",e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; } case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK: {
response: } else { mEnable = false; handleDisable(); } break; case MESSAGE_RESTORE_ON_SETTING: try { if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore to disable Bluetooth"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore to enable Bluetooth"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting",e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; } case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK: { IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj; mStateChangeCallbacks.register(callback); break; }

sample: 629
buggy_code:  private static final int MESSAGE_BLUETOOTH_STATE_CHANGE = 60; private static final int MESSAGE_TIMEOUT_BIND = 100; private static final int MESSAGE_TIMEOUT_UNBIND = 101; private static final int MESSAGE_GET_NAME_AND_ADDRESS = 200; private static final int MESSAGE_USER_SWITCHED = 300; private static final int MESSAGE_USER_UNLOCKED = 301; private static final int MESSAGE_ADD_PROXY_DELAYED = 400; private static final int MESSAGE_BIND_PROFILE_SERVICE = 401; <|startfocus|> private static final int MESSAGE_RESTORE_ON_SETTING = 500; <|endfocus|> private static final int RESTORE_SETTING_TO_ON = 1; private static final int RESTORE_SETTING_TO_OFF = 0; private static final int MAX_SAVE_RETRIES = 3; private static final int MAX_ERROR_RESTART_RETRIES = 6; // Bluetooth persisted setting is off private static final int BLUETOOTH_OFF=0; // Bluetooth persisted setting is on // and Airplane mode won't affect Bluetooth state at start up private static final int BLUETOOTH_ON_BLUETOOTH=1; // Bluetooth persisted setting is on
code_review:  prefer this to be RESTORE_USER_SETTING to make it clear that it's coming from elsewhere 
target code: private static final int MESSAGE_BLUETOOTH_STATE_CHANGE = 60; private static final int MESSAGE_TIMEOUT_BIND = 100; private static final int MESSAGE_TIMEOUT_UNBIND = 101; private static final int MESSAGE_GET_NAME_AND_ADDRESS = 200; private static final int MESSAGE_USER_SWITCHED = 300; private static final int MESSAGE_USER_UNLOCKED = 301; private static final int MESSAGE_ADD_PROXY_DELAYED = 400; private static final int MESSAGE_BIND_PROFILE_SERVICE = 401; private static final int MESSAGE_RESTORE_USER_SETTING = 500; private static final int RESTORE_SETTING_TO_ON = 1; private static final int RESTORE_SETTING_TO_OFF = 0; private static final int MAX_SAVE_RETRIES = 3; private static final int MAX_ERROR_RESTART_RETRIES = 6; // Bluetooth persisted setting is off private static final int BLUETOOTH_OFF=0; // Bluetooth persisted setting is on // and Airplane mode won't affect Bluetooth state at start up private static final int BLUETOOTH_ON_BLUETOOTH=1; // Bluetooth persisted setting is on
response: private static final int MESSAGE_BLUETOOTH_STATE_CHANGE = 60; private static final int MESSAGE_TIMEOUT_BIND = 100; private static final int MESSAGE_TIMEOUT_UNBIND = 101; private static final int MESSAGE_GET_NAME_AND_ADDRESS = 200; private static final int MESSAGE_USER_SWITCHED = 300; private static final int MESSAGE_USER_UNLOCKED = 301; private static final int MESSAGE_ADD_PROXY_DELAYED = 400; private static final int MESSAGE_BIND_PROFILE_SERVICE = 401; private static final int MESSAGE_RESTORE_ON_SETTING = 500; private static final int RESTORE_SETTING_TO_ON = 1; private static final int RESTORE_SETTING_TO_OFF = 0; private static final int MAX_SAVE_RETRIES = 3; private static final int MAX_ERROR_RESTART_RETRIES = 6; private static final int BLUETOOTH_OFF = 0; private static final int BLUETOOTH_ON_BLUETOOTH = 1; // Bluetooth persisted setting is off private static final int RESTORE_USER_SETTING = 500; // Bluetooth persisted setting is on // and Airplane mode won't affect Bluetooth state at start up private static final int BLUETOOTH_ON_AIRPLANE_MODE = 1;

sample: 630
buggy_code:  Intent.EXTRA_SETTING_NEW_VALUE); if (DBG) Slog.d(TAG, "ACTION_SETTING_RESTORED with BLUETOOTH_ON, prevValue=" + prevValue + ", newValue=" + newValue); if ((newValue != null) && (prevValue != null) && !prevValue.equals(newValue)) { <|startfocus|> mHandler.sendMessage( mHandler.obtainMessage(MESSAGE_RESTORE_ON_SETTING, newValue.equals("0") ? RESTORE_SETTING_TO_OFF : RESTORE_SETTING_TO_ON, 0)); <|endfocus|> } } }
code_review:  it's more idiomatic to either: mHandler.obtainMessage(...).sendToTarget() or Message msg = mHandler.obtainMessage(...); msg.obj = ... mHandler.sendMessage(msg); 
target code: Intent.EXTRA_SETTING_NEW_VALUE); if (DBG) Slog.d(TAG, "ACTION_SETTING_RESTORED with BLUETOOTH_ON, prevValue=" + prevValue + ", newValue=" + newValue); if ((newValue != null) && (prevValue != null) && !prevValue.equals(newValue)) { Message msg = mHandler.obtainMessage(MESSAGE_RESTORE_USER_SETTING, newValue.equals("0") ? RESTORE_SETTING_TO_OFF : RESTORE_SETTING_TO_ON, 0); mHandler.sendMessage(msg); } } }
response: Intent.EXTRA_SETTING_NEW_VALUE); if (DBG) Slog.d(TAG, "ACTION_SETTING_RESTORED with BLUETOOTH_ON, prevValue=" + prevValue + ", newValue=" + newValue); if ((newValue != null) && (prevValue != null) && !prevValue.equals(newValue)) { Message msg = mHandler.obtainMessage(MESSAGE_RESTORE_ON_SETTING, newValue.equals("0") ? RESTORE_SETTING_TO_OFF : RESTORE_SETTING_TO_ON, 0); mHandler.sendMessage(msg); }

sample: 631
buggy_code:  if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to disabled"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to enabled"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { <|startfocus|> Slog.e(TAG,"Unable to change Bluetooth On setting",e); <|endfocus|> } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; } case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK: { IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj; mStateChangeCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK: {
code_review:  nit: spaces after commas 
target code: if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to disabled"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to enabled"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG,"Unable to change Bluetooth On setting", e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; } case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK: { IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj; mStateChangeCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK: {
response: if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to disabled"); disable(REASON_RESTORE_USER_SETTING, true); } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) { if (DBG) Slog.d(TAG, "Restore Bluetooth state to enabled"); enable(REASON_RESTORE_USER_SETTING); } } catch (RemoteException e) { Slog.e(TAG, "Unable to change Bluetooth On setting", e); } break; case MESSAGE_REGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_ADAPTER: { IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj; mCallbacks.unregister(callback); break; } case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK: { IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj; mStateChangeCallbacks.register(callback); break; } case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK: { IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj; mStateChangeCallbacks.unregister(callback); break; }

sample: 632
buggy_code:  * @hide */ public class ServiceInfo implements Parcelable { // arbitrary limit on the number of locale -> name pairs we support final static int MAP_LIMIT = 50; /** * User displayable names listed by language. Unmodifiable. */ final Map<Locale, String> names; /** * The class name for this service - used to catagorize and filter */ final String className; /** * The language for this service content */ final Locale locale; /** <|startfocus|> <|endfocus|> * The carrier's identifier for the service. */ final String serviceId; /** * The start time indicating when this service will be available. */ final Date sessionStartTime; /** * The end time indicating when this sesion stops being available. */ final Date sessionEndTime; public ServiceInfo(Map<Locale, String> newNames, String newClassName, Locale newLocale, String newServiceId, Date start, Date end) {
code_review:  empty line? 
target code: * @hide */ public class ServiceInfo implements Parcelable { // arbitrary limit on the number of locale -> name pairs we support final static int MAP_LIMIT = 50; /** * User displayable names listed by language. Unmodifiable. */ final Map<Locale, String> names; /** * The class name for this service - used to catagorize and filter */ final String className; /** * The language for this service content */ final Locale locale; /** * The carrier's identifier for the service. */ final String serviceId; /** * The start time indicating when this service will be available. */ final Date sessionStartTime; /** * The end time indicating when this sesion stops being available. */ final Date sessionEndTime; public ServiceInfo(Map<Locale, String> newNames, String newClassName, Locale newLocale, String newServiceId, Date start, Date end) {
response: private boolean rebindBottomOpRef(ILogicalOperator currentOp, Mutable<ILogicalOperator> opRef, Mutable<ILogicalOperator> replacementOpRef) { int index = 0; for (Mutable<ILogicalOperator> childRef : currentOp.getInputs()) { if (childRef == opRef) { currentOp.getInputs().set(index, replacementOpRef); return true; } else { if (rebindBottomOpRef(childRef.getValue(), opRef, replacementOpRef)) { return true; } } ++index; } return false; } public class ServiceInfo implements Parcelable { final static int MAP_LIMIT = 50; final Map<Locale, String> names; final String className; final Locale locale; final String serviceId; final Date sessionStartTime; final Date sessionEndTime; public ServiceInfo(Map<Locale, String> newNames, String newClassName, Locale newLocale, String newServiceId, Date start, Date end) { names = newNames; className = newClassName; locale = newLocale; serviceId = newServiceId; sessionStartTime = start; sessionEndTime = end; } }

sample: 633
buggy_code:  /** * Initialize streaming service for this app and subId, registering the listener. * * @param listener The callback to use to communicate with the app. * @param appName The package name of the calling app. * @param subscriptionId The subscription ID to use. * @return {@link MbmsException#ERROR_ALREADY_INITIALIZED} or {@link MbmsException#SUCCESS}. */ @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, <|startfocus|> int subscriptionId) throws RemoteException { <|endfocus|> return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * * Note that subsequent calls with the same appName and subId will replace * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS
code_review:  list what ints are allowed? 
target code: /** * Initialize streaming service for this app and subId, registering the listener. * * @param listener The callback to use to communicate with the app. * @param appName The package name of the calling app. * @param subscriptionId The subscription ID to use. * @return {@link MbmsException#ERROR_ALREADY_INITIALIZED} or {@link MbmsException#SUCCESS}. */ @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * * Note that subsequent calls with the same appName and subId will replace * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS
response: private void selectItemByText(@NotNull final JList list, @NotNull final String text) { final Integer selectedIndex = GuiActionRunner.execute(new GuiQuery<Integer>() { @Override protected Integer executeInEDT() throws Throwable { ListPopupModel listPopupModel = (ListPopupModel) list.getModel(); for (int i = 0; i < listPopupModel.getSize(); ++i) { PopupFactoryImpl.ActionItem actionItem = (PopupFactoryImpl.ActionItem) listPopupModel.get(i); if (actionItem.getText().equals(text)) { return i; } } return -1; } }); assertTrue(selectedIndex >= 0); GuiActionRunner.execute(new GuiTask() { @Override protected void executeInEDT() throws Throwable { list.setSelectedIndex(selectedIndex); } }); assertTrue(((PopupFactoryImpl.ActionItem) list.getSelectedValue()).getText().equals(text)); } @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; }

sample: 634
buggy_code:  /** * Initialize streaming service for this app and subId, registering the listener. * * @param listener The callback to use to communicate with the app. * @param appName The package name of the calling app. * @param subscriptionId The subscription ID to use. * @return {@link MbmsException#ERROR_ALREADY_INITIALIZED} or {@link MbmsException#SUCCESS}. */ @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, <|startfocus|> int subscriptionId) throws RemoteException { <|endfocus|> return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * * Note that subsequent calls with the same appName and subId will replace * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS
code_review:  same line? 
target code: /** * Initialize streaming service for this app and subId, registering the listener. * * @param listener The callback to use to communicate with the app. * @param appName The package name of the calling app. * @param subscriptionId The subscription ID to use. * @return {@link MbmsException#ERROR_ALREADY_INITIALIZED} or {@link MbmsException#SUCCESS}. */ @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * * Note that subsequent calls with the same appName and subId will replace * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS
response: @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; } @Override public void registerStreamingServices(String appName, int subscriptionId, List<ServiceClass> serviceClasses) throws RemoteException { // Register serviceClasses of interest with the appName/subId key // Starts async fetching data on streaming services of matching classes to be reported // later via IMbmsStreamingManagerCallback.streamingServicesUpdated(List) // Note that subsequent calls with the same appName and subId will replace // the service class list. }

sample: 635
buggy_code:  */ @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * <|startfocus|> * Note that subsequent calls with the same appName and subId will replace <|endfocus|> * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS * @param serviceClasses The service classes that the app wishes to get info on. The strings * may contain arbitrary data as negotiated between the app and the * carrier. */ @Override public int getStreamingServices(String appName, int subscriptionId, List<String> serviceClasses) throws MbmsException { return 0; } @Override public StreamingService startStreaming(String appName, int subId,
code_review:  and uid. Another app should be able to get services for the same appName and that's handled separately. We should also keep a list of tests we need to verify the impl meets expectations. 
target code: */ @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * * Note that subsequent calls with the same uid, appName and subId will replace * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS * @param serviceClasses The service classes that the app wishes to get info on. The strings * may contain arbitrary data as negotiated between the app and the * carrier. */ @Override public int getStreamingServices(String appName, int subscriptionId, List<String> serviceClasses) throws MbmsException { return 0; } @Override public StreamingService startStreaming(String appName, int subId,
response: @Override public int initialize(IMbmsStreamingManagerCallback listener, String appName, int subscriptionId) throws RemoteException { return 0; } /** * Registers serviceClasses of interest with the appName/subId key. * Starts async fetching data on streaming services of matching classes to be reported * later via {@link IMbmsStreamingManagerCallback#streamingServicesUpdated(List)} * Note that subsequent calls with the same appName and subId will replace * the service class list. * * @param appName The package name of the calling app. * @param subscriptionId The subscription id for eMBMS * @param serviceClasses The service classes that the app wishes to get info on. The strings * may contain arbitrary data as negotiated between the app and the * carrier. */ @Override public int getStreamingServices(String appName, int subscriptionId, List<String> serviceClasses) throws MbmsException { return 0; } @Override public StreamingService startStreaming(String appName, int subId, int uid) throws MbmsException { return null; }

sample: 636
buggy_code:  security.checkWrite(name); } } */ if (name == null) { // Android-changed: different exception message in ctor when file == null. // throw new NullPointerException(); throw new NullPointerException("file == null"); } if (file.isInvalid()) { throw new FileNotFoundException("Invalid file path"); } this.path = name; this.mode = imode; // BEGIN Android-changed: Use IoBridge.open() instead of open. <|startfocus|> fd = IoBridge.open(file.getPath(), imode); <|endfocus|> if (syncMetadata) { try { fd.sync(); } catch (IOException e) { // Ignored } } guard.open("close"); // END Android-changed: Use IoBridge.open() instead of open. } /** * Returns the opaque file descriptor object associated with this * stream. * * @return the file descriptor object associated with this stream. * @exception IOException if an I/O error occurs. * @see java.io.FileDescriptor */
code_review:  should probably use "name" for consistency with your change to the second argument. 
target code: security.checkWrite(name); } } */ if (name == null) { // Android-changed: different exception message in ctor when file == null. // throw new NullPointerException(); throw new NullPointerException("file == null"); } if (file.isInvalid()) { throw new FileNotFoundException("Invalid file path"); } this.path = name; this.mode = imode; // BEGIN Android-changed: Use IoBridge.open() instead of open. fd = IoBridge.open(name, imode); if (syncMetadata) { try { fd.sync(); } catch (IOException e) { // Ignored } } guard.open("close"); // END Android-changed: Use IoBridge.open() instead of open. } /** * Returns the opaque file descriptor object associated with this * stream. * * @return the file descriptor object associated with this stream. * @exception IOException if an I/O error occurs. * @see java.io.FileDescriptor */
response: security.checkWrite(name); } } */ if (name == null) { throw new NullPointerException("file == null"); } if (file.isInvalid()) { throw new FileNotFoundException("Invalid file path"); } this.path = name; this.mode = imode; fd = IoBridge.open(file.getPath(), imode); if (syncMetadata) { try { fd.sync(); } catch (IOException e) { // Ignored } } guard.open("close"); } /** * Returns the opaque file descriptor object associated with this * stream. * * @return the file descriptor object associated with this stream. * @exception IOException if an I/O error occurs. * @see java.io.FileDescriptor */

sample: 637
buggy_code:  if (VDBG) Log.d(TAG, "Tether Mode requested by " + who); handleInterfaceServingStateActive(message.arg1, who); who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface); // If there has been a change and an upstream is now // desired, kick off the selection process. final boolean previousUpstreamWanted = updateUpstreamWanted(); if (!previousUpstreamWanted && mUpstreamWanted) { chooseUpstreamType(true); } break; } <|startfocus|> case EVENT_IFACE_SERVING_STATE_INACTIVE: { <|endfocus|> TetherInterfaceStateMachine who = (TetherInterfaceStateMachine)message.obj; if (VDBG) Log.d(TAG, "Tether Mode unrequested by " + who); handleInterfaceServingStateInactive(who); if (mNotifyList.isEmpty()) { turnOffMasterTetherSettings(); // transitions appropriately } else { if (DBG) { Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:"); for (TetherInterfaceStateMachine o : mNotifyList) {
code_review:  Could this comment be improved a bit, it is a bit cryptic. 
target code: if (VDBG) Log.d(TAG, "Tether Mode requested by " + who); handleInterfaceServingStateActive(message.arg1, who); who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface); // If there has been a change and an upstream is now // desired, kick off the selection process. final boolean previousUpstreamWanted = updateUpstreamWanted(); if (!previousUpstreamWanted && mUpstreamWanted) { chooseUpstreamType(true); } break; } case CMD_TETHER_MODE_UNREQUESTED: { TetherInterfaceStateMachine who = (TetherInterfaceStateMachine)message.obj; if (VDBG) Log.d(TAG, "Tether Mode unrequested by " + who); handleInterfaceServingStateInactive(who); if (mNotifyList.isEmpty()) { turnOffMasterTetherSettings(); // transitions appropriately } else { if (DBG) { Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:"); for (TetherInterfaceStateMachine o : mNotifyList) {
response: private static String getNativePath(String packageName) { String nativePath = getApplicationInfo(packageName).nativeLibraryDir; if (nativePath == null) { throw new IllegalStateException("No native path found for " + packageName); } if (apkPath == null) { throw new IllegalStateException("No APK path found for " + packageName); } return apkPath; } private static List<String> convert(Collection<StyleWrapper> themesRaw) { List<String> themes = new ArrayList<String>(themesRaw.size()); for (ThemeEditorStyle theme : themesRaw) { themes.add(theme.getName()); } Collections.sort(themes); return themes; } private boolean hasExt(PackExt ext) { return (extensions & ext.getBit()) != 0; } // Case statement removed for brevity case EVENT_IFACE_SERVING_STATE_INACTIVE: { TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj; if (VDBG) { Log.d(TAG, "Tether Mode unrequested by " + who); } handleInterfaceServingStateInactive(who); if (mNotifyList.isEmpty()) { turnOffMasterTetherSettings(); } else { if (DBG) { Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:"); for (TetherInterfaceStateMachine o : mNotifyList) { // Code inside the for loop } } } }

sample: 638
buggy_code:  // /// CHECK-START: int Main.getSum21() instruction_simplifier$after_bce (after) /// CHECK-DAG: <<Int:i\d+>> IntConstant 21 loop:none /// CHECK-DAG: Return [<<Int>>] loop:none private static int getSum21() { int k = 0; int sum = 0; for (int i = 0; i < 6; i++) { k++; sum += k; } return sum; } <|startfocus|> // Ensure double induction does not "overshoot". <|endfocus|> private static int getIncr2(int[] arr) { for (int i = 0; i < 12; ) { arr[i++] = 30; arr[i++] = 29; } int sum = 0; for (int i = 0; i < 12; i++) { sum += arr[i]; } return sum; } // TODO: handle as closed/empty eventually? static int mainIndexReturnedN(int n) { int i; for (i = 0; i < n; i++); return i; }
code_review:  Maybe add some context what that means? 
target code: // /// CHECK-START: int Main.getSum21() instruction_simplifier$after_bce (after) /// CHECK-DAG: <<Int:i\d+>> IntConstant 21 loop:none /// CHECK-DAG: Return [<<Int>>] loop:none private static int getSum21() { int k = 0; int sum = 0; for (int i = 0; i < 6; i++) { k++; sum += k; } return sum; } // Ensure double induction does not "overshoot" the subscript range. private static int getIncr2(int[] arr) { for (int i = 0; i < 12; ) { arr[i++] = 30; arr[i++] = 29; } int sum = 0; for (int i = 0; i < 12; i++) { sum += arr[i]; } return sum; } // TODO: handle as closed/empty eventually? static int mainIndexReturnedN(int n) { int i; for (i = 0; i < n; i++); return i; }
response: // Buggy Code private static int getSum21() { int k = 0; int sum = 0; for (int i = 0; i < 6; i++) { k++; sum += k; } return sum; } // Review: Ensure double induction does not "overshoot". private static int getIncr2(int[] arr) { for (int i = 0; i < 12; ) { arr[i++] = 30; arr[i++] = 29; } int sum = 0; for (int i = 0; i < 12; i++) { sum += arr[i]; } return sum; } // TODO: handle as closed/empty eventually? static int mainIndexReturnedN(int n) { int i; for (i = 0; i < n; i++); return i; }

sample: 639
buggy_code:  // To account correctly for on-the-wire traffic, add the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface == null || !entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) { continue; } <|startfocus|> synchronized (sStackedIfaces) { if (!sStackedIfaces.containsKey(entry.iface)) { continue; } } <|endfocus|> entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA; entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA; entry.rxPackets = 0; entry.txPackets = 0; stats.combineValues(entry); } return stats; } private NetworkStats readNetworkStatsDetailInternal(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException { if (USE_NATIVE_PARSING) { final NetworkStats stats; if (lastStats != null) { stats = lastStats; stats.setElapsedRealtime(SystemClock.elapsedRealtime()); } else {
code_review:  Ouch. Should we just move this into the preceding synchronized block? 
target code: // To account correctly for on-the-wire traffic, add the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface == null || !entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) { continue; } entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA; entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA; entry.rxPackets = 0; entry.txPackets = 0; stats.combineValues(entry); } return stats; } private NetworkStats readNetworkStatsDetailInternal(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException { if (USE_NATIVE_PARSING) { final NetworkStats stats; if (lastStats != null) { stats = lastStats; stats.setElapsedRealtime(SystemClock.elapsedRealtime()); } else {
response: // To account correctly for on-the-wire traffic, add the 20 additional bytes difference // for all packets (http://b/12249687, http:/b/33681750). for (int i = 0; i < stats.size(); i++) { entry = stats.getValues(i, entry); if (entry.iface == null || !entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) { continue; } synchronized (sStackedIfaces) { if (!sStackedIfaces.containsKey(entry.iface)) { continue; } } entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA; entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA; entry.rxPackets = 0; entry.txPackets = 0; stats.combineValues(entry); } return stats; private NetworkStats readNetworkStatsDetailInternal(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException { if (USE_NATIVE_PARSING) { final NetworkStats stats; if (lastStats != null) { stats = lastStats; stats.setElapsedRealtime(SystemClock.elapsedRealtime()); } else { stats = new NetworkStats(SystemClock.elapsedRealtime(), 0); } synchronized (sStackedIfaces) { // Native parsing implementation } return stats; } else { // Java parsing implementation } }

sample: 640
buggy_code:  // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); <|startfocus|> final String baseIface = sStackedIfaces.valueAt(i); <|endfocus|> NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets;
code_review:  For safety, can/should we also check that stackedIface.startsWith(CLATD_INTERFACE_PREFIX) ? 
target code: // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); if (!stackedIface.startsWith(CLATD_INTERFACE_PREFIX)) { continue; } NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets;
response: // base interface. For correct stats accounting on the base interface, every 464xlat // packets needs to be subtracted for the root UID on the base interface both for tx // and rx traffic (http://b/12249687, http:/b/33681750). final int size = sStackedIfaces.size(); for (int i = 0; i < size; i++) { final String stackedIface = sStackedIfaces.keyAt(i); final String baseIface = sStackedIfaces.valueAt(i); if (stackedIface.startsWith(CLATD_INTERFACE_PREFIX)) { NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0L, 0L, 0L, 0L, 0L); for (int j = 0; j < stats.size(); j++) { entry = stats.getValues(j, entry); if (Objects.equals(entry.iface, stackedIface)) { adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); adjust.rxPackets -= entry.rxPackets; adjust.txPackets -= entry.txPackets; } } } }

sample: 641
buggy_code:  assertStatsEntry(stats, "lo", 0, SET_DEFAULT, 0x0, 1288L, 1288L); NetworkStatsFactory.noteStackedIface("v4-wlan0", null); } public void testDoubleClatAccounting100MBDownload() throws Exception { // Downloading 100mb from an ipv4 only destination in a foreground activity long appRxBytesBefore = 328684029L; long appRxBytesAfter = 439237478L; <|startfocus|> assertEquals("App traffix should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); <|endfocus|> long rootRxBytesBefore = 1394011L; long rootRxBytesAfter = 1398634L; assertEquals("Root traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); NetworkStatsFactory.noteStackedIface("v4-wlan0", "wlan0"); NetworkStats stats; // Stats snapshot before the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_before); assertStatsEntry(stats, "v4-wlan0", 10106, SET_FOREGROUND, 0x0, appRxBytesBefore, 5199872L); assertStatsEntry(stats, "wlan0", 0, SET_DEFAULT, 0x0, rootRxBytesBefore, 647888L); 
code_review:  Nit: traffic 
target code: assertStatsEntry(stats, "lo", 0, SET_DEFAULT, 0x0, 1288L, 1288L); NetworkStatsFactory.noteStackedIface("v4-wlan0", null); } public void testDoubleClatAccounting100MBDownload() throws Exception { // Downloading 100mb from an ipv4 only destination in a foreground activity long appRxBytesBefore = 328684029L; long appRxBytesAfter = 439237478L; assertEquals("App traffic should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); long rootRxBytesBefore = 1394011L; long rootRxBytesAfter = 1398634L; assertEquals("Root traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); NetworkStatsFactory.noteStackedIface("v4-wlan0", "wlan0"); NetworkStats stats; // Stats snapshot before the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_before); assertStatsEntry(stats, "v4-wlan0", 10106, SET_FOREGROUND, 0x0, appRxBytesBefore, 5199872L); assertStatsEntry(stats, "wlan0", 0, SET_DEFAULT, 0x0, rootRxBytesBefore, 647888L);
response: assertStatsEntry(stats, "lo", 0, SET_DEFAULT, 0x0, 1288L, 1288L); NetworkStatsFactory.noteStackedIface("v4-wlan0", null); } public void testDoubleClatAccounting100MBDownload() throws Exception { // Downloading 100mb from an ipv4 only destination in a foreground activity long appRxBytesBefore = 328684029L; long appRxBytesAfter = 439237478L; assertEquals("App traffic should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); long rootRxBytesBefore = 1394011L; long rootRxBytesAfter = 1398634L; assertEquals("Root traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); NetworkStatsFactory.noteStackedIface("v4-wlan0", "wlan0"); NetworkStats stats; // Stats snapshot before the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_before); assertStatsEntry(stats, "v4-wlan0", 10106, SET_FOREGROUND, 0x0, appRxBytesBefore, 5199872L); assertStatsEntry(stats, "wlan0", 0, SET_DEFAULT, 0x0, rootRxBytesBefore, 647888L); }

sample: 642
buggy_code:  } public void testDoubleClatAccounting100MBDownload() throws Exception { // Downloading 100mb from an ipv4 only destination in a foreground activity long appRxBytesBefore = 328684029L; long appRxBytesAfter = 439237478L; assertEquals("App traffix should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); long rootRxBytesBefore = 1394011L; long rootRxBytesAfter = 1398634L; <|startfocus|> assertEquals("Root traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); <|endfocus|> NetworkStatsFactory.noteStackedIface("v4-wlan0", "wlan0"); NetworkStats stats; // Stats snapshot before the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_before); assertStatsEntry(stats, "v4-wlan0", 10106, SET_FOREGROUND, 0x0, appRxBytesBefore, 5199872L); assertStatsEntry(stats, "wlan0", 0, SET_DEFAULT, 0x0, rootRxBytesBefore, 647888L); // Stats snapshot after the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_after);
code_review:  Nit: UID 0 
target code: } public void testDoubleClatAccounting100MBDownload() throws Exception { // Downloading 100mb from an ipv4 only destination in a foreground activity long appRxBytesBefore = 328684029L; long appRxBytesAfter = 439237478L; assertEquals("App traffix should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); long rootRxBytesBefore = 1394011L; long rootRxBytesAfter = 1398634L; assertEquals("UID 0 traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); NetworkStatsFactory.noteStackedIface("v4-wlan0", "wlan0"); NetworkStats stats; // Stats snapshot before the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_before); assertStatsEntry(stats, "v4-wlan0", 10106, SET_FOREGROUND, 0x0, appRxBytesBefore, 5199872L); assertStatsEntry(stats, "wlan0", 0, SET_DEFAULT, 0x0, rootRxBytesBefore, 647888L); // Stats snapshot after the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_after);
response: public void testDoubleClatAccounting100MBDownload() throws Exception { // Downloading 100mb from an ipv4 only destination in a foreground activity long appRxBytesBefore = 328684029L; long appRxBytesAfter = 439237478L; assertEquals("App traffic should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); long rootRxBytesBefore = 1394011L; long rootRxBytesAfter = 1398634L; assertEquals("Root traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); NetworkStatsFactory.noteStackedIface("v4-wlan0", "wlan0"); NetworkStats stats; // Stats snapshot before the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_before); assertStatsEntry(stats, "v4-wlan0", 10106, SET_FOREGROUND, 0x0, appRxBytesBefore, 5199872L); assertStatsEntry(stats, "wlan0", 0, SET_DEFAULT, 0x0, rootRxBytesBefore, 647888L); // Stats snapshot after the download stats = parseDetailedStats(R.raw.xt_qtaguid_with_clat_100mb_download_after); }

sample: 643
buggy_code:  public void onConnected() { Log.d(TAG, "BrowsablePlayerListBuilder: " + mCurrentPlayer.packageName + " OK"); mCurrentBrowser.disconnect(); mCurrentBrowser = null; mBrowsePlayerInfoList.add(mCurrentPlayer); MediaPlayerInfo info = getMediaPlayerInfo(mCurrentPlayer.packageName); <|startfocus|> MediaController controller = info == null ? null : info.getMediaController(); <|endfocus|> // Refresh the media player entry so it notices we can browse if (controller != null) { addMediaPlayerController(controller.getWrappedInstance()); } else { addMediaPlayerPackage(mCurrentPlayer.packageName); } mPlayersChanged = true; connectNextPlayer();
code_review:  For readability, I'd prefer the conditional to be in brackets; e.g. controller = (info == null) ? ... 
target code: public void onConnected() { Log.d(TAG, "BrowsablePlayerListBuilder: " + mCurrentPlayer.packageName + " OK"); mCurrentBrowser.disconnect(); mCurrentBrowser = null; mBrowsePlayerInfoList.add(mCurrentPlayer); MediaPlayerInfo info = getMediaPlayerInfo(mCurrentPlayer.packageName); MediaController controller = (info == null) ? null : info.getMediaController(); // Refresh the media player entry so it notices we can browse if (controller != null) { addMediaPlayerController(controller.getWrappedInstance()); } else { addMediaPlayerPackage(mCurrentPlayer.packageName); } mPlayersChanged = true; connectNextPlayer();
response: public void onConnected() { Log.d(TAG, "BrowsablePlayerListBuilder: " + mCurrentPlayer.packageName + " OK"); mCurrentBrowser.disconnect(); mCurrentBrowser = null; mBrowsePlayerInfoList.add(mCurrentPlayer); MediaPlayerInfo info = getMediaPlayerInfo(mCurrentPlayer.packageName); MediaController controller = (info == null) ? null : info.getMediaController(); // Refresh the media player entry so it notices we can browse if (controller != null) { addMediaPlayerController(controller.getWrappedInstance()); } else { addMediaPlayerPackage(mCurrentPlayer.packageName); } mPlayersChanged = true; connectNextPlayer(); }

sample: 644
buggy_code:  } shr32(); for (int i = 0; i < 128; i++) { expectEquals(0x3fffffff, a[i], "shr32"); } shr33(); for (int i = 0; i < 128; i++) { expectEquals(0x1fffffff, a[i], "shr33"); } shrMinus254(); for (int i = 0; i < 128; i++) { <|startfocus|> expectEquals(0x07ffffff, a[i], "shrMinus255"); <|endfocus|> } // Bit-wise not operator. not(); for (int i = 0; i < 128; i++) { expectEquals(0xf8000000, a[i], "not"); } // Done. System.out.println("passed");
code_review:  254 
target code: } shr32(); for (int i = 0; i < 128; i++) { expectEquals(0x3fffffff, a[i], "shr32"); } shr33(); for (int i = 0; i < 128; i++) { expectEquals(0x1fffffff, a[i], "shr33"); } shrMinus254(); for (int i = 0; i < 128; i++) { expectEquals(0x07ffffff, a[i], "shrMinus254"); } // Bit-wise not operator. not(); for (int i = 0; i < 128; i++) { expectEquals(0xf8000000, a[i], "not"); } // Done. System.out.println("passed");
response: } shr32(); for (int i = 0; i < 128; i++) { expectEquals(0x3fffffff, a[i], "shr32"); } shr33(); for (int i = 0; i < 128; i++) { expectEquals(0x1fffffff, a[i], "shr33"); } shrMinus255(); for (int i = 0; i < 128; i++) { expectEquals(0x07ffffff, a[i], "shrMinus255"); } // Bit-wise not operator. not(); for (int i = 0; i < 128; i++) { expectEquals(0xf8000000, a[i], "not"); } // Done. System.out.println("passed");

sample: 645
buggy_code:  } shr64(); for (int i = 0; i < 128; i++) { expectEquals(0x3fffffffffffffffL, a[i], "shr64"); } shr65(); for (int i = 0; i < 128; i++) { expectEquals(0x1fffffffffffffffL, a[i], "shr65"); } shrMinus254(); for (int i = 0; i < 128; i++) { <|startfocus|> expectEquals(0x07ffffffffffffffL, a[i], "shr65"); <|endfocus|> } // Bit-wise not operator. not(); for (int i = 0; i < 128; i++) { expectEquals(0xf800000000000000L, a[i], "not"); } // Done. System.out.println("passed");
code_review:  Minus254 
target code: } shr64(); for (int i = 0; i < 128; i++) { expectEquals(0x3fffffffffffffffL, a[i], "shr64"); } shr65(); for (int i = 0; i < 128; i++) { expectEquals(0x1fffffffffffffffL, a[i], "shr65"); } shrMinus254(); for (int i = 0; i < 128; i++) { expectEquals(0x07ffffffffffffffL, a[i], "shrMinus254"); } // Bit-wise not operator. not(); for (int i = 0; i < 128; i++) { expectEquals(0xf800000000000000L, a[i], "not"); } // Done. System.out.println("passed");
response: } shr64(); for (int i = 0; i < 128; i++) { expectEquals(0x3fffffffffffffffL, a[i], "shr64"); } shr65(); for (int i = 0; i < 128; i++) { expectEquals(0x1fffffffffffffffL, a[i], "shr65"); } shrMinus254(); for (int i = 0; i < 128; i++) { expectEquals(0x07ffffffffffffffL, a[i], "shr65"); } // Bit-wise not operator. not(); for (int i = 0; i < 128; i++) { expectEquals(0xf800000000000000L, a[i], "not"); } // Done. System.out.println("passed");

sample: 646
buggy_code:  */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_REPORT = "android.bluetooth.input.profile.action.REPORT"; /** * @hide */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.input.profile.action.VIRTUAL_UNPLUG_STATUS"; /** * @hide */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_IDLE_TIME_CHANGED = <|startfocus|> "codeaurora.bluetooth.input.profile.action.IDLE_TIME_CHANGED"; <|endfocus|> /** * Return codes for the connect and disconnect Bluez / Dbus calls. * @hide */ public static final int INPUT_DISCONNECT_FAILED_NOT_CONNECTED = 5000; /** * @hide */ public static final int INPUT_CONNECT_FAILED_ALREADY_CONNECTED = 5001; /** * @hide */ public static final int INPUT_CONNECT_FAILED_ATTEMPT_FAILED = 5002; /** * @hide */ public static final int INPUT_OPERATION_GENERIC_FAILURE = 5003; /** * @hide */
code_review:  android 
target code: */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_REPORT = "android.bluetooth.input.profile.action.REPORT"; /** * @hide */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.input.profile.action.VIRTUAL_UNPLUG_STATUS"; /** * @hide */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_IDLE_TIME_CHANGED = "android.bluetooth.input.profile.action.IDLE_TIME_CHANGED"; /** * Return codes for the connect and disconnect Bluez / Dbus calls. * @hide */ public static final int INPUT_DISCONNECT_FAILED_NOT_CONNECTED = 5000; /** * @hide */ public static final int INPUT_CONNECT_FAILED_ALREADY_CONNECTED = 5001; /** * @hide */ public static final int INPUT_CONNECT_FAILED_ATTEMPT_FAILED = 5002; /** * @hide */ public static final int INPUT_OPERATION_GENERIC_FAILURE = 5003; /** * @hide */
response: @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_REPORT = "android.bluetooth.input.profile.action.REPORT"; @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.input.profile.action.VIRTUAL_UNPLUG_STATUS"; @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String ACTION_IDLE_TIME_CHANGED = "codeaurora.bluetooth.input.profile.action.IDLE_TIME_CHANGED"; public static final int INPUT_DISCONNECT_FAILED_NOT_CONNECTED = 5000; public static final int INPUT_CONNECT_FAILED_ALREADY_CONNECTED = 5001; public static final int INPUT_CONNECT_FAILED_ATTEMPT_FAILED = 5002; public static final int INPUT_OPERATION_GENERIC_FAILURE = 5003;

sample: 647
buggy_code:  /** * @hide */ public static final String EXTRA_REPORT = "android.bluetooth.BluetoothInputDevice.extra.REPORT"; /** * @hide */ public static final String EXTRA_STATUS = "android.bluetooth.BluetoothInputDevice.extra.STATUS"; /** * @hide */ public static final String EXTRA_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.BluetoothInputDevice.extra.VIRTUAL_UNPLUG_STATUS"; /** * @hide */ <|startfocus|> public static final String EXTRA_IDLE_TIME = "codeaurora.bluetooth.BluetoothInputDevice.extra.IDLE_TIME"; <|endfocus|> private Context mContext; private ServiceListener mServiceListener; private BluetoothAdapter mAdapter; private IBluetoothInputDevice mService; final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback = new IBluetoothStateChangeCallback.Stub() { public void onBluetoothStateChange(boolean up) { if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up); if (!up) { if (VDBG) Log.d(TAG,"Unbinding service..."); synchronized (mConnection) { try { mService = null; mContext.unbindService(mConnection);
code_review:  android 
target code: /** * @hide */ public static final String EXTRA_REPORT = "android.bluetooth.BluetoothInputDevice.extra.REPORT"; /** * @hide */ public static final String EXTRA_STATUS = "android.bluetooth.BluetoothInputDevice.extra.STATUS"; /** * @hide */ public static final String EXTRA_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.BluetoothInputDevice.extra.VIRTUAL_UNPLUG_STATUS"; /** * @hide */ public static final String EXTRA_IDLE_TIME = "android.bluetooth.BluetoothInputDevice.extra.IDLE_TIME"; private Context mContext; private ServiceListener mServiceListener; private BluetoothAdapter mAdapter; private IBluetoothInputDevice mService; final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback = new IBluetoothStateChangeCallback.Stub() { public void onBluetoothStateChange(boolean up) { if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up); if (!up) { if (VDBG) Log.d(TAG,"Unbinding service..."); synchronized (mConnection) { try { mService = null; mContext.unbindService(mConnection);
response: public static final String EXTRA_REPORT = "android.bluetooth.BluetoothInputDevice.extra.REPORT"; public static final String EXTRA_STATUS = "android.bluetooth.BluetoothInputDevice.extra.STATUS"; public static final String EXTRA_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.BluetoothInputDevice.extra.VIRTUAL_UNPLUG_STATUS"; public static final String EXTRA_IDLE_TIME = "codeaurora.bluetooth.BluetoothInputDevice.extra.IDLE_TIME"; private Context mContext; private ServiceListener mServiceListener; private BluetoothAdapter mAdapter; private IBluetoothInputDevice mService; final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback = new IBluetoothStateChangeCallback.Stub() { public void onBluetoothStateChange(boolean up) { if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up); if (!up) { if (VDBG) Log.d(TAG,"Unbinding service..."); synchronized (mConnection) { try { mService = null; mContext.unbindService(mConnection); // ... } catch (Exception e) { Log.e(TAG, "Unable to unbind service", e); } } } } };

sample: 648
buggy_code:  */ public boolean getEmergencyCallbackMode(int subId) { try { ITelephony telephony = getITelephony(); if (telephony == null) { return false; } return telephony.getEmergencyCallbackMode(subId); } catch (RemoteException e) { Log.e(TAG, "Error calling ITelephony#getEmergencyCallbackMode", e); } return false; } /** * Get the most recently available signal strength information. * <|startfocus|> * <p>Requires Permission: * {@link android.Manifest.permission#READ_PHONE_STATE} * <|endfocus|> * Get the most recent SignalStrength information reported by the modem. Due * to power saving this information may not always be current. * @return the most recent cached signal strength info from the modem * @hide */ @Nullable public SignalStrength getSignalStrength() { try { ITelephony service = getITelephony(); if (service != null) { return service.getSignalStrength(getSubId(), getOpPackageName()); } } catch (RemoteException e) {
code_review:  Looking at TelephonyRegistry it doesn't look like listening for SignalStrength requires a permission - we should mimic other accessors of SignalStrength in this regard. 
target code: */ public boolean getEmergencyCallbackMode(int subId) { try { ITelephony telephony = getITelephony(); if (telephony == null) { return false; } return telephony.getEmergencyCallbackMode(subId); } catch (RemoteException e) { Log.e(TAG, "Error calling ITelephony#getEmergencyCallbackMode", e); } return false; } /** * Get the most recently available signal strength information. * * Get the most recent SignalStrength information reported by the modem. Due * to power saving this information may not always be current. * @return the most recent cached signal strength info from the modem * @hide */ @Nullable public SignalStrength getSignalStrength() { try { ITelephony service = getITelephony(); if (service != null) { return service.getSignalStrength(getSubId(), getOpPackageName()); } } catch (RemoteException e) {
response: import android.os.RemoteException; import android.telephony.SignalStrength; public boolean getEmergencyCallbackMode(int subId) { try { ITelephony telephony = getITelephony(); if (telephony == null) { return false; } return telephony.getEmergencyCallbackMode(subId); } catch (RemoteException e) { Log.e(TAG, "Error calling ITelephony#getEmergencyCallbackMode", e); } return false; } @Nullable public SignalStrength getSignalStrength() { try { ITelephony service = getITelephony(); if (service != null) { return service.getSignalStrength(getSubId(), getOpPackageName()); } } catch (RemoteException e) { Log.e(TAG, "Error calling ITelephony#getSignalStrength", e); } return null; }

sample: 649
buggy_code:  * class. The testcase checks that no any unexpected ERROR is returned and that * the JSR45 metadata matches the expected value. */ public void testSourceDebugExtension001() { doTest("testSourceDebugExtension001", "Lorg/apache/harmony/jpda/tests/jdwp/Events/SourceDebugExtensionMockClass;", JDWPConstants.Error.NONE); } /** * This testcase exercises ReferenceType.SourceDebugExtension command. * * The class queried is a primitive type which on ART does not <|startfocus|> * have a DEX cache installed. <|endfocus|> */ public void testSourceDebugExtension002() { doTest("testSourceDebugExtension001", "I", JDWPConstants.Error.ABSENT_INFORMATION); } /** * This testcase exercises ReferenceType.SourceDebugExtension command. * * The class queried is a primitive array which on ART does not * have a DEX cache installed. */ public void testSourceDebugExtension003() { doTest("testSourceDebugExtension003", "[I", JDWPConstants.Error.ABSENT_INFORMATION); } /** * This testcase exercises ReferenceType.SourceDebugExtension command. *
code_review:  -> have an associated dex cache. (here and below). 
target code: * class. The testcase checks that no any unexpected ERROR is returned and that * the JSR45 metadata matches the expected value. */ public void testSourceDebugExtension001() { doTest("testSourceDebugExtension001", "Lorg/apache/harmony/jpda/tests/jdwp/Events/SourceDebugExtensionMockClass;", JDWPConstants.Error.NONE); } /** * This testcase exercises ReferenceType.SourceDebugExtension command. * * The class queried is a primitive type which on ART does not * have an associated DEX cache. */ public void testSourceDebugExtension002() { doTest("testSourceDebugExtension001", "I", JDWPConstants.Error.ABSENT_INFORMATION); } /** * This testcase exercises ReferenceType.SourceDebugExtension command. * * The class queried is a primitive array which on ART does not * have a DEX cache installed. */ public void testSourceDebugExtension003() { doTest("testSourceDebugExtension003", "[I", JDWPConstants.Error.ABSENT_INFORMATION); } /** * This testcase exercises ReferenceType.SourceDebugExtension command. *
response: public void testSourceDebugExtension001() { doTest("testSourceDebugExtension001", "Lorg/apache/harmony/jpda/tests/jdwp/Events/SourceDebugExtensionMockClass;", JDWPConstants.Error.NONE); } public void testSourceDebugExtension002() { doTest("testSourceDebugExtension001", "I", JDWPConstants.Error.ABSENT_INFORMATION); } public void testSourceDebugExtension003() { doTest("testSourceDebugExtension003", "[I", JDWPConstants.Error.ABSENT_INFORMATION); } public void testSourceDebugExtension004() { doTest("testSourceDebugExtension004", "[Ljava/lang/String;", JDWPConstants.Error.ABSENT_INFORMATION); } public void testSourceDebugExtension005() { doTest("testSourceDebugExtension005", "[[Ljava/lang/String;", JDWPConstants.Error.ABSENT_INFORMATION); }

sample: 650
buggy_code:  * the server name from the certificate mismatch. */ defaultHostnameVerifier = (HostnameVerifier) Class.forName("com.android.okhttp.internal.tls.OkHostnameVerifier") .getField("INSTANCE").get(null); originalDefaultHostnameVerifierClass = defaultHostnameVerifier.getClass(); } catch (Exception e) { throw new AssertionError("Failed to obtain okhttp HostnameVerifier", e); } } } /** * The <code>hostnameVerifier</code> for this object. */ <|startfocus|> protected HostnameVerifier hostnameVerifier; <|endfocus|> /** * Sets the default <code>HostnameVerifier</code> inherited by a * new instance of this class. * <P> * If this method is not called, the default * <code>HostnameVerifier</code> assumes the connection should not * be permitted. * * @param v the default host name verifier * @throws IllegalArgumentException if the <code>HostnameVerifier</code> * parameter is null. * @throws SecurityException if a security manager exists and its * <code>checkPermission</code> method does not allow
code_review:  probably needs a change comment: // Android-change: lazy initialization of hostnameVerifier. or similar? 
target code: * the server name from the certificate mismatch. */ defaultHostnameVerifier = (HostnameVerifier) Class.forName("com.android.okhttp.internal.tls.OkHostnameVerifier") .getField("INSTANCE").get(null); originalDefaultHostnameVerifierClass = defaultHostnameVerifier.getClass(); } catch (Exception e) { throw new AssertionError("Failed to obtain okhttp HostnameVerifier", e); } } } /** * The <code>hostnameVerifier</code> for this object. */ protected HostnameVerifier hostnameVerifier; // END Android-changed: Use lazily-created OkHttp hostname verifier /** * Sets the default <code>HostnameVerifier</code> inherited by a * new instance of this class. * <P> * If this method is not called, the default * <code>HostnameVerifier</code> assumes the connection should not * be permitted. * * @param v the default host name verifier * @throws IllegalArgumentException if the <code>HostnameVerifier</code> * parameter is null. * @throws SecurityException if a security manager exists and its * <code>checkPermission</code> method does not allow
response: defaultHostnameVerifier = (HostnameVerifier) Class.forName("com.android.okhttp.internal.tls.OkHostnameVerifier") .getField("INSTANCE").get(null); originalDefaultHostnameVerifierClass = defaultHostnameVerifier.getClass(); } catch (Exception e) { throw new AssertionError("Failed to obtain okhttp HostnameVerifier", e); } } protected HostnameVerifier hostnameVerifier; public void setDefaultHostnameVerifier(HostnameVerifier v) { if (v == null) { throw new IllegalArgumentException("HostnameVerifier parameter is null"); } this.hostnameVerifier = v; } public HostnameVerifier getDefaultHostnameVerifier() { return this.hostnameVerifier; }

sample: 651
buggy_code:  // missing server, so no trusted time available return false; } // We can't do this at initialization time: ConnectivityService might not be running yet. synchronized (this) { if (mCM == null) { mCM = (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE); } } final NetworkInfo ni = mCM == null ? null : mCM.getActiveNetworkInfo(); <|startfocus|> if (ni == null || (ni != null && !ni.isConnected())) { <|endfocus|> if (LOGD) Log.d(TAG, "forceRefresh: no connectivity"); return false; } if (LOGD) Log.d(TAG, "forceRefresh() from cache miss"); final SntpClient client = new SntpClient(); if (client.requestTime(mServer, (int) mTimeout)) { mHasCache = true; mCachedNtpTime = client.getNtpTime(); mCachedNtpElapsedRealtime = client.getNtpTimeReference(); mCachedNtpCertainty = client.getRoundTripTime() / 2; return true; } else { return false; }
code_review:  This is redundant: If the right hand side of the '||' operator is evaluated, it is because ni != null. 
target code: // missing server, so no trusted time available return false; } // We can't do this at initialization time: ConnectivityService might not be running yet. synchronized (this) { if (mCM == null) { mCM = (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE); } } final NetworkInfo ni = mCM == null ? null : mCM.getActiveNetworkInfo(); if (ni == null || !ni.isConnected()) { if (LOGD) Log.d(TAG, "forceRefresh: no connectivity"); return false; } if (LOGD) Log.d(TAG, "forceRefresh() from cache miss"); final SntpClient client = new SntpClient(); if (client.requestTime(mServer, (int) mTimeout)) { mHasCache = true; mCachedNtpTime = client.getNtpTime(); mCachedNtpElapsedRealtime = client.getNtpTimeReference(); mCachedNtpCertainty = client.getRoundTripTime() / 2; return true; } else { return false; }
response: private boolean isNetworkConnected() { if (ni == null || !ni.isConnected()) { if (LOGD) Log.d(TAG, "forceRefresh: no connectivity"); return false; } return true; }

sample: 652
buggy_code:  private void onPollNetworkTime(int event) { // If Automatic time is not set, don't bother. <|startfocus|> final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || !netInfo.isConnected()) return; <|endfocus|> mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); }
code_review:  line too long 
target code: private void onPollNetworkTime(int event) { // If Automatic time is not set, don't bother. final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || (netInfo != null && !netInfo.isConnected())) return; mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); }
response: private void onPollNetworkTime(int event) { final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || !netInfo.isConnected()) return; mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); } }

sample: 653
buggy_code:  private void onPollNetworkTime(int event) { // If Automatic time is not set, don't bother. <|startfocus|> final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || !netInfo.isConnected()) return; <|endfocus|> mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); }
code_review:  Could you unfold this similarly to the original "if (!isAutomaticTimeRequested()) return;": if (!isAutomaticTimeRequested()) return; if (mConnManager == null) return; if (!mConnManager.getActiveNetworkInfo().isConnected()) return; This would prevent the bug where mConnManager is null, netInfo gets assigned to null on line 167, and netInfo.isConnected() throws a NPE on line 168. Also, getActiveNetworkInfo() is a binder call that needs to take a lock in the framework. It would be better if it is done after the early return from !isAutomaticTimeRequested(). 
target code: private void onPollNetworkTime(int event) { // If Automatic time is not set, don't bother. final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || (netInfo != null && !netInfo.isConnected())) return; mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); }
response: private void onPollNetworkTime(int event) { if (!isAutomaticTimeRequested()) { return; } if (mConnManager == null) { return; } final NetworkInfo netInfo = mConnManager.getActiveNetworkInfo(); if (netInfo == null || !netInfo.isConnected()) { return; } mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); } }

sample: 654
buggy_code:  * * You should have received a copy of the GNU General Public License version * 2 along with this work; if not, write to the Free Software Foundation, * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. */ package javax.security.auth; <|startfocus|> // Android-removed: This permission system is unavailable on Android <|endfocus|> /** * Legacy security code; do not use. */ public final class AuthPermission extends java.security.BasicPermission { public AuthPermission(String name) { super(""); } public AuthPermission(String name, String actions) { super("", ""); } } 
code_review:  What does "unavailable" mean? These classes exist, do you mean "nonfunctional"? (I think the term "legacy security code" is used elsewhere). When the change is not *purely* a removal, I personally prefer Android-changed. I also prefer a "." at the end, when there is space. But up to you. 
target code: * * You should have received a copy of the GNU General Public License version * 2 along with this work; if not, write to the Free Software Foundation, * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. */ package javax.security.auth; // Android-changed: We don't implement this permission system on Android. /** * Legacy security code; do not use. */ public final class AuthPermission extends java.security.BasicPermission { public AuthPermission(String name) { super(""); } public AuthPermission(String name, String actions) { super("", ""); } }
response: static void call(ChangeInfo changeInfo, RevisionInfo revisionInfo) { if (ChangeGlue.onSubmitChange(changeInfo, revisionInfo)) { final Change.Id changeId = changeInfo.legacy_id(); int j = revisionInfo.commit().other(); boolean flag = (j == 1) ? false : true; if (revisionInfo.commit().otherBranchCommit().equalsIgnoreCase("different branch commit")) { boolean reply = Window.confirm("You are about to merge change from a different branch.\n " + "Do you want to continue ?"); if (reply == true) { ChangeApi.submit(changeId.get(), revisionInfo.name(), new GerritCallback<SubmitInfo>() { public void onSuccess(SubmitInfo result) { redisplay(); } public void onFailure(Throwable err) { if (SubmitFailureDialog.isConflict(err)) { new SubmitFailureDialog(err.getMessage()).center(); } else { super.onFailure(err); } redisplay(); } private void redisplay() { Gerrit.display(PageLinks.toChange(changeId)); } }); } else { // Do something else } } } } public static void log(String message, IStatus status) { if (message != null) { getDefault().getLog().log(StatusUtil.newStatus(IStatus.ERROR, message, null)); } getDefault().getLog().log(status); } import org.eclipse.jgit.treewalk.EmptyTreeIterator; import org.eclipse.jgit.treewalk.TreeWalk; import org.eclipse.jgit.treewalk.filter.TreeFilter; public class StageBuilder { private static final int SMALL_BATCH_SIZE = 5; private static final byte[] PEEL = { ' ', '^' }; private final String txnStage; private final String txnId; public StageBuilder(String txnStageNamespace, ObjectId txnId) { // Constructor implementation } } package javax.security.auth; public final class AuthPermission extends java.security.BasicPermission { public AuthPermission(String name) { super(""); } public AuthPermission(String name, String actions) { super("", ""); } }

sample: 655
buggy_code:  public NetworkTimeUpdateService(Context context) { mContext = context; mTime = NtpTrustedTime.getInstance(context); mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE); <|startfocus|> mConnManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); <|endfocus|> Intent pollIntent = new Intent(ACTION_POLL, null); mPendingPollIntent = PendingIntent.getBroadcast(mContext, POLL_REQUEST, pollIntent, 0); mPollingIntervalMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpPollingInterval); mPollingIntervalShorterMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpPollingIntervalShorter); mTryAgainTimesMax = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpRetry); mTimeErrorThresholdMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpThreshold); mWakeLock = ((PowerManager) context.getSystemService(Context.POWER_SERVICE)).newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG);
code_review:  [nit] Okay with me to use a name like "mCM", if only to help avoid line length issues and line-wrapping. 
target code: public NetworkTimeUpdateService(Context context) { mContext = context; mTime = NtpTrustedTime.getInstance(context); mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE); mCM = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); Intent pollIntent = new Intent(ACTION_POLL, null); mPendingPollIntent = PendingIntent.getBroadcast(mContext, POLL_REQUEST, pollIntent, 0); mPollingIntervalMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpPollingInterval); mPollingIntervalShorterMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpPollingIntervalShorter); mTryAgainTimesMax = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpRetry); mTimeErrorThresholdMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpThreshold); mWakeLock = ((PowerManager) context.getSystemService(Context.POWER_SERVICE)).newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG);
response: public NetworkTimeUpdateService(Context context) { mContext = context; mTime = NtpTrustedTime.getInstance(context); mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE); mConnManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); Intent pollIntent = new Intent(ACTION_POLL, null); mPendingPollIntent = PendingIntent.getBroadcast(mContext, POLL_REQUEST, pollIntent, 0); mPollingIntervalMs = mContext.getResources().getInteger(com.android.internal.R.integer.config_ntpPollingInterval); mPollingIntervalShorterMs = mContext.getResources().getInteger(com.android.internal.R.integer.config_ntpPollingIntervalShorter); mTryAgainTimesMax = mContext.getResources().getInteger(com.android.internal.R.integer.config_ntpRetry); mTimeErrorThresholdMs = mContext.getResources().getInteger(com.android.internal.R.integer.config_ntpThreshold); mWakeLock = ((PowerManager) context.getSystemService(Context.POWER_SERVICE)).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG); }

sample: 656
buggy_code:  } } }; /** Handler to do the network accesses on */ private class MyHandler extends Handler { public MyHandler(Looper l) { super(l); } @Override public void handleMessage(Message msg) { switch (msg.what) { case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CHANGED: onPollNetworkTime(msg.what); break; } } } <|startfocus|> private class NetworkCallback extends ConnectivityManager.NetworkCallback{ <|endfocus|> @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)){ mNetworkValidated = true; }else { mNetworkValidated = false; } } } /** Observer to watch for changes to the AUTO_TIME setting */ private static class SettingsObserver extends ContentObserver { private int mMsg; private Handler mHandler; SettingsObserver(Handler handler, int msg) { super(handler); mHandler = handler; mMsg = msg; } void observe(Context context) {
code_review:  Might be better to call it something like NetworkTimeCallback or TimeServiceNetworkCallback, to avoid confusion with the same name of its base class. 
target code: } } }; /** Handler to do the network accesses on */ private class MyHandler extends Handler { public MyHandler(Looper l) { super(l); } @Override public void handleMessage(Message msg) { switch (msg.what) { case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CHANGED: onPollNetworkTime(msg.what); break; } } } private class NetworkTimeUpdateCallback extends ConnectivityManager.NetworkCallback { @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)){ mNetworkValidated = true; }else { mNetworkValidated = false; } } } /** Observer to watch for changes to the AUTO_TIME setting */ private static class SettingsObserver extends ContentObserver { private int mMsg; private Handler mHandler; SettingsObserver(Handler handler, int msg) { super(handler); mHandler = handler; mMsg = msg; } void observe(Context context) {
response: final public class CreateBranchCommand extends SshCommand { @Option(name = "--revision", aliases = {"-r"}, metaVar = "REVISION", usage = "base revision of the new branch") private String revision; @Argument(index = 0, required = true, metaVar = "PROJECT", usage = "name of the project") private ProjectControl project; @Argument(index = 1, required = true, metaVar = "NAME", usage = "name of branch to be created") private String name; @Inject GerritApi gApi; @Override protected void run() throws UnloggedFailure, Failure, Exception { BranchInput in = new BranchInput(); in.revision = revision; gApi.projects().name(project.getProject().getNameKey().get()).branch(name).create(in); } } InetAddress inetAddress; String hostName; hostName = "" + (0xff & hostAddress) + "." + (0xff & (hostAddress >> 8)) + "." + (0xff & (hostAddress >> 16)) + "." + (0xff & (hostAddress >> 24)); try { inetAddress = InetAddress.getByName(hostName); } catch (UnknownHostException e) { return null; } return inetAddress; } /** * Add a default route through the specified gateway. * @param interfaceName interface on which the route should be added * @param gw the IP address of the gateway to which the route is desired, * @param prefixLength specifies default or host route, value=32/128 for IPv4/IPv6 * host route respectively and value=0 for default IPv4/IPv6 route to a gateway. * @return {@code true} on success, {@code false} on failure */ public static boolean addRoute(String interfaceName, InetAddress gw, int prefixLength) { String dstStr; // Rest of the code } private class MyHandler extends Handler { public MyHandler(Looper l) { super(l); } @Override public void handleMessage(Message msg) { switch (msg.what) { case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CHANGED: onPollNetworkTime(msg.what); break; } } } private class NetworkTimeCallback extends ConnectivityManager.NetworkCallback { @Override public

sample: 657
buggy_code:  } } }; /** Handler to do the network accesses on */ private class MyHandler extends Handler { public MyHandler(Looper l) { super(l); } @Override public void handleMessage(Message msg) { switch (msg.what) { case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CHANGED: onPollNetworkTime(msg.what); break; } } } <|startfocus|> private class NetworkCallback extends ConnectivityManager.NetworkCallback{ <|endfocus|> @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)){ mNetworkValidated = true; }else { mNetworkValidated = false; } } } /** Observer to watch for changes to the AUTO_TIME setting */ private static class SettingsObserver extends ContentObserver { private int mMsg; private Handler mHandler; SettingsObserver(Handler handler, int msg) { super(handler); mHandler = handler; mMsg = msg; } void observe(Context context) {
code_review:  [nit] a space before { would be nice. 
target code: } } }; /** Handler to do the network accesses on */ private class MyHandler extends Handler { public MyHandler(Looper l) { super(l); } @Override public void handleMessage(Message msg) { switch (msg.what) { case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CHANGED: onPollNetworkTime(msg.what); break; } } } private class NetworkTimeUpdateCallback extends ConnectivityManager.NetworkCallback { @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)){ mNetworkValidated = true; }else { mNetworkValidated = false; } } } /** Observer to watch for changes to the AUTO_TIME setting */ private static class SettingsObserver extends ContentObserver { private int mMsg; private Handler mHandler; SettingsObserver(Handler handler, int msg) { super(handler); mHandler = handler; mMsg = msg; } void observe(Context context) {
response: import android.bluetooth.BluetoothDevice; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.net.ConnectivityManager; import android.net.Network; import android.net.NetworkCapabilities; import android.content.Context; import android.database.ContentObserver; import java.util.ArrayList; import java.util.List; import java.util.UUID; public class BluetoothGattService implements Parcelable { public static final int SERVICE_TYPE_PRIMARY = 0; public static final int SERVICE_TYPE_SECONDARY = 1; protected BluetoothDevice mDevice; protected UUID mUuid; protected int mInstanceId; protected int mServiceType; protected List<BluetoothGattCharacteristic> mCharacteristics; protected List<BluetoothGattService> mIncludedServices; public BluetoothGattService(UUID uuid, int instanceId, int serviceType) { mUuid = uuid; mInstanceId = instanceId; mServiceType = serviceType; mCharacteristics = new ArrayList<>(); mIncludedServices = new ArrayList<>(); } public BluetoothDevice getDevice() { return mDevice; } public UUID getUuid() { return mUuid; } public int getInstanceId() { return mInstanceId; } public int getServiceType() { return mServiceType; } public List<BluetoothGattCharacteristic> getCharacteristics() { return mCharacteristics; } public List<BluetoothGattService> getIncludedServices() { return mIncludedServices; } public void addCharacteristic(BluetoothGattCharacteristic characteristic) { mCharacteristics.add(characteristic); } public void addIncludedService(BluetoothGattService includedService) { mIncludedServices.add(includedService); } // Parcelable implementation // ... private class MyHandler extends Handler { public MyHandler(Looper l) { super(l); } @Override public void handleMessage(Message msg) { switch (msg.what) { case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CHANGED: onPollNetworkTime(msg.what); break; } } } private class NetworkCallback extends ConnectivityManager.NetworkCallback { @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)) { mNetworkValidated = true; } else { mNetwork

sample: 658
buggy_code:  public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)){ mNetworkValidated = true; }else { mNetworkValidated = false; } <|startfocus|> <|endfocus|>
code_review:  Could just be: mNetworkValidated = netCap.hasCapability(NET_...VALIDATED); 
target code: public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { if (networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)){ mNetworkValidated = true; }else { mNetworkValidated = false; } } @Override public void onLost(Network network) { mNetworkValidated = false; }
response: public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED); }

sample: 659
buggy_code:  private void onPollNetworkTime(int event) { // If Automatic time is not set, don't bother. final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); <|startfocus|> if (!isAutomaticTimeRequested() || <|endfocus|> netInfo == null || !netInfo.isConnected()) return; mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); }
code_review:  This is kind of the old way of doing things. I think a better way would be to have this class register a request to track the default network via CM.registerDefaultNetworkCallback(cb, mHandler). The callback could just update a volatile boolean "isConnected" for now whenever the network capabilities have NET_CAPABILITY_VALIDATED. 
target code: private void onPollNetworkTime(int event) { // If Automatic time is not set, don't bother. final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || netInfo == null || !netInfo.isConnected()) return; mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); }
response: private void onPollNetworkTime(int event) { final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || netInfo == null || !netInfo.isConnected()) { return; } mWakeLock.acquire(); try { onPollNetworkTimeUnderWakeLock(event); } finally { mWakeLock.release(); } }

sample: 660
buggy_code:  return; case INS_GET_LOCK: /* getLock(lockId, sendMetadata) */ resp = sendLockData(apdu, p1, p2); if (resp != 0) { sendResponseCode(apdu, resp); } return; case INS_SET_LOCK: /* setlock(index, val) { data } */ if (p1 >= (byte)locks.length) { sendResponseCode(apdu, (short)0x0100); return; } <|startfocus|> if (metadataLength == (short) 0) { resp = locks[p1].set(p2); sendResponseCode(apdu, resp); <|endfocus|> return; } resp = locks[p1].setWithMetadata(p2, metadata, (short) 0, metadataLength); // "Consume" the metadata. metadataLength = (short)0; sendResponseCode(apdu, resp); return; case INS_SET_PRODUCTION: /* setProduction(p1) */ if (globalState.setProduction(enable) == true) { resp = 0x0000; } else { resp = 0x0001; } sendResponseCode(apdu, resp); return; /* carrierLockTest() { testVector } */
code_review:  Just relying on this state might lead to problems, especially if there are errors which cause the meta data to be loaded but not consumed. Looks like p1 and p2 are already being used so maybe a new instruction to split the meta/no-meta locks? It still requires locks with meta data to "use it right" but I'm not sure what the potential cost of that might be. 
target code: return; case INS_GET_LOCK: /* getLock(lockId, sendMetadata) */ resp = sendLockData(apdu, p1, p2); if (resp != 0) { sendResponseCode(apdu, resp); } return; case INS_SET_LOCK: /* setlock(index, val) { data } */ if (p1 >= (byte)locks.length) { sendResponseCode(apdu, (short)0x0100); return; } // useMetadata argument byte is required. if (numBytes != 1) { sendResponseCode(apdu, (short)0x0200); return; } resp = locks[p1].setWithMetadata(p2, metadata, (short) 0, metadataLength); // "Consume" the metadata. metadataLength = (short)0; sendResponseCode(apdu, resp); return; case INS_SET_PRODUCTION: /* setProduction(p1) */ if (globalState.setProduction(enable) == true) { resp = 0x0000; } else { resp = 0x0001; } sendResponseCode(apdu, resp); return; /* carrierLockTest() { testVector } */
response: return; case INS_GET_LOCK: resp = sendLockData(apdu, p1, p2); if (resp != 0) { sendResponseCode(apdu, resp); } return; case INS_SET_LOCK: if (p1 >= (byte)locks.length) { sendResponseCode(apdu, (short)0x0100); return; } if (metadataLength == (short) 0) { resp = locks[p1].set(p2); sendResponseCode(apdu, resp); } else { resp = locks[p1].setWithMetadata(p2, metadata, (short) 0, metadataLength); metadataLength = (short)0; sendResponseCode(apdu, resp); } return; case INS_SET_PRODUCTION: if (globalState.setProduction(enable) == true) { resp = 0x0000; } else { resp = 0x0001; } sendResponseCode(apdu, resp); return; /* carrierLockTest() { testVector } */

sample: 661
buggy_code: import android.widget.TextView; import java.io.IOException; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.lang.InterruptedException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.Random; public class CaptivePortalLoginActivity extends Activity { private static final String TAG = CaptivePortalLoginActivity.class.getSimpleName(); private static final boolean DBG = true; <|startfocus|> // Turn this flag on to desactivate auto-closing after successful captive portal login. private static final boolean NO_AUTOCLOSE = false; <|endfocus|> private static final int SOCKET_TIMEOUT_MS = 10000; private enum Result { DISMISSED, UNWANTED, WANTED_AS_IS }; private URL mUrl; private String mUserAgent; private Network mNetwork; private CaptivePortal mCaptivePortal; private NetworkCallback mNetworkCallback; private ConnectivityManager mCm; private boolean mLaunchBrowser = false; private MyWebViewClient mWebViewClient; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mCm = ConnectivityManager.from(this);
code_review:  deactivate? 
target code: import android.widget.TextView; import java.io.IOException; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.lang.InterruptedException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.Random; public class CaptivePortalLoginActivity extends Activity { private static final String TAG = CaptivePortalLoginActivity.class.getSimpleName(); private static final boolean DBG = true; private static final int SOCKET_TIMEOUT_MS = 10000; private enum Result { DISMISSED, UNWANTED, WANTED_AS_IS }; private URL mUrl; private String mUserAgent; private Network mNetwork; private CaptivePortal mCaptivePortal; private NetworkCallback mNetworkCallback; private ConnectivityManager mCm; private boolean mLaunchBrowser = false; private MyWebViewClient mWebViewClient; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mCm = ConnectivityManager.from(this);
response: import android.widget.TextView; import java.io.IOException; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.lang.InterruptedException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.Random; public class CaptivePortalLoginActivity extends Activity { private static final String TAG = CaptivePortalLoginActivity.class.getSimpleName(); private static final boolean DBG = true; private static final boolean NO_AUTOCLOSE = false; private static final int SOCKET_TIMEOUT_MS = 10000; private enum Result { DISMISSED, UNWANTED, WANTED_AS_IS }; private URL mUrl; private String mUserAgent; private Network mNetwork; private CaptivePortal mCaptivePortal; private NetworkCallback mNetworkCallback; private ConnectivityManager mCm; private boolean mLaunchBrowser = false; private MyWebViewClient mWebViewClient; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mCm = ConnectivityManager.from(this); } private void deactivate() { // Code to deactivate } }

sample: 662
buggy_code:  private void testForCaptivePortal() { <|startfocus|> if (NO_AUTOCLOSE) { return; } <|endfocus|> // TODO: reuse NetworkMonitor facilities for consistent captive portal detection. new Thread(new Runnable() { public void run() { // Give time for captive portal to open. try { Thread.sleep(1000); } catch (InterruptedException e) { } HttpURLConnection urlConnection = null; int httpResponseCode = 500; try { urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl); urlConnection.setInstanceFollowRedirects(false); urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS); urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS); urlConnection.setUseCaches(false); if (mUserAgent != null) { urlConnection.setRequestProperty("User-Agent", mUserAgent); } // cannot read request header after connection String requestHeader = urlConnection.getRequestProperties().toString(); urlConnection.getInputStream(); httpResponseCode = urlConnection.getResponseCode(); if (DBG) { Log.d(TAG, "probe at " + mUrl +
code_review:  Does this belong here or at the end of done()? I would seem to me, with only a cursory glance, that it might be better with: done(...) { if (!NO_AUTOCLOSE) { finishAndRemoveTask(); } } maybe? 
target code: private void testForCaptivePortal() { // TODO: reuse NetworkMonitor facilities for consistent captive portal detection. new Thread(new Runnable() { public void run() { // Give time for captive portal to open. try { Thread.sleep(1000); } catch (InterruptedException e) { } HttpURLConnection urlConnection = null; int httpResponseCode = 500; try { urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl); urlConnection.setInstanceFollowRedirects(false); urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS); urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS); urlConnection.setUseCaches(false); if (mUserAgent != null) { urlConnection.setRequestProperty("User-Agent", mUserAgent); } // cannot read request header after connection String requestHeader = urlConnection.getRequestProperties().toString(); urlConnection.getInputStream(); httpResponseCode = urlConnection.getResponseCode(); if (DBG) { Log.d(TAG, "probe at " + mUrl +
response: private void testForCaptivePortal() { if (NO_AUTOCLOSE) { return; } new Thread(new Runnable() { public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { } HttpURLConnection urlConnection = null; int httpResponseCode = 500; try { urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl); urlConnection.setInstanceFollowRedirects(false); urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS); urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS); urlConnection.setUseCaches(false); if (mUserAgent != null) { urlConnection.setRequestProperty("User-Agent", mUserAgent); } String requestHeader = urlConnection.getRequestProperties().toString(); urlConnection.getInputStream(); httpResponseCode = urlConnection.getResponseCode(); if (DBG) { Log.d(TAG, "probe at " + mUrl + " returns " + httpResponseCode); } } catch (IOException e) { if (DBG) { Log.d(TAG, "IOException - portal probably not detected"); } } finally { if (urlConnection != null) { urlConnection.disconnect(); } done(httpResponseCode); } } }).start(); }

sample: 663
buggy_code:  public void systemRunning() { registerForTelephonyIntents(); registerForAlarms(); HandlerThread thread = new HandlerThread(TAG); thread.start(); mHandler = new MyHandler(thread.getLooper()); mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback(); mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler); <|startfocus|> // Check the network time on the new thread mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget(); <|endfocus|> mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED); mSettingsObserver.observe(mContext);
code_review:  onPollNetworkTime will be call when network available, so we think that the line is useless. @Erik 
target code: public void systemRunning() { registerForTelephonyIntents(); registerForAlarms(); HandlerThread thread = new HandlerThread(TAG); thread.start(); mHandler = new MyHandler(thread.getLooper()); mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback(); mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler); mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED); mSettingsObserver.observe(mContext);
response: public void systemRunning() { registerForTelephonyIntents(); registerForAlarms(); HandlerThread thread = new HandlerThread(TAG); thread.start(); mHandler = new MyHandler(thread.getLooper()); mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback(); mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler); mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED); mSettingsObserver.observe(mContext); }

sample: 664
buggy_code: <|startfocus|> public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability( <|endfocus|> NetworkCapabilities.NET_CAPABILITY_VALIDATED);
code_review:  "netCap" makes this line shorter. 
target code: public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { mNetworkValidated = netCap.hasCapability( NetworkCapabilities.NET_CAPABILITY_VALIDATED);
response: public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED); }

sample: 665
buggy_code: <|startfocus|> public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability( <|endfocus|> NetworkCapabilities.NET_CAPABILITY_VALIDATED);
code_review:  import android.net.Network; 
target code: public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { mNetworkValidated = netCap.hasCapability( NetworkCapabilities.NET_CAPABILITY_VALIDATED);
response: import android.net.Network; public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED); }

sample: 666
buggy_code: <|startfocus|> public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability( <|endfocus|> NetworkCapabilities.NET_CAPABILITY_VALIDATED);
code_review:  import android.net.NetworkCapabilities; 
target code: public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { mNetworkValidated = netCap.hasCapability( NetworkCapabilities.NET_CAPABILITY_VALIDATED);
response: import android.net.NetworkCapabilities; public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED); }

sample: 667
buggy_code:  /// CHECK-DAG: <<Get2:b\d+>> ArrayGet loop:<<Loop>> outer_loop:none /// CHECK-DAG: <<Max:i\d+>> InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none /// CHECK-DAG: <<Cnv:b\d+>> TypeConversion [<<Max>>] loop:<<Loop>> outer_loop:none /// CHECK-DAG: ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>> outer_loop:none // <|startfocus|> // TODO: narrow type vectorization. <|endfocus|> private static void doitMax(byte[] x, byte[] y, byte[] z) { int min = Math.min(x.length, Math.min(y.length, z.length)); for (int i = 0; i < min; i++) { x[i] = (byte) Math.max(y[i], z[i]); } } public static void main(String[] args) { // Initialize cross-values for the interesting values. int total = 256 * 256; byte[] x = new byte[total];
code_review:  Why aren't there loop_optimization after cases? Why aren't there disassembly after cases? It's neither checking for vector HIR nor SIMD instructions actually being emitted. Am I misunderstanding something? (Here and in all the other test files) 
target code: /// CHECK-DAG: <<Get2:b\d+>> ArrayGet loop:<<Loop>> outer_loop:none /// CHECK-DAG: <<Max:i\d+>> InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none /// CHECK-DAG: <<Cnv:b\d+>> TypeConversion [<<Max>>] loop:<<Loop>> outer_loop:none /// CHECK-DAG: ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>> outer_loop:none // // TODO: narrow type vectorization. /// CHECK-START: void Main.doitMax(byte[], byte[], byte[]) loop_optimization (after) /// CHECK-NOT: VecMax private static void doitMax(byte[] x, byte[] y, byte[] z) { int min = Math.min(x.length, Math.min(y.length, z.length)); for (int i = 0; i < min; i++) { x[i] = (byte) Math.max(y[i], z[i]); } } public static void main(String[] args) { // Initialize cross-values for the interesting values. int total = 256 * 256; byte[] x = new byte[total];
response: private static void doitMax(byte[] x, byte[] y, byte[] z) { int min = Math.min(x.length, Math.min(y.length, z.length)); for (int i = 0; i < min; i++) { x[i] = (byte) Math.max(y[i], z[i]); } } public static void main(String[] args) { int total = 256 * 256; byte[] x = new byte[total]; byte[] y = new byte[total]; byte[] z = new byte[total]; doitMax(x, y, z); }

sample: 668
buggy_code:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.telephony; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.content.pm.PackageManager; import android.content.pm.ResolveInfo; import android.os.DeadObjectException; import android.os.IBinder; import android.os.RemoteException; <|startfocus|> import android.telephony.mbms.IMbmsStreamingManagerCallback; import android.telephony.mbms.IStreamingServiceCallback; <|endfocus|> import android.telephony.mbms.MbmsException; import android.telephony.mbms.StreamingService; import android.telephony.mbms.StreamingServiceInfo; import android.telephony.mbms.vendor.IMbmsStreamingService; import android.util.Log; import java.util.LinkedList; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID; /** @hide */ public class MbmsStreamingManager { private interface ServiceListener { void onServiceConnected(); void onServiceDisconnected(); } private static final String LOG_TAG = "MbmsStreamingManager";
code_review:  remove? 
target code: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.telephony; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.content.pm.PackageManager; import android.content.pm.ResolveInfo; import android.os.DeadObjectException; import android.os.IBinder; import android.os.RemoteException; import android.telephony.mbms.MbmsException; import android.telephony.mbms.StreamingService; import android.telephony.mbms.StreamingServiceInfo; import android.telephony.mbms.vendor.IMbmsStreamingService; import android.util.Log; import java.util.LinkedList; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID; /** @hide */ public class MbmsStreamingManager { private interface ServiceListener { void onServiceConnected(); void onServiceDisconnected(); } private static final String LOG_TAG = "MbmsStreamingManager";
response: package android.telephony; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.content.pm.PackageManager; import android.content.pm.ResolveInfo; import android.os.DeadObjectException; import android.os.IBinder; import android.os.RemoteException; import android.telephony.mbms.IMbmsStreamingManagerCallback; import android.telephony.mbms.IStreamingServiceCallback; import android.telephony.mbms.MbmsException; import android.telephony.mbms.StreamingService; import android.telephony.mbms.StreamingServiceInfo; import android.telephony.mbms.vendor.IMbmsStreamingService; import android.util.Log; import java.util.LinkedList; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID; /** @hide */ public class MbmsStreamingManager { private interface ServiceListener { void onServiceConnected(); void onServiceDisconnected(); } private static final String LOG_TAG = "MbmsStreamingManager"; }

sample: 669
buggy_code:  * limitations under the License. */ package android.os; /** * Mimics the real Android class when running tests on host. This class is needed by the code * generated by Desugar to choose the runtime strategy of try-with-resource based on the android * runtime version. Set it to 17 to force to use the mimic desugaring strategy. */ public class Build { public static class VERSION { public static final int SDK_INT = 17; <|startfocus|> public static final String SDK = "17"; <|endfocus|> } } 
code_review:  I am wondering what is the risk here, because the with this version SDK_INT is known at compile time, whereas with the framework version, the value is known a runtime. Maybe the desugaring tool take the value by introspection, but, anyway, it is an implementation detail, no? 
target code: * limitations under the License. */ package android.os; /** * Mimics the real Android class when running tests on host. This class is needed by the code * generated by Desugar to choose the runtime strategy of try-with-resource based on the android * runtime version. Set it to 17 to force to use the mimic desugaring strategy. */ public class Build { public static class VERSION { public static final int SDK_INT = 17; } }
response: package android.os; public class Build { public static class VERSION { public static final int SDK_INT = 17; public static final String SDK = "17"; } }

sample: 670
buggy_code:  * limitations under the License. */ package android.os; /** * Mimics the real Android class when running tests on host. This class is needed by the code * generated by Desugar to choose the runtime strategy of try-with-resource based on the android * runtime version. Set it to 17 to force to use the mimic desugaring strategy. */ public class Build { public static class VERSION { public static final int SDK_INT = 17; <|startfocus|> public static final String SDK = "17"; <|endfocus|> } } 
code_review:  Needed? 
target code: * limitations under the License. */ package android.os; /** * Mimics the real Android class when running tests on host. This class is needed by the code * generated by Desugar to choose the runtime strategy of try-with-resource based on the android * runtime version. Set it to 17 to force to use the mimic desugaring strategy. */ public class Build { public static class VERSION { public static final int SDK_INT = 17; } }
response: package android.os; public class Build { public static class VERSION { public static final int SDK_INT = 17; public static final String SDK = "17"; } }

sample: 671
buggy_code: import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.Random; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; import static java.nio.charset.StandardCharsets.UTF_8; /** * Tests URLConnections for ftp:// URLs. */ public class FtpURLConnectionTest extends TestCase { private static final String FILE_PATH = "test/file/for/FtpURLConnectionTest.txt"; <|startfocus|> private static final String USER = "user"; private static final String PASSWORD = "password"; <|endfocus|> private static final String SERVER_HOSTNAME = "localhost"; private static final String USER_HOME_DIR = "/home/user"; private FakeFtpServer fakeFtpServer; private UnixFakeFileSystem fileSystem; @Override public void setUp() throws Exception { super.setUp(); fakeFtpServer = new FakeFtpServer(); fakeFtpServer.setServerControlPort(0 /* allocate port number automatically */); fakeFtpServer.addUserAccount(new UserAccount(USER, PASSWORD, USER_HOME_DIR)); fileSystem = new UnixFakeFileSystem(); fakeFtpServer.setFileSystem(fileSystem);
code_review:  Maybe rename to VALID_USER and VALID_PASSWORD since it's now appearing in the tests. 
target code: import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.Random; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; import static java.nio.charset.StandardCharsets.UTF_8; /** * Tests URLConnections for ftp:// URLs. */ public class FtpURLConnectionTest extends TestCase { private static final String FILE_PATH = "test/file/for/FtpURLConnectionTest.txt"; private static final String SERVER_HOSTNAME = "localhost"; private static final String USER_HOME_DIR = "/home/user"; private FakeFtpServer fakeFtpServer; private UnixFakeFileSystem fileSystem; @Override public void setUp() throws Exception { super.setUp(); fakeFtpServer = new FakeFtpServer(); fakeFtpServer.setServerControlPort(0 /* allocate port number automatically */); fakeFtpServer.addUserAccount(new UserAccount(USER, PASSWORD, USER_HOME_DIR)); fileSystem = new UnixFakeFileSystem(); fakeFtpServer.setFileSystem(fileSystem);
response: import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.Random; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; import static java.nio.charset.StandardCharsets.UTF_8; public class FtpURLConnectionTest extends TestCase { private static final String FILE_PATH = "test/file/for/FtpURLConnectionTest.txt"; private static final String VALID_USER = "user"; private static final String VALID_PASSWORD = "password"; private static final String SERVER_HOSTNAME = "localhost"; private static final String USER_HOME_DIR = "/home/user"; private FakeFtpServer fakeFtpServer; private UnixFakeFileSystem fileSystem; @Override public void setUp() throws Exception { super.setUp(); fakeFtpServer = new FakeFtpServer(); fakeFtpServer.setServerControlPort(0 /* allocate port number automatically */); fakeFtpServer.addUserAccount(new UserAccount(VALID_USER, VALID_PASSWORD, USER_HOME_DIR)); fileSystem = new UnixFakeFileSystem(); fakeFtpServer.setFileSystem(fileSystem); } }

sample: 672
buggy_code:  int total = interesting.length * interesting.length; short[] x = new short[total]; short[] y = new short[total]; short[] z = new short[total]; int k = 0; for (int i = 0; i < interesting.length; i++) { for (int j = 0; j < interesting.length; j++) { x[k] = 0; y[k] = interesting[i]; z[k] = interesting[j]; k++; } } <|startfocus|> <|endfocus|> // And test. doitMin(x, y, z); for (int i = 0; i < total; i++) { short expected = (short) Math.min(y[i], z[i]); expectEquals(expected, x[i]); } doitMax(x, y, z); for (int i = 0; i < total; i++) { short expected = (short) Math.max(y[i], z[i]); expectEquals(expected, x[i]); } System.out.println("passed");
code_review:  Remove one blank line. 
target code: int total = interesting.length * interesting.length; short[] x = new short[total]; short[] y = new short[total]; short[] z = new short[total]; int k = 0; for (int i = 0; i < interesting.length; i++) { for (int j = 0; j < interesting.length; j++) { x[k] = 0; y[k] = interesting[i]; z[k] = interesting[j]; k++; } } // And test. doitMin(x, y, z); for (int i = 0; i < total; i++) { short expected = (short) Math.min(y[i], z[i]); expectEquals(expected, x[i]); } doitMax(x, y, z); for (int i = 0; i < total; i++) { short expected = (short) Math.max(y[i], z[i]); expectEquals(expected, x[i]); } System.out.println("passed");
response: int total = interesting.length * interesting.length; short[] x = new short[total]; short[] y = new short[total]; short[] z = new short[total]; int k = 0; for (int i = 0; i < interesting.length; i++) { for (int j = 0; j < interesting.length; j++) { x[k] = 0; y[k] = interesting[i]; z[k] = interesting[j]; k++; } } // And test. doitMin(x, y, z); for (int i = 0; i < total; i++) { short expected = (short) Math.min(y[i], z[i]); expectEquals(expected, x[i]); } doitMax(x, y, z); for (int i = 0; i < total; i++) { short expected = (short) Math.max(y[i], z[i]); expectEquals(expected, x[i]); } System.out.println("passed");

sample: 673
buggy_code: <|startfocus|> private void recordAndEmit(String category, String msg) { <|endfocus|> final String entry = logLine(category, msg); mLocalLog.log(entry); if (ERROR.equals(category)) { Log.e(mTag, entry); } else { Log.d(mTag, entry); }
code_review:  What about an enum for categories ? toString() on enum will print the name as expected. 
target code: private void recordAndEmit(Category category, String msg) { final String entry = logLine(category, msg); mLocalLog.log(entry); if (ERROR.equals(category)) { Log.e(mTag, entry); } else { Log.d(mTag, entry); }
response: private void recordAndEmit(Category category, String msg) { final String entry = logLine(category.toString(), msg); mLocalLog.log(entry); if (Category.ERROR.equals(category)) { Log.e(mTag, entry); } else { Log.d(mTag, entry); } }

sample: 674
buggy_code:  import android.content.Context; import android.content.ContextWrapper; import android.content.res.Resources; import android.support.test.filters.SmallTest; import android.support.test.runner.AndroidJUnit4; import android.telephony.TelephonyManager; import com.android.internal.util.test.BroadcastInterceptingContext; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; @RunWith(AndroidJUnit4.class) @SmallTest public class TetheringConfigurationTest { <|startfocus|> private static final String[] PROVISIONING_APP_NAME = {"some", "app"}; <|endfocus|> @Mock private Context mContext; @Mock private TelephonyManager mTelephonyManager; @Mock private Resources mResources; private Context mMockContext; private boolean mWithTelephonyManager; private class MockContext extends BroadcastInterceptingContext { MockContext(Context base) { super(base); } @Override public Resources getResources() { return mResources; } @Override public Object getSystemService(String name) { if (Context.TELEPHONY_SERVICE.equals(name)) { return mWithTelephonyManager ? mTelephonyManager : null; } return super.getSystemService(name); } }
code_review:  Unused? 
target code: import android.content.Context; import android.content.ContextWrapper; import android.content.res.Resources; import android.support.test.filters.SmallTest; import android.support.test.runner.AndroidJUnit4; import android.telephony.TelephonyManager; import com.android.internal.util.test.BroadcastInterceptingContext; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; @RunWith(AndroidJUnit4.class) @SmallTest public class TetheringConfigurationTest { @Mock private Context mContext; @Mock private TelephonyManager mTelephonyManager; @Mock private Resources mResources; private Context mMockContext; private boolean mWithTelephonyManager; private class MockContext extends BroadcastInterceptingContext { MockContext(Context base) { super(base); } @Override public Resources getResources() { return mResources; } @Override public Object getSystemService(String name) { if (Context.TELEPHONY_SERVICE.equals(name)) { return mWithTelephonyManager ? mTelephonyManager : null; } return super.getSystemService(name); } }
response: import android.content.Context; import android.content.ContextWrapper; import android.content.res.Resources; import android.support.test.filters.SmallTest; import android.support.test.runner.AndroidJUnit4; import android.telephony.TelephonyManager; import com.android.internal.util.test.BroadcastInterceptingContext; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; @RunWith(AndroidJUnit4.class) @SmallTest public class TetheringConfigurationTest { private static final String[] PROVISIONING_APP_NAME = {"some", "app"}; @Mock private Context mContext; @Mock private TelephonyManager mTelephonyManager; @Mock private Resources mResources; private Context mMockContext; private boolean mWithTelephonyManager; private class MockContext extends BroadcastInterceptingContext { MockContext(Context base) { super(base); } @Override public Resources getResources() { return mResources; } @Override public Object getSystemService(String name) { if (Context.TELEPHONY_SERVICE.equals(name)) { return mWithTelephonyManager ? mTelephonyManager : null; } return super.getSystemService(name); } } }

sample: 675
buggy_code: import android.telephony.TelephonyManager; import com.android.internal.util.test.BroadcastInterceptingContext; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; @RunWith(AndroidJUnit4.class) @SmallTest public class TetheringConfigurationTest { private static final String[] PROVISIONING_APP_NAME = {"some", "app"}; @Mock private Context mContext; @Mock private TelephonyManager mTelephonyManager; @Mock private Resources mResources; private Context mMockContext; <|startfocus|> private boolean mWithTelephonyManager; <|endfocus|> private class MockContext extends BroadcastInterceptingContext { MockContext(Context base) { super(base); } @Override public Resources getResources() { return mResources; } @Override public Object getSystemService(String name) { if (Context.TELEPHONY_SERVICE.equals(name)) { return mWithTelephonyManager ? mTelephonyManager : null; } return super.getSystemService(name); } } @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this);
code_review:  mHasTelephonyManager? 
target code: import android.telephony.TelephonyManager; import com.android.internal.util.test.BroadcastInterceptingContext; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; @RunWith(AndroidJUnit4.class) @SmallTest public class TetheringConfigurationTest { private static final String[] PROVISIONING_APP_NAME = {"some", "app"}; @Mock private Context mContext; @Mock private TelephonyManager mTelephonyManager; @Mock private Resources mResources; private Context mMockContext; private boolean mHasTelephonyManager; private class MockContext extends BroadcastInterceptingContext { MockContext(Context base) { super(base); } @Override public Resources getResources() { return mResources; } @Override public Object getSystemService(String name) { if (Context.TELEPHONY_SERVICE.equals(name)) { return mWithTelephonyManager ? mTelephonyManager : null; } return super.getSystemService(name); } } @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this);
response: import android.telephony.TelephonyManager; import com.android.internal.util.test.BroadcastInterceptingContext; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations; @RunWith(AndroidJUnit4.class) @SmallTest public class TetheringConfigurationTest { private static final String[] PROVISIONING_APP_NAME = {"some", "app"}; @Mock private Context mContext; @Mock private TelephonyManager mTelephonyManager; @Mock private Resources mResources; private Context mMockContext; private boolean mWithTelephonyManager; private class MockContext extends BroadcastInterceptingContext { MockContext(Context base) { super(base); } @Override public Resources getResources() { return mResources; } @Override public Object getSystemService(String name) { if (Context.TELEPHONY_SERVICE.equals(name)) { return mWithTelephonyManager ? mTelephonyManager : null; } return super.getSystemService(name); } } @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); } }

sample: 676
buggy_code:  * is only meant for debugging and is not guaranteed to be stable across * releases and/or devices. * * @hide */ public static native String getDexFileStatus(String fileName, String instructionSet) throws FileNotFoundException; /** <|startfocus|> * Returns the full file path of the optimized dex file {@code fileName}. The returned string * is the full file name including path of optimized dex file, if it exists. <|endfocus|> * @hide */ public static native String[] getDexFileOutputPath(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns whether the given filter is a valid filter. * * @hide */ public native static boolean isValidCompilerFilter(String filter); /** * Returns whether the given filter is based on profiles. * * @hide */ public native static boolean isProfileGuidedCompilerFilter(String filter); /** * Returns the version of the compiler filter that is not based on profiles.
code_review:  update this. 
target code: * is only meant for debugging and is not guaranteed to be stable across * releases and/or devices. * * @hide */ public static native String getDexFileStatus(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns the paths of the optimized files generated for {@code fileName}. * If no optimized code exists the method returns null. * @hide */ public static native String[] getDexFileOutputPath(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns whether the given filter is a valid filter. * * @hide */ public native static boolean isValidCompilerFilter(String filter); /** * Returns whether the given filter is based on profiles. * * @hide */ public native static boolean isProfileGuidedCompilerFilter(String filter); /** * Returns the version of the compiler filter that is not based on profiles.
response: /** * Returns the full file path of the optimized dex file {@code fileName}. * The returned string is the full file name including path of optimized dex file, if it exists. * @param fileName The name of the dex file * @param instructionSet The instruction set * @return The full file path of the optimized dex file * @throws FileNotFoundException If the file is not found * @hide */ public static native String getDexFileStatus(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns the full file path of the optimized dex file {@code fileName}. * The returned string is the full file name including path of optimized dex file, if it exists. * @param fileName The name of the dex file * @param instructionSet The instruction set * @return The full file path of the optimized dex file * @throws FileNotFoundException If the file is not found * @hide */ public static native String[] getDexFileOutputPath(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns whether the given filter is a valid filter. * @param filter The filter to check * @return True if the filter is valid, false otherwise * @hide */ public native static boolean isValidCompilerFilter(String filter); /** * Returns whether the given filter is based on profiles. * @param filter The filter to check * @return True if the filter is based on profiles, false otherwise * @hide */ public native static boolean isProfileGuidedCompilerFilter(String filter); /** * Returns the version of the compiler filter that is not based on profiles. * @return The version of the compiler filter * @hide */ public native static int getNonProfileGuidedCompilerFilterVersion();

sample: 677
buggy_code:  * releases and/or devices. * * @hide */ public static native String getDexFileStatus(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns the full file path of the optimized dex file {@code fileName}. The returned string * is the full file name including path of optimized dex file, if it exists. * @hide */ <|startfocus|> public static native String[] getDexFileOutputPath(String fileName, String instructionSet) <|endfocus|> throws FileNotFoundException; /** * Returns whether the given filter is a valid filter. * * @hide */ public native static boolean isValidCompilerFilter(String filter); /** * Returns whether the given filter is based on profiles. * * @hide */ public native static boolean isProfileGuidedCompilerFilter(String filter); /** * Returns the version of the compiler filter that is not based on profiles. * If the input is not a valid filter, or the filter is already not based on
code_review:  Rename this to getDexFileOutputPaths ? 
target code: * releases and/or devices. * * @hide */ public static native String getDexFileStatus(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns the full file path of the optimized dex file {@code fileName}. The returned string * is the full file name including path of optimized dex file, if it exists. * @hide */ public static native String[] getDexFileOutputPaths(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns whether the given filter is a valid filter. * * @hide */ public native static boolean isValidCompilerFilter(String filter); /** * Returns whether the given filter is based on profiles. * * @hide */ public native static boolean isProfileGuidedCompilerFilter(String filter); /** * Returns the version of the compiler filter that is not based on profiles. * If the input is not a valid filter, or the filter is already not based on
response: /** * Returns the full file path of the optimized dex file {@code fileName}. * The returned string is the full file name including path of optimized dex file, if it exists. * * @param fileName The name of the dex file. * @param instructionSet The instruction set of the device. * @return The full file path of the optimized dex file. * @throws FileNotFoundException If the optimized dex file is not found. */ public static native String[] getDexFileOutputPaths(String fileName, String instructionSet) throws FileNotFoundException; /** * Returns whether the given filter is a valid filter. * * @param filter The filter to check. * @return True if the filter is valid, false otherwise. */ public native static boolean isValidCompilerFilter(String filter); /** * Returns whether the given filter is based on profiles. * * @param filter The filter to check. * @return True if the filter is based on profiles, false otherwise. */ public native static boolean isProfileGuidedCompilerFilter(String filter); /** * Returns the version of the compiler filter that is not based on profiles. * If the input is not a valid filter, or the filter is already not based on profiles, * the input filter is returned. * * @param filter The filter to convert. * @return The version of the compiler filter that is not based on profiles. */ public native static String getNonProfileGuidedCompilerFilter(String filter);

sample: 678
buggy_code:  // determine the ABI from either ApplicationInfo or Build String arch = "arm"; if (cameraInfo.primaryCpuAbi != null && VMRuntime.is64BitAbi(cameraInfo.primaryCpuAbi)) { arch = arch + "64"; } else { if (VMRuntime.is64BitAbi(Build.SUPPORTED_ABIS[0])) { arch = arch + "64"; } } // get the path to the odex or oat file String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { <|startfocus|> optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); <|endfocus|> } catch (IOException ioe) {} if (optimizedCode == null) { return true; } //not pinning the oat/odex is not a fatal error for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } }
code_review:  files 
target code: // determine the ABI from either ApplicationInfo or Build String arch = "arm"; if (cameraInfo.primaryCpuAbi != null && VMRuntime.is64BitAbi(cameraInfo.primaryCpuAbi)) { arch = arch + "64"; } else { if (VMRuntime.is64BitAbi(Build.SUPPORTED_ABIS[0])) { arch = arch + "64"; } } // get the path to the odex or oat file String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { files = DexFile.getDexFileOutputPaths(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } //not pinning the oat/odex is not a fatal error for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } }
response: // determine the ABI from either ApplicationInfo or Build String arch = "arm"; if (cameraInfo.primaryCpuAbi != null && VMRuntime.is64BitAbi(cameraInfo.primaryCpuAbi)) { arch = arch + "64"; } else { if (VMRuntime.is64BitAbi(Build.SUPPORTED_ABIS[0])) { arch = arch + "64"; } } // get the path to the odex or oat file String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } // not pinning the oat/odex is not a fatal error for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } }

sample: 679
buggy_code:  String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } //not pinning the oat/odex is not a fatal error <|startfocus|> for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE); <|endfocus|> if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } } return true;
code_review:  for (String file : files) 
target code: String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } //not pinning the oat/odex is not a fatal error for (String file : files) { pf = pinFile(file, 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } } return true;
response: String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } for (String file : optimizedCode) { pf = pinFile(file, 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } } return true;

sample: 680
buggy_code:  String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } //not pinning the oat/odex is not a fatal error <|startfocus|> for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE); <|endfocus|> if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } } return true;
code_review:  MAX_CAMERA_PIN_SIZE can now be exceeded if the sum of the sizes of files returned by getDexFileOutputPaths exceeds it. Is that intentional? 
target code: String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } //not pinning the oat/odex is not a fatal error for (String file : files) { pf = pinFile(file, 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } } return true;
response: String baseCodePath = cameraInfo.getBaseCodePath(); String[] optimizedCode = null; try { optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch); } catch (IOException ioe) {} if (optimizedCode == null) { return true; } for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE); if (pf != null) { mPinnedCameraFiles.add(pf); if (DEBUG) { Slog.i(TAG, "Pinned " + pf.mFilename); } } } return true;

sample: 681
buggy_code:  packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED); packageIntentFilter.addAction(Intent.ACTION_PACKAGE_ADDED); packageIntentFilter.addDataScheme("package"); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, packageIntentFilter, null, null); IntentFilter bootIntentFilter = new IntentFilter(Intent.ACTION_BOOT_COMPLETED); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, bootIntentFilter, null, null); IntentFilter userRemovedFilter = new IntentFilter(Intent.ACTION_USER_REMOVED); <|startfocus|> context.registerReceiverAsUser(mReceiver, UserHandle.ALL, userRemovedFilter, null, null); <|endfocus|> Uri defaultDialerSetting = Settings.Secure.getUriFor(Settings.Secure.DIALER_DEFAULT_APPLICATION); context.getContentResolver() .registerContentObserver(defaultDialerSetting, false, mDefaultDialerObserver, UserHandle.USER_ALL);
code_review:  The broadcast is sent to all running users except the one that has been removed. so registerReceiever should be good enough. 
target code: packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED); packageIntentFilter.addAction(Intent.ACTION_PACKAGE_ADDED); packageIntentFilter.addDataScheme("package"); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, packageIntentFilter, null, null); IntentFilter bootIntentFilter = new IntentFilter(Intent.ACTION_BOOT_COMPLETED); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, bootIntentFilter, null, null); IntentFilter userRemovedFilter = new IntentFilter(Intent.ACTION_USER_REMOVED); context.registerReceiver(mReceiver, userRemovedFilter); Uri defaultDialerSetting = Settings.Secure.getUriFor(Settings.Secure.DIALER_DEFAULT_APPLICATION); context.getContentResolver() .registerContentObserver(defaultDialerSetting, false, mDefaultDialerObserver, UserHandle.USER_ALL);
response: packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED); packageIntentFilter.addAction(Intent.ACTION_PACKAGE_ADDED); packageIntentFilter.addDataScheme("package"); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, packageIntentFilter, null, null); IntentFilter bootIntentFilter = new IntentFilter(Intent.ACTION_BOOT_COMPLETED); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, bootIntentFilter, null, null); IntentFilter userRemovedFilter = new IntentFilter(Intent.ACTION_USER_REMOVED); context.registerReceiver(mReceiver, userRemovedFilter); Uri defaultDialerSetting = Settings.Secure.getUriFor(Settings.Secure.DIALER_DEFAULT_APPLICATION); context.getContentResolver().registerContentObserver(defaultDialerSetting, false, mDefaultDialerObserver, UserHandle.USER_ALL);

sample: 682
buggy_code: <|startfocus|> public IPv6TetheringCoordinator( SharedLog log, ArrayList<TetherInterfaceStateMachine> notifyList) { mLog = log.forSubComponent(TAG); <|endfocus|> mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mUniqueLocalPrefix = generateUniqueLocalPrefix(); mNextSubnetId = 0;
code_review:  Is there a reason why the log is the first parameter? (Here and elsewhere.) Often the recommendation is to have the most important parameters at the beginning. 
target code: public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mUniqueLocalPrefix = generateUniqueLocalPrefix(); mNextSubnetId = 0;
response: public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList, SharedLog log) { mLog = log.forSubComponent(TAG); mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mUniqueLocalPrefix = generateUniqueLocalPrefix(); mNextSubnetId = 0; }

sample: 683
buggy_code: <|startfocus|> public void error(String msg) { recordAndEmit(Category.ERROR, msg); <|endfocus|>
code_review:  Also consider using "e" here for consistency with android.util.Log. Other levels might be "i", "w", "v", etc. 
target code: public void e(String msg) { Log.e(mTag, record(Category.ERROR, msg));
response: public void e(String msg) { recordAndEmit(Category.ERROR, msg); }

sample: 684
buggy_code:  } public void dump(FileDescriptor fd, PrintWriter writer, String[] args) { mLocalLog.readOnlyLocalLog().dump(fd, writer, args); } public void error(Exception e) { recordAndEmit(Category.ERROR, e.toString()); } public void error(String msg) { recordAndEmit(Category.ERROR, msg); } public void event(String msg) { record(Category.EVENT, msg); } public void log(String msg) { record(Category.NONE, msg); } <|startfocus|> public void logAndEmit(String msg) { recordAndEmit(Category.NONE, msg); } <|endfocus|> public void mark(String msg) { record(Category.MARK, msg); } private void record(Category category, String msg) { mLocalLog.log(logLine(category, msg)); } private void recordAndEmit(Category category, String msg) { final String entry = logLine(category, msg); mLocalLog.log(entry); if (Category.ERROR.equals(category)) { Log.e(mTag, entry); } else { Log.d(mTag, entry); } } 
code_review:  There's an inconsistency here between what logs+emits and what just logs. In the future I fear we could be surprised if we do: error(...); event(...); error(...); and we don't find event in the system log. Maybe make all the functions both emit and log? 
target code: } public void dump(FileDescriptor fd, PrintWriter writer, String[] args) { mLocalLog.readOnlyLocalLog().dump(fd, writer, args); } public void error(Exception e) { recordAndEmit(Category.ERROR, e.toString()); } public void error(String msg) { recordAndEmit(Category.ERROR, msg); } public void event(String msg) { record(Category.EVENT, msg); } public void log(String msg) { record(Category.NONE, msg); } public void mark(String msg) { record(Category.MARK, msg); } private void record(Category category, String msg) { mLocalLog.log(logLine(category, msg)); } private void recordAndEmit(Category category, String msg) { final String entry = logLine(category, msg); mLocalLog.log(entry); if (Category.ERROR.equals(category)) { Log.e(mTag, entry); } else { Log.d(mTag, entry); } }
response: } public void dump(FileDescriptor fd, PrintWriter writer, String[] args) { mLocalLog.readOnlyLocalLog().dump(fd, writer, args); } public void error(Exception e) { recordAndEmit(Category.ERROR, e.toString()); } public void error(String msg) { recordAndEmit(Category.ERROR, msg); } public void event(String msg) { recordAndEmit(Category.EVENT, msg); } public void log(String msg) { recordAndEmit(Category.NONE, msg); } public void logAndEmit(String msg) { recordAndEmit(Category.NONE, msg); } public void mark(String msg) { record(Category.MARK, msg); } private void record(Category category, String msg) { mLocalLog.log(logLine(category, msg)); } private void recordAndEmit(Category category, String msg) { final String entry = logLine(category, msg); mLocalLog.log(entry); if (Category.ERROR.equals(category)) { Log.e(mTag, entry); } else { Log.d(mTag, entry); } }

sample: 685
buggy_code:  phoneAccountHandle = extras.getParcelable( TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE); } boolean isSelfManaged = phoneAccountHandle != null && isSelfManagedConnectionService(phoneAccountHandle); if (isSelfManaged) { mContext.enforceCallingOrSelfPermission(Manifest.permission.MANAGE_OWN_CALLS, "Self-managed ConnectionServices require MANAGE_OWN_CALLS permission."); if (!callingPackage.equals( phoneAccountHandle.getComponentName().getPackageName()) && !canCallPhone(callingPackage, <|startfocus|> "CALL_PHONE permission requried to place calls.")) { <|endfocus|> // The caller is not allowed to place calls, so we want to ensure that it // can only place calls through itself. throw new SecurityException("Self-managed ConnectionServices can only " + "place calls through their own ConnectionService."); } } else if (!canCallPhone(callingPackage, "placeCall")) { throw new SecurityException("Package " + callingPackage + " is not allowed to place phone calls"); } // Note: we can still get here for the default/system dialer, even if the Phone
code_review:  required 
target code: phoneAccountHandle = extras.getParcelable( TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE); } boolean isSelfManaged = phoneAccountHandle != null && isSelfManagedConnectionService(phoneAccountHandle); if (isSelfManaged) { mContext.enforceCallingOrSelfPermission(Manifest.permission.MANAGE_OWN_CALLS, "Self-managed ConnectionServices require MANAGE_OWN_CALLS permission."); if (!callingPackage.equals( phoneAccountHandle.getComponentName().getPackageName()) && !canCallPhone(callingPackage, "CALL_PHONE permission required to place calls.")) { // The caller is not allowed to place calls, so we want to ensure that it // can only place calls through itself. throw new SecurityException("Self-managed ConnectionServices can only " + "place calls through their own ConnectionService."); } } else if (!canCallPhone(callingPackage, "placeCall")) { throw new SecurityException("Package " + callingPackage + " is not allowed to place phone calls"); } // Note: we can still get here for the default/system dialer, even if the Phone
response: phoneAccountHandle = extras.getParcelable(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE); boolean isSelfManaged = phoneAccountHandle != null && isSelfManagedConnectionService(phoneAccountHandle); if (isSelfManaged) { mContext.enforceCallingOrSelfPermission(Manifest.permission.MANAGE_OWN_CALLS, "Self-managed ConnectionServices require MANAGE_OWN_CALLS permission."); if (!callingPackage.equals(phoneAccountHandle.getComponentName().getPackageName()) && !canCallPhone(callingPackage, "CALL_PHONE permission required to place calls.")) { throw new SecurityException("Self-managed ConnectionServices can only place calls through their own ConnectionService."); } } else if (!canCallPhone(callingPackage, "placeCall")) { throw new SecurityException("Package " + callingPackage + " is not allowed to place phone calls"); }

sample: 686
buggy_code:  private String logLine(Category category, String msg) { final StringJoiner sj = new StringJoiner(" "); if (!isRootLogInstance()) sj.add("[" + mComponent + "]"); <|startfocus|> if (!Category.NONE.equals(category)) sj.add(category.toString()); <|endfocus|> return sj.add(msg).toString();
code_review:  Just FYI: pointer equality works for enums. 
target code: private String logLine(Category category, String msg) { final StringJoiner sj = new StringJoiner(" "); if (!isRootLogInstance()) sj.add("[" + mComponent + "]"); if (category != Category.NONE) sj.add(category.toString()); return sj.add(msg).toString();
response: private String logLine(Category category, String msg) { final StringJoiner sj = new StringJoiner(" "); if (!isRootLogInstance()) { sj.add("[" + mComponent + "]"); } if (category != Category.NONE) { sj.add(category.toString()); } return sj.add(msg).toString(); }

sample: 687
buggy_code:  * is used for accessing the key store and trust store for TLS * certificates. * * @param target The base URL for the server to be accessed. * @param conf The configuration for certificates and credentials. * @param mapper The object mapper. * @param loader The resource loader. */ public GatewayClient(String target, ClientConfig conf, ObjectMapper mapper, ResourceLoader loader) { super(target, conf, mapper, loader); } /** <|startfocus|> * Ping the peer Acumos. <|endfocus|> * * @param peerId The ID of the peer Acumos. * @return Information about the peer. */ public MLPPeer ping(String peerId) { return handleResponse(PEER_PFX + FederationClient.PING_URI, new ParameterizedTypeReference<JsonResponse<MLPPeer>>(){}, peerId); } /** * Ask the peer about its peers. * * @param peerId The ID of the peer Acumos. * @return The list of the peer's peers. */ public List<MLPPeer> getPeers(String peerId) {
code_review:  .. but you're pinging locally, right? Also see comments about ping on GatewayClient 
target code: * is used for accessing the key store and trust store for TLS * certificates. * * @param target The base URL for the server to be accessed. * @param conf The configuration for certificates and credentials. * @param mapper The object mapper. * @param loader The resource loader. */ public GatewayClient(String target, ClientConfig conf, ObjectMapper mapper, ResourceLoader loader) { super(target, conf, mapper, loader); } /** * Verify connectivity between the local gateway server and the remote * federation server. * * @param peerId The ID of the peer Acumos. * @return Information about the peer. */ public MLPPeer ping(String peerId) { return handleResponse(PEER_PFX + FederationClient.PING_URI, new ParameterizedTypeReference<JsonResponse<MLPPeer>>(){}, peerId); } /** * Ask the peer about its peers. * * @param peerId The ID of the peer Acumos. * @return The list of the peer's peers. */ public List<MLPPeer> getPeers(String peerId) {
response: public GatewayClient(String target, ClientConfig conf, ObjectMapper mapper, ResourceLoader loader) { super(target, conf, mapper, loader); } public MLPPeer ping(String peerId) { return handleResponse(PEER_PFX + FederationClient.PING_URI, new ParameterizedTypeReference<JsonResponse<MLPPeer>>(){}, peerId); } public List<MLPPeer> getPeers(String peerId) { // implementation }

sample: 688
buggy_code:  } /** * Ask the peer about its peers. * * @param peerId The ID of the peer Acumos. * @return The list of the peer's peers. */ public List<MLPPeer> getPeers(String peerId) { return handleResponse(PEER_PFX + FederationClient.PEERS_URI, new ParameterizedTypeReference<JsonResponse<List<MLPPeer>>>(){}, peerId); } /** <|startfocus|> * Register with the peer. <|endfocus|> * * @param peerId The ID of the peer Acumos. * @return Information about the peer. */ public MLPPeer register(String peerId) { return handleResponse(PEER_PFX + FederationClient.REGISTER_URI, HttpMethod.POST, new ParameterizedTypeReference<JsonResponse<MLPPeer>>(){}, peerId); } /** * Ask the peer for a list of catalogs. * * @param peerId The ID of the peer Acumos. * @return The list of catalogs (enhanced with their sizes), the peer is willing to share. */ public List<MLPCatalog> getCatalogs(String peerId) {
code_review:  What does registration accomplish? I mean, does it cause a change in state inside the target local gateway? 
target code: } /** * Ask the peer about its peers. * * @param peerId The ID of the peer Acumos. * @return The list of the peer's peers. */ public List<MLPPeer> getPeers(String peerId) { return handleResponse(PEER_PFX + FederationClient.PEERS_URI, new ParameterizedTypeReference<JsonResponse<List<MLPPeer>>>(){}, peerId); } /** * Ask the remote federation server to * add the local server to its list of peers. * * @param peerId The ID of the peer Acumos. * @return Information about the peer. */ public MLPPeer register(String peerId) { return handleResponse(PEER_PFX + FederationClient.REGISTER_URI, HttpMethod.POST, new ParameterizedTypeReference<JsonResponse<MLPPeer>>(){}, peerId); } /** * Ask the peer for a list of catalogs. * * @param peerId The ID of the peer Acumos. * @return The list of catalogs (enhanced with their sizes), the peer is willing to share. */ public List<MLPCatalog> getCatalogs(String peerId) {
response: } /** * Ask the peer about its peers. * * @param peerId The ID of the peer Acumos. * @return The list of the peer's peers. */ public List<MLPPeer> getPeers(String peerId) { return handleResponse(PEER_PFX + FederationClient.PEERS_URI, new ParameterizedTypeReference<JsonResponse<List<MLPPeer>>>(){}, peerId); } /** * Register with the peer. * * @param peerId The ID of the peer Acumos. * @return Information about the peer. */ public MLPPeer register(String peerId) { return handleResponse(PEER_PFX + FederationClient.REGISTER_URI, HttpMethod.POST, new ParameterizedTypeReference<JsonResponse<MLPPeer>>(){}, peerId); } /** * Ask the peer for a list of catalogs. * * @param peerId The ID of the peer Acumos. * @return The list of catalogs (enhanced with their sizes), the peer is willing to share. */ public List<MLPCatalog> getCatalogs(String peerId) { return handleResponse(PEER_PFX + FederationClient.CATALOGS_URI, new ParameterizedTypeReference<JsonResponse<List<MLPCatalog>>>(){}, peerId); }

sample: 689
buggy_code:  * * Configuration classes are also Conponents so they are subject to Component scanning. */ @SpringBootApplication @EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, HibernateJpaAutoConfiguration.class }) @EnableConfigurationProperties @ComponentScan(basePackages = "org.acumos.federation", useDefaultFilters = false, includeFilters = @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE, classes={org.acumos.federation.gateway.config.GatewayConfiguration.class, org.acumos.federation.gateway.config.AdapterConfiguration.class})) <|startfocus|> public class Application { <|endfocus|> private final static EELFLoggerDelegate logger = EELFLoggerDelegate.getLogger(Application.class); /** * We should be able to swap the LocalConfiguration in the case of adapters. */ public static void main(String[] args) throws Exception { SpringApplicationBuilder gatewayBuilder = new SpringApplicationBuilder(Application.class) .bannerMode(Banner.Mode.OFF) .web(false); gatewayBuilder.child(FederationConfiguration.class) .bannerMode(Banner.Mode.OFF) .web(true) .run(args); gatewayBuilder.child(LocalConfiguration.class)
code_review:  server 
target code: * * Configuration classes are also Conponents so they are subject to Component scanning. */ @SpringBootApplication @EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, HibernateJpaAutoConfiguration.class }) @EnableConfigurationProperties @ComponentScan(basePackages = "org.acumos.federation", useDefaultFilters = false, includeFilters = @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE, classes={org.acumos.federation.gateway.config.GatewayConfiguration.class, org.acumos.federation.gateway.config.AdapterConfiguration.class})) public class Application { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); private final static EELFLoggerDelegate logger = EELFLoggerDelegate.getLogger(Application.class); /** * We should be able to swap the LocalConfiguration in the case of adapters. */ public static void main(String[] args) throws Exception { SpringApplicationBuilder gatewayBuilder = new SpringApplicationBuilder(Application.class) .bannerMode(Banner.Mode.OFF) .web(false); gatewayBuilder.child(FederationConfiguration.class) .bannerMode(Banner.Mode.OFF) .web(true) .run(args); gatewayBuilder.child(LocalConfiguration.class)
response: @SpringBootApplication @EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, HibernateJpaAutoConfiguration.class }) @EnableConfigurationProperties @ComponentScan(basePackages = "org.acumos.federation", useDefaultFilters = false, includeFilters = @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE, classes={org.acumos.federation.gateway.config.GatewayConfiguration.class, org.acumos.federation.gateway.config.AdapterConfiguration.class})) public class Application { private final static EELFLoggerDelegate logger = EELFLoggerDelegate.getLogger(Application.class); public static void main(String[] args) throws Exception { SpringApplicationBuilder gatewayBuilder = new SpringApplicationBuilder(Application.class) .bannerMode(Banner.Mode.OFF) .web(false); gatewayBuilder.child(FederationConfiguration.class) .bannerMode(Banner.Mode.OFF) .web(true) .run(args); gatewayBuilder.child(LocalConfiguration.class); } }

sample: 690
buggy_code:  public MLPSolution createSolution(MLPSolution solution) { <|startfocus|> Set<MLPTag> tags = solution.getTags(); solution.setTags(Collections.emptySet()); solution = clients.getCDSClient().createSolution(solution); doTags(tags, solution.getSolutionId()); return solution; <|endfocus|>
code_review:  CDS createSolution() method creates tags not seen before. One of the very few things it does without being asked. 
target code: public MLPSolution createSolution(MLPSolution solution) { return clients.getCDSClient().createSolution(solution);
response: public MLPSolution createSolution(MLPSolution solution) { Set<MLPTag> tags = solution.getTags(); solution.setTags(Collections.emptySet()); solution = clients.getCDSClient().createSolution(solution); doTags(tags, solution.getSolutionId()); return solution; }

sample: 691
buggy_code:  import com.github.dockerjava.api.DockerClient; import com.github.dockerjava.core.DefaultDockerClientConfig; import com.github.dockerjava.core.DockerClientBuilder; import org.acumos.cds.client.ICommonDataServiceRestClient; import org.acumos.cds.client.CommonDataServiceRestClientImpl; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.FederationClient; /** * Defines all beans used to access outside services. * * By mocking this bean, all external access can be stubbed out. */ <|startfocus|> public class Clients { <|endfocus|> @Autowired private FederationConfig federation; @Autowired private ServiceConfig cdmsConfig; @Autowired private NexusConfig nexusConfig; @Autowired private DockerConfig dockerConfig; private ICommonDataServiceRestClient cdsClient; private NexusClient nexusClient; private DockerClient dockerClient; public FederationClient getFederationClient(String url) { return new FederationClient(url, federation); } public synchronized ICommonDataServiceRestClient getCDSClient() { if (cdsClient == null) { String url = cdmsConfig.getUrl(); ClientConfig cc = new ClientConfig(); cc.setCreds(cdmsConfig);
code_review:  Would you possibly consider a less generic name, just for clarity? 
target code: import com.github.dockerjava.api.DockerClient; import com.github.dockerjava.core.DefaultDockerClientConfig; import com.github.dockerjava.core.DockerClientBuilder; import org.acumos.cds.client.ICommonDataServiceRestClient; import org.acumos.cds.client.CommonDataServiceRestClientImpl; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.FederationClient; /** * Defines all beans used to access outside services. * * By mocking this bean, all external access can be stubbed out. */ public class Clients { @Autowired private FederationConfig federation; @Autowired private ServiceConfig cdmsConfig; @Autowired private NexusConfig nexusConfig; @Autowired private DockerConfig dockerConfig; private ICommonDataServiceRestClient cdsClient; private NexusClient nexusClient; private DockerClient dockerClient; public FederationClient getFederationClient(String url) { return new FederationClient(url, federation); } public synchronized ICommonDataServiceRestClient getCDSClient() { if (cdsClient == null) { String url = cdmsConfig.getUrl(); ClientConfig cc = new ClientConfig(); cc.setCreds(cdmsConfig);
response: import com.github.dockerjava.api.DockerClient; import com.github.dockerjava.core.DefaultDockerClientConfig; import com.github.dockerjava.core.DockerClientBuilder; import org.acumos.cds.client.ICommonDataServiceRestClient; import org.acumos.cds.client.CommonDataServiceRestClientImpl; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.FederationClient; public class Clients { @Autowired private FederationConfig federation; @Autowired private ServiceConfig cdmsConfig; @Autowired private NexusConfig nexusConfig; @Autowired private DockerConfig dockerConfig; private ICommonDataServiceRestClient cdsClient; private NexusClient nexusClient; private DockerClient dockerClient; public FederationClient getFederationClient(String url) { return new FederationClient(url, federation); } public synchronized ICommonDataServiceRestClient getCDSClient() { if (cdsClient == null) { String url = cdmsConfig.getUrl(); ClientConfig cc = new ClientConfig(); cc.setCreds(cdmsConfig); cdsClient = new CommonDataServiceRestClientImpl(url, cc); } return cdsClient; } public synchronized NexusClient getNexusClient() { if (nexusClient == null) { nexusClient = new NexusClient(nexusConfig); } return nexusClient; } public synchronized DockerClient getDockerClient() { if (dockerClient == null) { DefaultDockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder() .withDockerHost(dockerConfig.getHost()) .withDockerTlsVerify(dockerConfig.isTlsVerify()) .withDockerCertPath(dockerConfig.getCertPath()) .withDockerConfig(dockerConfig.getDockerConfig()) .build(); dockerClient = DockerClientBuilder.getInstance(config).build(); } return dockerClient; } }

sample: 692
buggy_code:  public InputStream getArtifactContent(MLPArtifact artifact); /** * Set the URI for an artifact. * * @param solutionId The ID of the solution. * @param artifact The artifact to set the URI on. */ public void setArtifactUri(String solutionId, MLPArtifact artifact); /** * Put the content of an artifact. * * @param artifact The artifact to put. * @param tag The image tag in the input data. <|startfocus|> * @param is The data to put. <|endfocus|> */ public void putArtifactContent(MLPArtifact artifact, String tag, InputStream is); /** * Get the body of a document. * * @param document The document to retrieve. * @return An InputStream for reading the document's content. */ public InputStream getDocumentContent(MLPDocument document); /** * Set the URI for an document. * * @param solutionId The ID of the solution. * @param document The document to set the URI on. */
code_review:  stream. Does this method close the stream when it's done? 
target code: public InputStream getArtifactContent(MLPArtifact artifact); /** * Set the URI for an artifact. * * @param solutionId The ID of the solution. * @param artifact The artifact to set the URI on. */ public void setArtifactUri(String solutionId, MLPArtifact artifact); /** * Put the content of an artifact. * * @param artifact The artifact to put. * @param tag The image tag in the input data. * @param is The data to put. Implementations must close the input stream. */ public void putArtifactContent(MLPArtifact artifact, String tag, InputStream is); /** * Get the body of a document. * * @param document The document to retrieve. * @return An InputStream for reading the document's content. */ public InputStream getDocumentContent(MLPDocument document); /** * Set the URI for an document. * * @param solutionId The ID of the solution. * @param document The document to set the URI on. */
response: public InputStream getArtifactContent(MLPArtifact artifact); /** * Set the URI for an artifact. * * @param solutionId The ID of the solution. * @param artifact The artifact to set the URI on. */ public void setArtifactUri(String solutionId, MLPArtifact artifact); /** * Put the content of an artifact. * * @param artifact The artifact to put. * @param tag The image tag in the input data. * @param is The data to put. */ public void putArtifactContent(MLPArtifact artifact, String tag, InputStream is); /** * Get the body of a document. * * @param document The document to retrieve. * @return An InputStream for reading the document's content. */ public InputStream getDocumentContent(MLPDocument document); /** * Set the URI for a document. * * @param solutionId The ID of the solution. * @param document The document to set the URI on. */ public void setDocumentUri(String solutionId, MLPDocument document);

sample: 693
buggy_code:  */ public InputStream getDocumentContent(MLPDocument document); /** * Set the URI for an document. * * @param solutionId The ID of the solution. * @param document The document to set the URI on. */ public void setDocumentUri(String solutionId, MLPDocument document); /** * Put the content of a document. * * @param document The document to put. <|startfocus|> * @param is The data to put. <|endfocus|> */ public void putDocumentContent(MLPDocument document, InputStream is); } 
code_review:  stream. Does this method close the stream when it's done? 
target code: */ public InputStream getDocumentContent(MLPDocument document); /** * Set the URI for an document. * * @param solutionId The ID of the solution. * @param document The document to set the URI on. */ public void setDocumentUri(String solutionId, MLPDocument document); /** * Put the content of a document. * * @param document The document to put. * @param is The data to put. Implementations must close the input stream. */ public void putDocumentContent(MLPDocument document, InputStream is); }
response: package com.googlesource.gerrit.plugins.xdocs.formatter; import com.googlesource.gerrit.plugins.xdocs.ConfigSection; import java.io.IOException; import java.io.InputStream; public interface StreamFormatter extends Formatter { /** * Formats the given raw text as html. * * @param projectName the name of the project that contains the file to be formatted * @param revision the abbreviated revision from which the file is loaded * @param cfg the global configuration for this formatter * @param raw the raw stream * @return the content from the given stream formatted as html * @throws IOException thrown if the formatting fails */ public String format(String projectName, String revision, ConfigSection cfg, InputStream raw) throws IOException; } import org.eclipse.tracecompass.internal.provisional.tmf.chart.core.descriptor.IDataChartDescriptor; public class DescriptorsInformation { private final boolean fAreDescriptorsNumerical; private final boolean fAreDescriptorsDuration; private final boolean fAreDescriptorsTimestamp; public DescriptorsInformation(Collection<IDataChartDescriptor<?, ?>> descriptors) { DescriptorTypeVisitor visitor = new DescriptorTypeVisitor(); descriptors.forEach(desc -> desc.accept(visitor)); if (visitor.isEmpty()) { throw new IllegalArgumentException("No descriptor were given."); } if (visitor.isMixed()) { // Handle mixed descriptors } else { // Handle non-mixed descriptors } } } import com.google.common.collect.ImmutableSet; import com.google.common.base.Splitter; import java.util.Locale; import java.util.stream.Stream; public class SomeClass { public void someMethod() { assertThat(Splitter.on(", ").splitToList(allowMethods)) .named(ACCESS_CONTROL_ALLOW_METHODS) .containsExactly("GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS"); assertThat(allowHeaders) .named(ACCESS_CONTROL_ALLOW_HEADERS) .isNotNull(); assertThat(Splitter.on(", ").splitToList(allowHeaders)) .named(ACCESS_CONTROL_ALLOW_HEADERS) .containsExactlyElementsIn( Stream.of(AUTHORIZATION, CONTENT_TYPE, "X-Gerrit-Auth", "X-Requested-With") .map(s -> s.toLowerCase(Locale.US)) .collect(ImmutableSet.toImmutableSet())); // Handle other assertions } } public interface DocumentService { public InputStream getDocumentContent(

sample: 694
buggy_code: import org.acumos.cds.domain.MLPSolutionRevision; import org.acumos.cds.domain.MLPArtifact; import org.acumos.cds.domain.MLPDocument; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.data.Artifact; import org.acumos.federation.client.data.Document; import org.acumos.federation.client.data.JsonResponse; import org.acumos.federation.client.data.SolutionRevision; /** * Controller bean for the external (public) API. */ @Controller @CrossOrigin public class FederationController { <|startfocus|> private static final Logger log = LoggerFactory.getLogger(FederationController.class); <|endfocus|> @Autowired private FederationConfig federation; @Autowired private WebSecurityConfigurerAdapter security; @Autowired private PeerService peerService; @Autowired private CatalogService catalogService; @Autowired private ContentService contentService; private UriTemplateHandler originBuilder; private String makeOrigin(String uri, Object... params) { if (originBuilder == null) {
code_review:  This isn't a web site -- why is this needed? 
target code: import org.acumos.cds.domain.MLPSolutionRevision; import org.acumos.cds.domain.MLPArtifact; import org.acumos.cds.domain.MLPDocument; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.data.Artifact; import org.acumos.federation.client.data.Document; import org.acumos.federation.client.data.JsonResponse; import org.acumos.federation.client.data.SolutionRevision; /** * Controller bean for the external (public) API. */ @Controller @CrossOrigin public class FederationController { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private FederationConfig federation; @Autowired private WebSecurityConfigurerAdapter security; @Autowired private PeerService peerService; @Autowired private CatalogService catalogService; @Autowired private ContentService contentService; private UriTemplateHandler originBuilder; private String makeOrigin(String uri, Object... params) { if (originBuilder == null) {
response: public void setBuffer(char[] buffer){ this.buffer = buffer; tokenBegin = bufpos = 0; containsEscapes = false; tokenBegin = -1; } import org.acumos.cds.domain.MLPSolutionRevision; import org.acumos.cds.domain.MLPArtifact; import org.acumos.cds.domain.MLPDocument; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.data.Artifact; import org.acumos.federation.client.data.Document; import org.acumos.federation.client.data.JsonResponse; import org.acumos.federation.client.data.SolutionRevision; @Controller @CrossOrigin public class FederationController { private static final Logger log = LoggerFactory.getLogger(FederationController.class); @Autowired private FederationConfig federation; @Autowired private WebSecurityConfigurerAdapter security; @Autowired private PeerService peerService; @Autowired private CatalogService catalogService; @Autowired private ContentService contentService; private UriTemplateHandler originBuilder; private String makeOrigin(String uri, Object... params) { if (originBuilder == null) { // code to build origin } // code to return origin } }

sample: 695
buggy_code: import org.acumos.cds.domain.MLPDocument; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.data.Artifact; import org.acumos.federation.client.data.Document; import org.acumos.federation.client.data.JsonResponse; import org.acumos.federation.client.data.SolutionRevision; /** * Controller bean for the external (public) API. */ @Controller @CrossOrigin public class FederationController { <|startfocus|> private static final Logger log = LoggerFactory.getLogger(FederationController.class); <|endfocus|> @Autowired private FederationConfig federation; @Autowired private WebSecurityConfigurerAdapter security; @Autowired private PeerService peerService; @Autowired private CatalogService catalogService; @Autowired private ContentService contentService; private UriTemplateHandler originBuilder; private String makeOrigin(String uri, Object... params) { if (originBuilder == null) { originBuilder = ClientBase.buildRestTemplate("https://" + ((Security)security).getSelf().getSubjectName() + ":" + federation.getServer().getPort(), new ClientConfig(), null, null).getUriTemplateHandler(); }
code_review:  Please use the method handles lookup trick 
target code: import org.acumos.cds.domain.MLPDocument; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.data.Artifact; import org.acumos.federation.client.data.Document; import org.acumos.federation.client.data.JsonResponse; import org.acumos.federation.client.data.SolutionRevision; /** * Controller bean for the external (public) API. */ @Controller @CrossOrigin public class FederationController { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private FederationConfig federation; @Autowired private WebSecurityConfigurerAdapter security; @Autowired private PeerService peerService; @Autowired private CatalogService catalogService; @Autowired private ContentService contentService; private UriTemplateHandler originBuilder; private String makeOrigin(String uri, Object... params) { if (originBuilder == null) { originBuilder = ClientBase.buildRestTemplate("https://" + ((Security)security).getSelf().getSubjectName() + ":" + federation.getServer().getPort(), new ClientConfig(), null, null).getUriTemplateHandler(); }
response: import org.acumos.cds.domain.MLPDocument; import org.acumos.federation.client.ClientBase; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.data.Artifact; import org.acumos.federation.client.data.Document; import org.acumos.federation.client.data.JsonResponse; import org.acumos.federation.client.data.SolutionRevision; @Controller @CrossOrigin public class FederationController { private static final Logger log = LoggerFactory.getLogger(FederationController.class); @Autowired private FederationConfig federation; @Autowired private WebSecurityConfigurerAdapter security; @Autowired private PeerService peerService; @Autowired private CatalogService catalogService; @Autowired private ContentService contentService; private UriTemplateHandler originBuilder; private String makeOrigin(String uri, Object... params) { if (originBuilder == null) { originBuilder = ClientBase.buildRestTemplate("https://" + ((Security)security).getSelf().getSubjectName() + ":" + federation.getServer().getPort(), new ClientConfig(), null, null).getUriTemplateHandler(); } } }

sample: 696
buggy_code:  public JsonResponse<Void> badRequestError(HttpServletRequest request, HttpServletResponse response, BadRequestException badRequest) { <|startfocus|> log.info("Request {} failed {} {} {}", request.getRequestURI(), badRequest.getMessage(), badRequest.getCode(), badRequest); <|endfocus|> JsonResponse<Void> ret = new JsonResponse<>(); ret.setError(badRequest.getMessage()); response.setStatus(badRequest.getCode()); return ret;
code_review:  Please call log.error, not info 
target code: public JsonResponse<Void> badRequestError(HttpServletRequest request, HttpServletResponse response, BadRequestException badRequest) { log.warn("Rejecting invalid request {}: {} {} {}", request.getRequestURI(), badRequest.getMessage(), badRequest.getCode(), badRequest); JsonResponse<Void> ret = new JsonResponse<>(); ret.setError(badRequest.getMessage()); response.setStatus(badRequest.getCode()); return ret;
response: public JsonResponse<Void> badRequestError(HttpServletRequest request, HttpServletResponse response, BadRequestException badRequest) { log.error("Request {} failed {} {} {}", request.getRequestURI(), badRequest.getMessage(), badRequest.getCode(), badRequest); JsonResponse<Void> ret = new JsonResponse<>(); ret.setError(badRequest.getMessage()); response.setStatus(badRequest.getCode()); return ret; }

sample: 697
buggy_code:  import org.acumos.cds.domain.MLPCatalog; import org.acumos.cds.domain.MLPSolution; import org.acumos.cds.domain.MLPPeer; import org.acumos.cds.domain.MLPPeerSubscription; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.GatewayClient; import org.acumos.federation.client.data.JsonResponse; /** * Controller bean for the internal (gateway) API. */ @Controller @CrossOrigin @Secured(Security.ROLE_INTERNAL) @RequestMapping(GatewayClient.PEER_PFX) public class GatewayController { <|startfocus|> private static final Logger log = LoggerFactory.getLogger(GatewayController.class); <|endfocus|> @Autowired private Clients clients; @Autowired private PeerService peerService; @Autowired private PeerGateway peerGateway; @ApiOperation(value = "Invoked by local Acumos to get a list of catalogs available from a peer Acumos instance .", response = MLPCatalog.class, responseContainer = "List") @RequestMapping(value = FederationClient.CATALOGS_URI, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE) @ResponseBody public JsonResponse<List<MLPCatalog>> getCatalogs( HttpServletResponse response, @PathVariable("peerId") String peerId) {
code_review:  Please don't repeat the class name, use the MethodHandles.lookupClass() trick. 
target code: import org.acumos.cds.domain.MLPCatalog; import org.acumos.cds.domain.MLPSolution; import org.acumos.cds.domain.MLPPeer; import org.acumos.cds.domain.MLPPeerSubscription; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.GatewayClient; import org.acumos.federation.client.data.JsonResponse; /** * Controller bean for the internal (gateway) API. */ @Controller @CrossOrigin @Secured(Security.ROLE_INTERNAL) @RequestMapping(GatewayClient.PEER_PFX) public class GatewayController { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private Clients clients; @Autowired private PeerService peerService; @Autowired private PeerGateway peerGateway; @ApiOperation(value = "Invoked by local Acumos to get a list of catalogs available from a peer Acumos instance .", response = MLPCatalog.class, responseContainer = "List") @RequestMapping(value = FederationClient.CATALOGS_URI, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE) @ResponseBody public JsonResponse<List<MLPCatalog>> getCatalogs( HttpServletResponse response, @PathVariable("peerId") String peerId) {
response: import org.acumos.cds.domain.MLPCatalog; import org.acumos.cds.domain.MLPSolution; import org.acumos.cds.domain.MLPPeer; import org.acumos.cds.domain.MLPPeerSubscription; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.GatewayClient; import org.acumos.federation.client.data.JsonResponse; @Controller @CrossOrigin @Secured(Security.ROLE_INTERNAL) @RequestMapping(GatewayClient.PEER_PFX) public class GatewayController { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private Clients clients; @Autowired private PeerService peerService; @Autowired private PeerGateway peerGateway; @ApiOperation(value = "Invoked by local Acumos to get a list of catalogs available from a peer Acumos instance .", response = MLPCatalog.class, responseContainer = "List") @RequestMapping(value = FederationClient.CATALOGS_URI, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE) @ResponseBody public JsonResponse<List<MLPCatalog>> getCatalogs(HttpServletResponse response, @PathVariable("peerId") String peerId) { // code implementation } }

sample: 698
buggy_code: import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.User; import org.acumos.cds.domain.MLPPeer; import org.acumos.federation.client.config.TlsConfig; import org.acumos.federation.client.FederationClient; /** * Service bean implementing authentication and peer identification services * on requests to the Federation Gateway. */ @Configuration @EnableWebSecurity <|startfocus|> public class Security extends WebSecurityConfigurerAdapter { <|endfocus|> /** * The role indicating a peer is allowed to register. */ public static final String ROLE_REGISTER = "ROLE_REGISTRATION"; /** * The role indicating a peer is allowed to cancel their registration. */ public static final String ROLE_UNREGISTER = "ROLE_UNREGISTRATION"; /** * The role indicating a peer has normal access to the gateway. */ public static final String ROLE_PEER = "ROLE_PEER"; /** * The role indicating a peer has trusted access to the gateway. */
code_review:  would you possibly consider a less generic name, maybe GatewaySecurity or ? 
target code: import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.User; import org.acumos.cds.domain.MLPPeer; import org.acumos.federation.client.config.TlsConfig; import org.acumos.federation.client.FederationClient; /** * Service bean implementing authentication and peer identification services * on requests to the Federation Gateway. */ @Configuration @EnableWebSecurity public class Security extends WebSecurityConfigurerAdapter { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); /** * The role indicating a peer is allowed to register. */ public static final String ROLE_REGISTER = "ROLE_REGISTRATION"; /** * The role indicating a peer is allowed to cancel their registration. */ public static final String ROLE_UNREGISTER = "ROLE_UNREGISTRATION"; /** * The role indicating a peer has normal access to the gateway. */ public static final String ROLE_PEER = "ROLE_PEER"; /** * The role indicating a peer has trusted access to the gateway. */
response: import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.User; import org.acumos.cds.domain.MLPPeer; import org.acumos.federation.client.config.TlsConfig; import org.acumos.federation.client.FederationClient; @Configuration @EnableWebSecurity public class GatewaySecurity extends WebSecurityConfigurerAdapter { public static final String ROLE_REGISTER = "ROLE_REGISTRATION"; public static final String ROLE_UNREGISTER = "ROLE_UNREGISTRATION"; public static final String ROLE_PEER = "ROLE_PEER"; public static final String ROLE_TRUSTED_PEER = "ROLE_TRUSTED_PEER"; // Rest of the code... }

sample: 699
buggy_code:  if (alias == null) { Enumeration<String> aliases = ks.aliases(); while (aliases.hasMoreElements()) { alias = aliases.nextElement(); if (ks.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) { break; } } } myself = peerService.getSelf(getLdapNameField(new LdapName(((X509Certificate)ks.getCertificate(alias)).getSubjectX500Principal().getName()), "CN")); } } catch (Exception e) { myself = new MLPPeer(); <|startfocus|> myself.setStatusCode(PSC_UNKNOWN); <|endfocus|> }
code_review:  Please log the exception. Maybe this is normal, but it sure looks like a strange case, creating an empty peer 
target code: if (alias == null) { Enumeration<String> aliases = ks.aliases(); while (aliases.hasMoreElements()) { alias = aliases.nextElement(); if (ks.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) { break; } } } myself = peerService.getSelf(getLdapNameField(new LdapName(((X509Certificate)ks.getCertificate(alias)).getSubjectX500Principal().getName()), "CN")); } } catch (Exception e) { myself = new MLPPeer(); myself.setStatusCode(PSC_UNKNOWN); log.error("Cannot determine 'self' peer", e); }
response: if (alias == null) { Enumeration<String> aliases = ks.aliases(); while (aliases.hasMoreElements()) { alias = aliases.nextElement(); if (ks.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) { break; } } } try { myself = peerService.getSelf(getLdapNameField(new LdapName(((X509Certificate)ks.getCertificate(alias)).getSubjectX500Principal().getName()), "CN")); } catch (Exception e) { myself = new MLPPeer(); myself.setStatusCode(PSC_UNKNOWN); }

sample: 700
buggy_code:  logger.debug("JWTAuthorizationFilter() begin"); this.secretKey = secretKey; this.userService = new UserService(cdsClient); logger.debug("JWTAuthorizationFilter() end"); } /** * Method is called internally and should not be accessible directly using class instance. * */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { logger.debug("doFilterInternal() begin"); <|startfocus|> HttpServletRequest httpRequest = (HttpServletRequest) request; <|endfocus|> String authToken = null; authToken = httpRequest.getHeader(AUTHORIZATION_HEADER_KEY); logger.debug("AUTHORIZATION_HEADER_KEY : " + authToken); if (authToken == null) { authToken = httpRequest.getHeader(JWT_TOKEN_HEADER_KEY); logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); } if (authToken == null) { authToken = request.getParameter(JWT_TOKEN_HEADER_KEY); logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); } if (authToken != null) {
code_review:  This cast is not needed. Please remove. 
target code: logger.debug("JWTAuthorizationFilter() begin"); this.secretKey = secretKey; this.userService = new UserService(cdsClient); logger.debug("JWTAuthorizationFilter() end"); } /** * Method is called internally and should not be accessible directly using class instance. * */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { logger.debug("doFilterInternal() begin"); HttpServletRequest httpRequest = request; String authToken = null; authToken = httpRequest.getHeader(AUTHORIZATION_HEADER_KEY); logger.debug("AUTHORIZATION_HEADER_KEY : " + authToken); if (authToken == null) { authToken = httpRequest.getHeader(JWT_TOKEN_HEADER_KEY); logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); } if (authToken == null) { authToken = request.getParameter(JWT_TOKEN_HEADER_KEY); logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); } if (authToken != null) {
response: public void applyTo(TaskAttribute taskAttribute) { Assert.isNotNull(taskAttribute); TaskData taskData = taskAttribute.getTaskData(); TaskAttributeMapper mapper = taskData.getAttributeMapper(); taskAttribute.getMetaData().defaults().setType(TaskAttribute.TYPE_ATTACHMENT); if (getAttachmentId() != null) { mapper.setValue(taskAttribute, getAttachmentId()); } if (getAuthor() != null && getAuthor().getPersonId() != null) { TaskAttribute child = taskAttribute.createMappedAttribute(TaskAttribute.ATTACHMENT_AUTHOR); TaskAttributeMetaData defaults = child.getMetaData().defaults(); defaults.setType(TaskAttribute.TYPE_PERSON); defaults.setLabel("Attachment Author:"); mapper.setRepositoryPerson(child, getAuthor()); } if (getContentType() != null) { TaskAttribute child = taskAttribute.createMappedAttribute(TaskAttribute.ATTACHMENT_CONTENT_TYPE); TaskAttributeMetaData defaults = child.getMetaData().defaults(); defaults.setType(TaskAttribute.TYPE_SHORT_TEXT); defaults.setLabel("Content Type:"); mapper.setValue(child, getContentType()); } if (getCreationDate() != null) { // Rest of the code } }

sample: 701
buggy_code:  logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); } if (authToken != null) { authToken = authToken.replace(TOKEN_PASS_KEY, ""); logger.debug("TOKEN_PASS_KEY : " + authToken); JWTTokenVO jwtTokenVO = JwtTokenUtil.getUserToken(authToken, secretKey); if (jwtTokenVO != null <|startfocus|> && !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken)) { //validate token if (validateToken(jwtTokenVO, secretKey)) { <|endfocus|> MLPUser mlpUser = userService.findUserByUsername(jwtTokenVO.getUserName()); //TODO : Need to implement role base authority UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( new AuthenticatedUser(mlpUser), authToken, new ArrayList<>()); authentication.setDetails(new WebAuthenticationDetailsSource() .buildDetails(httpRequest)); SecurityContextHolder.getContext().setAuthentication(authentication); } } } chain.doFilter(request, response); logger.debug("doFilterInternal() End"); } private boolean validateToken(JWTTokenVO jwtTokenVO, String secretKey) { logger.debug("validateToken() Begin");
code_review:  no reason to separate these if conditions, please merge them. 
target code: logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); } if (authToken != null) { authToken = authToken.replace(TOKEN_PASS_KEY, ""); logger.debug("TOKEN_PASS_KEY : " + authToken); JWTTokenVO jwtTokenVO = JwtTokenUtil.getUserToken(authToken, secretKey); if (jwtTokenVO != null && !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken) && validateToken(jwtTokenVO, secretKey)) { //validate token MLPUser mlpUser = userService.findUserByUsername(jwtTokenVO.getUserName()); //TODO : Need to implement role base authority UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( new AuthenticatedUser(mlpUser), authToken, new ArrayList<>()); authentication.setDetails(new WebAuthenticationDetailsSource() .buildDetails(httpRequest)); SecurityContextHolder.getContext().setAuthentication(authentication); } } } chain.doFilter(request, response); logger.debug("doFilterInternal() End"); } private boolean validateToken(JWTTokenVO jwtTokenVO, String secretKey) { logger.debug("validateToken() Begin");
response: logger.debug("JWT_TOKEN_HEADER_KEY : " + authToken); if (authToken != null) { authToken = authToken.replace(TOKEN_PASS_KEY, ""); logger.debug("TOKEN_PASS_KEY : " + authToken); JWTTokenVO jwtTokenVO = JwtTokenUtil.getUserToken(authToken, secretKey); if (jwtTokenVO != null && !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken)) { //validate token if (validateToken(jwtTokenVO, secretKey)) { MLPUser mlpUser = userService.findUserByUsername(jwtTokenVO.getUserName()); //TODO : Need to implement role base authority UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( new AuthenticatedUser(mlpUser), authToken, new ArrayList<>()); authentication.setDetails(new WebAuthenticationDetailsSource() .buildDetails(httpRequest)); SecurityContextHolder.getContext().setAuthentication(authentication); } } } chain.doFilter(request, response); logger.debug("doFilterInternal() End"); private boolean validateToken(JWTTokenVO jwtTokenVO, String secretKey) { logger.debug("validateToken() Begin"); }

sample: 702
buggy_code:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.federation.client; import java.util.List; import org.acumos.cds.domain.MLPCatalog; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.config.TlsConfig; import org.acumos.federation.client.data.Catalog; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.GatewayClient; <|startfocus|> <|endfocus|> public class ClientDemo { private static final String peerApiUrl = "https://public.otheracumos.org:9084"; private static final String internalApiUrl = "https://federation-service:9011"; private static final String keystore = "keystore.jks"; private static final String keystorepass = "keystore_pass"; private static final String firstpeerid = "12345678-1234-1234-1234-1234567890ab"; private static final String secondpeerid = "cafebebe-cafe-bebe-cafe-bebecafebebe"; public static void main(String[] args) throws Exception { ClientConfig cconf = new ClientConfig();
code_review:  This is *great* but please add a few bits of javadoc, or if you've explained it in RST somewhere, add a link to that. 
target code: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.federation.client; import java.util.List; import org.acumos.cds.domain.MLPCatalog; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.config.TlsConfig; import org.acumos.federation.client.data.Catalog; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.GatewayClient; /** * Demonstrates use of the Federation (public "E5" interface) and * Gateway (private internal interface) clients. */ public class ClientDemo { private static final String peerApiUrl = "https://public.otheracumos.org:9084"; private static final String internalApiUrl = "https://federation-service:9011"; private static final String keystore = "keystore.jks"; private static final String keystorepass = "keystore_pass"; private static final String firstpeerid = "12345678-1234-1234-1234-1234567890ab"; private static final String secondpeerid = "cafebebe-cafe-bebe-cafe-bebecafebebe"; public static void main(String[] args) throws Exception { ClientConfig cconf = new ClientConfig();
response: package org.acumos.federation.client; import java.util.List; import org.acumos.cds.domain.MLPCatalog; import org.acumos.federation.client.config.ClientConfig; import org.acumos.federation.client.config.TlsConfig; import org.acumos.federation.client.data.Catalog; import org.acumos.federation.client.FederationClient; import org.acumos.federation.client.GatewayClient; public class ClientDemo { private static final String peerApiUrl = "https://public.otheracumos.org:9084"; private static final String internalApiUrl = "https://federation-service:9011"; private static final String keystore = "keystore.jks"; private static final String keystorepass = "keystore_pass"; private static final String firstpeerid = "12345678-1234-1234-1234-1234567890ab"; private static final String secondpeerid = "cafebebe-cafe-bebe-cafe-bebecafebebe"; public static void main(String[] args) throws Exception { ClientConfig cconf = new ClientConfig(); TlsConfig tlsConfig = new TlsConfig(keystore, keystorepass); cconf.setTlsConfig(tlsConfig); cconf.setPeerApiUrl(peerApiUrl); cconf.setInternalApiUrl(internalApiUrl); FederationClient federationClient = new FederationClient(cconf); GatewayClient gatewayClient = federationClient.getGatewayClient(); List<Catalog> catalogs = gatewayClient.getCatalogs(); for (Catalog catalog : catalogs) { System.out.println("Catalog ID: " + catalog.getCatalogId()); System.out.println("Catalog Name: " + catalog.getCatalogName()); System.out.println("Catalog Description: " + catalog.getCatalogDescription()); System.out.println("Catalog Owner: " + catalog.getCatalogOwner()); System.out.println("Catalog Type: " + catalog.getCatalogType()); System.out.println("Catalog URL: " + catalog.getCatalogUrl()); System.out.println("Catalog Created: " + catalog.getCreated()); System.out.println("Catalog Modified: " + catalog.getModified()); System.out.println("Catalog Metadata: " + catalog.getMetadata()); System.out.println("Catalog Active: " + catalog.isActive()); System.out.println("Catalog Deleted: " + catalog.isDeleted()); System.out.println

sample: 703
buggy_code:  private static final String keystorepass = "keystore_pass"; private static final String firstpeerid = "12345678-1234-1234-1234-1234567890ab"; private static final String secondpeerid = "cafebebe-cafe-bebe-cafe-bebecafebebe"; public static void main(String[] args) throws Exception { ClientConfig cconf = new ClientConfig(); cconf.setSsl(new TlsConfig()); cconf.getSsl().setKeyStore(keystore); cconf.getSsl().setKeyStorePassword(keystorepass); <|startfocus|> FederationClient fedclient = new FederationClient(peerApiUrl, cconf); <|endfocus|> System.out.println("Listing remote acumos catalogs using public E5 interface"); for (MLPCatalog mcat: fedclient.getCatalogs()) { System.out.println("Catalog " + mcat.getName() + " has " + ((Catalog)mcat).getSize() + " models"); } GatewayClient gwclient = new GatewayClient(internalApiUrl, cconf); System.out.println("Fetching first peer's catalogs from inside Acumos using private interface"); for (MLPCatalog mcat: gwclient.getCatalogs(firstpeerid)) {
code_review:  Would you please add a PING (healthcheck) as the first item demonstrated? 
target code: private static final String keystorepass = "keystore_pass"; private static final String firstpeerid = "12345678-1234-1234-1234-1234567890ab"; private static final String secondpeerid = "cafebebe-cafe-bebe-cafe-bebecafebebe"; public static void main(String[] args) throws Exception { ClientConfig cconf = new ClientConfig(); cconf.setSsl(new TlsConfig()); cconf.getSsl().setKeyStore(keystore); cconf.getSsl().setKeyStorePassword(keystorepass); FederationClient fedclient = new FederationClient(peerApiUrl, cconf); System.out.println("Checking connectivity to remote acumos using public E5 interface"); System.out.println("Response from remote acumos is " + fedclient.ping()); System.out.println("Listing remote acumos catalogs using public E5 interface"); for (MLPCatalog mcat: fedclient.getCatalogs()) { System.out.println("Catalog " + mcat.getName() + " has " + ((Catalog)mcat).getSize() + " models"); } GatewayClient gwclient = new GatewayClient(internalApiUrl, cconf); System.out.println("Fetching first peer's catalogs from inside Acumos using private interface"); for (MLPCatalog mcat: gwclient.getCatalogs(firstpeerid)) {
response: private static final String keystorepass = "keystore_pass"; private static final String firstpeerid = "12345678-1234-1234-1234-1234567890ab"; private static final String secondpeerid = "cafebebe-cafe-bebe-cafe-bebecafebebe"; public static void main(String[] args) throws Exception { ClientConfig cconf = new ClientConfig(); cconf.setSsl(new TlsConfig()); cconf.getSsl().setKeyStore(keystore); cconf.getSsl().setKeyStorePassword(keystorepass); FederationClient fedclient = new FederationClient(peerApiUrl, cconf); System.out.println("Listing remote acumos catalogs using public E5 interface"); for (MLPCatalog mcat : fedclient.getCatalogs()) { System.out.println("Catalog " + mcat.getName() + " has " + ((Catalog) mcat).getSize() + " models"); } GatewayClient gwclient = new GatewayClient(internalApiUrl, cconf); System.out.println("Fetching first peer's catalogs from inside Acumos using private interface"); for (MLPCatalog mcat : gwclient.getCatalogs(firstpeerid)) { System.out.println("Catalog " + mcat.getName() + " has " + ((Catalog) mcat).getSize() + " models"); } }

sample: 704
buggy_code: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(value = "/") public class PipeLineServiceController { <|startfocus|> /** * */ <|endfocus|> private static final String PIPELINE_INPROGRESS = "IP"; private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired @Qualifier("InputValidationServiceImpl") private InputValidationService inputValidationService; @Autowired @Qualifier("PipeLineValidationServiceImpl") private PipeLineValidationService pipeLineValidationService; @Autowired @Qualifier("PipeLineServiceImpl") private PipeLineService pipeLineService; @Autowired private PipeLineCacheService pipelineCacheService; /** * Creates new independent Pipeline for a user. * @param authenticatedUserId
code_review:  remove empty comment 
target code: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(value = "/") public class PipeLineServiceController { private static final String PIPELINE_INPROGRESS = "IP"; private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired @Qualifier("InputValidationServiceImpl") private InputValidationService inputValidationService; @Autowired @Qualifier("PipeLineValidationServiceImpl") private PipeLineValidationService pipeLineValidationService; @Autowired @Qualifier("PipeLineServiceImpl") private PipeLineService pipeLineService; @Autowired private PipeLineCacheService pipelineCacheService; /** * Creates new independent Pipeline for a user. * @param authenticatedUserId
response: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(value = "/") public class PipeLineServiceController { private static final String PIPELINE_INPROGRESS = "IP"; private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired @Qualifier("InputValidationServiceImpl") private InputValidationService inputValidationService; @Autowired @Qualifier("PipeLineValidationServiceImpl") private PipeLineValidationService pipeLineValidationService; @Autowired @Qualifier("PipeLineServiceImpl") private PipeLineService pipeLineService; @Autowired private PipeLineCacheService pipelineCacheService; /** * Creates new independent Pipeline for a user. * @param authenticatedUserId */ @RequestMapping(value = "/createPipeline/{authenticatedUserId}", method = RequestMethod.POST) @ResponseBody public ResponseEntity<String> createPipeline(@PathVariable String authenticatedUserId, @RequestBody PipelineRequest pipelineRequest) { // Implementation code here } /** * Retrieves the status of a pipeline. * @param authenticatedUserId * @param pipelineId */ @RequestMapping(value = "/getPipelineStatus/{authenticatedUserId}/{pipelineId}", method = RequestMethod.GET) @ResponseBody public ResponseEntity<String> getPipelineStatus(@PathVariable String authenticatedUserId, @PathVariable String pipelineId) { // Implementation code here } /** * Updates the status of a pipeline. * @param authenticatedUserId * @param pipelineId * @param pipelineStatus */ @RequestMapping(value = "/updatePipelineStatus/{authenticatedUserId}/{pipelineId}/{pipelineStatus}", method = RequestMethod.PUT) @ResponseBody public ResponseEntity<String> updatePipelineStatus(@PathVariable String authenticatedUserId, @PathVariable String pipelineId, @PathVariable String pipelineStatus) { // Implementation code here } /** * Deletes a pipeline. * @param authenticatedUserId * @param pipelineId */ @RequestMapping(value = "/deletePipeline/{authenticatedUserId}/{pipelineId}", method = RequestMethod.DELETE) @ResponseBody public

sample: 705
buggy_code:  } else { logger.debug("Skipping flow creation...flow " + pipelineName + " already exists for user " + acumosLoginId + " in NiFi Registry."); // THROW AN EXCEPTION TO MLWB-UI - REQUESTED PIPELINE NAME ALREADY EXISTS BOTH IN NIFI IN AND REGISTRY throw new DuplicatePipeLineException("Request PipeLine Name : " + pipelineName + " already Exists in Both NiFi Server and NiFi Registry"); } logger.debug("NiFi createPipeline() end"); return flowURL; } <|startfocus|> <|endfocus|> public boolean checkifNifiPodRunning(String acumosLoginId) { boolean nifiPodRunning = false; logger.debug("checkifNifiPodRunning() begin"); nifiPodRunning = createNiFi.checkifNifiPodRunning(acumosLoginId); logger.debug("checkifNifiPodRunning() End"); return nifiPodRunning; } public String createNiFiInstance(String acumosLoginId) { logger.debug("createNiFiInstance() Begin"); String nifiURL = null; // Call the Kubernetes API to create a NiFi Instance try { nifiURL = createNiFi.createNiFiInstanceForUser(acumosLoginId);
code_review:  Java Doc is missingc 
target code: } else { logger.debug("Skipping flow creation...flow " + pipelineName + " already exists for user " + acumosLoginId + " in NiFi Registry."); // THROW AN EXCEPTION TO MLWB-UI - REQUESTED PIPELINE NAME ALREADY EXISTS BOTH IN NIFI IN AND REGISTRY throw new DuplicatePipeLineException("Request PipeLine Name : " + pipelineName + " already Exists in Both NiFi Server and NiFi Registry"); } logger.debug("NiFi createPipeline() end"); return flowURL; } /** * This method will check if the NiFi POD is running or not * @param acumosLoginId * Accepts acumosLoginId as parameter * @return * boolean as true/false */ public boolean checkifNifiPodRunning(String acumosLoginId) { boolean nifiPodRunning = false; logger.debug("checkifNifiPodRunning() begin"); nifiPodRunning = createNiFi.checkifNifiPodRunning(acumosLoginId); logger.debug("checkifNifiPodRunning() End"); return nifiPodRunning; } public String createNiFiInstance(String acumosLoginId) { logger.debug("createNiFiInstance() Begin"); String nifiURL = null; // Call the Kubernetes API to create a NiFi Instance try { nifiURL = createNiFi.createNiFiInstanceForUser(acumosLoginId);
response: import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class MyClass { private static final Logger logger = LoggerFactory.getLogger(MyClass.class); public void createPipeline(String pipelineName, String acumosLoginId) throws DuplicatePipeLineException { logger.debug("createPipeline() begin"); // Check if the pipeline already exists in NiFi and NiFi Registry boolean pipelineExists = checkPipelineExists(pipelineName, acumosLoginId); if (pipelineExists) { logger.debug("Skipping flow creation...flow {} already exists for user {} in NiFi Registry.", pipelineName, acumosLoginId); throw new DuplicatePipeLineException("Requested Pipeline Name: " + pipelineName + " already exists in both NiFi Server and NiFi Registry"); } // Create the pipeline in NiFi String flowURL = createPipelineInNiFi(pipelineName, acumosLoginId); logger.debug("NiFi createPipeline() end"); return flowURL; } public boolean checkifNifiPodRunning(String acumosLoginId) { boolean nifiPodRunning = false; logger.debug("checkifNifiPodRunning() begin"); nifiPodRunning = createNiFi.checkifNifiPodRunning(acumosLoginId); logger.debug("checkifNifiPodRunning() End"); return nifiPodRunning; } public String createNiFiInstance(String acumosLoginId) { logger.debug("createNiFiInstance() Begin"); String nifiURL = null; // Call the Kubernetes API to create a NiFi Instance try { nifiURL = createNiFi.createNiFiInstanceForUser(acumosLoginId); logger.debug("createNiFiInstance() End"); } catch (Exception e) { logger.error("Failed to create NiFi instance for user {}", acumosLoginId, e); } return nifiURL; } private boolean checkPipelineExists(String pipelineName, String acumosLoginId) { // Implementation to check if the pipeline exists in NiFi and NiFi Registry } private String createPipelineInNiFi(String pipelineName, String acumosLoginId) { // Implementation to create the pipeline in NiFi } }

sample: 706
buggy_code:  throw new DuplicatePipeLineException("Request PipeLine Name : " + pipelineName + " already Exists in Both NiFi Server and NiFi Registry"); } logger.debug("NiFi createPipeline() end"); return flowURL; } public boolean checkifNifiPodRunning(String acumosLoginId) { boolean nifiPodRunning = false; logger.debug("checkifNifiPodRunning() begin"); nifiPodRunning = createNiFi.checkifNifiPodRunning(acumosLoginId); logger.debug("checkifNifiPodRunning() End"); return nifiPodRunning; } <|startfocus|> <|endfocus|> public String createNiFiInstance(String acumosLoginId) { logger.debug("createNiFiInstance() Begin"); String nifiURL = null; // Call the Kubernetes API to create a NiFi Instance try { nifiURL = createNiFi.createNiFiInstanceForUser(acumosLoginId); } catch (NiFiInstanceCreationException e) { logger.error("Exception occured while creating NiFi Instance for User",e); throw new NiFiInstanceCreationException("Exception occured while creating NiFi Instance for User "); } logger.debug("createNiFiInstance() End"); return nifiURL; } 
code_review:  Java Doc missing 
target code: throw new DuplicatePipeLineException("Request PipeLine Name : " + pipelineName + " already Exists in Both NiFi Server and NiFi Registry"); } logger.debug("NiFi createPipeline() end"); return flowURL; } public boolean checkifNifiPodRunning(String acumosLoginId) { boolean nifiPodRunning = false; logger.debug("checkifNifiPodRunning() begin"); nifiPodRunning = createNiFi.checkifNifiPodRunning(acumosLoginId); logger.debug("checkifNifiPodRunning() End"); return nifiPodRunning; } /** * This method will create the Instance of NiFi * @param acumosLoginId * Accepts acumosLoginId as parameter * @return * NiFi URL */ public String createNiFiInstance(String acumosLoginId) { logger.debug("createNiFiInstance() Begin"); String nifiURL = null; // Call the Kubernetes API to create a NiFi Instance try { nifiURL = createNiFi.createNiFiInstanceForUser(acumosLoginId); } catch (NiFiInstanceCreationException e) { logger.error("Exception occured while creating NiFi Instance for User",e); throw new NiFiInstanceCreationException("Exception occured while creating NiFi Instance for User "); } logger.debug("createNiFiInstance() End"); return nifiURL; }
response: public void clearCandidates() { fTraceTypes.clear(); fTraceFiles.clear(); } public String createNiFiInstance(String acumosLoginId) { logger.debug("createNiFiInstance() Begin"); String nifiURL = null; // Call the Kubernetes API to create a NiFi Instance try { nifiURL = createNiFi.createNiFiInstanceForUser(acumosLoginId); } catch (NiFiInstanceCreationException e) { logger.error("Exception occurred while creating NiFi Instance for User", e); throw new NiFiInstanceCreationException("Exception occurred while creating NiFi Instance for User"); } logger.debug("createNiFiInstance() End"); return nifiURL; }

sample: 707
buggy_code: */ package org.acumos.workbench.pipelineservice.service; import java.lang.invoke.MethodHandles; import org.acumos.workbench.common.vo.Pipeline; import org.acumos.workbench.pipelineservice.exception.DuplicateRequestException; import org.acumos.workbench.pipelineservice.util.MLWBRequestCache; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class PipeLineCacheService { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private MLWBRequestCache requestCache; <|startfocus|> <|endfocus|> public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } 
code_review:  Java Doc missing 
target code: */ package org.acumos.workbench.pipelineservice.service; import java.lang.invoke.MethodHandles; import org.acumos.workbench.common.vo.Pipeline; import org.acumos.workbench.pipelineservice.exception.DuplicateRequestException; import org.acumos.workbench.pipelineservice.util.MLWBRequestCache; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class PipeLineCacheService { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private MLWBRequestCache requestCache; /** * This method will put the create request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); }
response: package org.acumos.workbench.pipelineservice.service; import java.lang.invoke.MethodHandles; import org.acumos.workbench.common.vo.Pipeline; import org.acumos.workbench.pipelineservice.exception.DuplicateRequestException; import org.acumos.workbench.pipelineservice.util.MLWBRequestCache; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class PipeLineCacheService { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private MLWBRequestCache requestCache; public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } }

sample: 708
buggy_code:  private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private MLWBRequestCache requestCache; public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } <|startfocus|> <|endfocus|> public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } 
code_review:  Java Doc missing 
target code: private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private MLWBRequestCache requestCache; public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } /** * This method will remove the create request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); }
response: private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private MLWBRequestCache requestCache; public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); }

sample: 709
buggy_code:  public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } <|startfocus|> <|endfocus|> public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } 
code_review:  Java Doc missing 
target code: public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } /** * This method will put update request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); }
response: /** * This method puts a create request into the request cache. * If the request already exists, it throws a DuplicateRequestException. * * @param requestId The ID of the request * @param pipeline The pipeline object */ public void putCreateRequest(String requestId, Pipeline pipeline) { logger.debug("putCreateRequest() Begin "); Boolean exist = requestCache.checkIfCreateRequestExists(requestId, pipeline); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addCreateRequest(requestId, pipeline); } logger.debug("putCreateRequest() End"); } /** * This method removes a create request from the request cache. * * @param requestId The ID of the request * @param pipeline The pipeline object */ public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } /** * This method puts an update request into the request cache. * If the request already exists, it throws a DuplicateRequestException. * * @param requestId The ID of the request * @param pipeline The pipeline object */ public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } /** * This method removes an update request from the request cache. * * @param requestId The ID of the request * @param pipeline The pipeline object */ public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } */

sample: 710
buggy_code:  } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } <|startfocus|> <|endfocus|> public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } public void putDeleteRequest(String requestId, String pipelineId) { logger.debug("putDeleteRequest() Begin "); Boolean exist = requestCache.checkIfDeleteRequestExists(requestId, pipelineId); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addDeleteRequest(requestId, pipelineId); } logger.debug("putDeleteRequest() End "); } 
code_review:  Java Doc missing 
target code: } public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } /** * This method will remove update request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } public void putDeleteRequest(String requestId, String pipelineId) { logger.debug("putDeleteRequest() Begin "); Boolean exist = requestCache.checkIfDeleteRequestExists(requestId, pipelineId); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addDeleteRequest(requestId, pipelineId); } logger.debug("putDeleteRequest() End "); }
response: /** * This method removes the create request from the request cache. * * @param requestId The ID of the create request. * @param pipeline The pipeline associated with the create request. */ public void removeCreateRequest(String requestId, Pipeline pipeline) { requestCache.removeCreateRequest(requestId); } /** * This method puts the update request into the request cache. * * @param requestId The ID of the update request. * @param pipeline The pipeline associated with the update request. * @throws DuplicateRequestException If a duplicate request is found. */ public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } /** * This method removes the update request from the request cache. * * @param requestId The ID of the update request. * @param pipeline The pipeline associated with the update request. */ public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } /** * This method puts the delete request into the request cache. * * @param requestId The ID of the delete request. * @param pipelineId The ID of the pipeline associated with the delete request. * @throws DuplicateRequestException If a duplicate request is found. */ public void putDeleteRequest(String requestId, String pipelineId) { logger.debug("putDeleteRequest() Begin "); Boolean exist = requestCache.checkIfDeleteRequestExists(requestId, pipelineId); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addDeleteRequest(requestId, pipelineId); } logger.debug("putDeleteRequest() End "); }

sample: 711
buggy_code:  } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } <|startfocus|> <|endfocus|> public void putDeleteRequest(String requestId, String pipelineId) { logger.debug("putDeleteRequest() Begin "); Boolean exist = requestCache.checkIfDeleteRequestExists(requestId, pipelineId); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addDeleteRequest(requestId, pipelineId); } logger.debug("putDeleteRequest() End "); } public void removeDeleteRequest(String requestId, String pipelineId) { requestCache.removeDeleteRequest(requestId); } 
code_review:  Java Doc missing 
target code: } public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } /** * This method will put delete request * @param requestId * Accepts the requestId as parameter * @param pipelineId * Accepts the pipelineId as parameter * */ public void putDeleteRequest(String requestId, String pipelineId) { logger.debug("putDeleteRequest() Begin "); Boolean exist = requestCache.checkIfDeleteRequestExists(requestId, pipelineId); if(exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addDeleteRequest(requestId, pipelineId); } logger.debug("putDeleteRequest() End "); } public void removeDeleteRequest(String requestId, String pipelineId) { requestCache.removeDeleteRequest(requestId); }
response: /** * This method puts an update request into the request cache. * If the request already exists, it throws a DuplicateRequestException. * * @param requestId The ID of the request * @param pipeline The pipeline object */ public void putUpdateRequest(String requestId, Pipeline pipeline) { logger.debug("putUpdateRequest() Begin "); Boolean exist = requestCache.checkIfUpdateRequestExists(requestId, pipeline); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addUpdateRequest(requestId, pipeline); } logger.debug("putUpdateRequest() End "); } /** * This method removes an update request from the request cache. * * @param requestId The ID of the request * @param pipeline The pipeline object */ public void removeUpdateRequest(String requestId, Pipeline pipeline) { requestCache.removeUpdateRequest(requestId); } /** * This method puts a delete request into the request cache. * If the request already exists, it throws a DuplicateRequestException. * * @param requestId The ID of the request * @param pipelineId The ID of the pipeline */ public void putDeleteRequest(String requestId, String pipelineId) { logger.debug("putDeleteRequest() Begin "); Boolean exist = requestCache.checkIfDeleteRequestExists(requestId, pipelineId); if (exist) { logger.error("Duplicate Request Exception ocured. "); throw new DuplicateRequestException(); } else { requestCache.addDeleteRequest(requestId, pipelineId); } logger.debug("putDeleteRequest() End "); } /** * This method removes a delete request from the request cache. * * @param requestId The ID of the request * @param pipelineId The ID of the pipeline */ public void removeDeleteRequest(String requestId, String pipelineId) { requestCache.removeDeleteRequest(requestId); }

sample: 712
buggy_code:  @ApplicationScope @Component public class MLWBRequestCache implements Serializable { private static final long serialVersionUID = -4688732173089705360L; private Map<String, Pipeline> createRequests; // Key is Request Id and value is pipeline input private Map<String, Pipeline> updateRequests; // Key is Request Id and value is pipeline input private Map<String, String> deleteRequests; // Key is Request Id and value is pipeline Id private Map<String, String> archiveRequests; // Key is Request Id and value is pipeline Id <|startfocus|> <|endfocus|> public MLWBRequestCache() { createRequests = new HashMap<String, Pipeline>(); updateRequests = new HashMap<String, Pipeline>(); deleteRequests = new HashMap<String, String>(); archiveRequests = new HashMap<String, String>(); } public void addCreateRequest(String key, Pipeline value) { createRequests.put(key, value); } public void removeCreateRequest(String key) { createRequests.remove(key); } public Pipeline getCreateRequestByKey(String key) { if(createRequests.containsKey(key)) { return createRequests.get(key);
code_review:  Java Doc missing 
target code: @ApplicationScope @Component public class MLWBRequestCache implements Serializable { private static final long serialVersionUID = -4688732173089705360L; private Map<String, Pipeline> createRequests; // Key is Request Id and value is pipeline input private Map<String, Pipeline> updateRequests; // Key is Request Id and value is pipeline input private Map<String, String> deleteRequests; // Key is Request Id and value is pipeline Id private Map<String, String> archiveRequests; // Key is Request Id and value is pipeline Id /** * Constructor */ public MLWBRequestCache() { createRequests = new HashMap<String, Pipeline>(); updateRequests = new HashMap<String, Pipeline>(); deleteRequests = new HashMap<String, String>(); archiveRequests = new HashMap<String, String>(); } public void addCreateRequest(String key, Pipeline value) { createRequests.put(key, value); } public void removeCreateRequest(String key) { createRequests.remove(key); } public Pipeline getCreateRequestByKey(String key) { if(createRequests.containsKey(key)) { return createRequests.get(key);
response: @ApplicationScope @Component public class MLWBRequestCache implements Serializable { private static final long serialVersionUID = -4688732173089705360L; private Map<String, Pipeline> createRequests; private Map<String, Pipeline> updateRequests; private Map<String, String> deleteRequests; private Map<String, String> archiveRequests; public MLWBRequestCache() { createRequests = new HashMap<String, Pipeline>(); updateRequests = new HashMap<String, Pipeline>(); deleteRequests = new HashMap<String, String>(); archiveRequests = new HashMap<String, String>(); } public void addCreateRequest(String key, Pipeline value) { createRequests.put(key, value); } public void removeCreateRequest(String key) { createRequests.remove(key); } public Pipeline getCreateRequestByKey(String key) { if (createRequests.containsKey(key)) { return createRequests.get(key); } return null; } }

sample: 713
buggy_code:  private Map<String, String> deleteRequests; // Key is Request Id and value is pipeline Id private Map<String, String> archiveRequests; // Key is Request Id and value is pipeline Id public MLWBRequestCache() { createRequests = new HashMap<String, Pipeline>(); updateRequests = new HashMap<String, Pipeline>(); deleteRequests = new HashMap<String, String>(); archiveRequests = new HashMap<String, String>(); } <|startfocus|> <|endfocus|> public void addCreateRequest(String key, Pipeline value) { createRequests.put(key, value); } public void removeCreateRequest(String key) { createRequests.remove(key); } public Pipeline getCreateRequestByKey(String key) { if(createRequests.containsKey(key)) { return createRequests.get(key); } return null; } /** * Check if request with given requestId or Pipeline already exists in the cache. * @param key * request Id * @param value * Pipeline * @return boolean
code_review:  Java Doc missing 
target code: private Map<String, String> deleteRequests; // Key is Request Id and value is pipeline Id private Map<String, String> archiveRequests; // Key is Request Id and value is pipeline Id public MLWBRequestCache() { createRequests = new HashMap<String, Pipeline>(); updateRequests = new HashMap<String, Pipeline>(); deleteRequests = new HashMap<String, String>(); archiveRequests = new HashMap<String, String>(); } /** * This method will Add Create Request * @param key * Accepts key as parameter * @param value * Accepts value as parameter */ public void addCreateRequest(String key, Pipeline value) { createRequests.put(key, value); } public void removeCreateRequest(String key) { createRequests.remove(key); } public Pipeline getCreateRequestByKey(String key) { if(createRequests.containsKey(key)) { return createRequests.get(key); } return null; } /** * Check if request with given requestId or Pipeline already exists in the cache. * @param key * request Id * @param value * Pipeline * @return boolean
response: private Map<String, String> deleteRequests; private Map<String, String> archiveRequests; public MLWBRequestCache() { createRequests = new HashMap<String, Pipeline>(); updateRequests = new HashMap<String, Pipeline>(); deleteRequests = new HashMap<String, String>(); archiveRequests = new HashMap<String, String>(); } public void addCreateRequest(String key, Pipeline value) { createRequests.put(key, value); } public void removeCreateRequest(String key) { createRequests.remove(key); } public Pipeline getCreateRequestByKey(String key) { if (createRequests.containsKey(key)) { return createRequests.get(key); } return null; } /** * Check if request with given requestId or Pipeline already exists in the cache. * * @param key request Id * @param value Pipeline * @return boolean */ public boolean checkRequestExists(String key, Pipeline value) { return createRequests.containsKey(key) || createRequests.containsValue(value); }

sample: 714
buggy_code:  List<Nodes> nodesList = new ArrayList<Nodes>(); nodesList.add(node); cdump.setNodes(nodesList); String nodeId = "123"; String userId = "123"; //try { when(props.getPackagepath()).thenReturn("org/acumos/vo/"); when(props.getClassName()).thenReturn("DataVO"); Resource resource1 = resourceLoader.getResource(PROTOBUF_TEMPLATE_NAME) ; when(resourceLoader.getResource("classpath:Protobuf_Template.txt")).thenReturn(resource1); <|startfocus|> //when(resourceLoader.getInputStream()).thenReturn(inputStream); //gdmServiceImpl.createDeployGDM(cdump, nodeId, userId); //} catch (ServiceException e) { // e.printStackTrace(); //} <|endfocus|> 
code_review:  remove commented code if not required 
target code: List<Nodes> nodesList = new ArrayList<Nodes>(); nodesList.add(node); cdump.setNodes(nodesList); String nodeId = "123"; String userId = "123"; //try { when(props.getPackagepath()).thenReturn("org/acumos/vo/"); when(props.getClassName()).thenReturn("DataVO"); Resource resource1 = resourceLoader.getResource(PROTOBUF_TEMPLATE_NAME) ; when(resourceLoader.getResource("classpath:Protobuf_Template.txt")).thenReturn(resource1); gdmServiceImpl.createDeployGDM(cdump, nodeId, userId); } catch (ServiceException e) { e.printStackTrace(); }
response: List<Nodes> nodesList = new ArrayList<Nodes>(); nodesList.add(node); cdump.setNodes(nodesList); String nodeId = "123"; String userId = "123"; Resource resource1 = resourceLoader.getResource(PROTOBUF_TEMPLATE_NAME); when(resourceLoader.getResource("classpath:Protobuf_Template.txt")).thenReturn(resource1);

sample: 715
buggy_code:  * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ /** * */ package org.acumos.designstudio.test; <|startfocus|> import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; <|endfocus|> import java.lang.invoke.MethodHandles; import java.util.ArrayList; import java.util.List; import java.util.Properties; import org.acumos.designstudio.ce.util.ConfigurationProperties; import org.acumos.designstudio.ce.vo.DSSolution; import org.acumos.designstudio.ce.vo.MatchingModel; import org.acumos.designstudio.ce.vo.SuccessErrorMessage; import org.acumos.designstudio.ce.vo.blueprint.BPCollatorMap; import org.acumos.designstudio.ce.vo.blueprint.BPDataBrokerMap;
code_review:  Please remove empty comment 
target code: * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ /** * */ package org.acumos.designstudio.test; import static org.junit.Assert.*; import java.lang.invoke.MethodHandles; import java.util.ArrayList; import java.util.List; import java.util.Properties; import org.acumos.designstudio.ce.util.ConfigurationProperties; import org.acumos.designstudio.ce.vo.DSSolution; import org.acumos.designstudio.ce.vo.MatchingModel; import org.acumos.designstudio.ce.vo.SuccessErrorMessage; import org.acumos.designstudio.ce.vo.blueprint.BPCollatorMap; import org.acumos.designstudio.ce.vo.blueprint.BPDataBrokerMap;
response: package org.eclipse.egit.ui.internal.rebase; import java.util.LinkedList; import java.util.List; import org.eclipse.egit.core.internal.rebase.RebaseInteractivePlan; import org.eclipse.jface.viewers.ITreeContentProvider; import org.eclipse.jface.viewers.Viewer; import org.eclipse.jgit.lib.RebaseTodoLine; public enum RebaseInteractivePlanContentProvider implements ITreeContentProvider { INSTANCE; private RebaseInteractivePlanContentProvider() { } public void dispose() { } public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { } public Object[] getElements(Object inputElement) { if (inputElement instanceof RebaseInteractivePlan) { RebaseInteractivePlan plan = (RebaseInteractivePlan) inputElement; List<RebaseTodoLine> lines = plan.getLines(); return lines.toArray(); } return new Object[0]; } public Object[] getChildren(Object parentElement) { return new Object[0]; } public Object getParent(Object element) { return null; } public boolean hasChildren(Object element) { return false; } }

sample: 716
buggy_code:  import com.google.common.collect.Lists; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.ApiKey; import springfox.documentation.service.AuthorizationScope; import springfox.documentation.service.Contact; import springfox.documentation.service.SecurityReference; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spi.service.contexts.SecurityContext; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfiguration { <|startfocus|> <|endfocus|> @Bean public Docket swaggerSpringfoxDocket() { Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .forCodeGeneration(true) .genericModelSubstitutes(ResponseEntity.class) .ignoredParameterTypes(Pageable.class) .ignoredParameterTypes(java.sql.Date.class) .directModelSubstitute(java.time.LocalDate.class, java.sql.Date.class) .directModelSubstitute(java.time.ZonedDateTime.class, Date.class) .directModelSubstitute(java.time.LocalDateTime.class, Date.class) .securityContexts(Lists.newArrayList(securityContext()))
code_review:  Class is not formatted. 
target code: import com.google.common.collect.Lists; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.ApiKey; import springfox.documentation.service.AuthorizationScope; import springfox.documentation.service.Contact; import springfox.documentation.service.SecurityReference; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spi.service.contexts.SecurityContext; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfiguration { @Bean public Docket swaggerSpringfoxDocket() { Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .forCodeGeneration(true) .genericModelSubstitutes(ResponseEntity.class) .ignoredParameterTypes(Pageable.class) .ignoredParameterTypes(java.sql.Date.class) .directModelSubstitute(java.time.LocalDate.class, java.sql.Date.class) .directModelSubstitute(java.time.ZonedDateTime.class, Date.class) .directModelSubstitute(java.time.LocalDateTime.class, Date.class) .securityContexts(Lists.newArrayList(securityContext()))
response: import com.google.common.collect.Lists; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.ApiKey; import springfox.documentation.service.AuthorizationScope; import springfox.documentation.service.Contact; import springfox.documentation.service.SecurityReference; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spi.service.contexts.SecurityContext; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfiguration { @Bean public Docket swaggerSpringfoxDocket() { Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .forCodeGeneration(true) .genericModelSubstitutes(ResponseEntity.class) .ignoredParameterTypes(Pageable.class) .ignoredParameterTypes(java.sql.Date.class) .directModelSubstitute(java.time.LocalDate.class, java.sql.Date.class) .directModelSubstitute(java.time.ZonedDateTime.class, Date.class) .directModelSubstitute(java.time.LocalDateTime.class, Date.class) .securityContexts(Lists.newArrayList(securityContext())); return docket; } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title("API Documentation") .description("API Documentation") .version("1.0") .contact(new Contact("Name", "URL", "email@example.com")) .build(); } private SecurityContext securityContext() { return SecurityContext.builder() .securityReferences(defaultAuth()) .forPaths(PathSelectors.any()) .build(); } private List<SecurityReference> defaultAuth() { AuthorizationScope authorizationScope = new AuthorizationScope("global", "accessEverything"); AuthorizationScope[] authorizationScopes = new AuthorizationScope[]{authorizationScope}; return Lists.newArrayList(new SecurityReference("apiKey", authorizationScopes)); } }

sample: 717
buggy_code:  } // Secure the endpoints with HTTP Basic authentication @Override protected void configure(HttpSecurity http) throws Exception { http .csrf().disable() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers("/swagger-ui.html").permitAll() .anyRequest().authenticated() .and() .addFilterBefore(jwtAuthorizationFilterBean(), UsernamePasswordAuthenticationFilter.class); } @Bean public JWTAuthorizationFilter jwtAuthorizationFilterBean() throws Exception { <|startfocus|> JWTAuthorizationFilter jwtAuthorizationFilter = new JWTAuthorizationFilter(authenticationManagerBean(),conf.getJwtSecretKey(), cdsClient); <|endfocus|> return jwtAuthorizationFilter; } } 
code_review:  Please format the code 
target code: } // Secure the endpoints with HTTP Basic authentication @Override protected void configure(HttpSecurity http) throws Exception { http .csrf().disable() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers("/swagger-ui.html").permitAll() .anyRequest().authenticated() .and() .addFilterBefore(jwtAuthorizationFilterBean(), UsernamePasswordAuthenticationFilter.class); } @Bean public JWTAuthorizationFilter jwtAuthorizationFilterBean() throws Exception { JWTAuthorizationFilter jwtAuthorizationFilter = new JWTAuthorizationFilter(authenticationManagerBean(), conf.getJwtSecretKey(), cdsClient); return jwtAuthorizationFilter; } }
response: // Secure the endpoints with HTTP Basic authentication @Override protected void configure(HttpSecurity http) throws Exception { http .csrf().disable() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers("/swagger-ui.html").permitAll() .anyRequest().authenticated() .and() .addFilterBefore(jwtAuthorizationFilterBean(), UsernamePasswordAuthenticationFilter.class); } @Bean public JWTAuthorizationFilter jwtAuthorizationFilterBean() throws Exception { JWTAuthorizationFilter jwtAuthorizationFilter = new JWTAuthorizationFilter(authenticationManagerBean(), conf.getJwtSecretKey(), cdsClient); return jwtAuthorizationFilter; }

sample: 718
buggy_code:  * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.service; import org.acumos.workbench.common.vo.Model; public interface ModelValidationService { /** <|startfocus|> * To Validate the Input Data * <|endfocus|> * @param authenticatedUserId the authenticated User Id * @param model the model */ public void validateInputData(String authenticatedUserId, Model model); } 
code_review:  If you use the Eclipse code formatter, it will instantly clean up all dangling whitespace problems like this 
target code: * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.service; import org.acumos.workbench.common.vo.Model; public interface ModelValidationService { /** * To Validate the Input for * * @param authenticatedUserId the authenticated User Id * @param model the model */ public void validateInputData(String authenticatedUserId, Model model); }
response: package org.acumos.workbench.modelservice.service; import org.acumos.workbench.common.vo.Model; public interface ModelValidationService { public void validateInputData(String authenticatedUserId, Model model); }

sample: 719
buggy_code:  * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.service; import org.acumos.workbench.common.vo.Model; public interface ModelValidationService { /** <|startfocus|> * To Validate the Input for : * 1. <|endfocus|> * @param authenticatedUserId * @param model */ public void validateInputData(String authenticatedUserId, Model model); } 
code_review:  what is this 1. ?? 
target code: * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.service; import org.acumos.workbench.common.vo.Model; public interface ModelValidationService { /** * To Validate the Input Data * * @param authenticatedUserId * @param model */ public void validateInputData(String authenticatedUserId, Model model); }
response: /* * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.service; import org.acumos.workbench.common.vo.Model; public interface ModelValidationService { public void validateInputData(String authenticatedUserId, Model model); }

sample: 720
buggy_code:  * ===============LICENSE_START======================================================= * Acumos * =================================================================================== <|startfocus|> * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. <|endfocus|> * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.designstudio.toscagenerator.test; import java.io.File; import java.io.IOException; import java.lang.invoke.MethodHandles; import java.time.Instant; import java.util.ArrayList; import java.util.List; import org.acumos.cds.domain.MLPSolutionRevision; import org.acumos.designstudio.toscagenerator.ToscaGeneratorClient;
code_review:  update to 2019 
target code: * ===============LICENSE_START======================================================= * Acumos * =================================================================================== * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.designstudio.toscagenerator.test; import java.io.File; import java.io.IOException; import java.lang.invoke.MethodHandles; import java.time.Instant; import java.util.ArrayList; import java.util.List; import org.acumos.cds.domain.MLPSolutionRevision; import org.acumos.designstudio.toscagenerator.ToscaGeneratorClient;
response: * ===============LICENSE_START======================================================= * Acumos * =================================================================================== * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.designstudio.toscagenerator.test; import java.io.File; import java.io.IOException; import java.lang.invoke.MethodHandles; import java.time.Instant; import java.util.ArrayList; import java.util.List; import org.acumos.cds.domain.MLPSolutionRevision; import org.acumos.designstudio.toscagenerator.ToscaGeneratorClient;

sample: 721
buggy_code: import org.junit.Rule; import org.junit.Test; import org.mockito.MockitoAnnotations; import org.mockito.junit.MockitoJUnit; import org.mockito.junit.MockitoRule; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ToscaGeneratorClientTest { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); @Before public void setUp() { MockitoAnnotations.initMocks(this); } <|startfocus|> //@Test(expected = ServiceException.class) <|endfocus|> public void ToscaClientTest(){
code_review:  Class don't have any test method 
target code: import org.junit.Rule; import org.junit.Test; import org.mockito.MockitoAnnotations; import org.mockito.junit.MockitoJUnit; import org.mockito.junit.MockitoRule; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ToscaGeneratorClientTest { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); @Before public void setUp() { MockitoAnnotations.initMocks(this); } @Test() public void ToscaClientTest(){
response: import org.junit.Rule; import org.junit.Test; import org.mockito.MockitoAnnotations; import org.mockito.junit.MockitoJUnit; import org.mockito.junit.MockitoRule; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ToscaGeneratorClientTest { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); @Before public void setUp() { MockitoAnnotations.initMocks(this); } @Test(expected = ServiceException.class) public void ToscaClientTest() { // Test code goes here } }

sample: 722
buggy_code:  mlpRev.setModified(Instant.now()); mlpRev.setOnboarded(Instant.now()); mlpRev.setPublisher("techmdev"); mlpRev.setRevisionId("123"); mlpRev.setSolutionId("123"); mlpRev.setUserId("123"); mlpRev.setVerifiedLicense("Yes"); mlpRev.setVerifiedVulnerability("Yes"); mlpRev.setVersion("1"); List<MLPSolutionRevision> listMLPSolRev = new ArrayList<>(); listMLPSolRev.add(mlpRev); try { <|startfocus|> //when(protoService.createProtoJson("123", "1", tagFile)).thenReturn("str"); //when(toscaGeneratorService.uploadFilesToRepository("123", "1", artList)).thenReturn(artList); //when(cdmsClient.getSolutionRevisions("123")).thenReturn(listMLPSolRev); <|endfocus|> client.generateTOSCA("123", "123", "1", "123", protoFile, tagFile); } catch (AcumosException e) { logger.error("AcumosException occured while generating the TOSCA File"); } 
code_review:  Remove commented code. 
target code: mlpRev.setModified(Instant.now()); mlpRev.setOnboarded(Instant.now()); mlpRev.setPublisher("techmdev"); mlpRev.setRevisionId("123"); mlpRev.setSolutionId("123"); mlpRev.setUserId("123"); mlpRev.setVerifiedLicense("Yes"); mlpRev.setVerifiedVulnerability("Yes"); mlpRev.setVersion("1"); List<MLPSolutionRevision> listMLPSolRev = new ArrayList<>(); listMLPSolRev.add(mlpRev); try { client.generateTOSCA("123", "123", "1", "123", protoFile, tagFile); } catch (AcumosException e) { logger.error("AcumosException occured while generating the TOSCA File"); }
response: mlpRev.setModified(Instant.now()); mlpRev.setOnboarded(Instant.now()); mlpRev.setPublisher("techmdev"); mlpRev.setRevisionId("123"); mlpRev.setSolutionId("123"); mlpRev.setUserId("123"); mlpRev.setVerifiedLicense("Yes"); mlpRev.setVerifiedVulnerability("Yes"); mlpRev.setVersion("1"); List<MLPSolutionRevision> listMLPSolRev = new ArrayList<>(); listMLPSolRev.add(mlpRev); try { client.generateTOSCA("123", "123", "1", "123", protoFile, tagFile); } catch (AcumosException e) { logger.error("AcumosException occured while generating the TOSCA File"); }

sample: 723
buggy_code:  * ===============LICENSE_START======================================================= * Acumos * =================================================================================== <|startfocus|> * Copyright (C) 2018 - 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. <|endfocus|> * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.csvdatabroker.vo; import static org.junit.Assert.assertTrue; import org.junit.Test; public class CSVdatabrokerVOTest { @Test public void csvdatabrokerVOTest() { DataBrokerMap dataBrokerMap = new DataBrokerMap(); dataBrokerMap.setScript("test");
code_review:  Remove 2018, should be consistent across 
target code: * ===============LICENSE_START======================================================= * Acumos * =================================================================================== * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.csvdatabroker.vo; import static org.junit.Assert.assertTrue; import org.junit.Test; public class CSVdatabrokerVOTest { @Test public void csvdatabrokerVOTest() { DataBrokerMap dataBrokerMap = new DataBrokerMap(); dataBrokerMap.setScript("test");
response: /***************************************************************************** * Copyright (C) 2018 - 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *****************************************************************************/ package org.acumos.csvdatabroker.vo; import static org.junit.Assert.assertTrue; import org.junit.Test; public class CSVdatabrokerVOTest { 	@Test 	public void csvdatabrokerVOTest() { 		DataBrokerMap dataBrokerMap = new DataBrokerMap(); 		dataBrokerMap.setScript("test"); 	} }

sample: 724
buggy_code:  * ===============LICENSE_START======================================================= * Acumos * =================================================================================== <|startfocus|> * Copyright (C) 2018 - 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. <|endfocus|> * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.sqldatabroker.vo; import static org.junit.Assert.assertTrue; import java.util.ArrayList; import java.util.List; import org.acumos.sqldatabroker.exceptionhandler.ServiceException; import org.junit.Test; public class DataBrokerMapVOTest { @Test
code_review:  Remove 2018 
target code: * ===============LICENSE_START======================================================= * Acumos * =================================================================================== * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.sqldatabroker.vo; import static org.junit.Assert.assertTrue; import java.util.ArrayList; import java.util.List; import org.acumos.sqldatabroker.exceptionhandler.ServiceException; import org.junit.Test; public class DataBrokerMapVOTest { @Test
response: /***************************************************************************** * Copyright (C) 2018 - 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *****************************************************************************/ package org.acumos.sqldatabroker.vo; import static org.junit.Assert.assertTrue; import java.util.ArrayList; import java.util.List; import org.acumos.sqldatabroker.exceptionhandler.ServiceException; import org.junit.Test; public class DataBrokerMapVOTest { 	@Test 	public void test() { 		// Add test cases here 	} }

sample: 725
buggy_code:  * ===============LICENSE_START======================================================= * Acumos * =================================================================================== <|startfocus|> * Copyright (C) 2018 - 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. <|endfocus|> * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.csvdatabroker.vo; import static org.junit.Assert.assertTrue; import org.junit.Test; public class CSVdatabrokerVOTest { @Test public void csvdatabrokerVOTest() { DataBrokerMap dataBrokerMap = new DataBrokerMap(); dataBrokerMap.setScript("test");
code_review:  Remove 2018, also fix similar other occurrences. 
target code: * ===============LICENSE_START======================================================= * Acumos * =================================================================================== * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.csvdatabroker.vo; import static org.junit.Assert.assertTrue; import org.junit.Test; public class CSVdatabrokerVOTest { @Test public void csvdatabrokerVOTest() { DataBrokerMap dataBrokerMap = new DataBrokerMap(); dataBrokerMap.setScript("test");
response: /***************************************************************************** * Copyright (C) 2018 - 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. * * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *****************************************************************************/ package org.acumos.csvdatabroker.vo; import static org.junit.Assert.assertTrue; import org.junit.Test; public class CSVdatabrokerVOTest { @Test public void csvdatabrokerVOTest() { DataBrokerMap dataBrokerMap = new DataBrokerMap(); dataBrokerMap.setScript("test"); } }

sample: 726
buggy_code:  @RestController @RequestMapping(value = "/") public class ModelServiceController { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired @Qualifier("InputValidationServiceImpl") private InputValidationService inputValidationService; @Autowired @Qualifier("ModelValidationServiceImpl") private ModelValidationService modelValidationService; @Autowired @Qualifier("ModelServiceImpl") private ModelService modelService; <|startfocus|> @ApiOperation(value = "This API will list out all the Models that belongs to user") <|endfocus|> @RequestMapping(value = "/users/{authenticatedUserId}/models/", method = RequestMethod.GET) public ResponseEntity<?> listModels(HttpServletRequest request,@ApiParam(value="Acumos User login Id",required = true)@PathVariable("authenticatedUserId") String authenticatedUserId){ logger.debug("listModels() Begin"); String authToken = getAuthJWTToken(request); //1. Check the Authenticated User Id is present or not inputValidationService.isValuePresent(ModelServiceConstants.MODEL_AUTHENTICATED_USER_ID, authenticatedUserId);
code_review:  need to rephrase the API operation 
target code: @RestController @RequestMapping(value = "/") public class ModelServiceController { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired @Qualifier("InputValidationServiceImpl") private InputValidationService inputValidationService; @Autowired @Qualifier("ModelValidationServiceImpl") private ModelValidationService modelValidationService; @Autowired @Qualifier("ModelServiceImpl") private ModelService modelService; @ApiOperation(value = "List out all the Models that belongs to user") @RequestMapping(value = "/users/{authenticatedUserId}/models/", method = RequestMethod.GET) public ResponseEntity<?> listModels(HttpServletRequest request,@ApiParam(value="Acumos User login Id",required = true)@PathVariable("authenticatedUserId") String authenticatedUserId){ logger.debug("listModels() Begin"); String authToken = getAuthJWTToken(request); //1. Check the Authenticated User Id is present or not inputValidationService.isValuePresent(ModelServiceConstants.MODEL_AUTHENTICATED_USER_ID, authenticatedUserId);
response: @RestController @RequestMapping(value = "/") public class ModelServiceController { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired @Qualifier("InputValidationServiceImpl") private InputValidationService inputValidationService; @Autowired @Qualifier("ModelValidationServiceImpl") private ModelValidationService modelValidationService; @Autowired @Qualifier("ModelServiceImpl") private ModelService modelService; @ApiOperation(value = "List all the Models belonging to a user") @RequestMapping(value = "/users/{authenticatedUserId}/models/", method = RequestMethod.GET) public ResponseEntity<?> listModels(HttpServletRequest request, @ApiParam(value = "Acumos User login Id", required = true) @PathVariable("authenticatedUserId") String authenticatedUserId) { logger.debug("listModels() Begin"); String authToken = getAuthJWTToken(request); // 1. Check if the Authenticated User Id is present or not inputValidationService.isValuePresent(ModelServiceConstants.MODEL_AUTHENTICATED_USER_ID, authenticatedUserId); // Rest of the code... } }

sample: 727
buggy_code: import org.acumos.workbench.common.vo.Version; import org.acumos.workbench.modelservice.exceptionhandling.ModelNotFoundException; import org.acumos.workbench.modelservice.util.ConfigurationProperties; import org.acumos.workbench.modelservice.util.ModelServiceProperties; import org.acumos.workbench.modelservice.util.ModelServiceUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.slf4j.MDC; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; <|startfocus|> import org.springframework.web.client.RestClientResponseException; <|endfocus|> @Service("ModelServiceImpl") public class ModelServiceImpl implements ModelService { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private CommonDataServiceRestClientImpl cdsClient; @Autowired private ModelServiceProperties props; @Autowired private ConfigurationProperties confprops; @Autowired private ProjectServiceRestClientImpl psClient; @Override public List<Model> getModels(String authenticatedUserId, String projectId) { logger.debug("getModels() Begin"); List<Model> modelList = new ArrayList<Model>(); MLPUser mlpUser = getUserDetails(authenticatedUserId);
code_review:  Pleas include a line between import and start of the class definition. 
target code: import org.acumos.workbench.common.vo.Version; import org.acumos.workbench.modelservice.exceptionhandling.ModelNotFoundException; import org.acumos.workbench.modelservice.util.ConfigurationProperties; import org.acumos.workbench.modelservice.util.ModelServiceProperties; import org.acumos.workbench.modelservice.util.ModelServiceUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.slf4j.MDC; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import org.springframework.web.client.RestClientResponseException; @Service("ModelServiceImpl") public class ModelServiceImpl implements ModelService { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private CommonDataServiceRestClientImpl cdsClient; @Autowired private ModelServiceProperties props; @Autowired private ConfigurationProperties confprops; @Autowired private ProjectServiceRestClientImpl psClient; @Override public List<Model> getModels(String authenticatedUserId, String projectId) { logger.debug("getModels() Begin"); List<Model> modelList = new ArrayList<Model>(); MLPUser mlpUser = getUserDetails(authenticatedUserId);
response: import org.acumos.workbench.common.vo.Version; import org.acumos.workbench.modelservice.exceptionhandling.ModelNotFoundException; import org.acumos.workbench.modelservice.util.ConfigurationProperties; import org.acumos.workbench.modelservice.util.ModelServiceProperties; import org.acumos.workbench.modelservice.util.ModelServiceUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.slf4j.MDC; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import org.springframework.web.client.RestClientResponseException; @Service("ModelServiceImpl") public class ModelServiceImpl implements ModelService { private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Autowired private CommonDataServiceRestClientImpl cdsClient; @Autowired private ModelServiceProperties props; @Autowired private ConfigurationProperties confprops; @Autowired private ProjectServiceRestClientImpl psClient; @Override public List<Model> getModels(String authenticatedUserId, String projectId) { logger.debug("getModels() Begin"); List<Model> modelList = new ArrayList<Model>(); MLPUser mlpUser = getUserDetails(authenticatedUserId); // ... } }

sample: 728
buggy_code:  Model model = getModelWithErrorStatus(ex); return new ResponseEntity<Model>(model, HttpStatus.NOT_FOUND); } /** * To handle AssociationExistsException and returns appropriate response to UI. * @param ex * the exception thrown by the service method * @param request * the WebRequest * @return ResponseEntitiy<Model> * returns Model with ServiceStatus indicating error */ <|startfocus|> @ExceptionHandler(AssociationExistsException.class) public final ResponseEntity<?> handleAssociationExistsException(AssociationExistsException ex, WebRequest request) { <|endfocus|> Model model = getModelWithErrorStatus(ex); return new ResponseEntity<Model>(model, HttpStatus.NOT_FOUND); } /** * To handle AssociationNotFoundException and returns appropriate response to UI. * @param ex * the exception thrown by the service method * @param request * the WebRequest * @return ResponseEntitiy<Model> * returns Model with ServiceStatus indicating error */ @ExceptionHandler(ProjectModelAssociationNotFoundException.class)
code_review:  Use AssociationException instead. 
target code: Model model = getModelWithErrorStatus(ex); return new ResponseEntity<Model>(model, HttpStatus.NOT_FOUND); } /** * To handle AssociationExistsException and returns appropriate response to UI. * @param ex * the exception thrown by the service method * @param request * the WebRequest * @return ResponseEntitiy<Model> * returns Model with ServiceStatus indicating error */ @ExceptionHandler(AssociationException.class) public final ResponseEntity<?> handleAssociationExistsException(AssociationException ex, WebRequest request) { Model model = getModelWithErrorStatus(ex); return new ResponseEntity<Model>(model, HttpStatus.NOT_FOUND); } /** * To handle AssociationNotFoundException and returns appropriate response to UI. * @param ex * the exception thrown by the service method * @param request * the WebRequest * @return ResponseEntitiy<Model> * returns Model with ServiceStatus indicating error */ @ExceptionHandler(ProjectModelAssociationNotFoundException.class)
response: Model model = getModelWithErrorStatus(ex); return new ResponseEntity<Model>(model, HttpStatus.NOT_FOUND); } @ExceptionHandler(AssociationException.class) public final ResponseEntity<?> handleAssociationException(AssociationException ex, WebRequest request) { Model model = getModelWithErrorStatus(ex); return new ResponseEntity<Model>(model, HttpStatus.NOT_FOUND); } @ExceptionHandler(ProjectModelAssociationNotFoundException.class)

sample: 729
buggy_code:  * * @param fieldName * The name of the filed to be shown in the error message. * @param value * The value to be validated * @throws ValueNotFoundException * throws ValueNotFoundException in case value is null or empty. */ public void isValuePresent(String fieldName, String value) throws ValueNotFoundException; /** <|startfocus|> * This method will validates the input Json value of Model <|endfocus|> * @param model * the model object with input values * @throws InvalidInputJSONException * throws InvalidInputJSONException in case of error in the input JSON */ public void validateModelInputJson(Model model) throws InvalidInputJSONException; } 
code_review:  Remove text "This method will" and stat with "To validate the....." 
target code: * * @param fieldName * The name of the filed to be shown in the error message. * @param value * The value to be validated * @throws ValueNotFoundException * throws ValueNotFoundException in case value is null or empty. */ public void isValuePresent(String fieldName, String value) throws ValueNotFoundException; /** * To validate the input Json value of Model * @param model * the model object with input values * @throws InvalidInputJSONException * throws InvalidInputJSONException in case of error in the input JSON */ public void validateModelInputJson(Model model) throws InvalidInputJSONException; }
response: public void isValuePresent(String fieldName, String value) throws ValueNotFoundException; public void validateModelInputJson(Model model) throws InvalidInputJSONException;

sample: 730
buggy_code:  * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.util; public class ModelServiceConstants { public static final String MODEL_AUTHENTICATED_USER_ID = "AuthenticatedUserId"; public static final String DELETED = "DELETED"; public static final String MODEL_IS_ACTIVE = "Model is Active"; public static final String CATALOGNAMES = "CATALOG_NAMES"; public static final String UNARCHIVE = "UA"; public static final String ARCHIVE = "A"; <|startfocus|> public static final String PROJECT_ID = "projectId"; <|endfocus|> public static final String ASSOCIATIONID = "ASSOCIATION_ID"; public static final String MODELTYPECODE = "MODEL_TYPE_CODE"; public static final String MODELPUBLISHSTATUS = "MODEL_PUBLISH_STATUS"; } 
code_review:  No underscore in name please. 
target code: * ===============LICENSE_END========================================================= */ package org.acumos.workbench.modelservice.util; public class ModelServiceConstants { public static final String MODEL_AUTHENTICATED_USER_ID = "AuthenticatedUserId"; public static final String DELETED = "DELETED"; public static final String MODEL_IS_ACTIVE = "Model is Active"; public static final String CATALOGNAMES = "CATALOG_NAMES"; public static final String UNARCHIVE = "UA"; public static final String ARCHIVE = "A"; public static final String PROJECTID = "projectId"; public static final String ASSOCIATIONID = "ASSOCIATION_ID"; public static final String MODELTYPECODE = "MODEL_TYPE_CODE"; public static final String MODELPUBLISHSTATUS = "MODEL_PUBLISH_STATUS"; }
response: package org.acumos.workbench.modelservice.util; public class ModelServiceConstants { public static final String MODEL_AUTHENTICATED_USER_ID = "AuthenticatedUserId"; public static final String DELETED = "DELETED"; public static final String MODEL_IS_ACTIVE = "Model is Active"; public static final String CATALOGNAMES = "CATALOG_NAMES"; public static final String UNARCHIVE = "UA"; public static final String ARCHIVE = "A"; public static final String PROJECTID = "projectId"; public static final String ASSOCIATIONID = "ASSOCIATION_ID"; public static final String MODELTYPECODE = "MODEL_TYPE_CODE"; public static final String MODELPUBLISHSTATUS = "MODEL_PUBLISH_STATUS"; }

sample: 731
buggy_code:  private List<String> getConnectedPortInputMsgNames(List<ProtobufServiceOperation> operations) { List<String> inputMessageNames = null; for (ProtobufServiceOperation o : operations) { <|startfocus|> // TODO : Current logic returns the first operation's input msg // name, but need to update the logic to return the connected port // input message name <|endfocus|> inputMessageNames = o.getInputMessageNames(); } return inputMessageNames;
code_review:  Because of complete class formatting, comments in TODO is multi lined, Please get the comment on same line. 
target code: private List<String> getConnectedPortInputMsgNames(List<ProtobufServiceOperation> operations) { List<String> inputMessageNames = null; for (ProtobufServiceOperation o : operations) { // TODO : Current logic returns the first operation's input msg name, but need to update the logic to return the connected port input message name inputMessageNames = o.getInputMessageNames(); } return inputMessageNames;
response: private List<String> getConnectedPortInputMsgNames(List<ProtobufServiceOperation> operations) { List<String> inputMessageNames = null; for (ProtobufServiceOperation o : operations) { inputMessageNames = o.getInputMessageNames(); } return inputMessageNames; }

sample: 732
buggy_code:  // 1. Get the list of SolutionRevision for the solutionId. mlpSolutionRevisionList = getSolutionRevisionsList(solutionId); // 2. Match the version with the SolutionRevision and get the // solutionRevisionId. if (null != mlpSolutionRevisionList && !mlpSolutionRevisionList.isEmpty()) { solutionRevisionId = mlpSolutionRevisionList.stream().filter(mlp -> mlp.getVersion().equals(version)) .findFirst().get().getRevisionId(); <|startfocus|> logger.debug(EELFLoggerDelegator.debugLogger," SolutionRevisonId for Version : {} ", solutionRevisionId); <|endfocus|> } else { result = String.format(error, "501", "Failed to fetch the Solution Revision List"); } } catch (Exception e) { logger.error(EELFLoggerDelegator.errorLogger, "Error : Exception in fetchJsonTOSCA() : Failed to fetch the Solution Revision List", e); result = String.format(error, "501", "Failed to fetch the Solution Revision List for the version {} ", version); } if (null != solutionRevisionId) {
code_review:  Please fix the TODO pending on you. 
target code: // 1. Get the list of SolutionRevision for the solutionId. mlpSolutionRevisionList = getSolutionRevisionsList(solutionId); // 2. Match the version with the SolutionRevision and get the // solutionRevisionId. if (null != mlpSolutionRevisionList && !mlpSolutionRevisionList.isEmpty()) { solutionRevisionId = mlpSolutionRevisionList.stream().filter(mlp -> mlp.getVersion().equals(version)) .findFirst().get().getRevisionId(); logger.debug(EELFLoggerDelegator.debugLogger," SolutionRevisonId for Version : " + solutionRevisionId); } else { result = String.format(error, "501", "Failed to fetch the Solution Revision List"); } } catch (Exception e) { logger.error(EELFLoggerDelegator.errorLogger, "Error : Exception in fetchJsonTOSCA() : Failed to fetch the Solution Revision List", e); result = String.format(error, "501", "Failed to fetch the Solution Revision List for the version {} ", version); } if (null != solutionRevisionId) {
response: // 1. Get the list of SolutionRevision for the solutionId. mlpSolutionRevisionList = getSolutionRevisionsList(solutionId); // 2. Match the version with the SolutionRevision and get the solutionRevisionId. if (null != mlpSolutionRevisionList && !mlpSolutionRevisionList.isEmpty()) { solutionRevisionId = mlpSolutionRevisionList.stream() .filter(mlp -> mlp.getVersion().equals(version)) .findFirst() .get() .getRevisionId(); logger.debug(EELFLoggerDelegator.debugLogger, "SolutionRevisonId for Version : {}", solutionRevisionId); } else { result = String.format(error, "501", "Failed to fetch the Solution Revision List"); } } catch (Exception e) { logger.error(EELFLoggerDelegator.errorLogger, "Error : Exception in fetchJsonTOSCA() : Failed to fetch the Solution Revision List", e); result = String.format(error, "501", "Failed to fetch the Solution Revision List for the version {}", version); } if (null != solutionRevisionId) { // continue with the code logic }

sample: 733
buggy_code:  // add protobuf file addProtobufFile(protobufJarEntryName, tempJar); // add DavaVO.class file List<String> dataVOEntryList = addDataVOClasses(DataVOClassEntryName, tempJar); JarEntry entry = null; // Open the original jar jar = new JarFile(jarFile); // Loop through the jar entries and add them to the temp jar, // skipping the entry that was added to the temp jar already. for (Enumeration entries = jar.entries(); entries.hasMoreElements();) { // Get the next entry. <|startfocus|> entry = (JarEntry) entries.nextElement(); <|endfocus|> // If the entry has not been added already, add it. if (!entry.getName().equals(fieldMappingJarEntryName) && !dataVOEntryList.contains(entry.getName())) { // Get an input stream for the entry. InputStream entryStream = jar.getInputStream(entry); // Read the entry and write it to the temp jar. tempJar.putNextEntry(entry); while ((bytesRead = entryStream.read(buffer)) != -1) {
code_review:  Please remove unnecessary empty lines. Please check rest of the class and remove empty lines. 
target code: // add protobuf file addProtobufFile(protobufJarEntryName, tempJar); // add DavaVO.class file List<String> dataVOEntryList = addDataVOClasses(DataVOClassEntryName, tempJar); JarEntry entry = null; // Open the original jar jar = new JarFile(jarFile); // Loop through the jar entries and add them to the temp jar, // skipping the entry that was added to the temp jar already. for (Enumeration entries = jar.entries(); entries.hasMoreElements();) { // Get the next entry. // Read the entry and write it to the temp jar. // If the entry has not been added already, add it. if (!entry.getName().equals(fieldMappingJarEntryName) && !dataVOEntryList.contains(entry.getName())) { // Get an input stream for the entry. InputStream entryStream = jar.getInputStream(entry); // Read the entry and write it to the temp jar. tempJar.putNextEntry(entry); while ((bytesRead = entryStream.read(buffer)) != -1) {
response: // add protobuf file addProtobufFile(protobufJarEntryName, tempJar); // add DavaVO.class file List<String> dataVOEntryList = addDataVOClasses(DataVOClassEntryName, tempJar); JarEntry entry = null; // Open the original jar jar = new JarFile(jarFile); // Loop through the jar entries and add them to the temp jar, // skipping the entry that was added to the temp jar already. for (Enumeration entries = jar.entries(); entries.hasMoreElements();) { // Get the next entry. entry = (JarEntry) entries.nextElement(); // If the entry has not been added already, add it. if (!entry.getName().equals(fieldMappingJarEntryName) && !dataVOEntryList.contains(entry.getName())) { // Get an input stream for the entry. InputStream entryStream = jar.getInputStream(entry); // Read the entry and write it to the temp jar. tempJar.putNextEntry(entry); while ((bytesRead = entryStream.read(buffer)) != -1) { // Write the bytes to the temp jar. tempJar.write(buffer, 0, bytesRead); } } }

sample: 734
buggy_code:  curPartIdx++; if (curPartIdx <= endPartIdx) { boolean suitablePartFound = false; for (int i = curPartIdx; i <= endPartIdx; i++) { // Prune partition because no element in it can satisfy the occurrence threshold. if (partitionCursors[i] == null || partitionCursors[i].size() < occurrenceThreshold) { <|startfocus|> // Temp : // System.out // .println("\nPartitionedTOccurrenceSearcher::continueSearch() skipping the partition " + i); // <|endfocus|> continue; } suitablePartFound = true; curPartIdx = i; break; } // If no partition is availble to explore, we stop here. if (!suitablePartFound) { isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } // Temp : // System.out.println("\nMerging the cursor for the partition " + curPartIdx + " start " // + partitions.getMinValidPartitionIndex() + " end " + endPartIdx // + " - PartitionedTOccurrenceSearcher::continueSearch()"); // 
code_review:  MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine 
target code: curPartIdx++; if (curPartIdx <= endPartIdx) { boolean suitablePartFound = false; for (int i = curPartIdx; i <= endPartIdx; i++) { // Prune partition because no element in it can satisfy the occurrence threshold. if (partitionCursors[i] == null || partitionCursors[i].size() < occurrenceThreshold) { continue; } suitablePartFound = true; curPartIdx = i; break; } // If no partition is availble to explore, we stop here. if (!suitablePartFound) { isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } // Temp : // System.out.println("\nMerging the cursor for the partition " + curPartIdx + " start " // + partitions.getMinValidPartitionIndex() + " end " + endPartIdx // + " - PartitionedTOccurrenceSearcher::continueSearch()"); //
response: curPartIdx++; if (curPartIdx <= endPartIdx) { boolean suitablePartFound = false; for (int i = curPartIdx; i <= endPartIdx; i++) { if (partitionCursors[i] == null || partitionCursors[i].size() < occurrenceThreshold) { continue; } suitablePartFound = true; curPartIdx = i; break; } if (!suitablePartFound) { isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } }

sample: 735
buggy_code:  isSingleInvertedList = true; needToReadNewPart = true; } else { singleInvListCursor = null; isSingleInvertedList = false; needToReadNewPart = invListMerger.merge(partitionCursors[curPartIdx], occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); <|startfocus|> // Temp : // System.out.println("PartitionedTOccurrenceSearcher::continueSearch() - " + needToReadNewPart // + " tupleCount " + searchResultFta.getTupleCount()); // <|endfocus|> } // Finished processing one partition if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; // Temp : // System.out.println("Final partition " + curPartIdx + " Search done"); return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) {
code_review:  MAJOR SonarQube violation: Split this 126 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: isSingleInvertedList = true; needToReadNewPart = true; } else { singleInvListCursor = null; isSingleInvertedList = false; needToReadNewPart = invListMerger.merge(partitionCursors[curPartIdx], occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); } // Finished processing one partition if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; // Temp : // System.out.println("Final partition " + curPartIdx + " Search done"); return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) {
response: isSingleInvertedList = true; needToReadNewPart = true; } else { singleInvListCursor = null; isSingleInvertedList = false; needToReadNewPart = invListMerger.merge(partitionCursors[curPartIdx], occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); } if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; return true; } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) {

sample: 736
buggy_code:  needToReadNewPart = true; } else { singleInvListCursor = null; isSingleInvertedList = false; needToReadNewPart = invListMerger.merge(partitionCursors[curPartIdx], occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); <|startfocus|> // Temp : // System.out.println("PartitionedTOccurrenceSearcher::continueSearch() - " + needToReadNewPart // + " tupleCount " + searchResultFta.getTupleCount()); // <|endfocus|> } // Finished processing one partition if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; // Temp : // System.out.println("Final partition " + curPartIdx + " Search done"); return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) {
code_review:  MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine 
target code: needToReadNewPart = true; } else { singleInvListCursor = null; isSingleInvertedList = false; needToReadNewPart = invListMerger.merge(partitionCursors[curPartIdx], occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); } // Finished processing one partition if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; // Temp : // System.out.println("Final partition " + curPartIdx + " Search done"); return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) {
response: needToReadNewPart = true; } else { singleInvListCursor = null; isSingleInvertedList = false; needToReadNewPart = invListMerger.merge(partitionCursors[curPartIdx], occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); } if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) {

sample: 737
buggy_code:  searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); // Temp : // System.out.println("PartitionedTOccurrenceSearcher::continueSearch() - " + needToReadNewPart // + " tupleCount " + searchResultFta.getTupleCount()); // } // Finished processing one partition if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; <|startfocus|> // Temp : // System.out.println("Final partition " + curPartIdx + " Search done"); <|endfocus|> return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) { ShortPointable.setShort(lowerBoundTuple.getFieldData(0), lowerBoundTuple.getFieldStart(0), numTokensLowerBound); ShortPointable.setShort(upperBoundTuple.getFieldData(0), upperBoundTuple.getFieldStart(0), numTokensUpperBound); } public ITupleReference getPrefixSearchKey() { return searchKey; } public ITupleReference getFullLowSearchKey() { return fullLowSearchKey;
code_review:  MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine 
target code: searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); // Temp : // System.out.println("PartitionedTOccurrenceSearcher::continueSearch() - " + needToReadNewPart // + " tupleCount " + searchResultFta.getTupleCount()); // } // Finished processing one partition if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; return true; } } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) { ShortPointable.setShort(lowerBoundTuple.getFieldData(0), lowerBoundTuple.getFieldStart(0), numTokensLowerBound); ShortPointable.setShort(upperBoundTuple.getFieldData(0), upperBoundTuple.getFieldStart(0), numTokensUpperBound); } public ITupleReference getPrefixSearchKey() { return searchKey; } public ITupleReference getFullLowSearchKey() { return fullLowSearchKey;
response: searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); if (needToReadNewPart && isFinalPartIdx) { invListMerger.close(); finalSearchResult.finalizeWrite(); isFinishedSearch = true; return true; } else { isFinishedSearch = true; } return false; } public void setNumTokensBoundsInSearchKeys(short numTokensLowerBound, short numTokensUpperBound) { ShortPointable.setShort(lowerBoundTuple.getFieldData(0), lowerBoundTuple.getFieldStart(0), numTokensLowerBound); ShortPointable.setShort(upperBoundTuple.getFieldData(0), upperBoundTuple.getFieldStart(0), numTokensUpperBound); } public ITupleReference getPrefixSearchKey() { return searchKey; } public ITupleReference getFullLowSearchKey() { return fullLowSearchKey; }

sample: 738
buggy_code:  singleInvListCursor.prepareLoadPages(); singleInvListCursor.loadPages(); isSingleInvertedList = true; isFinishedSearch = true; } else { finalSearchResult.reset(); isFinishedSearch = invListMerger.merge(invListCursors, occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); <|startfocus|> // Temp : System.out.println("PartitionedTOccurrenceSearcher::search() - " + isFinishedSearch + " tupleCount " + searchResultFta.getTupleCount()); // <|endfocus|> } if (isFinishedSearch) { invListMerger.close(); finalSearchResult.finalizeWrite(); } // Some or all output was generated by the merger. Let the result cursor fetch the output. resultCursor.open(null, searchPred); } /** * Continues a search process if it was paused because the output buffer (one frame) of the final result was full. * This method should not be called for a single inverted list case since there cannot be multiple inverted list * cursors for a single keyword.
code_review:  MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 
target code: singleInvListCursor.prepareLoadPages(); singleInvListCursor.loadPages(); isSingleInvertedList = true; isFinishedSearch = true; } else { finalSearchResult.reset(); isFinishedSearch = invListMerger.merge(invListCursors, occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); } if (isFinishedSearch) { invListMerger.close(); finalSearchResult.finalizeWrite(); } // Some or all output was generated by the merger. Let the result cursor fetch the output. resultCursor.open(null, searchPred); } /** * Continues a search process if it was paused because the output buffer (one frame) of the final result was full. * This method should not be called for a single inverted list case since there cannot be multiple inverted list * cursors for a single keyword.
response: singleInvListCursor.prepareLoadPages(); singleInvListCursor.loadPages(); isSingleInvertedList = true; isFinishedSearch = true; } else { finalSearchResult.reset(); isFinishedSearch = invListMerger.merge(invListCursors, occurrenceThreshold, numPrefixLists, finalSearchResult); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); } if (isFinishedSearch) { invListMerger.close(); finalSearchResult.finalizeWrite(); } resultCursor.open(null, searchPred);

sample: 739
buggy_code:  * false otherwise. * @throws HyracksDataException */ @Override public boolean continueSearch() throws HyracksDataException { if (isFinishedSearch) { return true; } isFinishedSearch = invListMerger.continueMerge(); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); <|startfocus|> // Temp : System.out.println("PartitionedTOccurrenceSearcher::continueSearch() - " + isFinishedSearch + " tupleCount " + searchResultFta.getTupleCount()); // <|endfocus|> if (isFinishedSearch) { invListMerger.close(); finalSearchResult.finalizeWrite(); } return isFinishedSearch; } } 
code_review:  MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 
target code: * false otherwise. * @throws HyracksDataException */ @Override public boolean continueSearch() throws HyracksDataException { if (isFinishedSearch) { return true; } isFinishedSearch = invListMerger.continueMerge(); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); if (isFinishedSearch) { invListMerger.close(); finalSearchResult.finalizeWrite(); } return isFinishedSearch; } }
response: @Override public boolean continueSearch() throws HyracksDataException { if (isFinishedSearch) { return true; } isFinishedSearch = invListMerger.continueMerge(); searchResultBuffer = finalSearchResult.getNextFrame(); searchResultTupleIndex = 0; searchResultFta.reset(searchResultBuffer); if (isFinishedSearch) { invListMerger.close(); finalSearchResult.finalizeWrite(); } return isFinishedSearch; }

sample: 740
buggy_code:  * Otherwise, it performs an insert. * * @param tuple * Tuple to be deleted. * @throws HyracksDataException * If the BufferCache throws while un/pinning or un/latching. * @throws IndexException * If there is no matching tuple in the index. * */ public void upsert(ITupleReference tuple) throws HyracksDataException; /** * Creates a cursor appropriate for passing into search(). <|startfocus|> * <|endfocus|> * @throws HyracksDataException * */ public IIndexCursor createSearchCursor(boolean exclusive) throws HyracksDataException; /** * Open the given cursor for an index search using the given predicate as * search condition. * * @param icursor * Cursor over the index entries satisfying searchPred. * @param searchPred * Search condition. * @throws HyracksDataException * If the BufferCache throws while un/pinning or un/latching. * @throws IndexException */ public void search(IIndexCursor cursor, ISearchPredicate searchPred) throws HyracksDataException; } 
code_review:  MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws 
target code: * Otherwise, it performs an insert. * * @param tuple * Tuple to be deleted. * @throws HyracksDataException * If the BufferCache throws while un/pinning or un/latching. * @throws IndexException * If there is no matching tuple in the index. * */ public void upsert(ITupleReference tuple) throws HyracksDataException; /** * Creates a cursor appropriate for passing into search(). * * @throws HyracksDataException * */ public IIndexCursor createSearchCursor(boolean exclusive) throws HyracksDataException; /** * Open the given cursor for an index search using the given predicate as * search condition. * * @param icursor * Cursor over the index entries satisfying searchPred. * @param searchPred * Search condition. * @throws HyracksDataException * If the BufferCache throws while un/pinning or un/latching. * @throws IndexException */ public void search(IIndexCursor cursor, ISearchPredicate searchPred) throws HyracksDataException; }
response: public void upsert(ITupleReference tuple) throws HyracksDataException; public IIndexCursor createSearchCursor(boolean exclusive) throws HyracksDataException; public void search(IIndexCursor cursor, ISearchPredicate searchPred) throws HyracksDataException;

sample: 741
buggy_code:  public boolean append(byte[] bytes, int offset, int length) { if (tupleDataEndOffset + length + TUPLE_COUNT_SIZE <= frameSize) { <|startfocus|> if (buffer == null) { System.out.println("buffer null"); } <|endfocus|> System.arraycopy(bytes, offset, buffer.array(), tupleDataEndOffset, length); tupleDataEndOffset += length; return true; } return false;
code_review:  MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 
target code: public boolean append(byte[] bytes, int offset, int length) { if (tupleDataEndOffset + length + TUPLE_COUNT_SIZE <= frameSize) { System.arraycopy(bytes, offset, buffer.array(), tupleDataEndOffset, length); tupleDataEndOffset += length; return true; } return false;
response: public boolean append(byte[] bytes, int offset, int length) { if (tupleDataEndOffset + length + TUPLE_COUNT_SIZE <= frameSize) { if (buffer == null) { LOGGER.info("buffer null"); } System.arraycopy(bytes, offset, buffer.array(), tupleDataEndOffset, length); tupleDataEndOffset += length; return true; } return false; }

sample: 742
buggy_code:  invListTuple = invListCursor.getTuple(); if (!newSearchResult.append(invListTuple, 1)) { // For a final result, needs to pause when a frame becomes full to let the caller // consume the frame. SearchResult.append() should only return false for this case. return false; } invListTidx++; if (invListCursor.hasNext()) { invListCursor.next(); } } // append remaining elements from previous result set <|startfocus|> int countp = 0; <|endfocus|> while (resultTidx < prevResultFrameTupleCount) { resultTuple.reset(prevCurrentBuffer.array(), resultFrameTupleAcc.getTupleStartOffset(resultTidx)); count = getCount(resultTuple); if (!newSearchResult.append(resultTuple, count)) { // For a final result, needs to pause when a frame becomes full to let the caller // consume the frame. SearchResult.append() should only return false for this case. return false; } resultTidx++; checkPrevResultAndFetchNextFrame(prevSearchResult); } return finishMergingOneList(isFinalList, prevSearchResult, newSearchResult); } 
code_review:  MAJOR SonarQube violation: Remove this unused "countp" local variable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1481 
target code: invListTuple = invListCursor.getTuple(); if (!newSearchResult.append(invListTuple, 1)) { // For a final result, needs to pause when a frame becomes full to let the caller // consume the frame. SearchResult.append() should only return false for this case. return false; } invListTidx++; if (invListCursor.hasNext()) { invListCursor.next(); } } // append remaining elements from previous result set while (resultTidx < prevResultFrameTupleCount) { resultTuple.reset(prevCurrentBuffer.array(), resultFrameTupleAcc.getTupleStartOffset(resultTidx)); count = getCount(resultTuple); if (!newSearchResult.append(resultTuple, count)) { // For a final result, needs to pause when a frame becomes full to let the caller // consume the frame. SearchResult.append() should only return false for this case. return false; } resultTidx++; checkPrevResultAndFetchNextFrame(prevSearchResult); } return finishMergingOneList(isFinalList, prevSearchResult, newSearchResult); }
response: invListTuple = invListCursor.getTuple(); if (!newSearchResult.append(invListTuple, 1)) { return false; } invListTidx++; if (invListCursor.hasNext()) { invListCursor.next(); } while (resultTidx < prevResultFrameTupleCount) { resultTuple.reset(prevCurrentBuffer.array(), resultFrameTupleAcc.getTupleStartOffset(resultTidx)); count = getCount(resultTuple); if (!newSearchResult.append(resultTuple, count)) { return false; } resultTidx++; checkPrevResultAndFetchNextFrame(prevSearchResult); } return finishMergingOneList(isFinalList, prevSearchResult, newSearchResult);

sample: 743
buggy_code:  } private static final Map<Integer, ReplicationRequestType> TYPES = new HashMap<>(); static { Stream.of(ReplicationRequestType.values()).forEach(type -> TYPES.put(type.ordinal(), type)); } public static ByteBuffer readRequest(SocketChannel socketChannel, ByteBuffer dataBuffer) throws IOException { //read request size NetworkingUtil.readBytes(socketChannel, dataBuffer, Integer.BYTES); final int requestSize = dataBuffer.getInt(); if (dataBuffer.capacity() < requestSize) { dataBuffer = ByteBuffer.allocate(requestSize); } //read request <|startfocus|> NetworkingUtil.readBytes(socketChannel, dataBuffer, requestSize); <|endfocus|> return dataBuffer; } public static ReplicationRequestType getRequestType(SocketChannel socketChannel, ByteBuffer byteBuffer) throws IOException { //read replication request type NetworkingUtil.readBytes(socketChannel, byteBuffer, REPLICATION_REQUEST_TYPE_SIZE); return TYPES.get(byteBuffer.getInt()); } private static ByteBuffer getGoodbyeBuffer() { ByteBuffer bb = ByteBuffer.allocate(REPLICATION_REQUEST_TYPE_SIZE); bb.putInt(ReplicationRequestType.GOODBYE.ordinal()); bb.flip(); return bb; } 
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "dataBuffer". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: } private static final Map<Integer, ReplicationRequestType> TYPES = new HashMap<>(); static { Stream.of(ReplicationRequestType.values()).forEach(type -> TYPES.put(type.ordinal(), type)); } public static ByteBuffer readRequest(SocketChannel socketChannel, ByteBuffer dataBuffer) throws IOException { //read request size NetworkingUtil.readBytes(socketChannel, dataBuffer, Integer.BYTES); final int requestSize = dataBuffer.getInt(); if (dataBuffer.capacity() < requestSize) { dataBuffer = ByteBuffer.allocate(requestSize); } //read request NetworkingUtil.readBytes(socketChannel, buf, requestSize); return dataBuffer; } public static ReplicationRequestType getRequestType(SocketChannel socketChannel, ByteBuffer byteBuffer) throws IOException { //read replication request type NetworkingUtil.readBytes(socketChannel, byteBuffer, REPLICATION_REQUEST_TYPE_SIZE); return TYPES.get(byteBuffer.getInt()); } private static ByteBuffer getGoodbyeBuffer() { ByteBuffer bb = ByteBuffer.allocate(REPLICATION_REQUEST_TYPE_SIZE); bb.putInt(ReplicationRequestType.GOODBYE.ordinal()); bb.flip(); return bb; }
response: private static final Map<Integer, ReplicationRequestType> TYPES = new HashMap<>(); static { Stream.of(ReplicationRequestType.values()).forEach(type -> TYPES.put(type.ordinal(), type)); } public static ByteBuffer readRequest(SocketChannel socketChannel, ByteBuffer dataBuffer) throws IOException { NetworkingUtil.readBytes(socketChannel, dataBuffer, Integer.BYTES); final int requestSize = dataBuffer.getInt(); if (dataBuffer.capacity() < requestSize) { dataBuffer = ByteBuffer.allocate(requestSize); } NetworkingUtil.readBytes(socketChannel, dataBuffer, requestSize); return dataBuffer; } public static ReplicationRequestType getRequestType(SocketChannel socketChannel, ByteBuffer byteBuffer) throws IOException { NetworkingUtil.readBytes(socketChannel, byteBuffer, REPLICATION_REQUEST_TYPE_SIZE); return TYPES.get(byteBuffer.getInt()); } private static ByteBuffer getGoodbyeBuffer() { ByteBuffer bb = ByteBuffer.allocate(REPLICATION_REQUEST_TYPE_SIZE); bb.putInt(ReplicationRequestType.GOODBYE.ordinal()); bb.flip(); return bb; }

sample: 744
buggy_code: <|startfocus|> public static int getJobIdFromLogAckMessage(String msg) { return Integer.parseInt(msg.substring((msg.indexOf(JOB_REPLICATION_ACK) + 1))); <|endfocus|>
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public static int getTxnIdFromLogAckMessage(String msg) { return Integer.parseInt(msg.substring(msg.indexOf(LOG_REPLICATION_ACK) + 1));
response: public static int getJobIdFromLogAckMessage(String msg) { return Integer.parseInt(msg.substring(msg.indexOf(JOB_REPLICATION_ACK) + 1)); }

sample: 745
buggy_code:  ITupleReference highSearchKey = null; partSearcher.setNumTokensBoundsInSearchKeys(numTokensLowerBound, numTokensUpperBound); if (numTokensLowerBound < 0) { ctx.getBtreePred().setLowKeyComparator(ctx.getPrefixSearchCmp()); lowSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.getBtreePred().setLowKeyComparator(ctx.getSearchCmp()); lowSearchKey = partSearcher.getFullLowSearchKey(); } if (numTokensUpperBound < 0) { <|startfocus|> ctx.getBtreePred().setHighKeyComparator(ctx.getPrefixSearchCmp()); <|endfocus|> highSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.getBtreePred().setHighKeyComparator(ctx.getSearchCmp()); highSearchKey = partSearcher.getFullHighSearchKey(); } ctx.getBtreePred().setLowKey(lowSearchKey, true); ctx.getBtreePred().setHighKey(highSearchKey, true); ctx.getBtreeAccessor().search(ctx.getBtreeCursor(), ctx.getBtreePred()); boolean tokenExists = false; try { while (ctx.getBtreeCursor().hasNext()) { ctx.getBtreeCursor().next(); ITupleReference btreeTuple = ctx.getBtreeCursor().getTuple();
code_review:  MAJOR SonarQube violation: Split this 150 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: ITupleReference highSearchKey = null; partSearcher.setNumTokensBoundsInSearchKeys(numTokensLowerBound, numTokensUpperBound); if (numTokensLowerBound < 0) { ctx.getBtreePred().setLowKeyComparator(ctx.getPrefixSearchCmp()); lowSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.getBtreePred().setLowKeyComparator(ctx.getSearchCmp()); lowSearchKey = partSearcher.getFullLowSearchKey(); } if (numTokensUpperBound < 0) { ctx.btreePred.setHighKeyComparator(ctx.prefixSearchCmp); highSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.getBtreePred().setHighKeyComparator(ctx.getSearchCmp()); highSearchKey = partSearcher.getFullHighSearchKey(); } ctx.getBtreePred().setLowKey(lowSearchKey, true); ctx.getBtreePred().setHighKey(highSearchKey, true); ctx.getBtreeAccessor().search(ctx.getBtreeCursor(), ctx.getBtreePred()); boolean tokenExists = false; try { while (ctx.getBtreeCursor().hasNext()) { ctx.getBtreeCursor().next(); ITupleReference btreeTuple = ctx.getBtreeCursor().getTuple();
response: ITupleReference highSearchKey = null; partSearcher.setNumTokensBoundsInSearchKeys(numTokensLowerBound, numTokensUpperBound); if (numTokensLowerBound < 0) { ctx.getBtreePred().setLowKeyComparator(ctx.getPrefixSearchCmp()); lowSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.getBtreePred().setLowKeyComparator(ctx.getSearchCmp()); lowSearchKey = partSearcher.getFullLowSearchKey(); } if (numTokensUpperBound < 0) { ctx.getBtreePred().setHighKeyComparator(ctx.getPrefixSearchCmp()); highSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.getBtreePred().setHighKeyComparator(ctx.getSearchCmp()); highSearchKey = partSearcher.getFullHighSearchKey(); } ctx.getBtreePred().setLowKey(lowSearchKey, true); ctx.getBtreePred().setHighKey(highSearchKey, true); ctx.getBtreeAccessor().search(ctx.getBtreeCursor(), ctx.getBtreePred()); boolean tokenExists = false; try { while (ctx.getBtreeCursor().hasNext()) { ctx.getBtreeCursor().next(); ITupleReference btreeTuple = ctx.getBtreeCursor().getTuple(); } } catch (Exception e) { // Handle exception } finally { ctx.getBtreeCursor().close(); }

sample: 746
buggy_code:  } protected void createAndOpenFile() throws HyracksDataException { if (isInMemoryOpMode) { // In-memory mode should not generate a file. return; } if (searchResultWriter == null) { FileReference file = ctx.getJobletContext().createManagedWorkspaceFile(FILE_PREFIX); searchResultWriter = new RunFileWriter(file, ctx.getIoManager()); searchResultWriter.open(); isFileOpened = true; } <|startfocus|> // Temp : // System.out.println(file + " - InvertedIndexSearchResult::file create and open - "); <|endfocus|> } // Deallocates the I/O buffer (one frame). This should be the last oepration. protected void deallocateIOBuffer() throws HyracksDataException { if (ioBufferFrame != null) { // Temp : // System.out.println( // "InvertedIndexSearchResult::deallocateIOBuffer() buffer - " + ObjectUtils.identityToString(ioBuffer)); bufferManager.releaseFrame(ioBuffer); buffers.clear(); ioBufferFrame = null; ioBuffer = null; } } /**
code_review:  MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine 
target code: } protected void createAndOpenFile() throws HyracksDataException { if (isInMemoryOpMode) { // In-memory mode should not generate a file. return; } if (searchResultWriter == null) { FileReference file = ctx.getJobletContext().createManagedWorkspaceFile(FILE_PREFIX); searchResultWriter = new RunFileWriter(file, ctx.getIoManager()); searchResultWriter.open(); isFileOpened = true; } } // Deallocates the I/O buffer (one frame). This should be the last oepration. protected void deallocateIOBuffer() throws HyracksDataException { if (ioBufferFrame != null) { // Temp : // System.out.println( // "InvertedIndexSearchResult::deallocateIOBuffer() buffer - " + ObjectUtils.identityToString(ioBuffer)); bufferManager.releaseFrame(ioBuffer); buffers.clear(); ioBufferFrame = null; ioBuffer = null; } } /**
response: protected void createAndOpenFile() throws HyracksDataException { if (isInMemoryOpMode) { // In-memory mode should not generate a file. return; } if (searchResultWriter == null) { FileReference file = ctx.getJobletContext().createManagedWorkspaceFile(FILE_PREFIX); searchResultWriter = new RunFileWriter(file, ctx.getIoManager()); searchResultWriter.open(); isFileOpened = true; } } // Deallocates the I/O buffer (one frame). This should be the last operation. protected void deallocateIOBuffer() throws HyracksDataException { if (ioBufferFrame != null) { bufferManager.releaseFrame(ioBuffer); buffers.clear(); ioBufferFrame = null; ioBuffer = null; } }

sample: 747
buggy_code:  foundIn = i; return true; } } if (i == 0 && includeMutableComponent) { // unlatch/unpin btreeCursors[i].reset(); searchCallback.reconcile(predicate.getLowKey()); reconciled = true; // retraverse btreeAccessors[0].search(btreeCursors[i], predicate); if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); if (((ILSMTreeTupleReference) btreeCursors[i].getTuple()).isAntimatter()) { searchCallback.cancel(predicate.getLowKey()); <|startfocus|> btreeCursors[i].close(); <|endfocus|> return false; } else { frameTuple = btreeCursors[i].getTuple(); foundTuple = true; searchCallback.complete(predicate.getLowKey()); foundIn = i; return true; } } else { searchCallback.cancel(predicate.getLowKey()); btreeCursors[i].close(); } } else { frameTuple = btreeCursors[i].getTuple(); searchCallback.reconcile(frameTuple); searchCallback.complete(frameTuple); foundTuple = true; foundIn = i;
code_review:  MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 
target code: foundIn = i; return true; } } if (i == 0 && includeMutableComponent) { // unlatch/unpin btreeCursors[i].reset(); searchCallback.reconcile(predicate.getLowKey()); reconciled = true; // retraverse btreeAccessors[0].search(btreeCursors[i], predicate); if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); if (((ILSMTreeTupleReference) btreeCursors[i].getTuple()).isAntimatter()) { searchCallback.cancel(predicate.getLowKey()); rangeCursors[i].close(); return false; } else { frameTuple = btreeCursors[i].getTuple(); foundTuple = true; searchCallback.complete(predicate.getLowKey()); foundIn = i; return true; } } else { searchCallback.cancel(predicate.getLowKey()); btreeCursors[i].close(); } } else { frameTuple = btreeCursors[i].getTuple(); searchCallback.reconcile(frameTuple); searchCallback.complete(frameTuple); foundTuple = true; foundIn = i;
response: private boolean searchInBTreeCursors(int i, boolean includeMutableComponent) { if (i == 0 && includeMutableComponent) { btreeCursors[i].reset(); searchCallback.reconcile(predicate.getLowKey()); reconciled = true; btreeAccessors[0].search(btreeCursors[i], predicate); if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); if (((ILSMTreeTupleReference) btreeCursors[i].getTuple()).isAntimatter()) { searchCallback.cancel(predicate.getLowKey()); btreeCursors[i].close(); return false; } else { frameTuple = btreeCursors[i].getTuple(); foundTuple = true; searchCallback.complete(predicate.getLowKey()); foundIn = i; return true; } } else { searchCallback.cancel(predicate.getLowKey()); btreeCursors[i].close(); } } else { frameTuple = btreeCursors[i].getTuple(); searchCallback.reconcile(frameTuple); searchCallback.complete(frameTuple); foundTuple = true; foundIn = i; return true; } return false; }

sample: 748
buggy_code:  protected void appendToLogTail(ILogRecord logRecord) { syncAppendToLogTail(logRecord); if (waitForFlush(logRecord) && !logRecord.isFlushed()) { synchronized (logRecord) { while (!logRecord.isFlushed()) { try { logRecord.wait(); } catch (InterruptedException e) { // NOSONAR ensure txn survive at this stage // ignore interrupt } } <|startfocus|> } <|endfocus|> }
code_review:  why can't we reset the interrupted once the critical section is complete? 
target code: protected void appendToLogTail(ILogRecord logRecord) { syncAppendToLogTail(logRecord); if (waitForFlush(logRecord) && !logRecord.isFlushed()) { synchronized (logRecord) { while (!logRecord.isFlushed()) { try { logRecord.wait(); } catch (InterruptedException e) { // NOSONAR ensure txn survive at this stage // ignore interrupt } } }); }
response: protected void appendToLogTail(ILogRecord logRecord) { syncAppendToLogTail(logRecord); if (waitForFlush(logRecord) && !logRecord.isFlushed()) { synchronized (logRecord) { while (!logRecord.isFlushed()) { try { logRecord.wait(); } catch (InterruptedException e) { // NOSONAR ensure txn survive at this stage // ignore interrupt Thread.currentThread().interrupt(); } } } } }

sample: 749
buggy_code:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.common.replication; import java.util.HashMap; import java.util.Map; public class ReplicationStrategyFactory { private static final Map<String, Class<? extends IReplicationStrategy>> BUILT_IN_REPLICATION_STRATEGY = new HashMap<>(); static { <|startfocus|> BUILT_IN_REPLICATION_STRATEGY.put("no_replication", NoReplicationStrategy.class); <|endfocus|> BUILT_IN_REPLICATION_STRATEGY.put("all", AllDatasetsReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("metadata", MetadataOnlyReplicationStrategy.class); } private ReplicationStrategyFactory() { throw new AssertionError(); } public static IReplicationStrategy create(String name) { String strategyName = name.toLowerCase(); if (!BUILT_IN_REPLICATION_STRATEGY.containsKey(strategyName)) { throw new IllegalStateException("Couldn't find strategy with name: " + name); } Class<? extends IReplicationStrategy> clazz = BUILT_IN_REPLICATION_STRATEGY.get(strategyName); try {
code_review:  none 
target code: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.common.replication; import java.util.HashMap; import java.util.Map; public class ReplicationStrategyFactory { private static final Map<String, Class<? extends IReplicationStrategy>> BUILT_IN_REPLICATION_STRATEGY = new HashMap<>(); static { BUILT_IN_REPLICATION_STRATEGY.put("none", NoReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("all", AllDatasetsReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("metadata", MetadataOnlyReplicationStrategy.class); } private ReplicationStrategyFactory() { throw new AssertionError(); } public static IReplicationStrategy create(String name) { String strategyName = name.toLowerCase(); if (!BUILT_IN_REPLICATION_STRATEGY.containsKey(strategyName)) { throw new IllegalStateException("Couldn't find strategy with name: " + name); } Class<? extends IReplicationStrategy> clazz = BUILT_IN_REPLICATION_STRATEGY.get(strategyName); try {
response: Refactored Code: ```java * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.common.replication; import java.util.HashMap; import java.util.Map; public class ReplicationStrategyFactory { private static final Map<String, Class<? extends IReplicationStrategy>> BUILT_IN_REPLICATION_STRATEGY = new HashMap<>(); static { BUILT_IN_REPLICATION_STRATEGY.put("no_replication", NoReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("all", AllDatasetsReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("metadata", MetadataOnlyReplicationStrategy.class); } private ReplicationStrategyFactory() { throw new AssertionError(); } public static IReplicationStrategy create(String name) { String strategyName = name.toLowerCase(); if (!BUILT_IN_REPLICATION_STRATEGY.containsKey(strategyName)) { throw new IllegalStateException("Couldn't find strategy with name: " + name); } Class<? extends IReplicationStrategy> clazz = BUILT_IN_REPLICATION_STRATEGY.get(strategyName); try { return clazz.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new IllegalStateException("Failed to create replication strategy: " + name, e); } } } ```

sample: 750
buggy_code:  setNumActiveIOOps(getNumActiveIOOps() + 1); } public synchronized void undeclareActiveIOOperation() { setNumActiveIOOps(getNumActiveIOOps() - 1); //notify threads waiting on this dataset info notifyAll(); } public synchronized Set<ILSMIndex> getDatasetIndexes() { Set<ILSMIndex> datasetIndexes = new HashSet<>(); for (IndexInfo iInfo : getIndexes().values()) { if (iInfo.isOpen()) { datasetIndexes.add(iInfo.getIndex()); } } <|startfocus|> return datasetIndexes; <|endfocus|> } @Override public int compareTo(DatasetInfo i) { // sort by (isOpen, referenceCount, lastAccess) ascending, where true < false // // Example sort order: // ------------------- // (F, 0, 70) <-- largest // (F, 0, 60) // (T, 10, 80) // (T, 10, 70) // (T, 9, 90) // (T, 0, 100) <-- smallest if (isOpen() && !i.isOpen()) { return -1;
code_review:  MAJOR SonarQube violation: Rename "partitionIndexes" which hides the field declared at line 34. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck 
target code: setNumActiveIOOps(getNumActiveIOOps() + 1); } public synchronized void undeclareActiveIOOperation() { setNumActiveIOOps(getNumActiveIOOps() - 1); //notify threads waiting on this dataset info notifyAll(); } public synchronized Set<ILSMIndex> getDatasetIndexes() { Set<ILSMIndex> datasetIndexes = new HashSet<>(); for (IndexInfo iInfo : getIndexes().values()) { if (iInfo.isOpen()) { datasetIndexes.add(iInfo.getIndex()); } } return indexSet; } @Override public int compareTo(DatasetInfo i) { // sort by (isOpen, referenceCount, lastAccess) ascending, where true < false // // Example sort order: // ------------------- // (F, 0, 70) <-- largest // (F, 0, 60) // (T, 10, 80) // (T, 10, 70) // (T, 9, 90) // (T, 0, 100) <-- smallest if (isOpen() && !i.isOpen()) { return -1;
response: private int numActiveIOOps; public synchronized void declareActiveIOOperation() { numActiveIOOps++; } public synchronized void undeclareActiveIOOperation() { numActiveIOOps--; notifyAll(); } public synchronized Set<ILSMIndex> getDatasetIndexes() { Set<ILSMIndex> datasetIndexes = new HashSet<>(); for (IndexInfo iInfo : indexes.values()) { if (iInfo.isOpen()) { datasetIndexes.add(iInfo.getIndex()); } } return datasetIndexes; } @Override public int compareTo(DatasetInfo i) { if (isOpen() && !i.isOpen()) { return -1; } else if (!isOpen() && i.isOpen()) { return 1; } else { int referenceCountComparison = Integer.compare(referenceCount, i.referenceCount); if (referenceCountComparison != 0) { return referenceCountComparison; } else { return Long.compare(lastAccess, i.lastAccess); } } }

sample: 751
buggy_code:  ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { closeDataset(dslc.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { <|startfocus|> ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { if (dslc.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dslc.getDatasetInfo()); <|endfocus|> } } } @Override public synchronized void stop(boolean dumpState, OutputStream outputStream) throws IOException { if (stopped) { return; } if (dumpState) { dumpState(outputStream); } closeAllDatasets(); datasetLifecycles.clear();
code_review:  MAJOR SonarQube violation: Split this 133 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { closeDataset(dslc.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { if (dsr.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dsr.getDatasetInfo()); } } } @Override public synchronized void stop(boolean dumpState, OutputStream outputStream) throws IOException { if (stopped) { return; } if (dumpState) { dumpState(outputStream); } closeAllDatasets(); datasetLifecycles.clear();
response: ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { closeDataset(dslc.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { if (dslc.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dslc.getDatasetInfo()); } } } @Override public synchronized void stop(boolean dumpState, OutputStream outputStream) throws IOException { if (stopped) { return; } if (dumpState) { dumpState(outputStream); } closeAllDatasets(); datasetLifecycles.clear(); }

sample: 752
buggy_code:  synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { closeDataset(dslc.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { <|startfocus|> ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { if (dslc.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dslc.getDatasetInfo()); <|endfocus|> } } } @Override public synchronized void stop(boolean dumpState, OutputStream outputStream) throws IOException { if (stopped) { return; } if (dumpState) { dumpState(outputStream); } closeAllDatasets(); datasetLifecycles.clear(); stopped = true; } @Override
code_review:  MAJOR SonarQube violation: Split this 128 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { closeDataset(dslc.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { if (dsr.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dsr.getDatasetInfo()); } } } @Override public synchronized void stop(boolean dumpState, OutputStream outputStream) throws IOException { if (stopped) { return; } if (dumpState) { dumpState(outputStream); } closeAllDatasets(); datasetLifecycles.clear(); stopped = true; } @Override
response: synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { closeDataset(dslc.getDatasetInfo()); } ArrayList<DatasetLifecycle> openDatasets = new ArrayList<>(datasetLifecycles.values()); for (DatasetLifecycle dslc : openDatasets) { if (dslc.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dslc.getDatasetInfo()); } } if (stopped) { return; } if (dumpState) { dumpState(outputStream); } closeAllDatasets(); datasetLifecycles.clear(); stopped = true;

sample: 753
buggy_code:  protected void cleanupForAbort() { <|startfocus|> for(Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>>e:primaryIndexTrackers.entrySet()) { <|endfocus|> AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
code_review:  MAJOR SonarQube violation: ':' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
response: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); } }

sample: 754
buggy_code:  protected void cleanupForAbort() { <|startfocus|> for(Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>>e:primaryIndexTrackers.entrySet()) { <|endfocus|> AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
code_review:  MAJOR SonarQube violation: ':' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
response: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); } }

sample: 755
buggy_code:  protected void cleanupForAbort() { <|startfocus|> for(Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>>e:primaryIndexTrackers.entrySet()) { <|endfocus|> AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
code_review:  MAJOR SonarQube violation: '>' is followed by an illegal character. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Acom.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck 
target code: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
response: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); } }

sample: 756
buggy_code:  protected void cleanupForAbort() { <|startfocus|> for(Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>>e:primaryIndexTrackers.entrySet()) { <|endfocus|> AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
code_review:  MAJOR SonarQube violation: 'for' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
response: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); } }

sample: 757
buggy_code:  protected void cleanupForAbort() { <|startfocus|> for(Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>>e:primaryIndexTrackers.entrySet()) { <|endfocus|> AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
code_review:  MAJOR SonarQube violation: Split this 130 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); }
response: protected void cleanupForAbort() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) { AtomicInteger pendingOps = partitionPendingOps.get(e.getKey()); e.getValue().first.cleanupNumActiveOperationsForAbortedJob(pendingOps.get()); } }

sample: 758
buggy_code:  return primaryKeyVars; } /** * Returns the search key expression which feeds a secondary-index search. If we are optimizing a selection query * then this method returns the a ConstantExpression from the first constant value in the optimizable function * expression. * If we are optimizing a join, then this method returns the VariableReferenceExpression that should feed the * secondary index probe. * * @throws AlgebricksException */ <|startfocus|> public static Pair<ILogicalExpression, ILogicalExpression> createSearchKeyExpr(Index index, <|endfocus|> IOptimizableFuncExpr optFuncExpr, IAType indexedFieldType, OptimizableOperatorSubTree probeSubTree) throws AlgebricksException { if (probeSubTree == null) { // We are optimizing a selection query. Search key is a constant. // Type Checking and type promotion is done here if (optFuncExpr.getNumConstantExpr() == 0) { //We are looking at a selection case, but using two variables //This means that the second variable comes from a nonPure function call //TODO: Right now we miss on type promotion for nonpure functions
code_review:  MAJOR SonarQube violation: The Cyclomatic Complexity of this method "createSearchKeyExpr" is 32 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity 
target code: return primaryKeyVars; } /** * Returns the search key expression which feeds a secondary-index search. If we are optimizing a selection query * then this method returns the a ConstantExpression from the first constant value in the optimizable function * expression. * If we are optimizing a join, then this method returns the VariableReferenceExpression that should feed the * secondary index probe. * * @throws AlgebricksException */ public static Triple<ILogicalExpression, ILogicalExpression, Boolean> createSearchKeyExpr(Index index, IOptimizableFuncExpr optFuncExpr, IAType indexedFieldType, OptimizableOperatorSubTree probeSubTree) throws AlgebricksException { if (probeSubTree == null) { // We are optimizing a selection query. Search key is a constant. // Type Checking and type promotion is done here if (optFuncExpr.getNumConstantExpr() == 0) { //We are looking at a selection case, but using two variables //This means that the second variable comes from a nonPure function call //TODO: Right now we miss on type promotion for nonpure functions
response: Fixed Code: jobGenParams.writeToFuncArgs(secondaryIndexFuncArgs); List<LogicalVariable> secondaryIndexUnnestVars = new ArrayList<LogicalVariable>(); List<Object> secondaryIndexOutputTypes = new ArrayList<Object>(); appendSecondaryIndexOutputVars(dataset, recordType, metaRecordType, index, outputPrimaryKeysOnly, context, secondaryIndexUnnestVars); appendSecondaryIndexTypes(dataset, recordType, metaRecordType, index, outputPrimaryKeysOnly, secondaryIndexOutputTypes); IFunctionInfo secondaryIndexSearch = FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.INDEX_SEARCH); UnnestingFunctionCallExpression secondaryIndexSearchFunc = new UnnestingFunctionCallExpression(secondaryIndexSearch, secondaryIndexFuncArgs); secondaryIndexSearchFunc.setReturnsUniqueValues(true);

sample: 759
buggy_code:  if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null, logManager.getNodeId(), indexes.size()); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { <|startfocus|> throw new HyracksDataException(e); <|endfocus|> } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) {
code_review:  CRITICAL SonarQube violation: Remove this call to "wait" or move it into a "while" loop. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2274 
target code: if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null, logManager.getNodeId(), indexes.size()); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) {
response: if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null, logManager.getNodeId(), indexes.size()); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } while (!logRecord.isFlushed()) { try { logRecord.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } } for (ILSMIndex index : indexes) { AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // perform synchronous flush } }

sample: 760
buggy_code:  synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null, logManager.getNodeId(), indexes.size()); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { <|startfocus|> throw new HyracksDataException(e); <|endfocus|> } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially.
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null, logManager.getNodeId(), indexes.size()); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially.
response: synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null, logManager.getNodeId(), indexes.size()); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { logRecord.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } for (ILSMIndex index : indexes) { AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially. } }

sample: 761
buggy_code:  try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { <|startfocus|> if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } <|endfocus|> } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) {
code_review:  CRITICAL SonarQube violation: Remove this call to "wait" or move it into a "while" loop. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2274 
target code: try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { closeIndex(iInfo); } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) {
response: try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } }

sample: 762
buggy_code:  try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { <|startfocus|> if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } <|endfocus|> } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) {
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { closeIndex(iInfo); } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) {
response: try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { closeDataset(dsr.getDatasetInfo()); } } @Override public synchronized void closeUserDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { try { closeDataset(dsr.getDatasetInfo()); } catch (HyracksDataException e) { // handle exception } } }

sample: 763
buggy_code:  // we will force all jobs to spill their cached entities to disk. // This could happen only when we have many jobs with small // number of records and none of them have job commit. freeJobsCachedEntities(txnId); } jobId2WinnerEntitiesMap.put(txnId, jobEntityWinners); } else { jobEntityWinners = jobId2WinnerEntitiesMap.get(txnId); } jobEntityWinners.add(logRecord); } <|startfocus|> @SuppressWarnings({"squid:MethodCyclomaticComplexity","squid:S134"}) <|endfocus|> private synchronized void startRecoveryRedoPhase(Set<Integer> partitions, ILogReader logReader, long lowWaterMarkLSN, Set<Long> winnerTxnSet) throws IOException, ACIDException { int redoCount = 0; long txnId = 0; long resourceId; long maxDiskLastLsn; long lsn = -1; ILSMIndex index = null; LocalResource localResource = null; DatasetLocalResource localResourceMetadata = null; boolean foundWinner = false; JobEntityCommits jobEntityWinners = null; IAppRuntimeContextProvider appRuntimeContext = txnSubsystem.getAsterixAppRuntimeContextProvider(); IDatasetLifecycleManager datasetLifecycleManager = appRuntimeContext.getDatasetLifecycleManager();
code_review:  remove this. It is better that we get the warning so that we know this is a good candidate to refactor. 
target code: // we will force all jobs to spill their cached entities to disk. // This could happen only when we have many jobs with small // number of records and none of them have job commit. freeJobsCachedEntities(txnId); } jobId2WinnerEntitiesMap.put(txnId, jobEntityWinners); } else { jobEntityWinners = jobId2WinnerEntitiesMap.get(txnId); } jobEntityWinners.add(logRecord); } private synchronized void startRecoveryRedoPhase(Set<Integer> partitions, ILogReader logReader, long lowWaterMarkLSN, Set<Long> winnerTxnSet) throws IOException, ACIDException { int redoCount = 0; long txnId = 0; long resourceId; long maxDiskLastLsn; long lsn = -1; ILSMIndex index = null; LocalResource localResource = null; DatasetLocalResource localResourceMetadata = null; boolean foundWinner = false; JobEntityCommits jobEntityWinners = null; IAppRuntimeContextProvider appRuntimeContext = txnSubsystem.getAsterixAppRuntimeContextProvider(); IDatasetLifecycleManager datasetLifecycleManager = appRuntimeContext.getDatasetLifecycleManager();
response: // we will force all jobs to spill their cached entities to disk. // This could happen only when we have many jobs with small // number of records and none of them have job commit. freeJobsCachedEntities(txnId); jobId2WinnerEntitiesMap.put(txnId, jobEntityWinners); } else { jobEntityWinners = jobId2WinnerEntitiesMap.get(txnId); } jobEntityWinners.add(logRecord); @SuppressWarnings({"squid:MethodCyclomaticComplexity","squid:S134"}) private synchronized void startRecoveryRedoPhase(Set<Integer> partitions, ILogReader logReader, long lowWaterMarkLSN, Set<Long> winnerTxnSet) throws IOException, ACIDException { int redoCount = 0; long txnId = 0; long resourceId; long maxDiskLastLsn; long lsn = -1; ILSMIndex index = null; LocalResource localResource = null; DatasetLocalResource localResourceMetadata = null; boolean foundWinner = false; JobEntityCommits jobEntityWinners = null; IAppRuntimeContextProvider appRuntimeContext = txnSubsystem.getAsterixAppRuntimeContextProvider(); IDatasetLifecycleManager datasetLifecycleManager = appRuntimeContext.getDatasetLifecycleManager();

sample: 764
buggy_code:  private void doWriteLogRecord(ByteBuffer buffer) { buffer.put(logSource); buffer.put(logType); buffer.putLong(txnId); switch (logType) { case LogType.ENTITY_COMMIT: <|startfocus|> writeEntityInfo(buffer); <|endfocus|> break; case LogType.UPDATE: writeEntityInfo(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); if (oldValueSize > 0) { buffer.putInt(oldValueSize); buffer.putInt(oldValueFieldCount); writeTuple(buffer, oldValue, oldValueSize); } break; case LogType.FILTER: writeEntityInfoNoPK(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); break; case LogType.FLUSH: buffer.putInt(datasetId); break; case LogType.MARKER: buffer.putInt(datasetId); buffer.putInt(resourcePartition); callback.before(buffer); buffer.putInt(logSize);
code_review:  writeEntityResource 
target code: private void doWriteLogRecord(ByteBuffer buffer) { buffer.put(logSource); buffer.put(logType); buffer.putLong(txnId); switch (logType) { case LogType.ENTITY_COMMIT: writeEntityResource(buffer); writeEntityValue(buffer); break; case LogType.UPDATE: writeEntityInfo(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); if (oldValueSize > 0) { buffer.putInt(oldValueSize); buffer.putInt(oldValueFieldCount); writeTuple(buffer, oldValue, oldValueSize); } break; case LogType.FILTER: writeEntityInfoNoPK(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); break; case LogType.FLUSH: buffer.putInt(datasetId); break; case LogType.MARKER: buffer.putInt(datasetId); buffer.putInt(resourcePartition); callback.before(buffer); buffer.putInt(logSize);
response: private void doWriteLogRecord(ByteBuffer buffer) { buffer.put(logSource); buffer.put(logType); buffer.putLong(txnId); switch (logType) { case LogType.ENTITY_COMMIT: writeEntityInfo(buffer); break; case LogType.UPDATE: writeEntityInfo(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); if (oldValueSize > 0) { buffer.putInt(oldValueSize); buffer.putInt(oldValueFieldCount); writeTuple(buffer, oldValue, oldValueSize); } break; case LogType.FILTER: writeEntityInfoNoPK(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); break; case LogType.FLUSH: buffer.putInt(datasetId); break; case LogType.MARKER: buffer.putInt(datasetId); buffer.putInt(resourcePartition); callback.before(buffer); buffer.putInt(logSize); break; } }

sample: 765
buggy_code: <|startfocus|> private void writeEntityInfo(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId); <|endfocus|> buffer.putInt(PKHashValue); if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } buffer.putInt(PKValueSize); writePKValue(buffer);
code_review:  writeEntityValue 
target code: private void writeEntityValue(ByteBuffer buffer) { buffer.putInt(PKHashValue); if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } buffer.putInt(PKValueSize); writePKValue(buffer);
response: private void writeEntityInfo(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId); buffer.putInt(PKHashValue); if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } buffer.putInt(PKValueSize); writePKValue(buffer); }

sample: 766
buggy_code: <|startfocus|> private void writeEntityInfo(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId); <|endfocus|> buffer.putInt(PKHashValue); if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } buffer.putInt(PKValueSize); writePKValue(buffer);
code_review:  remove 
target code: private void writeEntityValue(ByteBuffer buffer) { buffer.putInt(PKHashValue); if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } buffer.putInt(PKValueSize); writePKValue(buffer);
response: private void writeEntityInfo(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId); buffer.putInt(PKHashValue); if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } buffer.putInt(PKValueSize); writePKValue(buffer); }

sample: 767
buggy_code: <|startfocus|> private void writeEntityInfoNoPK(ByteBuffer buffer) { <|endfocus|> buffer.putInt(resourcePartition); buffer.putInt(datasetId);
code_review:  writeEntityResource 
target code: private void writeEntityResource(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId);
response: private void writeEntityResource(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId); }

sample: 768
buggy_code:  txnId = buffer.getLong(); switch (logType) { case LogType.FLUSH: if (buffer.remaining() < ILogRecord.DS_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourceId = 0l; // fall throuh case LogType.WAIT: computeAndSetLogSize(); break; case LogType.JOB_COMMIT: case LogType.ABORT: datasetId = -1; PKHashValue = -1; computeAndSetLogSize(); break; case LogType.ENTITY_COMMIT: <|startfocus|> if (readEntityInfo(buffer)) { <|endfocus|> computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) {
code_review:  readEntityResource 
target code: txnId = buffer.getLong(); switch (logType) { case LogType.FLUSH: if (buffer.remaining() < ILogRecord.DS_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourceId = 0l; // fall throuh case LogType.WAIT: computeAndSetLogSize(); break; case LogType.JOB_COMMIT: case LogType.ABORT: datasetId = -1; PKHashValue = -1; computeAndSetLogSize(); break; case LogType.ENTITY_COMMIT: if (readEntityResource(buffer) && readEntityValue(buffer)) { computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) {
response: txnId = buffer.getLong(); switch (logType) { case LogType.FLUSH: if (buffer.remaining() < ILogRecord.DS_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourceId = 0l; // fall through case LogType.WAIT: computeAndSetLogSize(); break; case LogType.JOB_COMMIT: case LogType.ABORT: datasetId = -1; PKHashValue = -1; computeAndSetLogSize(); break; case LogType.ENTITY_COMMIT: if (readEntityInfo(buffer)) { computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; }

sample: 769
buggy_code:  if (readEntityInfo(buffer)) { computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: <|startfocus|> if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; <|endfocus|> } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining = logSize - MARKER_BASE_LOG_SIZE;
code_review:  readEntityResource 
target code: if (readEntityInfo(buffer)) { computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityResource(buffer)) { return readUpdateInfo(buffer); } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining = logSize - MARKER_BASE_LOG_SIZE;
response: if (readEntityInfo(buffer)) { computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining = logSize - MARKER_BASE_LOG_SIZE;

sample: 770
buggy_code:  computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: <|startfocus|> if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; <|endfocus|> } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining = logSize - MARKER_BASE_LOG_SIZE; if (buffer.remaining() < lenRemaining) {
code_review:  return 
target code: computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityResource(buffer)) { return readUpdateInfo(buffer); } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining = logSize - MARKER_BASE_LOG_SIZE; if (buffer.remaining() < lenRemaining) {
response: Buggy Code: computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining = logSize - MARKER_BASE_LOG_SIZE; if (buffer.remaining() < lenRemaining) { return RecordReadStatus.TRUNCATED; } Refactored Code: computeAndSetLogSize(); } else { return RecordReadStatus.TRUNCATED; } break; case LogType.UPDATE: if (readEntityInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.FILTER: if (readEntityNoPKInfo(buffer)) { RecordReadStatus updStatus = readUpdateInfo(buffer); if (updStatus != RecordReadStatus.OK) { return updStatus; } } else { return RecordReadStatus.TRUNCATED; } break; case LogType.MARKER: if (buffer.remaining() < DS_LEN + RS_PARTITION_LEN + PRVLSN_LEN + LOGRCD_SZ_LEN) { return RecordReadStatus.TRUNCATED; } datasetId = buffer.getInt(); resourcePartition = buffer.getInt(); prevMarkerLSN = buffer.getLong(); logSize = buffer.getInt(); int lenRemaining

sample: 771
buggy_code:  private boolean readEntityInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length <|startfocus|> if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { <|endfocus|> return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); PKHashValue = buffer.getInt(); PKValueSize = buffer.getInt(); // attempt to read in the PK if (buffer.remaining() < PKValueSize) { return false; } if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } PKValue = readPKValue(buffer); return true;
code_review:  readEntityValue 
target code: private boolean readEntityInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length if (buffer.remaining() < ENTITY_VALUE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); PKHashValue = buffer.getInt(); PKValueSize = buffer.getInt(); // attempt to read in the PK if (buffer.remaining() < PKValueSize) { return false; } if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } PKValue = readPKValue(buffer); return true;
response: private boolean readEntityInfo(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); PKHashValue = buffer.getInt(); PKValueSize = buffer.getInt(); if (buffer.remaining() < PKValueSize) { return false; } if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } PKValue = readPKValue(buffer); return true; }

sample: 772
buggy_code:  private boolean readEntityInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { return false; } <|startfocus|> resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); <|endfocus|> PKHashValue = buffer.getInt(); PKValueSize = buffer.getInt(); // attempt to read in the PK if (buffer.remaining() < PKValueSize) { return false; } if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } PKValue = readPKValue(buffer); return true;
code_review:  remove 
target code: private boolean readEntityInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { return false; } PKHashValue = buffer.getInt(); PKValueSize = buffer.getInt(); // attempt to read in the PK if (buffer.remaining() < PKValueSize) { return false; } if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } PKValue = readPKValue(buffer); return true;
response: private boolean readEntityInfo(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); PKHashValue = buffer.getInt(); PKValueSize = buffer.getInt(); if (buffer.remaining() < PKValueSize) { return false; } if (PKValueSize <= 0) { throw new IllegalStateException("Primary Key Size is less than or equal to 0"); } PKValue = readPKValue(buffer); return true; }

sample: 773
buggy_code: <|startfocus|> private boolean readEntityNoPKInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { <|endfocus|> return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true;
code_review:  readEntityResource 
target code: private boolean readEntityResource(ByteBuffer buffer) { //attempt to read in the resourcePartition and dsid if (buffer.remaining() < ENTITY_RESOURCE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true;
response: private boolean readEntityNoPKInfo(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true; }

sample: 774
buggy_code: <|startfocus|> private boolean readEntityNoPKInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { <|endfocus|> return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true;
code_review:  fix comment 
target code: private boolean readEntityResource(ByteBuffer buffer) { //attempt to read in the resourcePartition and dsid if (buffer.remaining() < ENTITY_RESOURCE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true;
response: private boolean readEntityNoPKInfo(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true; }

sample: 775
buggy_code: <|startfocus|> private boolean readEntityNoPKInfo(ByteBuffer buffer) { //attempt to read in the resourcePartition, dsid, PK hash and PK length if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) { <|endfocus|> return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true;
code_review:  this isn't correct. You need a new one for entity resource length, then adjust ENTITYCOMMIT_UPDATE_HEADER_LEN 
target code: private boolean readEntityResource(ByteBuffer buffer) { //attempt to read in the resourcePartition and dsid if (buffer.remaining() < ENTITY_RESOURCE_HEADER_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true;
response: private boolean readEntityNoPKInfo(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN + ENTITY_RESOURCE_LENGTH_LEN) { return false; } resourcePartition = buffer.getInt(); datasetId = buffer.getInt(); return true; }

sample: 776
buggy_code:  if (isDeleteOperation(tuple, numOfPrimaryKeys)) { // Only delete if it is a delete and not upsert abstractModCallback.setOp(Operation.DELETE); lsmAccessor.forceDelete(tuple); recordWasDeleted = true; } else { abstractModCallback.setOp(Operation.UPSERT); lsmAccessor.forceUpsert(tuple); recordWasInserted = true; } if (isFiltered && prevTuple != null) { // need to update the filter of the new component with the previous value <|startfocus|> lsmAccessor.updateFilter(prevTuple, true); <|endfocus|> } writeOutput(index, recordWasInserted, recordWasDeleted); } catch (Exception e) { throw HyracksDataException.create(e); } } @Override public void start() throws HyracksDataException { lsmAccessor.getCtx().setOperation(IndexOperation.UPSERT); } @Override public void finish() throws HyracksDataException { lsmAccessor.getCtx().setOperation(IndexOperation.UPSERT); } }; } // we have the permutation which has [pk locations, record location, optional:filter-location] // the index -> we don't need anymore data?
code_review:  revert 
target code: if (isDeleteOperation(tuple, numOfPrimaryKeys)) { // Only delete if it is a delete and not upsert abstractModCallback.setOp(Operation.DELETE); lsmAccessor.forceDelete(tuple); recordWasDeleted = true; } else { abstractModCallback.setOp(Operation.UPSERT); lsmAccessor.forceUpsert(tuple); recordWasInserted = true; } if (isFiltered && prevTuple != null) { // need to update the filter of the new component with the previous value lsmAccessor.updateFilter(prevTuple); } writeOutput(index, recordWasInserted, recordWasDeleted); } catch (Exception e) { throw HyracksDataException.create(e); } } @Override public void start() throws HyracksDataException { lsmAccessor.getCtx().setOperation(IndexOperation.UPSERT); } @Override public void finish() throws HyracksDataException { lsmAccessor.getCtx().setOperation(IndexOperation.UPSERT); } }; } // we have the permutation which has [pk locations, record location, optional:filter-location] // the index -> we don't need anymore data?
response: if (isDeleteOperation(tuple, numOfPrimaryKeys)) { abstractModCallback.setOp(Operation.DELETE); lsmAccessor.forceDelete(tuple); recordWasDeleted = true; } else { abstractModCallback.setOp(Operation.UPSERT); lsmAccessor.forceUpsert(tuple); recordWasInserted = true; } if (isFiltered && prevTuple != null) { lsmAccessor.updateFilter(prevTuple, true); } writeOutput(index, recordWasInserted, recordWasDeleted); } catch (Exception e) { throw HyracksDataException.create(e); } } @Override public void start() throws HyracksDataException { lsmAccessor.getCtx().setOperation(IndexOperation.UPSERT); } @Override public void finish() throws HyracksDataException { lsmAccessor.getCtx().setOperation(IndexOperation.UPSERT); } }; return modCallback; }

sample: 777
buggy_code:  * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.ophelpers; public enum IndexOperation { CREATE, INSERT, DELETE, UPDATE, UPSERT, FILTER_MOD, <|startfocus|> SEARCH, <|endfocus|> DISKORDERSCAN, PHYSICALDELETE, NOOP, MERGE, FULL_MERGE, FLUSH, REPLICATE, DISK_COMPONENT_SCAN, DELETE_MEMORY_COMPONENT, DELETE_DISK_COMPONENTS } 
code_review:  you shouldn't need this 
target code: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.ophelpers; public enum IndexOperation { CREATE, INSERT, DELETE, UPDATE, UPSERT, FILTER_MOD, SEARCH, FILTER_MOD, DISKORDERSCAN, PHYSICALDELETE, NOOP, MERGE, FULL_MERGE, FLUSH, REPLICATE, DISK_COMPONENT_SCAN, DELETE_MEMORY_COMPONENT, DELETE_DISK_COMPONENTS }
response: import org.apache.hyracks.storage.am.common.ophelpers.IndexOperation; public enum IndexOperation { CREATE, INSERT, DELETE, UPDATE, UPSERT, FILTER_MOD, SEARCH, DISKORDERSCAN, PHYSICALDELETE, NOOP, MERGE, FULL_MERGE, FLUSH, REPLICATE, DISK_COMPONENT_SCAN, DELETE_MEMORY_COMPONENT, DELETE_DISK_COMPONENTS }

sample: 778
buggy_code:  ctx.setOperation(IndexOperation.UPSERT); lsmHarness.forceUpdateMeta(ctx, key, value); } @Override public ITreeIndexCursor createSearchCursor(boolean exclusive) { return cursorFactory.create(ctx); } @Override public void updateFilter(ITupleReference tuple) throws HyracksDataException { ctx.setOperation(IndexOperation.UPSERT); lsmHarness.updateFilter(ctx, tuple); } <|startfocus|> public void updateFilter(ITupleReference tuple, boolean callback) throws HyracksDataException { ctx.setOperation(IndexOperation.UPSERT); lsmHarness.updateFilter(ctx, tuple, callback); } <|endfocus|> public void batchOperate(FrameTupleAccessor accessor, FrameTupleReference tuple, IFrameTupleProcessor processor, IFrameOperationCallback frameOpCallback) throws HyracksDataException { lsmHarness.batchOperate(ctx, accessor, tuple, processor, frameOpCallback); } @Override public void scanDiskComponents(IIndexCursor cursor) throws HyracksDataException { ctx.setOperation(IndexOperation.DISK_COMPONENT_SCAN); lsmHarness.scanDiskComponents(ctx, cursor); } @Override public String toString() { return getClass().getSimpleName() + ':' + lsmHarness.toString(); } @Override
code_review:  remove 
target code: ctx.setOperation(IndexOperation.UPSERT); lsmHarness.forceUpdateMeta(ctx, key, value); } @Override public ITreeIndexCursor createSearchCursor(boolean exclusive) { return cursorFactory.create(ctx); } @Override public void updateFilter(ITupleReference tuple) throws HyracksDataException { ctx.setOperation(IndexOperation.UPSERT); lsmHarness.updateFilter(ctx, tuple); } public void batchOperate(FrameTupleAccessor accessor, FrameTupleReference tuple, IFrameTupleProcessor processor, IFrameOperationCallback frameOpCallback) throws HyracksDataException { lsmHarness.batchOperate(ctx, accessor, tuple, processor, frameOpCallback); } @Override public void scanDiskComponents(IIndexCursor cursor) throws HyracksDataException { ctx.setOperation(IndexOperation.DISK_COMPONENT_SCAN); lsmHarness.scanDiskComponents(ctx, cursor); } @Override public String toString() { return getClass().getSimpleName() + ':' + lsmHarness.toString(); } @Override
response: public PhoneSubInfo(Phone phone) { mPhone = phone; mContext = phone.getContext(); } public void updateFilter(ITupleReference tuple, boolean callback) throws HyracksDataException { ctx.setOperation(IndexOperation.UPSERT); lsmHarness.updateFilter(ctx, tuple, callback); } public void batchOperate(FrameTupleAccessor accessor, FrameTupleReference tuple, IFrameTupleProcessor processor, IFrameOperationCallback frameOpCallback) throws HyracksDataException { lsmHarness.batchOperate(ctx, accessor, tuple, processor, frameOpCallback); } @Override public void scanDiskComponents(IIndexCursor cursor) throws HyracksDataException { ctx.setOperation(IndexOperation.DISK_COMPONENT_SCAN); lsmHarness.scanDiskComponents(ctx, cursor); } @Override public String toString() { return getClass().getSimpleName() + ':' + lsmHarness.toString(); }

sample: 779
buggy_code:  } @Override public void found(ITupleReference before, ITupleReference after) throws HyracksDataException { if (isFoundNull) { Assert.assertEquals(null, before); } else { Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, before)); } Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, after)); } <|startfocus|> @Override public void after(ITupleReference tuple) throws HyracksDataException { Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, tuple)); } <|endfocus|> } } 
code_review:  you shouldn't need this 
target code: } @Override public void found(ITupleReference before, ITupleReference after) throws HyracksDataException { if (isFoundNull) { Assert.assertEquals(null, before); } else { Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, before)); } Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, after)); } } }
response: } @Override public void found(ITupleReference before, ITupleReference after) throws HyracksDataException { if (isFoundNull) { Assert.assertEquals(null, before); } else { Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, before)); } Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, after)); } @Override public void after(ITupleReference tuple) throws HyracksDataException { Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, tuple)); } }

sample: 780
buggy_code:  // Do nothing. } @Override public void before(ITupleReference tuple) { // Do nothing. } @Override public void found(ITupleReference before, ITupleReference after) { // Do nothing. } @Override public void cancel(ITupleReference tuple) { // Do nothing. } @Override public void complete(ITupleReference tuple) throws HyracksDataException { // Do nothing. } <|startfocus|> @Override public void after(ITupleReference tuple) throws HyracksDataException { // Do nothing. } <|endfocus|> } 
code_review:  you shouldn't need this 
target code: // Do nothing. } @Override public void before(ITupleReference tuple) { // Do nothing. } @Override public void found(ITupleReference before, ITupleReference after) { // Do nothing. } @Override public void cancel(ITupleReference tuple) { // Do nothing. } @Override public void complete(ITupleReference tuple) throws HyracksDataException { // Do nothing. } }
response: // Do nothing. @Override public void before(ITupleReference tuple) { // Do nothing. } @Override public void found(ITupleReference before, ITupleReference after) { // Do nothing. } @Override public void cancel(ITupleReference tuple) { // Do nothing. } @Override public void complete(ITupleReference tuple) throws HyracksDataException { // Do nothing. } @Override public void after(ITupleReference tuple) throws HyracksDataException { // Do nothing. }

sample: 781
buggy_code:  public void after(ITupleReference tuple) { <|startfocus|> <|endfocus|>
code_review:  you shouldn't need this 
target code: public void after(ITupleReference tuple) { //Nothing to do there, not testing filters
response: public void after(ITupleReference tuple) { // code implementation goes here }

sample: 782
buggy_code:  IOptimizationContext context, Quadruple<Boolean, Boolean, Boolean, Boolean> indexOnlyPlanInfo) throws AlgebricksException { // index-only plan possible? boolean isIndexOnlyPlan = false; // secondary key field usage after the select (join) operators // This boolean is mainly used for R-Tree case since R-Tree index generates an MBR // and we can restore original point or rectangle from this MBR if an index is built on point or rectangle. <|startfocus|> boolean secondaryKeyFieldUsedAfterSelectOrJoinOp = indexOnlyPlanInfo.getSecond(); <|endfocus|> // Whether a post verification (especially for R-Tree case) is required after the secondary index search // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); 
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "secondaryKeyFieldUsedAfterSelectOrJoinOp". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: IOptimizationContext context, Quadruple<Boolean, Boolean, Boolean, Boolean> indexOnlyPlanInfo) throws AlgebricksException { // index-only plan possible? boolean isIndexOnlyPlan = false; // secondary key field usage after the select (join) operators // This boolean is mainly used for R-Tree case since R-Tree index generates an MBR // and we can restore original point or rectangle from this MBR if an index is built on point or rectangle. boolean secondaryKeyFieldUsedAfterSelectOrJoinOp; // Whether a post verification (especially for R-Tree case) is required after the secondary index search // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth();
response: IOptimizationContext context, Quadruple<Boolean, Boolean, Boolean, Boolean> indexOnlyPlanInfo) throws AlgebricksException { boolean isIndexOnlyPlan = false; boolean secondaryKeyFieldUsedAfterSelectOrJoinOp = indexOnlyPlanInfo.getSecond(); boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); // rest of the code... }

sample: 783
buggy_code:  // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? <|startfocus|> boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); <|endfocus|> // matched function expressions List<IOptimizableFuncExpr> matchedFuncExprs = analysisCtx.getMatchedFuncExprs(); // If no-index-only option is given, we stop here to honor that request. boolean noIndexOnlyPlanOption = getNoIndexOnlyOption(context); if (noIndexOnlyPlanOption) { indexOnlyPlanInfo.setFirst(isIndexOnlyPlan); return; } // logical variables that select (join) operator is using List<LogicalVariable> usedVarsInSelJoinOp = new ArrayList<>(); List<LogicalVariable> usedVarsInSelJoinOpTemp = new ArrayList<>(); // live variables that select (join) operator can access
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "doesSIdxSearchCoverAllPredicates". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? boolean doesSIdxSearchCoverAllPredicates; // matched function expressions List<IOptimizableFuncExpr> matchedFuncExprs = analysisCtx.getMatchedFuncExprs(); // If no-index-only option is given, we stop here to honor that request. boolean noIndexOnlyPlanOption = getNoIndexOnlyOption(context); if (noIndexOnlyPlanOption) { indexOnlyPlanInfo.setFirst(isIndexOnlyPlan); return; } // logical variables that select (join) operator is using List<LogicalVariable> usedVarsInSelJoinOp = new ArrayList<>(); List<LogicalVariable> usedVarsInSelJoinOpTemp = new ArrayList<>(); // live variables that select (join) operator can access
response: boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); List<IOptimizableFuncExpr> matchedFuncExprs = analysisCtx.getMatchedFuncExprs(); boolean noIndexOnlyPlanOption = getNoIndexOnlyOption(context); if (noIndexOnlyPlanOption) { indexOnlyPlanInfo.setFirst(isIndexOnlyPlan); return; } List<LogicalVariable> usedVarsInSelJoinOp = new ArrayList<>(); List<LogicalVariable> usedVarsInSelJoinOpTemp = new ArrayList<>(); // remaining code...

sample: 784
buggy_code:  || funcExpr.getFunctionIdentifier() == BuiltinFunctions.FULLTEXT_CONTAINS_WO_OPTION) { boolean matches = AccessMethodUtils.analyzeFuncExprArgsForOneConstAndVarAndUpdateAnalysisCtx(funcExpr, analysisCtx, context, typeEnvironment); if (!matches) { matches = AccessMethodUtils.analyzeFuncExprArgsForTwoVarsAndUpdateAnalysisCtx(funcExpr, analysisCtx); } return matches; } return analyzeGetItemFuncExpr(funcExpr, assignsAndUnnests, analysisCtx); } public boolean analyzeGetItemFuncExpr(AbstractFunctionCallExpression funcExpr, List<AbstractLogicalOperator> assignsAndUnnests, AccessMethodAnalysisContext analysisCtx) <|startfocus|> throws AlgebricksException { <|endfocus|> if (funcExpr.getFunctionIdentifier() != BuiltinFunctions.GET_ITEM) { return false; } ILogicalExpression arg1 = funcExpr.getArguments().get(0).getValue(); ILogicalExpression arg2 = funcExpr.getArguments().get(1).getValue(); // The second arg is the item index to be accessed. It must be a constant. if (arg2.getExpressionTag() != LogicalExpressionTag.CONSTANT) { return false; } // The first arg must be a variable or a function expr.
code_review:  MAJOR SonarQube violation: The Cyclomatic Complexity of this method "analyzeGetItemFuncExpr" is 23 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity 
target code: || funcExpr.getFunctionIdentifier() == BuiltinFunctions.FULLTEXT_CONTAINS_WO_OPTION) { boolean matches = AccessMethodUtils.analyzeFuncExprArgsForOneConstAndVarAndUpdateAnalysisCtx(funcExpr, analysisCtx, context, typeEnvironment); if (!matches) { matches = AccessMethodUtils.analyzeFuncExprArgsForTwoVarsAndUpdateAnalysisCtx(funcExpr, analysisCtx); } return matches; } return analyzeGetItemFuncExpr(funcExpr, assignsAndUnnests, analysisCtx); } public boolean analyzeGetItemFuncExpr(AbstractFunctionCallExpression funcExpr, List<AbstractLogicalOperator> assignsAndUnnests, AccessMethodAnalysisContext analysisCtx) throws AlgebricksException { if (funcExpr.getFunctionIdentifier() != BuiltinFunctions.GET_ITEM) { return false; } ILogicalExpression arg1 = funcExpr.getArguments().get(0).getValue(); ILogicalExpression arg2 = funcExpr.getArguments().get(1).getValue(); // The second arg is the item index to be accessed. It must be a constant. if (arg2.getExpressionTag() != LogicalExpressionTag.CONSTANT) { return false; } // The first arg must be a variable or a function expr.
response: typeEnvironment); if (!matches) { matches = AccessMethodUtils.analyzeFuncExprArgsForTwoVars(funcExpr, analysisCtx); } return matches; return analyzeGetItemFuncExpr(funcExpr, assignsAndUnnests, analysisCtx); public boolean analyzeGetItemFuncExpr(AbstractFunctionCallExpression funcExpr, List<AbstractLogicalOperator> assignsAndUnnests, AccessMethodAnalysisContext analysisCtx) throws AlgebricksException { if (funcExpr.getFunctionIdentifier() != BuiltinFunctions.GET_ITEM) { return false; } ILogicalExpression arg1 = funcExpr.getArguments().get(0).getValue(); ILogicalExpression arg2 = funcExpr.getArguments().get(1).getValue(); if (arg2.getExpressionTag() != LogicalExpressionTag.CONSTANT) { return false; } if (arg1.getExpressionTag() != LogicalExpressionTag.VARIABLE) { return false; } // Rest of the code } OrderedListBuilder orderedList = (OrderedListBuilder) getOrderedListBuilder(); orderedList.reset(orderedListType); for (int iter1 = 0; iter1 < jArray.length(); iter1++) { itemBuffer.reset(); if (writeField(jArray.get(iter1), orderedListType.getItemType(), itemBuffer.getDataOutput())) { orderedList.addItem(itemBuffer); } } orderedList.write(output, true); private boolean writeFieldWithFieldType(Object fieldObj, IAType fieldType, DataOutput out) throws HyracksDataException { boolean writeResult = true; IAType chkFieldType; if (fieldType instanceof AUnionType) { chkFieldType = ((AUnionType) fieldType).getActualType(); } else { chkFieldType = fieldType; } if (chkFieldType != null) { switch (chkFieldType.getTypeTag()) { case STRING: out.write(fieldType.getTypeTag().serialize()); utf8Writer.writeUTF8(fieldObj.toString(), out); break; case INT64: out.write(fieldType.getTypeTag().serialize()); if (fieldObj instanceof Integer) { // Rest of the code } } } }

sample: 785
buggy_code:  // (E.g. There are index-nested-loop-joins in the plan.) private List<Mutable<ILogicalOperator>> ixJoinOuterAdditionalDataSourceRefs = null; private List<DataSourceType> ixJoinOuterAdditionalDataSourceTypes = null; private List<Dataset> ixJoinOuterAdditionalDatasets = null; private List<ARecordType> ixJoinOuterAdditionalRecordTypes = null; /** * Identifies the root of the subtree and initializes the data-source, assign, and unnest information. */ <|startfocus|> public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef, IOptimizationContext context) throws AlgebricksException { <|endfocus|> reset(); rootRef = subTreeOpRef; root = subTreeOpRef.getValue(); boolean passedSource = false; boolean result = false; Mutable<ILogicalOperator> searchOpRef = subTreeOpRef; // Examine the op's children to match the expected patterns. AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); MetadataProvider metadataProvider = (MetadataProvider) context.getMetadataProvider(); do { // Skips the limit operator. if (subTreeOp.getOperatorTag() == LogicalOperatorTag.LIMIT) {
code_review:  MAJOR SonarQube violation: The Cyclomatic Complexity of this method "initFromSubTree" is 22 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity 
target code: // (E.g. There are index-nested-loop-joins in the plan.) private List<Mutable<ILogicalOperator>> ixJoinOuterAdditionalDataSourceRefs = null; private List<DataSourceType> ixJoinOuterAdditionalDataSourceTypes = null; private List<Dataset> ixJoinOuterAdditionalDatasets = null; private List<ARecordType> ixJoinOuterAdditionalRecordTypes = null; /** * Identifies the root of the subtree and initializes the data-source, assign, and unnest information. */ public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef) throws AlgebricksException { reset(); rootRef = subTreeOpRef; root = subTreeOpRef.getValue(); boolean passedSource = false; boolean result = false; Mutable<ILogicalOperator> searchOpRef = subTreeOpRef; // Examine the op's children to match the expected patterns. AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); MetadataProvider metadataProvider = (MetadataProvider) context.getMetadataProvider(); do { // Skips the limit operator. if (subTreeOp.getOperatorTag() == LogicalOperatorTag.LIMIT) {
response: do { if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) { subTreeOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue(); } if (subTreeOp.getOperatorTag() != LogicalOperatorTag.ASSIGN && subTreeOp.getOperatorTag() != LogicalOperatorTag.UNNEST) { result = initializeDataSource(subTreeOpRef); passedSource = true; if (!subTreeOp.getInputs().isEmpty()) { searchOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); } } while (subTreeOp.getOperatorTag() == LogicalOperatorTag.ASSIGN || subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST) { if (!OperatorPropertiesUtil.isMovable(subTreeOp)) { return false; } else { getAssignsAndUnnestsRefs().add(subTreeOpRef); getAssignsAndUnnests().add(subTreeOp); } subTreeOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue(); } } while (true);

sample: 786
buggy_code:  // object creation: should be relatively low btreeCursors = new ITreeIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; bloomFilters = new BloomFilter[numBTrees]; } includeMutableComponent = false; for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree = (BTree) component.getIndex(); if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; bloomFilters[i] = null; <|startfocus|> }else { <|endfocus|> bloomFilters[i] = ((LSMBTreeWithBloomFilterDiskComponent) component).getBloomFilter(); } if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].close(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true;
code_review:  MAJOR SonarQube violation: 'else' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: // object creation: should be relatively low btreeCursors = new ITreeIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; bloomFilters = new BloomFilter[numBTrees]; } includeMutableComponent = false; for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree = (BTree) component.getIndex(); if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; bloomFilters[i] = null; } else { bloomFilters[i] = ((LSMBTreeWithBloomFilterDiskComponent) component).getBloomFilter(); } if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].close(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true;
response: // object creation: should be relatively low btreeCursors = new ITreeIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; bloomFilters = new BloomFilter[numBTrees]; includeMutableComponent = false; for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree = (BTree) component.getIndex(); if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; bloomFilters[i] = null; } else { bloomFilters[i] = ((LSMBTreeWithBloomFilterDiskComponent) component).getBloomFilter(); } if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].close(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true; }

sample: 787
buggy_code:  // object creation: should be relatively low btreeCursors = new ITreeIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; bloomFilters = new BloomFilter[numBTrees]; } includeMutableComponent = false; for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree = (BTree) component.getIndex(); if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; bloomFilters[i] = null; <|startfocus|> }else { <|endfocus|> bloomFilters[i] = ((LSMBTreeWithBloomFilterDiskComponent) component).getBloomFilter(); } if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].close(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true;
code_review:  MAJOR SonarQube violation: '}' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: // object creation: should be relatively low btreeCursors = new ITreeIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; bloomFilters = new BloomFilter[numBTrees]; } includeMutableComponent = false; for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree = (BTree) component.getIndex(); if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; bloomFilters[i] = null; } else { bloomFilters[i] = ((LSMBTreeWithBloomFilterDiskComponent) component).getBloomFilter(); } if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].close(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true;
response: // object creation: should be relatively low btreeCursors = new ITreeIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; bloomFilters = new BloomFilter[numBTrees]; includeMutableComponent = false; for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree = (BTree) component.getIndex(); if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; bloomFilters[i] = null; } else { bloomFilters[i] = ((LSMBTreeWithBloomFilterDiskComponent) component).getBloomFilter(); } if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].close(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true; }

sample: 788
buggy_code:  public int compare(ReferenceEntry tp1, ReferenceEntry tp2) { int[] tPointers1 = tp1.getTPointers(); int[] tPointers2 = tp2.getTPointers(); int cmp = NormalizedKeyUtils.compareNormalizeKeys(tPointers1, 0, tPointers2, 0, normalizedKeyLength); <|startfocus|> if (cmp != 0) { <|endfocus|> return cmp; } IFrameTupleAccessor fta1 = tp1.getAccessor(); IFrameTupleAccessor fta2 = tp2.getAccessor(); byte[] b1 = fta1.getBuffer().array(); byte[] b2 = fta2.getBuffer().array(); for (int f = 0; f < sortFields.length; ++f) { int c; try { c = comparators[f].compare(b1, tPointers1[2 * f + normalizedKeyLength], tPointers1[2 * f + normalizedKeyLength + 1], b2, tPointers2[2 * f + normalizedKeyLength], tPointers2[2 * f + normalizedKeyLength + 1]); if (c != 0) { return c; } } catch (HyracksDataException e) {
code_review:  shouldn't this have || isDecisive? 
target code: public int compare(ReferenceEntry tp1, ReferenceEntry tp2) { int[] tPointers1 = tp1.getTPointers(); int[] tPointers2 = tp2.getTPointers(); int cmp = NormalizedKeyUtils.compareNormalizeKeys(tPointers1, 0, tPointers2, 0, normalizedKeyLength); if (cmp != 0 || normalizedKeyDecisive) { return cmp; } IFrameTupleAccessor fta1 = tp1.getAccessor(); IFrameTupleAccessor fta2 = tp2.getAccessor(); byte[] b1 = fta1.getBuffer().array(); byte[] b2 = fta2.getBuffer().array(); for (int f = 0; f < sortFields.length; ++f) { int c; try { c = comparators[f].compare(b1, tPointers1[2 * f + normalizedKeyLength], tPointers1[2 * f + normalizedKeyLength + 1], b2, tPointers2[2 * f + normalizedKeyLength], tPointers2[2 * f + normalizedKeyLength + 1]); if (c != 0) { return c; } } catch (HyracksDataException e) {
response: public int compare(ReferenceEntry tp1, ReferenceEntry tp2) { int[] tPointers1 = tp1.getTPointers(); int[] tPointers2 = tp2.getTPointers(); int cmp = NormalizedKeyUtils.compareNormalizeKeys(tPointers1, 0, tPointers2, 0, normalizedKeyLength); if (cmp != 0) { return cmp; } IFrameTupleAccessor fta1 = tp1.getAccessor(); IFrameTupleAccessor fta2 = tp2.getAccessor(); byte[] b1 = fta1.getBuffer().array(); byte[] b2 = fta2.getBuffer().array(); for (int f = 0; f < sortFields.length; ++f) { int c; try { c = comparators[f].compare(b1, tPointers1[2 * f + normalizedKeyLength], tPointers1[2 * f + normalizedKeyLength + 1], b2, tPointers2[2 * f + normalizedKeyLength], tPointers2[2 * f + normalizedKeyLength + 1]); if (c != 0) { return c; } } catch (HyracksDataException e) { // Handle exception } } return 0; }

sample: 789
buggy_code:  flushAndWaitForIO(dsInfo, iInfo); } } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { <|startfocus|> throw new HyracksDataException(e); <|endfocus|> } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values());
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: flushAndWaitForIO(dsInfo, iInfo); } } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw HyracksDataException.create(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values());
response: private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dataset : openDatasets) { closeDataset(dataset.getDatasetInfo()); } }

sample: 790
buggy_code:  if (op2.getOperatorTag() == LogicalOperatorTag.DATASOURCESCAN) { DataSourceScanOperator scan = (DataSourceScanOperator) op2; int n = scan.getVariables().size(); LogicalVariable scanRecordVar = scan.getVariables().get(n - 1); IDataSource<DataSourceId> dataSource = (IDataSource<DataSourceId>) scan.getDataSource(); byte dsType = ((DataSource) dataSource).getDatasourceType(); <|startfocus|> if (dsType == DataSource.Type.FEED || dsType == DataSource.Type.LOADABLE || dsType == DataSource.Type.FUNCTION) { <|endfocus|> return false; } DataSourceId asid = dataSource.getId(); MetadataProvider mp = (MetadataProvider) context.getMetadataProvider(); Dataset dataset = mp.findDataset(asid.getDataverseName(), asid.getDatasourceName()); if (dataset == null) { throw new AlgebricksException("Dataset " + asid.getDatasourceName() + " not found."); } if (dataset.getDatasetType() != DatasetType.INTERNAL) { setAsFinal(access, context, finalAnnot); return false; } String tName = dataset.getItemTypeName();
code_review:  Let's change this line to: if (dsType != DataSource.Type.INTERNAL_DATASET && dsType != DataSource.Type.EXTERNAL_DATASET) { return false; } this should fix CB issue (we have additional datasource types) 
target code: if (op2.getOperatorTag() == LogicalOperatorTag.DATASOURCESCAN) { DataSourceScanOperator scan = (DataSourceScanOperator) op2; int n = scan.getVariables().size(); LogicalVariable scanRecordVar = scan.getVariables().get(n - 1); IDataSource<DataSourceId> dataSource = (IDataSource<DataSourceId>) scan.getDataSource(); byte dsType = ((DataSource) dataSource).getDatasourceType(); if (dsType != DataSource.Type.INTERNAL_DATASET && dsType != DataSource.Type.EXTERNAL_DATASET) { return false; } DataSourceId asid = dataSource.getId(); MetadataProvider mp = (MetadataProvider) context.getMetadataProvider(); Dataset dataset = mp.findDataset(asid.getDataverseName(), asid.getDatasourceName()); if (dataset == null) { throw new AlgebricksException("Dataset " + asid.getDatasourceName() + " not found."); } if (dataset.getDatasetType() != DatasetType.INTERNAL) { setAsFinal(access, context, finalAnnot); return false; } String tName = dataset.getItemTypeName();
response: if (op2.getOperatorTag() == LogicalOperatorTag.DATASOURCESCAN) { DataSourceScanOperator scan = (DataSourceScanOperator) op2; int n = scan.getVariables().size(); LogicalVariable scanRecordVar = scan.getVariables().get(n - 1); IDataSource<DataSourceId> dataSource = (IDataSource<DataSourceId>) scan.getDataSource(); byte dsType = ((DataSource) dataSource).getDatasourceType(); if (dsType != DataSource.Type.INTERNAL_DATASET && dsType != DataSource.Type.EXTERNAL_DATASET) { return false; } DataSourceId asid = dataSource.getId(); MetadataProvider mp = (MetadataProvider) context.getMetadataProvider(); Dataset dataset = mp.findDataset(asid.getDataverseName(), asid.getDatasourceName()); if (dataset == null) { throw new AlgebricksException("Dataset " + asid.getDatasourceName() + " not found."); } if (dataset.getDatasetType() != DatasetType.INTERNAL) { setAsFinal(access, context, finalAnnot); return false; } String tName = dataset.getItemTypeName(); }

sample: 791
buggy_code:  buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); if (oldValueSize > 0) { buffer.putInt(oldValueSize); buffer.putInt(oldValueFieldCount); writeTuple(buffer, oldValue, oldValueSize); } break; case LogType.FILTER: writeEntityResource(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); <|startfocus|> System.out.println(newValueSize); <|endfocus|> break; case LogType.FLUSH: buffer.putInt(datasetId); break; case LogType.MARKER: buffer.putInt(datasetId); buffer.putInt(resourcePartition); callback.before(buffer); buffer.putInt(logSize); buffer.put(marker); break; default: // Do nothing }
code_review:  MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 
target code: buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); if (oldValueSize > 0) { buffer.putInt(oldValueSize); buffer.putInt(oldValueFieldCount); writeTuple(buffer, oldValue, oldValueSize); } break; case LogType.FILTER: writeEntityResource(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); break; case LogType.FLUSH: buffer.putInt(datasetId); break; case LogType.MARKER: buffer.putInt(datasetId); buffer.putInt(resourcePartition); callback.before(buffer); buffer.putInt(logSize); buffer.put(marker); break; default: // Do nothing }
response: buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); if (oldValueSize > 0) { buffer.putInt(oldValueSize); buffer.putInt(oldValueFieldCount); writeTuple(buffer, oldValue, oldValueSize); } break; case LogType.FILTER: writeEntityResource(buffer); buffer.putLong(resourceId); buffer.putInt(logSize); buffer.putInt(newValueFieldCount); buffer.put(newOp); buffer.putInt(newValueSize); writeTuple(buffer, newValue, newValueSize); break; case LogType.FLUSH: buffer.putInt(datasetId); break; case LogType.MARKER: buffer.putInt(datasetId); buffer.putInt(resourcePartition); callback.before(buffer); buffer.putInt(logSize); buffer.put(marker); break; default: // Do nothing

sample: 792
buggy_code:  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IModificationOperationCallback; public interface IExtendedModificationOperationCallback extends <|startfocus|> IModificationOperationCallback{ <|endfocus|> /** * Called after the action taken in found, to take action on a tuple that is not part of the index * itself but is part of an ancillary structure that is updated alongside the index. An example would * be a simple statistic on the index that records the minimum and maximum values. * * @param after The tuple to feed to the ancilliary structure * @throws HyracksDataException */ void after(ITupleReference after) throws HyracksDataException; } 
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IModificationOperationCallback; public interface IExtendedModificationOperationCallback extends IModificationOperationCallback { /** * Called after the action taken in found, to take action on a tuple that is not part of the index * itself but is part of an ancillary structure that is updated alongside the index. An example would * be a simple statistic on the index that records the minimum and maximum values. * * @param after The tuple to feed to the ancilliary structure * @throws HyracksDataException */ void after(ITupleReference after) throws HyracksDataException; }
response: package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IModificationOperationCallback; public interface IExtendedModificationOperationCallback extends IModificationOperationCallback { void after(ITupleReference after) throws HyracksDataException; }

sample: 793
buggy_code:  public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { <|startfocus|> return createAccessor(createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())), <|endfocus|> iap.getSearchOperationCallback()));
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { return createAccessor(createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback()));
response: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { return createAccessor(createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback())); }

sample: 794
buggy_code:  public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { <|startfocus|> return createAccessor(createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())), <|endfocus|> iap.getSearchOperationCallback()));
code_review:  MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { return createAccessor(createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback()));
response: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { return createAccessor(createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())), iap.getSearchOperationCallback())); }

sample: 795
buggy_code:  if (minTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { <|startfocus|> if(!logged) { <|endfocus|> opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);
code_review:  BLOCKER SonarQube violation: Change this condition so that it does not always evaluate to "true" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2583 
target code: if (minTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { if (!logged) { opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);
response: if (minTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { if (!logged) { opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); // ... rest of the code }

sample: 796
buggy_code:  if (minTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { <|startfocus|> if(!logged) { <|endfocus|> opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: if (minTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { if (!logged) { opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);
response: if (minTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { if (!logged) { opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); // rest of the code }

sample: 797
buggy_code:  if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; <|startfocus|> if(!logged) { <|endfocus|> opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if(!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) {
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if(!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) {
response: if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { // resize maxTupleBytes if necessary } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); } }

sample: 798
buggy_code:  minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if(!logged) { opCallback.after(tuple); <|startfocus|> logged = true; <|endfocus|> } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if(!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes];
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "logged". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if(!logged) { opCallback.after(tuple); } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if(!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes];
response: minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes]; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } }

sample: 799
buggy_code:  int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if(!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { <|startfocus|> if(!logged) { <|endfocus|> opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); } else { tupleWriter.writeTuple(tuple, maxTupleBytes, 0); } ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } } } @Override public ITupleReference getMinTuple() { return minTuple; } @Override
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if(!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); } else { tupleWriter.writeTuple(tuple, maxTupleBytes, 0); } ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } } } @Override public ITupleReference getMinTuple() { return minTuple; } @Override
response: int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); } else { tupleWriter.writeTuple(tuple, maxTupleBytes, 0); } ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } } } @Override public ITupleReference getMinTuple() { return minTuple; } @Override

sample: 800
buggy_code:  return new LSMInvertedIndexAccessor(getHarness(), createOpContext((IExtendedModificationOperationCallback) (iap.getModificationCallback()), iap.getSearchOperationCallback())); } @Override protected LSMInvertedIndexOpContext createOpContext(IExtendedModificationOperationCallback modificationCallback, ISearchOperationCallback searchCallback) throws HyracksDataException { return new LSMInvertedIndexOpContext(this, memoryComponents, modificationCallback, searchCallback, invertedIndexFieldsForNonBulkLoadOps, filterFieldsForNonBulkLoadOps, getFilterCmpFactories(), tracer); } <|startfocus|> protected LSMInvertedIndexOpContext createRecoveryOpContext(IExtendedModificationOperationCallback modificationCallback, ISearchOperationCallback searchCallback) throws HyracksDataException { return new LSMInvertedIndexOpContext(this, memoryComponents, modificationCallback, searchCallback, invertedIndexFieldsForNonBulkLoadOps, null, null, tracer); } <|endfocus|> @Override public ITypeTraits[] getInvListTypeTraits() { return invListTypeTraits; } @Override public IBinaryComparatorFactory[] getInvListCmpFactories() { return invListCmpFactories; } @Override public ITypeTraits[] getTokenTypeTraits() { return tokenTypeTraits; } @Override public IBinaryComparatorFactory[] getTokenCmpFactories() { return tokenCmpFactories; } 
code_review:  MAJOR SonarQube violation: Split this 124 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: return new LSMInvertedIndexAccessor(getHarness(), createOpContext((IExtendedModificationOperationCallback) (iap.getModificationCallback()), iap.getSearchOperationCallback())); } @Override protected LSMInvertedIndexOpContext createOpContext(IExtendedModificationOperationCallback modificationCallback, ISearchOperationCallback searchCallback) throws HyracksDataException { return new LSMInvertedIndexOpContext(this, memoryComponents, modificationCallback, searchCallback, invertedIndexFieldsForNonBulkLoadOps, filterFieldsForNonBulkLoadOps, getFilterCmpFactories(), tracer); } @Override public ITypeTraits[] getInvListTypeTraits() { return invListTypeTraits; } @Override public IBinaryComparatorFactory[] getInvListCmpFactories() { return invListCmpFactories; } @Override public ITypeTraits[] getTokenTypeTraits() { return tokenTypeTraits; } @Override public IBinaryComparatorFactory[] getTokenCmpFactories() { return tokenCmpFactories; }
response: import org.apache.hyracks.algebricks.core.algebra.metadata.IMetadataProvider; /** * This class is the type computer for not-missing function. * If the input type is not a union, we just return it. * If the input type is a union, * case 1: we return a new union without missing if the new union still has more than one types; * case 2: we return the non-missing item type in the original union if there are only missing and it in the original union. */ public class NotMissingTypeComputer implements IResultTypeComputer { public static final NotMissingTypeComputer INSTANCE = new NotMissingTypeComputer(); @Override public IAType computeType(ILogicalExpression expression, IVariableTypeEnvironment env, IMetadataProvider<?, ?> metadataProvider) throws AlgebricksException { AbstractFunctionCallExpression f = (AbstractFunctionCallExpression) expression; IAType type = (IAType) env.getType(f.getArguments().get(0).getValue()); if (type.getTypeTag() != ATypeTag.UNION) { // directly return the input type if it is not a union return type; } } } .createTuplePairComparator(ctx); final ITuplePairComparator nljComparatorBuild2Probe = tuplePairComparatorFactoryBuild2Probe.createTuplePairComparator(ctx); final IPredicateEvaluator predEvaluator = (predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator()); for (int i = 0; i < comparatorFactories.length; i++) { comparators[i] = comparatorFactories[i].createBinaryComparator(); } final IMissingWriter[] nonMatchWriter = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories.length] : null; final ArrayTupleBuilder nullTupleBuild = isLeftOuter ? new ArrayTupleBuilder(buildRd.getFieldCount()) : null; if (isLeftOuter) { DataOutput out = nullTupleBuild.getDataOutput(); for (int i = 0; i < nonMatchWriterFactories.length; i++) { nonMatchWriter[i] = nonMatchWriterFactories[i].createMissingWriter(); nonMatchWriter[i].writeMissing(out); nullTupleBuild.addFieldEndOffset(); } } IOperatorNodePushable op = new AbstractUnaryInputUnaryOutputOperatorNodePushable() { private BuildAndPartitionTaskState state; private

sample: 801
buggy_code:  public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { <|startfocus|> LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())), <|endfocus|> iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory);
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) iap.getModificationCallback()), iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory);
response: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory); }

sample: 802
buggy_code:  public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { <|startfocus|> LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())), <|endfocus|> iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory);
code_review:  MAJOR SonarQube violation: Split this 125 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) iap.getModificationCallback()), iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory);
response: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())), iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory); }

sample: 803
buggy_code:  public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = <|startfocus|> createOpContext(((IExtendedModificationOperationCallback) iap.getModificationCallback()), iap.getSearchOperationCallback()); <|endfocus|> return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory);
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory);
response: public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { LSMRTreeOpContext opCtx = createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback()); return new LSMTreeIndexAccessor(getHarness(), opCtx, cursorFactory); }

sample: 804
buggy_code:  // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker. flushAndWaitForIO(dsInfo, iInfo); } } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { <|startfocus|> flushDatasetOpenIndexes(dsInfo, false); <|endfocus|> } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException {
code_review:  CRITICAL SonarQube violation: Remove this call to "wait" or move it into a "while" loop. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2274 
target code: // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker. flushAndWaitForIO(dsInfo, iInfo); } } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsr, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException {
response: // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker. flushAndWaitForIO(dsInfo, iInfo); } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { // First wait for any ongoing IO operations for (DatasetInfo dsInfo : datasetInfos.values()) { synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } } // Close all datasets for (DatasetInfo dsInfo : datasetInfos.values()) { closeDataset(dsInfo); } }

sample: 805
buggy_code:  // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker. flushAndWaitForIO(dsInfo, iInfo); } } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { <|startfocus|> flushDatasetOpenIndexes(dsInfo, false); <|endfocus|> } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException {
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker. flushAndWaitForIO(dsInfo, iInfo); } } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsr, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException {
response: // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker. flushAndWaitForIO(dsInfo, iInfo); } } private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException { // First wait for any ongoing IO operations synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } try { flushDatasetOpenIndexes(dsInfo, false); } catch (Exception e) { throw new HyracksDataException(e); } for (IndexInfo iInfo : dsInfo.getIndexes().values()) { if (iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().deactivate(false); } iInfo.setOpen(false); } } removeDatasetFromCache(dsInfo.getDatasetID()); dsInfo.setOpen(false); } @Override public synchronized void closeAllDatasets() throws HyracksDataException { // First wait for any ongoing IO operations for (DatasetInfo dsInfo : datasetInfos.values()) { synchronized (dsInfo) { while (dsInfo.getNumActiveIOOps() > 0) { try { dsInfo.wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } } for (DatasetInfo dsInfo : datasetInfos.values()) { closeDataset(dsInfo); } }

sample: 806
buggy_code:  } catch (HyracksDataException e) { datasetLifecycleManager.close(localResource.getPath()); throw e; } //#. set resourceId and maxDiskLastLSN to the map resourceId2MaxLSNMap.put(resourceId, maxDiskLastLsn); } else { maxDiskLastLsn = resourceId2MaxLSNMap.get(resourceId); } <|startfocus|> // lsn @ maxDiskLastLsn is either a flush log or a master replica log if (lsn >= maxDiskLastLsn) { redo(logRecord, datasetLifecycleManager); redoCount++; } <|endfocus|> } break; case LogType.JOB_COMMIT: case LogType.ENTITY_COMMIT: case LogType.ABORT: case LogType.FLUSH: case LogType.WAIT: case LogType.MARKER: //do nothing break; default: throw new ACIDException("Unsupported LogType: " + logRecord.getLogType()); } logRecord = logReader.next(); } LOGGER.info("Logs REDO phase completed. Redo logs count: " + redoCount); } finally {
code_review:  MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 
target code: } catch (HyracksDataException e) { datasetLifecycleManager.close(localResource.getPath()); throw e; } //#. set resourceId and maxDiskLastLSN to the map resourceId2MaxLSNMap.put(resourceId, maxDiskLastLsn); } else { maxDiskLastLsn = resourceId2MaxLSNMap.get(resourceId); } } } break; case LogType.JOB_COMMIT: case LogType.ENTITY_COMMIT: case LogType.ABORT: case LogType.FLUSH: case LogType.WAIT: case LogType.MARKER: //do nothing break; default: throw new ACIDException("Unsupported LogType: " + logRecord.getLogType()); } logRecord = logReader.next(); } LOGGER.info("Logs REDO phase completed. Redo logs count: " + redoCount); } finally {
response: } catch (HyracksDataException e) { datasetLifecycleManager.close(localResource.getPath()); throw e; } resourceId2MaxLSNMap.put(resourceId, maxDiskLastLsn); } else { maxDiskLastLsn = resourceId2MaxLSNMap.get(resourceId); } if (lsn >= maxDiskLastLsn) { redo(logRecord, datasetLifecycleManager); redoCount++; } break; case LogType.JOB_COMMIT: case LogType.ENTITY_COMMIT: case LogType.ABORT: case LogType.FLUSH: case LogType.WAIT: case LogType.MARKER: //do nothing break; default: throw new ACIDException("Unsupported LogType: " + logRecord.getLogType()); } logRecord = logReader.next(); } LOGGER.info("Logs REDO phase completed. Redo logs count: " + redoCount); } finally {

sample: 807
buggy_code:  int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { <|startfocus|> if (!logged) { opCallback.after(tuple); logged = true; } <|endfocus|> int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);
code_review:  BLOCKER SonarQube violation: Change this condition so that it does not always evaluate to "true" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2583 
target code: int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { opCallback.after(tuple); logged = true; int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);
response: int numBytes = tupleWriter.bytesRequired(tuple); minTupleBytes = new byte[numBytes]; opCallback.after(tuple); logged = true; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); minTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, minTuple); if (c < 0) { if (!logged) { opCallback.after(tuple); logged = true; } int numBytes = tupleWriter.bytesRequired(tuple); if (minTupleBytes.length < numBytes) { minTupleBytes = new byte[numBytes]; } tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple);

sample: 808
buggy_code:  minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); <|startfocus|> logged = true; <|endfocus|> } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes];
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "logged". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); } else { tupleWriter.writeTuple(tuple, minTupleBytes, 0); } ((ITreeIndexTupleReference) minTuple).resetByTupleOffset(minTupleBuf.array(), 0); } } if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes];
response: minTupleBytes = new byte[numBytes]; tupleWriter.writeTuple(tuple, minTupleBytes, 0); minTupleBuf = ByteBuffer.wrap(minTupleBytes); if (maxTuple == null) { int numBytes = tupleWriter.bytesRequired(tuple); maxTupleBytes = new byte[numBytes]; if (!logged) { opCallback.after(tuple); logged = true; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } else { int c = cmp.compare(tuple, maxTuple); if (c > 0) { if (!logged) { opCallback.after(tuple); } int numBytes = tupleWriter.bytesRequired(tuple); if (maxTupleBytes.length < numBytes) { maxTupleBytes = new byte[numBytes]; } tupleWriter.writeTuple(tuple, maxTupleBytes, 0); maxTupleBuf = ByteBuffer.wrap(maxTupleBytes); maxTuple = tupleWriter.createTupleReference(); ((ITreeIndexTupleReference) maxTuple).resetByTupleOffset(maxTupleBuf.array(), 0); } }

sample: 809
buggy_code:  return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { <|startfocus|> while(confiscatedPages.contains(c)){ throw new IllegalStateException(); } <|endfocus|> } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; }
code_review:  MAJOR SonarQube violation: 'catch' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; }
response: return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { while (confiscatedPages.contains(c)) { throw new IllegalStateException(); } } } } finally { confiscateLock.unlock(); } } synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } }

sample: 810
buggy_code:  return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { <|startfocus|> while(confiscatedPages.contains(c)){ throw new IllegalStateException(); } <|endfocus|> } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; }
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; }
response: return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { while (confiscatedPages.contains(c)) { throw new IllegalStateException(); } } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } }

sample: 811
buggy_code:  return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { <|startfocus|> while(confiscatedPages.contains(c)){ throw new IllegalStateException(); } <|endfocus|> } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; }
code_review:  MAJOR SonarQube violation: '}' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; }
response: return pin(dpid, newPage, null); } @Override public ICachedPage pin(long dpid, boolean newPage, ILargePageHelper helper) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { while (confiscatedPages.contains(c)) { throw new IllegalStateException(); } } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } }

sample: 812
buggy_code:  return null; } }); } for(int i=0;i<bufferCacheNumPages;i++){ synchronized (readers[i]){ while(readers[i].getValue() == null){ readers[i].wait(); } } } final long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start < duration){ for(int i=0;i<bufferCacheNumPages;i++){ readers[i].getValue().interrupt(); } <|startfocus|> Thread.sleep(25); <|endfocus|> } try { for (int i = 0; i < bufferCacheNumPages; i++) { futures[i].get(); } } finally { bufferCache.deleteFile(fileId); bufferCache.close(); } } @Test public void simpleOpenPinCloseTest() throws HyracksException { TestStorageManagerComponentHolder.init(PAGE_SIZE, NUM_PAGES, MAX_OPEN_FILES); IBufferCache bufferCache = TestStorageManagerComponentHolder.getBufferCache(ctx.getJobletContext().getServiceContext()); IIOManager ioManager = TestStorageManagerComponentHolder.getIOManager(); String fileName = getFileName(); FileReference file = ioManager.resolve(fileName);
code_review:  MAJOR SonarQube violation: Remove this use of "Thread.sleep()". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2925 
target code: return null; } }); } for(int i=0;i<bufferCacheNumPages;i++){ synchronized (readers[i]){ while(readers[i].getValue() == null){ readers[i].wait(); } } } final long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start < duration){ for(int i=0;i<bufferCacheNumPages;i++){ readers[i].getValue().interrupt(); } Thread.sleep(25); // NOSONAR Sleep so some reads are successful } try { for (int i = 0; i < bufferCacheNumPages; i++) { futures[i].get(); } } finally { bufferCache.deleteFile(fileId); bufferCache.close(); } } @Test public void simpleOpenPinCloseTest() throws HyracksException { TestStorageManagerComponentHolder.init(PAGE_SIZE, NUM_PAGES, MAX_OPEN_FILES); IBufferCache bufferCache = TestStorageManagerComponentHolder.getBufferCache(ctx.getJobletContext().getServiceContext()); IIOManager ioManager = TestStorageManagerComponentHolder.getIOManager(); String fileName = getFileName(); FileReference file = ioManager.resolve(fileName);
response: return null; } }); } for(int i=0;i<bufferCacheNumPages;i++){ synchronized (readers[i]){ while(readers[i].getValue() == null){ readers[i].wait(); } } } final long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start < duration){ for(int i=0;i<bufferCacheNumPages;i++){ readers[i].getValue().interrupt(); } wait(25); } try { for (int i = 0; i < bufferCacheNumPages; i++) { futures[i].get(); } } finally { bufferCache.deleteFile(fileId); bufferCache.close(); } } @Test public void simpleOpenPinCloseTest() throws HyracksException { TestStorageManagerComponentHolder.init(PAGE_SIZE, NUM_PAGES, MAX_OPEN_FILES); IBufferCache bufferCache = TestStorageManagerComponentHolder.getBufferCache(ctx.getJobletContext().getServiceContext()); IIOManager ioManager = TestStorageManagerComponentHolder.getIOManager(); String fileName = getFileName(); FileReference file = ioManager.resolve(fileName);

sample: 813
buggy_code:  this.btreePred = (RangePredicate) searchPred; btreeAccessor.search(btreeCursor, btreePred); openInvListRangeSearchCursor(); } @Override public boolean hasNext() throws HyracksDataException { // No more results possible if (!isInvListCursorOpen) { return false; } if (invListRangeSearchCursor.hasNext()) { return true; } // The current inverted-list-range-search cursor is exhausted. <|startfocus|> if (isInvListCursorOpen) { invListRangeSearchCursor.close(); isInvListCursorOpen = false; } <|endfocus|> openInvListRangeSearchCursor(); return isInvListCursorOpen; } @Override public void next() throws HyracksDataException { invListRangeSearchCursor.next(); if (concatTuple.hasMaxTuples()) { concatTuple.removeLastTuple(); } concatTuple.addTuple(invListRangeSearchCursor.getTuple()); } @Override public void destroy() throws HyracksDataException { if (isInvListCursorOpen) { invListRangeSearchCursor.unloadPages(); invListRangeSearchCursor.destroy(); isInvListCursorOpen = false; } btreeCursor.destroy(); } @Override
code_review:  BLOCKER SonarQube violation: Change this condition so that it does not always evaluate to "true" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2583 
target code: this.btreePred = (RangePredicate) searchPred; btreeAccessor.search(btreeCursor, btreePred); openInvListRangeSearchCursor(); } @Override public boolean hasNext() throws HyracksDataException { // No more results possible if (!isInvListCursorOpen) { return false; } if (invListRangeSearchCursor.hasNext()) { return true; } // The current inverted-list-range-search cursor is exhausted. invListRangeSearchCursor.close(); isInvListCursorOpen = false; openInvListRangeSearchCursor(); return isInvListCursorOpen; } @Override public void next() throws HyracksDataException { invListRangeSearchCursor.next(); if (concatTuple.hasMaxTuples()) { concatTuple.removeLastTuple(); } concatTuple.addTuple(invListRangeSearchCursor.getTuple()); } @Override public void destroy() throws HyracksDataException { if (isInvListCursorOpen) { invListRangeSearchCursor.unloadPages(); invListRangeSearchCursor.destroy(); isInvListCursorOpen = false; } btreeCursor.destroy(); } @Override
response: this.btreePred = (RangePredicate) searchPred; btreeAccessor.search(btreeCursor, btreePred); openInvListRangeSearchCursor(); @Override public boolean hasNext() throws HyracksDataException { // No more results possible if (!isInvListCursorOpen) { return false; } if (invListRangeSearchCursor.hasNext()) { return true; } // The current inverted-list-range-search cursor is exhausted. if (isInvListCursorOpen) { invListRangeSearchCursor.close(); isInvListCursorOpen = false; } openInvListRangeSearchCursor(); return isInvListCursorOpen; } @Override public void next() throws HyracksDataException { invListRangeSearchCursor.next(); if (concatTuple.hasMaxTuples()) { concatTuple.removeLastTuple(); } concatTuple.addTuple(invListRangeSearchCursor.getTuple()); } @Override public void destroy() throws HyracksDataException { if (isInvListCursorOpen) { invListRangeSearchCursor.unloadPages(); invListRangeSearchCursor.destroy(); isInvListCursorOpen = false; } btreeCursor.destroy(); } @Override

sample: 814
buggy_code:  // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { <|startfocus|> while(confiscatedPages.contains(c)){ throw new IllegalStateException(); } <|endfocus|> } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if(DEBUG){ pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);
code_review:  MAJOR SonarQube violation: 'finally' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if(DEBUG){ pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);
response: // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { while (confiscatedPages.contains(c)) { throw new IllegalStateException(); } } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if (DEBUG) { pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);

sample: 815
buggy_code:  // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { <|startfocus|> while(confiscatedPages.contains(c)){ throw new IllegalStateException(); } <|endfocus|> } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if(DEBUG){ pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if(DEBUG){ pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);
response: // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { while (confiscatedPages.contains(c)) { throw new IllegalStateException(); } } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if (DEBUG) { pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);

sample: 816
buggy_code:  // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { <|startfocus|> while(confiscatedPages.contains(c)){ throw new IllegalStateException(); } <|endfocus|> } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if(DEBUG){ pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally{ confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if(DEBUG){ pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);
response: // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { while (confiscatedPages.contains(c)) { throw new IllegalStateException(); } } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage, helper); cPage.valid = true; } } } else { cPage.valid = true; } pageReplacementStrategy.notifyCachePageAccess(cPage); if (DEBUG) { pinnedPageOwner.put((CachedPage) cPage, Thread.currentThread().getStackTrace()); } cPage.setLargePageHelper(helper);

sample: 817
buggy_code:  pageReplacementStrategy.notifyCachePageAccess(cPage); return cPage; } cPage = cPage.next; } } finally { bucket.bucketLock.unlock(); } return cPage; } @Override public ICachedPage pin(long dpid, boolean newPage) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } <|startfocus|> CachedPage cPage = findPage(dpid); <|endfocus|> if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage); cPage.valid = true; } } } else {
code_review:  warn 
target code: pageReplacementStrategy.notifyCachePageAccess(cPage); return cPage; } cPage = cPage.next; } } finally { bucket.bucketLock.unlock(); } return cPage; } @Override public ICachedPage pin(long dpid, boolean newPage) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage); cPage.valid = true; } } } else {
response: protected void doStop() { log.info("Stopping client"); wrkr.shutdownGracefully(); try { sock.channel().closeFuture().sync(); } catch (InterruptedException e) { log.warn("Client stop interrupted"); Thread.currentThread().interrupt(); } log.info("Client stopped"); notifyStopped(); } out.add(result); return out; } catch (IOException e) { throw new OrmException(e); } catch (ParseException e) { throw new OrmException(e); } protected Directory readIndexDirectory() throws IOException { Directory dir = new RAMDirectory(); byte[] buffer = new byte[4096]; InputStream index = QueryDocumentationFilter.class.getClassLoader().getResourceAsStream(INDEX_PATH); if (index == null) { log.warn("No index available"); return null; } ZipInputStream zip = new ZipInputStream(index); try { ZipEntry entry; while ((entry = zip.getNextEntry()) != null) { IndexOutput out = dir.createOutput(entry.getName(), null); int count; while ((count = zip.read(buffer)) != -1) { out.writeBytes(buffer, count); } out.close(); } } finally { zip.close(); } // We must NOT call dir.close() here, as DirectoryReader.open() expects an opened directory. return dir; } ((Interface2Builder) parentBuilder).setIpv4(readValue); } @Nonnull @Override public Ipv4Builder getBuilder(@Nonnull final InstanceIdentifier<Ipv4> id) { return new Ipv4Builder(); } @Override public void readCurrentAttributes(@Nonnull final InstanceIdentifier<Ipv4> id, @Nonnull final Ipv4Builder builder, @Nonnull final ReadContext ctx) throws ReadFailedException { LOG.warn("Operation not supported"); } pageReplacementStrategy.notifyCachePageAccess(cPage); return cPage; } cPage = cPage.next; } } finally { bucket.bucketLock.unlock(); } return cPage; } @Override public ICachedPage pin(long dpid, boolean newPage) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid); if (!newPage)

sample: 818
buggy_code:  pageReplacementStrategy.notifyCachePageAccess(cPage); return cPage; } cPage = cPage.next; } } finally { bucket.bucketLock.unlock(); } return cPage; } @Override public ICachedPage pin(long dpid, boolean newPage) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } <|startfocus|> CachedPage cPage = findPage(dpid); <|endfocus|> if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage); cPage.valid = true; } } } else {
code_review:  let's move the unpin to a finally, if a boolean (i.e. success) isn't set after the tryRead(), so that we handle non-Exception throwables here as well. 
target code: pageReplacementStrategy.notifyCachePageAccess(cPage); return cPage; } cPage = cPage.next; } } finally { bucket.bucketLock.unlock(); } return cPage; } @Override public ICachedPage pin(long dpid, boolean newPage) throws HyracksDataException { // Calling the pinSanityCheck should be used only for debugging, since // the synchronized block over the fileInfoMap is a hot spot. if (DEBUG) { pinSanityCheck(dpid); } CachedPage cPage = findPage(dpid, false); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage); cPage.valid = true; } } } else {
response: CachedPage cPage = findPage(dpid); if (!newPage) { if (DEBUG) { confiscateLock.lock(); try { for (CachedPage c : confiscatedPages) { if (c.dpid == dpid && c.confiscated.get()) { throw new IllegalStateException(); } } } finally { confiscateLock.unlock(); } } // Resolve race of multiple threads trying to read the page from // disk. synchronized (cPage) { if (!cPage.valid) { read(cPage); cPage.valid = true; } } } else { try { tryRead(cPage); } finally { if (!cPage.valid) { unpin(cPage); } } } return cPage;

sample: 819
buggy_code:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.common; import java.io.File; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Random; <|startfocus|> import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; <|endfocus|> import org.apache.commons.lang3.mutable.Mutable; import org.apache.commons.lang3.mutable.MutableObject; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.exceptions.HyracksException; import org.apache.hyracks.api.io.FileReference; import org.apache.hyracks.api.io.IIOManager; import org.apache.hyracks.storage.common.buffercache.CachedPage; import org.apache.hyracks.storage.common.buffercache.IBufferCache; import org.apache.hyracks.storage.common.buffercache.ICachedPage; import org.apache.hyracks.storage.common.file.BufferedFileHandle;
code_review:  Welcome to IntelliJ. You need to change the config to not use * until the number of imports in the same package is > 99. Also the formatting of the whole file isn't right. You will need to import the Eclipse config file. 
target code: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.common; import java.io.File; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Random; import org.apache.commons.lang3.mutable.Mutable; import org.apache.commons.lang3.mutable.MutableObject; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.exceptions.HyracksException; import org.apache.hyracks.api.io.FileReference; import org.apache.hyracks.api.io.IIOManager; import org.apache.hyracks.storage.common.buffercache.CachedPage; import org.apache.hyracks.storage.common.buffercache.IBufferCache; import org.apache.hyracks.storage.common.buffercache.ICachedPage; import org.apache.hyracks.storage.common.file.BufferedFileHandle;
response: package org.apache.hyracks.storage.common; import java.io.File; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Random; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; import org.apache.commons.lang3.mutable.Mutable; import org.apache.commons.lang3.mutable.MutableObject; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.exceptions.HyracksException; import org.apache.hyracks.api.io.FileReference; import org.apache.hyracks.api.io.IIOManager; import org.apache.hyracks.storage.common.buffercache.CachedPage; import org.apache.hyracks.storage.common.buffercache.IBufferCache; import org.apache.hyracks.storage.common.buffercache.ICachedPage; import org.apache.hyracks.storage.common.file.BufferedFileHandle; public class StorageUtils { private static final int MAX_OPEN_FILES = 100; private static final int MAX_OPEN_FILES_THRESHOLD = (int) (MAX_OPEN_FILES * 0.9); private static final int MAX_OPEN_FILES_WAIT_TIME = 100; private static final int MAX_OPEN_FILES_WAIT_ATTEMPTS = 10; private static final int MAX_OPEN_FILES_WAIT_BACKOFF = 10; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_ATTEMPTS = 10; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_THRESHOLD = 100; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX = 1000; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_ATTEMPTS = 10; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_THRESHOLD = 1000; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_MAX = 10000; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_MAX_ATTEMPTS = 10; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_MAX_THRESHOLD = 10000; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_MAX_MAX = 100000; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_MAX_MAX_ATTEMPTS = 10; private static final int MAX_OPEN_FILES_WAIT_BACKOFF_MAX_MAX_MAX_THRESHOLD = 100000; private static final int MAX_OPEN_FILES_WAIT

sample: 820
buggy_code:  } this.writer = writer; } @Override public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // input is not accessed } @Override public void open() throws HyracksDataException { if (idx == 0) { writer.open(); } } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { writer.nextFrame(buffer); } @Override public void fail() throws HyracksDataException { <|startfocus|> boolean failed = this.failed.getValue(); this.failed.setValue(Boolean.TRUE); <|endfocus|> if (!failed) { writer.fail(); } } @Override public void close() throws HyracksDataException { if (idx == 0) { writer.close(); } } } } 
code_review:  MAJOR SonarQube violation: Rename "failed" which hides the field declared at line 62. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck 
target code: } this.writer = writer; } @Override public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // input is not accessed } @Override public void open() throws HyracksDataException { if (idx == 0) { writer.open(); } } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { writer.nextFrame(buffer); } @Override public void fail() throws HyracksDataException { boolean failed = failedShared.getValue(); failedShared.setValue(Boolean.TRUE); if (!failed) { writer.fail(); } } @Override public void close() throws HyracksDataException { if (idx == 0) { writer.close(); } } } }
response: private final IFrameWriter writer; private final MutableBoolean failed; public ForwardingFrameWriter(IFrameWriter writer) { this.writer = writer; this.failed = new MutableBoolean(false); } @Override public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // input is not accessed } @Override public void open() throws HyracksDataException { if (idx == 0) { writer.open(); } } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { writer.nextFrame(buffer); } @Override public void fail() throws HyracksDataException { boolean wasFailed = this.failed.getValue(); this.failed.setValue(true); if (!wasFailed) { writer.fail(); } } @Override public void close() throws HyracksDataException { if (idx == 0) { writer.close(); } }

sample: 821
buggy_code:  int n = subplans.size(); AlgebricksPipeline[] result = new AlgebricksPipeline[n]; for (int i = 0; i < n; i++) { List<AlgebricksPipeline> subplanOps = subplans.get(i); if (subplanOps.size() != 1) { throw new AlgebricksException("Attempting to construct a nested plan with " + subplanOps.size() <|startfocus|> + " operator descriptors. Currently, nested plans can only consist in linear pipelines of Asterix micro operators."); <|endfocus|> } result[i] = subplanOps.get(0); } return result; } protected List<List<AlgebricksPipeline>> compileSubplansImpl(IOperatorSchema outerPlanSchema, AbstractOperatorWithNestedPlans npOp, IOperatorSchema opSchema, JobGenContext context) throws AlgebricksException { List<List<AlgebricksPipeline>> subplans = new ArrayList<>(npOp.getNestedPlans().size()); PlanCompiler pc = new PlanCompiler(context); for (ILogicalPlan p : npOp.getNestedPlans()) { subplans.add(buildPipelineWithProjection(p, outerPlanSchema, npOp, opSchema, pc)); } return subplans; } 
code_review:  MAJOR SonarQube violation: Split this 141 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: int n = subplans.size(); AlgebricksPipeline[] result = new AlgebricksPipeline[n]; for (int i = 0; i < n; i++) { List<AlgebricksPipeline> subplanOps = subplans.get(i); if (subplanOps.size() != 1) { throw new AlgebricksException("Attempting to construct a nested plan with " + subplanOps.size() + " operator descriptors. Currently, nested plans can only consist in linear pipelines of " + "Asterix micro operators."); } result[i] = subplanOps.get(0); } return result; } protected List<List<AlgebricksPipeline>> compileSubplansImpl(IOperatorSchema outerPlanSchema, AbstractOperatorWithNestedPlans npOp, IOperatorSchema opSchema, JobGenContext context) throws AlgebricksException { List<List<AlgebricksPipeline>> subplans = new ArrayList<>(npOp.getNestedPlans().size()); PlanCompiler pc = new PlanCompiler(context); for (ILogicalPlan p : npOp.getNestedPlans()) { subplans.add(buildPipelineWithProjection(p, outerPlanSchema, npOp, opSchema, pc)); } return subplans; }
response: int n = subplans.size(); AlgebricksPipeline[] result = new AlgebricksPipeline[n]; for (int i = 0; i < n; i++) { List<AlgebricksPipeline> subplanOps = subplans.get(i); if (subplanOps.size() != 1) { throw new AlgebricksException("Attempting to construct a nested plan with " + subplanOps.size() + " operator descriptors. Currently, nested plans can only consist in linear pipelines of Asterix micro operators."); } result[i] = subplanOps.get(0); } return result; } protected List<List<AlgebricksPipeline>> compileSubplansImpl(IOperatorSchema outerPlanSchema, AbstractOperatorWithNestedPlans npOp, IOperatorSchema opSchema, JobGenContext context) throws AlgebricksException { List<List<AlgebricksPipeline>> subplans = new ArrayList<>(npOp.getNestedPlans().size()); PlanCompiler pc = new PlanCompiler(context); for (ILogicalPlan p : npOp.getNestedPlans()) { subplans.add(buildPipelineWithProjection(p, outerPlanSchema, npOp, opSchema, pc)); } return subplans; }

sample: 822
buggy_code:  context.getTypeEnvironment(op.getInputs().get(0).getValue()), inputSchemas[0], context); IMissingWriterFactory[] missingWriterFactories = new IMissingWriterFactory[np.get(0).getOutputWidth()]; for (int i = 0; i < missingWriterFactories.length; i++) { missingWriterFactories[i] = context.getMissingWriterFactory(); } RecordDescriptor recDesc = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), opSchema, context); <|startfocus|> SubplanRuntimeFactory runtime = new SubplanRuntimeFactory(np, missingWriterFactories, inputRecordDesc, recDesc, null); <|endfocus|> builder.contributeMicroOperator(subplan, runtime, recDesc); ILogicalOperator src = op.getInputs().get(0).getValue(); builder.contributeGraphEdge(src, 0, op, 0); } @Override public boolean expensiveThanMaterialization() { return true; } } 
code_review:  MAJOR SonarQube violation: Split this 126 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: context.getTypeEnvironment(op.getInputs().get(0).getValue()), inputSchemas[0], context); IMissingWriterFactory[] missingWriterFactories = new IMissingWriterFactory[np.get(0).getOutputWidth()]; for (int i = 0; i < missingWriterFactories.length; i++) { missingWriterFactories[i] = context.getMissingWriterFactory(); } RecordDescriptor recDesc = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), opSchema, context); SubplanRuntimeFactory runtime = new SubplanRuntimeFactory(np, missingWriterFactories, inputRecordDesc, recDesc, null); builder.contributeMicroOperator(subplan, runtime, recDesc); ILogicalOperator src = op.getInputs().get(0).getValue(); builder.contributeGraphEdge(src, 0, op, 0); } @Override public boolean expensiveThanMaterialization() { return true; } }
response: context.getTypeEnvironment(op.getInputs().get(0).getValue()), inputSchemas[0], context); IMissingWriterFactory[] missingWriterFactories = new IMissingWriterFactory[np.get(0).getOutputWidth()]; for (int i = 0; i < missingWriterFactories.length; i++) { missingWriterFactories[i] = context.getMissingWriterFactory(); } RecordDescriptor recDesc = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), opSchema, context); SubplanRuntimeFactory runtime = new SubplanRuntimeFactory(np, missingWriterFactories, inputRecordDesc, recDesc, null); builder.contributeMicroOperator(subplan, runtime, recDesc); ILogicalOperator src = op.getInputs().get(0).getValue(); builder.contributeGraphEdge(src, 0, op, 0); } @Override public boolean expensiveThanMaterialization() { return true; }

sample: 823
buggy_code: <|startfocus|> public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { <|endfocus|>
code_review:  MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 
target code: public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // input is not accessed
response: public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // TODO: Implement this method throw new UnsupportedOperationException("Not implemented yet"); }

sample: 824
buggy_code:  return useConnectorPolicyForScheduling; } public void setUseConnectorPolicyForScheduling(boolean useConnectorPolicyForScheduling) { this.useConnectorPolicyForScheduling = useConnectorPolicyForScheduling; } public void setRequiredClusterCapacity(IClusterCapacity capacity) { this.requiredClusterCapacity = capacity; } public IClusterCapacity getRequiredClusterCapacity() { return requiredClusterCapacity; } public void setMetaOps(List<? extends IOperatorDescriptor> metaOps) { this.metaOps = metaOps; } <|startfocus|> public List<? extends IOperatorDescriptor> getMetaOps() { <|endfocus|> return metaOps; } private <K, V> void insertIntoIndexedMap(Map<K, List<V>> map, K key, int index, V value) { List<V> vList = map.computeIfAbsent(key, k -> new ArrayList<>()); extend(vList, index); vList.set(index, value); } @Override public String toString() { StringBuilder buffer = new StringBuilder(); opMap.forEach((key, value) -> { buffer.append(key.getId()).append(" : ").append(value.toString()).append("\n");
code_review:  MAJOR SonarQube violation: Remove usage of generic wildcard type. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1452 
target code: return useConnectorPolicyForScheduling; } public void setUseConnectorPolicyForScheduling(boolean useConnectorPolicyForScheduling) { this.useConnectorPolicyForScheduling = useConnectorPolicyForScheduling; } public void setRequiredClusterCapacity(IClusterCapacity capacity) { this.requiredClusterCapacity = capacity; } public IClusterCapacity getRequiredClusterCapacity() { return requiredClusterCapacity; } public void setMetaOps(List<? extends IOperatorDescriptor> metaOps) { this.metaOps = metaOps; } public List<IOperatorDescriptor> getMetaOps() { return metaOps; } private <K, V> void insertIntoIndexedMap(Map<K, List<V>> map, K key, int index, V value) { List<V> vList = map.computeIfAbsent(key, k -> new ArrayList<>()); extend(vList, index); vList.set(index, value); } @Override public String toString() { StringBuilder buffer = new StringBuilder(); opMap.forEach((key, value) -> { buffer.append(key.getId()).append(" : ").append(value.toString()).append("\n");
response: return useConnectorPolicyForScheduling; } public void setUseConnectorPolicyForScheduling(boolean useConnectorPolicyForScheduling) { this.useConnectorPolicyForScheduling = useConnectorPolicyForScheduling; } public void setRequiredClusterCapacity(IClusterCapacity capacity) { this.requiredClusterCapacity = capacity; } public IClusterCapacity getRequiredClusterCapacity() { return requiredClusterCapacity; } public void setMetaOps(List<IOperatorDescriptor> metaOps) { this.metaOps = metaOps; } public List<IOperatorDescriptor> getMetaOps() { return metaOps; } private <K, V> void insertIntoIndexedMap(Map<K, List<V>> map, K key, int index, V value) { List<V> vList = map.computeIfAbsent(key, k -> new ArrayList<>()); extend(vList, index); vList.set(index, value); } @Override public String toString() { StringBuilder buffer = new StringBuilder(); opMap.forEach((key, value) -> { buffer.append(key.getId()).append(" : ").append(value.toString()).append("\n"); }); return buffer.toString(); }

sample: 825
buggy_code:  * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.ipc.impl; import org.apache.hyracks.ipc.api.IIPCEventListener; public class NoOpIPCEventListener implements IIPCEventListener { <|startfocus|> public static final IIPCEventListener INSTANCE = new NoOpIPCEventListener(); <|endfocus|> } 
code_review:  MAJOR SonarQube violation: Add a private constructor to hide the implicit public one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1118 
target code: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.ipc.impl; import org.apache.hyracks.ipc.api.IIPCEventListener; public class NoOpIPCEventListener implements IIPCEventListener { public static final IIPCEventListener INSTANCE = new NoOpIPCEventListener(); private NoOpIPCEventListener() { } }
response: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.ipc.impl; import org.apache.hyracks.ipc.api.IIPCEventListener; public class NoOpIPCEventListener implements IIPCEventListener { private NoOpIPCEventListener() { } public static final IIPCEventListener INSTANCE = new NoOpIPCEventListener(); }

sample: 826
buggy_code:  return new BloomFilterBuilder(numElements, numHashes, numBitsPerElement); } public class BloomFilterBuilder implements IIndexBulkLoader { private final long[] hashes = BloomFilter.createHashArray(); private final long numElements; private final int numHashes; private final long numBits; private final int numPages; private final IFIFOPageQueue queue; private final ICachedPage[] pages; private ICachedPage metaDataPage = null; <|startfocus|> public BloomFilterBuilder(long numElements, int numHashes, int numBitsPerElement) throws HyracksDataException { <|endfocus|> if (!isActivated) { throw HyracksDataException.create(ErrorCode.CANNOT_CREATE_BLOOM_FILTER_BUILDER_FOR_INACTIVE_FILTER); } queue = bufferCache.createFIFOQueue(); this.numElements = numElements; this.numHashes = numHashes; numBits = this.numElements * numBitsPerElement; long tmp = (long) Math.ceil(numBits / (double) numBitsPerPage); if (tmp > Integer.MAX_VALUE) { throw HyracksDataException.create(ErrorCode.CANNOT_CREATE_BLOOM_FILTER_WITH_NUMBER_OF_PAGES, tmp); } numPages = (int) tmp; pages = new ICachedPage[numPages];
code_review:  MAJOR SonarQube violation: Split this 129 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: return new BloomFilterBuilder(numElements, numHashes, numBitsPerElement); } public class BloomFilterBuilder implements IIndexBulkLoader { private final long[] hashes = BloomFilter.createHashArray(); private final long numElements; private final int numHashes; private final long numBits; private final int numPages; private final IFIFOPageQueue queue; private final ICachedPage[] pages; private ICachedPage metaDataPage = null; public BloomFilterBuilder(long estimatedNumElemenets, int numHashes, int numBitsPerElement) throws HyracksDataException { if (!isActivated) { throw HyracksDataException.create(ErrorCode.CANNOT_CREATE_BLOOM_FILTER_BUILDER_FOR_INACTIVE_FILTER); } queue = bufferCache.createFIFOQueue(); this.numElements = numElements; this.numHashes = numHashes; numBits = this.numElements * numBitsPerElement; long tmp = (long) Math.ceil(numBits / (double) numBitsPerPage); if (tmp > Integer.MAX_VALUE) { throw HyracksDataException.create(ErrorCode.CANNOT_CREATE_BLOOM_FILTER_WITH_NUMBER_OF_PAGES, tmp); } numPages = (int) tmp; pages = new ICachedPage[numPages];
response: return new BloomFilterBuilder(numElements, numHashes, numBitsPerElement); } public class BloomFilterBuilder implements IIndexBulkLoader { private final long[] hashes = BloomFilter.createHashArray(); private final long numElements; private final int numHashes; private final long numBits; private final int numPages; private final IFIFOPageQueue queue; private final ICachedPage[] pages; private ICachedPage metaDataPage = null; public BloomFilterBuilder(long numElements, int numHashes, int numBitsPerElement) throws HyracksDataException { if (!isActivated) { throw HyracksDataException.create(ErrorCode.CANNOT_CREATE_BLOOM_FILTER_BUILDER_FOR_INACTIVE_FILTER); } queue = bufferCache.createFIFOQueue(); this.numElements = numElements; this.numHashes = numHashes; numBits = this.numElements * numBitsPerElement; long tmp = (long) Math.ceil(numBits / (double) numBitsPerPage); if (tmp > Integer.MAX_VALUE) { throw HyracksDataException.create(ErrorCode.CANNOT_CREATE_BLOOM_FILTER_WITH_NUMBER_OF_PAGES, tmp); } numPages = (int) tmp; pages = new ICachedPage[numPages]; } }

sample: 827
buggy_code: import org.apache.hyracks.tests.util.NoOpOperatorDescriptor; import org.junit.Assert; import org.junit.Test; public class JobFailureTest extends AbstractMultiNCIntegrationTest { @Test public void failureOnCreatePushRuntime() throws Exception { JobId jobId = null; for (int i = 0; i < 20; i++) { JobSpecification spec = new JobSpecification(); <|startfocus|> JobId runJobId = runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[]{4}, true)); <|endfocus|> if (i == 0) { jobId = runJobId; // passes. read from job archive waitForCompletion(jobId, ExceptionOnCreatePushRuntimeOperatorDescriptor.ERROR_MESSAGE); } } // passes. read from job history waitForCompletion(jobId, ExceptionOnCreatePushRuntimeOperatorDescriptor.ERROR_MESSAGE); for (int i = 0; i < 300; i++) { JobSpecification spec = new JobSpecification(); runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[] { 4 }, true)); } // passes. history has been cleared
code_review:  long line 
target code: import org.apache.hyracks.tests.util.NoOpOperatorDescriptor; import org.junit.Assert; import org.junit.Test; public class JobFailureTest extends AbstractMultiNCIntegrationTest { @Test public void failureOnCreatePushRuntime() throws Exception { JobId jobId = null; for (int i = 0; i < 20; i++) { JobSpecification spec = new JobSpecification(); JobId runJobId = runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[] { 4 }, true)); if (i == 0) { jobId = runJobId; // passes. read from job archive waitForCompletion(jobId, ExceptionOnCreatePushRuntimeOperatorDescriptor.ERROR_MESSAGE); } } // passes. read from job history waitForCompletion(jobId, ExceptionOnCreatePushRuntimeOperatorDescriptor.ERROR_MESSAGE); for (int i = 0; i < 300; i++) { JobSpecification spec = new JobSpecification(); runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[] { 4 }, true)); } // passes. history has been cleared
response: import org.apache.hyracks.tests.util.NoOpOperatorDescriptor; import org.junit.Assert; import org.junit.Test; public class JobFailureTest extends AbstractMultiNCIntegrationTest { @Test public void failureOnCreatePushRuntime() throws Exception { JobId jobId = null; for (int i = 0; i < 20; i++) { JobSpecification spec = new JobSpecification(); JobId runJobId = runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[]{4}, true)); if (i == 0) { jobId = runJobId; waitForCompletion(jobId, ExceptionOnCreatePushRuntimeOperatorDescriptor.ERROR_MESSAGE); } } waitForCompletion(jobId, ExceptionOnCreatePushRuntimeOperatorDescriptor.ERROR_MESSAGE); for (int i = 0; i < 300; i++) { JobSpecification spec = new JobSpecification(); runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[] { 4 }, true)); } } }

sample: 828
buggy_code:  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.api.http.server; import java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.function.Function; <|startfocus|> import javax.xml.transform.Result; <|endfocus|> import org.apache.asterix.algebra.base.ILangExtension; import org.apache.asterix.app.message.CancelQueryRequest; import org.apache.asterix.app.message.ExecuteStatementRequestMessage; import org.apache.asterix.app.message.ExecuteStatementResponseMessage; import org.apache.asterix.app.result.ResultReader; import org.apache.asterix.common.api.Duration; import org.apache.asterix.common.api.IApplicationContext; import org.apache.asterix.common.config.GlobalConfig; import org.apache.asterix.common.exceptions.ErrorCode; import org.apache.asterix.common.exceptions.ExceptionUtils; import org.apache.asterix.common.exceptions.RuntimeDataException; import org.apache.asterix.common.messaging.api.INCMessageBroker;
code_review:  Do we need this? 
target code: * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.api.http.server; import java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.function.Function; import org.apache.asterix.algebra.base.ILangExtension; import org.apache.asterix.app.message.CancelQueryRequest; import org.apache.asterix.app.message.ExecuteStatementRequestMessage; import org.apache.asterix.app.message.ExecuteStatementResponseMessage; import org.apache.asterix.app.result.ResultReader; import org.apache.asterix.common.api.Duration; import org.apache.asterix.common.api.IApplicationContext; import org.apache.asterix.common.config.GlobalConfig; import org.apache.asterix.common.exceptions.ErrorCode; import org.apache.asterix.common.exceptions.ExceptionUtils; import org.apache.asterix.common.exceptions.RuntimeDataException; import org.apache.asterix.common.messaging.api.INCMessageBroker;
response: Fixed Code: ```java package org.apache.asterix.api.http.server; import java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.function.Function; import org.apache.asterix.algebra.base.ILangExtension; import org.apache.asterix.app.message.CancelQueryRequest; import org.apache.asterix.app.message.ExecuteStatementRequestMessage; import org.apache.asterix.app.message.ExecuteStatementResponseMessage; import org.apache.asterix.app.result.ResultReader; import org.apache.asterix.common.api.Duration; import org.apache.asterix.common.api.IApplicationContext; import org.apache.asterix.common.config.GlobalConfig; import org.apache.asterix.common.exceptions.ErrorCode; import org.apache.asterix.common.exceptions.ExceptionUtils; import org.apache.asterix.common.exceptions.RuntimeDataException; import org.apache.asterix.common.messaging.api.INCMessageBroker; import javax.xml.transform.Result; public class MyClass { // code here } ```

sample: 829
buggy_code:  channel.abort(); } finally { channel.close(); resultState.readClose(); // if resultState has been exhausted, delete the result partition if (resultState.isExhausted()) { datasetPartitionManager.removePartition(resultState.getResultSetPartitionId().getJobId(), resultState.getResultSetPartitionId().getResultSetId(), resultState.getResultSetPartitionId().getPartition()); } } } catch (HyracksDataException e) { LOGGER.error("unexpected failure in partition reader", e); } <|startfocus|> if (LOGGER.isInfoEnabled()) { LOGGER.info("result reading successful(" + resultState.getResultSetPartitionId() + ")"); <|endfocus|> }
code_review:  Should this/does this fail the request? 
target code: channel.abort(); } finally { channel.close(); resultState.readClose(); // if resultState has been exhausted, delete the result partition if (resultState.isExhausted()) { datasetPartitionManager.removePartition(resultState.getResultSetPartitionId().getJobId(), resultState.getResultSetPartitionId().getResultSetId(), resultState.getResultSetPartitionId().getPartition()); } } } catch (HyracksDataException e) { LOGGER.error("unexpected failure in partition reader", e); } if (LOGGER.isDebugEnabled()) { LOGGER.debug("result reading successful(" + resultState.getResultSetPartitionId() + ")"); }
response: channel.abort(); } finally { channel.close(); resultState.readClose(); // if resultState has been exhausted, delete the result partition if (resultState.isExhausted()) { datasetPartitionManager.removePartition(resultState.getResultSetPartitionId().getJobId(), resultState.getResultSetPartitionId().getResultSetId(), resultState.getResultSetPartitionId().getPartition()); } } catch (HyracksDataException e) { LOGGER.error("unexpected failure in partition reader", e); } if (LOGGER.isInfoEnabled()) { LOGGER.info("result reading successful(" + resultState.getResultSetPartitionId() + ")"); }

sample: 830
buggy_code:  * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.translator; import java.util.Map; import org.apache.asterix.translator.IStatementExecutor.Stats; import org.apache.hyracks.api.dataset.IHyracksDataset; public interface IRequestParameters { /** * @return A Hyracks dataset client object that is used to read the results. */ IHyracksDataset getHyracksDataset(); /** <|startfocus|> * @return The {@code ResultDelivery} kind required for queries in the list of statements <|endfocus|> */ ResultProperties getResultProperties(); /** * @return a reference to write the stats of executed queries */ Stats getStats(); /** * @return a reference to write the metadata of executed queries */ IStatementExecutor.ResultMetadata getOutMetadata(); /** * @return the client context id for the query */ String getClientContextId(); /** * @return Optional request parameters. Otherwise null. */ Map<String, String> getOptionalParameters(); } 
code_review:  fixme 
target code: * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.translator; import java.util.Map; import org.apache.asterix.translator.IStatementExecutor.Stats; import org.apache.hyracks.api.dataset.IHyracksDataset; public interface IRequestParameters { /** * @return A Hyracks dataset client object that is used to read the results. */ IHyracksDataset getHyracksDataset(); /** * Gets the required result properties of the request. * * @return the result properties */ ResultProperties getResultProperties(); /** * @return a reference to write the stats of executed queries */ Stats getStats(); /** * @return a reference to write the metadata of executed queries */ IStatementExecutor.ResultMetadata getOutMetadata(); /** * @return the client context id for the query */ String getClientContextId(); /** * @return Optional request parameters. Otherwise null. */ Map<String, String> getOptionalParameters(); }
response: package org.apache.asterix.translator; import java.util.Map; import org.apache.asterix.translator.IStatementExecutor.Stats; import org.apache.hyracks.api.dataset.IHyracksDataset; public interface IRequestParameters { IHyracksDataset getHyracksDataset(); ResultProperties getResultProperties(); Stats getStats(); IStatementExecutor.ResultMetadata getOutMetadata(); String getClientContextId(); Map<String, String> getOptionalParameters(); }

sample: 831
buggy_code:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IIndexCursor; public interface ILSMIndexCursor extends IIndexCursor { /** <|startfocus|> * @return the min tuple of the current index's filter <|endfocus|> */ ITupleReference getFilterMinTuple(); /** * * @return the max tuple of the current index's filter */ ITupleReference getFilterMaxTuple(); } 
code_review:  To be more clear, I think this should be "current component's filter"? 
target code: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IIndexCursor; public interface ILSMIndexCursor extends IIndexCursor { /** * @return the min tuple of the corresponding component's filter */ ITupleReference getFilterMinTuple(); /** * * @return the max tuple of the current index's filter */ ITupleReference getFilterMaxTuple(); }
response: package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IIndexCursor; public interface ILSMIndexCursor extends IIndexCursor { ITupleReference getFilterMinTuple(); ITupleReference getFilterMaxTuple(); }

sample: 832
buggy_code:  * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IIndexCursor; <|startfocus|> public interface ILSMIndexCursor extends IIndexCursor{ <|endfocus|> /** * @return the min tuple of the current index's filter */ ITupleReference getFilterMinTuple(); /** * * @return the max tuple of the current index's filter */ ITupleReference getFilterMaxTuple(); } 
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IIndexCursor; public interface ILSMIndexCursor extends IIndexCursor { /** * @return the min tuple of the current index's filter */ ITupleReference getFilterMinTuple(); /** * * @return the max tuple of the current index's filter */ ITupleReference getFilterMaxTuple(); }
response: ```java /* * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.hyracks.storage.common.IIndexCursor; public interface ILSMIndexCursor extends IIndexCursor { ITupleReference getFilterMinTuple(); ITupleReference getFilterMaxTuple(); } ```

sample: 833
buggy_code:  AbstractLogicalOperator op2 = (AbstractLogicalOperator) opRef2.getValue(); // If it's not an indexed field, it is pushed so that scan can be // rewritten into index search. if (op2.getOperatorTag() == LogicalOperatorTag.PROJECT || context.checkAndAddToAlreadyCompared(access, op2) && !(op2.getOperatorTag() == LogicalOperatorTag.SELECT && isAccessToIndexedField(access, context))) { return false; } <|startfocus|> Object annotation = op2.getAnnotations().get(IS_MOVABLE); <|endfocus|> if (annotation != null && !((Boolean) annotation)) { return false; } if (tryingToPushThroughSelectionWithSameDataSource(access, op2)) { return false; } if (testAndModifyRedundantOp(access, op2)) { propagateFieldAccessRec(opRef2, context, finalAnnot); return true; } List<LogicalVariable> usedInAccess = new LinkedList<>(); VariableUtilities.getUsedVariables(access, usedInAccess); List<LogicalVariable> produced2 = new LinkedList<>(); if (op2.getOperatorTag() == LogicalOperatorTag.GROUP) { VariableUtilities.getLiveVariables(op2, produced2);
code_review:  Since we here anyways, can you change that to refernce OperatorPropertiesUtil.MOVABLE instead? 
target code: AbstractLogicalOperator op2 = (AbstractLogicalOperator) opRef2.getValue(); // If it's not an indexed field, it is pushed so that scan can be // rewritten into index search. if (op2.getOperatorTag() == LogicalOperatorTag.PROJECT || context.checkAndAddToAlreadyCompared(access, op2) && !(op2.getOperatorTag() == LogicalOperatorTag.SELECT && isAccessToIndexedField(access, context))) { return false; } Object annotation = op2.getAnnotations().get("isMovable"); if (annotation != null && !((Boolean) annotation)) { return false; } if (tryingToPushThroughSelectionWithSameDataSource(access, op2)) { return false; } if (testAndModifyRedundantOp(access, op2)) { propagateFieldAccessRec(opRef2, context, finalAnnot); return true; } List<LogicalVariable> usedInAccess = new LinkedList<>(); VariableUtilities.getUsedVariables(access, usedInAccess); List<LogicalVariable> produced2 = new LinkedList<>(); if (op2.getOperatorTag() == LogicalOperatorTag.GROUP) { VariableUtilities.getLiveVariables(op2, produced2);
response: AbstractLogicalOperator op2 = (AbstractLogicalOperator) opRef2.getValue(); if (op2.getOperatorTag() == LogicalOperatorTag.PROJECT || context.checkAndAddToAlreadyCompared(access, op2) && !(op2.getOperatorTag() == LogicalOperatorTag.SELECT && isAccessToIndexedField(access, context))) { return false; } Object annotation = op2.getAnnotations().get(IS_MOVABLE); if (annotation != null && !((Boolean) annotation)) { return false; } if (tryingToPushThroughSelectionWithSameDataSource(access, op2)) { return false; } if (testAndModifyRedundantOp(access, op2)) { propagateFieldAccessRec(opRef2, context, finalAnnot); return true; } List<LogicalVariable> usedInAccess = new LinkedList<>(); VariableUtilities.getUsedVariables(access, usedInAccess); List<LogicalVariable> produced2 = new LinkedList<>(); if (op2.getOperatorTag() == LogicalOperatorTag.GROUP) { VariableUtilities.getLiveVariables(op2, produced2); }

sample: 834
buggy_code:  import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator; import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable; import org.apache.hyracks.algebricks.core.algebra.properties.VariablePropagationPolicy; import org.apache.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; public abstract class AbstractBinaryJoinOperator extends AbstractLogicalOperator { protected final Mutable<ILogicalExpression> condition; protected JoinKind joinKind; <|startfocus|> public Map<Integer, Integer> getPhaseToInput() { return phaseToInput; } protected Map<Integer,Integer> phaseToInput; <|endfocus|> public enum JoinKind { INNER, LEFT_OUTER } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition) { this.joinKind = joinKind; this.condition = condition; this.phaseToInput = new HashMap<>(); phaseToInput.put(0,1); phaseToInput.put(1,0); } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition, Mutable<ILogicalOperator> input1, Mutable<ILogicalOperator> input2) { this(joinKind, condition);
code_review:  MAJOR SonarQube violation: Add the "@Override" annotation above this method signature Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1161 
target code: import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator; import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable; import org.apache.hyracks.algebricks.core.algebra.properties.VariablePropagationPolicy; import org.apache.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; public abstract class AbstractBinaryJoinOperator extends AbstractLogicalOperator { protected final Mutable<ILogicalExpression> condition; protected JoinKind joinKind; public enum JoinKind { INNER, LEFT_OUTER } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition) { this.joinKind = joinKind; this.condition = condition; this.phaseToInput = new HashMap<>(); phaseToInput.put(0,1); phaseToInput.put(1,0); } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition, Mutable<ILogicalOperator> input1, Mutable<ILogicalOperator> input2) { this(joinKind, condition);
response: import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator; import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable; import org.apache.hyracks.algebricks.core.algebra.properties.VariablePropagationPolicy; import org.apache.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; import java.util.HashMap; import java.util.Map; public abstract class AbstractBinaryJoinOperator extends AbstractLogicalOperator { protected final Mutable<ILogicalExpression> condition; protected JoinKind joinKind; public Map<Integer, Integer> getPhaseToInput() { return phaseToInput; } protected Map<Integer,Integer> phaseToInput; public enum JoinKind { INNER, LEFT_OUTER } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition) { this.joinKind = joinKind; this.condition = condition; this.phaseToInput = new HashMap<>(); phaseToInput.put(0,1); phaseToInput.put(1,0); } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition, Mutable<ILogicalOperator> input1, Mutable<ILogicalOperator> input2) { this(joinKind, condition); this.input1 = input1; this.input2 = input2; } }

sample: 835
buggy_code: import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator; import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable; import org.apache.hyracks.algebricks.core.algebra.properties.VariablePropagationPolicy; import org.apache.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; public abstract class AbstractBinaryJoinOperator extends AbstractLogicalOperator { protected final Mutable<ILogicalExpression> condition; protected JoinKind joinKind; <|startfocus|> public Map<Integer, Integer> getPhaseToInput() { return phaseToInput; } protected Map<Integer,Integer> phaseToInput; <|endfocus|> public enum JoinKind { INNER, LEFT_OUTER } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition) { this.joinKind = joinKind; this.condition = condition; this.phaseToInput = new HashMap<>(); phaseToInput.put(0,1); phaseToInput.put(1,0); } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition, Mutable<ILogicalOperator> input1, Mutable<ILogicalOperator> input2) { this(joinKind, condition); inputs.add(input1); inputs.add(input2); } 
code_review:  MAJOR SonarQube violation: "phaseToInput" is the name of a field in "AbstractLogicalOperator". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2387 
target code: import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator; import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable; import org.apache.hyracks.algebricks.core.algebra.properties.VariablePropagationPolicy; import org.apache.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; public abstract class AbstractBinaryJoinOperator extends AbstractLogicalOperator { protected final Mutable<ILogicalExpression> condition; protected JoinKind joinKind; public enum JoinKind { INNER, LEFT_OUTER } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition) { this.joinKind = joinKind; this.condition = condition; this.phaseToInput = new HashMap<>(); phaseToInput.put(0,1); phaseToInput.put(1,0); } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition, Mutable<ILogicalOperator> input1, Mutable<ILogicalOperator> input2) { this(joinKind, condition); inputs.add(input1); inputs.add(input2); }
response: import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator; import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable; import org.apache.hyracks.algebricks.core.algebra.properties.VariablePropagationPolicy; import org.apache.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; public abstract class AbstractBinaryJoinOperator extends AbstractLogicalOperator { protected final Mutable<ILogicalExpression> condition; protected JoinKind joinKind; protected Map<Integer, Integer> phaseToInput; public enum JoinKind { INNER, LEFT_OUTER } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition) { this.joinKind = joinKind; this.condition = condition; this.phaseToInput = new HashMap<>(); phaseToInput.put(0, 1); phaseToInput.put(1, 0); } public AbstractBinaryJoinOperator(JoinKind joinKind, Mutable<ILogicalExpression> condition, Mutable<ILogicalOperator> input1, Mutable<ILogicalOperator> input2) { this(joinKind, condition); inputs.add(input1); inputs.add(input2); } public Map<Integer, Integer> getPhaseToInput() { return phaseToInput; } }

sample: 836
buggy_code:  if (connection != null) { inp.put("input", connection.getLeft().getLeft().getOperatorId().toString()); } } } if (pleObject.size() > 0) { pcObject.set("location", pleObject); } if (pcObject.size() > 0) { op.set("partition-constraints", pcObject); } <|startfocus|> if(inp.size() > 0) { op.set("inputs", inp); } <|endfocus|> } jopArray.add(op); }); jjob.set("operators", jopArray); ArrayNode jcArray = om.createArrayNode(); connMap.forEach((key, value) -> { ObjectNode conn = om.createObjectNode(); Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>> connection = connectorOpMap.get(key); if (connection != null) { conn.put("in-operator-id", connection.getLeft().getLeft().getOperatorId().toString()); conn.put("in-operator-port", connection.getLeft().getRight().intValue());
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: if (connection != null) { inp.put("input", connection.getLeft().getLeft().getOperatorId().toString()); } } } if (pleObject.size() > 0) { pcObject.set("location", pleObject); } if (pcObject.size() > 0) { op.set("partition-constraints", pcObject); } } jopArray.add(op); }); jjob.set("operators", jopArray); ArrayNode jcArray = om.createArrayNode(); connMap.forEach((key, value) -> { ObjectNode conn = om.createObjectNode(); Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>> connection = connectorOpMap.get(key); if (connection != null) { conn.put("in-operator-id", connection.getLeft().getLeft().getOperatorId().toString()); conn.put("in-operator-port", connection.getLeft().getRight().intValue());
response: if (connection != null) { inp.put("input", connection.getLeft().getLeft().getOperatorId().toString()); } if (pleObject.size() > 0) { pcObject.set("location", pleObject); } if (pcObject.size() > 0) { op.set("partition-constraints", pcObject); } if (inp.size() > 0) { op.set("inputs", inp); } jopArray.add(op); }); jjob.set("operators", jopArray); ArrayNode jcArray = om.createArrayNode(); connMap.forEach((key, value) -> { ObjectNode conn = om.createObjectNode(); Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>> connection = connectorOpMap.get(key); if (connection != null) { conn.put("in-operator-id", connection.getLeft().getLeft().getOperatorId().toString()); conn.put("in-operator-port", connection.getLeft().getRight().intValue()); } // rest of the code });

sample: 837
buggy_code:  } } return false; } /** * Executes the passed interruptible, retrying if the operation fails due to {@link ClosedByInterruptException}. * Once the interruptible completes, the current thread will be re-interrupted, if the original operation was * interrupted. */ public static void doIoUninterruptibly(ThrowingIOInterruptible interruptible) throws IOException { boolean interrupted = false; try { while (true) { try { interruptible.run(); break; <|startfocus|> } catch (ClosedByInterruptException e) { <|endfocus|> LOGGER.error("IO operation Interrupted. Retrying..", e); interrupted = true; Thread.interrupted(); } } } finally { if (interrupted) { Thread.currentThread().interrupt(); } } } @FunctionalInterface public interface Interruptible { void run() throws InterruptedException; } @FunctionalInterface public interface ThrowingInterruptible { void run() throws Exception; // NOSONAR } @FunctionalInterface public interface ThrowingIOInterruptible { void run() throws IOException; } } 
code_review:  should we handle both InterruptedException & ClosedByInterruptException here? 
target code: } } return false; } /** * Executes the passed interruptible, retrying if the operation fails due to {@link ClosedByInterruptException}. * Once the interruptible completes, the current thread will be re-interrupted, if the original operation was * interrupted. */ public static void doIoUninterruptibly(ThrowingIOInterruptible interruptible) throws IOException { boolean interrupted = false; try { while (true) { try { interruptible.run(); break; } catch (ClosedByInterruptException | InterruptedException e) { LOGGER.error("IO operation Interrupted. Retrying..", e); interrupted = true; Thread.interrupted(); } } } finally { if (interrupted) { Thread.currentThread().interrupt(); } } } @FunctionalInterface public interface Interruptible { void run() throws InterruptedException; } @FunctionalInterface public interface ThrowingInterruptible { void run() throws Exception; // NOSONAR } @FunctionalInterface public interface ThrowingIOInterruptible { void run() throws IOException; } }
response: } } return false; } /** * Executes the passed interruptible, retrying if the operation fails due to {@link ClosedByInterruptException}. * Once the interruptible completes, the current thread will be re-interrupted, if the original operation was * interrupted. */ public static void doIoUninterruptibly(ThrowingIOInterruptible interruptible) throws IOException { boolean interrupted = false; try { while (true) { try { interruptible.run(); break; } catch (ClosedByInterruptException e) { LOGGER.error("IO operation Interrupted. Retrying..", e); interrupted = true; Thread.interrupted(); } } } finally { if (interrupted) { Thread.currentThread().interrupt(); } } } @FunctionalInterface public interface Interruptible { void run() throws InterruptedException; } @FunctionalInterface public interface ThrowingInterruptible { void run() throws Exception; // NOSONAR } @FunctionalInterface public interface ThrowingIOInterruptible { void run() throws IOException; } }

sample: 838
buggy_code:  } catch (ClosedByInterruptException e) { LOGGER.error("IO operation Interrupted. Retrying..", e); interrupted = true; Thread.interrupted(); } } } finally { if (interrupted) { Thread.currentThread().interrupt(); } } } @FunctionalInterface public interface Interruptible { void run() throws InterruptedException; } @FunctionalInterface public interface ThrowingInterruptible { void run() throws Exception; // NOSONAR } @FunctionalInterface public interface ThrowingIOInterruptible { <|startfocus|> void run() throws IOException; <|endfocus|> } } 
code_review:  if you extend per comment on line 163, += InterruptedException here 
target code: } catch (ClosedByInterruptException e) { LOGGER.error("IO operation Interrupted. Retrying..", e); interrupted = true; Thread.interrupted(); } } } finally { if (interrupted) { Thread.currentThread().interrupt(); } } } @FunctionalInterface public interface Interruptible { void run() throws InterruptedException; } @FunctionalInterface public interface ThrowingInterruptible { void run() throws Exception; // NOSONAR } @FunctionalInterface public interface ThrowingIOInterruptible { void run() throws IOException, InterruptedException; } }
response: import java.io.IOException; import java.nio.channels.ClosedByInterruptException; public class InterruptibleUtils { private static final Logger LOGGER = LoggerFactory.getLogger(InterruptibleUtils.class); public static void runInterruptible(Interruptible action) { boolean interrupted = false; try { while (true) { try { action.run(); break; } catch (ClosedByInterruptException e) { LOGGER.error("IO operation Interrupted. Retrying..", e); interrupted = true; Thread.interrupted(); } } } catch (InterruptedException e) { interrupted = true; } finally { if (interrupted) { Thread.currentThread().interrupt(); } } } @FunctionalInterface public interface Interruptible { void run() throws InterruptedException; } @FunctionalInterface public interface ThrowingInterruptible { void run() throws Exception; } @FunctionalInterface public interface ThrowingIOInterruptible { void run() throws IOException; } }

sample: 839
buggy_code:  if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Substitute node joining : " + serviceContext.getNodeId()); } updateOnNodeJoin(); } appContext.initialize(initialRun); MessagingProperties messagingProperties = ((IPropertiesProvider) appContext).getMessagingProperties(); messageBroker = new NCMessageBroker(controllerService, messagingProperties); serviceContext.setMessageBroker(messageBroker); MessagingChannelInterfaceFactory interfaceFactory = new MessagingChannelInterfaceFactory((NCMessageBroker) messageBroker, messagingProperties); <|startfocus|> serviceContext.setMessagingChannelInterfaceFactory(interfaceFactory); <|endfocus|> boolean replicationEnabled = ClusterProperties.INSTANCE.isReplicationEnabled(); boolean autoFailover = ClusterProperties.INSTANCE.isAutoFailoverEnabled(); if (initialRun) { LOGGER.info("System is being initialized. (first run)"); } else { IRecoveryManager recoveryMgr = appContext.getTransactionSubsystem().getRecoveryManager(); systemState = recoveryMgr.getSystemState(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("System is in a state: " + systemState); } //do not attempt to perform remote recovery if this is a virtual NC if (autoFailover && !virtualNC) {
code_review:  MAJOR SonarQube violation: Remove this unused "latestCheckpoint" local variable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1481 
target code: if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Substitute node joining : " + serviceContext.getNodeId()); } updateOnNodeJoin(); } appContext.initialize(initialRun); MessagingProperties messagingProperties = ((IPropertiesProvider) appContext).getMessagingProperties(); messageBroker = new NCMessageBroker(controllerService, messagingProperties); serviceContext.setMessageBroker(messageBroker); MessagingChannelInterfaceFactory interfaceFactory = new MessagingChannelInterfaceFactory((NCMessageBroker) messageBroker, messagingProperties); this.ncServiceCtx.setMessagingChannelInterfaceFactory(interfaceFactory); boolean replicationEnabled = ClusterProperties.INSTANCE.isReplicationEnabled(); boolean autoFailover = ClusterProperties.INSTANCE.isAutoFailoverEnabled(); if (initialRun) { LOGGER.info("System is being initialized. (first run)"); } else { IRecoveryManager recoveryMgr = appContext.getTransactionSubsystem().getRecoveryManager(); systemState = recoveryMgr.getSystemState(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("System is in a state: " + systemState); } //do not attempt to perform remote recovery if this is a virtual NC if (autoFailover && !virtualNC) {
response: if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Substitute node joining : " + serviceContext.getNodeId()); } updateOnNodeJoin(); appContext.initialize(initialRun); MessagingProperties messagingProperties = ((IPropertiesProvider) appContext).getMessagingProperties(); messageBroker = new NCMessageBroker(controllerService, messagingProperties); serviceContext.setMessageBroker(messageBroker); MessagingChannelInterfaceFactory interfaceFactory = new MessagingChannelInterfaceFactory((NCMessageBroker) messageBroker, messagingProperties); serviceContext.setMessagingChannelInterfaceFactory(interfaceFactory); boolean replicationEnabled = ClusterProperties.INSTANCE.isReplicationEnabled(); boolean autoFailover = ClusterProperties.INSTANCE.isAutoFailoverEnabled(); if (initialRun) { LOGGER.info("System is being initialized. (first run)"); } else { IRecoveryManager recoveryMgr = appContext.getTransactionSubsystem().getRecoveryManager(); systemState = recoveryMgr.getSystemState(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("System is in a state: " + systemState); } //do not attempt to perform remote recovery if this is a virtual NC if (autoFailover && !virtualNC) { // Perform remote recovery } }

sample: 840
buggy_code:  if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Substitute node joining : " + serviceContext.getNodeId()); } updateOnNodeJoin(); } appContext.initialize(initialRun); MessagingProperties messagingProperties = ((IPropertiesProvider) appContext).getMessagingProperties(); messageBroker = new NCMessageBroker(controllerService, messagingProperties); serviceContext.setMessageBroker(messageBroker); MessagingChannelInterfaceFactory interfaceFactory = new MessagingChannelInterfaceFactory((NCMessageBroker) messageBroker, messagingProperties); <|startfocus|> serviceContext.setMessagingChannelInterfaceFactory(interfaceFactory); <|endfocus|> boolean replicationEnabled = ClusterProperties.INSTANCE.isReplicationEnabled(); boolean autoFailover = ClusterProperties.INSTANCE.isAutoFailoverEnabled(); if (initialRun) { LOGGER.info("System is being initialized. (first run)"); } else { IRecoveryManager recoveryMgr = appContext.getTransactionSubsystem().getRecoveryManager(); systemState = recoveryMgr.getSystemState(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("System is in a state: " + systemState); } //do not attempt to perform remote recovery if this is a virtual NC if (autoFailover && !virtualNC) {
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "latestCheckpoint". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Substitute node joining : " + serviceContext.getNodeId()); } updateOnNodeJoin(); } appContext.initialize(initialRun); MessagingProperties messagingProperties = ((IPropertiesProvider) appContext).getMessagingProperties(); messageBroker = new NCMessageBroker(controllerService, messagingProperties); serviceContext.setMessageBroker(messageBroker); MessagingChannelInterfaceFactory interfaceFactory = new MessagingChannelInterfaceFactory((NCMessageBroker) messageBroker, messagingProperties); this.ncServiceCtx.setMessagingChannelInterfaceFactory(interfaceFactory); boolean replicationEnabled = ClusterProperties.INSTANCE.isReplicationEnabled(); boolean autoFailover = ClusterProperties.INSTANCE.isAutoFailoverEnabled(); if (initialRun) { LOGGER.info("System is being initialized. (first run)"); } else { IRecoveryManager recoveryMgr = appContext.getTransactionSubsystem().getRecoveryManager(); systemState = recoveryMgr.getSystemState(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("System is in a state: " + systemState); } //do not attempt to perform remote recovery if this is a virtual NC if (autoFailover && !virtualNC) {
response: if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Substitute node joining : " + serviceContext.getNodeId()); } updateOnNodeJoin(); appContext.initialize(initialRun); MessagingProperties messagingProperties = ((IPropertiesProvider) appContext).getMessagingProperties(); messageBroker = new NCMessageBroker(controllerService, messagingProperties); serviceContext.setMessageBroker(messageBroker); MessagingChannelInterfaceFactory interfaceFactory = new MessagingChannelInterfaceFactory((NCMessageBroker) messageBroker, messagingProperties); serviceContext.setMessagingChannelInterfaceFactory(interfaceFactory); boolean replicationEnabled = ClusterProperties.INSTANCE.isReplicationEnabled(); boolean autoFailover = ClusterProperties.INSTANCE.isAutoFailoverEnabled(); if (initialRun) { LOGGER.info("System is being initialized. (first run)"); } else { IRecoveryManager recoveryMgr = appContext.getTransactionSubsystem().getRecoveryManager(); systemState = recoveryMgr.getSystemState(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("System is in a state: " + systemState); } //do not attempt to perform remote recovery if this is a virtual NC if (autoFailover && !virtualNC) { latestCheckpoint = recoveryMgr.getLatestCheckpoint(); } }

sample: 841
buggy_code:  int n = subplans.size(); AlgebricksPipeline[] result = new AlgebricksPipeline[n]; for (int i = 0; i < n; i++) { List<AlgebricksPipeline> subplanOps = subplans.get(i); if (subplanOps.size() != 1) { throw new AlgebricksException("Attempting to construct a nested plan with " + subplanOps.size() + " operator descriptors. Currently, nested plans can only consist in linear pipelines of " <|startfocus|> + "Asterix micro operators."); <|endfocus|> } result[i] = subplanOps.get(0); } return result; } protected List<List<AlgebricksPipeline>> compileSubplansImpl(IOperatorSchema outerPlanSchema, AbstractOperatorWithNestedPlans npOp, IOperatorSchema opSchema, JobGenContext context) throws AlgebricksException { List<List<AlgebricksPipeline>> subplans = new ArrayList<>(npOp.getNestedPlans().size()); PlanCompiler pc = new PlanCompiler(context); for (ILogicalPlan p : npOp.getNestedPlans()) { subplans.add(buildPipelineWithProjection(p, outerPlanSchema, npOp, opSchema, pc)); } return subplans; } 
code_review:  Just remove "Asterix" here (it's part of Algebricks anyway ...). 
target code: int n = subplans.size(); AlgebricksPipeline[] result = new AlgebricksPipeline[n]; for (int i = 0; i < n; i++) { List<AlgebricksPipeline> subplanOps = subplans.get(i); if (subplanOps.size() != 1) { throw new AlgebricksException("Attempting to construct a nested plan with " + subplanOps.size() + " operator descriptors. Currently, nested plans can only consist in linear pipelines of " + "micro operators."); } result[i] = subplanOps.get(0); } return result; } protected List<List<AlgebricksPipeline>> compileSubplansImpl(IOperatorSchema outerPlanSchema, AbstractOperatorWithNestedPlans npOp, IOperatorSchema opSchema, JobGenContext context) throws AlgebricksException { List<List<AlgebricksPipeline>> subplans = new ArrayList<>(npOp.getNestedPlans().size()); PlanCompiler pc = new PlanCompiler(context); for (ILogicalPlan p : npOp.getNestedPlans()) { subplans.add(buildPipelineWithProjection(p, outerPlanSchema, npOp, opSchema, pc)); } return subplans; }
response: int n = subplans.size(); AlgebricksPipeline[] result = new AlgebricksPipeline[n]; for (int i = 0; i < n; i++) { List<AlgebricksPipeline> subplanOps = subplans.get(i); if (subplanOps.size() != 1) { throw new AlgebricksException("Attempting to construct a nested plan with " + subplanOps.size() + " operator descriptors. Currently, nested plans can only consist in linear pipelines."); } result[i] = subplanOps.get(0); } return result; } protected List<List<AlgebricksPipeline>> compileSubplansImpl(IOperatorSchema outerPlanSchema, AbstractOperatorWithNestedPlans npOp, IOperatorSchema opSchema, JobGenContext context) throws AlgebricksException { List<List<AlgebricksPipeline>> subplans = new ArrayList<>(npOp.getNestedPlans().size()); PlanCompiler pc = new PlanCompiler(context); for (ILogicalPlan p : npOp.getNestedPlans()) { subplans.add(buildPipelineWithProjection(p, outerPlanSchema, npOp, opSchema, pc)); } return subplans; }

sample: 842
buggy_code:  opSchema.addAllVariables(topOpInSubplanScm); Map<OperatorDescriptorId, IOperatorDescriptor> opMap = nestedJob.getOperatorMap(); List<? extends IOperatorDescriptor> metaOps = nestedJob.getMetaOps(); if (opMap.size() != metaOps.size()) { for (IOperatorDescriptor opd : opMap.values()) { if (!(opd instanceof AlgebricksMetaOperatorDescriptor)) { throw new AlgebricksException( <|startfocus|> "Can only generate Hyracks jobs for pipelinable Asterix nested plans, not for " + opd <|endfocus|> .getClass().getName()); } } throw new IllegalStateException(); } List<AlgebricksPipeline> result = new ArrayList<>(metaOps.size()); for (IOperatorDescriptor opd : metaOps) { AlgebricksMetaOperatorDescriptor amod = (AlgebricksMetaOperatorDescriptor) opd; result.add(amod.getPipeline()); } return result; } } 
code_review:  Remove "Asterix" (and Hyracks)? 
target code: opSchema.addAllVariables(topOpInSubplanScm); Map<OperatorDescriptorId, IOperatorDescriptor> opMap = nestedJob.getOperatorMap(); List<? extends IOperatorDescriptor> metaOps = nestedJob.getMetaOps(); if (opMap.size() != metaOps.size()) { for (IOperatorDescriptor opd : opMap.values()) { if (!(opd instanceof AlgebricksMetaOperatorDescriptor)) { throw new AlgebricksException( "Can only generate jobs for pipelinable nested plans, not for " + opd .getClass().getName()); } } throw new IllegalStateException(); } List<AlgebricksPipeline> result = new ArrayList<>(metaOps.size()); for (IOperatorDescriptor opd : metaOps) { AlgebricksMetaOperatorDescriptor amod = (AlgebricksMetaOperatorDescriptor) opd; result.add(amod.getPipeline()); } return result; } }
response: opSchema.addAllVariables(topOpInSubplanScm); Map<OperatorDescriptorId, IOperatorDescriptor> opMap = nestedJob.getOperatorMap(); List<? extends IOperatorDescriptor> metaOps = nestedJob.getMetaOps(); if (opMap.size() != metaOps.size()) { for (IOperatorDescriptor opd : opMap.values()) { if (!(opd instanceof AlgebricksMetaOperatorDescriptor)) { throw new AlgebricksException("Can only generate jobs for pipelinable nested plans, not for " + opd.getClass().getName()); } } throw new IllegalStateException(); } List<AlgebricksPipeline> result = new ArrayList<>(metaOps.size()); for (IOperatorDescriptor opd : metaOps) { AlgebricksMetaOperatorDescriptor amod = (AlgebricksMetaOperatorDescriptor) opd; result.add(amod.getPipeline()); } return result;

sample: 843
buggy_code:  Map<OperatorDescriptorId, IOperatorDescriptor> opMap = nestedJob.getOperatorMap(); List<? extends IOperatorDescriptor> metaOps = nestedJob.getMetaOps(); if (opMap.size() != metaOps.size()) { for (IOperatorDescriptor opd : opMap.values()) { if (!(opd instanceof AlgebricksMetaOperatorDescriptor)) { throw new AlgebricksException( "Can only generate Hyracks jobs for pipelinable Asterix nested plans, not for " + opd .getClass().getName()); } } <|startfocus|> throw new IllegalStateException(); <|endfocus|> } List<AlgebricksPipeline> result = new ArrayList<>(metaOps.size()); for (IOperatorDescriptor opd : metaOps) { AlgebricksMetaOperatorDescriptor amod = (AlgebricksMetaOperatorDescriptor) opd; result.add(amod.getPipeline()); } return result; } } 
code_review:  It seems that there is no way to leave this branch alive. Do the earlier checks help to identify errors? Should we add a message to this exception? 
target code: Map<OperatorDescriptorId, IOperatorDescriptor> opMap = nestedJob.getOperatorMap(); List<? extends IOperatorDescriptor> metaOps = nestedJob.getMetaOps(); if (opMap.size() != metaOps.size()) { for (IOperatorDescriptor opd : opMap.values()) { if (!(opd instanceof AlgebricksMetaOperatorDescriptor)) { throw new AlgebricksException( "Can only generate Hyracks jobs for pipelinable Asterix nested plans, not for " + opd .getClass().getName()); } } throw new IllegalStateException("Unexpected nested plan"); } List<AlgebricksPipeline> result = new ArrayList<>(metaOps.size()); for (IOperatorDescriptor opd : metaOps) { AlgebricksMetaOperatorDescriptor amod = (AlgebricksMetaOperatorDescriptor) opd; result.add(amod.getPipeline()); } return result; } }
response: Map<OperatorDescriptorId, IOperatorDescriptor> opMap = nestedJob.getOperatorMap(); List<? extends IOperatorDescriptor> metaOps = nestedJob.getMetaOps(); if (opMap.size() != metaOps.size()) { for (IOperatorDescriptor opd : opMap.values()) { if (!(opd instanceof AlgebricksMetaOperatorDescriptor)) { throw new AlgebricksException("Can only generate Hyracks jobs for pipelinable Asterix nested plans, not for " + opd.getClass().getName()); } } throw new IllegalStateException(); } List<AlgebricksPipeline> result = new ArrayList<>(metaOps.size()); for (IOperatorDescriptor opd : metaOps) { AlgebricksMetaOperatorDescriptor amod = (AlgebricksMetaOperatorDescriptor) opd; result.add(amod.getPipeline()); } return result;

sample: 844
buggy_code:  return true; } @Override public void contributeRuntimeOperator(IHyracksJobBuilder builder, JobGenContext context, ILogicalOperator op, IOperatorSchema opSchema, IOperatorSchema[] inputSchemas, IOperatorSchema outerPlanSchema) throws AlgebricksException { RecordDescriptor recordDescriptor = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), opSchema, context); List<Mutable<ILogicalOperator>> inputs = op.getInputs(); int nInputs = inputs.size(); MicroUnionAllRuntimeFactory runtime = new MicroUnionAllRuntimeFactory(nInputs); builder.contributeMicroOperator(op, runtime, recordDescriptor); <|startfocus|> for (int i = 0; i < nInputs; i++) { ILogicalOperator src = inputs.get(i).getValue(); builder.contributeGraphEdge(src, 0, op, i); } <|endfocus|> } } 
code_review:  Can everything except for these lines be pulled up into AbstractUnionAllPOperator as well? 
target code: return true; } @Override public void contributeRuntimeOperator(IHyracksJobBuilder builder, JobGenContext context, ILogicalOperator op, IOperatorSchema opSchema, IOperatorSchema[] inputSchemas, IOperatorSchema outerPlanSchema) throws AlgebricksException { RecordDescriptor recordDescriptor = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), opSchema, context); List<Mutable<ILogicalOperator>> inputs = op.getInputs(); int nInputs = inputs.size(); MicroUnionAllRuntimeFactory runtime = new MicroUnionAllRuntimeFactory(nInputs); builder.contributeMicroOperator(op, runtime, recordDescriptor); super.contributeRuntimeOperator(builder, context, op, opSchema, inputSchemas, outerPlanSchema); } }
response: final String message); public void raiseError(final String message) throws Exception; public void waitForUserAcknowledgement(final String message); public void appendText(String text); }; public final String TAG = "PowerTestApp"; private final static String RESPONSE_OK = "OK"; private final static String RESPONSE_ERR = "ERR"; public final static String SOCKET_NAME = "/android/cts/powertest"; private static final int BUFFER_SIZE = 4096; private byte[] mBuffer; private LocalServerSocket mServerSocket; private volatile boolean mStopThread; private final SensorManager mSensorManager; private final PowerManager mPowerManager; private final Context mContext; private final Listener mListener; private boolean mConnected = false; public PowerTestHostLink(Context context, final Listener listener) { Log.d(TAG, " +++ Begin of localSocketServer() +++ "); mListener = listener; mBuffer = new byte[BUFFER_SIZE]; mContext = context; try { mServerSocket = new LocalServerSocket(SOCKET_NAME);

sample: 845
buggy_code:  RecordDescriptor pipelineLastRecordDescriptor = pipeline.getRecordDescriptors()[pipeline.getRecordDescriptors().length - 1]; RecordDescriptor outputRecordDescriptor; IFrameWriter outputWriter; if (i == 0) { // primary pipeline outputWriter = new TupleOuterProduct(pipelineLastRecordDescriptor, missingWriters); outputRecordDescriptor = SubplanRuntimeFactory.this.outputRecordDesc; } else { // secondary pipeline IPushRuntime outputPushRuntime = linkSecondaryPipeline(pipeline, pipelineAssemblers, i); if (outputPushRuntime == null) { <|startfocus|> throw new IllegalStateException(); <|endfocus|> } outputPushRuntime.setInputRecordDescriptor(0, pipelineLastRecordDescriptor); outputWriter = outputPushRuntime; outputRecordDescriptor = pipelineLastRecordDescriptor; } PipelineAssembler pa = new PipelineAssembler(pipeline, 1, 1, inputRecordDesc, outputRecordDescriptor); startOfPipelines[i] = (NestedTupleSourceRuntime) pa.assemblePipeline(outputWriter, ctx); pipelineAssemblers[i] = pa; } } IPushRuntime linkSecondaryPipeline(AlgebricksPipeline pipeline, PipelineAssembler[] pipelineAssemblers, int pipelineAssemblersCount) { IPushRuntimeFactory[] outputRuntimeFactories = pipeline.getOutputRuntimeFactories();
code_review:  Add a message? 
target code: RecordDescriptor pipelineLastRecordDescriptor = pipeline.getRecordDescriptors()[pipeline.getRecordDescriptors().length - 1]; RecordDescriptor outputRecordDescriptor; IFrameWriter outputWriter; if (i == 0) { // primary pipeline outputWriter = new TupleOuterProduct(pipelineLastRecordDescriptor, missingWriters); outputRecordDescriptor = SubplanRuntimeFactory.this.outputRecordDesc; } else { // secondary pipeline IPushRuntime outputPushRuntime = linkSecondaryPipeline(pipeline, pipelineAssemblers, i); if (outputPushRuntime == null) { throw new IllegalStateException("Invalid pipeline"); } outputPushRuntime.setInputRecordDescriptor(0, pipelineLastRecordDescriptor); outputWriter = outputPushRuntime; outputRecordDescriptor = pipelineLastRecordDescriptor; } PipelineAssembler pa = new PipelineAssembler(pipeline, 1, 1, inputRecordDesc, outputRecordDescriptor); startOfPipelines[i] = (NestedTupleSourceRuntime) pa.assemblePipeline(outputWriter, ctx); pipelineAssemblers[i] = pa; } } IPushRuntime linkSecondaryPipeline(AlgebricksPipeline pipeline, PipelineAssembler[] pipelineAssemblers, int pipelineAssemblersCount) { IPushRuntimeFactory[] outputRuntimeFactories = pipeline.getOutputRuntimeFactories();
response: RecordDescriptor pipelineLastRecordDescriptor = pipeline.getRecordDescriptors()[pipeline.getRecordDescriptors().length - 1]; RecordDescriptor outputRecordDescriptor; IFrameWriter outputWriter; if (i == 0) { // primary pipeline outputWriter = new TupleOuterProduct(pipelineLastRecordDescriptor, missingWriters); outputRecordDescriptor = SubplanRuntimeFactory.this.outputRecordDesc; } else { // secondary pipeline IPushRuntime outputPushRuntime = linkSecondaryPipeline(pipeline, pipelineAssemblers, i); if (outputPushRuntime == null) { throw new IllegalStateException(); } outputPushRuntime.setInputRecordDescriptor(0, pipelineLastRecordDescriptor); outputWriter = outputPushRuntime; outputRecordDescriptor = pipelineLastRecordDescriptor; } PipelineAssembler pa = new PipelineAssembler(pipeline, 1, 1, inputRecordDesc, outputRecordDescriptor); startOfPipelines[i] = (NestedTupleSourceRuntime) pa.assemblePipeline(outputWriter, ctx); pipelineAssemblers[i] = pa; } IPushRuntime linkSecondaryPipeline(AlgebricksPipeline pipeline, PipelineAssembler[] pipelineAssemblers, int pipelineAssemblersCount) { IPushRuntimeFactory[] outputRuntimeFactories = pipeline.getOutputRuntimeFactories();

sample: 846
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 847
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 848
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 849
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 850
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 851
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 852
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>>>=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 853
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>>>=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 854
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 855
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: 'if' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 856
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '{' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 857
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 858
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '}' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 859
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} <|startfocus|> if(n>0xff){n>>>=8;log|=8;} <|endfocus|> if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "n". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if (n > 0xff) { n >>>= 8; log |= 8; } if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 860
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 861
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 862
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>>>=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 863
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>>>=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 864
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 865
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '{' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 866
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 867
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '|=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 868
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '|=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 869
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '}' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 870
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} <|startfocus|> if(n>0xf){n>>>=4;log|=4;} <|endfocus|> if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "n". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if (n > 0xf) { n >>>= 4; log |= 4; } if(n>0b11){n>>>=2;log|=2;} return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 871
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 872
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 873
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>>>=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 874
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '>>>=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 875
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 876
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '{' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 877
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 878
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '|=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 879
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '|=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 880
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: '}' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 881
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} <|startfocus|> if(n>0b11){n>>>=2;log|=2;} <|endfocus|> return log+(n>>>1);
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "n". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if (n > 3) { n >>>= 2; log |= 2; } return log+(n>>>1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } int temp = n; if (temp > 0b11) { temp >>>= 2; log |= 2; } return log + (temp >>> 1); }

sample: 882
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '>' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 883
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '>' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 884
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '>>>=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 885
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '>>>=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 886
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 887
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '{' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 888
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 889
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '|=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 890
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '|=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 891
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '}' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 892
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "n". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 893
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '+' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 894
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '+' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 895
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '>>>' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 896
buggy_code:  public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} <|startfocus|> return log+(n>>>1); <|endfocus|>
code_review:  MAJOR SonarQube violation: '>>>' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around 
target code: public static int log2Floor(int n) { assert n>=1;int log=0;if(n>0xffff){n>>>=16;log=16;} if(n>0xff){n>>>=8;log|=8;} if(n>0xf){n>>>=4;log|=4;} if(n>0b11){n>>>=2;log|=2;} return log + (n >>> 1);
response: public static int log2Floor(int n) { assert n >= 1; int log = 0; if (n > 0xffff) { n >>>= 16; log = 16; } if (n > 0xff) { n >>>= 8; log |= 8; } if (n > 0xf) { n >>>= 4; log |= 4; } if (n > 0b11) { n >>>= 2; log |= 2; } return log + (n >>> 1); }

sample: 897
buggy_code:  public Ini toIni(boolean includeDefaults) { Ini ini = new Ini(); (includeDefaults ? configurationMap : definedMap).forEach((option, value) -> { if (value != null) { ini.add(option.section().sectionName(), option.ini(), option.type().serializeToIni(value)); } }); <|startfocus|> getSections().forEach((section -> { ini.add(section.sectionName()); })); <|endfocus|> nodeSpecificMap.forEach((key, nodeValueMap) -> { String section = Section.NC.sectionName() + "/" + key; synchronized (nodeValueMap) { for (Map.Entry<IOption, Object> entry : nodeValueMap.entrySet()) { if (entry.getValue() != null) { final IOption option = entry.getKey(); ini.add(section, option.ini(), option.type().serializeToIni(entry.getValue())); } } } }); extensionOptions.forEach((extension, options) -> { options.forEach(option -> ini .add(extension, option.getKey(), option.getValue())); }); return ini;
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public Ini toIni(boolean includeDefaults) { Ini ini = new Ini(); (includeDefaults ? configurationMap : definedMap).forEach((option, value) -> { if (value != null) { ini.add(option.section().sectionName(), option.ini(), option.type().serializeToIni(value)); } }); nodeSpecificMap.forEach((key, nodeValueMap) -> { String section = Section.NC.sectionName() + "/" + key; synchronized (nodeValueMap) { for (Map.Entry<IOption, Object> entry : nodeValueMap.entrySet()) { if (entry.getValue() != null) { final IOption option = entry.getKey(); ini.add(section, option.ini(), option.type().serializeToIni(entry.getValue())); } } } }); extensionOptions.forEach((extension, options) -> { options.forEach(option -> ini .add(extension, option.getKey(), option.getValue())); }); return ini;
response: public Ini toIni(boolean includeDefaults) { Ini ini = new Ini(); (includeDefaults ? configurationMap : definedMap).forEach((option, value) -> { if (value != null) { ini.add(option.section().sectionName(), option.ini(), option.type().serializeToIni(value)); } }); getSections().forEach(section -> { ini.add(section.sectionName()); }); nodeSpecificMap.forEach((key, nodeValueMap) -> { String section = Section.NC.sectionName() + "/" + key; synchronized (nodeValueMap) { for (Map.Entry<IOption, Object> entry : nodeValueMap.entrySet()) { if (entry.getValue() != null) { final IOption option = entry.getKey(); ini.add(section, option.ini(), option.type().serializeToIni(entry.getValue())); } } } }); extensionOptions.forEach((extension, options) -> { options.forEach(option -> ini.add(extension, option.getKey(), option.getValue())); }); return ini; }

sample: 898
buggy_code:  public void sendApplicationMessageToCC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; public void registerResultPartitionLocation(JobId jobId, ResultSetId rsId, boolean orderedResult, boolean emptyResult, int partition, int nPartitions, NetworkAddress networkAddress) throws Exception; public void reportResultPartitionWriteCompletion(JobId jobId, ResultSetId rsId, int partition) throws Exception; public void reportResultPartitionFailure(JobId jobId, ResultSetId rsId, int partition, HyracksDataException cause) throws Exception; public void getNodeControllerInfos() throws Exception; <|startfocus|> public void notifyThreadDump(String nodeId, String requestId, String threadDumpJSON) throws Exception; <|endfocus|> } 
code_review:  CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 
target code: public void sendApplicationMessageToCC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; public void registerResultPartitionLocation(JobId jobId, ResultSetId rsId, boolean orderedResult, boolean emptyResult, int partition, int nPartitions, NetworkAddress networkAddress) throws Exception; public void reportResultPartitionWriteCompletion(JobId jobId, ResultSetId rsId, int partition) throws Exception; public void reportResultPartitionFailure(JobId jobId, ResultSetId rsId, int partition, HyracksDataException cause) throws Exception; public void getNodeControllerInfos() throws Exception; public void notifyThreadDump(String nodeId, String threadDumpJSON) throws Exception; }
response: public void sendApplicationMessageToCC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; public void registerResultPartitionLocation(JobId jobId, ResultSetId rsId, boolean orderedResult, boolean emptyResult, int partition, int nPartitions, NetworkAddress networkAddress) throws Exception; public void reportResultPartitionWriteCompletion(JobId jobId, ResultSetId rsId, int partition) throws Exception; public void reportResultPartitionFailure(JobId jobId, ResultSetId rsId, int partition, HyracksDataException cause) throws Exception; public void getNodeControllerInfos() throws Exception; public void notifyThreadDump(String nodeId, String requestId, String threadDumpJSON) throws Exception;

sample: 899
buggy_code:  List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags, Map<String, byte[]> contextRuntTimeVarMap) throws Exception; public void abortTasks(JobId jobId, List<TaskAttemptId> tasks) throws Exception; public void cleanUpJoblet(JobId jobId, JobStatus status) throws Exception; public void reportPartitionAvailability(PartitionId pid, NetworkAddress networkAddress) throws Exception; public void deployBinary(DeploymentId deploymentId, List<URL> url) throws Exception; public void undeployBinary(DeploymentId deploymentId) throws Exception; <|startfocus|> public void distributeJob(JobId jobId, byte[] planBytes) throws Exception; public void destroyJob(JobId jobId) throws Exception; <|endfocus|> public void dumpState(String stateDumpId) throws Exception; public void shutdown(boolean terminateNCService) throws Exception; public void sendApplicationMessageToNC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; public void takeThreadDump(String requestId) throws Exception; } 
code_review:  CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 
target code: List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags, Map<String, byte[]> contextRuntTimeVarMap) throws Exception; public void abortTasks(JobId jobId, List<TaskAttemptId> tasks) throws Exception; public void cleanUpJoblet(JobId jobId, JobStatus status) throws Exception; public void reportPartitionAvailability(PartitionId pid, NetworkAddress networkAddress) throws Exception; public void deployBinary(DeploymentId deploymentId, List<URL> url) throws Exception; public void undeployBinary(DeploymentId deploymentId) throws Exception; public void dumpState(String stateDumpId) throws Exception; public void shutdown(boolean terminateNCService) throws Exception; public void sendApplicationMessageToNC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; public void takeThreadDump(String requestId) throws Exception; }
response: List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags, Map<String, byte[]> contextRuntTimeVarMap) throws Exception; public void abortTasks(JobId jobId, List<TaskAttemptId> tasks) throws Exception; public void cleanUpJoblet(JobId jobId, JobStatus status) throws Exception; public void reportPartitionAvailability(PartitionId pid, NetworkAddress networkAddress) throws Exception; public void deployBinary(DeploymentId deploymentId, List<URL> url) throws Exception; public void undeployBinary(DeploymentId deploymentId) throws Exception; public void distributeJob(JobId jobId, byte[] planBytes) throws Exception; public void destroyJob(JobId jobId) throws Exception; public void dumpState(String stateDumpId) throws Exception; public void shutdown(boolean terminateNCService) throws Exception; public void sendApplicationMessageToNC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; public void takeThreadDump(String requestId) throws Exception;

sample: 900
buggy_code:  throws HyracksDataException { this.ctx = ctx; this.treeIndexHelper = indexHelperFactory.create(ctx.getJobletContext().getServiceContext(), partition); this.searchCallbackFactory = searchCallbackFactory; } @Override public void initialize() throws HyracksDataException { treeIndexHelper.open(); try { try { writer.open(); FrameTupleAppender appender = new FrameTupleAppender(new VSizeFrame(ctx)); scan(appender); appender.write(writer, true); } catch (Throwable th) { writer.fail(); <|startfocus|> throw HyracksDataException.create(th); } finally { <|endfocus|> writer.close(); } } catch (Throwable th) { throw HyracksDataException.create(th); } } private void scan(FrameTupleAppender appender) throws IOException { ITreeIndex treeIndex = (ITreeIndex) treeIndexHelper.getIndexInstance(); LocalResource resource = treeIndexHelper.getResource(); ISearchOperationCallback searchCallback = searchCallbackFactory.createSearchOperationCallback(resource.getId(), ctx, null); IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback); ITreeIndexAccessor indexAccessor = (ITreeIndexAccessor) treeIndex.createAccessor(iap); try {
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: throws HyracksDataException { this.ctx = ctx; this.treeIndexHelper = indexHelperFactory.create(ctx.getJobletContext().getServiceContext(), partition); this.searchCallbackFactory = searchCallbackFactory; } @Override public void initialize() throws HyracksDataException { treeIndexHelper.open(); try { try { writer.open(); FrameTupleAppender appender = new FrameTupleAppender(new VSizeFrame(ctx)); scan(appender); appender.write(writer, true); } catch (Throwable th) { writer.fail(); } catch (Throwable failFailure) {// NOSONAR: Must maintain all stacks failure = ExceptionUtils.suppress(failure, failFailure); } } finally { try { writer.close(); } } catch (Throwable th) { throw HyracksDataException.create(th); } } private void scan(FrameTupleAppender appender) throws IOException { ITreeIndex treeIndex = (ITreeIndex) treeIndexHelper.getIndexInstance(); LocalResource resource = treeIndexHelper.getResource(); ISearchOperationCallback searchCallback = searchCallbackFactory.createSearchOperationCallback(resource.getId(), ctx, null); IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback); ITreeIndexAccessor indexAccessor = (ITreeIndexAccessor) treeIndex.createAccessor(iap); try {
response: throws HyracksDataException { this.ctx = ctx; this.treeIndexHelper = indexHelperFactory.create(ctx.getJobletContext().getServiceContext(), partition); this.searchCallbackFactory = searchCallbackFactory; } @Override public void initialize() throws HyracksDataException { treeIndexHelper.open(); try { try { writer.open(); FrameTupleAppender appender = new FrameTupleAppender(new VSizeFrame(ctx)); scan(appender); appender.write(writer, true); } catch (Throwable th) { writer.fail(); throw HyracksDataException.create(th); } finally { writer.close(); } } catch (Throwable th) { throw HyracksDataException.create(th); } } private void scan(FrameTupleAppender appender) throws IOException { ITreeIndex treeIndex = (ITreeIndex) treeIndexHelper.getIndexInstance(); LocalResource resource = treeIndexHelper.getResource(); ISearchOperationCallback searchCallback = searchCallbackFactory.createSearchOperationCallback(resource.getId(), ctx, null); IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback); ITreeIndexAccessor indexAccessor = (ITreeIndexAccessor) treeIndex.createAccessor(iap); try { // code for scanning the index and appending tuples to the appender } catch (IOException e) { throw e; } }

sample: 901
buggy_code:  this.searchCallbackFactory = searchCallbackFactory; } @Override public void initialize() throws HyracksDataException { treeIndexHelper.open(); try { try { writer.open(); FrameTupleAppender appender = new FrameTupleAppender(new VSizeFrame(ctx)); scan(appender); appender.write(writer, true); } catch (Throwable th) { writer.fail(); throw HyracksDataException.create(th); } finally { writer.close(); } <|startfocus|> } catch (Throwable th) { throw HyracksDataException.create(th); <|endfocus|> } } private void scan(FrameTupleAppender appender) throws IOException { ITreeIndex treeIndex = (ITreeIndex) treeIndexHelper.getIndexInstance(); LocalResource resource = treeIndexHelper.getResource(); ISearchOperationCallback searchCallback = searchCallbackFactory.createSearchOperationCallback(resource.getId(), ctx, null); IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback); ITreeIndexAccessor indexAccessor = (ITreeIndexAccessor) treeIndex.createAccessor(iap); try { doScan(treeIndex, indexAccessor, appender); } finally { indexAccessor.destroy(); } } 
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: this.searchCallbackFactory = searchCallbackFactory; } @Override public void initialize() throws HyracksDataException { treeIndexHelper.open(); try { try { writer.open(); FrameTupleAppender appender = new FrameTupleAppender(new VSizeFrame(ctx)); scan(appender); appender.write(writer, true); } catch (Throwable th) { writer.fail(); throw HyracksDataException.create(th); } finally { writer.close(); } } } private void scan(FrameTupleAppender appender) throws IOException { ITreeIndex treeIndex = (ITreeIndex) treeIndexHelper.getIndexInstance(); LocalResource resource = treeIndexHelper.getResource(); ISearchOperationCallback searchCallback = searchCallbackFactory.createSearchOperationCallback(resource.getId(), ctx, null); IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback); ITreeIndexAccessor indexAccessor = (ITreeIndexAccessor) treeIndex.createAccessor(iap); try { doScan(treeIndex, indexAccessor, appender); } finally { indexAccessor.destroy(); } }
response: this.searchCallbackFactory = searchCallbackFactory; @Override public void initialize() throws HyracksDataException { treeIndexHelper.open(); try { try { writer.open(); FrameTupleAppender appender = new FrameTupleAppender(new VSizeFrame(ctx)); scan(appender); appender.write(writer, true); } catch (Throwable th) { writer.fail(); throw HyracksDataException.create(th); } finally { writer.close(); } } catch (Throwable th) { throw HyracksDataException.create(th); } } private void scan(FrameTupleAppender appender) throws IOException { ITreeIndex treeIndex = (ITreeIndex) treeIndexHelper.getIndexInstance(); LocalResource resource = treeIndexHelper.getResource(); ISearchOperationCallback searchCallback = searchCallbackFactory.createSearchOperationCallback(resource.getId(), ctx, null); IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback); ITreeIndexAccessor indexAccessor = (ITreeIndexAccessor) treeIndex.createAccessor(iap); try { doScan(treeIndex, indexAccessor, appender); } finally { indexAccessor.destroy(); } }

sample: 902
buggy_code:  for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { filterTuples.add(mergeOp.getMergingComponents().get(i).getLSMComponentFilter().getMinTuple()); filterTuples.add(mergeOp.getMergingComponents().get(i).getLSMComponentFilter().getMaxTuple()); } getFilterManager().updateFilter(mergedComponent.getLSMComponentFilter(), filterTuples); getFilterManager().writeFilter(mergedComponent.getLSMComponentFilter(), mergedComponent.getMetadataHolder()); } componentBulkLoader.end(); return mergedComponent; } @Override public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { <|startfocus|> return new LSMRTreeAccessor(getLsmHarness(), <|endfocus|> createOpContext(iap.getModificationCallback(), iap.getSearchOperationCallback()), buddyBTreeFields); } // This function is modified for R-Trees without antimatter tuples to allow buddy B-Tree to have only primary keys @Override public void modify(IIndexOperationContext ictx, ITupleReference tuple) throws HyracksDataException { LSMRTreeOpContext ctx = (LSMRTreeOpContext) ictx; if (ctx.getOperation() == IndexOperation.PHYSICALDELETE) {
code_review:  MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 
target code: for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { filterTuples.add(mergeOp.getMergingComponents().get(i).getLSMComponentFilter().getMinTuple()); filterTuples.add(mergeOp.getMergingComponents().get(i).getLSMComponentFilter().getMaxTuple()); } getFilterManager().updateFilter(mergedComponent.getLSMComponentFilter(), filterTuples); getFilterManager().writeFilter(mergedComponent.getLSMComponentFilter(), mergedComponent.getMetadataHolder()); } componentBulkLoader.end(); return mergedComponent; } @Override public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { return new LSMRTreeAccessor(getHarness(), createOpContext(iap.getModificationCallback(), iap.getSearchOperationCallback()), buddyBTreeFields); } // This function is modified for R-Trees without antimatter tuples to allow buddy B-Tree to have only primary keys @Override public void modify(IIndexOperationContext ictx, ITupleReference tuple) throws HyracksDataException { LSMRTreeOpContext ctx = (LSMRTreeOpContext) ictx; if (ctx.getOperation() == IndexOperation.PHYSICALDELETE) {
response: for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { filterTuples.add(mergeOp.getMergingComponents().get(i).getLSMComponentFilter().getMinTuple()); filterTuples.add(mergeOp.getMergingComponents().get(i).getLSMComponentFilter().getMaxTuple()); } getFilterManager().updateFilter(mergedComponent.getLSMComponentFilter(), filterTuples); getFilterManager().writeFilter(mergedComponent.getLSMComponentFilter(), mergedComponent.getMetadataHolder()); componentBulkLoader.end(); return mergedComponent; } @Override public ILSMIndexAccessor createAccessor(IIndexAccessParameters iap) { return new LSMRTreeAccessor(getLsmHarness(), createOpContext(iap.getModificationCallback(), iap.getSearchOperationCallback()), buddyBTreeFields); } @Override public void modify(IIndexOperationContext ictx, ITupleReference tuple) throws HyracksDataException { LSMRTreeOpContext ctx = (LSMRTreeOpContext) ictx; if (ctx.getOperation() == IndexOperation.PHYSICALDELETE) { ctx.getRTree().delete(tuple); } else { ctx.getRTree().upsert(tuple); } }

sample: 903
buggy_code:  public void resetNonIndexFieldsTuple(ITupleReference newValue) { tupleWithNonIndexFields.reset(newValue); } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; HyracksDataException failure = null; try { accessor.destroy(); } catch (HyracksDataException e) { failure = e; } finally { try { if (cursor != null) { cursor.destroy(); } } catch (Exception e) { throw HyracksDataException.suppress(failure, e); } <|startfocus|> } <|endfocus|> } } 
code_review:  BLOCKER SonarQube violation: Remove this throw statement from this finally block. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1143 
target code: public void resetNonIndexFieldsTuple(ITupleReference newValue) { tupleWithNonIndexFields.reset(newValue); } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; HyracksDataException failure = null; try { accessor.destroy(); } catch (HyracksDataException e) { failure = e; } finally { try { if (cursor != null) { cursor.destroy(); } } catch (Exception e) { throw HyracksDataException.suppress(failure, e); } } if (failure != null) { throw HyracksDataException.create(failure); } } }
response: public void resetNonIndexFieldsTuple(ITupleReference newValue) { tupleWithNonIndexFields.reset(newValue); } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; HyracksDataException failure = null; try { accessor.destroy(); } catch (HyracksDataException e) { failure = e; } finally { try { if (cursor != null) { cursor.destroy(); } } catch (Exception e) { throw HyracksDataException.suppress(failure, e); } } }

sample: 904
buggy_code:  public void resetNonIndexFieldsTuple(ITupleReference newValue) { tupleWithNonIndexFields.reset(newValue); } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; HyracksDataException failure = null; try { accessor.destroy(); } catch (HyracksDataException e) { failure = e; } finally { try { if (cursor != null) { cursor.destroy(); } } catch (Exception e) { throw HyracksDataException.suppress(failure, e); } <|startfocus|> } <|endfocus|> } } 
code_review:  CRITICAL SonarQube violation: Refactor this code to not throw exceptions in finally blocks. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1163 
target code: public void resetNonIndexFieldsTuple(ITupleReference newValue) { tupleWithNonIndexFields.reset(newValue); } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; HyracksDataException failure = null; try { accessor.destroy(); } catch (HyracksDataException e) { failure = e; } finally { try { if (cursor != null) { cursor.destroy(); } } catch (Exception e) { throw HyracksDataException.suppress(failure, e); } } if (failure != null) { throw HyracksDataException.create(failure); } } }
response: public void resetNonIndexFieldsTuple(ITupleReference newValue) { tupleWithNonIndexFields.reset(newValue); } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; HyracksDataException failure = null; try { accessor.destroy(); } catch (HyracksDataException e) { failure = e; } finally { try { if (cursor != null) { cursor.destroy(); } } catch (Exception e) { throw HyracksDataException.suppress(failure, e); } } }

sample: 905
buggy_code:  builder.addField(diskTuple.getFieldData(i), diskTuple.getFieldStart(i), diskTuple.getFieldLength(i)); } } @Override public ITupleReference doGetTuple() { return outputTuple; } @Override public void doDestroy() throws HyracksDataException { Throwable failure = null; if (lsmHarness != null) { if (rangeCursors != null) { for (int i = 0; i < rangeCursors.length; i++) { try { rangeCursors[i].destroy(); <|startfocus|> } catch (Throwable th) { <|endfocus|> failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } 
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: builder.addField(diskTuple.getFieldData(i), diskTuple.getFieldStart(i), diskTuple.getFieldLength(i)); } } @Override public ITupleReference doGetTuple() { return outputTuple; } @Override public void doDestroy() throws HyracksDataException { Throwable failure = null; if (lsmHarness != null) { if (rangeCursors != null) { for (int i = 0; i < rangeCursors.length; i++) { try { rangeCursors[i].destroy(); } catch (Throwable th) { // NOSONAR. Must destroy all cursors failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } }
response: builder.addField(diskTuple.getFieldData(i), diskTuple.getFieldStart(i), diskTuple.getFieldLength(i)); } @Override public ITupleReference doGetTuple() { return outputTuple; } @Override public void doDestroy() throws HyracksDataException { Throwable failure = null; if (lsmHarness != null) { if (rangeCursors != null) { for (int i = 0; i < rangeCursors.length; i++) { try { rangeCursors[i].destroy(); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } }

sample: 906
buggy_code:  } @Override public void doDestroy() throws HyracksDataException { Throwable failure = null; if (lsmHarness != null) { if (rangeCursors != null) { for (int i = 0; i < rangeCursors.length; i++) { try { rangeCursors[i].destroy(); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); <|startfocus|> } catch (Throwable th) { <|endfocus|> failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } private class PriorityQueueScanComparator extends PriorityQueueComparator { public PriorityQueueScanComparator(MultiComparator cmp) { super(cmp); } @Override
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: } @Override public void doDestroy() throws HyracksDataException { Throwable failure = null; if (lsmHarness != null) { if (rangeCursors != null) { for (int i = 0; i < rangeCursors.length; i++) { try { rangeCursors[i].destroy(); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { // NOSONAR. Don't lose the root cause failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } private class PriorityQueueScanComparator extends PriorityQueueComparator { public PriorityQueueScanComparator(MultiComparator cmp) { super(cmp); } @Override
response: @Override public void doDestroy() throws HyracksDataException { Throwable failure = null; if (lsmHarness != null) { if (rangeCursors != null) { for (int i = 0; i < rangeCursors.length; i++) { try { rangeCursors[i].destroy(); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } private class PriorityQueueScanComparator extends PriorityQueueComparator { public PriorityQueueScanComparator(MultiComparator cmp) { super(cmp); } @Override public int compare(FrameTupleAccessor accessor, int t1, int t2) { try { return super.compare(accessor, t1, t2); } catch (Exception e) { throw new HyracksDataException(e); } } }

sample: 907
buggy_code:  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.lsm.common.util; import org.apache.hyracks.storage.am.common.api.IIndexOperationContext; import org.apache.hyracks.storage.common.IIndexAccessor; import org.apache.hyracks.storage.common.IIndexCursor; public class DestroyUtils { <|startfocus|> <|endfocus|> public static <T extends IIndexOperationContext> Throwable destroy(T[] contexts) { Throwable failure = null; for (int i = 0; i < contexts.length; i++) { if (contexts[i] != null) { try { contexts[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null;
code_review:  MAJOR SonarQube violation: Add a private constructor to hide the implicit public one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1118 
target code: * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.lsm.common.util; import org.apache.hyracks.storage.am.common.api.IIndexOperationContext; import org.apache.hyracks.storage.common.IIndexAccessor; import org.apache.hyracks.storage.common.IIndexCursor; public class DestroyUtils { private DestroyUtils() { } public static <T extends IIndexOperationContext> Throwable destroy(T[] contexts) { Throwable failure = null; for (int i = 0; i < contexts.length; i++) { if (contexts[i] != null) { try { contexts[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null;
response: package org.apache.hyracks.storage.am.lsm.common.util; import org.apache.hyracks.storage.am.common.api.IIndexOperationContext; import org.apache.hyracks.storage.common.IIndexAccessor; import org.apache.hyracks.storage.common.IIndexCursor; public class DestroyUtils { private DestroyUtils() { throw new AssertionError("This util class should not be initialized."); } public static <T extends IIndexOperationContext> Throwable destroy(T[] contexts) { Throwable failure = null; for (int i = 0; i < contexts.length; i++) { if (contexts[i] != null) { try { contexts[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } }

sample: 908
buggy_code: package org.apache.hyracks.storage.am.lsm.common.util; import org.apache.hyracks.storage.am.common.api.IIndexOperationContext; import org.apache.hyracks.storage.common.IIndexAccessor; import org.apache.hyracks.storage.common.IIndexCursor; public class DestroyUtils { public static <T extends IIndexOperationContext> Throwable destroy(T[] contexts) { Throwable failure = null; for (int i = 0; i < contexts.length; i++) { if (contexts[i] != null) { try { contexts[i].destroy(); <|startfocus|> } catch (Throwable th) { <|endfocus|> if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th;
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: package org.apache.hyracks.storage.am.lsm.common.util; import org.apache.hyracks.storage.am.common.api.IIndexOperationContext; import org.apache.hyracks.storage.common.IIndexAccessor; import org.apache.hyracks.storage.common.IIndexCursor; public class DestroyUtils { public static <T extends IIndexOperationContext> Throwable destroy(T[] contexts) { Throwable failure = null; for (int i = 0; i < contexts.length; i++) { if (contexts[i] != null) { try { contexts[i].destroy(); } catch (Throwable th) { // NOSONAR must destroy all if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th;
response: package org.apache.hyracks.storage.am.lsm.common.util; import org.apache.hyracks.storage.am.common.api.IIndexOperationContext; import org.apache.hyracks.storage.common.IIndexAccessor; import org.apache.hyracks.storage.common.IIndexCursor; public class DestroyUtils { public static <T extends IIndexOperationContext> Throwable destroy(T[] contexts) { Throwable failure = null; for (int i = 0; i < contexts.length; i++) { if (contexts[i] != null) { try { contexts[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } }

sample: 909
buggy_code:  } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); <|startfocus|> } catch (Throwable th) { <|endfocus|> if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexCursor> Throwable destroy(T[] cursors) { Throwable failure = null; for (int i = 0; i < cursors.length; i++) { if (cursors[i] != null) { try { cursors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else {
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); } catch (Throwable th) { // NOSONAR must destroy all if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexCursor> Throwable destroy(T[] cursors) { Throwable failure = null; for (int i = 0; i < cursors.length; i++) { if (cursors[i] != null) { try { cursors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else {
response: } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } return failure; } public static <T extends IIndexAccessor> Throwable destroy(T[] accessors) { Throwable failure = null; for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { try { accessors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexCursor> Throwable destroy(T[] cursors) { Throwable failure = null; for (int i = 0; i < cursors.length; i++) { if (cursors[i] != null) { try { cursors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; }

sample: 910
buggy_code:  } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexCursor> Throwable destroy(T[] cursors) { Throwable failure = null; for (int i = 0; i < cursors.length; i++) { if (cursors[i] != null) { try { cursors[i].destroy(); <|startfocus|> } catch (Throwable th) { <|endfocus|> if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } } 
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } public static <T extends IIndexCursor> Throwable destroy(T[] cursors) { Throwable failure = null; for (int i = 0; i < cursors.length; i++) { if (cursors[i] != null) { try { cursors[i].destroy(); } catch (Throwable th) { // NOSONAR must destroy all if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; } }
response: } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } return failure; } public static <T extends IIndexCursor> Throwable destroy(T[] cursors) { Throwable failure = null; for (int i = 0; i < cursors.length; i++) { if (cursors[i] != null) { try { cursors[i].destroy(); } catch (Throwable th) { if (failure == null) { failure = th; } else { failure.addSuppressed(th); } } } } return failure; }

sample: 911
buggy_code:  boolean abort = true; try { try { ISearchPredicate rtreeSearchPred = new SearchPredicate(null, null); ILSMIndexOperationContext opCtx = ((LSMRTreeSortedCursor) cursor).getOpCtx(); search(opCtx, cursor, rtreeSearchPred); try { mergedComponent = createDiskComponent(componentFactory, mergeOp.getTarget(), mergeOp.getBTreeTarget(), mergeOp.getBloomFilterTarget(), true); <|startfocus|> // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the r-trees so that <|endfocus|> // lsmHarness.endSearch() is called once when the r-trees have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component is not included in the merge operation long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMRTreeDiskComponent) mergeOp.getMergingComponents().get(i))
code_review:  MAJOR SonarQube violation: Split this 130 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: boolean abort = true; try { try { ISearchPredicate rtreeSearchPred = new SearchPredicate(null, null); ILSMIndexOperationContext opCtx = ((LSMRTreeSortedCursor) cursor).getOpCtx(); search(opCtx, cursor, rtreeSearchPred); try { mergedComponent = createDiskComponent(componentFactory, mergeOp.getTarget(), mergeOp.getBTreeTarget(), mergeOp.getBloomFilterTarget(), true); // In case we must keep the deleted-keys BTrees, then they must be merged // *before* merging the r-trees so that // lsmHarness.endSearch() is called once when the r-trees have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component is not included in the merge operation long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMRTreeDiskComponent) mergeOp.getMergingComponents().get(i))
response: boolean abort = true; try { try { ISearchPredicate rtreeSearchPred = new SearchPredicate(null, null); ILSMIndexOperationContext opCtx = ((LSMRTreeSortedCursor) cursor).getOpCtx(); search(opCtx, cursor, rtreeSearchPred); try { mergedComponent = createDiskComponent(componentFactory, mergeOp.getTarget(), mergeOp.getBTreeTarget(), mergeOp.getBloomFilterTarget(), true); if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents.get(diskComponents.size() - 1)) { long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMRTreeDiskComponent) mergeOp.getMergingComponents().get(i)) .getRTree().getNumElements(); } if (numElements > 0) { mergeDeletedKeys(mergeOp.getMergingComponents(), mergeOp.getBTreeTarget(), mergeOp.getBloomFilterTarget()); } } abort = false; } catch (Throwable th) { throw th; } finally { if (abort) { mergedComponent.destroy(); } } } finally { lsmHarness.endSearch(opCtx); } } finally { cursor.close(); }

sample: 912
buggy_code:  // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the r-trees so that // lsmHarness.endSearch() is called once when the r-trees have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { <|startfocus|> // Keep the deleted tuples since the oldest disk component is not included in the merge operation <|endfocus|> long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMRTreeDiskComponent) mergeOp.getMergingComponents().get(i)) .getBloomFilter().getNumElements(); } componentBulkLoader = mergedComponent.createBulkLoader(1.0f, false, numElements, false, false, false); LSMRTreeDeletedKeysBTreeMergeCursor btreeCursor = new LSMRTreeDeletedKeysBTreeMergeCursor(opCtx); try { search(opCtx, btreeCursor, rtreeSearchPred); try { while (btreeCursor.hasNext()) {
code_review:  MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the r-trees so that // lsmHarness.endSearch() is called once when the r-trees have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component // is not included in the merge operation long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMRTreeDiskComponent) mergeOp.getMergingComponents().get(i)) .getBloomFilter().getNumElements(); } componentBulkLoader = mergedComponent.createBulkLoader(1.0f, false, numElements, false, false, false); LSMRTreeDeletedKeysBTreeMergeCursor btreeCursor = new LSMRTreeDeletedKeysBTreeMergeCursor(opCtx); try { search(opCtx, btreeCursor, rtreeSearchPred); try { while (btreeCursor.hasNext()) {
response: // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the r-trees so that // lsmHarness.endSearch() is called once when the r-trees have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component is not included in the merge operation long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMRTreeDiskComponent) mergeOp.getMergingComponents().get(i)) .getBloomFilter().getNumElements(); } componentBulkLoader = mergedComponent.createBulkLoader(1.0f, false, numElements, false, false, false); LSMRTreeDeletedKeysBTreeMergeCursor btreeCursor = new LSMRTreeDeletedKeysBTreeMergeCursor(opCtx); try { search(opCtx, btreeCursor, rtreeSearchPred); try { while (btreeCursor.hasNext()) { // Process deleted tuples } } finally { btreeCursor.close(); } } catch (Exception e) { // Handle exception } }

sample: 913
buggy_code:  } doOpen(initialState, searchPred); state = State.OPENED; if (STORE_TRACES) { openCallStack = new Throwable().getStackTrace(); } } protected void doOpen(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { // Do nothing } @Override public final boolean hasNext() throws HyracksDataException { <|startfocus|> if (ENFORCE_NEXT_HAS_NEXT) { if (state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); } <|endfocus|> } return doHasNext(); } protected boolean doHasNext() throws HyracksDataException { return false; } @Override public final void next() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT) { if (state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); } } doNext(); } protected void doNext() throws HyracksDataException { // Do nothing } @Override
code_review:  MAJOR SonarQube violation: Merge this if statement with the enclosing one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1066 
target code: } doOpen(initialState, searchPred); state = State.OPENED; if (STORE_TRACES) { openCallStack = new Throwable().getStackTrace(); } } protected void doOpen(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { // Do nothing } @Override public final boolean hasNext() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); } return doHasNext(); } protected boolean doHasNext() throws HyracksDataException { return false; } @Override public final void next() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT) { if (state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); } } doNext(); } protected void doNext() throws HyracksDataException { // Do nothing } @Override
response: } doOpen(initialState, searchPred); state = State.OPENED; if (STORE_TRACES) { openCallStack = new Throwable().getStackTrace(); } } protected void doOpen(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { // Do nothing } @Override public final boolean hasNext() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); } return doHasNext(); } protected boolean doHasNext() throws HyracksDataException { return false; } @Override public final void next() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); } doNext(); } protected void doNext() throws HyracksDataException { // Do nothing } @Override

sample: 914
buggy_code:  if (state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); } } return doHasNext(); } protected boolean doHasNext() throws HyracksDataException { return false; } @Override public final void next() throws HyracksDataException { <|startfocus|> if (ENFORCE_NEXT_HAS_NEXT) { if (state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); } <|endfocus|> } doNext(); } protected void doNext() throws HyracksDataException { // Do nothing } @Override public final void destroy() throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY) { if (state == State.DESTROYED) { LOGGER.log(Level.WARN, "multiple cursor.destroy() call in " + Arrays.toString(new Throwable().getStackTrace())); return; } else if (state != State.CLOSED) { if (STORE_TRACES && openCallStack != null) {
code_review:  MAJOR SonarQube violation: Merge this if statement with the enclosing one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1066 
target code: if (state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); } } return doHasNext(); } protected boolean doHasNext() throws HyracksDataException { return false; } @Override public final void next() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); } doNext(); } protected void doNext() throws HyracksDataException { // Do nothing } @Override public final void destroy() throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY) { if (state == State.DESTROYED) { LOGGER.log(Level.WARN, "multiple cursor.destroy() call in " + Arrays.toString(new Throwable().getStackTrace())); return; } else if (state != State.CLOSED) { if (STORE_TRACES && openCallStack != null) {
response: if (state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); } return doHasNext(); } protected boolean doHasNext() throws HyracksDataException { return false; } @Override public final void next() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); } doNext(); } protected void doNext() throws HyracksDataException { // Do nothing } @Override public final void destroy() throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY) { if (state == State.DESTROYED) { LOGGER.log(Level.WARN, "multiple cursor.destroy() call in " + Arrays.toString(new Throwable().getStackTrace())); return; } else if (state != State.CLOSED) { if (STORE_TRACES && openCallStack != null) { LOGGER.log(Level.WARN, "cursor.destroy() called without cursor.close() in " + Arrays.toString(openCallStack)); } close(); } state = State.DESTROYED; } }

sample: 915
buggy_code:  private ByteBuffer buffer; private volatile long dpid; private int multiplier; private VirtualPage next; <|startfocus|> private AtomicInteger readCount = new AtomicInteger(0); private AtomicInteger writeCount = new AtomicInteger(0); // String readStackTrace; <|endfocus|> public VirtualPage(ByteBuffer buffer, int pageSize) { this.buffer = buffer; this.pageSize = pageSize; latch = new ReentrantReadWriteLock(true); dpid = -1; next = null;
code_review:  MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine 
target code: private ByteBuffer buffer; private volatile long dpid; private int multiplier; private VirtualPage next; public VirtualPage(ByteBuffer buffer, int pageSize) { this.buffer = buffer; this.pageSize = pageSize; latch = new ReentrantReadWriteLock(true); dpid = -1; next = null;
response: private ByteBuffer buffer; private volatile long dpid; private int multiplier; private VirtualPage next; private AtomicInteger readCount = new AtomicInteger(0); private AtomicInteger writeCount = new AtomicInteger(0); public VirtualPage(ByteBuffer buffer, int pageSize) { this.buffer = buffer; this.pageSize = pageSize; latch = new ReentrantReadWriteLock(true); dpid = -1; next = null; }

sample: 916
buggy_code:  public void acquireReadLatch() { latch.readLock().lock(); <|startfocus|> readCount.incrementAndGet(); // readStackTrace = Arrays.toString(new Throwable().getStackTrace()); <|endfocus|>
code_review:  MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine 
target code: public void acquireReadLatch() { latch.readLock().lock();
response: public void acquireReadLatch() { latch.readLock().lock(); readCount.incrementAndGet(); }

sample: 917
buggy_code:  LOGGER.info("Disk-Order Scan:"); } ITreeIndexAccessor treeIndexAccessor = (ITreeIndexAccessor) indexAccessor; TreeIndexDiskOrderScanCursor diskOrderCursor = (TreeIndexDiskOrderScanCursor) treeIndexAccessor.createDiskOrderScanCursor(); try { treeIndexAccessor.diskOrderScan(diskOrderCursor); try { while (diskOrderCursor.hasNext()) { diskOrderCursor.next(); ITupleReference frameTuple = diskOrderCursor.getTuple(); String rec = TupleUtils.printTuple(frameTuple, fieldSerdes); <|startfocus|> if (LOGGER.isInfoEnabled()) { LOGGER.info(rec); } <|endfocus|> } } finally { diskOrderCursor.close(); } } finally { diskOrderCursor.destroy(); } } catch (UnsupportedOperationException e) { // Ignore exception because some indexes, e.g. the LSMRTree, don't // support disk-order scan. if (LOGGER.isInfoEnabled()) { LOGGER.info("Ignoring disk-order scan since it's not supported."); } } catch (ClassCastException e) { // Ignore exception because IIndexAccessor sometimes isn't // an ITreeIndexAccessor, e.g., for the LSMRTree.
code_review:  MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 
target code: LOGGER.info("Disk-Order Scan:"); } ITreeIndexAccessor treeIndexAccessor = (ITreeIndexAccessor) indexAccessor; TreeIndexDiskOrderScanCursor diskOrderCursor = (TreeIndexDiskOrderScanCursor) treeIndexAccessor.createDiskOrderScanCursor(); try { treeIndexAccessor.diskOrderScan(diskOrderCursor); try { while (diskOrderCursor.hasNext()) { diskOrderCursor.next(); ITupleReference frameTuple = diskOrderCursor.getTuple(); String rec = TupleUtils.printTuple(frameTuple, fieldSerdes); LOGGER.info(rec); } } finally { diskOrderCursor.close(); } } finally { diskOrderCursor.destroy(); } } catch (UnsupportedOperationException e) { // Ignore exception because some indexes, e.g. the LSMRTree, don't // support disk-order scan. if (LOGGER.isInfoEnabled()) { LOGGER.info("Ignoring disk-order scan since it's not supported."); } } catch (ClassCastException e) { // Ignore exception because IIndexAccessor sometimes isn't // an ITreeIndexAccessor, e.g., for the LSMRTree.
response: ITreeIndexAccessor treeIndexAccessor = (ITreeIndexAccessor) indexAccessor; TreeIndexDiskOrderScanCursor diskOrderCursor = (TreeIndexDiskOrderScanCursor) treeIndexAccessor.createDiskOrderScanCursor(); try { treeIndexAccessor.diskOrderScan(diskOrderCursor); while (diskOrderCursor.hasNext()) { diskOrderCursor.next(); ITupleReference frameTuple = diskOrderCursor.getTuple(); if (LOGGER.isInfoEnabled()) { LOGGER.info(TupleUtils.printTuple(frameTuple, fieldSerdes)); } } } catch (UnsupportedOperationException e) { // Ignore exception because some indexes, e.g. the LSMRTree, don't support disk-order scan. if (LOGGER.isInfoEnabled()) { LOGGER.info("Ignoring disk-order scan since it's not supported."); } } catch (ClassCastException e) { // Ignore exception because IIndexAccessor sometimes isn't an ITreeIndexAccessor, e.g., for the LSMRTree. } finally { diskOrderCursor.close(); diskOrderCursor.destroy(); }

sample: 918
buggy_code:  Class<?> c = Class.forName(className); ncAppEntryPoint = (INCApplicationEntryPoint) c.newInstance(); String[] args = ncConfig.appArgs == null ? new String[0] : ncConfig.appArgs.toArray(new String[ncConfig.appArgs.size()]); ncAppEntryPoint.start(appCtx, args); } executor = Executors.newCachedThreadPool(appCtx.getThreadFactory()); } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { <|startfocus|> LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); <|endfocus|> } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } queue.stop(); if (ncAppEntryPoint != null) { ncAppEntryPoint.stop(); } /** * Stop heartbeat after NC has stopped to avoid false node failure detection
code_review:  CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 
target code: Class<?> c = Class.forName(className); ncAppEntryPoint = (INCApplicationEntryPoint) c.newInstance(); String[] args = ncConfig.appArgs == null ? new String[0] : ncConfig.appArgs.toArray(new String[ncConfig.appArgs.size()]); ncAppEntryPoint.start(appCtx, args); } executor = Executors.newCachedThreadPool(appCtx.getThreadFactory()); } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing shutdown abnormally"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } queue.stop(); if (ncAppEntryPoint != null) { ncAppEntryPoint.stop(); } /** * Stop heartbeat after NC has stopped to avoid false node failure detection
response: Class<?> c = Class.forName(className); ncAppEntryPoint = (INCApplicationEntryPoint) c.newInstance(); String[] args = ncConfig.appArgs == null ? new String[0] : ncConfig.appArgs.toArray(new String[ncConfig.appArgs.size()]); ncAppEntryPoint.start(appCtx, args); executor = Executors.newCachedThreadPool(appCtx.getThreadFactory()); } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } queue.stop(); if (ncAppEntryPoint != null) { ncAppEntryPoint.stop(); } } // Stop heartbeat after NC has stopped to avoid false node failure detection }

sample: 919
buggy_code:  CCNCFunctions.NodeRegistrationResult nrrf = (CCNCFunctions.NodeRegistrationResult) fn; setNodeRegistrationResult(nrrf.getNodeParameters(), nrrf.getException()); return; case GET_NODE_CONTROLLERS_INFO_RESPONSE: CCNCFunctions.GetNodeControllersInfoResponseFunction gncirf = (CCNCFunctions.GetNodeControllersInfoResponseFunction) fn; setNodeControllersInfo(gncirf.getNodeControllerInfos()); return; case DEPLOY_BINARY: CCNCFunctions.DeployBinaryFunction dbf = (CCNCFunctions.DeployBinaryFunction) fn; queue.schedule(new DeployBinaryWork(NodeControllerService.this, dbf.getDeploymentId(), dbf.getBinaryURLs())); <|startfocus|> return; <|endfocus|> case UNDEPLOY_BINARY: CCNCFunctions.UnDeployBinaryFunction ndbf = (CCNCFunctions.UnDeployBinaryFunction) fn; queue.schedule(new UnDeployBinaryWork(NodeControllerService.this, ndbf.getDeploymentId())); return; case STATE_DUMP_REQUEST: final CCNCFunctions.StateDumpRequestFunction dsrf = (StateDumpRequestFunction) fn; queue.schedule(new StateDumpWork(NodeControllerService.this, dsrf.getStateDumpId())); return; case SHUTDOWN_REQUEST: final CCNCFunctions.ShutdownRequestFunction sdrf = (CCNCFunctions.ShutdownRequestFunction) fn;
code_review:  MAJOR SonarQube violation: Add the missing @deprecated Javadoc tag. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMissingDeprecatedCheck 
target code: CCNCFunctions.NodeRegistrationResult nrrf = (CCNCFunctions.NodeRegistrationResult) fn; setNodeRegistrationResult(nrrf.getNodeParameters(), nrrf.getException()); return; case GET_NODE_CONTROLLERS_INFO_RESPONSE: CCNCFunctions.GetNodeControllersInfoResponseFunction gncirf = (CCNCFunctions.GetNodeControllersInfoResponseFunction) fn; setNodeControllersInfo(gncirf.getNodeControllerInfos()); return; case DEPLOY_BINARY: CCNCFunctions.DeployBinaryFunction dbf = (CCNCFunctions.DeployBinaryFunction) fn; queue.schedule(new DeployBinaryWork(NodeControllerService.this, dbf.getDeploymentId(), dbf.getBinaryURLs())); return; } case UNDEPLOY_BINARY: CCNCFunctions.UnDeployBinaryFunction ndbf = (CCNCFunctions.UnDeployBinaryFunction) fn; queue.schedule(new UnDeployBinaryWork(NodeControllerService.this, ndbf.getDeploymentId())); return; case STATE_DUMP_REQUEST: final CCNCFunctions.StateDumpRequestFunction dsrf = (StateDumpRequestFunction) fn; queue.schedule(new StateDumpWork(NodeControllerService.this, dsrf.getStateDumpId())); return; case SHUTDOWN_REQUEST: final CCNCFunctions.ShutdownRequestFunction sdrf = (CCNCFunctions.ShutdownRequestFunction) fn;
response: CCNCFunctions.NodeRegistrationResult nrrf = (CCNCFunctions.NodeRegistrationResult) fn; setNodeRegistrationResult(nrrf.getNodeParameters(), nrrf.getException()); return; case GET_NODE_CONTROLLERS_INFO_RESPONSE: CCNCFunctions.GetNodeControllersInfoResponseFunction gncirf = (CCNCFunctions.GetNodeControllersInfoResponseFunction) fn; setNodeControllersInfo(gncirf.getNodeControllerInfos()); return; case DEPLOY_BINARY: CCNCFunctions.DeployBinaryFunction dbf = (CCNCFunctions.DeployBinaryFunction) fn; queue.schedule(new DeployBinaryWork(NodeControllerService.this, dbf.getDeploymentId(), dbf.getBinaryURLs())); return; @Deprecated case UNDEPLOY_BINARY: CCNCFunctions.UnDeployBinaryFunction ndbf = (CCNCFunctions.UnDeployBinaryFunction) fn; queue.schedule(new UnDeployBinaryWork(NodeControllerService.this, ndbf.getDeploymentId())); return; case STATE_DUMP_REQUEST: final CCNCFunctions.StateDumpRequestFunction dsrf = (StateDumpRequestFunction) fn; queue.schedule(new StateDumpWork(NodeControllerService.this, dsrf.getStateDumpId())); return; case SHUTDOWN_REQUEST: final CCNCFunctions.ShutdownRequestFunction sdrf = (CCNCFunctions.ShutdownRequestFunction) fn;

sample: 920
buggy_code:  */ package org.apache.hyracks.api.job; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.control.CcId; import org.apache.hyracks.api.exceptions.ErrorCode; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.IWritable; public final class JobId implements IWritable, Serializable, Comparable { <|startfocus|> public static final int CC_BITS = Short.SIZE; public static final int ID_BITS = Long.SIZE - CC_BITS; public static final long MAX_ID = (1L << ID_BITS) - 1; <|endfocus|> public static final JobId INVALID = null; private static final long serialVersionUID = 1L; private long id; private transient CcId ccId; public static JobId create(DataInput dis) throws IOException { JobId jobId = new JobId(); jobId.readFields(dis); return jobId; } private JobId() { } public JobId(long id) { this.id = id; } public long getId() {
code_review:  private 
target code: */ package org.apache.hyracks.api.job; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.control.CcId; import org.apache.hyracks.api.exceptions.ErrorCode; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.IWritable; public final class JobId implements IWritable, Serializable, Comparable { private static final int CC_BITS = Short.SIZE; private static final int ID_BITS = Long.SIZE - CC_BITS; static final long MAX_ID = (1L << ID_BITS) - 1; public static final JobId INVALID = null; private static final long serialVersionUID = 1L; private long id; private transient CcId ccId; public static JobId create(DataInput dis) throws IOException { JobId jobId = new JobId(); jobId.readFields(dis); return jobId; } private JobId() { } public JobId(long id) { this.id = id; } public long getId() {
response: package org.apache.hyracks.api.job; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.control.CcId; import org.apache.hyracks.api.exceptions.ErrorCode; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.IWritable; public final class JobId implements IWritable, Serializable, Comparable { public static final int CC_BITS = Short.SIZE; public static final int ID_BITS = Long.SIZE - CC_BITS; public static final long MAX_ID = (1L << ID_BITS) - 1; public static final JobId INVALID = null; private static final long serialVersionUID = 1L; private long id; private transient CcId ccId; public static JobId create(DataInput dis) throws IOException { JobId jobId = new JobId(); jobId.readFields(dis); return jobId; } private JobId() { } public JobId(long id) { this.id = id; } public long getId() { return id; } public CcId getCcId() { return ccId; } public void setCcId(CcId ccId) { this.ccId = ccId; } @Override public void writeFields(DataOutput output) throws HyracksDataException { try { output.writeLong(id); } catch (IOException e) { throw HyracksDataException.create(e); } } @Override public void readFields(DataInput input) throws HyracksDataException { try { id = input.readLong(); } catch (IOException e) { throw HyracksDataException.create(e); } } @Override public int compareTo(Object o) { if (o == null || !(o instanceof JobId)) { throw new IllegalArgumentException("Cannot compare JobId with non-JobId object"); } JobId other = (JobId) o; return Long.compare(id, other.id); } @Override public int hashCode() { return Long.hashCode(id); } @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null ||

sample: 921
buggy_code: import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.control.CcId; import org.apache.hyracks.api.exceptions.ErrorCode; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.IWritable; public final class JobId implements IWritable, Serializable, Comparable { <|startfocus|> public static final int CC_BITS = Short.SIZE; public static final int ID_BITS = Long.SIZE - CC_BITS; public static final long MAX_ID = (1L << ID_BITS) - 1; <|endfocus|> public static final JobId INVALID = null; private static final long serialVersionUID = 1L; private long id; private transient CcId ccId; public static JobId create(DataInput dis) throws IOException { JobId jobId = new JobId(); jobId.readFields(dis); return jobId; } private JobId() { } public JobId(long id) { this.id = id; } public long getId() { return id; } public CcId getCcId() {
code_review:  private 
target code: import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.control.CcId; import org.apache.hyracks.api.exceptions.ErrorCode; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.IWritable; public final class JobId implements IWritable, Serializable, Comparable { private static final int CC_BITS = Short.SIZE; private static final int ID_BITS = Long.SIZE - CC_BITS; static final long MAX_ID = (1L << ID_BITS) - 1; public static final JobId INVALID = null; private static final long serialVersionUID = 1L; private long id; private transient CcId ccId; public static JobId create(DataInput dis) throws IOException { JobId jobId = new JobId(); jobId.readFields(dis); return jobId; } private JobId() { } public JobId(long id) { this.id = id; } public long getId() { return id; } public CcId getCcId() {
response: import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.control.CcId; import org.apache.hyracks.api.exceptions.ErrorCode; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.IWritable; public final class JobId implements IWritable, Serializable, Comparable { public static final int CC_BITS = Short.SIZE; public static final int ID_BITS = Long.SIZE - CC_BITS; public static final long MAX_ID = (1L << ID_BITS) - 1; public static final JobId INVALID = null; private static final long serialVersionUID = 1L; private long id; private transient CcId ccId; public static JobId create(DataInput dis) throws IOException { JobId jobId = new JobId(); jobId.readFields(dis); return jobId; } private JobId() { } public JobId(long id) { this.id = id; } public long getId() { return id; } public CcId getCcId() { return ccId; } }

sample: 922
buggy_code:  ncAppEntryPoint.stop(); /* * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; } <|startfocus|> public Map<JobId, ActivityClusterGraph> getActivityClusterGraphMap() { return activityClusterGraphMap; } <|endfocus|> public NetworkManager getNetworkManager() { return netManager; } public DatasetNetworkManager getDatasetNetworkManager() { return datasetNetworkManager; } public PartitionManager getPartitionManager() { return partitionManager; } public IClusterController getClusterController() { return ccs; } public NodeParameters getNodeParameters() { return nodeParameters; } public ExecutorService getExecutorService() { return executor; } public NCConfig getConfiguration() {
code_review:  need to stop its heartbeat thread too 
target code: ncAppEntryPoint.stop(); /* * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; } public NetworkManager getNetworkManager() { return netManager; } public DatasetNetworkManager getDatasetNetworkManager() { return datasetNetworkManager; } public PartitionManager getPartitionManager() { return partitionManager; } public IClusterController getClusterController() { return ccs; } public NodeParameters getNodeParameters() { return nodeParameters; } public ExecutorService getExecutorService() { return executor; } public NCConfig getConfiguration() {
response: ncAppEntryPoint.stop(); heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; } public Map<JobId, ActivityClusterGraph> getActivityClusterGraphMap() { return activityClusterGraphMap; } public NetworkManager getNetworkManager() { return netManager; } public DatasetNetworkManager getDatasetNetworkManager() { return datasetNetworkManager; } public PartitionManager getPartitionManager() { return partitionManager; } public IClusterController getClusterController() { return ccs; } public NodeParameters getNodeParameters() { return nodeParameters; } public ExecutorService getExecutorService() { return executor; } public NCConfig getConfiguration() { return configuration; }

sample: 923
buggy_code:  currentRecordChannel = new DatasetNetworkInputChannel(netManager, getSocketAddress(record), jobId, resultSetId, currentRecord, NUM_READ_BUFFERS); currentRecordMonitor = getMonitor(currentRecord); currentRecordChannel.registerMonitor(currentRecordMonitor); currentRecordChannel.open(datasetClientCtx); } private boolean isFirstRead() { return currentRecord == -1; } private boolean isLastRecord() { return knownRecords != null && currentRecord == knownRecords.length - 1; } <|startfocus|> private class DatasetInputChannelMonitor implements IInputChannelMonitor { <|endfocus|> private int availableFrames; private boolean eos; private boolean failed; DatasetInputChannelMonitor() { eos = false; failed = false; } @Override public synchronized void notifyFailure(IInputChannel channel) { failed = true; notifyAll(); } @Override public synchronized void notifyDataAvailability(IInputChannel channel, int nFrames) { availableFrames += nFrames; notifyAll(); } @Override public synchronized void notifyEndOfStream(IInputChannel channel) { eos = true; notifyAll(); } synchronized boolean failed() { return failed; } 
code_review:  s/class/static class/ :) 
target code: currentRecordChannel = new DatasetNetworkInputChannel(netManager, getSocketAddress(record), jobId, resultSetId, currentRecord, NUM_READ_BUFFERS); currentRecordMonitor = getMonitor(currentRecord); currentRecordChannel.registerMonitor(currentRecordMonitor); currentRecordChannel.open(datasetClientCtx); } private boolean isFirstRead() { return currentRecord == -1; } private boolean isLastRecord() { return knownRecords != null && currentRecord == knownRecords.length - 1; } private static class DatasetInputChannelMonitor implements IInputChannelMonitor { private int availableFrames; private boolean eos; private boolean failed; DatasetInputChannelMonitor() { eos = false; failed = false; } @Override public synchronized void notifyFailure(IInputChannel channel) { failed = true; notifyAll(); } @Override public synchronized void notifyDataAvailability(IInputChannel channel, int nFrames) { availableFrames += nFrames; notifyAll(); } @Override public synchronized void notifyEndOfStream(IInputChannel channel) { eos = true; notifyAll(); } synchronized boolean failed() { return failed; }
response: static class DatasetInputChannelMonitor implements IInputChannelMonitor { private int availableFrames; private boolean eos; private boolean failed; DatasetInputChannelMonitor() { eos = false; failed = false; } @Override public synchronized void notifyFailure(IInputChannel channel) { failed = true; notifyAll(); } @Override public synchronized void notifyDataAvailability(IInputChannel channel, int nFrames) { availableFrames += nFrames; notifyAll(); } @Override public synchronized void notifyEndOfStream(IInputChannel channel) { eos = true; notifyAll(); } synchronized boolean failed() { return failed; } }

sample: 924
buggy_code:  private static final boolean[] UNIQUE_META_FIELDS = null; private static final int[] KEY_INDEXES = { 0 }; private static final int[] KEY_INDICATORS = { Index.RECORD_INDICATOR }; private static final List<Integer> KEY_INDICATORS_LIST = Arrays.asList(new Integer[] { Index.RECORD_INDICATOR }); private static final int TOTAL_NUM_OF_RECORDS = 10000; private static final int RECORDS_PER_COMPONENT = 1000; private static final int DATASET_ID = 101; <|startfocus|> private static final int PARTITION_ID = 1; <|endfocus|> private static final String DATAVERSE_NAME = "TestDV"; private static final String DATASET_NAME = "TestDS"; private static final String DATA_TYPE_NAME = "DUMMY"; private static final String NODE_GROUP_NAME = "DEFAULT"; private static final Predicate<ILSMComponent> memoryComponentsPredicate = c -> c instanceof ILSMMemoryComponent; private static final StorageComponentProvider storageManager = new StorageComponentProvider(); private static TestNodeController nc; private static TestLsmBtree lsmBtree; private static NCAppRuntimeContext ncAppCtx; private static IDatasetLifecycleManager dsLifecycleMgr; private static Dataset dataset;
code_review:  why 1 when there's use of partition 0 in the index creation? 
target code: private static final boolean[] UNIQUE_META_FIELDS = null; private static final int[] KEY_INDEXES = { 0 }; private static final int[] KEY_INDICATORS = { Index.RECORD_INDICATOR }; private static final List<Integer> KEY_INDICATORS_LIST = Arrays.asList(new Integer[] { Index.RECORD_INDICATOR }); private static final int TOTAL_NUM_OF_RECORDS = 10000; private static final int RECORDS_PER_COMPONENT = 1000; private static final int DATASET_ID = 101; private static final int PARTITION_ID = 0; private static final String DATAVERSE_NAME = "TestDV"; private static final String DATASET_NAME = "TestDS"; private static final String DATA_TYPE_NAME = "DUMMY"; private static final String NODE_GROUP_NAME = "DEFAULT"; private static final Predicate<ILSMComponent> memoryComponentsPredicate = c -> c instanceof ILSMMemoryComponent; private static final StorageComponentProvider storageManager = new StorageComponentProvider(); private static TestNodeController nc; private static TestLsmBtree lsmBtree; private static NCAppRuntimeContext ncAppCtx; private static IDatasetLifecycleManager dsLifecycleMgr; private static Dataset dataset;
response: private static final boolean[] UNIQUE_META_FIELDS = null; private static final int[] KEY_INDEXES = { 0 }; private static final int[] KEY_INDICATORS = { Index.RECORD_INDICATOR }; private static final List<Integer> KEY_INDICATORS_LIST = Arrays.asList(new Integer[] { Index.RECORD_INDICATOR }); private static final int TOTAL_NUM_OF_RECORDS = 10000; private static final int RECORDS_PER_COMPONENT = 1000; private static final int DATASET_ID = 101; private static final int PARTITION_ID = 0; private static final String DATAVERSE_NAME = "TestDV"; private static final String DATASET_NAME = "TestDS"; private static final String DATA_TYPE_NAME = "DUMMY"; private static final String NODE_GROUP_NAME = "DEFAULT"; private static final Predicate<ILSMComponent> memoryComponentsPredicate = c -> c instanceof ILSMMemoryComponent; private static final StorageComponentProvider storageManager = new StorageComponentProvider(); private static TestNodeController nc; private static TestLsmBtree lsmBtree; private static NCAppRuntimeContext ncAppCtx; private static IDatasetLifecycleManager dsLifecycleMgr; private static Dataset dataset;

sample: 925
buggy_code:  /** * @return the operation callback */ ILSMIOOperationCallback getCallback(); /** * @return the index id */ String getIndexIdentifier(); /** * @return the operation type */ LSMIOOperationType getIOOpertionType(); @Override Boolean call() throws HyracksDataException; /** * @return The target of the io operation */ FileReference getTarget(); /** * @return the accessor of the operation */ ILSMIndexAccessor getAccessor(); <|startfocus|> <|endfocus|> LSMComponentFileReferences getComponentFiles(); } 
code_review:  javadocs? 
target code: /** * @return the operation callback */ ILSMIOOperationCallback getCallback(); /** * @return the index id */ String getIndexIdentifier(); /** * @return the operation type */ LSMIOOperationType getIOOpertionType(); @Override Boolean call() throws HyracksDataException; /** * @return The target of the io operation */ FileReference getTarget(); /** * @return the accessor of the operation */ ILSMIndexAccessor getAccessor(); /** * @return the component files produced by this operation */ LSMComponentFileReferences getComponentFiles(); }
response: package org.apache.hyracks.storage.am.common.api; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.FileReference; public interface ILSMIOOperation { ILSMIOOperationCallback getCallback(); String getIndexIdentifier(); LSMIOOperationType getIOOpertionType(); Boolean call() throws HyracksDataException; FileReference getTarget(); ILSMIndexAccessor getAccessor(); LSMComponentFileReferences getComponentFiles(); }

sample: 926
buggy_code: <|startfocus|> private boolean isScan; <|endfocus|> public LSMBTreeCursorInitialState(ITreeIndexFrameFactory leafFrameFactory, MultiComparator cmp, MultiComparator bloomFilterCmp, ILSMHarness lsmHarness, ISearchPredicate predicate, ISearchOperationCallback searchCallback, List<ILSMComponent> operationalComponents) { this.leafFrameFactory = leafFrameFactory; this.cmp = cmp; this.bloomFilterCmp = bloomFilterCmp; this.lsmHarness = lsmHarness; this.searchCallback = searchCallback; this.predicate = predicate; this.operationalComponents = operationalComponents;
code_review:  What's the usage of this "isScan"? I remembered previous there is a similar functionality by checking the search predicate itself. 
target code: private boolean isDiskComponentScan; public LSMBTreeCursorInitialState(ITreeIndexFrameFactory leafFrameFactory, MultiComparator cmp, MultiComparator bloomFilterCmp, ILSMHarness lsmHarness, ISearchPredicate predicate, ISearchOperationCallback searchCallback, List<ILSMComponent> operationalComponents) { this.leafFrameFactory = leafFrameFactory; this.cmp = cmp; this.bloomFilterCmp = bloomFilterCmp; this.lsmHarness = lsmHarness; this.searchCallback = searchCallback; this.predicate = predicate; this.operationalComponents = operationalComponents;
response: private boolean isScan = false; public LSMBTreeCursorInitialState(ITreeIndexFrameFactory leafFrameFactory, MultiComparator cmp, MultiComparator bloomFilterCmp, ILSMHarness lsmHarness, ISearchPredicate predicate, ISearchOperationCallback searchCallback, List<ILSMComponent> operationalComponents) { this.leafFrameFactory = leafFrameFactory; this.cmp = cmp; this.bloomFilterCmp = bloomFilterCmp; this.lsmHarness = lsmHarness; this.searchCallback = searchCallback; this.predicate = predicate; this.operationalComponents = operationalComponents; }

sample: 927
buggy_code:  btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].reset(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true; } @Override <|startfocus|> public void close() throws HyracksDataException { if (lsmHarness != null) { try { closeCursors(); btreeCursors = null; } finally { lsmHarness.endSearch(opCtx); <|endfocus|> } } nextHasBeenCalled = false; foundTuple = false; } @Override public ITupleReference getTuple() { return frameTuple; } @Override public ITupleReference getFilterMinTuple() { ILSMComponentFilter filter = getFilter(); return filter == null ? null : filter.getMinTuple(); } @Override public ITupleReference getFilterMaxTuple() { ILSMComponentFilter filter = getFilter(); return filter == null ? null : filter.getMaxTuple(); } 
code_review:  why call closeCursors instead of destroyCursors here? 
target code: btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { // re-use btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].reset(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true; } @Override public void doDestroy() throws HyracksDataException { if (btreeCursors != null) { for (int i = 0; i < numBTrees; ++i) { if (btreeCursors[i] != null) { btreeCursors[i].destroy(); } } } nextHasBeenCalled = false; foundTuple = false; } @Override public ITupleReference getTuple() { return frameTuple; } @Override public ITupleReference getFilterMinTuple() { ILSMComponentFilter filter = getFilter(); return filter == null ? null : filter.getMinTuple(); } @Override public ITupleReference getFilterMaxTuple() { ILSMComponentFilter filter = getFilter(); return filter == null ? null : filter.getMaxTuple(); }
response: btreeCursors[i] = btreeAccessors[i].createPointCursor(false); } else { btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); btreeCursors[i].reset(); } } nextHasBeenCalled = false; foundTuple = false; } @Override public void next() throws HyracksDataException { nextHasBeenCalled = true; } @Override public void close() throws HyracksDataException { if (lsmHarness != null) { try { destroyCursors(); btreeCursors = null; } finally { lsmHarness.endSearch(opCtx); } } nextHasBeenCalled = false; foundTuple = false; } @Override public ITupleReference getTuple() { return frameTuple; } @Override public ITupleReference getFilterMinTuple() { ILSMComponentFilter filter = getFilter(); return filter == null ? null : filter.getMinTuple(); } @Override public ITupleReference getFilterMaxTuple() { ILSMComponentFilter filter = getFilter(); return filter == null ? null : filter.getMaxTuple(); }

sample: 928
buggy_code:  private final LSMBTreeRangeSearchCursor rangeCursor; private ITreeIndexCursor currentCursor; public LSMBTreeSearchCursor(ILSMIndexOperationContext opCtx) { pointCursor = new LSMBTreePointSearchCursor(opCtx); rangeCursor = new LSMBTreeRangeSearchCursor(opCtx); } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMBTreeCursorInitialState lsmInitialState = (LSMBTreeCursorInitialState) initialState; RangePredicate btreePred = (RangePredicate) searchPred; <|startfocus|> currentCursor = btreePred.isPointPredicate(lsmInitialState.getOriginalKeyComparator()) ? pointCursor : rangeCursor; <|endfocus|> currentCursor.open(lsmInitialState, searchPred); } @Override public boolean hasNext() throws HyracksDataException { return currentCursor.hasNext(); } @Override public void next() throws HyracksDataException { currentCursor.next(); } @Override public void close() throws HyracksDataException { if (currentCursor != null) { currentCursor.close(); } currentCursor = null; } @Override public void reset() throws HyracksDataException { if (currentCursor != null) { currentCursor.reset(); } currentCursor = null;
code_review:  I see the usage here...But I suggest we should change the name of isScan to make it more clear (this is very different from a normal index scan). For example, isDiskComponentScan. 
target code: private final LSMBTreeRangeSearchCursor rangeCursor; private ITreeIndexCursor currentCursor; public LSMBTreeSearchCursor(ILSMIndexOperationContext opCtx) { pointCursor = new LSMBTreePointSearchCursor(opCtx); rangeCursor = new LSMBTreeRangeSearchCursor(opCtx); } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMBTreeCursorInitialState lsmInitialState = (LSMBTreeCursorInitialState) initialState; RangePredicate btreePred = (RangePredicate) searchPred; currentCursor = lsmInitialState.isDiskComponentScan() ? scanCursor : btreePred.isPointPredicate(lsmInitialState.getOriginalKeyComparator()) ? pointCursor : rangeCursor; currentCursor.open(lsmInitialState, searchPred); } @Override public boolean hasNext() throws HyracksDataException { return currentCursor.hasNext(); } @Override public void next() throws HyracksDataException { currentCursor.next(); } @Override public void close() throws HyracksDataException { if (currentCursor != null) { currentCursor.close(); } currentCursor = null; } @Override public void reset() throws HyracksDataException { if (currentCursor != null) { currentCursor.reset(); } currentCursor = null;
response: private final LSMBTreeRangeSearchCursor rangeCursor; private ITreeIndexCursor currentCursor; public LSMBTreeSearchCursor(ILSMIndexOperationContext opCtx) { pointCursor = new LSMBTreePointSearchCursor(opCtx); rangeCursor = new LSMBTreeRangeSearchCursor(opCtx); } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMBTreeCursorInitialState lsmInitialState = (LSMBTreeCursorInitialState) initialState; RangePredicate btreePred = (RangePredicate) searchPred; currentCursor = btreePred.isPointPredicate(lsmInitialState.getOriginalKeyComparator()) ? pointCursor : rangeCursor; currentCursor.open(lsmInitialState, searchPred); } @Override public boolean hasNext() throws HyracksDataException { return currentCursor.hasNext(); } @Override public void next() throws HyracksDataException { currentCursor.next(); } @Override public void close() throws HyracksDataException { if (currentCursor != null) { currentCursor.close(); } currentCursor = null; } @Override public void reset() throws HyracksDataException { if (currentCursor != null) { currentCursor.reset(); } currentCursor = null; }

sample: 929
buggy_code:  // (E.g. There are index-nested-loop-joins in the plan.) private List<Mutable<ILogicalOperator>> ixJoinOuterAdditionalDataSourceRefs = null; private List<DataSourceType> ixJoinOuterAdditionalDataSourceTypes = null; private List<Dataset> ixJoinOuterAdditionalDatasets = null; private List<ARecordType> ixJoinOuterAdditionalRecordTypes = null; /** * Identifies the root of the subtree and initializes the data-source, assign, and unnest information. */ <|startfocus|> public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef, IOptimizationContext context) throws AlgebricksException { <|endfocus|> reset(); rootRef = subTreeOpRef; root = subTreeOpRef.getValue(); boolean passedSource = false; boolean result = false; Mutable<ILogicalOperator> searchOpRef = subTreeOpRef; // Examine the op's children to match the expected patterns. AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); do { // Skips select operator. if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) { searchOpRef = subTreeOp.getInputs().get(0);
code_review:  MAJOR SonarQube violation: Remove this unused method parameter "context". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 
target code: // (E.g. There are index-nested-loop-joins in the plan.) private List<Mutable<ILogicalOperator>> ixJoinOuterAdditionalDataSourceRefs = null; private List<DataSourceType> ixJoinOuterAdditionalDataSourceTypes = null; private List<Dataset> ixJoinOuterAdditionalDatasets = null; private List<ARecordType> ixJoinOuterAdditionalRecordTypes = null; /** * Identifies the root of the subtree and initializes the data-source, assign, and unnest information. */ public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef) throws AlgebricksException { reset(); rootRef = subTreeOpRef; root = subTreeOpRef.getValue(); boolean passedSource = false; boolean result = false; Mutable<ILogicalOperator> searchOpRef = subTreeOpRef; // Examine the op's children to match the expected patterns. AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); do { // Skips select operator. if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) { searchOpRef = subTreeOp.getInputs().get(0);
response: private List<Mutable<ILogicalOperator>> ixJoinOuterAdditionalDataSourceRefs = null; private List<DataSourceType> ixJoinOuterAdditionalDataSourceTypes = null; private List<Dataset> ixJoinOuterAdditionalDatasets = null; private List<ARecordType> ixJoinOuterAdditionalRecordTypes = null; public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef) throws AlgebricksException { reset(); rootRef = subTreeOpRef; root = subTreeOpRef.getValue(); boolean passedSource = false; boolean result = false; Mutable<ILogicalOperator> searchOpRef = subTreeOpRef; AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); do { if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) { searchOpRef = subTreeOp.getInputs().get(0); } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.DATASOURCESCAN) { if (passedSource) { return false; } passedSource = true; DataSourceScanOperator dataSourceScanOp = (DataSourceScanOperator) subTreeOp; dataSourceRef = searchOpRef; dataSourceType = dataSourceScanOp.getDataSource().getDatasourceType(); dataset = dataSourceScanOp.getDataSource().getDataset(); recordType = dataSourceScanOp.getDataSource().getSchema().getType(); } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.ASSIGN) { assignRef = searchOpRef; AssignOperator assignOp = (AssignOperator) subTreeOp; assignExpressions = assignOp.getExpressions(); } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST) { unnestRef = searchOpRef; UnnestOperator unnestOp = (UnnestOperator) subTreeOp; unnestExpressions = unnestOp.getExpressions(); } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.INDEX_NESTED_LOOP_JOIN) { IndexNestedLoopJoinOperator joinOp = (IndexNestedLoopJoinOperator) subTreeOp; ixJoinOuterAdditionalDataSourceRefs = joinOp.getOuterAdditionalDataSourceRefs(); ixJoinOuterAdditionalDataSourceTypes = joinOp.getOuterAdditionalDataSourceTypes(); ixJoinOuterAdditionalDatasets = joinOp.getOuterAdditionalDatas

sample: 930
buggy_code:  } } /** * Computes and returns the byte array for an integer value. */ public static byte[] computeByteArrayForIntValue(int value) throws AlgebricksException { ArrayBackedValueStorage castBuffer = new ArrayBackedValueStorage(); try { AInt32 val = new AInt32(value); SerializerDeserializerUtil.serializeTag(val, castBuffer.getDataOutput()); AInt32SerializerDeserializer.INSTANCE.serialize(val, castBuffer.getDataOutput()); } catch (HyracksDataException e) { <|startfocus|> throw CompilationException.create(ErrorCode.CANNOT_SERIALIZE_A_VALUE); <|endfocus|> } return castBuffer.getByteArray(); } } 
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: } } /** * Computes and returns the byte array for an integer value. */ public static byte[] computeByteArrayForIntValue(int value) throws AlgebricksException { ArrayBackedValueStorage castBuffer = new ArrayBackedValueStorage(); try { AInt32 val = new AInt32(value); SerializerDeserializerUtil.serializeTag(val, castBuffer.getDataOutput()); AInt32SerializerDeserializer.INSTANCE.serialize(val, castBuffer.getDataOutput()); } catch (HyracksDataException e) { throw CompilationException.create(ErrorCode.CANNOT_SERIALIZE_A_VALUE, e); } return castBuffer.getByteArray(); } }
response: ```java } } /** * Computes and returns the byte array for an integer value. */ public static byte[] computeByteArrayForIntValue(int value) throws AlgebricksException { ArrayBackedValueStorage castBuffer = new ArrayBackedValueStorage(); try { AInt32 val = new AInt32(value); SerializerDeserializerUtil.serializeTag(val, castBuffer.getDataOutput()); AInt32SerializerDeserializer.INSTANCE.serialize(val, castBuffer.getDataOutput()); } catch (HyracksDataException e) { throw CompilationException.create(ErrorCode.CANNOT_SERIALIZE_A_VALUE); } return castBuffer.getByteArray(); } } ```

sample: 931
buggy_code:  private ITreeIndexAccessor[] btreeAccessors; private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; <|startfocus|> private int numberOfFieldFromIndex = 0; private ArrayTupleBuilder tupleBuilderForProceedResult; private ArrayTupleReference copyTuple = null; <|endfocus|> public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness();
code_review:  MAJOR SonarQube violation: Remove this unused "numberOfFieldFromIndex" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 
target code: private ITreeIndexAccessor[] btreeAccessors; private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness();
response: private ITreeIndexAccessor[] btreeAccessors; private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; private ArrayTupleBuilder tupleBuilderForProceedResult; private ArrayTupleReference copyTuple = null; public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness(); }

sample: 932
buggy_code:  private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; <|startfocus|> private int numberOfFieldFromIndex = 0; private ArrayTupleBuilder tupleBuilderForProceedResult; private ArrayTupleReference copyTuple = null; <|endfocus|> public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness();
code_review:  MAJOR SonarQube violation: Remove this unused "tupleBuilderForProceedResult" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 
target code: private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness();
response: private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; private int numberOfFieldFromIndex = 0; private ArrayTupleReference copyTuple = null; public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness(); }

sample: 933
buggy_code:  private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; <|startfocus|> private int numberOfFieldFromIndex = 0; private ArrayTupleBuilder tupleBuilderForProceedResult; private ArrayTupleReference copyTuple = null; <|endfocus|> public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness();
code_review:  MAJOR SonarQube violation: Remove this unused "copyTuple" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 
target code: private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness();
response: private RTreeSearchCursor[] mutableRTreeCursors; private ITreeIndexCursor[] btreeCursors; private RangePredicate btreeRangePredicate; private boolean foundNext; private ITupleReference frameTuple; private int[] comparatorFields; private MultiComparator btreeCmp; private int currentCursor; private SearchPredicate rtreeSearchPredicate; private int numMutableComponents; private boolean open; protected ISearchOperationCallback searchCallback; private boolean resultOfsearchCallBackProceed = false; private int numberOfFieldFromIndex = 0; private ArrayTupleBuilder tupleBuilderForProceedResult; public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx) { this(opCtx, false); } public LSMRTreeWithAntiMatterTuplesSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { super(opCtx, returnDeletedTuples); currentCursor = 0; } @Override public void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { LSMRTreeCursorInitialState lsmInitialState = (LSMRTreeCursorInitialState) initialState; cmp = lsmInitialState.getHilbertCmp(); btreeCmp = lsmInitialState.getBTreeCmp(); lsmHarness = lsmInitialState.getLSMHarness(); }

sample: 934
buggy_code:  public interface INcApplicationContext extends IApplicationContext { IIOManager getIoManager(); Executor getThreadExecutor(); ITransactionSubsystem getTransactionSubsystem(); void preStop() throws Exception; boolean isShuttingdown(); ILSMIOOperationScheduler getLSMIOScheduler(); ILSMMergePolicyFactory getMetadataMergePolicyFactory(); IBufferCache getBufferCache(); ILocalResourceRepository getLocalResourceRepository(); IDatasetLifecycleManager getDatasetLifecycleManager(); IDatasetMemoryManager getDatasetMemoryManager(); IResourceIdFactory getResourceIdFactory(); <|startfocus|> ILSMOperationTracker getLSMBTreeOperationTracker(int datasetID, int partition); <|endfocus|> void initialize(boolean initialRun) throws IOException, ACIDException, AlgebricksException; void setShuttingdown(boolean b); void deinitialize() throws HyracksDataException; double getBloomFilterFalsePositiveRate(); Object getActiveManager(); IReplicationManager getReplicationManager(); IReplicationChannel getReplicationChannel(); /** * Exports the metadata node to the metadata RMI port. * * @throws RemoteException */ void exportMetadataNodeStub() throws RemoteException; /** * Initializes the metadata node and bootstraps the metadata. * * @param newUniverse * @throws Exception */
code_review:  Let's rename this method too. maybe getPrimaryOperationTracker 
target code: public interface INcApplicationContext extends IApplicationContext { IIOManager getIoManager(); Executor getThreadExecutor(); ITransactionSubsystem getTransactionSubsystem(); void preStop() throws Exception; boolean isShuttingdown(); ILSMIOOperationScheduler getLSMIOScheduler(); ILSMMergePolicyFactory getMetadataMergePolicyFactory(); IBufferCache getBufferCache(); ILocalResourceRepository getLocalResourceRepository(); IDatasetLifecycleManager getDatasetLifecycleManager(); IDatasetMemoryManager getDatasetMemoryManager(); IResourceIdFactory getResourceIdFactory(); ILSMOperationTracker getPrimaryOperationTracker(int datasetID, int partition); void initialize(boolean initialRun) throws IOException, ACIDException, AlgebricksException; void setShuttingdown(boolean b); void deinitialize() throws HyracksDataException; double getBloomFilterFalsePositiveRate(); Object getActiveManager(); IReplicationManager getReplicationManager(); IReplicationChannel getReplicationChannel(); /** * Exports the metadata node to the metadata RMI port. * * @throws RemoteException */ void exportMetadataNodeStub() throws RemoteException; /** * Initializes the metadata node and bootstraps the metadata. * * @param newUniverse * @throws Exception */
response: public interface INcApplicationContext extends IApplicationContext { IIOManager getIoManager(); Executor getThreadExecutor(); ITransactionSubsystem getTransactionSubsystem(); void preStop() throws Exception; boolean isShuttingdown(); ILSMIOOperationScheduler getLSMIOScheduler(); ILSMMergePolicyFactory getMetadataMergePolicyFactory(); IBufferCache getBufferCache(); ILocalResourceRepository getLocalResourceRepository(); IDatasetLifecycleManager getDatasetLifecycleManager(); IDatasetMemoryManager getDatasetMemoryManager(); IResourceIdFactory getResourceIdFactory(); ILSMOperationTracker getPrimaryOperationTracker(int datasetID, int partition); void initialize(boolean initialRun) throws IOException, ACIDException, AlgebricksException; void setShuttingdown(boolean b); void deinitialize() throws HyracksDataException; double getBloomFilterFalsePositiveRate(); Object getActiveManager(); IReplicationManager getReplicationManager(); IReplicationChannel getReplicationChannel(); void exportMetadataNodeStub() throws RemoteException; void initializeMetadataNode() throws Exception; }

sample: 935
buggy_code:  idGenerator.refresh(); if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { <|startfocus|> throw new HyracksDataException(e); <|endfocus|> } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially.
code_review:  CRITICAL SonarQube violation: Remove this call to "wait" or move it into a "while" loop. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2274 
target code: idGenerator.refresh(); if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially.
response: idGenerator.refresh(); if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { logRecord.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } for (ILSMIndex index : indexes) { AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially. } }

sample: 936
buggy_code:  idGenerator.refresh(); if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { <|startfocus|> throw new HyracksDataException(e); <|endfocus|> } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially.
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: idGenerator.refresh(); if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { //notification will come from LogBuffer class (notifyFlushTerminator) logRecord.wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } } } for (ILSMIndex index : indexes) { //update resource lsn AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially.
response: idGenerator.refresh(); if (dsInfo.isDurable()) { synchronized (logRecord) { TransactionUtil.formFlushLogRecord(logRecord, dsInfo.getDatasetID(), null); try { logManager.log(logRecord); } catch (ACIDException e) { throw new HyracksDataException("could not write flush log while closing dataset", e); } try { logRecord.wait(); } catch (InterruptedException e) { throw new HyracksDataException(e); } } } for (ILSMIndex index : indexes) { AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) index.getIOOperationCallback(); ioOpCallback.updateLastLSN(logRecord.getLSN()); } if (asyncFlush) { for (ILSMIndex index : indexes) { ILSMIndexAccessor accessor = index.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleFlush(index.getIOOperationCallback()); } } else { for (ILSMIndex index : indexes) { // TODO: This is not efficient since we flush the indexes sequentially. index.getIOOperationCallback().flush(); } }

sample: 937
buggy_code:  this.setMemoryAllocated(false); } @Override public void touch() { super.touch(); setLastAccess(System.currentTimeMillis()); } @Override public void untouch() { super.untouch(); setLastAccess(System.currentTimeMillis()); } public synchronized void declareActiveIOOperation() { numActiveIOOps++; } public synchronized void undeclareActiveIOOperation() { numActiveIOOps--; //notify threads waiting on this dataset info notifyAll(); } <|startfocus|> public synchronized Set<ILSMIndex> getDatasetPartitionIndexes(int partition) { <|endfocus|> Set<ILSMIndex> indexSet = new HashSet<>(); Set<IndexInfo> partitionIndexInfos = this.partitionIndexes.get(partition); if (partitionIndexInfos != null) { for (IndexInfo iInfo : partitionIndexInfos) { if (iInfo.isOpen()) { indexSet.add(iInfo.getIndex()); } } } return indexSet; } @Override public int compareTo(DatasetInfo i) { // sort by (isOpen, referenceCount, lastAccess) ascending, where true < false // // Example sort order: // -------------------
code_review:  let's rename to getDatasetPartitionOpenIndexes ? since this only cares about the open ones 
target code: this.setMemoryAllocated(false); } @Override public void touch() { super.touch(); setLastAccess(System.currentTimeMillis()); } @Override public void untouch() { super.untouch(); setLastAccess(System.currentTimeMillis()); } public synchronized void declareActiveIOOperation() { numActiveIOOps++; } public synchronized void undeclareActiveIOOperation() { numActiveIOOps--; //notify threads waiting on this dataset info notifyAll(); } public synchronized Set<ILSMIndex> getDatasetPartitionOpenIndexes(int partition) { Set<ILSMIndex> indexSet = new HashSet<>(); Set<IndexInfo> partitionIndexInfos = this.partitionIndexes.get(partition); if (partitionIndexInfos != null) { for (IndexInfo iInfo : partitionIndexInfos) { if (iInfo.isOpen()) { indexSet.add(iInfo.getIndex()); } } } return indexSet; } @Override public int compareTo(DatasetInfo i) { // sort by (isOpen, referenceCount, lastAccess) ascending, where true < false // // Example sort order: // -------------------
response: this.setMemoryAllocated(false); @Override public void touch() { super.touch(); setLastAccess(System.currentTimeMillis()); } @Override public void untouch() { super.untouch(); setLastAccess(System.currentTimeMillis()); } public synchronized void declareActiveIOOperation() { numActiveIOOps++; } public synchronized void undeclareActiveIOOperation() { numActiveIOOps--; //notify threads waiting on this dataset info notifyAll(); } public synchronized Set<ILSMIndex> getDatasetPartitionOpenIndexes(int partition) { Set<ILSMIndex> indexSet = new HashSet<>(); Set<IndexInfo> partitionIndexInfos = this.partitionIndexes.get(partition); if (partitionIndexInfos != null) { for (IndexInfo iInfo : partitionIndexInfos) { if (iInfo.isOpen()) { indexSet.add(iInfo.getIndex()); } } } return indexSet; } @Override public int compareTo(DatasetInfo i) { // sort by (isOpen, referenceCount, lastAccess) ascending, where true < false // // Example sort order: // -------------------

sample: 938
buggy_code:  public String toString() { <|startfocus|> return "JID:[" + getCcId() + "]" + getIdOnly(); <|endfocus|>
code_review:  space 
target code: public String toString() { return "JID[" + (id >>> ID_BITS) + ":" + getIdOnly() + "]";
response: public String toString() { return "JID:[" + getCcId() + "]" + getIdOnly(); }

sample: 939
buggy_code: import java.util.Map; import java.util.Set; import org.apache.hyracks.api.application.ICCServiceContext; import org.apache.hyracks.api.application.IClusterLifecycleListener; import org.apache.hyracks.api.config.IApplicationConfig; import org.apache.hyracks.api.config.IOption; import org.apache.hyracks.api.context.ICCContext; import org.apache.hyracks.api.exceptions.HyracksException; import org.apache.hyracks.api.job.IJobLifecycleListener; import org.apache.hyracks.api.job.JobId; import org.apache.hyracks.api.job.JobSpecification; import org.apache.hyracks.api.job.JobStatus; <|startfocus|> import org.apache.hyracks.api.messages.IMessageBroker; <|endfocus|> import org.apache.hyracks.api.service.IControllerService; import org.apache.hyracks.control.cc.ClusterControllerService; import org.apache.hyracks.control.common.application.ServiceContext; import org.apache.hyracks.control.common.context.ServerContext; import org.apache.hyracks.control.common.utils.HyracksThreadFactory; import org.apache.hyracks.control.common.work.IResultCallback; public class CCServiceContext extends ServiceContext implements ICCServiceContext { private final ICCContext ccContext; protected final Set<String> initPendingNodeIds; protected final Set<String> deinitPendingNodeIds; protected IResultCallback<Object> initializationCallback; protected IResultCallback<Object> deinitializationCallback; 
code_review:  is this needed? 
target code: import java.util.Map; import java.util.Set; import org.apache.hyracks.api.application.ICCServiceContext; import org.apache.hyracks.api.application.IClusterLifecycleListener; import org.apache.hyracks.api.config.IApplicationConfig; import org.apache.hyracks.api.config.IOption; import org.apache.hyracks.api.context.ICCContext; import org.apache.hyracks.api.exceptions.HyracksException; import org.apache.hyracks.api.job.IJobLifecycleListener; import org.apache.hyracks.api.job.JobId; import org.apache.hyracks.api.job.JobSpecification; import org.apache.hyracks.api.job.JobStatus; import org.apache.hyracks.api.service.IControllerService; import org.apache.hyracks.control.cc.ClusterControllerService; import org.apache.hyracks.control.common.application.ServiceContext; import org.apache.hyracks.control.common.context.ServerContext; import org.apache.hyracks.control.common.utils.HyracksThreadFactory; import org.apache.hyracks.control.common.work.IResultCallback; public class CCServiceContext extends ServiceContext implements ICCServiceContext { private final ICCContext ccContext; protected final Set<String> initPendingNodeIds; protected final Set<String> deinitPendingNodeIds; protected IResultCallback<Object> initializationCallback; protected IResultCallback<Object> deinitializationCallback;
response: import java.util.Map; import java.util.Set; import org.apache.hyracks.api.application.ICCServiceContext; import org.apache.hyracks.api.application.IClusterLifecycleListener; import org.apache.hyracks.api.config.IApplicationConfig; import org.apache.hyracks.api.config.IOption; import org.apache.hyracks.api.context.ICCContext; import org.apache.hyracks.api.exceptions.HyracksException; import org.apache.hyracks.api.job.IJobLifecycleListener; import org.apache.hyracks.api.job.JobId; import org.apache.hyracks.api.job.JobSpecification; import org.apache.hyracks.api.job.JobStatus; import org.apache.hyracks.api.service.IControllerService; import org.apache.hyracks.control.cc.ClusterControllerService; import org.apache.hyracks.control.common.application.ServiceContext; import org.apache.hyracks.control.common.context.ServerContext; import org.apache.hyracks.control.common.utils.HyracksThreadFactory; import org.apache.hyracks.control.common.work.IResultCallback; public class CCServiceContext extends ServiceContext implements ICCServiceContext { private final ICCContext ccContext; protected final Set<String> initPendingNodeIds; protected final Set<String> deinitPendingNodeIds; protected IResultCallback<Object> initializationCallback; protected IResultCallback<Object> deinitializationCallback; }

sample: 940
buggy_code:  indexOnlyPlanInfo.setFirst(false); return; } // index-only plan possible? boolean isIndexOnlyPlan = false; // secondary key field usage after the select (join) operators // This boolean is mainly used for R-Tree case since R-Tree index generates an MBR // and we can restore original point or rectangle from this MBR if an index is built on point or rectangle. <|startfocus|> boolean secondaryKeyFieldUsedAfterSelectOrJoinOp = indexOnlyPlanInfo.getSecond(); <|endfocus|> // Whether a post verification (especially for R-Tree case) is required after the secondary index search // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); // matched function expressions
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "secondaryKeyFieldUsedAfterSelectOrJoinOp". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: indexOnlyPlanInfo.setFirst(false); return; } // index-only plan possible? boolean isIndexOnlyPlan = false; // secondary key field usage after the select (join) operators // This boolean is mainly used for R-Tree case since R-Tree index generates an MBR // and we can restore original point or rectangle from this MBR if an index is built on point or rectangle. boolean secondaryKeyFieldUsedAfterSelectOrJoinOp; // Whether a post verification (especially for R-Tree case) is required after the secondary index search // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); // matched function expressions
response: indexOnlyPlanInfo.setFirst(false); return; boolean isIndexOnlyPlan = false; boolean secondaryKeyFieldUsedAfterSelectOrJoinOp = indexOnlyPlanInfo.getSecond(); boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); // matched function expressions // remaining code...

sample: 941
buggy_code:  // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? <|startfocus|> boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); <|endfocus|> // matched function expressions List<IOptimizableFuncExpr> matchedFuncExprs = analysisCtx.getMatchedFuncExprs(); // logical variables that select (join) operator is using List<LogicalVariable> usedVarsInSelJoinOp = new ArrayList<>(); List<LogicalVariable> usedVarsInSelJoinOpTemp = new ArrayList<>(); // live variables that select (join) operator can access List<LogicalVariable> liveVarsAfterSelJoinOp = new ArrayList<>(); // PK, record variable List<LogicalVariable> dataScanPKRecordVars; List<LogicalVariable> dataScanPKVars = new ArrayList<>(); List<LogicalVariable> dataScanRecordVars = new ArrayList<>(); 
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "doesSIdxSearchCoverAllPredicates". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: // (e.g., the shape of the given query is not a point or rectangle. // Then, we may need to apply the select again using the real polygon, not MBR of it to get the true // result, not a super-set of it.) boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); // Does the given index can cover all search predicates? boolean doesSIdxSearchCoverAllPredicates; // matched function expressions List<IOptimizableFuncExpr> matchedFuncExprs = analysisCtx.getMatchedFuncExprs(); // logical variables that select (join) operator is using List<LogicalVariable> usedVarsInSelJoinOp = new ArrayList<>(); List<LogicalVariable> usedVarsInSelJoinOpTemp = new ArrayList<>(); // live variables that select (join) operator can access List<LogicalVariable> liveVarsAfterSelJoinOp = new ArrayList<>(); // PK, record variable List<LogicalVariable> dataScanPKRecordVars; List<LogicalVariable> dataScanPKVars = new ArrayList<>(); List<LogicalVariable> dataScanRecordVars = new ArrayList<>();
response: boolean requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.getThird(); boolean doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.getFourth(); List<IOptimizableFuncExpr> matchedFuncExprs = analysisCtx.getMatchedFuncExprs(); List<LogicalVariable> usedVarsInSelJoinOp = new ArrayList<>(); List<LogicalVariable> usedVarsInSelJoinOpTemp = new ArrayList<>(); List<LogicalVariable> liveVarsAfterSelJoinOp = new ArrayList<>(); List<LogicalVariable> dataScanPKRecordVars; List<LogicalVariable> dataScanPKVars = new ArrayList<>(); List<LogicalVariable> dataScanRecordVars = new ArrayList<>();

sample: 942
buggy_code:  public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override @SuppressWarnings("unchecked") public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { <|startfocus|> private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private final DataOutput out = resultStorage.getDataOutput(); private final IPointable argPtr0 = new VoidPointable(); private final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); <|endfocus|> private final AMutableInt32 intRes = new AMutableInt32(0); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); try { byte[] bytes0 = argPtr0.getByteArray(); int offset0 = argPtr0.getStartOffset(); int len0 = argPtr0.getLength(); ATypeTag tag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes0[offset0]); if (tag != ATypeTag.GEOMETRY) {
code_review:  MAJOR SonarQube violation: Reduce this anonymous class number of lines from 53 to at most 20, or make it a named class. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 
target code: public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override @SuppressWarnings("unchecked") public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { private class AbstractSTSingleGeometryEvaluator implements IScalarEvaluator { private final AMutableInt32 intRes = new AMutableInt32(0); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); try { byte[] bytes0 = argPtr0.getByteArray(); int offset0 = argPtr0.getStartOffset(); int len0 = argPtr0.getLength(); ATypeTag tag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes0[offset0]); if (tag != ATypeTag.GEOMETRY) {
response: public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override @SuppressWarnings("unchecked") public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private final DataOutput out = resultStorage.getDataOutput(); private final IPointable argPtr0 = new VoidPointable(); private final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); private final AMutableInt32 intRes = new AMutableInt32(0); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); try { byte[] bytes0 = argPtr0.getByteArray(); int offset0 = argPtr0.getStartOffset(); int len0 = argPtr0.getLength(); ATypeTag tag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes0[offset0]); if (tag != ATypeTag.GEOMETRY) { // Rest of the code } } catch (IOException e) { throw HyracksDataException.create(e); } } }; } }; }

sample: 943
buggy_code:  public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { <|startfocus|> private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); private IPointable inputArg = new VoidPointable(); private IScalarEvaluator eval = args[0].createScalarEvaluator(ctx); <|endfocus|> @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { eval.evaluate(tuple, inputArg); byte[] data = inputArg.getByteArray(); int offset = inputArg.getStartOffset(); int len = inputArg.getLength(); if (data[offset] != ATypeTag.SERIALIZED_BINARY_TYPE_TAG) { throw new TypeMismatchException(BuiltinFunctions.ST_GEOM_FROM_WKB, 0, data[offset], ATypeTag.SERIALIZED_BINARY_TYPE_TAG); } try { out.writeByte(ATypeTag.SERIALIZED_GEOMETRY_TYPE_TAG);
code_review:  MAJOR SonarQube violation: Reduce this anonymous class number of lines from 29 to at most 20, or make it a named class. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 
target code: public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { private class STGeomFromWKBEvaulator implements IScalarEvaluator { @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { eval.evaluate(tuple, inputArg); byte[] data = inputArg.getByteArray(); int offset = inputArg.getStartOffset(); int len = inputArg.getLength(); if (data[offset] != ATypeTag.SERIALIZED_BINARY_TYPE_TAG) { throw new TypeMismatchException(BuiltinFunctions.ST_GEOM_FROM_WKB, 0, data[offset], ATypeTag.SERIALIZED_BINARY_TYPE_TAG); } try { out.writeByte(ATypeTag.SERIALIZED_GEOMETRY_TYPE_TAG);
response: public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); private IPointable inputArg = new VoidPointable(); private IScalarEvaluator eval = args[0].createScalarEvaluator(ctx); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { eval.evaluate(tuple, inputArg); byte[] data = inputArg.getByteArray(); int offset = inputArg.getStartOffset(); int len = inputArg.getLength(); if (data[offset] != ATypeTag.SERIALIZED_BINARY_TYPE_TAG) { throw new TypeMismatchException(BuiltinFunctions.ST_GEOM_FROM_WKB, 0, data[offset], ATypeTag.SERIALIZED_BINARY_TYPE_TAG); } try { out.writeByte(ATypeTag.SERIALIZED_GEOMETRY_TYPE_TAG); out.write(data, offset + 1, len - 1); result.set(resultStorage); } catch (IOException e) { throw HyracksDataException.create(e); } } }; } }; }

sample: 944
buggy_code:  public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { <|startfocus|> return new IScalarEvaluator() { private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); private IPointable inputArg = new VoidPointable(); private IScalarEvaluator eval = args[0].createScalarEvaluator(ctx); <|endfocus|> @Override @SuppressWarnings("unchecked") public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { eval.evaluate(tuple, inputArg); byte[] bytes = inputArg.getByteArray(); int offset = inputArg.getStartOffset(); int len = inputArg.getLength(); AOrderedListType type = new AOrderedListType(BuiltinType.AGEOMETRY, null); byte typeTag = inputArg.getByteArray()[inputArg.getStartOffset()]; ISerializerDeserializer serde; if (typeTag == ATypeTag.SERIALIZED_ORDEREDLIST_TYPE_TAG) { serde = new AOrderedListSerializerDeserializer(type);
code_review:  MAJOR SonarQube violation: Reduce this anonymous class number of lines from 44 to at most 20, or make it a named class. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 
target code: public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { return new STPolygonizeEvaluator(args, ctx); } }; } @Override @SuppressWarnings("unchecked") public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { eval.evaluate(tuple, inputArg); byte[] bytes = inputArg.getByteArray(); int offset = inputArg.getStartOffset(); int len = inputArg.getLength(); AOrderedListType type = new AOrderedListType(BuiltinType.AGEOMETRY, null); byte typeTag = inputArg.getByteArray()[inputArg.getStartOffset()]; ISerializerDeserializer serde; if (typeTag == ATypeTag.SERIALIZED_ORDEREDLIST_TYPE_TAG) { serde = new AOrderedListSerializerDeserializer(type);
response: public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); private IPointable inputArg = new VoidPointable(); private IScalarEvaluator eval = args[0].createScalarEvaluator(ctx); @Override @SuppressWarnings("unchecked") public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { eval.evaluate(tuple, inputArg); byte[] bytes = inputArg.getByteArray(); int offset = inputArg.getStartOffset(); int len = inputArg.getLength(); AOrderedListType type = new AOrderedListType(BuiltinType.AGEOMETRY, null); byte typeTag = inputArg.getByteArray()[inputArg.getStartOffset()]; ISerializerDeserializer serde; if (typeTag == ATypeTag.SERIALIZED_ORDEREDLIST_TYPE_TAG) { serde = new AOrderedListSerializerDeserializer(type); } // rest of the code... } }; } }; }

sample: 945
buggy_code:  public int hashCode() { <|startfocus|> return first.hashCode() * 71 + second.hashCode() * 31 + third.hashCode() * 17 + fourth.hashCode(); <|endfocus|>
code_review:  use Objects.hash() as Pair/Triple do 
target code: public int hashCode() { return Objects.hash(first, second, third, fourth);
response: public int hashCode() { return Objects.hash(first, second, third, fourth); }

sample: 946
buggy_code:  public boolean equals(Object o) { if (!(o instanceof Quadruple<?, ?, ?, ?>)) { return false; } <|startfocus|> Quadruple<?, ?, ?, ?> quadRuple = (Quadruple<?, ?, ?, ?>) o; return first.equals(quadRuple.first) && second.equals(quadRuple.second) && third.equals(quadRuple.third) && fourth.equals(quadRuple.fourth); <|endfocus|>
code_review:  Use Objects.equals() as Pair/Triple do (it handles 'null' values) 
target code: public boolean equals(Object o) { if (!(o instanceof Quadruple<?, ?, ?, ?>)) { return false; } Quadruple<?, ?, ?, ?> quadruple = (Quadruple<?, ?, ?, ?>) o; return Objects.equals(first, quadruple.first) && Objects.equals(second, quadruple.second) && Objects.equals(third, quadruple.third) && Objects.equals(fourth, quadruple.fourth);
response: public boolean equals(Object o) { if (!(o instanceof Quadruple<?, ?, ?, ?>)) { return false; } Quadruple<?, ?, ?, ?> quadRuple = (Quadruple<?, ?, ?, ?>) o; return Objects.equals(first, quadRuple.first) && Objects.equals(second, quadRuple.second) && Objects.equals(third, quadRuple.third) && Objects.equals(fourth, quadRuple.fourth); }

sample: 947
buggy_code:  public boolean hasNext() { <|startfocus|> if (currentElementIx < numElements) { return true; } else { return false; } <|endfocus|>
code_review:  return currentElementIx < numElements 
target code: public boolean hasNext() { return currentElementIx < numElements;
response: public boolean hasNext() { return currentElementIx < numElements; }

sample: 948
buggy_code:  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.common; import java.util.Arrays; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; <|startfocus|> public class EnforcedIndexCursor implements IIndexCursor { <|endfocus|> enum State { CLOSED, OPENED, DESTROYED } private static final boolean STORE_TRACES = false; private static final boolean ENFORCE_NEXT_HAS_NEXT = true; private static final boolean ENFORCE_OPEN_CLOSE_DESTROY = true; private static final Logger LOGGER = LogManager.getLogger(); private State state = State.CLOSED; private StackTraceElement[] openCallStack; private StackTraceElement[] destroyCallStack; @Override public final void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY && state != State.CLOSED) {
code_review:  shouldn't this be an abstract class with the // do nothing methods as abstract methods? 
target code: * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.common; import java.util.Arrays; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public abstract class EnforcedIndexCursor implements IIndexCursor { enum State { CLOSED, OPENED, DESTROYED } private static final boolean STORE_TRACES = false; private static final boolean ENFORCE_NEXT_HAS_NEXT = true; private static final boolean ENFORCE_OPEN_CLOSE_DESTROY = true; private static final Logger LOGGER = LogManager.getLogger(); private State state = State.CLOSED; private StackTraceElement[] openCallStack; private StackTraceElement[] destroyCallStack; @Override public final void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY && state != State.CLOSED) {
response: package org.apache.hyracks.storage.common; import java.util.Arrays; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.data.accessors.ITupleReference; import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public abstract class EnforcedIndexCursor implements IIndexCursor { enum State { CLOSED, OPENED, DESTROYED } private static final boolean STORE_TRACES = false; private static final boolean ENFORCE_NEXT_HAS_NEXT = true; private static final boolean ENFORCE_OPEN_CLOSE_DESTROY = true; private static final Logger LOGGER = LogManager.getLogger(); private State state = State.CLOSED; private StackTraceElement[] openCallStack; private StackTraceElement[] destroyCallStack; @Override public final void open(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY && state != State.CLOSED) { throw new IllegalStateException("Cursor is not closed"); } state = State.OPENED; if (STORE_TRACES) { openCallStack = Thread.currentThread().getStackTrace(); } try { doOpen(initialState, searchPred); } catch (HyracksDataException e) { state = State.CLOSED; throw e; } } protected abstract void doOpen(ICursorInitialState initialState, ISearchPredicate searchPred) throws HyracksDataException; @Override public final boolean next() throws HyracksDataException { if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cursor is not opened"); } return doNext(); } protected abstract boolean doNext() throws HyracksDataException; @Override public final void close() throws HyracksDataException { if (ENFORCE_OPEN_CLOSE_DESTROY && state != State.OPENED) { throw new IllegalStateException("Cursor is not opened"); } state = State.CLOSED; if (STORE_TRACES) { openCallStack = null; } doClose(); } protected abstract void doClose() throws HyracksDataException; @Override public final void destroy() throws HyracksDataException { if

sample: 949
buggy_code:  private static final long serialVersionUID = 1L; private static final int METADATA_DATASET_ID = MetadataPrimaryIndexes.PROPERTIES_METADATA.getDatasetId(); // shared between core and extension private IDatasetLifecycleManager datasetLifecycleManager; private ITransactionSubsystem transactionSubsystem; private int metadataStoragePartition; // core only private transient MetadataTupleTranslatorProvider tupleTranslatorProvider; // extension only private Map<ExtensionMetadataDatasetId, ExtensionMetadataDataset<?>> extensionDatasets; public static final MetadataNode INSTANCE = new MetadataNode(); private MetadataNode() { super(); } <|startfocus|> public void initialize(IAppRuntimeContext runtimeContext, <|endfocus|> MetadataTupleTranslatorProvider tupleTranslatorProvider, List<IMetadataExtension> metadataExtensions) { this.tupleTranslatorProvider = tupleTranslatorProvider; this.transactionSubsystem = runtimeContext.getTransactionSubsystem(); this.datasetLifecycleManager = runtimeContext.getDatasetLifecycleManager(); this.metadataStoragePartition = ((IPropertiesProvider) runtimeContext).getMetadataProperties() .getMetadataPartition().getPartitionId(); if (metadataExtensions != null) { extensionDatasets = new HashMap<>(); for (IMetadataExtension metadataExtension : metadataExtensions) { for (ExtensionMetadataDataset<?> extensionIndex : metadataExtension.getExtensionIndexes()) {
code_review:  CRITICAL SonarQube violation: Make "txnIdFactory" transient or serializable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1948 
target code: private static final long serialVersionUID = 1L; private static final int METADATA_DATASET_ID = MetadataPrimaryIndexes.PROPERTIES_METADATA.getDatasetId(); // shared between core and extension private IDatasetLifecycleManager datasetLifecycleManager; private ITransactionSubsystem transactionSubsystem; private int metadataStoragePartition; // core only private transient MetadataTupleTranslatorProvider tupleTranslatorProvider; // extension only private Map<ExtensionMetadataDatasetId, ExtensionMetadataDataset<?>> extensionDatasets; public static final MetadataNode INSTANCE = new MetadataNode(); private MetadataNode() { super(); } public void initialize(INcApplicationContext runtimeContext, MetadataTupleTranslatorProvider tupleTranslatorProvider, List<IMetadataExtension> metadataExtensions) { this.tupleTranslatorProvider = tupleTranslatorProvider; this.transactionSubsystem = runtimeContext.getTransactionSubsystem(); this.datasetLifecycleManager = runtimeContext.getDatasetLifecycleManager(); this.metadataStoragePartition = ((IPropertiesProvider) runtimeContext).getMetadataProperties() .getMetadataPartition().getPartitionId(); if (metadataExtensions != null) { extensionDatasets = new HashMap<>(); for (IMetadataExtension metadataExtension : metadataExtensions) { for (ExtensionMetadataDataset<?> extensionIndex : metadataExtension.getExtensionIndexes()) {
response: private static final long serialVersionUID = 1L; private static final int METADATA_DATASET_ID = MetadataPrimaryIndexes.PROPERTIES_METADATA.getDatasetId(); private IDatasetLifecycleManager datasetLifecycleManager; private ITransactionSubsystem transactionSubsystem; private int metadataStoragePartition; private transient MetadataTupleTranslatorProvider tupleTranslatorProvider; private Map<ExtensionMetadataDatasetId, ExtensionMetadataDataset<?>> extensionDatasets; public static final MetadataNode INSTANCE = new MetadataNode(); private MetadataNode() { super(); } public void initialize(IAppRuntimeContext runtimeContext, MetadataTupleTranslatorProvider tupleTranslatorProvider, List<IMetadataExtension> metadataExtensions) { this.tupleTranslatorProvider = tupleTranslatorProvider; this.transactionSubsystem = runtimeContext.getTransactionSubsystem(); this.datasetLifecycleManager = runtimeContext.getDatasetLifecycleManager(); this.metadataStoragePartition = ((IPropertiesProvider) runtimeContext).getMetadataProperties() .getMetadataPartition().getPartitionId(); if (metadataExtensions != null) { extensionDatasets = new HashMap<>(); for (IMetadataExtension metadataExtension : metadataExtensions) { for (ExtensionMetadataDataset<?> extensionIndex : metadataExtension.getExtensionIndexes()) { // initialize extension datasets } } } }

sample: 950
buggy_code:  import java.util.concurrent.atomic.AtomicLong; import java.util.function.Supplier; import org.apache.asterix.common.transactions.ILongBlockFactory; import org.apache.asterix.common.transactions.ITxnIdFactory; import org.apache.asterix.common.transactions.TxnId; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Represents a factory to generate unique transaction IDs. */ <|startfocus|> /*package*/ class CcTxnIdFactory implements ITxnIdFactory { private static int TXN_BLOCK_SIZE = 10; <|endfocus|> private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry
code_review:  MAJOR SonarQube violation: Rename this field "TXN_BLOCK_SIZE" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: import java.util.concurrent.atomic.AtomicLong; import java.util.function.Supplier; import org.apache.asterix.common.transactions.ILongBlockFactory; import org.apache.asterix.common.transactions.ITxnIdFactory; import org.apache.asterix.common.transactions.TxnId; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Represents a factory to generate unique transaction IDs. */ class CcTxnIdFactory implements ITxnIdFactory { private static final int TXN_BLOCK_SIZE = 1024; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry
response: import java.util.concurrent.atomic.AtomicLong; import java.util.function.Supplier; import org.apache.asterix.common.transactions.ILongBlockFactory; import org.apache.asterix.common.transactions.ITxnIdFactory; import org.apache.asterix.common.transactions.TxnId; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Represents a factory to generate unique transaction IDs. */ class CcTxnIdFactory implements ITxnIdFactory { private static final int TXN_BLOCK_SIZE = 10; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry } } } }

sample: 951
buggy_code:  private static int TXN_BLOCK_SIZE = 10; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { <|startfocus|> // retry <|endfocus|> block = new Block(blockFactorySupplier.get().getBlock(TXN_BLOCK_SIZE), TXN_BLOCK_SIZE); } } } @Override public void ensureMinimumId(long id) throws AlgebricksException { blockFactorySupplier.get().ensureMinimum(id); } static class Block { private static final BlockExhaustedException BLOCK_EXHAUSTED_EXCEPTION = new BlockExhaustedException(); private final AtomicLong id; private final long start; private final long endExclusive; private Block(long start, long blockSize) { this.id = new AtomicLong(start); this.start = start;
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: private static int TXN_BLOCK_SIZE = 10; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry LOGGER.info("block exhausted; obtaining new block from supplier"); block = new Block(blockFactorySupplier.get().getBlock(TXN_BLOCK_SIZE), TXN_BLOCK_SIZE); } } } @Override public void ensureMinimumId(long id) throws AlgebricksException { blockFactorySupplier.get().ensureMinimum(id); } static class Block { private static final BlockExhaustedException BLOCK_EXHAUSTED_EXCEPTION = new BlockExhaustedException(); private final AtomicLong id; private final long start; private final long endExclusive; private Block(long start, long blockSize) { this.id = new AtomicLong(start); this.start = start;
response: private static int TXN_BLOCK_SIZE = 10; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { block = new Block(blockFactorySupplier.get().getBlock(TXN_BLOCK_SIZE), TXN_BLOCK_SIZE); } } } @Override public void ensureMinimumId(long id) throws AlgebricksException { blockFactorySupplier.get().ensureMinimum(id); } static class Block { private static final BlockExhaustedException BLOCK_EXHAUSTED_EXCEPTION = new BlockExhaustedException(); private final AtomicLong id; private final long start; private final long endExclusive; private Block(long start, long blockSize) { this.id = new AtomicLong(start); this.start = start; this.endExclusive = start + blockSize; } private long nextId() throws BlockExhaustedException { long currentId = id.getAndIncrement(); if (currentId >= endExclusive) { throw BLOCK_EXHAUSTED_EXCEPTION; } return currentId; } }

sample: 952
buggy_code:  } @Override public ActiveManager getActiveManager() { return activeManager; } @Override public ReplicationProperties getReplicationProperties() { return replicationProperties; } @Override public IReplicationChannel getReplicationChannel() { return replicationChannel; } @Override public IReplicationManager getReplicationManager() { return replicationManager; } @Override public ILibraryManager getLibraryManager() { return libraryManager; } @Override public void initializeMetadata(boolean newUniverse) throws Exception { <|startfocus|> Collection<IAsterixStateProxy> proxies; LOGGER.info("Bootstrapping metadata"); <|endfocus|> MetadataNode.INSTANCE.initialize(this, ncExtensionManager.getMetadataTupleTranslatorProvider(), ncExtensionManager.getMetadataExtensions()); //noinspection unchecked ConcurrentHashMap<CcId, IAsterixStateProxy> proxyMap = ((ConcurrentHashMap<CcId, IAsterixStateProxy>) getServiceContext().getDistributedState()); if (proxyMap == null) { throw new IllegalStateException("Metadata node cannot access distributed state"); } // This is a special case, we just give the metadataNode directly. // This way we can delay the registration of the metadataNode until // it is completely initialized.
code_review:  MAJOR SonarQube violation: Remove this unused "proxies" local variable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1481 
target code: } @Override public ActiveManager getActiveManager() { return activeManager; } @Override public ReplicationProperties getReplicationProperties() { return replicationProperties; } @Override public IReplicationChannel getReplicationChannel() { return replicationChannel; } @Override public IReplicationManager getReplicationManager() { return replicationManager; } @Override public ILibraryManager getLibraryManager() { return libraryManager; } @Override public void initializeMetadata(boolean newUniverse) throws Exception { IAsterixStateProxy proxy; if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Bootstrapping metadata"); } MetadataNode.INSTANCE.initialize(this, ncExtensionManager.getMetadataTupleTranslatorProvider(), ncExtensionManager.getMetadataExtensions()); //noinspection unchecked ConcurrentHashMap<CcId, IAsterixStateProxy> proxyMap = ((ConcurrentHashMap<CcId, IAsterixStateProxy>) getServiceContext().getDistributedState()); if (proxyMap == null) { throw new IllegalStateException("Metadata node cannot access distributed state"); } // This is a special case, we just give the metadataNode directly. // This way we can delay the registration of the metadataNode until // it is completely initialized.
response: } @Override public ActiveManager getActiveManager() { return activeManager; } @Override public ReplicationProperties getReplicationProperties() { return replicationProperties; } @Override public IReplicationChannel getReplicationChannel() { return replicationChannel; } @Override public IReplicationManager getReplicationManager() { return replicationManager; } @Override public ILibraryManager getLibraryManager() { return libraryManager; } @Override public void initializeMetadata(boolean newUniverse) throws Exception { LOGGER.info("Bootstrapping metadata"); MetadataNode.INSTANCE.initialize(this, ncExtensionManager.getMetadataTupleTranslatorProvider(), ncExtensionManager.getMetadataExtensions()); //noinspection unchecked ConcurrentHashMap<CcId, IAsterixStateProxy> proxyMap = ((ConcurrentHashMap<CcId, IAsterixStateProxy>) getServiceContext().getDistributedState()); if (proxyMap == null) { throw new IllegalStateException("Metadata node cannot access distributed state"); } // This is a special case, we just give the metadataNode directly. // This way we can delay the registration of the metadataNode until // it is completely initialized.

sample: 953
buggy_code:  return replicationManager; } @Override public ILibraryManager getLibraryManager() { return libraryManager; } @Override public void initializeMetadata(boolean newUniverse) throws Exception { Collection<IAsterixStateProxy> proxies; LOGGER.info("Bootstrapping metadata"); MetadataNode.INSTANCE.initialize(this, ncExtensionManager.getMetadataTupleTranslatorProvider(), ncExtensionManager.getMetadataExtensions()); <|startfocus|> //noinspection unchecked ConcurrentHashMap<CcId, IAsterixStateProxy> proxyMap = ((ConcurrentHashMap<CcId, IAsterixStateProxy>) getServiceContext().getDistributedState()); if (proxyMap == null) { <|endfocus|> throw new IllegalStateException("Metadata node cannot access distributed state"); } // This is a special case, we just give the metadataNode directly. // This way we can delay the registration of the metadataNode until // it is completely initialized. MetadataManager.initialize(proxyMap.values(), MetadataNode.INSTANCE); MetadataBootstrap.startUniverse(getServiceContext(), newUniverse); MetadataBootstrap.startDDLRecovery(); ncExtensionManager.initializeMetadata(getServiceContext()); LOGGER.info("Metadata node bound"); } @Override public synchronized void exportMetadataNodeStub() throws RemoteException {
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: return replicationManager; } @Override public ILibraryManager getLibraryManager() { return libraryManager; } @Override public void initializeMetadata(boolean newUniverse) throws Exception { Collection<IAsterixStateProxy> proxies; LOGGER.info("Bootstrapping metadata"); MetadataNode.INSTANCE.initialize(this, ncExtensionManager.getMetadataTupleTranslatorProvider(), ncExtensionManager.getMetadataExtensions()); proxy = (IAsterixStateProxy) getServiceContext().getDistributedState(); if (proxy == null) { throw new IllegalStateException("Metadata node cannot access distributed state"); } // This is a special case, we just give the metadataNode directly. // This way we can delay the registration of the metadataNode until // it is completely initialized. MetadataManager.initialize(proxyMap.values(), MetadataNode.INSTANCE); MetadataBootstrap.startUniverse(getServiceContext(), newUniverse); MetadataBootstrap.startDDLRecovery(); ncExtensionManager.initializeMetadata(getServiceContext()); LOGGER.info("Metadata node bound"); } @Override public synchronized void exportMetadataNodeStub() throws RemoteException {
response: private int indexOf(byte[] source, int sourceOffset, int sourceCount, byte[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex >= sourceCount) { return targetCount == 0 ? sourceCount : -1; } int from = fromIndex; if (from < 0) { from = 0; } if (targetCount == 0) { return fromIndex; } byte first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i <= max; i++) { if (source[i] != first) { while (++i <= max && source[i] != first) { ; } } if (i <= max) { int j = i + 1; int end = j + targetCount - 1; // Rest of the code } } // Rest of the code } public static IValueParserFactory[] getValueParserFactories(ARecordType recordType) { int n = recordType.getFieldTypes().length; IValueParserFactory[] fieldParserFactories = new IValueParserFactory[n]; for (int i = 0; i < n; i++) { ATypeTag tag = null; if (recordType.getFieldTypes()[i].getTypeTag() == ATypeTag.UNION) { AUnionType unionType = (AUnionType) recordType.getFieldTypes()[i]; if (!unionType.isNullableType()) { throw new NotImplementedException("Non-optional UNION type is not supported."); } tag = unionType.getActualType().getTypeTag(); } else { tag = recordType.getFieldTypes()[i].getTypeTag(); } if (tag == null) { throw new NotImplementedException("Failed to get the type information for field " + i + "."); } fieldParserFactories[i] = getParserFactory(tag); } return fieldParserFactories; } if (!typeTag.equals(ATypeTag.BOOLEAN)) { throw new AlgebricksException(AsterixBuiltinFunctions.EDIT_DISTANCE_STRING_IS_FILTERABLE.getName() + ": expects input type BOOLEAN as fourth argument, but got " + typeTag + "."); } boolean usePrePost = BooleanPointable.getBoolean

sample: 954
buggy_code:  } } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } catch (RemoteException e) { throw new RuntimeDataException(ErrorCode.REMOTE_EXCEPTION_WHEN_CALLING_METADATA_NODE, e); } super.init(); } } private static class NCMetadataManagerImpl extends MetadataManager { public NCMetadataManagerImpl(Collection<IAsterixStateProxy> proxies, IMetadataNode metadataNode) { super(proxies, metadataNode); } @Override <|startfocus|> public MetadataTransactionContext beginTransaction() throws RemoteException, ACIDException { <|endfocus|> TxnId txnId = new TxnId(metadataNode.reserveTxnIdBlock(1)); metadataNode.beginTransaction(txnId); return new MetadataTransactionContext(txnId); } } } 
code_review:  this is runtime, it doesn't have to be here 
target code: } } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } catch (RemoteException e) { throw new RuntimeDataException(ErrorCode.REMOTE_EXCEPTION_WHEN_CALLING_METADATA_NODE, e); } super.init(); } } private static class NCMetadataManagerImpl extends MetadataManager { public NCMetadataManagerImpl(Collection<IAsterixStateProxy> proxies, IMetadataNode metadataNode) { super(proxies, metadataNode); } @Override public MetadataTransactionContext beginTransaction() throws RemoteException { TxnId txnId = new TxnId(metadataNode.reserveTxnIdBlock(1)); metadataNode.beginTransaction(txnId); return new MetadataTransactionContext(txnId); } } }
response: import java.io.File; import java.util.ArrayList; import java.util.Collections; import java.util.List; import javax.annotation.Nonnull; public class LambdaNoGroupingShrinkTests { private File PROGUARD_SHRINK_NOTHING = new File(AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test044"), "shrink-nothing.flags"); private RuntimeTestInfo TEST001 = new RuntimeTestInfo(AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test044"), "com.android.jack.java8.lambda.test044.jack.Tests"); @Test public void testLamba040_whole() throws Exception { File lib = makeLibrary(new File[]{}, TEST001.directory); test(TEST001.jUnit, lib); } @Test @Runtime public void testLamba040_ByLib() throws Exception { File lib2 = makeLibrary(new File[]{}, new File(TEST001.directory, "lib2")); File lib1 = makeLibrary(new File[]{lib2}, new File(TEST001.directory, "lib1")); File libJack = makeLibrary(new File[]{lib2, lib1}, new File(TEST001.directory, "jack")); test(TEST001.jUnit, lib2, lib1, libJack); } @Test public void ltestLamba040_ByTestClass() throws Exception { File libs = makeLibrary(new File[]{}, new File(TEST001.directory, "lib1"), new File(TEST001.directory, "lib2")); File b2 = makeLibrary(new File[]{libs}, new File(TEST001.directory, "jack/B2.java")); File b3 = makeLibrary(new File[]{libs}, new File(TEST001.directory, "jack/B3.java")); File test = makeLibrary(new File[]{libs, b2, b3}); } private static class NCMetadataManagerImpl extends MetadataManager { public NCMetadataManagerImpl(Collection<IAsterixStateProxy> proxies, IMetadataNode metadataNode) { super(proxies, metadataNode); } @Override public MetadataTransactionContext beginTransaction() throws RemoteException, ACIDException { TxnId txnId = new TxnId(metadataNode.reserveTxnIdBlock(1)); metadataNode.beginTransaction(txnId); return new MetadataTransactionContext(txnId); } } }

sample: 955
buggy_code:  import java.util.concurrent.atomic.AtomicLong; import java.util.function.Supplier; import org.apache.asterix.common.transactions.ILongBlockFactory; import org.apache.asterix.common.transactions.ITxnIdFactory; import org.apache.asterix.common.transactions.TxnId; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Represents a factory to generate unique transaction IDs. */ <|startfocus|> /*package*/ class CcTxnIdFactory implements ITxnIdFactory { private static int TXN_BLOCK_SIZE = 10; <|endfocus|> private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry
code_review:  remove 
target code: import java.util.concurrent.atomic.AtomicLong; import java.util.function.Supplier; import org.apache.asterix.common.transactions.ILongBlockFactory; import org.apache.asterix.common.transactions.ITxnIdFactory; import org.apache.asterix.common.transactions.TxnId; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Represents a factory to generate unique transaction IDs. */ class CcTxnIdFactory implements ITxnIdFactory { private static final int TXN_BLOCK_SIZE = 1024; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry
response: import java.util.concurrent.atomic.AtomicLong; import java.util.function.Supplier; import org.apache.asterix.common.transactions.ILongBlockFactory; import org.apache.asterix.common.transactions.ITxnIdFactory; import org.apache.asterix.common.transactions.TxnId; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; class CcTxnIdFactory implements ITxnIdFactory { private static int TXN_BLOCK_SIZE = 10; private static final Logger LOGGER = LogManager.getLogger(); private final Supplier<ILongBlockFactory> blockFactorySupplier; private volatile Block block = new Block(0, 0); public CcTxnIdFactory(Supplier<ILongBlockFactory> blockFactorySupplier) { this.blockFactorySupplier = blockFactorySupplier; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry } } } }

sample: 956
buggy_code:  } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); <|startfocus|> if (messagingNetManager != null) { messagingNetManager.stop(); <|endfocus|> } workQueue.stop(); ncAppEntryPoint.stop(); /* * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; } 
code_review:  CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 
target code: } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); queue.stop(); if (ncAppEntryPoint != null) { ncAppEntryPoint.stop(); } workQueue.stop(); ncAppEntryPoint.stop(); /* * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; }
response: @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } workQueue.stop(); ncAppEntryPoint.stop(); /* * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; }

sample: 957
buggy_code:  } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } <|startfocus|> workQueue.stop(); ncAppEntryPoint.stop(); /* <|endfocus|> * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; } 
code_review:  use 
target code: } @Override public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } /** * Stop heartbeat after NC has stopped to avoid false node failure detection * on CC if an NC takes a long time to stop. */ heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; }
response: public synchronized void stop() throws Exception { if (!shuttedDown) { LOGGER.log(Level.INFO, "Stopping NodeControllerService"); executor.shutdownNow(); if (!executor.awaitTermination(10, TimeUnit.SECONDS)) { LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with abnormal shutdown"); } partitionManager.close(); datasetPartitionManager.close(); netManager.stop(); datasetNetworkManager.stop(); if (messagingNetManager != null) { messagingNetManager.stop(); } workQueue.stop(); ncAppEntryPoint.stop(); heartbeatTask.cancel(); LOGGER.log(Level.INFO, "Stopped NodeControllerService"); shuttedDown = true; } } public String getId() { return id; } public ServerContext getServerContext() { return serverCtx; } public Map<JobId, Joblet> getJobletMap() { return jobletMap; }

sample: 958
buggy_code:  // Scan diskInvertedIndexes ignoring the memoryInvertedIndex. // Create an inverted index instance. ILSMDiskComponent component = createDiskComponent(componentFactory, mergeOp.getTarget(), mergeOp.getDeletedKeysBTreeTarget(), mergeOp.getBloomFilterTarget(), true); ILSMDiskComponentBulkLoader componentBulkLoader; <|startfocus|> // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the inverted indexes so that // lsmHarness.endSearch() is called once when the inverted indexes have been merged. <|endfocus|> if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component is not included in the merge operation LSMInvertedIndexDeletedKeysBTreeMergeCursor btreeCursor = new LSMInvertedIndexDeletedKeysBTreeMergeCursor(opCtx); try { long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMInvertedIndexDiskComponent) mergeOp.getMergingComponents().get(i))
code_review:  MAJOR SonarQube violation: Split this 131 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: // Scan diskInvertedIndexes ignoring the memoryInvertedIndex. // Create an inverted index instance. ILSMDiskComponent component = createDiskComponent(componentFactory, mergeOp.getTarget(), mergeOp.getDeletedKeysBTreeTarget(), mergeOp.getBloomFilterTarget(), true); ILSMDiskComponentBulkLoader componentBulkLoader; // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the inverted // indexes so that lsmHarness.endSearch() is called once when the inverted indexes have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents .get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component is not included in the merge operation LSMInvertedIndexDeletedKeysBTreeMergeCursor btreeCursor = new LSMInvertedIndexDeletedKeysBTreeMergeCursor(opCtx); try { long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMInvertedIndexDiskComponent) mergeOp.getMergingComponents().get(i))
response: // Scan diskInvertedIndexes ignoring the memoryInvertedIndex. // Create an inverted index instance. ILSMDiskComponent component = createDiskComponent(componentFactory, mergeOp.getTarget(), mergeOp.getDeletedKeysBTreeTarget(), mergeOp.getBloomFilterTarget(), true); ILSMDiskComponentBulkLoader componentBulkLoader; // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the inverted indexes // so that lsmHarness.endSearch() is called once when the inverted indexes have been merged. if (mergeOp.getMergingComponents().get(mergeOp.getMergingComponents().size() - 1) != diskComponents.get(diskComponents.size() - 1)) { // Keep the deleted tuples since the oldest disk component is not included in the merge operation LSMInvertedIndexDeletedKeysBTreeMergeCursor btreeCursor = new LSMInvertedIndexDeletedKeysBTreeMergeCursor(opCtx); try { long numElements = 0L; for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) { numElements += ((LSMInvertedIndexDiskComponent) mergeOp.getMergingComponents().get(i)) .getBloomFilter().getNumElements(); } btreeCursor.open(mergeOp.getMergingComponents(), numElements); while (btreeCursor.hasNext()) { btreeCursor.next(); componentBulkLoader.delete(btreeCursor.getTuple()); } } finally { btreeCursor.close(); } }

sample: 959
buggy_code:  private boolean isOpen; <|startfocus|> private final Map<Long, List<StackTraceElement[]>> callers = new HashMap<>(); <|endfocus|> public Info() { referenceCount = 0; isOpen = false;
code_review:  MAJOR SonarQube violation: Remove this unused "LOGGER" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 
target code: private boolean isOpen; public Info() { referenceCount = 0; isOpen = false;
response: private boolean isOpen; private final Map<Long, List<StackTraceElement[]>> callers = new HashMap<>(); public Info() { referenceCount = 0; isOpen = false; }

sample: 960
buggy_code:  public void untouch() { long tid = Thread.currentThread().getId(); List<StackTraceElement[]> caller = callers.get(tid); if (caller == null || caller.isEmpty()) { throw new RuntimeException("Untouch of an untouched resource by thread: " + tid); } caller.remove(caller.size() - 1); <|startfocus|> --referenceCount; <|endfocus|>
code_review:  CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 
target code: public void untouch() { long tid = Thread.currentThread().getId(); List<StackTraceElement[]> caller = callers.get(tid); if (caller == null || caller.isEmpty()) { throw new RuntimeException("Untouch of an untouched resource by thread: " + tid); } caller.remove(caller.size() - 1); --referenceCount; if (referenceCount < 0) { throw new IllegalStateException("Unreferencing an unreferenced object"); }
response: public void untouch() { long tid = Thread.currentThread().getId(); List<StackTraceElement[]> caller = callers.get(tid); if (caller == null || caller.isEmpty()) { throw new IllegalStateException("Untouch of an untouched resource by thread: " + tid); } caller.remove(caller.size() - 1); --referenceCount; }

sample: 961
buggy_code:  public void touch() { long tid = Thread.currentThread().getId(); if (callers.containsKey(tid)) { LOGGER.log(Level.WARN, "\"Double touch of a resource by thread:" + tid + ". Previous call was from: " + Arrays.toString(callers.get(tid)) + ". This call is from: " + Arrays.toString(new Throwable().getStackTrace())); throw new RuntimeException("Double touch of a resource by thread: " + tid); } <|startfocus|> callers.put(tid, new Throwable().getStackTrace()); <|endfocus|> ++referenceCount;
code_review:  CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 
target code: public void touch() { long tid = Thread.currentThread().getId(); if (callers.containsKey(tid)) { LOGGER.log(Level.WARN, "\"Double touch of a resource by thread:" + tid + ". Previous call was from: " + Arrays.toString(callers.get(tid)) + ". This call is from: " + Arrays.toString(new Throwable().getStackTrace())); throw new RuntimeException("Double touch of a resource by thread: " + tid); } threads.add(new Throwable().getStackTrace()); ++referenceCount;
response: public void touch() { long tid = Thread.currentThread().getId(); if (callers.containsKey(tid)) { LOGGER.log(Level.WARN, "\"Double touch of a resource by thread:" + tid + ". Previous call was from: " + Arrays.toString(callers.get(tid)) + ". This call is from: " + Arrays.toString(new Throwable().getStackTrace())); throw new IllegalStateException("Double touch of a resource by thread: " + tid); } callers.put(tid, new Throwable().getStackTrace()); ++referenceCount; }

sample: 962
buggy_code:  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IDestroyable { /** * Destroy the object and releases any system resources associated * with it. If the object is already destroyed then invoking this * method has no effect. <|startfocus|> * All other calls after this method is invoked must throw exceptions <|endfocus|> * * @throws HyracksDataException */ void destroy() throws HyracksDataException; } 
code_review:  is undefined? seems like a strict contract to mandate throwing exceptions... 
target code: * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IDestroyable { /** * Destroy the object and releases any system resources associated * with it. If the object is already destroyed then invoking this * method has no effect. * All other calls after this method is invoked is undefined * * @throws HyracksDataException */ void destroy() throws HyracksDataException; }
response: package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IDestroyable { void destroy() throws HyracksDataException; }

sample: 963
buggy_code:  dest.add(context.newVar()); } } /** * Gets the primary key variables from the unnest-map or left-outer-unnest-map operator * that does a secondary index lookup. * The order: SK, PK, [Optional: the result of a TryLock on PK] */ public static List<LogicalVariable> getKeyVarsFromSecondaryUnnestMap(Dataset dataset, ARecordType recordType, <|startfocus|> ARecordType metaRecordType, ILogicalOperator unnestMapOp, Index index, int keyType, boolean outputPrimaryKeysOnlyFromSIdxSearch) throws AlgebricksException { <|endfocus|> int numPrimaryKeys; int numSecondaryKeys = KeyFieldTypeUtil.getNumSecondaryKeys(index, recordType, metaRecordType); if (dataset.getDatasetType() == DatasetType.EXTERNAL) { numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> keyVars = new ArrayList<>(); List<LogicalVariable> sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); // Assumption: the primary keys are located after the secondary key.
code_review:  let's create an enum for requested keys. 0,1,2 is not very informative 
target code: dest.add(context.newVar()); } } /** * Gets the primary key variables from the unnest-map or left-outer-unnest-map operator * that does a secondary index lookup. * The order: SK, PK, [Optional: the result of a TryLock on PK] */ public static List<LogicalVariable> getKeyVarsFromSecondaryUnnestMap(Dataset dataset, ARecordType recordType, ARecordType metaRecordType, ILogicalOperator unnestMapOp, Index index, secondaryUnnestMapOutputVarType keyVarType) throws AlgebricksException { int numPrimaryKeys; int numSecondaryKeys = KeyFieldTypeUtil.getNumSecondaryKeys(index, recordType, metaRecordType); if (dataset.getDatasetType() == DatasetType.EXTERNAL) { numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> keyVars = new ArrayList<>(); List<LogicalVariable> sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); // Assumption: the primary keys are located after the secondary key.
response: dest.add(context.newVar()); } } /** * Gets the primary key variables from the unnest-map or left-outer-unnest-map operator * that does a secondary index lookup. * The order: SK, PK, [Optional: the result of a TryLock on PK] */ public static List<LogicalVariable> getKeyVarsFromSecondaryUnnestMap(Dataset dataset, ARecordType recordType, ARecordType metaRecordType, ILogicalOperator unnestMapOp, Index index, KeyType keyType, boolean outputPrimaryKeysOnlyFromSIdxSearch) throws AlgebricksException { int numPrimaryKeys; int numSecondaryKeys = KeyFieldTypeUtil.getNumSecondaryKeys(index, recordType, metaRecordType); if (dataset.getDatasetType() == DatasetType.EXTERNAL) { numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> keyVars = new ArrayList<>(); List<LogicalVariable> sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); // Assumption: the primary keys are located after the secondary key.

sample: 964
buggy_code:  numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> keyVars = new ArrayList<>(); List<LogicalVariable> sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); // Assumption: the primary keys are located after the secondary key. int start; int stop; <|startfocus|> // If a secondary-index search didn't generate SKs if (outputPrimaryKeysOnlyFromSIdxSearch) { <|endfocus|> numSecondaryKeys = 0; } // Fetches keys: type 0 - PK, type 1 - SK, type 2 - the result of instantTryLock() on PK switch (keyType) { case 0: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case 1: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case 2: // Fetches conditional splitter - the last position
code_review:  it's a bit strange that we need do cannot tell this information from the operator itself, but instead rely on the function parameter. I think currently outputPrimaryKeysOnlyFromSIdxSearch is set to true only for inverted indexes. can we just set it here by looking at the index type instead? 
target code: numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> keyVars = new ArrayList<>(); List<LogicalVariable> sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); // Assumption: the primary keys are located after the secondary key. int start; int stop; // If a secondary-index search didn't generate SKs, set it to zero. // Currently, only an inverted-index search doesn't generate any SKs. boolean isNgramOrKeywordIndex = isInvertedIndex(index); if (isNgramOrKeywordIndex) { numSecondaryKeys = 0; } // Fetches keys: type 0 - PK, type 1 - SK, type 2 - the result of instantTryLock() on PK switch (keyType) { case 0: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case 1: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case 2: // Fetches conditional splitter - the last position
response: numPrimaryKeys = IndexingConstants.getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> keyVars = new ArrayList<>(); List<LogicalVariable> sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); int start; int stop; if (outputPrimaryKeysOnlyFromSIdxSearch) { numSecondaryKeys = 0; } switch (keyType) { case 0: start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case 1: start = 0; stop = numSecondaryKeys; break; case 2: start = numSecondaryKeys + numPrimaryKeys; stop = sourceVars.size(); break; default: throw new IllegalArgumentException("Invalid key type: " + keyType); }

sample: 965
buggy_code:  switch (keyType) { case 0: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case 1: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case 2: // Fetches conditional splitter - the last position start = numSecondaryKeys + numPrimaryKeys; <|startfocus|> stop = sourceVars.size(); <|endfocus|> break; default: return Collections.emptyList(); } for (int i = start; i < stop; i++) { keyVars.add(sourceVars.get(i)); } return keyVars; } public static List<LogicalVariable> getPrimaryKeyVarsFromSecondaryUnnestMap(Dataset dataset, ILogicalOperator unnestMapOp) { int numPrimaryKeys; if (dataset.getDatasetType() == DatasetType.EXTERNAL) { numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> primaryKeyVars = new ArrayList<>();
code_review:  should we just set stop = start + 1 here? sourceVars might have more variables if propagateIndexFilter = true 
target code: switch (keyType) { case 0: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case 1: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case 2: // Fetches conditional splitter - the last position start = numSecondaryKeys + numPrimaryKeys; stop = start + 1; break; default: return Collections.emptyList(); } for (int i = start; i < stop; i++) { keyVars.add(sourceVars.get(i)); } return keyVars; } public static List<LogicalVariable> getPrimaryKeyVarsFromSecondaryUnnestMap(Dataset dataset, ILogicalOperator unnestMapOp) { int numPrimaryKeys; if (dataset.getDatasetType() == DatasetType.EXTERNAL) { numPrimaryKeys = IndexingConstants .getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> primaryKeyVars = new ArrayList<>();
response: switch (keyType) { case 0: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case 1: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case 2: // Fetches conditional splitter - the last position start = numSecondaryKeys + numPrimaryKeys; stop = sourceVars.size(); break; default: return Collections.emptyList(); } for (int i = start; i < stop; i++) { keyVars.add(sourceVars.get(i)); } return keyVars; } public static List<LogicalVariable> getPrimaryKeyVarsFromSecondaryUnnestMap(Dataset dataset, ILogicalOperator unnestMapOp) { int numPrimaryKeys; if (dataset.getDatasetType() == DatasetType.EXTERNAL) { numPrimaryKeys = IndexingConstants.getRIDSize(((ExternalDatasetDetails) dataset.getDatasetDetails()).getProperties()); } else { numPrimaryKeys = dataset.getPrimaryKeys().size(); } List<LogicalVariable> primaryKeyVars = new ArrayList<>(); primaryKeyVars.addAll(getKeyVars(unnestMapOp, numPrimaryKeys, numPrimaryKeys, numPrimaryKeys + 1)); return primaryKeyVars; }

sample: 966
buggy_code:  // If the constant type and target type does not match, we may need to do a type conversion. if (constantValueTag != indexedFieldTypeTag && constantValue != null) { // To check whether the constant is REAL values, and target field is an INT type field. // In this case, we need to change the search parameter. Refer to the caller section for the detail. realTypeConvertedToIntegerType = isRealTypeConvertedToIntegerType(constantValueTag, indexedFieldTypeTag); <|startfocus|> if (realTypeConvertedToIntegerType) { <|endfocus|> // For the index on a closed-type field, // if a DOUBLE or FLOAT constant is converted to an INT type value, // we need to check a corner case where two real values are located // between an INT value. For example, the following query, // // for $emp in dataset empDataset // where $emp.age > double("2.3") and $emp.age < double("3.3") // return $emp.id; //
code_review:  1) it seems like this floor/ceil conversion is needed for index on closed-field (as the comment below indicates). For other indexes relaxing condition from < to <= would still work fine as before. So can we limit it to this case by changing this condition to "realTypeConvertedToIntegerType && !index.isEnforced() && !index.isOverridingKeyFieldTypes()" 2) The precision loss is also possible when converting a large BIGINT to FLOAT/DOUBLE. I wonder whether we need to deal with this in the new code? 
target code: // If the constant type and target type does not match, we may need to do a type conversion. if (constantValueTag != indexedFieldTypeTag && constantValue != null) { // To check whether the constant is REAL values, and target field is an INT type field. // In this case, we need to change the search parameter. Refer to the caller section for the detail. realTypeConvertedToIntegerType = isRealTypeConvertedToIntegerType(constantValueTag, indexedFieldTypeTag); if (realTypeConvertedToIntegerType && !index.isEnforced() && !index.isOverridingKeyFieldTypes()) { // For the index on a closed-type field, // if a DOUBLE or FLOAT constant is converted to an INT type value, // we need to check a corner case where two real values are located // between an INT value. For example, the following query, // // for $emp in dataset empDataset // where $emp.age > double("2.3") and $emp.age < double("3.3") // return $emp.id; //
response: // If the constant type and target type does not match, we may need to do a type conversion. if (constantValueTag != indexedFieldTypeTag && constantValue != null) { // To check whether the constant is REAL values, and target field is an INT type field. // In this case, we need to change the search parameter. Refer to the caller section for the detail. realTypeConvertedToIntegerType = isRealTypeConvertedToIntegerType(constantValueTag, indexedFieldTypeTag); if (realTypeConvertedToIntegerType) { // For the index on a closed-type field, // if a DOUBLE or FLOAT constant is converted to an INT type value, // we need to check a corner case where two real values are located // between an INT value. For example, the following query, // // for $emp in dataset empDataset // where $emp.age > double("2.3") and $emp.age < double("3.3") // return $emp.id; // // 1) it seems like this floor/ceil conversion is needed for index on closed-field // (as the comment below indicates). For other indexes relaxing condition from < to <= // would still work fine as before. So can we limit it to this case by changing this condition to // "realTypeConvertedToIntegerType && !index.isEnforced() && !index.isOverridingKeyFieldTypes()" // 2) The precision loss is also possible when converting a large BIGINT to FLOAT/DOUBLE. // I wonder whether we need to deal with this in the new code? } }

sample: 967
buggy_code:  mathFunctionTypeForNumericTypeCasting); break; case EQ: // equality case - both CEIL and FLOOR need to be applied. replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.FLOOR); replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; default: break; } <|startfocus|> } // Type conversion only case: (e.g., INT -> BIGINT) if (mathFunctionTypeForNumericTypeCasting == TypeCastingMathFunctionType.NONE) { <|endfocus|> replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); } } // No type-casting at all if (replacedConstantValue == null) { return new Triple<>(constantAtRuntimeExpression, null, false); } // A type-casting happened, but not EQ case if (replacedConstantValueForEQCase == null) {
code_review:  throw IllegalStateException here. NEQ is not expected here. 
target code: mathFunctionTypeForNumericTypeCasting); break; case EQ: // equality case - both CEIL and FLOOR need to be applied. replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.FLOOR); replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; default: break; } } else if (!realTypeConvertedToIntegerType) { // Type conversion only case: (e.g., INT -> BIGINT) replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); } } // No type-casting at all if (replacedConstantValue == null) { return new Triple<>(constantAtRuntimeExpression, null, false); } // A type-casting happened, but not EQ case if (replacedConstantValueForEQCase == null) {
response: public void processMathFunction(TypeCastingMathFunctionType mathFunctionTypeForNumericTypeCasting) { switch (mathFunctionTypeForNumericTypeCasting) { case CEIL: replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; case FLOOR: replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.FLOOR); break; case EQ: replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.FLOOR); replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; default: break; } if (mathFunctionTypeForNumericTypeCasting == TypeCastingMathFunctionType.NONE) { replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); } if (replacedConstantValue == null) { return new Triple<>(constantAtRuntimeExpression, null, false); } if (replacedConstantValueForEQCase == null) { throw new IllegalStateException("NEQ is not expected here."); } }

sample: 968
buggy_code:  replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; default: break; } } // Type conversion only case: (e.g., INT -> BIGINT) if (mathFunctionTypeForNumericTypeCasting == TypeCastingMathFunctionType.NONE) { replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); } <|startfocus|> <|endfocus|> } // No type-casting at all if (replacedConstantValue == null) { return new Triple<>(constantAtRuntimeExpression, null, false); } // A type-casting happened, but not EQ case if (replacedConstantValueForEQCase == null) { return new Triple<>(new ConstantExpression(replacedConstantValue), null, realTypeConvertedToIntegerType); } // A type-casting happened and it's an EQ case. return new Triple<>(new ConstantExpression(replacedConstantValue), new ConstantExpression(replacedConstantValueForEQCase), realTypeConvertedToIntegerType); }
code_review:  this should probably be "else if" from the previous "if" because mathFunctionTypeForNumericTypeCasting is assigned there to CEIL/FLOOR. Also the EQ case is weird because it does not assign mathFunctionTypeForNumericTypeCasting and therefore causes this if statement to run which will reassign replacedConstantValue. I think this problem would go away if we make this "else if" and we'll no longer need variable for mathFunctionTypeForNumericTypeCasting because it won't be used outside of the switch. 
target code: replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; default: break; } } // Type conversion only case: (e.g., INT -> BIGINT) if (mathFunctionTypeForNumericTypeCasting == TypeCastingMathFunctionType.NONE) { replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); } } // No type-casting at all if (replacedConstantValue == null) { return new Triple<>(constantAtRuntimeExpression, null, false); } // A type-casting happened, but not EQ case if (replacedConstantValueForEQCase == null) { return new Triple<>(new ConstantExpression(replacedConstantValue), null, realTypeConvertedToIntegerType); } // A type-casting happened and it's an EQ case. return new Triple<>(new ConstantExpression(replacedConstantValue), new ConstantExpression(replacedConstantValueForEQCase), realTypeConvertedToIntegerType); }
response: replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.CEIL); break; else if (mathFunctionTypeForNumericTypeCasting == TypeCastingMathFunctionType.NONE) { replacedConstantValue = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); } else if (replacedConstantValue == null) { return new Triple<>(constantAtRuntimeExpression, null, false); } else if (replacedConstantValueForEQCase == null) { return new Triple<>(new ConstantExpression(replacedConstantValue), null, realTypeConvertedToIntegerType); } else { return new Triple<>(new ConstantExpression(replacedConstantValue), new ConstantExpression(replacedConstantValueForEQCase), realTypeConvertedToIntegerType); }

sample: 969
buggy_code:  private final String nodeId; private final List<INCLifecycleTask> tasks; public RegistrationTasksResponseMessage(String nodeId, List<INCLifecycleTask> tasks) { this.nodeId = nodeId; this.tasks = tasks; } @Override public void handle(INcApplicationContext appCtx) throws HyracksDataException, InterruptedException { INCMessageBroker broker = (INCMessageBroker) appCtx.getServiceContext().getMessageBroker(); IControllerService cs = appCtx.getServiceContext().getControllerService(); <|startfocus|> cs.getExecutor().submit(() -> { boolean success = true; <|endfocus|> try { Throwable exception = null; try { for (INCLifecycleTask task : tasks) { if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Starting startup task: " + task); } task.perform(getCcId(), cs); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Completed startup task: " + task); } } } catch (Throwable e) { //NOSONAR all startup failures should be reported to CC LOGGER.log(Level.ERROR, "Failed during startup task", e);
code_review:  MAJOR SonarQube violation: Reduce this lambda expression number of lines from 33 to at most 20. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 
target code: private final String nodeId; private final List<INCLifecycleTask> tasks; public RegistrationTasksResponseMessage(String nodeId, List<INCLifecycleTask> tasks) { this.nodeId = nodeId; this.tasks = tasks; } @Override public void handle(INcApplicationContext appCtx) throws HyracksDataException, InterruptedException { INCMessageBroker broker = (INCMessageBroker) appCtx.getServiceContext().getMessageBroker(); IControllerService cs = appCtx.getServiceContext().getControllerService(); boolean success = true; try { Throwable exception = null; try { Throwable exception = null; try { for (INCLifecycleTask task : tasks) { if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Starting startup task: " + task); } task.perform(getCcId(), cs); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Completed startup task: " + task); } } } catch (Throwable e) { //NOSONAR all startup failures should be reported to CC LOGGER.log(Level.ERROR, "Failed during startup task", e);
response: private final String nodeId; private final List<INCLifecycleTask> tasks; public RegistrationTasksResponseMessage(String nodeId, List<INCLifecycleTask> tasks) { this.nodeId = nodeId; this.tasks = tasks; } @Override public void handle(INcApplicationContext appCtx) throws HyracksDataException, InterruptedException { INCMessageBroker broker = (INCMessageBroker) appCtx.getServiceContext().getMessageBroker(); IControllerService cs = appCtx.getServiceContext().getControllerService(); cs.getExecutor().submit(() -> { boolean success = true; try { Throwable exception = null; try { for (INCLifecycleTask task : tasks) { if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Starting startup task: " + task); } task.perform(getCcId(), cs); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Completed startup task: " + task); } } } catch (Throwable e) { LOGGER.log(Level.ERROR, "Failed during startup task", e); exception = e; } if (exception != null) { success = false; broker.sendApplicationMessageToCC(new RegistrationTasksResponseMessage(nodeId, tasks), nodeId); } } catch (Exception e) { LOGGER.log(Level.ERROR, "Failed to send registration tasks response message to CC", e); } }); }

sample: 970
buggy_code: class CachingTxnIdFactory implements ITxnIdFactory { private static final Logger LOGGER = LogManager.getLogger(); private final INcApplicationContext appCtx; private volatile Block block = new Block(0, 0); public CachingTxnIdFactory(INcApplicationContext appCtx) { this.appCtx = appCtx; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry LOGGER.info("block exhausted; obtaining new block from supplier"); <|startfocus|> TxnIdBlockRequestMessage.Block newBlock; <|endfocus|> try { newBlock = TxnIdBlockRequestMessage.send(appCtx); } catch (HyracksDataException e) { throw new AlgebricksException(e); } block = new Block(newBlock.getStartingId(), newBlock.getBlockSize()); } } } @Override public void ensureMinimumId(long id) throws AlgebricksException { throw new UnsupportedOperationException(); } @Override public long getIdBlock(int blockSize) { throw new UnsupportedOperationException(); } @Override
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: class CachingTxnIdFactory implements ITxnIdFactory { private static final Logger LOGGER = LogManager.getLogger(); private final INcApplicationContext appCtx; private volatile Block block = new Block(0, 0); public CachingTxnIdFactory(INcApplicationContext appCtx) { this.appCtx = appCtx; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { // retry LOGGER.info("block exhausted; obtaining new block from supplier"); TxnIdBlockRequest.Block newBlock; try { newBlock = TxnIdBlockRequestMessage.send(appCtx); } catch (HyracksDataException e) { throw new AlgebricksException(e); } block = new Block(newBlock.getStartingId(), newBlock.getBlockSize()); } } } @Override public void ensureMinimumId(long id) throws AlgebricksException { throw new UnsupportedOperationException(); } @Override public long getIdBlock(int blockSize) { throw new UnsupportedOperationException(); } @Override
response: class CachingTxnIdFactory implements ITxnIdFactory { private static final Logger LOGGER = LogManager.getLogger(); private final INcApplicationContext appCtx; private volatile Block block = new Block(0, 0); public CachingTxnIdFactory(INcApplicationContext appCtx) { this.appCtx = appCtx; } @Override public TxnId create() throws AlgebricksException { while (true) { try { return new TxnId(block.nextId()); } catch (BlockExhaustedException ex) { LOGGER.info("block exhausted; obtaining new block from supplier"); TxnIdBlockRequestMessage.Block newBlock; try { newBlock = TxnIdBlockRequestMessage.send(appCtx); } catch (HyracksDataException e) { throw new AlgebricksException(e); } block = new Block(newBlock.getStartingId(), newBlock.getBlockSize()); } } } @Override public void ensureMinimumId(long id) throws AlgebricksException { throw new UnsupportedOperationException(); } @Override public long getIdBlock(int blockSize) { throw new UnsupportedOperationException(); } }

sample: 971
buggy_code:  ((ClusterControllerService) appCtx.getServiceContext().getControllerService()).getJobIdFactory() .setMaxJobId(maxJobId); } public static void send(CcId ccId, NodeControllerService ncs) throws HyracksDataException { INcApplicationContext appContext = (INcApplicationContext) ncs.getApplicationContext(); long maxResourceId = Math.max(appContext.getLocalResourceRepository().maxId(), MetadataIndexImmutableProperties.FIRST_AVAILABLE_USER_DATASET_ID); <|startfocus|> long maxTxnId = Math.max(appContext.getMaxTxnId(), appContext.getTransactionSubsystem().getTransactionManager().getMaxTxnId()); <|endfocus|> long maxJobId = ncs.getMaxJobId(ccId); ReportLocalCountersMessage countersMessage = new ReportLocalCountersMessage(ncs.getId(), maxResourceId, maxTxnId, maxJobId); try { ((INCMessageBroker) ncs.getContext().getMessageBroker()).sendMessageToCC(ccId, countersMessage); } catch (Exception e) { LOGGER.log(Level.ERROR, "Unable to report local counters", e); throw HyracksDataException.create(e); } } @Override public String toString() { return ReportLocalCountersMessage.class.getSimpleName(); } } 
code_review:  Let's do the max in NCAppRuntimeContext itself so that this logic will be centralized there instead of this msg. In there, you will need to check if (txnSubsystem == null) and throw IllegalStateException if it is the case to prevent someone from calling getMaxTxnId before TransactionSubsystem is initialized. 
target code: ((ClusterControllerService) appCtx.getServiceContext().getControllerService()).getJobIdFactory() .setMaxJobId(maxJobId); } public static void send(CcId ccId, NodeControllerService ncs) throws HyracksDataException { INcApplicationContext appContext = (INcApplicationContext) ncs.getApplicationContext(); long maxResourceId = Math.max(appContext.getLocalResourceRepository().maxId(), MetadataIndexImmutableProperties.FIRST_AVAILABLE_USER_DATASET_ID); long maxTxnId = appContext.getMaxTxnId(); long maxJobId = ncs.getMaxJobId(ccId); ReportLocalCountersMessage countersMessage = new ReportLocalCountersMessage(ncs.getId(), maxResourceId, maxTxnId, maxJobId); try { ((INCMessageBroker) ncs.getContext().getMessageBroker()).sendMessageToCC(ccId, countersMessage); } catch (Exception e) { LOGGER.log(Level.ERROR, "Unable to report local counters", e); throw HyracksDataException.create(e); } } @Override public String toString() { return ReportLocalCountersMessage.class.getSimpleName(); } }
response: ((ClusterControllerService) appCtx.getServiceContext().getControllerService()).getJobIdFactory() .setMaxJobId(maxJobId); public static void send(CcId ccId, NodeControllerService ncs) throws HyracksDataException { INcApplicationContext appContext = (INcApplicationContext) ncs.getApplicationContext(); long maxResourceId = Math.max(appContext.getLocalResourceRepository().maxId(), MetadataIndexImmutableProperties.FIRST_AVAILABLE_USER_DATASET_ID); long maxTxnId = Math.max(appContext.getMaxTxnId(), appContext.getTransactionSubsystem().getTransactionManager().getMaxTxnId()); long maxJobId = ncs.getMaxJobId(ccId); ReportLocalCountersMessage countersMessage = new ReportLocalCountersMessage(ncs.getId(), maxResourceId, maxTxnId, maxJobId); try { ((INCMessageBroker) ncs.getContext().getMessageBroker()).sendMessageToCC(ccId, countersMessage); } catch (Exception e) { LOGGER.log(Level.ERROR, "Unable to report local counters", e); throw HyracksDataException.create(e); } } @Override public String toString() { return ReportLocalCountersMessage.class.getSimpleName(); }

sample: 972
buggy_code:  public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { // Do nothing <|endfocus|> } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable ignore) { // NOSONAR Logging exception will be ignored // NOSONAR ignore } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Exception e) { try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", e); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, e); } } return root; }

sample: 973
buggy_code:  public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { // Do nothing <|endfocus|> } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable ignore) { // NOSONAR Logging exception will be ignored // NOSONAR ignore } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 974
buggy_code:  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; <|startfocus|> <|endfocus|> public interface IDestroyable { /** * Destroy the object and releases any system resources associated * with it. If the object is already destroyed then invoking this * method has no effect. * All other calls after this method is invoked is undefined * * @throws HyracksDataException */ void destroy() throws HyracksDataException; } 
code_review:  @FunctionalInterface 
target code: * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; @FunctionalInterface public interface IDestroyable { /** * Destroy the object and releases any system resources associated * with it. If the object is already destroyed then invoking this * method has no effect. * All other calls after this method is invoked is undefined * * @throws HyracksDataException */ void destroy() throws HyracksDataException; }
response: @FunctionalInterface public interface IDestroyable { void destroy() throws HyracksDataException; }

sample: 975
buggy_code:  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IDestroyable { /** * Destroy the object and releases any system resources associated * with it. If the object is already destroyed then invoking this * method has no effect. <|startfocus|> * All other calls after this method is invoked is undefined <|endfocus|> * * @throws HyracksDataException */ void destroy() throws HyracksDataException; } 
code_review:  The behavior of 
target code: * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IDestroyable { /** * Destroy the object and releases any system resources associated * with it. If the object is already destroyed then invoking this * method has no effect. * The behavior of other calls after this method is invoked is undefined * * @throws HyracksDataException */ void destroy() throws HyracksDataException; }
response: package org.apache.hyracks.api.dataflow; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IDestroyable { void destroy() throws HyracksDataException; }

sample: 976
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { <|endfocus|> // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Exception e) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", e); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, e); } } return root; }

sample: 977
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { <|endfocus|> // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 978
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // Do nothing } } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 979
buggy_code:  public static Throwable close(List<IIndexDataflowHelper> indexHelpers, Throwable root) { for (int i = 0; i < indexHelpers.size(); i++) { <|startfocus|> root = close(indexHelpers, root); <|endfocus|> } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable close(List<IIndexDataflowHelper> indexHelpers, Throwable root) { for (int i = 0; i < indexHelpers.size(); i++) { root = close(indexHelpers.get(i), root); } return root;
response: public static Throwable close(List<IIndexDataflowHelper> indexHelpers, Throwable root) { for (int i = 0; i < indexHelpers.size(); i++) { root = close(indexHelpers, root); } return root; }

sample: 980
buggy_code:  reusablePred.setHighKeyComparator(predicate.getHighKeyComparator()); includeMutableComponent = false; int numBTrees = operationalComponents.size(); if (rangeCursors == null) { // object creation: should be relatively low rangeCursors = new IIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; } else if (rangeCursors.length != numBTrees) { // should destroy first Throwable failure = ExceptionUtils.suppress(DestroyUtils.destroy(btreeAccessors), DestroyUtils.destroy(rangeCursors)); <|startfocus|> if (failure != null) { throw HyracksDataException.create(failure); } <|endfocus|> rangeCursors = new IIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; } for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree; if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; } btree = (BTree) component.getIndex(); if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); rangeCursors[i] = btreeAccessors[i].createSearchCursor(false);
code_review:  throw if not null? 
target code: reusablePred.setHighKeyComparator(predicate.getHighKeyComparator()); includeMutableComponent = false; int numBTrees = operationalComponents.size(); if (rangeCursors == null) { // object creation: should be relatively low rangeCursors = new IIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; } else if (rangeCursors.length != numBTrees) { // should destroy first Throwable failure = ExceptionUtils.suppress(DestroyUtils.destroy(btreeAccessors), DestroyUtils.destroy(rangeCursors)); HyracksDataException.throwIfNotNull(failure); rangeCursors = new IIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; } for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree; if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; } btree = (BTree) component.getIndex(); if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); rangeCursors[i] = btreeAccessors[i].createSearchCursor(false);
response: reusablePred.setHighKeyComparator(predicate.getHighKeyComparator()); includeMutableComponent = false; int numBTrees = operationalComponents.size(); if (rangeCursors == null) { rangeCursors = new IIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; } else if (rangeCursors.length != numBTrees) { Throwable failure = ExceptionUtils.suppress(DestroyUtils.destroy(btreeAccessors), DestroyUtils.destroy(rangeCursors)); if (failure != null) { throw HyracksDataException.create(failure); } rangeCursors = new IIndexCursor[numBTrees]; btreeAccessors = new BTreeAccessor[numBTrees]; } for (int i = 0; i < numBTrees; i++) { ILSMComponent component = operationalComponents.get(i); BTree btree; if (component.getType() == LSMComponentType.MEMORY) { includeMutableComponent = true; } btree = (BTree) component.getIndex(); if (btreeAccessors[i] == null) { btreeAccessors[i] = btree.createAccessor(NoOpIndexAccessParameters.INSTANCE); rangeCursors[i] = btreeAccessors[i].createSearchCursor(false); } }

sample: 981
buggy_code:  try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { <|startfocus|> throw closeException; <|endfocus|> } } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); } } 
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "failure". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { throw HyracksDataException.create(closeException); } } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); } }
response: try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { throw closeException; } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); }

sample: 982
buggy_code:  indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { <|startfocus|> throw closeException; <|endfocus|> } } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); } } 
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "failure". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { throw HyracksDataException.create(closeException); } } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); } }
response: indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { throw closeException; } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); }

sample: 983
buggy_code:  } } try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { <|startfocus|> throw closeException; <|endfocus|> } } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); } } 
code_review:  MAJOR SonarQube violation: Remove this useless assignment to local variable "failure". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 
target code: } } try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } } try { // will definitely be called regardless of exceptions writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { throw HyracksDataException.create(closeException); } } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); } }
response: } try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } try { writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = new HyracksDataException(th); } else { closeException.addSuppressed(th); } } if (closeException != null) { throw closeException; } @Override public void doFail() throws HyracksDataException { failed = true; writer.fail(); }

sample: 984
buggy_code:  .getLongValue()); file.setLastModefiedTime(new Date( ((ADateTime) externalFileRecord.getValueByPos(FilesIndexDescription.EXTERNAL_FILE_MOD_DATE_FIELD_INDEX)) .getChrononTime())); } public void close() throws HyracksDataException { Throwable failure = ResourceReleaseUtils.close(fileIndexSearchCursor, null); failure = DestroyUtils.destroy(fileIndexSearchCursor, failure); failure = DestroyUtils.destroy(fileIndexAccessor, failure); failure = ResourceReleaseUtils.close(indexDataflowHelper, failure); <|startfocus|> if (failure != null) { throw HyracksDataException.create(failure); } <|endfocus|> } } 
code_review:  HyracksDataException.throwIfNotNull(failure);? 
target code: .getLongValue()); file.setLastModefiedTime(new Date( ((ADateTime) externalFileRecord.getValueByPos(FilesIndexDescription.EXTERNAL_FILE_MOD_DATE_FIELD_INDEX)) .getChrononTime())); } public void close() throws HyracksDataException { Throwable failure = ResourceReleaseUtils.close(fileIndexSearchCursor, null); failure = DestroyUtils.destroy(fileIndexSearchCursor, failure); failure = DestroyUtils.destroy(fileIndexAccessor, failure); failure = ResourceReleaseUtils.close(indexDataflowHelper, failure); HyracksDataException.throwIfNotNull(failure); } }
response: import org.apache.hyracks.data.std.primitive.VoidPointable; public class IntervalLogic implements Serializable { private static final long serialVersionUID = 1L; private final ComparisonHelper ch = new ComparisonHelper(); private final IPointable s1 = VoidPointable.FACTORY.createPointable(); private final IPointable e1 = VoidPointable.FACTORY.createPointable(); private final IPointable s2 = VoidPointable.FACTORY.createPointable(); private final IPointable e2 = VoidPointable.FACTORY.createPointable(); public boolean validateInterval(AIntervalPointable ip1) throws HyracksDataException { ip1.getStart(s1); ip1.getEnd(e1); return ch.compare(ip1.getTypeTag(), ip1.getTypeTag(), s1, e1) <= 0; } public boolean before(AIntervalPointable ip1, AIntervalPointable ip2) throws AsterixException { ip1.getEnd(e1); ip2.getStart(s2); // rest of the code... } } callback.afterFinalize(LSMOperationType.MERGE, null); return; } fullMergeIsRequested.set(false); lsmIndex.scheduleMerge(ctx, callback); } @Override public void merge(ILSMIndexOperationContext ctx, ILSMIOOperation operation) throws HyracksDataException, IndexException { if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Started a merge operation for index: " + lsmIndex + " ..."); } ILSMDiskComponent newComponent = null; try { newComponent = lsmIndex.merge(operation); operation.getCallback().afterOperation(LSMOperationType.MERGE, ctx.getComponentHolder(), newComponent); lsmIndex.markAsValid(newComponent); } catch (Throwable e) { e.printStackTrace(); throw e; } finally { exitComponents(ctx, LSMOperationType.MERGE, newComponent, false); operation.getCallback().afterFinalize(LSMOperationType.MERGE, newComponent); } if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Finished the merge operation for index: " + lsmIndex); } } @Override public void addBulkLoadedComponent(IDiskComponent c) throws HyracksDataException, IndexException { lsmIndex.markAsValid(c); } for (ExternalFile

sample: 985
buggy_code:  public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { // Do nothing <|endfocus|> } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  ignore 
target code: public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable ignore) { // NOSONAR Logging exception will be ignored // NOSONAR ignore } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(ITupleForwarder tupleForwarder, Throwable root) { if (tupleForwarder != null) { try { tupleForwarder.close(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 986
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { <|endfocus|> // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  ignore 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 987
buggy_code:  try { rangeCursors[i].destroy(); } catch (Throwable th) { // NOSONAR. Must destroy all cursors failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { // NOSONAR. Don't lose the root cause failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; <|startfocus|> if (failure != null) { throw HyracksDataException.create(failure); } <|endfocus|> } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } private class PriorityQueueScanComparator extends PriorityQueueComparator { public PriorityQueueScanComparator(MultiComparator cmp) { super(cmp); } @Override public int compare(PriorityQueueElement elementA, PriorityQueueElement elementB) { int result; try { result = cmp.compare(elementA.getTuple(), elementB.getTuple()); if (result != 0) { return result; }
code_review:  throwIfNotNull 
target code: try { rangeCursors[i].destroy(); } catch (Throwable th) { // NOSONAR. Must destroy all cursors failure = ExceptionUtils.suppress(failure, th); } } rangeCursors = null; } try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { // NOSONAR. Don't lose the root cause failure = ExceptionUtils.suppress(failure, th); } } foundNext = false; HyracksDataException.throwIfNotNull(failure); } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } private class PriorityQueueScanComparator extends PriorityQueueComparator { public PriorityQueueScanComparator(MultiComparator cmp) { super(cmp); } @Override public int compare(PriorityQueueElement elementA, PriorityQueueElement elementB) { int result; try { result = cmp.compare(elementA.getTuple(), elementB.getTuple()); if (result != 0) { return result; }
response: try { rangeCursors[i].destroy(); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } rangeCursors = null; try { lsmHarness.endScanDiskComponents(opCtx); } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } foundNext = false; if (failure != null) { throw HyracksDataException.create(failure); } @Override protected void setPriorityQueueComparator() { if (pqCmp == null || cmp != pqCmp.getMultiComparator()) { pqCmp = new PriorityQueueScanComparator(cmp); } } private class PriorityQueueScanComparator extends PriorityQueueComparator { public PriorityQueueScanComparator(MultiComparator cmp) { super(cmp); } @Override public int compare(PriorityQueueElement elementA, PriorityQueueElement elementB) { int result; try { result = cmp.compare(elementA.getTuple(), elementB.getTuple()); if (result != 0) { return result; } } catch (Throwable th) { failure = ExceptionUtils.suppress(failure, th); } return 0; } }

sample: 988
buggy_code:  */ package org.apache.asterix.test.base; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.junit.rules.TestWatcher; import org.junit.runner.Description; /* * Traces method entry/exit to System.out (or supplied PrintStream). To use, add the following to your test class: * * @Rule * public TestRule watcher = new TestMethodTracer(); * * @Rule <|startfocus|> * public TestRule watcher = new TestMethodTracer(System.err); <|endfocus|> */ public class TestMethodTracer extends TestWatcher { private static final Logger LOGGER = LogManager.getLogger(); @Override protected void starting(Description description) { LOGGER.info("### {} START", description.getMethodName()); } @Override protected void failed(Throwable e, Description description) { LOGGER.info("### {} FAILED ({})", description.getMethodName(), e.getClass().getName()); } @Override protected void succeeded(Description description) { LOGGER.info("### {} SUCCEEDED", description.getMethodName()); } } 
code_review:  update this 
target code: */ package org.apache.asterix.test.base; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.junit.rules.TestWatcher; import org.junit.runner.Description; /* * Traces method entry/exit to System.out (or supplied PrintStream). To use, add the following to your test class: * * @Rule * public TestRule watcher = new TestMethodTracer(); * * @Rule * public TestRule watcher = new TestMethodTracer(Level.INFO); * </code> */ public class TestMethodTracer extends TestWatcher { private static final Logger LOGGER = LogManager.getLogger(); @Override protected void starting(Description description) { LOGGER.info("### {} START", description.getMethodName()); } @Override protected void failed(Throwable e, Description description) { LOGGER.info("### {} FAILED ({})", description.getMethodName(), e.getClass().getName()); } @Override protected void succeeded(Description description) { LOGGER.info("### {} SUCCEEDED", description.getMethodName()); } }
response: ```java package org.apache.asterix.test.base; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.junit.rules.TestWatcher; import org.junit.runner.Description; /** * Traces method entry/exit to System.out (or supplied PrintStream). * To use, add the following to your test class: * * @Rule * public TestRule watcher = new TestMethodTracer(); * * @Rule * public TestRule watcher = new TestMethodTracer(System.err); */ public class TestMethodTracer extends TestWatcher { private static final Logger LOGGER = LogManager.getLogger(); @Override protected void starting(Description description) { LOGGER.info("### {} START", description.getMethodName()); } @Override protected void failed(Throwable e, Description description) { LOGGER.info("### {} FAILED ({})", description.getMethodName(), e.getClass().getName()); } @Override protected void succeeded(Description description) { LOGGER.info("### {} SUCCEEDED", description.getMethodName()); } } ```

sample: 989
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Exception e) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", e); } catch (Throwable ignore) { // Do nothing } root = ExceptionUtils.suppress(root, e); } } return root; }

sample: 990
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 991
buggy_code:  public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } } } return root;
response: public static Throwable destroy(IDestroyable destroyable, Throwable root) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable ignore) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 992
buggy_code:  } public LSMBTreePointSearchCursor getInsertSearchCursor() { return insertSearchCursor; } public BTreeRangeSearchCursor getMemCursor() { return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); <|startfocus|> failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure); <|endfocus|> if (failure != null) { throw HyracksDataException.create(failure); } } } 
code_review:  can remove this now, right? 
target code: } public LSMBTreePointSearchCursor getInsertSearchCursor() { return insertSearchCursor; } public BTreeRangeSearchCursor getMemCursor() { return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); failure = DestroyUtils.destroy(failure, insertSearchCursor, memCursor); if (failure != null) { throw HyracksDataException.create(failure); } } }
response: public LSMBTreePointSearchCursor getInsertSearchCursor() { return insertSearchCursor; } public BTreeRangeSearchCursor getMemCursor() { return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure); if (failure != null) { throw HyracksDataException.create(failure); } } }

sample: 993
buggy_code:  public BTreeRangeSearchCursor getMemCursor() { return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); <|startfocus|> failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure); <|endfocus|> if (failure != null) { throw HyracksDataException.create(failure); } } } 
code_review:  see comment in DestroyUtils, very confusing to support both parameter orders for DestroyUtils.destroy() 
target code: public BTreeRangeSearchCursor getMemCursor() { return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); failure = DestroyUtils.destroy(failure, insertSearchCursor, memCursor); if (failure != null) { throw HyracksDataException.create(failure); } } }
response: public BTreeRangeSearchCursor getMemCursor() { return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure); if (failure != null) { throw HyracksDataException.create(failure); } } }

sample: 994
buggy_code:  return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); <|startfocus|> failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure); <|endfocus|> if (failure != null) { throw HyracksDataException.create(failure); } } } 
code_review:  can't we just have one statement here: Throwable failure = DestroyUtils.destroy(mutableBTreeAccessors, mutableBTreeOpCtxs, insertSearchCursor, memCursor)? 
target code: return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); failure = DestroyUtils.destroy(failure, insertSearchCursor, memCursor); if (failure != null) { throw HyracksDataException.create(failure); } } }
response: return memCursor; } public LSMBTreeCursorInitialState getSearchInitialState() { return searchInitialState; } public MultiComparator getCmp() { return cmp; } @Override public void destroy() throws HyracksDataException { if (destroyed) { return; } destroyed = true; Throwable failure = DestroyUtils.destroy(null, mutableBTreeAccessors); failure = DestroyUtils.destroy(failure, mutableBTreeOpCtxs); failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure); if (failure != null) { throw HyracksDataException.create(failure); } } }

sample: 995
buggy_code:  } Function f = new Function(dataverse, getExternalFunctionFullName(libraryName, function.getName().trim()), args.size(), args, function.getReturnType().trim(), function.getDefinition().trim(), library.getLanguage().trim(), function.getFunctionType().trim(), null); MetadataManager.INSTANCE.addFunction(mdTxnCtx, f); if (LOGGER.isInfoEnabled()) { <|startfocus|> LOGGER.info("Installed function: " + getExternalFunctionFullName(libraryName, function.getName().trim())); <|endfocus|> } } } if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed functions in library :" + libraryName); } // Add adapters if (library.getLibraryAdapters() != null) { for (LibraryAdapter adapter : library.getLibraryAdapters().getLibraryAdapter()) { String adapterFactoryClass = adapter.getFactoryClass().trim(); String adapterName = getExternalFunctionFullName(libraryName, adapter.getName().trim()); AdapterIdentifier aid = new AdapterIdentifier(dataverse, adapterName); DatasourceAdapter dsa =
code_review:  Should we pull the trimming of strings out of these function calls and instead create a few well-named local variables? 
target code: } Function f = new Function(dataverse, getExternalFunctionFullName(libraryName, function.getName().trim()), args.size(), args, function.getReturnType().trim(), function.getDefinition().trim(), library.getLanguage().trim(), function.getFunctionType().trim(), null); MetadataManager.INSTANCE.addFunction(mdTxnCtx, f); if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed function: " + functionFullName); } } } if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed functions in library :" + libraryName); } // Add adapters if (library.getLibraryAdapters() != null) { for (LibraryAdapter adapter : library.getLibraryAdapters().getLibraryAdapter()) { String adapterFactoryClass = adapter.getFactoryClass().trim(); String adapterName = getExternalFunctionFullName(libraryName, adapter.getName().trim()); AdapterIdentifier aid = new AdapterIdentifier(dataverse, adapterName); DatasourceAdapter dsa =
response: } Function f = new Function(dataverse, getExternalFunctionFullName(libraryName, function.getName().trim()), args.size(), args, function.getReturnType().trim(), function.getDefinition().trim(), library.getLanguage().trim(), function.getFunctionType().trim(), null); MetadataManager.INSTANCE.addFunction(mdTxnCtx, f); if (LOGGER.isInfoEnabled()) { String functionName = getExternalFunctionFullName(libraryName, function.getName().trim()); LOGGER.info("Installed function: " + functionName); } } } if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed functions in library :" + libraryName); } // Add adapters if (library.getLibraryAdapters() != null) { for (LibraryAdapter adapter : library.getLibraryAdapters().getLibraryAdapter()) { String adapterFactoryClass = adapter.getFactoryClass().trim(); String adapterName = getExternalFunctionFullName(libraryName, adapter.getName().trim()); AdapterIdentifier aid = new AdapterIdentifier(dataverse, adapterName); DatasourceAdapter dsa =

sample: 996
buggy_code:  * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.api; import org.apache.asterix.external.library.java.JTypeTag; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IFunctionHelper { public IJObject getArgument(int index); public IJObject getResultObject(); public void setResult(IJObject result) throws HyracksDataException; public boolean isValidResult(); public IJObject getObject(JTypeTag jtypeTag) throws HyracksDataException; public void reset(); <|startfocus|> public String getParameters(); <|endfocus|> } 
code_review:  Again, is thin one or more parameters? 
target code: * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.api; import org.apache.asterix.external.library.java.JTypeTag; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IFunctionHelper { public IJObject getArgument(int index); public IJObject getResultObject(); public void setResult(IJObject result) throws HyracksDataException; public boolean isValidResult(); public IJObject getObject(JTypeTag jtypeTag) throws HyracksDataException; public void reset(); public String getParamsString(); }
response: *Refactored Buggy Code:* ```java package org.apache.asterix.external.api; import org.apache.asterix.external.library.java.JTypeTag; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IFunctionHelper { public IJObject getArgument(int index); public IJObject getResultObject(); public void setResult(IJObject result) throws HyracksDataException; public boolean isValidResult(); public IJObject getObject(JTypeTag jtypeTag) throws HyracksDataException; public void reset(); public String getParameters(); } ```

sample: 997
buggy_code: import org.apache.hyracks.data.std.api.IDataOutputProvider; import org.apache.hyracks.data.std.api.IValueReference; public class JavaFunctionHelper implements IFunctionHelper { private final IExternalFunctionInfo finfo; private final IDataOutputProvider outputProvider; private final IJObject[] arguments; private IJObject resultHolder; private final IObjectPool<IJObject, IAType> objectPool = new ListObjectPool<>(JTypeObjectFactory.INSTANCE); private final JObjectPointableVisitor pointableVisitor; private final PointableAllocator pointableAllocator; private final Map<Integer, TypeInfo> poolTypeInfo; <|startfocus|> private final String parameters; <|endfocus|> private boolean isValidResult = false; public JavaFunctionHelper(IExternalFunctionInfo finfo, IDataOutputProvider outputProvider, String parameters) throws HyracksDataException { this.finfo = finfo; this.outputProvider = outputProvider; this.pointableVisitor = new JObjectPointableVisitor(); this.pointableAllocator = new PointableAllocator(); this.arguments = new IJObject[finfo.getArgumentList().size()]; int index = 0; for (IAType param : finfo.getArgumentList()) { this.arguments[index++] = objectPool.allocate(param); } this.resultHolder = objectPool.allocate(finfo.getReturnType());
code_review:  One or more parameters? 
target code: import org.apache.hyracks.data.std.api.IDataOutputProvider; import org.apache.hyracks.data.std.api.IValueReference; public class JavaFunctionHelper implements IFunctionHelper { private final IExternalFunctionInfo finfo; private final IDataOutputProvider outputProvider; private final IJObject[] arguments; private IJObject resultHolder; private final IObjectPool<IJObject, IAType> objectPool = new ListObjectPool<>(JTypeObjectFactory.INSTANCE); private final JObjectPointableVisitor pointableVisitor; private final PointableAllocator pointableAllocator; private final Map<Integer, TypeInfo> poolTypeInfo; private final String paramsString; private boolean isValidResult = false; public JavaFunctionHelper(IExternalFunctionInfo finfo, IDataOutputProvider outputProvider, String parameters) throws HyracksDataException { this.finfo = finfo; this.outputProvider = outputProvider; this.pointableVisitor = new JObjectPointableVisitor(); this.pointableAllocator = new PointableAllocator(); this.arguments = new IJObject[finfo.getArgumentList().size()]; int index = 0; for (IAType param : finfo.getArgumentList()) { this.arguments[index++] = objectPool.allocate(param); } this.resultHolder = objectPool.allocate(finfo.getReturnType());
response: import org.apache.hyracks.data.std.api.IDataOutputProvider; import org.apache.hyracks.data.std.api.IValueReference; public class JavaFunctionHelper implements IFunctionHelper { private final IExternalFunctionInfo finfo; private final IDataOutputProvider outputProvider; private final IJObject[] arguments; private IJObject resultHolder; private final IObjectPool<IJObject, IAType> objectPool = new ListObjectPool<>(JTypeObjectFactory.INSTANCE); private final JObjectPointableVisitor pointableVisitor; private final PointableAllocator pointableAllocator; private final Map<Integer, TypeInfo> poolTypeInfo; private final String parameters; private boolean isValidResult = false; public JavaFunctionHelper(IExternalFunctionInfo finfo, IDataOutputProvider outputProvider, String parameters) throws HyracksDataException { this.finfo = finfo; this.outputProvider = outputProvider; this.pointableVisitor = new JObjectPointableVisitor(); this.pointableAllocator = new PointableAllocator(); this.arguments = new IJObject[finfo.getArgumentList().size()]; int index = 0; for (IAType param : finfo.getArgumentList()) { this.arguments[index++] = objectPool.allocate(param); } this.resultHolder = objectPool.allocate(finfo.getReturnType()); this.parameters = parameters; } }

sample: 998
buggy_code:  try { while (true) { pageCleanerPolicy.notifyCleanCycleStart(this); int curPage = 0; while (true) { synchronized (cachedPages) { if (curPage >= cachedPages.size()) { break; } CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } } curPage++; } if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); } <|startfocus|> } catch (Exception e) { e.printStackTrace(); } finally { shutdownComplete = true; notifyAll(); <|endfocus|> } } } @Override public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try {
code_review:  same comment above on name, etc. 
target code: try { while (true) { pageCleanerPolicy.notifyCleanCycleStart(this); int curPage = 0; while (true) { synchronized (cachedPages) { if (curPage >= cachedPages.size()) { break; } CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } } curPage++; } if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); } curPage++; } } } @Override public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try {
response: try { while (true) { pageCleanerPolicy.notifyCleanCycleStart(this); int curPage = 0; while (true) { synchronized (cachedPages) { if (curPage >= cachedPages.size()) { break; } CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } } curPage++; } if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); } } catch (Exception e) { e.printStackTrace(); } finally { shutdownComplete = true; notifyAll(); } @Override public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try { // code here } catch (IOException e) { e.printStackTrace(); } } }

sample: 999
buggy_code:  synchronized (cachedPages) { if (curPage >= cachedPages.size()) { break; } CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } } curPage++; } if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); } } catch (Exception e) { e.printStackTrace(); } finally { shutdownComplete = true; notifyAll(); <|startfocus|> } <|endfocus|> } } @Override public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try { for (Map.Entry<Integer, BufferedFileHandle> entry : fileInfoMap.entrySet()) {
code_review:  same comment above on name 
target code: synchronized (cachedPages) { if (curPage >= cachedPages.size()) { break; } CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } } curPage++; } if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); } } catch (Exception e) { e.printStackTrace(); } finally { shutdownComplete = true; notifyAll(); } if (!shutdownStart) { pageCleanerPolicy.notifyCleanCycleFinish(threadLock); } } } @Override public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try { for (Map.Entry<Integer, BufferedFileHandle> entry : fileInfoMap.entrySet()) {
response: synchronized (cachedPages) { if (curPage >= cachedPages.size()) { break; } CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } } curPage++; if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); } } catch (Exception e) { e.printStackTrace(); } finally { shutdownComplete = true; notifyAll(); } } @Override public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try { for (Map.Entry<Integer, BufferedFileHandle> entry : fileInfoMap.entrySet()) { // code to handle entry } } catch (Exception e) { e.printStackTrace(); } } }

sample: 1000
buggy_code:  public void close() { closed = true; fifoWriter.destroyQueue(); <|startfocus|> synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); <|endfocus|> } } } synchronized (fileInfoMap) { try { for (Map.Entry<Integer, BufferedFileHandle> entry : fileInfoMap.entrySet()) { boolean fileHasBeenDeleted = entry.getValue().fileHasBeenDeleted(); sweepAndFlush(entry.getKey(), !fileHasBeenDeleted); if (!fileHasBeenDeleted) { ioManager.close(entry.getValue().getFileHandle()); } } } catch (HyracksDataException e) { e.printStackTrace(); } fileInfoMap.clear(); }
code_review:  same comment above on name 
target code: public void close() { closed = true; fifoWriter.destroyQueue(); try { synchronized (cleanerThread.threadLock) { cleanerThread.shutdownStart = true; cleanerThread.threadLock.notifyAll(); while (!cleanerThread.shutdownComplete) { cleanerThread.threadLock.wait(); } } } synchronized (fileInfoMap) { try { for (Map.Entry<Integer, BufferedFileHandle> entry : fileInfoMap.entrySet()) { boolean fileHasBeenDeleted = entry.getValue().fileHasBeenDeleted(); sweepAndFlush(entry.getKey(), !fileHasBeenDeleted); if (!fileHasBeenDeleted) { ioManager.close(entry.getValue().getFileHandle()); } } } catch (HyracksDataException e) { e.printStackTrace(); } fileInfoMap.clear(); }
response: public void close() { closed = true; fifoWriter.destroyQueue(); synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } synchronized (fileInfoMap) { try { for (Map.Entry<Integer, BufferedFileHandle> entry : fileInfoMap.entrySet()) { boolean fileHasBeenDeleted = entry.getValue().fileHasBeenDeleted(); sweepAndFlush(entry.getKey(), !fileHasBeenDeleted); if (!fileHasBeenDeleted) { ioManager.close(entry.getValue().getFileHandle()); } } } catch (HyracksDataException e) { e.printStackTrace(); } fileInfoMap.clear(); } }

sample: 1001
buggy_code:  CachedPage cPage = bucket.cachedPage; bucket.cachedPage = bucket.cachedPage.next; cPage.next = null; } } } finally { bucket.bucketLock.unlock(); } } } private boolean invalidateIfFileIdMatch(int fileId, CachedPage cPage, boolean flushDirtyPages) throws HyracksDataException { if (BufferedFileHandle.getFileId(cPage.dpid) == fileId) { <|startfocus|> int pinCount = -1; <|endfocus|> if (cPage.dirty.get()) { if (flushDirtyPages) { write(cPage); } cPage.dirty.set(false); pinCount = cPage.pinCount.decrementAndGet(); } else { pinCount = cPage.pinCount.get(); } if (pinCount > 0) { throw new IllegalStateException("Page " + BufferedFileHandle.getFileId(cPage.dpid) + ":" + BufferedFileHandle.getPageId(cPage.dpid) + " is pinned and file is being closed. Pincount is: " + pinCount + " Page is confiscated: " + cPage.confiscated); } cPage.invalidate(); return true; }
code_review:  why is the queue empty? 
target code: CachedPage cPage = bucket.cachedPage; bucket.cachedPage = bucket.cachedPage.next; cPage.next = null; } } } finally { bucket.bucketLock.unlock(); } } } private boolean invalidateIfFileIdMatch(int fileId, CachedPage cPage, boolean flushDirtyPages) throws HyracksDataException { if (BufferedFileHandle.getFileId(cPage.dpid) == fileId) { int pinCount; if (cPage.dirty.get()) { if (flushDirtyPages) { write(cPage); } cPage.dirty.set(false); pinCount = cPage.pinCount.decrementAndGet(); } else { pinCount = cPage.pinCount.get(); } if (pinCount > 0) { throw new IllegalStateException("Page " + BufferedFileHandle.getFileId(cPage.dpid) + ":" + BufferedFileHandle.getPageId(cPage.dpid) + " is pinned and file is being closed. Pincount is: " + pinCount + " Page is confiscated: " + cPage.confiscated); } cPage.invalidate(); return true; }
response: /** * @author Loc Prieur-Drevon * @since 3.0 */ public class UpdateTraceBoundsJob extends Job { private static final Logger LOGGER = TraceCompassLog.getLogger(UpdateTraceBoundsJob.class); private static final String BOUNDS_FILE_NAME = "bounds"; private final Queue<TmfTraceElement> fTraceBoundsToUpdate; /** * Constructor. * * @param name The name of the job * @param traceBoundsToUpdate Queue of TmfTraceElement to update */ public UpdateTraceBoundsJob(String name, Queue<TmfTraceElement> traceBoundsToUpdate) { super(name); fTraceBoundsToUpdate = traceBoundsToUpdate; } @Override public IStatus run(IProgressMonitor monitor) { SubMonitor subMonitor = SubMonitor.convert(monitor, fTraceBoundsToUpdate.size()); while (!fTraceBoundsToUpdate.isEmpty()) { subMonitor.setTaskName(getName()); if (subMonitor.isCanceled()) { return Status.CANCEL_STATUS; } TmfTraceElement tElement = fTraceBoundsToUpdate.poll(); ITmfTimestamp start = tElement.getStartTime(); // rest of the code } return Status.OK_STATUS; } } public void addDesignSpaceChangedListener(IDesignSpaceChangeHandler changeEvent) { // implementation } public void removeDesignSpaceChangedListener(IDesignSpaceChangeHandler changeEvent) { // implementation } CachedPage cPage = bucket.cachedPage; bucket.cachedPage = bucket.cachedPage.next; cPage.next = null; // rest of the code

sample: 1002
buggy_code:  isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } return false; } // Finished one partition for the both cases #1 and #2. So, moves to the next partition. curPartIdx++; if (curPartIdx <= endPartIdx) { boolean suitablePartFound = false; for (int i = curPartIdx; i <= endPartIdx; i++) { // Prune partition because no element in it can satisfy the occurrence threshold. <|startfocus|> if (partitionCursors[i] == null || partitionCursors[i].size() < occurrenceThreshold) { <|endfocus|> continue; } suitablePartFound = true; curPartIdx = i; break; } // If no partition is availble to explore, we stop here. if (!suitablePartFound) { isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } // Merge inverted lists of current partition. numPrefixLists = searchModifier.getNumPrefixLists(occurrenceThreshold, partitionCursors[curPartIdx].size()); invListMerger.reset(); finalSearchResult.resetBuffer();
code_review:  MAJOR SonarQube violation: Reduce the total number of break and continue statements in this loop to use at most one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS135 
target code: isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } return false; } // Finished one partition for the both cases #1 and #2. So, moves to the next partition. curPartIdx++; if (curPartIdx <= endPartIdx) { boolean suitablePartFound = false; for (int i = curPartIdx; i <= endPartIdx; i++) { // Prune partition because no element in it can satisfy the occurrence threshold. if (partitionCursors[i] == null) { continue; } suitablePartFound = true; curPartIdx = i; break; } // If no partition is availble to explore, we stop here. if (!suitablePartFound) { isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } // Merge inverted lists of current partition. numPrefixLists = searchModifier.getNumPrefixLists(occurrenceThreshold, partitionCursors[curPartIdx].size()); invListMerger.reset(); finalSearchResult.resetBuffer();
response: isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; return false; curPartIdx++; if (curPartIdx <= endPartIdx) { boolean suitablePartFound = false; for (int i = curPartIdx; i <= endPartIdx; i++) { if (partitionCursors[i] == null || partitionCursors[i].size() < occurrenceThreshold) { continue; } suitablePartFound = true; curPartIdx = i; break; } if (!suitablePartFound) { isFinishedSearch = true; invListMerger.close(); finalSearchResult.finalizeWrite(); return true; } numPrefixLists = searchModifier.getNumPrefixLists(occurrenceThreshold, partitionCursors[curPartIdx].size()); invListMerger.reset(); finalSearchResult.resetBuffer();

sample: 1003
buggy_code:  this.argTypes = argTypes; this.failOnArgTypeMismatch = failOnArgTypeMismatch; } @Override public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { final IScalarEvaluator[] argEvals = new IScalarEvaluator[args.length]; final IPointable[] argPtrs = new IPointable[args.length]; for (int i = 0; i < args.length; i++) { argEvals[i] = args[i].createScalarEvaluator(ctx); argPtrs[i] = new VoidPointable(); } return new IScalarEvaluator() { <|startfocus|> final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); final DataOutput resultOutput = resultStorage.getDataOutput(); <|endfocus|> final ARecordVisitablePointable openRecordPointable = new ARecordVisitablePointable(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); final ARecordVisitablePointable[] argVisitablePointables; final BitSet castRequired; final ACastVisitor castVisitor; final Triple<IVisitablePointable, IAType, Boolean> castVisitorArg; final RecordBuilder outRecordBuilder = new RecordBuilder(); final BinaryEntry keyEntry = new BinaryEntry(); final BinaryEntry valEntry = new BinaryEntry(); final BinaryHashMap fieldMap =
code_review:  MAJOR SonarQube violation: Reduce this anonymous class number of lines from 124 to at most 20, or make it a named class. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 
target code: this.argTypes = argTypes; this.failOnArgTypeMismatch = failOnArgTypeMismatch; } @Override public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { final IScalarEvaluator[] argEvals = new IScalarEvaluator[args.length]; final IPointable[] argPtrs = new IPointable[args.length]; for (int i = 0; i < args.length; i++) { argEvals[i] = args[i].createScalarEvaluator(ctx); argPtrs[i] = new VoidPointable(); } return new IScalarEvaluator() { private static final int TABLE_FRAME_SIZE = 32768; private static final int TABLE_SIZE = 100; final ARecordVisitablePointable openRecordPointable = new ARecordVisitablePointable(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); final ARecordVisitablePointable[] argVisitablePointables; final BitSet castRequired; final ACastVisitor castVisitor; final Triple<IVisitablePointable, IAType, Boolean> castVisitorArg; final RecordBuilder outRecordBuilder = new RecordBuilder(); final BinaryEntry keyEntry = new BinaryEntry(); final BinaryEntry valEntry = new BinaryEntry(); final BinaryHashMap fieldMap =
response: this.argTypes = argTypes; this.failOnArgTypeMismatch = failOnArgTypeMismatch; } @Override public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { final IScalarEvaluator[] argEvals = new IScalarEvaluator[args.length]; final IPointable[] argPtrs = new IPointable[args.length]; for (int i = 0; i < args.length; i++) { argEvals[i] = args[i].createScalarEvaluator(ctx); argPtrs[i] = new VoidPointable(); } return new IScalarEvaluator() { final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); final DataOutput resultOutput = resultStorage.getDataOutput(); final ARecordVisitablePointable openRecordPointable = new ARecordVisitablePointable(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); final ARecordVisitablePointable[] argVisitablePointables; final BitSet castRequired; final ACastVisitor castVisitor; final Triple<IVisitablePointable, IAType, Boolean> castVisitorArg; final RecordBuilder outRecordBuilder = new RecordBuilder(); final BinaryEntry keyEntry = new BinaryEntry(); final BinaryEntry valEntry = new BinaryEntry(); final BinaryHashMap fieldMap = new BinaryHashMap(); { argVisitablePointables = new ARecordVisitablePointable[args.length]; castRequired = new BitSet(args.length); castVisitor = new ACastVisitor(); castVisitorArg = new Triple<>(null, null, false); for (int i = 0; i < args.length; i++) { argVisitablePointables[i] = new ARecordVisitablePointable(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); castRequired.set(i, false); } } @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); resultOutput.write(result.getByteArray(), result.getStartOffset(), result.getLength()); outRecordBuilder.reset(); fieldMap.clear(); keyEntry.reset(); valEntry.reset(); openRecordPointable.set(result.getByteArray(), result.getStartOffset(), result.getLength()); try { for (int i = 0; i < args.length; i++) { argPtrs

sample: 1004
buggy_code:  final BitSet castRequired; final ACastVisitor castVisitor; final Triple<IVisitablePointable, IAType, Boolean> castVisitorArg; final RecordBuilder outRecordBuilder = new RecordBuilder(); final BinaryEntry keyEntry = new BinaryEntry(); final BinaryEntry valEntry = new BinaryEntry(); final BinaryHashMap fieldMap = new BinaryHashMap(TABLE_SIZE, TABLE_FRAME_SIZE, outRecordBuilder.getFieldNameHashFunction(), outRecordBuilder.getFieldNameHashFunction(), outRecordBuilder.getFieldNameComparator()); <|startfocus|> { outRecordBuilder.reset(openRecordPointable.getInputRecordType()); valEntry.set(new byte[0], 0, 0); <|endfocus|> int argCount = argEvals.length; ARecordVisitablePointable[] vp = new ARecordVisitablePointable[argCount]; BitSet cr = new BitSet(); ACastVisitor cv = null; Triple<IVisitablePointable, IAType, Boolean> ca = null; for (int i = 0; i < argCount; i++) { ARecordType argType = argTypes[i]; if (argType != null) { vp[i] = new ARecordVisitablePointable(argType); if (hasDerivedType(argType.getFieldTypes())) {
code_review:  MAJOR SonarQube violation: Move the contents of this initializer to a standard constructor or to field initializers. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1171 
target code: final BitSet castRequired; final ACastVisitor castVisitor; final Triple<IVisitablePointable, IAType, Boolean> castVisitorArg; final RecordBuilder outRecordBuilder = new RecordBuilder(); final BinaryEntry keyEntry = new BinaryEntry(); final BinaryEntry valEntry = new BinaryEntry(); final BinaryHashMap fieldMap = new BinaryHashMap(TABLE_SIZE, TABLE_FRAME_SIZE, outRecordBuilder.getFieldNameHashFunction(), outRecordBuilder.getFieldNameHashFunction(), outRecordBuilder.getFieldNameComparator()); argPointables = new IPointable[args.length]; argRecordPointables = new ARecordVisitablePointable[args.length]; openRecordPointable = new ARecordVisitablePointable(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); int argCount = argEvals.length; ARecordVisitablePointable[] vp = new ARecordVisitablePointable[argCount]; BitSet cr = new BitSet(); ACastVisitor cv = null; Triple<IVisitablePointable, IAType, Boolean> ca = null; for (int i = 0; i < argCount; i++) { ARecordType argType = argTypes[i]; if (argType != null) { vp[i] = new ARecordVisitablePointable(argType); if (hasDerivedType(argType.getFieldTypes())) {
response: final BitSet castRequired; final ACastVisitor castVisitor; final Triple<IVisitablePointable, IAType, Boolean> castVisitorArg; final RecordBuilder outRecordBuilder = new RecordBuilder(); final BinaryEntry keyEntry = new BinaryEntry(); final BinaryEntry valEntry = new BinaryEntry(); final BinaryHashMap fieldMap = new BinaryHashMap(TABLE_SIZE, TABLE_FRAME_SIZE, outRecordBuilder.getFieldNameHashFunction(), outRecordBuilder.getFieldNameHashFunction(), outRecordBuilder.getFieldNameComparator()); outRecordBuilder.reset(openRecordPointable.getInputRecordType()); valEntry.set(new byte[0], 0, 0); int argCount = argEvals.length; ARecordVisitablePointable[] vp = new ARecordVisitablePointable[argCount]; BitSet cr = new BitSet(); ACastVisitor cv = null; Triple<IVisitablePointable, IAType, Boolean> ca = null; for (int i = 0; i < argCount; i++) { ARecordType argType = argTypes[i]; if (argType != null) { vp[i] = new ARecordVisitablePointable(argType); if (hasDerivedType(argType.getFieldTypes())) { cr.set(i); } } } castRequired = cr; castVisitor = cv; castVisitorArg = ca;

sample: 1005
buggy_code: import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities; import org.apache.hyracks.algebricks.core.algebra.plan.ALogicalPlanImpl; import org.apache.hyracks.algebricks.core.algebra.util.OperatorPropertiesUtil; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.storage.am.lsm.invertedindex.tokenizers.DelimitedUTF8StringBinaryTokenizer; /** * Static helper functions for rewriting plans using indexes. */ public class AccessMethodUtils { // Output variable type from a secondary unnest-map <|startfocus|> enum secondaryUnnestMapOutputVarType { <|endfocus|> PRIMARY_KEY, SECONDARY_KEY, CONDITIONAL_SPLIT_VAR } public static void appendPrimaryIndexTypes(Dataset dataset, IAType itemType, IAType metaItemType, List<Object> target) throws AlgebricksException { ARecordType recordType = (ARecordType) itemType; ARecordType metaRecordType = (ARecordType) metaItemType; target.addAll(KeyFieldTypeUtil.getPartitoningKeyTypes(dataset, recordType, metaRecordType)); // Adds data record type. target.add(itemType); // Adds meta record type if any. if (dataset.hasMetaPart()) { target.add(metaItemType); } } 
code_review:  class/enum names start with a capital letter, so should be "SecondaryUnnestMapOutputVarType" 
target code: import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities; import org.apache.hyracks.algebricks.core.algebra.plan.ALogicalPlanImpl; import org.apache.hyracks.algebricks.core.algebra.util.OperatorPropertiesUtil; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.storage.am.lsm.invertedindex.tokenizers.DelimitedUTF8StringBinaryTokenizer; /** * Static helper functions for rewriting plans using indexes. */ public class AccessMethodUtils { // Output variable type from a secondary unnest-map enum SecondaryUnnestMapOutputVarType { PRIMARY_KEY, SECONDARY_KEY, CONDITIONAL_SPLIT_VAR } public static void appendPrimaryIndexTypes(Dataset dataset, IAType itemType, IAType metaItemType, List<Object> target) throws AlgebricksException { ARecordType recordType = (ARecordType) itemType; ARecordType metaRecordType = (ARecordType) metaItemType; target.addAll(KeyFieldTypeUtil.getPartitoningKeyTypes(dataset, recordType, metaRecordType)); // Adds data record type. target.add(itemType); // Adds meta record type if any. if (dataset.hasMetaPart()) { target.add(metaItemType); } }
response: import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities; import org.apache.hyracks.algebricks.core.algebra.plan.ALogicalPlanImpl; import org.apache.hyracks.algebricks.core.algebra.util.OperatorPropertiesUtil; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.storage.am.lsm.invertedindex.tokenizers.DelimitedUTF8StringBinaryTokenizer; /** * Static helper functions for rewriting plans using indexes. */ public class AccessMethodUtils { enum SecondaryUnnestMapOutputVarType { PRIMARY_KEY, SECONDARY_KEY, CONDITIONAL_SPLIT_VAR } public static void appendPrimaryIndexTypes(Dataset dataset, IAType itemType, IAType metaItemType, List<Object> target) throws AlgebricksException { ARecordType recordType = (ARecordType) itemType; ARecordType metaRecordType = (ARecordType) metaItemType; target.addAll(KeyFieldTypeUtil.getPartitoningKeyTypes(dataset, recordType, metaRecordType)); target.add(itemType); if (dataset.hasMetaPart()) { target.add(metaItemType); } } }

sample: 1006
buggy_code:  switch (keyVarType) { case PRIMARY_KEY: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case SECONDARY_KEY: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case CONDITIONAL_SPLIT_VAR: // Sanity check - the given unnest map should generate this variable. if (!abstractUnnestMapOp.getGenerateCallBackProceedResultVar()) { <|startfocus|> CompilationException.create(ErrorCode.CANNOT_GET_CONDITIONAL_SPLIT_KEY_VARIABLE); <|endfocus|> } // Fetches conditional splitter - the last position start = numSecondaryKeys + numPrimaryKeys; stop = start + 1; break; default: return Collections.emptyList(); } for (int i = start; i < stop; i++) { keyVars.add(sourceVars.get(i)); } return keyVars; } public static List<LogicalVariable> getPrimaryKeyVarsFromPrimaryUnnestMap(Dataset dataset, ILogicalOperator unnestMapOp) { int numPrimaryKeys = dataset.getPrimaryKeys().size();
code_review:  Need to throw this exception. 
target code: switch (keyVarType) { case PRIMARY_KEY: // Fetches primary keys - the second position start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case SECONDARY_KEY: // Fetches secondary keys - the first position start = 0; stop = numSecondaryKeys; break; case CONDITIONAL_SPLIT_VAR: // Sanity check - the given unnest map should generate this variable. if (!abstractUnnestMapOp.getGenerateCallBackProceedResultVar()) { throw CompilationException.create(ErrorCode.CANNOT_GET_CONDITIONAL_SPLIT_KEY_VARIABLE); } // Fetches conditional splitter - the last position start = numSecondaryKeys + numPrimaryKeys; stop = start + 1; break; default: return Collections.emptyList(); } for (int i = start; i < stop; i++) { keyVars.add(sourceVars.get(i)); } return keyVars; } public static List<LogicalVariable> getPrimaryKeyVarsFromPrimaryUnnestMap(Dataset dataset, ILogicalOperator unnestMapOp) { int numPrimaryKeys = dataset.getPrimaryKeys().size();
response: switch (keyVarType) { case PRIMARY_KEY: start = numSecondaryKeys; stop = numSecondaryKeys + numPrimaryKeys; break; case SECONDARY_KEY: start = 0; stop = numSecondaryKeys; break; case CONDITIONAL_SPLIT_VAR: if (!abstractUnnestMapOp.getGenerateCallBackProceedResultVar()) { throw CompilationException.create(ErrorCode.CANNOT_GET_CONDITIONAL_SPLIT_KEY_VARIABLE); } start = numSecondaryKeys + numPrimaryKeys; stop = start + 1; break; default: return Collections.emptyList(); } for (int i = start; i < stop; i++) { keyVars.add(sourceVars.get(i)); } return keyVars; } public static List<LogicalVariable> getPrimaryKeyVarsFromPrimaryUnnestMap(Dataset dataset, ILogicalOperator unnestMapOp) { int numPrimaryKeys = dataset.getPrimaryKeys().size(); // rest of the code }

sample: 1007
buggy_code:  case UPDATE: case WRITE: case WRITE_RESULT: case INDEX_INSERT_DELETE_UPSERT: case INSERT_DELETE_UPSERT: case INTERSECT: return getOperatorRequiredMemory(operator, frameSize); case LEFT_OUTER_UNNEST_MAP: case UNNEST_MAP: // Since an inverted-index search requires certain amount of memory, needs to calculate // the memory size differently if the given index-search is an inverted-index search. long unnestMapMemorySize = frameSize; if (isInvertedIndexSearch((AbstractUnnestMapOperator) operator)) { <|startfocus|> unnestMapMemorySize = textSearchMemorySize; <|endfocus|> } return getOperatorRequiredMemory(operator, unnestMapMemorySize); case EXCHANGE: return getExchangeRequiredMemory((ExchangeOperator) operator); case GROUP: return getOperatorRequiredMemory(operator, groupByMemorySize); case ORDER: return getOperatorRequiredMemory(operator, sortMemorySize); case INNERJOIN: case LEFTOUTERJOIN: return getOperatorRequiredMemory(operator, joinMemorySize); default: throw new IllegalStateException("Unrecognized operator: " + operator.getOperatorTag()); }
code_review:  unnestMapMemorySize = textSearchMemorySize + frameSize? This is because we will also allocate the operator frame for writing the result to be consumed by the next operator 
target code: case UPDATE: case WRITE: case WRITE_RESULT: case INDEX_INSERT_DELETE_UPSERT: case INSERT_DELETE_UPSERT: case INTERSECT: return getOperatorRequiredMemory(operator, frameSize); case LEFT_OUTER_UNNEST_MAP: case UNNEST_MAP: // Since an inverted-index search requires certain amount of memory, needs to calculate // the memory size differently if the given index-search is an inverted-index search. long unnestMapMemorySize = frameSize; if (isInvertedIndexSearch((AbstractUnnestMapOperator) operator)) { unnestMapMemorySize += textSearchMemorySize; } return getOperatorRequiredMemory(operator, unnestMapMemorySize); case EXCHANGE: return getExchangeRequiredMemory((ExchangeOperator) operator); case GROUP: return getOperatorRequiredMemory(operator, groupByMemorySize); case ORDER: return getOperatorRequiredMemory(operator, sortMemorySize); case INNERJOIN: case LEFTOUTERJOIN: return getOperatorRequiredMemory(operator, joinMemorySize); default: throw new IllegalStateException("Unrecognized operator: " + operator.getOperatorTag()); }
response: case UPDATE: case WRITE: case WRITE_RESULT: case INDEX_INSERT_DELETE_UPSERT: case INSERT_DELETE_UPSERT: case INTERSECT: return getOperatorRequiredMemory(operator, frameSize); case LEFT_OUTER_UNNEST_MAP: case UNNEST_MAP: long unnestMapMemorySize = frameSize; if (isInvertedIndexSearch((AbstractUnnestMapOperator) operator)) { unnestMapMemorySize = textSearchMemorySize; } return getOperatorRequiredMemory(operator, unnestMapMemorySize); case EXCHANGE: return getExchangeRequiredMemory((ExchangeOperator) operator); case GROUP: return getOperatorRequiredMemory(operator, groupByMemorySize); case ORDER: return getOperatorRequiredMemory(operator, sortMemorySize); case INNERJOIN: case LEFTOUTERJOIN: return getOperatorRequiredMemory(operator, joinMemorySize); default: throw new IllegalStateException("Unrecognized operator: " + operator.getOperatorTag());

sample: 1008
buggy_code:  public static Throwable destroy(Throwable root, IDestroyable... destroyables) { for (IDestroyable destroyable : destroyables) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // NOSONAR // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable destroy(Throwable root, IDestroyable... destroyables) { for (IDestroyable destroyable : destroyables) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { // NOSONAR. Had to be done to satisfy contracts try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // NOSONAR // Do nothing } root = ExceptionUtils.suppress(root, th); // NOSONAR } } } return root;
response: public static Throwable destroy(Throwable root, IDestroyable... destroyables) { for (IDestroyable destroyable : destroyables) { if (destroyable != null) { try { destroyable.destroy(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } } return root; }

sample: 1009
buggy_code:  public static Throwable close(IFrameWriter writer, Throwable root) { if (writer != null) { try { writer.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // NOSONAR // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable close(IFrameWriter writer, Throwable root) { if (writer != null) { try { writer.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // NOSONAR // Do nothing } root = ExceptionUtils.suppress(root, th); // NOSONAR } } return root;
response: public static Throwable close(IFrameWriter writer, Throwable root) { if (writer != null) { try { writer.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1010
buggy_code:  */ String[] getPaths(); /** * @return the context associated with this IServlet */ ConcurrentMap<String, Object> ctx(); /** * handle the IServletRequest writing the response in the passed IServletResponse * * @param request * @param response */ void handle(IServletRequest request, IServletResponse response); /** * @return the handler for channel close events */ <|startfocus|> default IChannelCloseHandler getChannelCloseHandler() { return null; <|endfocus|> } } 
code_review:  should we add HttpServer as a method parameter, and return server.getCHannelCloseHandler() here? it might make use of this less clunky, but no strong preference 
target code: */ String[] getPaths(); /** * @return the context associated with this IServlet */ ConcurrentMap<String, Object> ctx(); /** * handle the IServletRequest writing the response in the passed IServletResponse * * @param request * @param response */ void handle(IServletRequest request, IServletResponse response); /** * @return the handler for channel close events */ default IChannelClosedHandler getChannelCloseHandler(HttpServer server) { return server.getChannelCloseHandler(); } }
response: String[] getPaths(); ConcurrentMap<String, Object> ctx(); void handle(IServletRequest request, IServletResponse response); default IChannelCloseHandler getChannelCloseHandler() { return null; }

sample: 1011
buggy_code:  Collection<Task> tasks = joblet.getTaskMap().values(); for (Task task : tasks) { task.abort(); allTasks.add(task); } final JobId jobId = joblet.getJobId(); if (dpm != null) { dpm.abortReader(jobId); dpm.sweep(jobId); } ncs.getWorkQueue().schedule(new CleanupJobletWork(ncs, jobId, JobStatus.FAILURE)); }); <|startfocus|> for (int i = 0; i < allTasks.size(); i++) { allTasks.get(i).awaitCompletion(); } <|endfocus|> } } 
code_review:  we need an overall timeout for all completions before we...? 
target code: Collection<Task> tasks = joblet.getTaskMap().values(); for (Task task : tasks) { task.abort(); allTasks.add(task); } final JobId jobId = joblet.getJobId(); if (dpm != null) { dpm.abortReader(jobId); dpm.sweep(jobId); } ncs.getWorkQueue().schedule(new CleanupJobletWork(ncs, jobId, JobStatus.FAILURE)); }); ncs.getWorkQueue().schedule(new EnsureAllCcTasksCompleted(ncs, ccId, abortedTasks)); } }
response: Collection<Task> tasks = joblet.getTaskMap().values(); for (Task task : tasks) { task.abort(); allTasks.add(task); } final JobId jobId = joblet.getJobId(); if (dpm != null) { dpm.abortReader(jobId); dpm.sweep(jobId); } ncs.getWorkQueue().schedule(new CleanupJobletWork(ncs, jobId, JobStatus.FAILURE)); for (int i = 0; i < allTasks.size(); i++) { allTasks.get(i).awaitCompletion(); }

sample: 1012
buggy_code:  import java.io.DataOutput; import java.io.IOException; import java.util.LinkedHashMap; import java.util.Map; public final class JRecord implements IJObject { private ARecordType recordType; private IJObject[] fields; private Map<String, IJObject> openFields; RecordBuilder recordBuilder = new RecordBuilder(); ArrayBackedValueStorage fieldName = new ArrayBackedValueStorage(); ArrayBackedValueStorage fieldValue = new ArrayBackedValueStorage(); AMutableString nameString = new AMutableString(""); <|startfocus|> private final AStringSerializerDeserializer aStringSerDer = AStringSerializerDeserializer.INSTANCE; <|endfocus|> public JRecord(ARecordType recordType, IJObject[] fields) { this.recordType = recordType; this.fields = fields; this.openFields = new LinkedHashMap<>(); } public JRecord(ARecordType recordType, IJObject[] fields, LinkedHashMap<String, IJObject> openFields) { this(recordType, fields); this.openFields = openFields; } public void addField(String fieldName, IJObject fieldValue) throws HyracksDataException { int pos = getFieldPosByName(fieldName); if (pos >= 0) {
code_review:  MAJOR SonarQube violation: Make this final field static too. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1170 
target code: import java.io.DataOutput; import java.io.IOException; import java.util.LinkedHashMap; import java.util.Map; public final class JRecord implements IJObject { private ARecordType recordType; private IJObject[] fields; private Map<String, IJObject> openFields; RecordBuilder recordBuilder = new RecordBuilder(); ArrayBackedValueStorage fieldName = new ArrayBackedValueStorage(); ArrayBackedValueStorage fieldValue = new ArrayBackedValueStorage(); AMutableString nameString = new AMutableString(""); public JRecord(ARecordType recordType, IJObject[] fields) { this.recordType = recordType; this.fields = fields; this.openFields = new LinkedHashMap<>(); } public JRecord(ARecordType recordType, IJObject[] fields, LinkedHashMap<String, IJObject> openFields) { this(recordType, fields); this.openFields = openFields; } public void addField(String fieldName, IJObject fieldValue) throws HyracksDataException { int pos = getFieldPosByName(fieldName); if (pos >= 0) {
response: import java.io.DataOutput; import java.io.IOException; import java.util.LinkedHashMap; import java.util.Map; public final class JRecord implements IJObject { private ARecordType recordType; private IJObject[] fields; private Map<String, IJObject> openFields; private RecordBuilder recordBuilder = new RecordBuilder(); private ArrayBackedValueStorage fieldName = new ArrayBackedValueStorage(); private ArrayBackedValueStorage fieldValue = new ArrayBackedValueStorage(); private AMutableString nameString = new AMutableString(""); private static final AStringSerializerDeserializer aStringSerDer = AStringSerializerDeserializer.INSTANCE; public JRecord(ARecordType recordType, IJObject[] fields) { this.recordType = recordType; this.fields = fields; this.openFields = new LinkedHashMap<>(); } public JRecord(ARecordType recordType, IJObject[] fields, LinkedHashMap<String, IJObject> openFields) { this(recordType, fields); this.openFields = openFields; } public void addField(String fieldName, IJObject fieldValue) throws HyracksDataException { int pos = getFieldPosByName(fieldName); if (pos >= 0) { // Add field logic } } private int getFieldPosByName(String fieldName) { // Get field position logic } }

sample: 1013
buggy_code: <|startfocus|> public JRecord(ARecordType recordType, IJObject[] fields, LinkedHashMap<String, IJObject> openFields) { <|endfocus|> this(recordType, fields); this.openFields = openFields;
code_review:  MAJOR SonarQube violation: The type of the "openFields" object should be an interface such as "Map" rather than the implementation "LinkedHashMap". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 
target code: public JRecord(ARecordType recordType, IJObject[] fields, Map<String, IJObject> openFields) { this(recordType, fields); this.openFields = openFields;
response: public JRecord(ARecordType recordType, IJObject[] fields, Map<String, IJObject> openFields) { this(recordType, fields); this.openFields = openFields; }

sample: 1014
buggy_code:  return new ARecord(mergedRecordType, mergedFields); } @Override public void reset() throws HyracksDataException { if (openFields != null && !openFields.isEmpty()) { openFields.clear(); } if (fields != null) { for (IJObject field : fields) { if (field != null) { field.reset(); } } } } <|startfocus|> public void reset(IJObject[] fields, LinkedHashMap<String, IJObject> openFields) throws HyracksDataException { <|endfocus|> this.reset(); this.fields = fields; this.openFields = openFields; } } 
code_review:  MAJOR SonarQube violation: The type of the "openFields" object should be an interface such as "Map" rather than the implementation "LinkedHashMap". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 
target code: return new ARecord(mergedRecordType, mergedFields); } @Override public void reset() throws HyracksDataException { if (openFields != null && !openFields.isEmpty()) { openFields.clear(); } if (fields != null) { for (IJObject field : fields) { if (field != null) { field.reset(); } } } } public void reset(IJObject[] fields, Map<String, IJObject> openFields) throws HyracksDataException { this.reset(); this.fields = fields; this.openFields = openFields; } }
response: import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator; import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.util.string.UTF8StringUtil; public class FullTextContainsDescriptor extends AbstractScalarFunctionDynamicDescriptor { private static final long serialVersionUID = 1L; public static final LinkedHashMap<String, ATypeTag> paramTypeMap = new LinkedHashMap<>(); public static final String SEARCH_MODE_OPTION = "mode"; public static final String DISJUNCTIVE_SEARCH_MODE_OPTION = "any"; public static final String CONJUNCTIVE_SEARCH_MODE_OPTION = "all"; static final byte[] searchModeOptionArray = UTF8StringUtil.writeStringToBytes(SEARCH_MODE_OPTION); static final byte[] disjunctiveFTSearchOptionArray = UTF8StringUtil.writeStringToBytes(DISJUNCTIVE_SEARCH_MODE_OPTION); static final byte[] conjunctiveFTSearchOptionArray = UTF8StringUtil.writeStringToBytes(CONJUNCTIVE_SEARCH_MODE_OPTION); static { paramTypeMap.put(SEARCH_MODE_OPTION, ATypeTag.STRING); } } public HashMap<Long, LocalResource> loadAndGetAllResources() throws HyracksDataException { //TODO During recovery, the memory usage currently is proportional to the number of resources available. //This could be fixed by traversing all resources on disk until the required resource is found. HashMap<Long, LocalResource> resourcesMap = new HashMap<Long, LocalResource>(); for (int i = 0; i < mountPoints.length; i++) { File storageRootDir = getStorageRootDirectoryIfExists(mountPoints[i], nodeId, i); if (storageRootDir == null) { continue; } //load all local resources. } return resourcesMap; } return new ARecord(mergedRecordType, mergedFields); @Override public void reset() throws HyracksDataException { if (openFields != null && !openFields.isEmpty()) { openFields.clear(); } if (fields != null) { for (IJObject field : fields) { if (field != null) { field.reset(); } } } } public void reset(IJObject[] fields, Map<String, IJObject> openFields) throws HyracksDataException { this.reset();

sample: 1015
buggy_code:  * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { <|startfocus|> public static JBuiltinType JBooleanType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() {
code_review:  MAJOR SonarQube violation: Add a private constructor to hide the implicit public one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1118 
target code: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() {
response: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { private JBuiltinType() { } public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() {

sample: 1016
buggy_code:  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { <|startfocus|> public static JBuiltinType JBooleanType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JBooleanType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } };
response: ```java package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; @Override public abstract IAType getIAType(); } ``` ```java package org.apache.asterix.om.base; import org.apache.asterix.common.exceptions.AsterixException; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; import org.apache.asterix.om.visitors.IOMVisitor; import org.json.JSONException; import org.json.JSONObject; public final class ABoolean implements IAObject { public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); private final Boolean bVal; private ABoolean(boolean b) { bVal = Boolean.valueOf(b); } public Boolean getBoolean() { return bVal; } public ABoolean valueOf(boolean b) { return b ? TRUE : FALSE; } @Override public IAType getType() { return BuiltinType.ABOOLEAN; } @Override public String toString() { return "ABoolean: {" + bVal + "}"; } public boolean equals(Object obj) { return obj == this; } @Override public int hashCode() { return super.hashCode(); } } ``` ```java package org.apache

sample: 1017
buggy_code:  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { <|startfocus|> public static JBuiltinType JBooleanType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } };
code_review:  MAJOR SonarQube violation: Make JBooleanType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } };
response: package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; @Override public abstract IAType getIAType(); }

sample: 1018
buggy_code:  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { <|startfocus|> public static JBuiltinType JBooleanType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } };
code_review:  MAJOR SonarQube violation: Rename this field "JBooleanType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } };
response: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; @Override public abstract IAType getIAType(); }

sample: 1019
buggy_code:  * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; <|startfocus|> public static JBuiltinType JByteType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override
code_review:  CRITICAL SonarQube violation: Make this "public static JByteType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JBYTE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override
response: package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; }

sample: 1020
buggy_code:  * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; <|startfocus|> public static JBuiltinType JByteType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override
code_review:  MAJOR SonarQube violation: Make JByteType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JBYTE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override
response: package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; }

sample: 1021
buggy_code:  * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; <|startfocus|> public static JBuiltinType JByteType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override
code_review:  MAJOR SonarQube violation: Rename this field "JByteType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JBYTE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override
response: package org.apache.asterix.external.library.java.base.builtin; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; }

sample: 1022
buggy_code:  import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; <|startfocus|> public static JBuiltinType JCircleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() {
code_review:  CRITICAL SonarQube violation: Make this "public static JCircleType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCIRCLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() {
response: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; }

sample: 1023
buggy_code:  import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; <|startfocus|> public static JBuiltinType JCircleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() {
code_review:  MAJOR SonarQube violation: Make JCircleType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCIRCLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() {
response: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; }

sample: 1024
buggy_code:  import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; <|startfocus|> public static JBuiltinType JCircleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() {
code_review:  MAJOR SonarQube violation: Rename this field "JCircleType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCIRCLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() {
response: import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; public abstract class JBuiltinType implements IJType { public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() {

sample: 1025
buggy_code:  public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; <|startfocus|> public static JBuiltinType JDateType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; 
code_review:  CRITICAL SonarQube violation: Make this "public static JDateType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDATE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };
response: public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };

sample: 1026
buggy_code:  public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; <|startfocus|> public static JBuiltinType JDateType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; 
code_review:  MAJOR SonarQube violation: Make JDateType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDATE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };
response: public static final JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };

sample: 1027
buggy_code:  public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; <|startfocus|> public static JBuiltinType JDateType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; 
code_review:  MAJOR SonarQube violation: Rename this field "JDateType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: public static JBuiltinType JBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDATE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };
response: public static JBuiltinType jBooleanType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } }; public static JBuiltinType jByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType jCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType jDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType jDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType jDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType jDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };

sample: 1028
buggy_code:  } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; <|startfocus|> public static JBuiltinType JDateTimeType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; 
code_review:  CRITICAL SonarQube violation: Make this "public static JDateTimeType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDATETIME = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } };
response: } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } };

sample: 1029
buggy_code:  } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; <|startfocus|> public static JBuiltinType JDateTimeType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; 
code_review:  MAJOR SonarQube violation: Make JDateTimeType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDATETIME = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } };
response: public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } };

sample: 1030
buggy_code:  } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; <|startfocus|> public static JBuiltinType JDateTimeType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; 
code_review:  MAJOR SonarQube violation: Rename this field "JDateTimeType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDATETIME = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JByteType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() {

sample: 1031
buggy_code:  } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; <|startfocus|> public static JBuiltinType JDoubleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; 
code_review:  CRITICAL SonarQube violation: Make this "public static JDoubleType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDOUBLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } };
response: ```java } }; public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; ```

sample: 1032
buggy_code:  } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; <|startfocus|> public static JBuiltinType JDoubleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; 
code_review:  MAJOR SonarQube violation: Make JDoubleType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDOUBLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } };
response: public static final JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } };

sample: 1033
buggy_code:  } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; <|startfocus|> public static JBuiltinType JDoubleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; 
code_review:  MAJOR SonarQube violation: Rename this field "JDoubleType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JCircleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDOUBLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @Override

sample: 1034
buggy_code:  } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; <|startfocus|> public static JBuiltinType JDurationType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; 
code_review:  CRITICAL SonarQube violation: Make this "public static JDurationType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDURATION = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } };
response: } }; public static final JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } };

sample: 1035
buggy_code:  } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; <|startfocus|> public static JBuiltinType JDurationType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; 
code_review:  MAJOR SonarQube violation: Make JDurationType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDURATION = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } };
response: public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } };

sample: 1036
buggy_code:  } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; <|startfocus|> public static JBuiltinType JDurationType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; 
code_review:  MAJOR SonarQube violation: Rename this field "JDurationType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JDateType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATE; } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDURATION = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @Override

sample: 1037
buggy_code:  } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; <|startfocus|> public static JBuiltinType JFloatType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JFloatType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFLOAT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };
response: ```java } }; public static final JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; ```

sample: 1038
buggy_code:  } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; <|startfocus|> public static JBuiltinType JFloatType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };
code_review:  MAJOR SonarQube violation: Make JFloatType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFLOAT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };
response: public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } };

sample: 1039
buggy_code:  } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; <|startfocus|> public static JBuiltinType JFloatType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };
code_review:  MAJOR SonarQube violation: Rename this field "JFloatType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JDateTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFLOAT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @Override

sample: 1040
buggy_code:  } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; <|startfocus|> public static JBuiltinType JIntType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JIntType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JINT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } };
response: ```java } }; public static final JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; ```

sample: 1041
buggy_code:  } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; <|startfocus|> public static JBuiltinType JIntType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } };
code_review:  MAJOR SonarQube violation: Make JIntType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JINT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } };
response: public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } };

sample: 1042
buggy_code:  } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; <|startfocus|> public static JBuiltinType JIntType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } };
code_review:  MAJOR SonarQube violation: Rename this field "JIntType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JDoubleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADOUBLE; } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JINT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @Override

sample: 1043
buggy_code:  } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; <|startfocus|> public static JBuiltinType JIntervalType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JIntervalType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JINTERVAL = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };
response: } }; public static final JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };

sample: 1044
buggy_code:  } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; <|startfocus|> public static JBuiltinType JIntervalType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };
code_review:  MAJOR SonarQube violation: Make JIntervalType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JINTERVAL = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };
response: public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } };

sample: 1045
buggy_code:  } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; <|startfocus|> public static JBuiltinType JIntervalType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };
code_review:  MAJOR SonarQube violation: Rename this field "JIntervalType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JDurationType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ADURATION; } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JINTERVAL = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; }

sample: 1046
buggy_code:  } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; <|startfocus|> public static JBuiltinType JLineType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JLineType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLINE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };
response: } }; public static final JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };

sample: 1047
buggy_code:  } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; <|startfocus|> public static JBuiltinType JLineType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };
code_review:  MAJOR SonarQube violation: Make JLineType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLINE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };
response: public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } };

sample: 1048
buggy_code:  } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; <|startfocus|> public static JBuiltinType JLineType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };
code_review:  MAJOR SonarQube violation: Rename this field "JLineType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JFloatType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AFLOAT; } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLINE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @Override

sample: 1049
buggy_code:  } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; <|startfocus|> public static JBuiltinType JLongType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JLongType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLONG = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };
response: } }; public static final JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };

sample: 1050
buggy_code:  } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; <|startfocus|> public static JBuiltinType JLongType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };
code_review:  MAJOR SonarQube violation: Make JLongType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLONG = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };
response: public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };

sample: 1051
buggy_code:  } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; <|startfocus|> public static JBuiltinType JLongType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };
code_review:  MAJOR SonarQube violation: Rename this field "JLongType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JIntType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT32; } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLONG = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @

sample: 1052
buggy_code:  } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; <|startfocus|> public static JBuiltinType JMissingType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JMissingType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMISSING = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };
response: } }; public static final JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };

sample: 1053
buggy_code:  } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; <|startfocus|> public static JBuiltinType JMissingType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };
code_review:  MAJOR SonarQube violation: Make JMissingType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMISSING = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };
response: public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } };

sample: 1054
buggy_code:  } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; <|startfocus|> public static JBuiltinType JMissingType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };
code_review:  MAJOR SonarQube violation: Rename this field "JMissingType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JIntervalType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMISSING = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @

sample: 1055
buggy_code:  } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; <|startfocus|> public static JBuiltinType JNullType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JNullType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNULL = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };
response: } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };

sample: 1056
buggy_code:  } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; <|startfocus|> public static JBuiltinType JNullType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };
code_review:  MAJOR SonarQube violation: Make JNullType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNULL = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };
response: } }; public static final JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };

sample: 1057
buggy_code:  } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; <|startfocus|> public static JBuiltinType JNullType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };
code_review:  MAJOR SonarQube violation: Rename this field "JNullType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JLineType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ALINE; } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNULL = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @

sample: 1058
buggy_code:  } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; <|startfocus|> public static JBuiltinType JPointType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JPointType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPOINT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };
response: ```java } }; public static final JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static final JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; ```

sample: 1059
buggy_code:  } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; <|startfocus|> public static JBuiltinType JPointType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };
code_review:  MAJOR SonarQube violation: Make JPointType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPOINT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };
response: public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };

sample: 1060
buggy_code:  } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; <|startfocus|> public static JBuiltinType JPointType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };
code_review:  MAJOR SonarQube violation: Rename this field "JPointType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JLongType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT64; } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPOINT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; }

sample: 1061
buggy_code:  } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; <|startfocus|> public static JBuiltinType JPoint3DType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JPoint3DType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPOINT3D = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } };
response: public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };

sample: 1062
buggy_code:  } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; <|startfocus|> public static JBuiltinType JPoint3DType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } };
code_review:  MAJOR SonarQube violation: Make JPoint3DType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPOINT3D = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } };
response: public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } };

sample: 1063
buggy_code:  } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; <|startfocus|> public static JBuiltinType JPoint3DType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } };
code_review:  MAJOR SonarQube violation: Rename this field "JPoint3DType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JMissingType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AMISSING; } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPOINT3D = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } };
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, * the expression to consider. * @param env, * the type environment. * @param checker, * the argument type checker. * @param resultTypeGenerator, * the result type generator. */ public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; }

sample: 1064
buggy_code:  } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; <|startfocus|> public static JBuiltinType JPolygonType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };
code_review:  CRITICAL SonarQube violation: Make this "public static JPolygonType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPOLYGON = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };
response: } }; public static final JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };

sample: 1065
buggy_code:  } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; <|startfocus|> public static JBuiltinType JPolygonType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };
code_review:  MAJOR SonarQube violation: Make JPolygonType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPOLYGON = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };
response: public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };

sample: 1066
buggy_code:  } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; <|startfocus|> public static JBuiltinType JPolygonType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };
code_review:  MAJOR SonarQube violation: Rename this field "JPolygonType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPOLYGON = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };
response: } }; public static JBuiltinType JNullType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ANULL; } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };

sample: 1067
buggy_code:  } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; <|startfocus|> public static JBuiltinType JRectangleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  CRITICAL SonarQube violation: Make this "public static JRectangleType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRECTANGLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: ```java } }; public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; ```

sample: 1068
buggy_code:  } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; <|startfocus|> public static JBuiltinType JRectangleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Make JRectangleType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRECTANGLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: public class MyClass { public static final JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }

sample: 1069
buggy_code:  } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; <|startfocus|> public static JBuiltinType JRectangleType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Rename this field "JRectangleType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JPointType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT; } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRECTANGLE = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }

sample: 1070
buggy_code:  } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; <|startfocus|> public static JBuiltinType JShortType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  CRITICAL SonarQube violation: Make this "public static JShortType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JSHORT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: ```java } }; public static final JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static final JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; ```

sample: 1071
buggy_code:  } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; <|startfocus|> public static JBuiltinType JShortType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Make JShortType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JSHORT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } };

sample: 1072
buggy_code:  } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; <|startfocus|> public static JBuiltinType JShortType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Rename this field "JShortType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JPoint3DType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JSHORT = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static void resolveResultType(ILogicalExpression expr, IVariableTypeEnvironment env, ArgTypeChecker checker, ResultTypeGenerator resultTypeGenerator) throws AlgebricksException { // implementation goes here } } public class Tracer implements ITracer { protected static final Level TRACE_LOG_LEVEL = Level.INFO; protected final Logger traceLog; protected String[] categories; protected static final int pid = PidHelper.getPid(); public Tracer(String name, String[] categories) { this.traceLog = Logger.getLogger(Tracer.class.getName() + "@" + name); this.categories = categories; } public static final Tracer ALL = new Tracer("All", new String[] { "*" }); @Override public String toString() { return getName() + Arrays.toString(categories) + (isEnabled() ? "enabled" : "disabled"); } @Override public String getName() { return traceLog.getName(); } @

sample: 1073
buggy_code:  } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; <|startfocus|> public static JBuiltinType JStringType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  CRITICAL SonarQube violation: Make this "public static JStringType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JSTRING = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: ```java public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; ```

sample: 1074
buggy_code:  } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; <|startfocus|> public static JBuiltinType JStringType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Make JStringType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JSTRING = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } };

sample: 1075
buggy_code:  } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; <|startfocus|> public static JBuiltinType JStringType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Rename this field "JStringType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JPolygonType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.APOLYGON; } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JSTRING = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }

sample: 1076
buggy_code:  } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; <|startfocus|> public static JBuiltinType JTimeType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  CRITICAL SonarQube violation: Make this "public static JTimeType" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 
target code: } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTIME = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: ```java public static final JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; ```

sample: 1077
buggy_code:  } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; <|startfocus|> public static JBuiltinType JTimeType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Make JTimeType a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTIME = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: public class MyClass { public static final JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static final JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static final JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }

sample: 1078
buggy_code:  } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; <|startfocus|> public static JBuiltinType JTimeType = new JBuiltinType() { <|endfocus|> @Override public IAType getIAType() { return BuiltinType.ATIME; } }; } 
code_review:  MAJOR SonarQube violation: Rename this field "JTimeType" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 
target code: } }; public static JBuiltinType JRectangleType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ARECTANGLE; } }; public static JBuiltinType JShortType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.AINT8; } }; public static JBuiltinType JStringType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ASTRING; } }; public static final JBuiltinType JTIME = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }
response: import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, the expression to consider. * @param env, the type environment. * @param checker, the argument type checker. * @param resultTypeGenerator, the result type generator. */ public static JBuiltinType JTimeType = new JBuiltinType() { @Override public IAType getIAType() { return BuiltinType.ATIME; } }; }

sample: 1079
buggy_code:  ((AMutableCircle) (value)).setValue((APoint) center.getIAObject(), radius); } @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.CIRCLE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> ACircleSerializerDeserializer.INSTANCE.serialize(((AMutableCircle) (value)), dataOutput); <|endfocus|> } @Override public void reset() { ((AMutableCircle) value).setValue(null, 0); } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: ((AMutableCircle) (value)).setValue((APoint) center.getIAObject(), radius); } @Override public IAType getIAType() { return BuiltinType.ACIRCLE; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.CIRCLE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ACircleSerializerDeserializer.INSTANCE.serialize((AMutableCircle) value, dataOutput); } @Override public void reset() { ((AMutableCircle) value).setValue(null, 0); } }
response: public static IValueParserFactory[] getValueParserFactories(ARecordType recordType) { int n = recordType.getFieldTypes().length; IValueParserFactory[] fieldParserFactories = new IValueParserFactory[n]; for (int i = 0; i < n; i++) { ATypeTag tag = null; if (recordType.getFieldTypes()[i].getTypeTag() == ATypeTag.UNION) { AUnionType unionType = (AUnionType) recordType.getFieldTypes()[i]; if (!unionType.isNullableType()) { throw new NotImplementedException("Non-optional UNION type is not supported."); } tag = unionType.getActualType().getTypeTag(); } else { tag = recordType.getFieldTypes()[i].getTypeTag(); } if (tag == null) { throw new NotImplementedException("Failed to get the type information for field " + i + "."); } fieldParserFactories[i] = getParserFactory(tag); } return fieldParserFactories; } if (!typeTag.equals(ATypeTag.BOOLEAN)) { throw new AlgebricksException(AsterixBuiltinFunctions.EDIT_DISTANCE_STRING_IS_FILTERABLE.getName() + ": expects input type BOOLEAN as fourth argument, but got " + typeTag + "."); } boolean usePrePost = BooleanPointable.getBoolean(usePrePostPtr.getByteArray(), usePrePostPtr.getStartOffset() + 1); long numGrams = usePrePost ? strLen + gramLen - 1 : strLen - gramLen + 1; long lowerBound = numGrams - edThresh * gramLen; try { if (lowerBound <= 0 || strLen == 0) { booleanSerde.serialize(ABoolean.FALSE, output); } else { booleanSerde.serialize(ABoolean.TRUE, output); } } catch (IOException e) { throw new AlgebricksException(e); } result.set(resultStorage); private int indexOf(byte[] source, int sourceOffset, int sourceCount, byte[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex >= sourceCount) { return targetCount == 0 ? sourceCount : -1; } int from = fromIndex; if (from < 0) { from = 0; } if (targetCount ==

sample: 1080
buggy_code:  public JDate(int chrononTimeInDays) { super(new AMutableDate(chrononTimeInDays)); } public void setValue(int chrononTimeInDays) { ((AMutableDate) value).setValue(chrononTimeInDays); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DATE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> ADateSerializerDeserializer.INSTANCE.serialize(((AMutableDate) value), dataOutput); <|endfocus|> } @Override public void reset() { ((AMutableDate) value).setValue(0); } @Override public IAType getIAType() { return BuiltinType.ADATE; } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public JDate(int chrononTimeInDays) { super(new AMutableDate(chrononTimeInDays)); } public void setValue(int chrononTimeInDays) { ((AMutableDate) value).setValue(chrononTimeInDays); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DATE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ADateSerializerDeserializer.INSTANCE.serialize((AMutableDate) value, dataOutput); } @Override public void reset() { ((AMutableDate) value).setValue(0); } @Override public IAType getIAType() { return BuiltinType.ADATE; } }
response: public JDate(int chrononTimeInDays) { super(new AMutableDate(chrononTimeInDays)); } public void setValue(int chrononTimeInDays) { ((AMutableDate) value).setValue(chrononTimeInDays); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DATE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ADateSerializerDeserializer.INSTANCE.serialize(((AMutableDate) value), dataOutput); } @Override public void reset() { ((AMutableDate) value).setValue(0); } @Override public IAType getIAType() { return BuiltinType.ADATE; }

sample: 1081
buggy_code:  public JDateTime(long chrononTime) { super(new AMutableDateTime(chrononTime)); } public void setValue(long chrononTime) { ((AMutableDateTime) value).setValue(chrononTime); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DATETIME.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> ADateTimeSerializerDeserializer.INSTANCE.serialize(((AMutableDateTime) value), dataOutput); <|endfocus|> } @Override public void reset() { ((AMutableDateTime) value).setValue(0); } @Override public IAType getIAType() { return BuiltinType.ADATETIME; } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public JDateTime(long chrononTime) { super(new AMutableDateTime(chrononTime)); } public void setValue(long chrononTime) { ((AMutableDateTime) value).setValue(chrononTime); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DATETIME.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ADateTimeSerializerDeserializer.INSTANCE.serialize((AMutableDateTime) value, dataOutput); } @Override public void reset() { ((AMutableDateTime) value).setValue(0); } @Override public IAType getIAType() { return BuiltinType.ADATETIME; } }
response: public JDateTime(long chrononTime) { super(new AMutableDateTime(chrononTime)); } public void setValue(long chrononTime) { ((AMutableDateTime) value).setValue(chrononTime); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DATETIME.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ADateTimeSerializerDeserializer.INSTANCE.serialize((AMutableDateTime) value, dataOutput); } @Override public void reset() { ((AMutableDateTime) value).setValue(0); } @Override public IAType getIAType() { return BuiltinType.ADATETIME; }

sample: 1082
buggy_code:  super(new AMutableDuration(months, milliseconds)); } public void setValue(int months, long milliseconds) { ((AMutableDuration) value).setValue(months, milliseconds); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DURATION.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> ADurationSerializerDeserializer.INSTANCE.serialize(((AMutableDuration) value), dataOutput); <|endfocus|> } @Override public void reset() { ((AMutableDuration) value).setValue(0, 0); } @Override public IAType getIAType() { return BuiltinType.ADURATION; } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: super(new AMutableDuration(months, milliseconds)); } public void setValue(int months, long milliseconds) { ((AMutableDuration) value).setValue(months, milliseconds); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DURATION.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ADurationSerializerDeserializer.INSTANCE.serialize((AMutableDuration) value, dataOutput); } @Override public void reset() { ((AMutableDuration) value).setValue(0, 0); } @Override public IAType getIAType() { return BuiltinType.ADURATION; } }
response: public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.DURATION.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ADurationSerializerDeserializer.INSTANCE.serialize((AMutableDuration) value, dataOutput); } @Override public void reset() { ((AMutableDuration) value).setValue(0, 0); } @Override public IAType getIAType() { return BuiltinType.ADURATION; }

sample: 1083
buggy_code:  } public long getIntervalEnd() { return ((AMutableInterval) value).getIntervalEnd(); } public short getIntervalType() { return ((AMutableInterval) value).getIntervalType(); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.INTERVAL.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> AIntervalSerializerDeserializer.INSTANCE.serialize(((AMutableInterval) value), dataOutput); <|endfocus|> } @Override public void reset() throws HyracksDataException { ((AMutableInterval) value).setValue(0L, 0L, (byte) 0); } @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: } public long getIntervalEnd() { return ((AMutableInterval) value).getIntervalEnd(); } public short getIntervalType() { return ((AMutableInterval) value).getIntervalType(); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.INTERVAL.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } AIntervalSerializerDeserializer.INSTANCE.serialize((AMutableInterval) value, dataOutput); } @Override public void reset() throws HyracksDataException { ((AMutableInterval) value).setValue(0L, 0L, (byte) 0); } @Override public IAType getIAType() { return BuiltinType.AINTERVAL; } }
response: public long getIntervalEnd() { return ((AMutableInterval) value).getIntervalEnd(); } public short getIntervalType() { return ((AMutableInterval) value).getIntervalType(); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.INTERVAL.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } AIntervalSerializerDeserializer.INSTANCE.serialize((AMutableInterval) value, dataOutput); } @Override public void reset() throws HyracksDataException { ((AMutableInterval) value).setValue(0L, 0L, (byte) 0); } @Override public IAType getIAType() { return BuiltinType.AINTERVAL; }

sample: 1084
buggy_code:  } public void setValue(APoint p1, APoint p2) { ((AMutableLine) value).setValue(p1, p2); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.LINE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> ALineSerializerDeserializer.INSTANCE.serialize(((AMutableLine) value), dataOutput); <|endfocus|> } @Override public void reset() { ((AMutableLine) value).setValue(null, null); } @Override public IAType getIAType() { return BuiltinType.ALINE; } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: } public void setValue(APoint p1, APoint p2) { ((AMutableLine) value).setValue(p1, p2); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.LINE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ALineSerializerDeserializer.INSTANCE.serialize((AMutableLine) value, dataOutput); } @Override public void reset() { ((AMutableLine) value).setValue(null, null); } @Override public IAType getIAType() { return BuiltinType.ALINE; } }
response: public void setValue(APoint p1, APoint p2) { ((AMutableLine) value).setValue(p1, p2); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.LINE.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } ALineSerializerDeserializer.INSTANCE.serialize(((AMutableLine) value), dataOutput); } @Override public void reset() { ((AMutableLine) value).setValue(null, null); } @Override public IAType getIAType() { return BuiltinType.ALINE; }

sample: 1085
buggy_code: <|startfocus|> public void reset() { <|endfocus|>
code_review:  MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 
target code: public void reset() { // no op for NULL
response: public void reset() { // Method intentionally left empty }

sample: 1086
buggy_code:  public double getYValue() { return ((AMutablePoint3D) value).getY(); } public double getZValue() { return ((AMutablePoint3D) value).getZ(); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.POINT3D.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } <|startfocus|> APoint3DSerializerDeserializer.INSTANCE.serialize(((AMutablePoint3D) value), dataOutput); <|endfocus|> } @Override public void reset() { ((AMutablePoint3D) value).setValue(0, 0, 0); } @Override public IAType getIAType() { return BuiltinType.APOINT3D; } } 
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public double getYValue() { return ((AMutablePoint3D) value).getY(); } public double getZValue() { return ((AMutablePoint3D) value).getZ(); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.POINT3D.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } APoint3DSerializerDeserializer.INSTANCE.serialize((AMutablePoint3D) value, dataOutput); } @Override public void reset() { ((AMutablePoint3D) value).setValue(0, 0, 0); } @Override public IAType getIAType() { return BuiltinType.APOINT3D; } }
response: public double getYValue() { return ((AMutablePoint3D) value).getY(); } public double getZValue() { return ((AMutablePoint3D) value).getZ(); } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { if (writeTypeTag) { try { dataOutput.writeByte(ATypeTag.POINT3D.serialize()); } catch (IOException e) { throw new HyracksDataException(e); } } APoint3DSerializerDeserializer.INSTANCE.serialize((AMutablePoint3D) value, dataOutput); } @Override public void reset() { ((AMutablePoint3D) value).setValue(0, 0, 0); } @Override public IAType getIAType() { return BuiltinType.APOINT3D; }

sample: 1087
buggy_code:  builder.appendString(String.valueOf(i)); break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); <|startfocus|> } else if (d == Double.NEGATIVE_INFINITY) { <|endfocus|> builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) {
code_review:  CRITICAL SonarQube violation: Equality tests should not be made with floating point values. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1244 
target code: builder.appendString(String.valueOf(i)); break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) {
response: builder.appendString(String.valueOf(i)); break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } }

sample: 1088
buggy_code:  break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); <|startfocus|> } else if (d == Double.NEGATIVE_INFINITY) { <|endfocus|> builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) {
code_review:  CRITICAL SonarQube violation: Equality tests should not be made with floating point values. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1244 
target code: break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) {
response: case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; }

sample: 1089
buggy_code:  } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); <|startfocus|> } else if (f == Double.NEGATIVE_INFINITY) { <|endfocus|> builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT:
code_review:  CRITICAL SonarQube violation: Equality tests should not be made with floating point values. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1244 
target code: } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Float.NEGATIVE_INFINITY) { // NOSONAR builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT:
response: } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT:

sample: 1090
buggy_code:  builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); <|startfocus|> } else if (f == Double.NEGATIVE_INFINITY) { <|endfocus|> builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT: case POINT3D: case RECTANGLE: case POLYGON:
code_review:  CRITICAL SonarQube violation: Equality tests should not be made with floating point values. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1244 
target code: builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Float.NEGATIVE_INFINITY) { // NOSONAR builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT: case POINT3D: case RECTANGLE: case POLYGON:
response: builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT: case POINT3D: case RECTANGLE: case POLYGON:

sample: 1091
buggy_code:  builder.appendString(String.valueOf(i)); break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); <|startfocus|> } else if (d == Double.NEGATIVE_INFINITY) { <|endfocus|> builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) {
code_review:  Add // NOSONAR at the end of the line. 
target code: builder.appendString(String.valueOf(i)); break; } case BIGINT: { long l = AInt64SerializerDeserializer.getLong(serString, startOffset); builder.appendString(String.valueOf(l)); break; } case DOUBLE: { double d = ADoubleSerializerDeserializer.getDouble(serString, startOffset); if (Double.isNaN(d)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (d == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) {
response: builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); // NOSONAR } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); // NOSONAR } else { builder.appendString(String.valueOf(f)); } break; }

sample: 1092
buggy_code:  } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); <|startfocus|> } else if (f == Double.NEGATIVE_INFINITY) { <|endfocus|> builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT:
code_review:  Float 
target code: } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); } break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Float.NEGATIVE_INFINITY) { // NOSONAR builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT:
response: } else if (d == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(d)); break; } case FLOAT: { float f = AFloatSerializerDeserializer.getFloat(serString, startOffset); if (Float.isNaN(f)) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NAN); } else if (f == Double.POSITIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.POSITIVE_INF); } else if (f == Double.NEGATIVE_INFINITY) { builder.appendUtf8StringPointable(AbstractDoubleConstructorEvaluator.NEGATIVE_INF); } else { builder.appendString(String.valueOf(f)); } break; } case BOOLEAN: { boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); builder.appendString(String.valueOf(b)); break; } // NotYetImplemented case CIRCLE: case DATE: case DATETIME: case LINE: case TIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: case INTERVAL: case ARRAY: case POINT:

sample: 1093
buggy_code:  completeOperation(index, opType, searchCallback, modificationCallback); } } @Override public synchronized void completeOperation(ILSMIndex index, LSMOperationType opType, ISearchOperationCallback searchCallback, IModificationOperationCallback modificationCallback) throws HyracksDataException { if (opType == LSMOperationType.MODIFICATION || opType == LSMOperationType.FORCE_MODIFICATION) { decrementNumActiveOperations(modificationCallback); <|startfocus|> if (numActiveOperations.get() == 0) { flushIfRequested(); } else if (numActiveOperations.get() < 0) { throw new HyracksDataException("The number of active operations cannot be negative!"); } <|endfocus|> } else if (opType == LSMOperationType.FLUSH || opType == LSMOperationType.MERGE || opType == LSMOperationType.REPLICATE) { dsInfo.undeclareActiveIOOperation(); } } public synchronized void flushIfNeeded() throws HyracksDataException { if (numActiveOperations.get() == 0) { flushIfRequested(); } } public void flushIfRequested() throws HyracksDataException { // If we need a flush, and this is the last completing operation, then schedule the flush,
code_review:  replace this by flushIfNeeded and move the < 0 check to decrementNumActiveOperations 
target code: completeOperation(index, opType, searchCallback, modificationCallback); } } @Override public synchronized void completeOperation(ILSMIndex index, LSMOperationType opType, ISearchOperationCallback searchCallback, IModificationOperationCallback modificationCallback) throws HyracksDataException { if (opType == LSMOperationType.MODIFICATION || opType == LSMOperationType.FORCE_MODIFICATION) { decrementNumActiveOperations(modificationCallback); flushIfNeeded(); } else if (opType == LSMOperationType.FLUSH || opType == LSMOperationType.MERGE || opType == LSMOperationType.REPLICATE) { dsInfo.undeclareActiveIOOperation(); } } public synchronized void flushIfNeeded() throws HyracksDataException { if (numActiveOperations.get() == 0) { flushIfRequested(); } } public void flushIfRequested() throws HyracksDataException { // If we need a flush, and this is the last completing operation, then schedule the flush,
response: import org.apache.asterix.external.input.record.reader.factory.SemiStructuredRecordReaderFactory; import org.apache.asterix.external.input.stream.factory.LocalFSInputStreamProviderFactory; import org.apache.asterix.external.input.stream.factory.SocketInputStreamProviderFactory; import org.apache.asterix.external.util.ExternalDataConstants; import org.apache.asterix.external.util.ExternalDataUtils; public class DatasourceFactoryProvider { public static IExternalDataSourceFactory getExternalDataSourceFactory(Map<String, String> configuration) throws Exception { switch (ExternalDataUtils.getDataSourceType(configuration)) { case RECORDS: return DatasourceFactoryProvider.getRecordReaderFactory(configuration); case STREAM: return DatasourceFactoryProvider.getInputStreamFactory(configuration.get(ExternalDataConstants.KEY_STREAM), configuration); } String reader = configuration.get(ExternalDataConstants.KEY_READER); if (reader != null) { return DatasourceFactoryProvider.getRecordReaderFactory(configuration); } return null; } public static IInputStreamProviderFactory getInputStreamFactory(String stream, Map<String, String> configuration) throws Exception { IInputStreamProviderFactory streamFactory; if (ExternalDataUtils.isExternal(stream)) { String dataverse = ExternalDataUtils.getDataverse(configuration); streamFactory = ExternalDataUtils.createExternalInputStreamFactory(dataverse, stream); } else { // Handle non-external stream } return streamFactory; } } protected void updateData(long start, long end, int nb, IProgressMonitor monitor) { double[] xAxis = getXAxis(start, end, nb); if (xAxis.length == 1) { return; } try (ScopeLog log = new ScopeLog(LOGGER, Level.FINE, "CounterChartViewer#updateData")) { for (CounterTreeViewerEntry counterEntry : Iterables.filter(fEntries, CounterTreeViewerEntry.class)) { if (monitor.isCanceled()) { return; } double[] steps = new double[xAxis.length]; ITmfStateSystem ss = counterEntry.getStateSystem(); Integer quark = counterEntry.getQuark(); // Perform necessary operations } } } import org.apache.impala.catalog.Type; import org.apache.impala.common.AnalysisException; import org.apache.impala.common.ImpalaException; import org.apache.impala.common.InternalException; import org.apache.impala.common.RuntimeEnv; import org.apache

sample: 1094
buggy_code:  public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { // Do nothing <|endfocus|> } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Exception e) { root = ExceptionUtils.suppress(root, e); } } return root; }

sample: 1095
buggy_code:  public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { // Do nothing <|endfocus|> } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1096
buggy_code:  public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // Do nothing } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); // NOSONAR } } return root;
response: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1097
buggy_code:  } public void write(IFileHandle fHandle, long offset, ByteBuffer data) throws HyracksDataException { if (state != State.INITIAL) { throw new IllegalStateException("Can't request a read operation through a " + state + " request"); } state = State.WRITE_REQUESTED; this.fHandle = fHandle; this.offset = offset; this.data = data; queue(); } private void queue() throws HyracksDataException { try { submittedRequests.put(this); <|startfocus|> } catch (InterruptedException e) { <|endfocus|> throw HyracksDataException.create(e); } } @Override public void await() throws InterruptedException { synchronized (this) { while (state != State.OPERATION_FAILED && state != State.OPERATION_SUCCEEDED) { wait(); } } } synchronized void handle() { try { if (state == State.READ_REQUESTED) { read = ioManager.doSyncRead(fHandle, offset, data); } else if (state == State.WRITE_REQUESTED) { if (data != null) { // single buffer
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: } public void write(IFileHandle fHandle, long offset, ByteBuffer data) throws HyracksDataException { if (state != State.INITIAL) { throw new IllegalStateException("Can't request a read operation through a " + state + " request"); } state = State.WRITE_REQUESTED; this.fHandle = fHandle; this.offset = offset; this.data = data; queue(); } private void queue() throws HyracksDataException { try { submittedRequests.put(this); } catch (InterruptedException e) { // NOSONAR: The call below will re-interrupt throw HyracksDataException.create(e); } } @Override public void await() throws InterruptedException { synchronized (this) { while (state != State.OPERATION_FAILED && state != State.OPERATION_SUCCEEDED) { wait(); } } } synchronized void handle() { try { if (state == State.READ_REQUESTED) { read = ioManager.doSyncRead(fHandle, offset, data); } else if (state == State.WRITE_REQUESTED) { if (data != null) { // single buffer
response: public void write(IFileHandle fHandle, long offset, ByteBuffer data) throws HyracksDataException { if (state != State.INITIAL) { throw new IllegalStateException("Can't request a read operation through a " + state + " request"); } state = State.WRITE_REQUESTED; this.fHandle = fHandle; this.offset = offset; this.data = data; queue(); } private void queue() throws HyracksDataException { try { submittedRequests.put(this); } catch (InterruptedException e) { throw HyracksDataException.create(e); } } @Override public void await() throws InterruptedException { synchronized (this) { while (state != State.OPERATION_FAILED && state != State.OPERATION_SUCCEEDED) { wait(); } } } synchronized void handle() { try { if (state == State.READ_REQUESTED) { read = ioManager.doSyncRead(fHandle, offset, data); } else if (state == State.WRITE_REQUESTED) { if (data != null) { // single buffer ioManager.doSyncWrite(fHandle, offset, data); } else { // multiple buffers ioManager.doSyncWrite(fHandle, offset, buffers); } } state = State.OPERATION_SUCCEEDED; } catch (Exception e) { state = State.OPERATION_FAILED; } synchronized (this) { notifyAll(); } }

sample: 1098
buggy_code:  read = ioManager.doSyncRead(fHandle, offset, data); } else if (state == State.WRITE_REQUESTED) { if (data != null) { // single buffer write = ioManager.doSyncWrite(fHandle, offset, data); } else { // multiple buffers writes = ioManager.doSyncWrite(fHandle, offset, dataArray); } } else { throw new IllegalStateException("IO Request with state = " + state); } state = State.OPERATION_SUCCEEDED; <|startfocus|> } catch (Throwable th) { <|endfocus|> state = State.OPERATION_FAILED; failure = HyracksDataException.create(th); } notifyAll(); } public State getState() { return state; } void recycle() { reset(); freeRequests.offer(this); } public int getRead() { return read; } public int getWrite() { return write; } public long getWrites() { return writes; } @Override public void run() throws InterruptedException { await(); } public HyracksDataException getFailure() { return failure;
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: read = ioManager.doSyncRead(fHandle, offset, data); } else if (state == State.WRITE_REQUESTED) { if (data != null) { // single buffer write = ioManager.doSyncWrite(fHandle, offset, data); } else { // multiple buffers writes = ioManager.doSyncWrite(fHandle, offset, dataArray); } } else { throw new IllegalStateException("IO Request with state = " + state); } state = State.OPERATION_SUCCEEDED; } catch (Throwable th) { // NOSONAR: This method must never throw anything state = State.OPERATION_FAILED; failure = HyracksDataException.create(th); } notifyAll(); } public State getState() { return state; } void recycle() { reset(); freeRequests.offer(this); } public int getRead() { return read; } public int getWrite() { return write; } public long getWrites() { return writes; } @Override public void run() throws InterruptedException { await(); } public HyracksDataException getFailure() { return failure;
response: read = ioManager.doSyncRead(fHandle, offset, data); } else if (state == State.WRITE_REQUESTED) { if (data != null) { // single buffer write write = ioManager.doSyncWrite(fHandle, offset, data); } else { // multiple buffers writes writes = ioManager.doSyncWrite(fHandle, offset, dataArray); } } else { throw new IllegalStateException("IO Request with state = " + state); } state = State.OPERATION_SUCCEEDED; try { // code block to be reviewed } catch (Exception e) { state = State.OPERATION_FAILED; failure = HyracksDataException.create(e); } notifyAll(); } public State getState() { return state; } void recycle() { reset(); freeRequests.offer(this); } public int getRead() { return read; } public int getWrite() { return write; } public long getWrites() { return writes; } @Override public void run() throws InterruptedException { await(); } public HyracksDataException getFailure() { return failure; }

sample: 1099
buggy_code:  public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); <|startfocus|> while (true) { <|endfocus|> IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); }
code_review:  MAJOR SonarQube violation: Reduce the total number of break and continue statements in this loop to use at most one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS135 
target code: public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { // NOSONAR: Suppress 1 continue and 1 break IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); }
response: public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); } }

sample: 1100
buggy_code:  public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); <|startfocus|> } catch (InterruptedException e) { <|endfocus|> LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); }
code_review:  CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 
target code: public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { // NOSONAR: This is not supposed to be ever interrupted LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); }
response: public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); Thread.currentThread().interrupt(); break; } next.handle(); } }

sample: 1101
buggy_code:  public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); <|startfocus|> } catch (Throwable th) { // NOSONAR Will be re-thrown <|endfocus|> try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  suppressed 
target code: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be suppressed try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // Do nothing } root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1102
buggy_code:  public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); <|startfocus|> } catch (Throwable loggingFailure) { // Do nothing <|endfocus|> } root = ExceptionUtils.suppress(root, th); } } return root;
code_review:  Suppress SQ warnings? 
target code: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { // NOSONAR Will be re-thrown try { LOGGER.log(Level.WARN, "Failure closing a closeable resource", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(AutoCloseable closable, Throwable root) { if (closable != null) { try { closable.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1103
buggy_code:  executor.execute(req); return req; } @Override public void close(IFileHandle fHandle) throws HyracksDataException { try { ((FileHandle) fHandle).close(); } catch (IOException e) { throw new HyracksDataException(e); } } public synchronized FileReference createWorkspaceFile(String prefix) throws HyracksDataException { IODeviceHandle dev = workAreaIODevices.get(workAreaDeviceIndex); workAreaDeviceIndex = (workAreaDeviceIndex + 1) % workAreaIODevices.size(); String waPath = dev.getWorkAreaPath(); File waf; try { <|startfocus|> waf = File.createTempFile(prefix, WORKSPACE_FILE_SUFFIX, new File(dev.getPath(), waPath)); <|endfocus|> } catch (IOException e) { throw new HyracksDataException(e); } return dev.createFileReference(waPath + File.separator + waf.getName()); } private abstract class AsyncRequest implements IIOFuture, Runnable { protected final FileHandle fHandle; protected final long offset; protected final ByteBuffer data; private boolean complete; private HyracksDataException exception; private int result; 
code_review:  Move this close to the other asyncWrite method? 
target code: executor.execute(req); return req; } @Override public void close(IFileHandle fHandle) throws HyracksDataException { try { ((FileHandle) fHandle).close(); } catch (IOException e) { throw new HyracksDataException(e); } } public synchronized FileReference createWorkspaceFile(String prefix) throws HyracksDataException { IODeviceHandle dev = workAreaIODevices.get(workAreaDeviceIndex); workAreaDeviceIndex = (workAreaDeviceIndex + 1) % workAreaIODevices.size(); String waPath = dev.getWorkAreaPath(); File waf; try { waf = File.createTempFile(prefix, WORKSPACE_FILE_SUFFIX, new File(dev.getMount(), waPath)); } catch (IOException e) { throw new HyracksDataException(e); } return dev.createFileReference(waPath + File.separator + waf.getName()); } private abstract class AsyncRequest implements IIOFuture, Runnable { protected final FileHandle fHandle; protected final long offset; protected final ByteBuffer data; private boolean complete; private HyracksDataException exception; private int result;
response: import org.apache.hyracks.api.exceptions.HyracksDataException; public class FeedStreamDataFlowController extends AbstractFeedDataFlowController implements IStreamFlowController { private IStreamDataParser dataParser; private AInputStream stream; @Override public void start(IFrameWriter writer) throws HyracksDataException { try { initializeTupleForwarder(writer); while (true) { tb.reset(); if (!dataParser.parse(tb.getDataOutput())) { break; } tb.addFieldEndOffset(); tupleForwarder.addTuple(tb); } } catch (Exception e) { throw new HyracksDataException(e); } } @Override public boolean stop() throws Exception { if (stream.stop()) { stream.close(); return true; } return false; } @Override public boolean handleException(Throwable th) { boolean handled = true; try { handled &= stream.skipError(); if (handled) { handled &= dataParser.reset(stream); } } catch (Exception e) { th.addSuppressed(e); return false; } return handled; } }

sample: 1104
buggy_code:  public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); <|startfocus|> } catch (InterruptedException e) { <|endfocus|> LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); }
code_review:  Suppress SQ warning? 
target code: public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { // NOSONAR: This is not supposed to be ever interrupted LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); }
response: @SuppressWarnings("unused") public void run() { Thread.currentThread().setName(getClass().getSimpleName() + "-" + num); while (true) { IoRequest next; try { next = queue.take(); } catch (InterruptedException e) { LOGGER.log(Level.WARN, "Ignoring interrupt. IO threads should never be interrupted."); continue; } if (next == POISON_PILL) { LOGGER.log(Level.INFO, "Exiting"); InvokeUtil.doUninterruptibly(() -> queue.put(POISON_PILL)); if (Thread.interrupted()) { LOGGER.log(Level.ERROR, "Ignoring interrupt. IO threads should never be interrupted."); } break; } next.handle(); } }

sample: 1105
buggy_code:  boolean finishConnect = false; try { finishConnect = channel.finishConnect(); } catch (IOException e) { key.cancel(); synchronized (connectionListener) { connectionListener.connectionFailure((InetSocketAddress) key.attachment(), e); } } if (finishConnect) { createConnection(key, channel); } } } } } catch (Exception e) { <|startfocus|> LOGGER.error(() -> new ParameterizedMessage("Error in TCPEndpoint {}", localAddress), e); <|endfocus|> } }
code_review:  not asking again 
target code: boolean finishConnect = false; try { finishConnect = channel.finishConnect(); } catch (IOException e) { key.cancel(); synchronized (connectionListener) { connectionListener.connectionFailure((InetSocketAddress) key.attachment(), e); } } if (finishConnect) { createConnection(key, channel); } } } } } catch (Exception e) { LOGGER.error("Error in TCPEndpoint {}", localAddress, e); } }
response: boolean finishConnect = false; try { finishConnect = channel.finishConnect(); } catch (IOException e) { key.cancel(); synchronized (connectionListener) { connectionListener.connectionFailure((InetSocketAddress) key.attachment(), e); } } if (finishConnect) { createConnection(key, channel); } } catch (Exception e) { LOGGER.error(() -> new ParameterizedMessage("Error in TCPEndpoint {}", localAddress), e); }

sample: 1106
buggy_code:  TestHelper.deleteExistingInstanceFiles(); String configPath = System.getProperty("user.dir") + File.separator + "src" + File.separator + "test" + File.separator + "resources" + File.separator + "cc.conf"; nc = new TestNodeController(configPath, false); nc.init(); ncAppCtx = nc.getAppRuntimeContext(); dsLifecycleMgr = ncAppCtx.getDatasetLifecycleManager(); } @AfterClass public static void tearDown() throws Exception { <|startfocus|> System.out.println("TearDown"); <|endfocus|> nc.deInit(); TestHelper.deleteExistingInstanceFiles(); } @Before public void createIndex() throws Exception { PrimaryIndexInfo primaryIndexInfo = StorageTestUtils.createPrimaryIndex(nc, PARTITION); IndexDataflowHelperFactory iHelperFactory = new IndexDataflowHelperFactory(nc.getStorageManager(), primaryIndexInfo.getFileSplitProvider()); JobId jobId = nc.newJobId(); ctx = nc.createTestContext(jobId, PARTITION, false); indexDataflowHelper = iHelperFactory.create(ctx.getJobletContext().getServiceContext(), PARTITION); indexDataflowHelper.open(); lsmBtree = (TestLsmBtree) indexDataflowHelper.getIndexInstance();
code_review:  Remove. 
target code: TestHelper.deleteExistingInstanceFiles(); String configPath = System.getProperty("user.dir") + File.separator + "src" + File.separator + "test" + File.separator + "resources" + File.separator + "cc.conf"; nc = new TestNodeController(configPath, false); nc.init(); ncAppCtx = nc.getAppRuntimeContext(); dsLifecycleMgr = ncAppCtx.getDatasetLifecycleManager(); } @AfterClass public static void tearDown() throws Exception { nc.deInit(); TestHelper.deleteExistingInstanceFiles(); } @Before public void createIndex() throws Exception { PrimaryIndexInfo primaryIndexInfo = StorageTestUtils.createPrimaryIndex(nc, PARTITION); IndexDataflowHelperFactory iHelperFactory = new IndexDataflowHelperFactory(nc.getStorageManager(), primaryIndexInfo.getFileSplitProvider()); JobId jobId = nc.newJobId(); ctx = nc.createTestContext(jobId, PARTITION, false); indexDataflowHelper = iHelperFactory.create(ctx.getJobletContext().getServiceContext(), PARTITION); indexDataflowHelper.open(); lsmBtree = (TestLsmBtree) indexDataflowHelper.getIndexInstance();
response: TestHelper.deleteExistingInstanceFiles(); String configPath = System.getProperty("user.dir") + File.separator + "src" + File.separator + "test" + File.separator + "resources" + File.separator + "cc.conf"; nc = new TestNodeController(configPath, false); nc.init(); ncAppCtx = nc.getAppRuntimeContext(); dsLifecycleMgr = ncAppCtx.getDatasetLifecycleManager(); @AfterClass public static void tearDown() throws Exception { nc.deInit(); TestHelper.deleteExistingInstanceFiles(); } @Before public void createIndex() throws Exception { PrimaryIndexInfo primaryIndexInfo = StorageTestUtils.createPrimaryIndex(nc, PARTITION); IndexDataflowHelperFactory iHelperFactory = new IndexDataflowHelperFactory(nc.getStorageManager(), primaryIndexInfo.getFileSplitProvider()); JobId jobId = nc.newJobId(); ctx = nc.createTestContext(jobId, PARTITION, false); indexDataflowHelper = iHelperFactory.create(ctx.getJobletContext().getServiceContext(), PARTITION); indexDataflowHelper.open(); lsmBtree = (TestLsmBtree) indexDataflowHelper.getIndexInstance(); }

sample: 1107
buggy_code: <|startfocus|> public void testRollbackWhileNoOp() { <|endfocus|> try { // allow all operations StorageTestUtils.allowAllOps(lsmBtree); // ensure no disk component and memory component is empty Assert.assertEquals(0, lsmBtree.getDiskComponents().size()); Assert.assertFalse(lsmBtree.isMemoryComponentsAllocated()); MutableArrayValueReference key = new MutableArrayValueReference("FlushMetadataOnlyTestKey".getBytes()); MutableArrayValueReference value = new MutableArrayValueReference("FlushMetadataOnlyTestValue".getBytes()); indexDataflowHelper.open(); ILSMIndexAccessor accessor = lsmBtree.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.updateMeta(key, value); Assert.assertTrue(lsmBtree.isMemoryComponentsAllocated()); Assert.assertTrue(lsmBtree.getCurrentMemoryComponent().isModified()); indexDataflowHelper.close(); // flush synchronously StorageTestUtils.flush(dsLifecycleMgr, lsmBtree, false); // assert one disk component Assert.assertEquals(1, lsmBtree.getDiskComponents().size()); VoidPointable pointable = VoidPointable.FACTORY.createPointable(); ComponentUtils.get(lsmBtree, key, pointable); Assert.assertTrue(DataUtils.equals(pointable, value)); // ensure that we can search this component
code_review:  Rename. 
target code: public void testFlushMetadataOnlyComponent() { try { // allow all operations StorageTestUtils.allowAllOps(lsmBtree); // ensure no disk component and memory component is empty Assert.assertEquals(0, lsmBtree.getDiskComponents().size()); Assert.assertFalse(lsmBtree.isMemoryComponentsAllocated()); MutableArrayValueReference key = new MutableArrayValueReference("FlushMetadataOnlyTestKey".getBytes()); MutableArrayValueReference value = new MutableArrayValueReference("FlushMetadataOnlyTestValue".getBytes()); indexDataflowHelper.open(); ILSMIndexAccessor accessor = lsmBtree.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.updateMeta(key, value); Assert.assertTrue(lsmBtree.isMemoryComponentsAllocated()); Assert.assertTrue(lsmBtree.getCurrentMemoryComponent().isModified()); indexDataflowHelper.close(); // flush synchronously StorageTestUtils.flush(dsLifecycleMgr, lsmBtree, false); // assert one disk component Assert.assertEquals(1, lsmBtree.getDiskComponents().size()); VoidPointable pointable = VoidPointable.FACTORY.createPointable(); ComponentUtils.get(lsmBtree, key, pointable); Assert.assertTrue(DataUtils.equals(pointable, value)); // ensure that we can search this component
response: public void testRollbackWhileNoOp() { try { // allow all operations StorageTestUtils.allowAllOps(lsmBtree); // ensure no disk component and memory component is empty Assert.assertEquals(0, lsmBtree.getDiskComponents().size()); Assert.assertFalse(lsmBtree.isMemoryComponentsAllocated()); MutableArrayValueReference key = new MutableArrayValueReference("FlushMetadataOnlyTestKey".getBytes()); MutableArrayValueReference value = new MutableArrayValueReference("FlushMetadataOnlyTestValue".getBytes()); indexDataflowHelper.open(); ILSMIndexAccessor accessor = lsmBtree.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.updateMeta(key, value); Assert.assertTrue(lsmBtree.isMemoryComponentsAllocated()); Assert.assertTrue(lsmBtree.getCurrentMemoryComponent().isModified()); indexDataflowHelper.close(); // flush synchronously StorageTestUtils.flush(dsLifecycleMgr, lsmBtree, false); // assert one disk component Assert.assertEquals(1, lsmBtree.getDiskComponents().size()); VoidPointable pointable = VoidPointable.FACTORY.createPointable(); ComponentUtils.get(lsmBtree, key, pointable); Assert.assertTrue(DataUtils.equals(pointable, value)); // ensure that we can search this component // ... } catch (Exception e) { // handle exception } }

sample: 1108
buggy_code: <|startfocus|> public static boolean equals(IValueReference first, IValueReference second) { <|endfocus|> if (first.getLength() != second.getLength()) { return false; } return equalsInRange(first.getByteArray(), first.getStartOffset(), second.getByteArray(), second.getStartOffset(), first.getLength());
code_review:  MAJOR SonarQube violation: Either override Object.equals(Object), or totally rename the method to prevent any confusion. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1201 
target code: public static boolean equals(IValueReference first, IValueReference second) { // NOSONAR if (first.getLength() != second.getLength()) { return false; } return equalsInRange(first.getByteArray(), first.getStartOffset(), second.getByteArray(), second.getStartOffset(), first.getLength());
response: public static boolean areEqual(IValueReference first, IValueReference second) { if (first.getLength() != second.getLength()) { return false; } return equalsInRange(first.getByteArray(), first.getStartOffset(), second.getByteArray(), second.getStartOffset(), first.getLength()); }

sample: 1109
buggy_code:  private static TestLsmBtree lsmBtree; private static NCAppRuntimeContext ncAppCtx; private static IDatasetLifecycleManager dsLifecycleMgr; private static IHyracksTaskContext ctx; private static IIndexDataflowHelper indexDataflowHelper; private static final int PARTITION = 0; @BeforeClass public static void setUp() throws Exception { TestHelper.deleteExistingInstanceFiles(); <|startfocus|> String configPath = System.getProperty("user.dir") + File.separator + "src" + File.separator + "test" + File.separator + "resources" + File.separator + "cc.conf"; <|endfocus|> nc = new TestNodeController(configPath, false); nc.init(); ncAppCtx = nc.getAppRuntimeContext(); dsLifecycleMgr = ncAppCtx.getDatasetLifecycleManager(); } @AfterClass public static void tearDown() throws Exception { System.out.println("TearDown"); nc.deInit(); TestHelper.deleteExistingInstanceFiles(); } @Before public void createIndex() throws Exception { PrimaryIndexInfo primaryIndexInfo = StorageTestUtils.createPrimaryIndex(nc, PARTITION); IndexDataflowHelperFactory iHelperFactory =
code_review:  use FilePath.joinPath 
target code: private static TestLsmBtree lsmBtree; private static NCAppRuntimeContext ncAppCtx; private static IDatasetLifecycleManager dsLifecycleMgr; private static IHyracksTaskContext ctx; private static IIndexDataflowHelper indexDataflowHelper; private static final int PARTITION = 0; @BeforeClass public static void setUp() throws Exception { TestHelper.deleteExistingInstanceFiles(); String configPath = Paths.get(System.getProperty("user.dir"), "src", "test", "resources", "cc.conf").toString(); nc = new TestNodeController(configPath, false); nc.init(); ncAppCtx = nc.getAppRuntimeContext(); dsLifecycleMgr = ncAppCtx.getDatasetLifecycleManager(); } @AfterClass public static void tearDown() throws Exception { System.out.println("TearDown"); nc.deInit(); TestHelper.deleteExistingInstanceFiles(); } @Before public void createIndex() throws Exception { PrimaryIndexInfo primaryIndexInfo = StorageTestUtils.createPrimaryIndex(nc, PARTITION); IndexDataflowHelperFactory iHelperFactory =
response: private static TestLsmBtree lsmBtree; private static NCAppRuntimeContext ncAppCtx; private static IDatasetLifecycleManager dsLifecycleMgr; private static IHyracksTaskContext ctx; private static IIndexDataflowHelper indexDataflowHelper; private static final int PARTITION = 0; @BeforeClass public static void setUp() throws Exception { TestHelper.deleteExistingInstanceFiles(); String configPath = FilePath.joinPath(System.getProperty("user.dir"), "src", "test", "resources", "cc.conf"); nc = new TestNodeController(configPath, false); nc.init(); ncAppCtx = nc.getAppRuntimeContext(); dsLifecycleMgr = ncAppCtx.getDatasetLifecycleManager(); } @AfterClass public static void tearDown() throws Exception { System.out.println("TearDown"); nc.deInit(); TestHelper.deleteExistingInstanceFiles(); } @Before public void createIndex() throws Exception { PrimaryIndexInfo primaryIndexInfo = StorageTestUtils.createPrimaryIndex(nc, PARTITION); IndexDataflowHelperFactory iHelperFactory = ... }

sample: 1110
buggy_code:  ncSection = ccini.add(sectionName); } if (ncConfig.getString(NCConfig.Option.CLUSTER_ADDRESS) == null) { ncSection.put(NCConfig.Option.CLUSTER_ADDRESS.ini(), ccs.getCCConfig().getClusterPublicAddress()); ncSection.put(NCConfig.Option.CLUSTER_PORT.ini(), String.valueOf(ccs.getCCConfig().getClusterPublicPort())); } // if not already configured, set GC max pause time millis to not exceed 1/2 the total max heartbeat miss period... String ncJvmArgs = ncConfig.getString(NCConfig.Option.JVM_ARGS); <|startfocus|> if (ncJvmArgs == null || !ncJvmArgs.contains("-XX:MaxGCPauseMillis")) { String gcMaxPauseArg = "-XX:MaxGCPauseMillis=" + getGcMaxPauseMillis(); <|endfocus|> ncSection.put(NCConfig.Option.JVM_ARGS.ini(), ncJvmArgs == null ? gcMaxPauseArg : ncJvmArgs + " " + gcMaxPauseArg); } // Finally insert *this* NC's name into localnc section - this is a fixed // entry point so that NCs can determine where all their config is.
code_review:  MAJOR SonarQube violation: Split this 123 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: ncSection = ccini.add(sectionName); } if (ncConfig.getString(NCConfig.Option.CLUSTER_ADDRESS) == null) { ncSection.put(NCConfig.Option.CLUSTER_ADDRESS.ini(), ccs.getCCConfig().getClusterPublicAddress()); ncSection.put(NCConfig.Option.CLUSTER_PORT.ini(), String.valueOf(ccs.getCCConfig().getClusterPublicPort())); } // if not already configured, set GC max pause time millis to not exceed 1/2 the total max heartbeat miss period... String ncJvmArgs = ncConfig.getString(NCConfig.Option.JVM_ARGS); if (ncJvmArgs == null || !ncJvmArgs.contains(JVM_ARG_MAX_GCPAUSE_MILLIS)) { String gcMaxPauseArg = JVM_ARG_MAX_GCPAUSE_MILLIS + getGcMaxPauseMillis(); ncSection.put(NCConfig.Option.JVM_ARGS.ini(), ncJvmArgs == null ? gcMaxPauseArg : ncJvmArgs + " " + gcMaxPauseArg); } // Finally insert *this* NC's name into localnc section - this is a fixed // entry point so that NCs can determine where all their config is.
response: ncSection = ccini.add(sectionName); if (ncConfig.getString(NCConfig.Option.CLUSTER_ADDRESS) == null) { ncSection.put(NCConfig.Option.CLUSTER_ADDRESS.ini(), ccs.getCCConfig().getClusterPublicAddress()); ncSection.put(NCConfig.Option.CLUSTER_PORT.ini(), String.valueOf(ccs.getCCConfig().getClusterPublicPort())); } String ncJvmArgs = ncConfig.getString(NCConfig.Option.JVM_ARGS); if (ncJvmArgs == null || !ncJvmArgs.contains("-XX:MaxGCPauseMillis")) { String gcMaxPauseArg = "-XX:MaxGCPauseMillis=" + getGcMaxPauseMillis(); ncSection.put(NCConfig.Option.JVM_ARGS.ini(), ncJvmArgs == null ? gcMaxPauseArg : ncJvmArgs + " " + gcMaxPauseArg); }

sample: 1111
buggy_code:  ncSection.put(NCConfig.Option.CLUSTER_PORT.ini(), String.valueOf(ccs.getCCConfig().getClusterPublicPort())); } // if not already configured, set GC max pause time millis to not exceed 1/2 the total max heartbeat miss period... String ncJvmArgs = ncConfig.getString(NCConfig.Option.JVM_ARGS); <|startfocus|> if (ncJvmArgs == null || !ncJvmArgs.contains("-XX:MaxGCPauseMillis")) { String gcMaxPauseArg = "-XX:MaxGCPauseMillis=" + getGcMaxPauseMillis(); <|endfocus|> ncSection.put(NCConfig.Option.JVM_ARGS.ini(), ncJvmArgs == null ? gcMaxPauseArg : ncJvmArgs + " " + gcMaxPauseArg); } // Finally insert *this* NC's name into localnc section - this is a fixed // entry point so that NCs can determine where all their config is. ccini.put(Section.LOCALNC.sectionName(), NCConfig.Option.NODE_ID.ini(), ncId); ccini.store(iniString); if (LOGGER.isDebugEnabled()) { LOGGER.debug("Returning Ini file:\n" + iniString.toString()); } return iniString.toString();
code_review:  constant 
target code: ncSection.put(NCConfig.Option.CLUSTER_PORT.ini(), String.valueOf(ccs.getCCConfig().getClusterPublicPort())); } // if not already configured, set GC max pause time millis to not exceed 1/2 the total max heartbeat miss period... String ncJvmArgs = ncConfig.getString(NCConfig.Option.JVM_ARGS); if (ncJvmArgs == null || !ncJvmArgs.contains(JVM_ARG_MAX_GCPAUSE_MILLIS)) { String gcMaxPauseArg = JVM_ARG_MAX_GCPAUSE_MILLIS + getGcMaxPauseMillis(); ncSection.put(NCConfig.Option.JVM_ARGS.ini(), ncJvmArgs == null ? gcMaxPauseArg : ncJvmArgs + " " + gcMaxPauseArg); } // Finally insert *this* NC's name into localnc section - this is a fixed // entry point so that NCs can determine where all their config is. ccini.put(Section.LOCALNC.sectionName(), NCConfig.Option.NODE_ID.ini(), ncId); ccini.store(iniString); if (LOGGER.isDebugEnabled()) { LOGGER.debug("Returning Ini file:\n" + iniString.toString()); } return iniString.toString();
response: public void run() { while (true) { try { if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Connecting NC service '" + ncId + "' at " + ncHost + ":" + ncPort); } Socket s = new Socket(ncHost, ncPort); ObjectOutputStream oos = new ObjectOutputStream(s.getOutputStream()); oos.writeUTF(NC_MAGIC_COOKIE); oos.writeUTF(serializeIni(ccs.getCCConfig().getIni())); oos.close(); break; // QQQ Should probably have an ACK here } catch (IOException e) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Failed to contact NC service at " + ncHost + ":" + ncPort + "; will retry", e); } } try { Thread.sleep(5000); } catch (InterruptedException ignored) { // Just go 'round again } } } public void run() { while (true) { try { if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Connecting NC service '" + ncId + "' at " + ncHost + ":" + ncPort); } Socket s = new Socket(ncHost, ncPort); ObjectOutputStream oos = new ObjectOutputStream(s.getOutputStream()); oos.writeUTF(NC_MAGIC_COOKIE); oos.writeUTF(serializeIni(ccs.getCCConfig().getIni())); oos.close(); break; // QQQ Should probably have an ACK here } catch (IOException e) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Failed to contact NC service at " + ncHost + ":" + ncPort + "; will retry", e); } } try { Thread.sleep(5000); } catch (InterruptedException ignored) { // Just go 'round again } } } public void run() { while (true) { try { if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Connecting NC service '" + ncId + "' at " + ncHost + ":" + ncPort); } Socket s = new Socket(ncHost, ncPort); ObjectOutputStream oos = new ObjectOutputStream(s.getOutputStream()); oos.writeUTF(NC_MAGIC_COOKIE); oos.writeUTF(serializeIni(ccs.getCCConfig().get

sample: 1112
buggy_code:  public List<String> getFunctionParameters(String dataverseName, String fullFunctionName) { <|startfocus|> return externalFunctionParameters.getOrDefault(dataverseName + "." + fullFunctionName, Collections.EMPTY_LIST); <|endfocus|>
code_review:  MAJOR SonarQube violation: Replace "Collections.EMPTY_LIST" by "Collections.emptyList()". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1596 
target code: public List<String> getFunctionParameters(String dataverseName, String fullFunctionName) { return externalFunctionParameters.getOrDefault(dataverseName + "." + fullFunctionName, Collections.emptyList());
response: public List<String> getFunctionParameters(String dataverseName, String fullFunctionName) { return externalFunctionParameters.getOrDefault(dataverseName + "." + fullFunctionName, Collections.emptyList()); }

sample: 1113
buggy_code:  String functionReturnType = function.getReturnType().trim(); String functionDefinition = function.getDefinition().trim(); String functionLanguage = library.getLanguage().trim(); String functionType = function.getFunctionType().trim(); List<String> args = new ArrayList<>(); for (String arg : fargs) { args.add(arg); } <|startfocus|> FunctionSignature signature = new FunctionSignature(dataverse, getExternalFunctionFullName(libraryName, function.getName().trim()), args.size()); <|endfocus|> Function f = new Function(signature, args, functionReturnType, functionDefinition, functionLanguage, functionType, null); MetadataManager.INSTANCE.addFunction(mdTxnCtx, f); if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed function: " + functionFullName); } } } if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed functions in library :" + libraryName); } // Add adapters if (library.getLibraryAdapters() != null) { for (LibraryAdapter adapter : library.getLibraryAdapters().getLibraryAdapter()) {
code_review:  This is exactly the definition of functionFullName in l.218. Let's use that. 
target code: String functionReturnType = function.getReturnType().trim(); String functionDefinition = function.getDefinition().trim(); String functionLanguage = library.getLanguage().trim(); String functionType = function.getFunctionType().trim(); List<String> args = new ArrayList<>(); for (String arg : fargs) { args.add(arg); } FunctionSignature signature = new FunctionSignature(dataverse, functionFullName, args.size()); Function f = new Function(signature, args, functionReturnType, functionDefinition, functionLanguage, functionType, null); MetadataManager.INSTANCE.addFunction(mdTxnCtx, f); if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed function: " + functionFullName); } } } if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed functions in library :" + libraryName); } // Add adapters if (library.getLibraryAdapters() != null) { for (LibraryAdapter adapter : library.getLibraryAdapters().getLibraryAdapter()) {
response: String functionReturnType = function.getReturnType().trim(); String functionDefinition = function.getDefinition().trim(); String functionLanguage = library.getLanguage().trim(); String functionType = function.getFunctionType().trim(); List<String> args = new ArrayList<>(); for (String arg : fargs) { args.add(arg); } FunctionSignature signature = new FunctionSignature(dataverse, getExternalFunctionFullName(libraryName, function.getName().trim()), args.size()); Function f = new Function(signature, args, functionReturnType, functionDefinition, functionLanguage, functionType, null); MetadataManager.INSTANCE.addFunction(mdTxnCtx, f); if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed function: " + functionFullName); } } if (LOGGER.isInfoEnabled()) { LOGGER.info("Installed functions in library :" + libraryName); } // Add adapters if (library.getLibraryAdapters() != null) { for (LibraryAdapter adapter : library.getLibraryAdapters().getLibraryAdapter()) {

sample: 1114
buggy_code:  configManager.set(nodeId, NCConfig.Option.NCSERVICE_PORT, NCConfig.NCSERVICE_PORT_DISABLED); final INCApplication ncApplication = createNCApplication(); ConfigManager ncConfigManager; if (confFile == null) { ncConfigManager = new ConfigManager(); } else { ncConfigManager = new ConfigManager(new String[] { "-config-file", confFile }); } ncApplication.registerConfig(ncConfigManager); <|startfocus|> opts.stream().forEach(opt -> ncConfigManager.set(nodeId, opt.getLeft(), opt.getRight())); <|endfocus|> nodeControllers.add( new NodeControllerService(fixupIODevices(createNCConfig(nodeId, ncConfigManager)), ncApplication)); } opts.stream().forEach(opt -> configManager.set(opt.getLeft(), opt.getRight())); cc.start(); // Starts ncs. nodeNames = ccConfig.getConfigManager().getNodeNames(); List<Thread> startupThreads = new ArrayList<>(); for (NodeControllerService nc : nodeControllers) { Thread ncStartThread = new Thread("IntegrationUtil-" + nc.getId()) { @Override public void run() { try { nc.start();
code_review:  you can use forEach without stream 
target code: configManager.set(nodeId, NCConfig.Option.NCSERVICE_PORT, NCConfig.NCSERVICE_PORT_DISABLED); final INCApplication ncApplication = createNCApplication(); ConfigManager ncConfigManager; if (confFile == null) { ncConfigManager = new ConfigManager(); } else { ncConfigManager = new ConfigManager(new String[] { "-config-file", confFile }); } ncApplication.registerConfig(ncConfigManager); opts.forEach(opt -> ncConfigManager.set(nodeId, opt.getLeft(), opt.getRight())); nodeControllers.add( new NodeControllerService(fixupIODevices(createNCConfig(nodeId, ncConfigManager)), ncApplication)); } opts.stream().forEach(opt -> configManager.set(opt.getLeft(), opt.getRight())); cc.start(); // Starts ncs. nodeNames = ccConfig.getConfigManager().getNodeNames(); List<Thread> startupThreads = new ArrayList<>(); for (NodeControllerService nc : nodeControllers) { Thread ncStartThread = new Thread("IntegrationUtil-" + nc.getId()) { @Override public void run() { try { nc.start();
response: configManager.set(nodeId, NCConfig.Option.NCSERVICE_PORT, NCConfig.NCSERVICE_PORT_DISABLED); final INCApplication ncApplication = createNCApplication(); ConfigManager ncConfigManager; if (confFile == null) { ncConfigManager = new ConfigManager(); } else { ncConfigManager = new ConfigManager(new String[] { "-config-file", confFile }); } ncApplication.registerConfig(ncConfigManager); opts.forEach(opt -> ncConfigManager.set(nodeId, opt.getLeft(), opt.getRight())); nodeControllers.add(new NodeControllerService(fixupIODevices(createNCConfig(nodeId, ncConfigManager)), ncApplication)); opts.forEach(opt -> configManager.set(opt.getLeft(), opt.getRight())); cc.start(); // Starts ncs. nodeNames = ccConfig.getConfigManager().getNodeNames(); List<Thread> startupThreads = new ArrayList<>(); for (NodeControllerService nc : nodeControllers) { Thread ncStartThread = new Thread("IntegrationUtil-" + nc.getId()) { @Override public void run() { try { nc.start(); } catch (Exception e) { // Handle exception } } }; startupThreads.add(ncStartThread); ncStartThread.start(); }

sample: 1115
buggy_code:  throws Exception { flushPartition(dslLifecycleMgr, lsmBtree, DATASET, async); } public static void flushPartition(IDatasetLifecycleManager dslLifecycleMgr, TestLsmBtree lsmBtree, Dataset dataset, boolean async) throws Exception { waitForOperations(lsmBtree); PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) lsmBtree.getOperationTracker(); opTracker.setFlushOnExit(true); opTracker.flushIfNeeded(); long maxWaitTime = 60000L; // 1min // wait for log record is flushed, i.e., the flush is scheduled <|startfocus|> long before = System.currentTimeMillis(); <|endfocus|> while (opTracker.isFlushLogCreated()) { Thread.sleep(5); // NOSONAR: Test code with a timeout if (System.currentTimeMillis() - before > maxWaitTime) { throw new IllegalStateException( (System.currentTimeMillis() - before) + "ms passed without scheduling the flush operation"); } } if (!async) { DatasetInfo dsInfo = dslLifecycleMgr.getDatasetInfo(dataset.getDatasetId()); dsInfo.waitForIO(); } } 
code_review:  use TimeUnit 
target code: throws Exception { flushPartition(dslLifecycleMgr, lsmBtree, DATASET, async); } public static void flushPartition(IDatasetLifecycleManager dslLifecycleMgr, TestLsmBtree lsmBtree, Dataset dataset, boolean async) throws Exception { waitForOperations(lsmBtree); PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) lsmBtree.getOperationTracker(); opTracker.setFlushOnExit(true); opTracker.flushIfNeeded(); long maxWaitTime = 60000L; // 1min // wait for log record is flushed, i.e., the flush is scheduled long before = System.nanoTime(); while (opTracker.isFlushLogCreated()) { Thread.sleep(5); // NOSONAR: Test code with a timeout if (System.currentTimeMillis() - before > maxWaitTime) { throw new IllegalStateException( (System.currentTimeMillis() - before) + "ms passed without scheduling the flush operation"); } } if (!async) { DatasetInfo dsInfo = dslLifecycleMgr.getDatasetInfo(dataset.getDatasetId()); dsInfo.waitForIO(); } }
response: private static final long MAX_WAIT_TIME = TimeUnit.MINUTES.toMillis(1); throws Exception { flushPartition(dslLifecycleMgr, lsmBtree, DATASET, async); } public static void flushPartition(IDatasetLifecycleManager dslLifecycleMgr, TestLsmBtree lsmBtree, Dataset dataset, boolean async) throws Exception { waitForOperations(lsmBtree); PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) lsmBtree.getOperationTracker(); opTracker.setFlushOnExit(true); opTracker.flushIfNeeded(); long before = System.currentTimeMillis(); while (opTracker.isFlushLogCreated()) { Thread.sleep(5); if (System.currentTimeMillis() - before > MAX_WAIT_TIME) { throw new IllegalStateException((System.currentTimeMillis() - before) + "ms passed without scheduling the flush operation"); } } if (!async) { DatasetInfo dsInfo = dslLifecycleMgr.getDatasetInfo(dataset.getDatasetId()); dsInfo.waitForIO(); } }

sample: 1116
buggy_code:  throws Exception { flushPartition(dslLifecycleMgr, lsmBtree, DATASET, async); } public static void flushPartition(IDatasetLifecycleManager dslLifecycleMgr, TestLsmBtree lsmBtree, Dataset dataset, boolean async) throws Exception { waitForOperations(lsmBtree); PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) lsmBtree.getOperationTracker(); opTracker.setFlushOnExit(true); opTracker.flushIfNeeded(); long maxWaitTime = 60000L; // 1min // wait for log record is flushed, i.e., the flush is scheduled <|startfocus|> long before = System.currentTimeMillis(); <|endfocus|> while (opTracker.isFlushLogCreated()) { Thread.sleep(5); // NOSONAR: Test code with a timeout if (System.currentTimeMillis() - before > maxWaitTime) { throw new IllegalStateException( (System.currentTimeMillis() - before) + "ms passed without scheduling the flush operation"); } } if (!async) { DatasetInfo dsInfo = dslLifecycleMgr.getDatasetInfo(dataset.getDatasetId()); dsInfo.waitForIO(); } } 
code_review:  it isn't safe to use System.currentTimeMillis(), use System.nanoTime 
target code: throws Exception { flushPartition(dslLifecycleMgr, lsmBtree, DATASET, async); } public static void flushPartition(IDatasetLifecycleManager dslLifecycleMgr, TestLsmBtree lsmBtree, Dataset dataset, boolean async) throws Exception { waitForOperations(lsmBtree); PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) lsmBtree.getOperationTracker(); opTracker.setFlushOnExit(true); opTracker.flushIfNeeded(); long maxWaitTime = 60000L; // 1min // wait for log record is flushed, i.e., the flush is scheduled long before = System.nanoTime(); while (opTracker.isFlushLogCreated()) { Thread.sleep(5); // NOSONAR: Test code with a timeout if (System.currentTimeMillis() - before > maxWaitTime) { throw new IllegalStateException( (System.currentTimeMillis() - before) + "ms passed without scheduling the flush operation"); } } if (!async) { DatasetInfo dsInfo = dslLifecycleMgr.getDatasetInfo(dataset.getDatasetId()); dsInfo.waitForIO(); } }
response: public void flushPartition(IDatasetLifecycleManager dslLifecycleMgr, TestLsmBtree lsmBtree, Dataset dataset, boolean async) throws Exception { waitForOperations(lsmBtree); PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) lsmBtree.getOperationTracker(); opTracker.setFlushOnExit(true); opTracker.flushIfNeeded(); long maxWaitTime = 60000L; // 1min long before = System.nanoTime(); while (opTracker.isFlushLogCreated()) { Thread.sleep(5); if (System.nanoTime() - before > maxWaitTime * 1000000) { throw new IllegalStateException((System.nanoTime() - before) + "ns passed without scheduling the flush operation"); } } if (!async) { DatasetInfo dsInfo = dslLifecycleMgr.getDatasetInfo(dataset.getDatasetId()); dsInfo.waitForIO(); } }

sample: 1117
buggy_code:  * harness callback simply. */ public class StubIOOperationCallback implements ILSMIOOperationCallback { private ILSMIndexOperationContext opCtx = null; @Override public void beforeOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Not interested in this } @Override public void afterOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { this.opCtx = opCtx; } @Override <|startfocus|> public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { <|endfocus|> } public List<ILSMDiskComponent> getLastOldComponents() { return opCtx.getComponentsToBeMerged(); } public ILSMDiskComponent getLastNewComponent() { return opCtx.getNewComponent(); } @Override public void recycled(ILSMMemoryComponent component, boolean componentSwitched) { // Not interested in this } @Override public void allocated(ILSMMemoryComponent component) { // Not interested in this } } 
code_review:  MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 
target code: * harness callback simply. */ public class StubIOOperationCallback implements ILSMIOOperationCallback { private ILSMIndexOperationContext opCtx = null; @Override public void beforeOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Not interested in this } @Override public void afterOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { this.opCtx = opCtx; } @Override public synchronized void afterFinalize(LSMOperationType opType, ILSMDiskComponent newComponent) throws HyracksDataException { } public List<ILSMDiskComponent> getLastOldComponents() { return opCtx.getComponentsToBeMerged(); } public ILSMDiskComponent getLastNewComponent() { return opCtx.getNewComponent(); } @Override public void recycled(ILSMMemoryComponent component, boolean componentSwitched) { // Not interested in this } @Override public void allocated(ILSMMemoryComponent component) { // Not interested in this } }
response: import org.apache.hyracks.api.dataflow.value.ISerializerDeserializer; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.DataInput; import java.io.DataOutput; public class AMissingSerializerDeserializer implements ISerializerDeserializer<AMissing> { private static final long serialVersionUID = 1L; public static final AMissingSerializerDeserializer INSTANCE = new AMissingSerializerDeserializer(); private AMissingSerializerDeserializer() { } @Override public AMissing deserialize(DataInput in) throws HyracksDataException { return AMissing.MISSING; } @Override public void serialize(AMissing instance, DataOutput out) throws HyracksDataException { // A missing value only has a typetag in its serialized form. } } import org.apache.hyracks.api.dataflow.value.ISerializerDeserializer; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.DataInput; import java.io.DataOutput; public class ANullSerializerDeserializer implements ISerializerDeserializer<IAObject> { private static final long serialVersionUID = 1L; public static final ANullSerializerDeserializer INSTANCE = new ANullSerializerDeserializer(); private ANullSerializerDeserializer() { } @Override public ANull deserialize(DataInput in) throws HyracksDataException { return ANull.NULL; } @Override public void serialize(IAObject instance, DataOutput out) throws HyracksDataException { // A null value only has a typetag in its serialized form. } } import org.apache.hyracks.algebricks.data.IPrinter; import org.apache.hyracks.algebricks.data.IPrinterFactory; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.PrintStream; public class AObjectPrinterFactory implements IPrinterFactory { private static final long serialVersionUID = 1L; public static final AObjectPrinterFactory INSTANCE = new AObjectPrinterFactory(); @Override public IPrinter createPrinter() { return PRINTER; } } /** * This method is intentionally left empty as it is not needed for the operation. */ public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { } public class StubIOOperationCallback implements ILSMIOOperationCallback { private ILSMIndexOperationContext opCtx = null;

sample: 1118
buggy_code:  * harness callback simply. */ public class StubIOOperationCallback implements ILSMIOOperationCallback { private ILSMIndexOperationContext opCtx = null; @Override public void beforeOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Not interested in this } @Override public void afterOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { this.opCtx = opCtx; } @Override <|startfocus|> public synchronized void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Redundant info from after <|endfocus|> } public List<ILSMDiskComponent> getLastOldComponents() { return opCtx.getComponentsToBeMerged(); } public ILSMDiskComponent getLastNewComponent() { return opCtx.getNewComponent(); } @Override public void recycled(ILSMMemoryComponent component, boolean componentSwitched) { // Not interested in this } @Override public void allocated(ILSMMemoryComponent component) { // Not interested in this } } 
code_review:  why is this synchronized? 
target code: * harness callback simply. */ public class StubIOOperationCallback implements ILSMIOOperationCallback { private ILSMIndexOperationContext opCtx = null; @Override public void beforeOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Not interested in this } @Override public void afterOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { this.opCtx = opCtx; } @Override public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { } public List<ILSMDiskComponent> getLastOldComponents() { return opCtx.getComponentsToBeMerged(); } public ILSMDiskComponent getLastNewComponent() { return opCtx.getNewComponent(); } @Override public void recycled(ILSMMemoryComponent component, boolean componentSwitched) { // Not interested in this } @Override public void allocated(ILSMMemoryComponent component) { // Not interested in this } }
response: public class StubIOOperationCallback implements ILSMIOOperationCallback { private ILSMIndexOperationContext opCtx = null; @Override public void beforeOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Not interested in this } @Override public void afterOperation(ILSMIndexOperationContext opCtx) throws HyracksDataException { this.opCtx = opCtx; } @Override public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Redundant info from after } public List<ILSMDiskComponent> getLastOldComponents() { return opCtx.getComponentsToBeMerged(); } public ILSMDiskComponent getLastNewComponent() { return opCtx.getNewComponent(); } @Override public void recycled(ILSMMemoryComponent component, boolean componentSwitched) { // Not interested in this } @Override public void allocated(ILSMMemoryComponent component) { // Not interested in this } }

sample: 1119
buggy_code:  protected LSMRTreeOpContext createOpContext(IIndexAccessParameters iap) { return new LSMRTreeOpContext(this, memoryComponents, rtreeLeafFrameFactory, rtreeInteriorFrameFactory, <|startfocus|> btreeLeafFrameFactory, ((IExtendedModificationOperationCallback) iap.getModificationCallback()), <|endfocus|> iap.getSearchOperationCallback(), getTreeFields(), getFilterFields(), getHarness(), comparatorFields, linearizerArray, getFilterCmpFactories(), tracer);
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: protected LSMRTreeOpContext createOpContext(IIndexAccessParameters iap) { return new LSMRTreeOpContext(this, memoryComponents, rtreeLeafFrameFactory, rtreeInteriorFrameFactory, btreeLeafFrameFactory, (IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback(), getTreeFields(), getFilterFields(), getHarness(), comparatorFields, linearizerArray, getFilterCmpFactories(), tracer);
response: protected LSMRTreeOpContext createOpContext(IIndexAccessParameters iap) { return new LSMRTreeOpContext(this, memoryComponents, rtreeLeafFrameFactory, rtreeInteriorFrameFactory, btreeLeafFrameFactory, (IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback(), getTreeFields(), getFilterFields(), getHarness(), comparatorFields, linearizerArray, getFilterCmpFactories(), tracer); }

sample: 1120
buggy_code:  * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.api; import java.io.DataOutput; import org.apache.asterix.om.base.IAObject; <|startfocus|> import org.apache.asterix.om.types.ATypeTag; <|endfocus|> import org.apache.asterix.om.types.IAType; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IJObject { IAType getIAType(); IAObject getIAObject(); void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException; void reset() throws HyracksDataException; } 
code_review:  Do we still need this? 
target code: * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.api; import java.io.DataOutput; import org.apache.asterix.om.base.IAObject; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IJObject { IAType getIAType(); IAObject getIAObject(); void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException; void reset() throws HyracksDataException; }
response: package org.apache.asterix.external.api; import java.io.DataOutput; import org.apache.asterix.om.base.IAObject; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.api.exceptions.HyracksDataException; public interface IJObject { IAType getIAType(); IAObject getIAObject(); void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException; void reset() throws HyracksDataException; }

sample: 1121
buggy_code:  super(); this.listType = new AOrderedListType(listItemType, null); } @Override public IAType getIAType() { return listType; } @Override public IAObject getIAObject() { AMutableOrderedList v = new AMutableOrderedList(listType); for (IJObject jObj : jObjects) { v.add(jObj.getIAObject()); } return v; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { <|startfocus|> IAsterixListBuilder listBuilder = new UnorderedListBuilder(); <|endfocus|> listBuilder.reset(listType); ArrayBackedValueStorage fieldValue = new ArrayBackedValueStorage(); for (IJObject jObject : jObjects) { fieldValue.reset(); jObject.serialize(fieldValue.getDataOutput(), true); listBuilder.addItem(fieldValue); } listBuilder.write(dataOutput, writeTypeTag); } @Override public void reset() { jObjects.clear(); } } 
code_review:  Should this be an ordered list? 
target code: super(); this.listType = new AOrderedListType(listItemType, null); } @Override public IAType getIAType() { return listType; } @Override public IAObject getIAObject() { AMutableOrderedList v = new AMutableOrderedList(listType); for (IJObject jObj : jObjects) { v.add(jObj.getIAObject()); } return v; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { IAsterixListBuilder listBuilder = new OrderedListBuilder(); listBuilder.reset(listType); ArrayBackedValueStorage fieldValue = new ArrayBackedValueStorage(); for (IJObject jObject : jObjects) { fieldValue.reset(); jObject.serialize(fieldValue.getDataOutput(), true); listBuilder.addItem(fieldValue); } listBuilder.write(dataOutput, writeTypeTag); } @Override public void reset() { jObjects.clear(); } }
response: super(); this.listType = new AOrderedListType(listItemType, null); } @Override public IAType getIAType() { return listType; } @Override public IAObject getIAObject() { AMutableOrderedList v = new AMutableOrderedList(listType); for (IJObject jObj : jObjects) { v.add(jObj.getIAObject()); } return v; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { IAsterixListBuilder listBuilder = new UnorderedListBuilder(); listBuilder.reset(listType); ArrayBackedValueStorage fieldValue = new ArrayBackedValueStorage(); for (IJObject jObject : jObjects) { fieldValue.reset(); jObject.serialize(fieldValue.getDataOutput(), true); listBuilder.addItem(fieldValue); } listBuilder.write(dataOutput, writeTypeTag); } @Override public void reset() { jObjects.clear(); }

sample: 1122
buggy_code:  * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base; import org.apache.asterix.dataflow.data.nontagged.serde.ABooleanSerializerDeserializer; import org.apache.asterix.om.base.ABoolean; import org.apache.asterix.om.base.IAObject; import org.apache.asterix.om.types.ATypeTag; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.DataOutput; public final class JBoolean extends JObject { <|startfocus|> private boolean value; <|endfocus|> public JBoolean(boolean value) { this.value = value; } public void setValue(boolean value) { this.value = value; } public boolean getValue() { return value; } @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } @Override public IAObject getIAObject() { return value ? ABoolean.TRUE : ABoolean.FALSE; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { serializeTypeTag(writeTypeTag, dataOutput, ATypeTag.BOOLEAN);
code_review:  MAJOR SonarQube violation: "value" is the name of a field in "JObject". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2387 
target code: * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library.java.base; import org.apache.asterix.dataflow.data.nontagged.serde.ABooleanSerializerDeserializer; import org.apache.asterix.om.base.ABoolean; import org.apache.asterix.om.base.IAObject; import org.apache.asterix.om.types.ATypeTag; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.DataOutput; public final class JBoolean extends JObject { private boolean aBoolean; public JBoolean(boolean value) { this.value = value; } public void setValue(boolean value) { this.value = value; } public boolean getValue() { return value; } @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } @Override public IAObject getIAObject() { return value ? ABoolean.TRUE : ABoolean.FALSE; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { serializeTypeTag(writeTypeTag, dataOutput, ATypeTag.BOOLEAN);
response: package org.apache.asterix.external.library.java.base; import org.apache.asterix.dataflow.data.nontagged.serde.ABooleanSerializerDeserializer; import org.apache.asterix.om.base.ABoolean; import org.apache.asterix.om.base.IAObject; import org.apache.asterix.om.types.ATypeTag; import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.DataOutput; public final class JBoolean extends JObject { private boolean value; public JBoolean(boolean value) { this.value = value; } public void setValue(boolean value) { this.value = value; } public boolean getValue() { return value; } @Override public IAType getIAType() { return BuiltinType.ABOOLEAN; } @Override public IAObject getIAObject() { return value ? ABoolean.TRUE : ABoolean.FALSE; } @Override public void serialize(DataOutput dataOutput, boolean writeTypeTag) throws HyracksDataException { serializeTypeTag(writeTypeTag, dataOutput, ATypeTag.BOOLEAN); ABooleanSerializerDeserializer.INSTANCE.serialize(value, dataOutput); } }

sample: 1123
buggy_code:  public ARectangle getValue() { <|startfocus|> return ((AMutableRectangle) value); <|endfocus|>
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public ARectangle getValue() { return (AMutableRectangle) value;
response: public ARectangle getValue() { return (AMutableRectangle) value; }

sample: 1124
buggy_code: <|startfocus|> public ITupleReference getSearchKey() { return MetadataNode.createTuple(signature.getNamespace(), signature.getName(), "" + signature.getArity()); <|endfocus|>
code_review:  MAJOR SonarQube violation: Use "Integer.toString" instead. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2131 
target code: public String getInitParameters() { return initParameters;
response: public ITupleReference getSearchKey() { return MetadataNode.createTuple(signature.getNamespace(), signature.getName(), Integer.toString(signature.getArity())); }

sample: 1125
buggy_code:  adapterRuntimeManager = new AdapterRuntimeManager(ctx, feedId, adapter, writer, partition); ActiveRuntimeId runtimeId = new ActiveRuntimeId(feedId, FeedRuntimeType.INTAKE.toString(), partition); ingestionRuntime = new IngestionRuntime(feedId, runtimeId, adapterRuntimeManager, ctx); feedManager.registerRuntime(ingestionRuntime); <|startfocus|> writer.open(); <|endfocus|> TaskUtils.putInSharedMap(HyracksConstants.KEY_MESSAGE, new VSizeFrame(ctx), ctx); adapterRuntimeManager.start(); synchronized (adapterRuntimeManager) { while (!adapterRuntimeManager.isDone()) { adapterRuntimeManager.wait(); } } if (adapterRuntimeManager.isFailed()) { throw new HyracksDataException("Unable to ingest data"); } } catch (Throwable ie) { /* * An Interrupted Exception is thrown if the Intake job cannot progress further due to failure of another node involved in the Hyracks job. * As the Intake job involves only the intake operator, the exception is indicative of a failure at the sibling intake operator location. * The surviving intake partitions must continue to live and receive data from the external source. */
code_review:  BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 
target code: adapterRuntimeManager = new AdapterRuntimeManager(ctx, feedId, adapter, writer, partition); ActiveRuntimeId runtimeId = new ActiveRuntimeId(feedId, FeedRuntimeType.INTAKE.toString(), partition); ingestionRuntime = new IngestionRuntime(feedId, runtimeId, adapterRuntimeManager, ctx); feedManager.registerRuntime(ingestionRuntime); writer.open(); open = true; TaskUtils.putInSharedMap(HyracksConstants.KEY_MESSAGE, new VSizeFrame(ctx), ctx); adapterRuntimeManager.start(); synchronized (adapterRuntimeManager) { while (!adapterRuntimeManager.isDone()) { adapterRuntimeManager.wait(); } } if (adapterRuntimeManager.isFailed()) { throw new HyracksDataException("Unable to ingest data"); } } catch (Throwable ie) { /* * An Interrupted Exception is thrown if the Intake job cannot progress further due to failure of another node involved in the Hyracks job. * As the Intake job involves only the intake operator, the exception is indicative of a failure at the sibling intake operator location. * The surviving intake partitions must continue to live and receive data from the external source. */
response: adapterRuntimeManager = new AdapterRuntimeManager(ctx, feedId, adapter, writer, partition); ActiveRuntimeId runtimeId = new ActiveRuntimeId(feedId, FeedRuntimeType.INTAKE.toString(), partition); ingestionRuntime = new IngestionRuntime(feedId, runtimeId, adapterRuntimeManager, ctx); feedManager.registerRuntime(ingestionRuntime); writer.open(); TaskUtils.putInSharedMap(HyracksConstants.KEY_MESSAGE, new VSizeFrame(ctx), ctx); adapterRuntimeManager.start(); synchronized (adapterRuntimeManager) { while (!adapterRuntimeManager.isDone()) { adapterRuntimeManager.wait(); } } if (adapterRuntimeManager.isFailed()) { throw new HyracksDataException("Unable to ingest data"); } catch (Exception e) { /* * An Interrupted Exception is thrown if the Intake job cannot progress further due to failure of another node involved in the Hyracks job. * As the Intake job involves only the intake operator, the exception is indicative of a failure at the sibling intake operator location. * The surviving intake partitions must continue to live and receive data from the external source. */ }

sample: 1126
buggy_code:  public static void exit(int status) { if (exitThread.isAlive()) { LOGGER.warn("ignoring duplicate request to exit with status " + status + "; already exiting with status " + exitThread.status + "..."); } <|startfocus|> exitThread.setStatus(status); exitThread.start(); <|endfocus|>
code_review:  return 
target code: public static void exit(int status) { if (exitThread.isAlive()) { LOGGER.warn("ignoring duplicate request to exit with status " + status + "; already exiting with status " + exitThread.status + "..."); }
response: public static void exit(int status) { if (exitThread.isAlive()) { LOGGER.warn("ignoring duplicate request to exit with status " + status + "; already exiting with status " + exitThread.status + "..."); } exitThread.setStatus(status); exitThread.start(); }

sample: 1127
buggy_code: import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Shutdown hook that invokes {@link NodeControllerService#stop() stop} method. * This shutdown hook must have a failsafe mechanism to halt the process in case the shutdown * operation is hanging for any reason */ public class NCShutdownHook extends Thread { <|startfocus|> public static final int FAILED_TO_STARTUP_EXIT_CODE = 2; public static final int FAILED_TO_RECOVER_EXIT_CODE = 3; <|endfocus|> private static final Logger LOGGER = LogManager.getLogger(); private final NodeControllerService nodeControllerService; NCShutdownHook(NodeControllerService nodeControllerService) { super("ShutdownHook-" + nodeControllerService.getId()); this.nodeControllerService = nodeControllerService; } @Override public void run() { try { try { LOGGER.info("Shutdown hook called"); } catch (Throwable th) {//NOSONAR } LOGGER.log(Level.INFO, () -> "Thread dump at shutdown: " + ThreadDumpUtil.takeDumpString()); nodeControllerService.stop();
code_review:  move these codes as well 
target code: import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * Shutdown hook that invokes {@link NodeControllerService#stop() stop} method. * This shutdown hook must have a failsafe mechanism to halt the process in case the shutdown * operation is hanging for any reason */ public class NCShutdownHook extends Thread { private static final Logger LOGGER = LogManager.getLogger(); private final NodeControllerService nodeControllerService; NCShutdownHook(NodeControllerService nodeControllerService) { super("ShutdownHook-" + nodeControllerService.getId()); this.nodeControllerService = nodeControllerService; } @Override public void run() { try { try { LOGGER.info("Shutdown hook called"); } catch (Throwable th) {//NOSONAR } LOGGER.log(Level.INFO, () -> "Thread dump at shutdown: " + ThreadDumpUtil.takeDumpString()); nodeControllerService.stop();
response: import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class NCShutdownHook extends Thread { public static final int FAILED_TO_STARTUP_EXIT_CODE = 2; public static final int FAILED_TO_RECOVER_EXIT_CODE = 3; private static final Logger LOGGER = LogManager.getLogger(); private final NodeControllerService nodeControllerService; NCShutdownHook(NodeControllerService nodeControllerService) { super("ShutdownHook-" + nodeControllerService.getId()); this.nodeControllerService = nodeControllerService; } @Override public void run() { try { try { LOGGER.info("Shutdown hook called"); } catch (Throwable th) { //NOSONAR } LOGGER.log(Level.INFO, () -> "Thread dump at shutdown: " + ThreadDumpUtil.takeDumpString()); nodeControllerService.stop(); } catch (Throwable th) { LOGGER.error("Error occurred during shutdown", th); } } }

sample: 1128
buggy_code:  protected void cleanup() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { int pendingOps = partitionPendingOps.get(e.getKey()).intValue(); for (int i = 0; i < pendingOps; i++) { try { e.getValue().first.completeOperation(null, LSMOperationType.MODIFICATION, null, e.getValue().second); } catch (HyracksDataException ex) { throw new ACIDException(ex); } <|startfocus|> } <|endfocus|> }
code_review:  why do we do this exact thing n (pendingOps) times? 
target code: protected void cleanup() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { int pendingOps = partitionPendingOps.get(e.getKey()).intValue(); for (int i = 0; i < pendingOps; i++) { try { e.getValue().first.completeOperation(null, LSMOperationType.MODIFICATION, null, e.getValue().second); } catch (HyracksDataException ex) { throw new ACIDException(ex); } }); }
response: protected void cleanup() { for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) { int pendingOps = partitionPendingOps.get(e.getKey()).intValue(); for (int i = 0; i < pendingOps; i++) { try { e.getValue().first.completeOperation(null, LSMOperationType.MODIFICATION, null, e.getValue().second); } catch (HyracksDataException ex) { throw new ACIDException(ex); } } } }

sample: 1129
buggy_code:  if (interrupted) { Thread.currentThread().interrupt(); } } } /** * Runs the supplied {@code action} until {@code stopCondition} is met or timeout. */ public static void runWithTimeout(ThrowingAction action, BooleanSupplier stopCondition, long timeout, TimeUnit unit) throws Exception { long remainingTime = unit.toNanos(timeout); final long startTime = System.nanoTime(); while (!stopCondition.getAsBoolean()) { if (remainingTime <= 0) { <|startfocus|> throw new TimeoutException(); <|endfocus|> } action.run(); remainingTime -= System.nanoTime() - startTime; } } } 
code_review:  should we include info on the timeout (like how long it was configured for) in the exception message, in case this will reach a log? 
target code: if (interrupted) { Thread.currentThread().interrupt(); } } } /** * Runs the supplied {@code action} until {@code stopCondition} is met or timeout. */ public static void runWithTimeout(ThrowingAction action, BooleanSupplier stopCondition, long timeout, TimeUnit unit) throws Exception { long remainingTime = unit.toNanos(timeout); final long startTime = System.nanoTime(); while (!stopCondition.getAsBoolean()) { if (remainingTime <= 0) { throw new TimeoutException("Stop condition was not met after " + unit.toSeconds(timeout) + " seconds."); } action.run(); remainingTime -= System.nanoTime() - startTime; } } }
response: try { if (interrupted) { Thread.currentThread().interrupt(); } } finally { // Log timeout information if it reaches a log String timeoutMessage = "Timeout occurred after " + timeout + " " + unit.toString(); throw new TimeoutException(timeoutMessage); } public static void runWithTimeout(ThrowingAction action, BooleanSupplier stopCondition, long timeout, TimeUnit unit) throws Exception { long remainingTime = unit.toNanos(timeout); final long startTime = System.nanoTime(); while (!stopCondition.getAsBoolean()) { if (remainingTime <= 0) { throw new TimeoutException(); } action.run(); remainingTime -= System.nanoTime() - startTime; } }

sample: 1130
buggy_code:  throws HyracksDataException { // start+1 and len-1 due to type tag ignore (only interested in String value) return comparator.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(), b.getStartOffset() + 1, b.getLength() - 1); } public static boolean isEqual(IValueReference a, IValueReference b, IBinaryComparator comparator) throws HyracksDataException { <|startfocus|> return (compareStringBinValues(a, b, comparator) == 0); <|endfocus|> } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2) { return byteArrayEqual(valueRef1, valueRef2, 3); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2, int dataOffset) { if (valueRef1 == null || valueRef2 == null) { return false; } if (valueRef1 == valueRef2) { return true; } int length1 = valueRef1.getLength(); int length2 = valueRef2.getLength(); if (length1 != length2) { return false; }
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: throws HyracksDataException { // start+1 and len-1 due to type tag ignore (only interested in String value) return comparator.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(), b.getStartOffset() + 1, b.getLength() - 1); } public static boolean isEqual(IValueReference a, IValueReference b, IBinaryComparator comparator) throws HyracksDataException { return compareStringBinValues(a, b, comparator) == 0; } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2) { return byteArrayEqual(valueRef1, valueRef2, 3); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2, int dataOffset) { if (valueRef1 == null || valueRef2 == null) { return false; } if (valueRef1 == valueRef2) { return true; } int length1 = valueRef1.getLength(); int length2 = valueRef2.getLength(); if (length1 != length2) { return false; }
response: public static IValueParserFactory[] getValueParserFactories(ARecordType recordType) { int n = recordType.getFieldTypes().length; IValueParserFactory[] fieldParserFactories = new IValueParserFactory[n]; for (int i = 0; i < n; i++) { ATypeTag tag = null; if (recordType.getFieldTypes()[i].getTypeTag() == ATypeTag.UNION) { AUnionType unionType = (AUnionType) recordType.getFieldTypes()[i]; if (!unionType.isNullableType()) { throw new NotImplementedException("Non-optional UNION type is not supported."); } tag = unionType.getActualType().getTypeTag(); } else { tag = recordType.getFieldTypes()[i].getTypeTag(); } if (tag == null) { throw new NotImplementedException("Failed to get the type information for field " + i + "."); } fieldParserFactories[i] = getParserFactory(tag); } return fieldParserFactories; } if (!typeTag.equals(ATypeTag.BOOLEAN)) { throw new AlgebricksException(AsterixBuiltinFunctions.EDIT_DISTANCE_STRING_IS_FILTERABLE.getName() + ": expects input type BOOLEAN as fourth argument, but got " + typeTag + "."); } boolean usePrePost = BooleanPointable.getBoolean(usePrePostPtr.getByteArray(), usePrePostPtr.getStartOffset() + 1); long numGrams = usePrePost ? strLen + gramLen - 1 : strLen - gramLen + 1; long lowerBound = numGrams - edThresh * gramLen; try { if (lowerBound <= 0 || strLen == 0) { booleanSerde.serialize(ABoolean.FALSE, output); } else { booleanSerde.serialize(ABoolean.TRUE, output); } } catch (IOException e) { throw new AlgebricksException(e); } result.set(resultStorage); private int indexOf(byte[] source, int sourceOffset, int sourceCount, byte[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex >= sourceCount) { return targetCount == 0 ? sourceCount : -1; } int from = fromIndex; if (from < 0) { from = 0; } if (targetCount ==

sample: 1131
buggy_code:  utf8Writer = new UTF8StringWriter(); } public static IBinaryComparator createStringBinaryComparator() { return PointableBinaryComparatorFactory.of(UTF8StringPointable.FACTORY).createBinaryComparator(); } public static int compareStringBinValues(IValueReference a, IValueReference b, IBinaryComparator comparitor) throws HyracksDataException { // start+1 and len-1 due to type tag ignore (only interested in String value) <|startfocus|> return comparitor.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(), <|endfocus|> b.getStartOffset() + 1, b.getLength() - 1); } public static boolean isEqual(IValueReference a, IValueReference b, IBinaryComparator comparitor) throws HyracksDataException { return (compareStringBinValues(a, b, comparitor) == 0); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2) { return byteArrayEqual(valueRef1, valueRef2, 3); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2, int dataOffset) { if (valueRef1 == null || valueRef2 == null) {
code_review:  -> comparator 
target code: utf8Writer = new UTF8StringWriter(); } public static IBinaryComparator createStringBinaryComparator() { return PointableBinaryComparatorFactory.of(UTF8StringPointable.FACTORY).createBinaryComparator(); } public static int compareStringBinValues(IValueReference a, IValueReference b, IBinaryComparator comparitor) throws HyracksDataException { // start+1 and len-1 due to type tag ignore (only interested in String value) return comparator.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(), b.getStartOffset() + 1, b.getLength() - 1); } public static boolean isEqual(IValueReference a, IValueReference b, IBinaryComparator comparitor) throws HyracksDataException { return (compareStringBinValues(a, b, comparitor) == 0); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2) { return byteArrayEqual(valueRef1, valueRef2, 3); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2, int dataOffset) { if (valueRef1 == null || valueRef2 == null) {
response: utf8Writer = new UTF8StringWriter(); } public static IBinaryComparator createStringBinaryComparator() { return PointableBinaryComparatorFactory.of(UTF8StringPointable.FACTORY).createBinaryComparator(); } public static int compareStringBinValues(IValueReference a, IValueReference b, IBinaryComparator comparator) throws HyracksDataException { return comparator.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(), b.getStartOffset() + 1, b.getLength() - 1); } public static boolean isEqual(IValueReference a, IValueReference b, IBinaryComparator comparator) throws HyracksDataException { return (compareStringBinValues(a, b, comparator) == 0); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2) { return byteArrayEqual(valueRef1, valueRef2, 3); } public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2, int dataOffset) { if (valueRef1 == null || valueRef2 == null) { return false; } byte[] bytes1 = valueRef1.getByteArray(); byte[] bytes2 = valueRef2.getByteArray(); int startOffset1 = valueRef1.getStartOffset() + dataOffset; int startOffset2 = valueRef2.getStartOffset() + dataOffset; int length1 = valueRef1.getLength() - dataOffset; int length2 = valueRef2.getLength() - dataOffset; if (length1 != length2) { return false; } for (int i = 0; i < length1; i++) { if (bytes1[startOffset1 + i] != bytes2[startOffset2 + i]) { return false; } } return true; }

sample: 1132
buggy_code:  } IndexCursorUtils.open(btreeAccessors, btreeCursors, btreeRangePredicate); try { for (int i = 0; i < numberOfTrees; i++) { if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); } else { depletedBtreeCursors[i] = true; } } } catch (Throwable th) { // NOSONAR Must catch all failures to close before throwing for (int i = 0; i < numberOfTrees; i++) { <|startfocus|> th = IndexCursorUtils.close(btreeCursors[i], th); <|endfocus|> } throw HyracksDataException.create(th); } } } 
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "th". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: } IndexCursorUtils.open(btreeAccessors, btreeCursors, btreeRangePredicate); try { for (int i = 0; i < numberOfTrees; i++) { if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); } else { depletedBtreeCursors[i] = true; } } } catch (Throwable th) { // NOSONAR Must catch all failures to close before throwing for (int i = 0; i < numberOfTrees; i++) { IndexCursorUtils.close(btreeCursors[i], th); } throw HyracksDataException.create(th); } } }
response: } IndexCursorUtils.open(btreeAccessors, btreeCursors, btreeRangePredicate); try { for (int i = 0; i < numberOfTrees; i++) { if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); } else { depletedBtreeCursors[i] = true; } } } catch (Throwable th) { for (int i = 0; i < numberOfTrees; i++) { th = IndexCursorUtils.close(btreeCursors[i], th); } throw HyracksDataException.create(th); } }

sample: 1133
buggy_code:  public static Throwable close(IIndexCursor cursor, Throwable root) { if (cursor != null) { try { cursor.close(); } catch (Throwable th) { // NOSONAR Will be suppressed try { LOGGER.log(Level.WARN, "Failure closing a cursor", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } <|startfocus|> root = ExceptionUtils.suppress(root, th); <|endfocus|> } } return root;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "root". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable close(IIndexCursor cursor, Throwable root) { if (cursor != null) { try { cursor.close(); } catch (Throwable th) { // NOSONAR Will be suppressed try { LOGGER.log(Level.WARN, "Failure closing a cursor", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } root = ExceptionUtils.suppress(root, th); // NOSONAR: Using the same variable is not bad in this context } } return root;
response: public static Throwable close(IIndexCursor cursor, Throwable root) { if (cursor != null) { try { cursor.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1134
buggy_code:  throws HyracksDataException { int opened = 0; try { for (int i = 0; i < cursors.length; i++) { if (accessors.get(i) != null) { accessors.get(i).search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { <|startfocus|> th = IndexCursorUtils.close(cursors[j], th); <|endfocus|> } throw HyracksDataException.create(th); } } public static void open(IIndexAccessor[] accessors, IIndexCursor[] cursors, ISearchPredicate pred) throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th);
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "th". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < cursors.length; i++) { if (accessors.get(i) != null) { accessors.get(i).search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static void open(IIndexAccessor[] accessors, IIndexCursor[] cursors, ISearchPredicate pred) throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th);
response: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < cursors.length; i++) { if (accessors.get(i) != null) { accessors.get(i).search(cursors[i], pred); } opened++; } } catch (Throwable th) { for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static void open(IIndexAccessor[] accessors, IIndexCursor[] cursors, ISearchPredicate pred) throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } }

sample: 1135
buggy_code:  throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { <|startfocus|> th = IndexCursorUtils.close(cursors[j], th); <|endfocus|> } throw HyracksDataException.create(th); } } public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; } } 
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "th". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; } }
response: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; }

sample: 1136
buggy_code:  public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { <|startfocus|> th = IndexCursorUtils.close(cursors[j], th); <|endfocus|> } return th;
code_review:  MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "th". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 
target code: public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); // NOSONAR: Using the same variable is cleaner in this context } return th;
response: public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; }

sample: 1137
buggy_code:  ILSMOperationTracker getOperationTracker(); ILSMIOOperationScheduler getIOScheduler(); ILSMIOOperationCallback getIOOperationCallback(); /** * components with lower indexes are newer than components with higher index */ List<ILSMDiskComponent> getDiskComponents(); boolean isPrimaryIndex(); void modify(IIndexOperationContext ictx, ITupleReference tuple) throws HyracksDataException; /** * If this method returns successfully, then the cursor has been opened, and need to be closed * Otherwise, it has not been opened <|startfocus|> * <|endfocus|> * @param ictx * @param cursor * @param pred * @throws HyracksDataException */ void search(ILSMIndexOperationContext ictx, IIndexCursor cursor, ISearchPredicate pred) throws HyracksDataException; public void scanDiskComponents(ILSMIndexOperationContext ctx, IIndexCursor cursor) throws HyracksDataException; void scheduleFlush(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; ILSMDiskComponent flush(ILSMIOOperation operation) throws HyracksDataException; void scheduleMerge(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; ILSMDiskComponent merge(ILSMIOOperation operation) throws HyracksDataException; 
code_review:  MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws 
target code: ILSMOperationTracker getOperationTracker(); ILSMIOOperationScheduler getIOScheduler(); ILSMIOOperationCallback getIOOperationCallback(); /** * components with lower indexes are newer than components with higher index */ List<ILSMDiskComponent> getDiskComponents(); boolean isPrimaryIndex(); void modify(IIndexOperationContext ictx, ITupleReference tuple) throws HyracksDataException; /** * If this method returns successfully, then the cursor has been opened, and need to be closed * Otherwise, it has not been opened * * @param ictx * @param cursor * @param pred * @throws HyracksDataException */ void search(ILSMIndexOperationContext ictx, IIndexCursor cursor, ISearchPredicate pred) throws HyracksDataException; public void scanDiskComponents(ILSMIndexOperationContext ctx, IIndexCursor cursor) throws HyracksDataException; void scheduleFlush(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; ILSMDiskComponent flush(ILSMIOOperation operation) throws HyracksDataException; void scheduleMerge(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; ILSMDiskComponent merge(ILSMIOOperation operation) throws HyracksDataException;
response: ILSMOperationTracker getOperationTracker(); ILSMIOOperationScheduler getIOScheduler(); ILSMIOOperationCallback getIOOperationCallback(); List<ILSMDiskComponent> getDiskComponents(); boolean isPrimaryIndex(); void modify(IIndexOperationContext ictx, ITupleReference tuple) throws HyracksDataException; void search(ILSMIndexOperationContext ictx, IIndexCursor cursor, ISearchPredicate pred) throws HyracksDataException; public void scanDiskComponents(ILSMIndexOperationContext ctx, IIndexCursor cursor) throws HyracksDataException; void scheduleFlush(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; ILSMDiskComponent flush(ILSMIOOperation operation) throws HyracksDataException; void scheduleMerge(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; ILSMDiskComponent merge(ILSMIOOperation operation) throws HyracksDataException;

sample: 1138
buggy_code:  public static Throwable close(IIndexCursor cursor, Throwable root) { if (cursor != null) { try { cursor.close(); } catch (Throwable th) { // NOSONAR Will be suppressed try { LOGGER.log(Level.WARN, "Failure closing a cursor", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } <|startfocus|> root = ExceptionUtils.suppress(root, th); // NOSONAR <|endfocus|> } } return root;
code_review:  what needs to be suppressed here? 
target code: public static Throwable close(IIndexCursor cursor, Throwable root) { if (cursor != null) { try { cursor.close(); } catch (Throwable th) { // NOSONAR Will be suppressed try { LOGGER.log(Level.WARN, "Failure closing a cursor", th); } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure } root = ExceptionUtils.suppress(root, th); } } return root;
response: public static Throwable close(IIndexCursor cursor, Throwable root) { if (cursor != null) { try { cursor.close(); } catch (Throwable th) { root = ExceptionUtils.suppress(root, th); } } return root; }

sample: 1139
buggy_code:  IOperatorNodePushable operatorNodePushable = operatorNodePushables.get(activityIdInputIndex.getLeft()); return operatorNodePushable.getInputFrameWriter(activityIdInputIndex.getRight()); } @Override public String getDisplayName() { return "Super Activity " + parent.getActivityMap().values().toString(); } @FunctionalInterface interface OperatorNodePushableAction { void run(IOperatorNodePushable op) throws HyracksDataException; } @SuppressWarnings("unchecked") private void runInParallel(OperatorNodePushableAction action) throws HyracksDataException { <|startfocus|> Future<Void>[] tasks = new Future[operatorNodePushablesBFSOrder.size()]; Throwable[] failures = new Throwable[operatorNodePushablesBFSOrder.size()]; <|endfocus|> final Semaphore startSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); int completed = 0; Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try {
code_review:  can remove if we stick to collections 
target code: IOperatorNodePushable operatorNodePushable = operatorNodePushables.get(activityIdInputIndex.getLeft()); return operatorNodePushable.getInputFrameWriter(activityIdInputIndex.getRight()); } @Override public String getDisplayName() { return "Super Activity " + parent.getActivityMap().values().toString(); } @FunctionalInterface interface OperatorNodePushableAction { void run(IOperatorNodePushable op) throws HyracksDataException; } @SuppressWarnings("unchecked") private void runInParallel(OperatorNodePushableAction action) throws HyracksDataException { List<Future<Void>> tasks = new ArrayList<>(operatorNodePushablesBFSOrder.size()); Queue<Throwable> failures = new ArrayBlockingQueue<>(operatorNodePushablesBFSOrder.size()); final Semaphore startSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); int completed = 0; Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try {
response: IOperatorNodePushable operatorNodePushable = operatorNodePushables.get(activityIdInputIndex.getLeft()); return operatorNodePushable.getInputFrameWriter(activityIdInputIndex.getRight()); } @Override public String getDisplayName() { return "Super Activity " + parent.getActivityMap().values().toString(); } @FunctionalInterface interface OperatorNodePushableAction { void run(IOperatorNodePushable op) throws HyracksDataException; } @SuppressWarnings("unchecked") private void runInParallel(OperatorNodePushableAction action) throws HyracksDataException { Future<Void>[] tasks = new Future[operatorNodePushablesBFSOrder.size()]; Throwable[] failures = new Throwable[operatorNodePushablesBFSOrder.size()]; final Semaphore startSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); int completed = 0; Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try { action.run(operatorNodePushablesBFSOrder.get(current)); } catch (Throwable th) { failures[current] = th; } finally { completeSemaphore.release(); } return null; }); } startSemaphore.acquire(); for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { completeSemaphore.acquire(); } for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { if (failures[i] != null) { if (root == null) { root = failures[i]; } else { root.addSuppressed(failures[i]); } } } if (root != null) { throw HyracksDataException.create(root); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw HyracksDataException.create(e); } }

sample: 1140
buggy_code:  } @FunctionalInterface interface OperatorNodePushableAction { void run(IOperatorNodePushable op) throws HyracksDataException; } @SuppressWarnings("unchecked") private void runInParallel(OperatorNodePushableAction action) throws HyracksDataException { Future<Void>[] tasks = new Future[operatorNodePushablesBFSOrder.size()]; Throwable[] failures = new Throwable[operatorNodePushablesBFSOrder.size()]; final Semaphore startSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); <|startfocus|> int completed = 0; <|endfocus|> Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try { action.run(operatorNodePushablesBFSOrder.get(current)); } catch (Throwable th) { // NOSONAR: Must catch all causes of failure failures[current] = th; throw th; } finally { completeSemaphore.release(); } return null; }); }
code_review:  why not leave as lists? we can then remove the use of indexes and just operate on the collections as before? 
target code: } @FunctionalInterface interface OperatorNodePushableAction { void run(IOperatorNodePushable op) throws HyracksDataException; } @SuppressWarnings("unchecked") private void runInParallel(OperatorNodePushableAction action) throws HyracksDataException { Future<Void>[] tasks = new Future[operatorNodePushablesBFSOrder.size()]; Throwable[] failures = new Throwable[operatorNodePushablesBFSOrder.size()]; final Semaphore startSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try { action.run(operatorNodePushablesBFSOrder.get(current)); } catch (Throwable th) { // NOSONAR: Must catch all causes of failure failures[current] = th; throw th; } finally { completeSemaphore.release(); } return null; }); }
response: import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception { Class<?> c = Class.forName("TypePropagation"); Method m = c.getMethod("method", int[].class); int[] array = new int[7]; Object[] arguments = { array }; m.invoke(null, arguments); } } Iterator<Expression> iterator = node.astArguments().iterator(); Expression argument = null; for (Expression arg : iterator) { argument = arg; } if (argument == null) { return; } long value = getLongValue(context, argument); if (value < min) { String message = String.format("Value will be forced up to %d as of Android 5.1; " + "don't rely on this to be exact", min); context.report(ISSUE, argument, context.getLocation(argument), message); } provider = config.createExecutableExtension("class");//$NON-NLS-1$ if (provider instanceof ICommitMessageProvider) { providers.add((ICommitMessageProvider) provider); } else { Activator.logError(UIText.CommitDialog_WrongTypeOfCommitMessageProvider, null); } } catch (CoreException | InvalidRegistryObjectException e) { String contributorName; try { contributorName = config.getDeclaringExtension().getContributor().getName(); } catch (InvalidRegistryObjectException e1) { contributorName = ""; //$NON-NLS-1$ } Activator.logError(MessageFormat.format(UIText.CommitDialog_ErrorCreatingCommitMessageProvider, contributorName), e); } } return providers; } provider = config.createExecutableExtension("class");//$NON-NLS-1$ if (provider instanceof ICommitMessageProvider) { providers.add((ICommitMessageProvider) provider); } else { Activator.logError(UIText.CommitDialog_WrongTypeOfCommitMessageProvider, null); } } catch (CoreException | InvalidRegistryObjectException e) { String contributorName; try { contributorName = config.getDeclaringExtension().getContributor().getName(); } catch (InvalidRegistryObjectException e1) { contributorName = ""; //$NON-NLS-1$ } Activator.logError(MessageFormat.format(UIText.CommitDialog_ErrorCreatingCommitMessageProvider, contributorName), e); } } return providers; } @SuppressWarnings("unchecked") private void runInParallel(Operator

sample: 1141
buggy_code:  final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); int completed = 0; Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try { action.run(operatorNodePushablesBFSOrder.get(current)); } catch (Throwable th) { // NOSONAR: Must catch all causes of failure <|startfocus|> failures[current] = th; <|endfocus|> throw th; } finally { completeSemaphore.release(); } return null; }); } for (Future<Void> task : tasks) { task.get(); completed++; } } catch (ExecutionException e) { root = e.getCause(); completed++; } catch (Throwable e) { // NOSONAR: Must catch all causes of failure root = e; } if (root != null) { cancelTasks(tasks, startSemaphore, completeSemaphore);
code_review:  MAJOR SonarQube violation: Extract this nested try block into a separate method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1141 
target code: final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); int completed = 0; Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try { action.run(operatorNodePushablesBFSOrder.get(current)); } catch (Throwable th) { // NOSONAR: Must catch all causes of failure failures.offer(th); throw th; } finally { completeSemaphore.release(); } return null; }); } for (Future<Void> task : tasks) { task.get(); completed++; } } catch (ExecutionException e) { root = e.getCause(); completed++; } catch (Throwable e) { // NOSONAR: Must catch all causes of failure root = e; } if (root != null) { cancelTasks(tasks, startSemaphore, completeSemaphore);
response: final Semaphore completeSemaphore = new Semaphore(1 - operatorNodePushablesBFSOrder.size()); int completed = 0; Throwable root = null; try { for (int i = 0; i < operatorNodePushablesBFSOrder.size(); i++) { final int current = i; tasks[i] = ctx.getExecutorService().submit(() -> { startSemaphore.release(); try { action.run(operatorNodePushablesBFSOrder.get(current)); } catch (Throwable th) { failures[current] = th; throw th; } finally { completeSemaphore.release(); } return null; }); } for (Future<Void> task : tasks) { task.get(); completed++; } } catch (ExecutionException e) { root = e.getCause(); completed++; } catch (Throwable e) { root = e; } if (root != null) { cancelTasks(tasks, startSemaphore, completeSemaphore); }

sample: 1142
buggy_code:  */ Checkpoint getLatest() throws ACIDException; /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); <|startfocus|> void lockLSN(long lsn); <|endfocus|> } 
code_review:  how about this? void secure(TxnId id); You can call this in TransactionManager before the rollback. Make it syncrhonized in CheckpointManager and just use a hash map to store the secured txnId and the current low water mark. Whenever a checkpoint attempt happens after that, check the minimum secured low water mark in the map and fail the checkpoint if its target is greater than that minimum. For any other reader, you can use a dummy txnId (e.g. -1) just to secure the low water mark. 
target code: */ Checkpoint getLatest() throws ACIDException; /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); void completed(TxnId id); }
response: public boolean hasIncrementalStats() { TPartitionStats partStats = getPartitionStats(); return partStats != null && partStats.intermediate_col_stats != null; } public synchronized ClassLoader getClassLoader(ObjectId rulesId) { if (rulesId == null || rulesDir == null) { return null; } Reference<? extends ClassLoader> ref = classLoaderCache.get(rulesId); if (ref != null) { ClassLoader cl = ref.get(); if (cl != null) { return cl; } synchronized(lock) { referMap.remove(rulesId); } ref.enqueue(); } cleanMap(); if (rulesId == null || rulesDir == null) { return null; } File jarFile = new File(rulesDir, "rules-" + rulesId.getName() + ".jar"); if (!jarFile.isFile()) { return null; } ClassLoader defaultLoader = getClass().getClassLoader(); URL url; try { url = jarFile.toURI().toURL(); } catch (MalformedURLException e) { return null; } URL[] urls = new URL[]{url}; } public interface CheckpointManager { Checkpoint getLatest() throws ACIDException; void doSharpCheckpoint() throws HyracksDataException; long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); void lockLSN(long lsn); }

sample: 1143
buggy_code:  /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); <|startfocus|> void lockLSN(long lsn); <|endfocus|> } 
code_review:  How about this? void completed(TxnId id); Call this in the finally block in TransactionManager in about. Make the method synchronized in CheckpointManager and just remove the txnid from the secured txns map. 
target code: /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); void completed(TxnId id); }
response: /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); void lockLSN(long lsn);

sample: 1144
buggy_code:  DataflowUtils.addTupleToFrame(tupleAppender, tuple, insertOp); lowWaterMarkLSN = recoveryManager.getMinFirstLSN(); currentLowWaterMarkLogFileId = logManager.getLogFileId(lowWaterMarkLSN); } } /* * At this point, the low-water mark is not in the initialLowWaterMarkFileId, so * a checkpoint should delete it. We will also start a second <|startfocus|> * job to ensure that the checkpointing coexists peacefully * with other concurrent readers of the log that request <|endfocus|> * deletions to be witheld */ JobId jobId2 = nc.newJobId(); IHyracksTaskContext ctx2 = nc.createTestContext(jobId2, 0, false); nc.getTransactionManager().beginTransaction(nc.getTxnJobId(ctx2), new TransactionOptions(ITransactionManager.AtomicityLevel.ENTITY_LEVEL)); // Prepare insert operation LSMInsertDeleteOperatorNodePushable insertOp2 = nc.getInsertPipeline(ctx2, dataset, KEY_TYPES, RECORD_TYPE, META_TYPE, null, KEY_INDEXES, KEY_INDICATOR_LIST, storageManager, null).getLeft(); insertOp2.open(); VSizeFrame frame2 = new VSizeFrame(ctx2);
code_review:  WS 
target code: DataflowUtils.addTupleToFrame(tupleAppender, tuple, insertOp); lowWaterMarkLSN = recoveryManager.getMinFirstLSN(); currentLowWaterMarkLogFileId = logManager.getLogFileId(lowWaterMarkLSN); } } /* * At this point, the low-water mark is not in the initialLowWaterMarkFileId, so * a checkpoint should delete it. We will also start a second * job to ensure that the checkpointing coexists peacefully * with other concurrent readers of the log that request * deletions to be witheld */ JobId jobId2 = nc.newJobId(); IHyracksTaskContext ctx2 = nc.createTestContext(jobId2, 0, false); nc.getTransactionManager().beginTransaction(nc.getTxnJobId(ctx2), new TransactionOptions(ITransactionManager.AtomicityLevel.ENTITY_LEVEL)); // Prepare insert operation LSMInsertDeleteOperatorNodePushable insertOp2 = nc.getInsertPipeline(ctx2, dataset, KEY_TYPES, RECORD_TYPE, META_TYPE, null, KEY_INDEXES, KEY_INDICATOR_LIST, storageManager, null).getLeft(); insertOp2.open(); VSizeFrame frame2 = new VSizeFrame(ctx2);
response: DataflowUtils.addTupleToFrame(tupleAppender, tuple, insertOp); lowWaterMarkLSN = recoveryManager.getMinFirstLSN(); currentLowWaterMarkLogFileId = logManager.getLogFileId(lowWaterMarkLSN); } JobId jobId2 = nc.newJobId(); IHyracksTaskContext ctx2 = nc.createTestContext(jobId2, 0, false); nc.getTransactionManager().beginTransaction(nc.getTxnJobId(ctx2), new TransactionOptions(ITransactionManager.AtomicityLevel.ENTITY_LEVEL)); LSMInsertDeleteOperatorNodePushable insertOp2 = nc.getInsertPipeline(ctx2, dataset, KEY_TYPES, RECORD_TYPE, META_TYPE, null, KEY_INDEXES, KEY_INDICATOR_LIST, storageManager, null).getLeft(); insertOp2.open(); VSizeFrame frame2 = new VSizeFrame(ctx2);

sample: 1145
buggy_code:  RECORD_TYPE, META_TYPE, null, KEY_INDEXES, KEY_INDICATOR_LIST, storageManager, null).getLeft(); insertOp2.open(); VSizeFrame frame2 = new VSizeFrame(ctx2); FrameTupleAppender tupleAppender2 = new FrameTupleAppender(frame2); for (int i = 0; i < 4; i++) { long lastCkpoint = recoveryManager.getMinFirstLSN(); long lastFileId = logManager.getLogFileId(lastCkpoint); <|startfocus|> System.out.println("ckpoint: " + lastCkpoint); <|endfocus|> checkpointManager.tryCheckpoint(lowWaterMarkLSN); // Validate initialLowWaterMarkFileId was deleted for (Long fileId : logManager.getLogFileIds()) { Assert.assertNotEquals(initialLowWaterMarkFileId, fileId.longValue()); } while (currentLowWaterMarkLogFileId == lastFileId) { ITupleReference tuple = tupleGenerator.next(); DataflowUtils.addTupleToFrame(tupleAppender2, tuple, insertOp2); lowWaterMarkLSN = recoveryManager.getMinFirstLSN(); currentLowWaterMarkLogFileId = logManager.getLogFileId(lowWaterMarkLSN); } }
code_review:  Use logger 
target code: RECORD_TYPE, META_TYPE, null, KEY_INDEXES, KEY_INDICATOR_LIST, storageManager, null).getLeft(); insertOp2.open(); VSizeFrame frame2 = new VSizeFrame(ctx2); FrameTupleAppender tupleAppender2 = new FrameTupleAppender(frame2); for (int i = 0; i < 4; i++) { long lastCkpoint = recoveryManager.getMinFirstLSN(); long lastFileId = logManager.getLogFileId(lastCkpoint); checkpointManager.tryCheckpoint(lowWaterMarkLSN); // Validate initialLowWaterMarkFileId was deleted for (Long fileId : logManager.getLogFileIds()) { Assert.assertNotEquals(initialLowWaterMarkFileId, fileId.longValue()); } while (currentLowWaterMarkLogFileId == lastFileId) { ITupleReference tuple = tupleGenerator.next(); DataflowUtils.addTupleToFrame(tupleAppender2, tuple, insertOp2); lowWaterMarkLSN = recoveryManager.getMinFirstLSN(); currentLowWaterMarkLogFileId = logManager.getLogFileId(lowWaterMarkLSN); } }
response: RECORD_TYPE, META_TYPE, null, KEY_INDEXES, KEY_INDICATOR_LIST, storageManager, null).getLeft(); insertOp2.open(); VSizeFrame frame2 = new VSizeFrame(ctx2); FrameTupleAppender tupleAppender2 = new FrameTupleAppender(frame2); for (int i = 0; i < 4; i++) { long lastCkpoint = recoveryManager.getMinFirstLSN(); long lastFileId = logManager.getLogFileId(lastCkpoint); logger.debug("ckpoint: " + lastCkpoint); checkpointManager.tryCheckpoint(lowWaterMarkLSN); // Validate initialLowWaterMarkFileId was deleted for (Long fileId : logManager.getLogFileIds()) { Assert.assertNotEquals(initialLowWaterMarkFileId, fileId.longValue()); } while (currentLowWaterMarkLogFileId == lastFileId) { ITupleReference tuple = tupleGenerator.next(); DataflowUtils.addTupleToFrame(tupleAppender2, tuple, insertOp2); lowWaterMarkLSN = recoveryManager.getMinFirstLSN(); currentLowWaterMarkLogFileId = logManager.getLogFileId(lowWaterMarkLSN); } }

sample: 1146
buggy_code:  /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); <|startfocus|> void lockLSN(long lsn); <|endfocus|> } 
code_review:  why lock specific LSNs? all what you need is to block the checkpoint from advancing the current low water mark until the log reader is done. 
target code: /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); void completed(TxnId id); }
response: void doSharpCheckpoint() throws HyracksDataException; long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void unlockLSN(long lsn); void lockLSN(long lsn);

sample: 1147
buggy_code:  private void touchLogFile(long fileId) { synchronized (txnLogFileId2ReaderCount) { if (txnLogFileId2ReaderCount.containsKey(fileId)) { txnLogFileId2ReaderCount.put(fileId, txnLogFileId2ReaderCount.get(fileId) + 1); } else { txnLogFileId2ReaderCount.put(fileId, 1); } <|startfocus|> } <|endfocus|>
code_review:  why? 
target code: private void touchLogFile(long fileId) { synchronized (txnLogFileId2ReaderCount) { if (txnLogFileId2ReaderCount.containsKey(fileId)) { txnLogFileId2ReaderCount.put(fileId, txnLogFileId2ReaderCount.get(fileId) + 1); } else { txnLogFileId2ReaderCount.put(fileId, 1); } } fileChannel.close();
response: private void touchLogFile(long fileId) { synchronized (txnLogFileId2ReaderCount) { if (txnLogFileId2ReaderCount.containsKey(fileId)) { txnLogFileId2ReaderCount.put(fileId, txnLogFileId2ReaderCount.get(fileId) + 1); } else { txnLogFileId2ReaderCount.put(fileId, 1); } } }

sample: 1148
buggy_code:  public void run() { <|startfocus|> while (true) { <|endfocus|> try { logRecord = flushLogsQ.take(); appendToLogTail(logRecord); } catch (ACIDException e) { e.printStackTrace(); } catch (InterruptedException e) { //ignore } }
code_review:  why? 
target code: public void run() { while (!Thread.currentThread().isInterrupted()) { try { logRecord = flushLogsQ.take(); appendToLogTail(logRecord); } catch (ACIDException e) { e.printStackTrace(); } catch (InterruptedException e) { //ignore } }
response: public void run() { while (true) { try { logRecord = flushLogsQ.take(); appendToLogTail(logRecord); } catch (ACIDException e) { e.printStackTrace(); } catch (InterruptedException e) { //ignore } } }

sample: 1149
buggy_code:  if (!checkpointDir.exists()) { if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory " + checkpointDirPath + " didn't exist. Creating one"); } checkpointDir.mkdirs(); } lsnThreshold = checkpointProperties.getLsnThreshold(); pollFrequency = checkpointProperties.getPollFrequency(); // We must keep at least the latest checkpoint historyToKeep = checkpointProperties.getHistoryToKeep() == 0 ? 1 : checkpointProperties.getHistoryToKeep(); <|startfocus|> lockedLSNs = new TreeMap<>(); <|endfocus|>
code_review:  why TreeMap? 
target code: if (!checkpointDir.exists()) { if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory " + checkpointDirPath + " didn't exist. Creating one"); } checkpointDir.mkdirs(); } lsnThreshold = checkpointProperties.getLsnThreshold(); pollFrequency = checkpointProperties.getPollFrequency(); // We must keep at least the latest checkpoint historyToKeep = checkpointProperties.getHistoryToKeep() == 0 ? 1 : checkpointProperties.getHistoryToKeep(); securedLSNs = new HashMap<>();
response: if (!checkpointDir.exists()) { if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory " + checkpointDirPath + " didn't exist. Creating one"); } checkpointDir.mkdirs(); } lsnThreshold = checkpointProperties.getLsnThreshold(); pollFrequency = checkpointProperties.getPollFrequency(); // We must keep at least the latest checkpoint historyToKeep = checkpointProperties.getHistoryToKeep() == 0 ? 1 : checkpointProperties.getHistoryToKeep(); lockedLSNs = new HashMap<>();

sample: 1150
buggy_code:  if (checkpointSucceeded) { ILogManager logManager = txnSubsystem.getLogManager(); synchronized (logManager) { for (Long l : lockedLSNs.keySet()) { if (minFirstLSN > l) { return minFirstLSN; } } logManager.deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } } return minFirstLSN; } @Override public void lockLSN(long lsn) { <|startfocus|> synchronized (txnSubsystem.getLogManager()) { <|endfocus|> if (!lockedLSNs.containsKey(lsn)) { lockedLSNs.put(lsn, 1); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) + 1); } } } @Override public void unlockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { return; } else { if (lockedLSNs.get(lsn) == 1) { lockedLSNs.remove(lsn); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) - 1); } } } } } 
code_review:  I don't see any reason for synchronizing on logManager. The log manager shouldn't be involved in protecting LSN. All ingestion threads are already competing on log manager, it wouldn't be wise to add additional unnecessary synchronization there. 
target code: if (checkpointSucceeded) { ILogManager logManager = txnSubsystem.getLogManager(); synchronized (logManager) { for (Long l : lockedLSNs.keySet()) { if (minFirstLSN > l) { return minFirstLSN; } } logManager.deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } } return minFirstLSN; } @Override public void lockLSN(long lsn) { synchronized (txnSubsystem.getRecoveryManager()) { if (!lockedLSNs.containsKey(lsn)) { lockedLSNs.put(lsn, 1); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) + 1); } } } @Override public void unlockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { return; } else { if (lockedLSNs.get(lsn) == 1) { lockedLSNs.remove(lsn); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) - 1); } } } } }
response: if (checkpointSucceeded) { for (Long l : lockedLSNs.keySet()) { if (minFirstLSN > l) { return minFirstLSN; } } logManager.deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; @Override public void lockLSN(long lsn) { if (!lockedLSNs.containsKey(lsn)) { lockedLSNs.put(lsn, 1); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) + 1); } } @Override public void unlockLSN(long lsn) { if (!lockedLSNs.containsKey(lsn)) { return; } else { if (lockedLSNs.get(lsn) == 1) { lockedLSNs.remove(lsn); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) - 1); } } }

sample: 1151
buggy_code:  } } return minFirstLSN; } @Override public void lockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { lockedLSNs.put(lsn, 1); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) + 1); } } } @Override public void unlockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { <|startfocus|> return; <|endfocus|> } else { if (lockedLSNs.get(lsn) == 1) { lockedLSNs.remove(lsn); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) - 1); } } } } } 
code_review:  if this happens, then something is wrong 
target code: } } return minFirstLSN; } @Override public void lockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { lockedLSNs.put(lsn, 1); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) + 1); } } } @Override public void unlockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { throw new IllegalStateException("Unlock on nonexisting LSN"); } else { if (lockedLSNs.get(lsn) == 1) { lockedLSNs.remove(lsn); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) - 1); } } } } }
response: } } return minFirstLSN; } @Override public void lockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { lockedLSNs.put(lsn, 1); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) + 1); } } } @Override public void unlockLSN(long lsn) { synchronized (txnSubsystem.getLogManager()) { if (!lockedLSNs.containsKey(lsn)) { return; } else { if (lockedLSNs.get(lsn) == 1) { lockedLSNs.remove(lsn); } else { lockedLSNs.replace(lsn, lockedLSNs.get(lsn) - 1); } } } } }

sample: 1152
buggy_code:  final IVisitablePointable vp1 = pa.allocateRecordValue(inRecType1); final IPointable argPtr0 = new VoidPointable(); final IPointable argPtr1 = new VoidPointable(); final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx); final List<RecordBuilder> rbStack = new ArrayList<>(); final ArrayBackedValueStorage tabvs = new ArrayBackedValueStorage(); <|startfocus|> final IBinaryComparator STRING_BINARY_COMPARATOR = PointableHelper.createStringBinaryComparator(); <|endfocus|> return new IScalarEvaluator() { private final RuntimeRecordTypeInfo runtimeRecordTypeInfo = new RuntimeRecordTypeInfo(); private final DeepEqualAssessor deepEqualAssesor = new DeepEqualAssessor(); private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); eval1.evaluate(tuple, argPtr1); vp0.set(argPtr0); vp1.set(argPtr1); 
code_review:  let's make it lower case. This is not a static constant anymore 
target code: final IVisitablePointable vp1 = pa.allocateRecordValue(inRecType1); final IPointable argPtr0 = new VoidPointable(); final IPointable argPtr1 = new VoidPointable(); final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx); final List<RecordBuilder> rbStack = new ArrayList<>(); final ArrayBackedValueStorage tabvs = new ArrayBackedValueStorage(); final IBinaryComparator stringBinaryComparator = PointableHelper.createStringBinaryComparator(); return new IScalarEvaluator() { private final RuntimeRecordTypeInfo runtimeRecordTypeInfo = new RuntimeRecordTypeInfo(); private final DeepEqualAssessor deepEqualAssesor = new DeepEqualAssessor(); private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); eval1.evaluate(tuple, argPtr1); vp0.set(argPtr0); vp1.set(argPtr1);
response: final IVisitablePointable vp1 = pa.allocateRecordValue(inRecType1); final IPointable argPtr0 = new VoidPointable(); final IPointable argPtr1 = new VoidPointable(); final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx); final List<RecordBuilder> rbStack = new ArrayList<>(); final ArrayBackedValueStorage tabvs = new ArrayBackedValueStorage(); final IBinaryComparator stringBinaryComparator = PointableHelper.createStringBinaryComparator(); return new IScalarEvaluator() { private final RuntimeRecordTypeInfo runtimeRecordTypeInfo = new RuntimeRecordTypeInfo(); private final DeepEqualAssessor deepEqualAssesor = new DeepEqualAssessor(); private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); eval1.evaluate(tuple, argPtr1); vp0.set(argPtr0); vp1.set(argPtr1); // rest of the code } };

sample: 1153
buggy_code:  public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { final PointableAllocator pa = new PointableAllocator(); final IVisitablePointable vp0 = pa.allocateRecordValue(inputRecType); final IVisitablePointable vp1 = pa.allocateListValue(inputListType); final IPointable inputArg0 = new VoidPointable(); final IPointable inputArg1 = new VoidPointable(); final IScalarEvaluator eval0 = inputRecordEvalFactory.createScalarEvaluator(ctx); final IScalarEvaluator eval1 = removeFieldPathsFactory.createScalarEvaluator(ctx); <|startfocus|> final IBinaryComparator STRING_BINARY_COMPARATOR = PointableHelper.createStringBinaryComparator(); <|endfocus|> return new IScalarEvaluator() { private final RuntimeRecordTypeInfo runtimeRecordTypeInfo = new RuntimeRecordTypeInfo(); private final List<RecordBuilder> rbStack = new ArrayList<>(); private final ArrayBackedValueStorage tabvs = new ArrayBackedValueStorage(); private final Deque<IVisitablePointable> recordPath = new ArrayDeque<>(); private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset();
code_review:  let's make it lower case. This is not a static constant anymore 
target code: public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { final PointableAllocator pa = new PointableAllocator(); final IVisitablePointable vp0 = pa.allocateRecordValue(inputRecType); final IVisitablePointable vp1 = pa.allocateListValue(inputListType); final IPointable inputArg0 = new VoidPointable(); final IPointable inputArg1 = new VoidPointable(); final IScalarEvaluator eval0 = inputRecordEvalFactory.createScalarEvaluator(ctx); final IScalarEvaluator eval1 = removeFieldPathsFactory.createScalarEvaluator(ctx); final IBinaryComparator stringBinaryComparator = PointableHelper.createStringBinaryComparator(); return new IScalarEvaluator() { private final RuntimeRecordTypeInfo runtimeRecordTypeInfo = new RuntimeRecordTypeInfo(); private final List<RecordBuilder> rbStack = new ArrayList<>(); private final ArrayBackedValueStorage tabvs = new ArrayBackedValueStorage(); private final Deque<IVisitablePointable> recordPath = new ArrayDeque<>(); private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset();
response: public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { final PointableAllocator pa = new PointableAllocator(); final IVisitablePointable vp0 = pa.allocateRecordValue(inputRecType); final IVisitablePointable vp1 = pa.allocateListValue(inputListType); final IPointable inputArg0 = new VoidPointable(); final IPointable inputArg1 = new VoidPointable(); final IScalarEvaluator eval0 = inputRecordEvalFactory.createScalarEvaluator(ctx); final IScalarEvaluator eval1 = removeFieldPathsFactory.createScalarEvaluator(ctx); final IBinaryComparator stringBinaryComparator = PointableHelper.createStringBinaryComparator(); return new IScalarEvaluator() { private final RuntimeRecordTypeInfo runtimeRecordTypeInfo = new RuntimeRecordTypeInfo(); private final List<RecordBuilder> rbStack = new ArrayList<>(); private final ArrayBackedValueStorage tabvs = new ArrayBackedValueStorage(); private final Deque<IVisitablePointable> recordPath = new ArrayDeque<>(); private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private DataOutput out = resultStorage.getDataOutput(); @Override public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); // rest of the code } }; }

sample: 1154
buggy_code:  } IndexCursorUtils.open(btreeAccessors, btreeCursors, btreeRangePredicate); try { for (int i = 0; i < numberOfTrees; i++) { if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); } else { depletedBtreeCursors[i] = true; } } } catch (Throwable th) { // NOSONAR Must catch all failures to close before throwing for (int i = 0; i < numberOfTrees; i++) { <|startfocus|> th = IndexCursorUtils.close(btreeCursors[i], th); <|endfocus|> } throw HyracksDataException.create(th); } } } 
code_review:  it seems this isn't needed, can we remove it? 
target code: } IndexCursorUtils.open(btreeAccessors, btreeCursors, btreeRangePredicate); try { for (int i = 0; i < numberOfTrees; i++) { if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); } else { depletedBtreeCursors[i] = true; } } } catch (Throwable th) { // NOSONAR Must catch all failures to close before throwing for (int i = 0; i < numberOfTrees; i++) { IndexCursorUtils.close(btreeCursors[i], th); } throw HyracksDataException.create(th); } } }
response: IndexCursorUtils.open(btreeAccessors, btreeCursors, btreeRangePredicate); try { for (int i = 0; i < numberOfTrees; i++) { if (btreeCursors[i].hasNext()) { btreeCursors[i].next(); } else { depletedBtreeCursors[i] = true; } } } catch (Throwable th) { for (int i = 0; i < numberOfTrees; i++) { th = IndexCursorUtils.close(btreeCursors[i], th); } throw HyracksDataException.create(th); }

sample: 1155
buggy_code:  throws HyracksDataException { int opened = 0; try { for (int i = 0; i < cursors.length; i++) { if (accessors.get(i) != null) { accessors.get(i).search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { <|startfocus|> th = IndexCursorUtils.close(cursors[j], th); <|endfocus|> } throw HyracksDataException.create(th); } } public static void open(IIndexAccessor[] accessors, IIndexCursor[] cursors, ISearchPredicate pred) throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th);
code_review:  this seems unneeded, remove it? 
target code: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < cursors.length; i++) { if (accessors.get(i) != null) { accessors.get(i).search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static void open(IIndexAccessor[] accessors, IIndexCursor[] cursors, ISearchPredicate pred) throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th);
response: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < cursors.length; i++) { if (accessors.get(i) != null) { accessors.get(i).search(cursors[i], pred); } opened++; } } catch (Throwable th) { for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static void open(IIndexAccessor[] accessors, IIndexCursor[] cursors, ISearchPredicate pred) throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } }

sample: 1156
buggy_code:  throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { <|startfocus|> th = IndexCursorUtils.close(cursors[j], th); <|endfocus|> } throw HyracksDataException.create(th); } } public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; } } 
code_review:  this seems unneeded, remove it? 
target code: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { // NOSONAR: Much catch all failures for (int j = 0; j < opened; j++) { IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; } }
response: throws HyracksDataException { int opened = 0; try { for (int i = 0; i < accessors.length; i++) { if (accessors[i] != null) { accessors[i].search(cursors[i], pred); } opened++; } } catch (Throwable th) { for (int j = 0; j < opened; j++) { th = IndexCursorUtils.close(cursors[j], th); } throw HyracksDataException.create(th); } } public static Throwable close(IIndexCursor[] cursors, Throwable th) { for (int j = 0; j < cursors.length; j++) { th = IndexCursorUtils.close(cursors[j], th); } return th; }

sample: 1157
buggy_code:  initializationTasks.add(ctx.getExecutorService().submit(new Callable<Void>() { @Override public Void call() throws Exception { opAction.runAction(op, opIndex); return null; } })); } // Waits until all parallel actions to finish. for (Future<Void> initializationTask : initializationTasks) { initializationTask.get(); } } catch (Throwable th) { for (Future<Void> initializationTask : initializationTasks) { initializationTask.cancel(true); } <|startfocus|> throw new HyracksDataException(th); <|endfocus|> } } } 
code_review:  replace with a one-liner? e.g. failures.forEach(f -> ExceptionUtils.suppress(root, f)) 
target code: initializationTasks.add(ctx.getExecutorService().submit(new Callable<Void>() { @Override public Void call() throws Exception { opAction.runAction(op, opIndex); return null; } })); } // Waits until all parallel actions to finish. for (Future<Void> initializationTask : initializationTasks) { initializationTask.get(); } } catch (Throwable th) { for (Future<Void> initializationTask : initializationTasks) { initializationTask.cancel(true); } } finally { completeSemaphore.acquireUninterruptibly(); } } }
response: initializationTasks.add(ctx.getExecutorService().submit(() -> { opAction.runAction(op, opIndex); return null; })); // Waits until all parallel actions to finish. for (Future<Void> initializationTask : initializationTasks) { initializationTask.get(); } } catch (Throwable th) { for (Future<Void> initializationTask : initializationTasks) { initializationTask.cancel(true); } throw new HyracksDataException(th); } }

sample: 1158
buggy_code:  public LogRecord next() { if (buffer.position() == endOffset) { return null; } RecordReadStatus status = logRecord.readLogRecord(buffer); //underflow is not expected because we are at the very tail of the current log buffer if (status != RecordReadStatus.OK) { <|startfocus|> throw new IllegalStateException( "Unexpected log read status: " + status + ". Read log: " + logRecord.getLogRecordForDisplay()); <|endfocus|> } return logRecord;
code_review:  should we just log this in the log, not include in the exception? also, can we please log the bytes in byte buffer, starting at position() prior to calling readLogRecord (or even some bytes before if available) up to the current position at time of status != RecordReadStatus.OK (including some bytes after if available)? 
target code: public LogRecord next() { if (buffer.position() == endOffset) { return null; } RecordReadStatus status = logRecord.readLogRecord(buffer); //underflow is not expected because we are at the very tail of the current log buffer if (status != RecordReadStatus.OK) { logReadFailure(status); throw new IllegalStateException("Unexpected log read status: " + status); } return logRecord;
response: public LogRecord next() { if (buffer.position() == endOffset) { return null; } RecordReadStatus status = logRecord.readLogRecord(buffer); if (status != RecordReadStatus.OK) { String logMessage = "Unexpected log read status: " + status + ". Read log: " + logRecord.getLogRecordForDisplay(); log.error(logMessage); throw new IllegalStateException(logMessage); } return logRecord; }

sample: 1159
buggy_code:  IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() { <|startfocus|> return securedLSNs.values().size() > 0 ? Collections.min(securedLSNs.values()) : -1; <|endfocus|> } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) { securedLSNs.remove(id); } } 
code_review:  MAJOR SonarQube violation: Use isEmpty() to check whether the collection is empty or not. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1155 
target code: IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() { return securedLSNs.isEmpty() ? Collections.min(securedLSNs.values()) : -1; } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) { securedLSNs.remove(id); } }
response: IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; private synchronized long getMinSecuredLSN() { return securedLSNs.isEmpty() ? -1 : Collections.min(securedLSNs.values()); } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) { securedLSNs.remove(id); }

sample: 1160
buggy_code:  Checkpoint getLatest() throws ACIDException; /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void secure(TxnId id) throws HyracksDataException; <|startfocus|> <|endfocus|> void completed(TxnId id); } 
code_review:  /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ 
target code: Checkpoint getLatest() throws ACIDException; /** * Performs a sharp checkpoint. * * @throws HyracksDataException */ void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void secure(TxnId id) throws HyracksDataException; /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ void completed(TxnId id); }
response: Checkpoint getLatest() throws ACIDException; void doSharpCheckpoint() throws HyracksDataException; long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void secure(TxnId id) throws HyracksDataException; void completed(TxnId id);

sample: 1161
buggy_code:  */ public abstract class AbstractCheckpointManager implements ICheckpointManager { private static final Logger LOGGER = LogManager.getLogger(); private static final String CHECKPOINT_FILENAME_PREFIX = "checkpoint_"; public static final long SHARP_CHECKPOINT_LSN = -1; private static final FilenameFilter filter = (File dir, String name) -> name.startsWith(CHECKPOINT_FILENAME_PREFIX); private final File checkpointDir; private final int historyToKeep; private final int lsnThreshold; private final int pollFrequency; <|startfocus|> protected Map<TxnId, Long> securedLSNs; <|endfocus|> protected final ITransactionSubsystem txnSubsystem; private CheckpointThread checkpointer; public AbstractCheckpointManager(ITransactionSubsystem txnSubsystem, CheckpointProperties checkpointProperties) { this.txnSubsystem = txnSubsystem; String checkpointDirPath = checkpointProperties.getCheckpointDirPath(); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory = " + checkpointDirPath); } if (!checkpointDirPath.endsWith(File.separator)) { checkpointDirPath += File.separator; } checkpointDir = new File(checkpointDirPath); // Create the checkpoint directory if missing if (!checkpointDir.exists()) {
code_review:  move it to CheckpointManager and make it private final 
target code: */ public abstract class AbstractCheckpointManager implements ICheckpointManager { private static final Logger LOGGER = LogManager.getLogger(); private static final String CHECKPOINT_FILENAME_PREFIX = "checkpoint_"; public static final long SHARP_CHECKPOINT_LSN = -1; private static final FilenameFilter filter = (File dir, String name) -> name.startsWith(CHECKPOINT_FILENAME_PREFIX); private final File checkpointDir; private final int historyToKeep; private final int lsnThreshold; private final int pollFrequency; protected final ITransactionSubsystem txnSubsystem; private CheckpointThread checkpointer; public AbstractCheckpointManager(ITransactionSubsystem txnSubsystem, CheckpointProperties checkpointProperties) { this.txnSubsystem = txnSubsystem; String checkpointDirPath = checkpointProperties.getCheckpointDirPath(); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory = " + checkpointDirPath); } if (!checkpointDirPath.endsWith(File.separator)) { checkpointDirPath += File.separator; } checkpointDir = new File(checkpointDirPath); // Create the checkpoint directory if missing if (!checkpointDir.exists()) {
response: public abstract class AbstractCheckpointManager implements ICheckpointManager { private static final Logger LOGGER = LogManager.getLogger(); private static final String CHECKPOINT_FILENAME_PREFIX = "checkpoint_"; public static final long SHARP_CHECKPOINT_LSN = -1; private static final FilenameFilter filter = (File dir, String name) -> name.startsWith(CHECKPOINT_FILENAME_PREFIX); private final File checkpointDir; private final int historyToKeep; private final int lsnThreshold; private final int pollFrequency; private final Map<TxnId, Long> securedLSNs; protected final ITransactionSubsystem txnSubsystem; private CheckpointThread checkpointer; public AbstractCheckpointManager(ITransactionSubsystem txnSubsystem, CheckpointProperties checkpointProperties) { this.txnSubsystem = txnSubsystem; String checkpointDirPath = checkpointProperties.getCheckpointDirPath(); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory = " + checkpointDirPath); } if (!checkpointDirPath.endsWith(File.separator)) { checkpointDirPath += File.separator; } checkpointDir = new File(checkpointDirPath); // Create the checkpoint directory if missing if (!checkpointDir.exists()) { checkpointDir.mkdirs(); } historyToKeep = checkpointProperties.getHistoryToKeep(); lsnThreshold = checkpointProperties.getLsnThreshold(); pollFrequency = checkpointProperties.getPollFrequency(); securedLSNs = new ConcurrentHashMap<>(); } // Rest of the code... }

sample: 1162
buggy_code:  final long minFirstLSN = txnSubsystem.getRecoveryManager().getMinFirstLSN(); boolean checkpointSucceeded = minFirstLSN >= checkpointTargetLSN; if (!checkpointSucceeded) { // Flush datasets with indexes behind target checkpoint LSN IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { <|startfocus|> for (Long l : securedLSNs.values()) { if (minFirstLSN >= l) { return minFirstLSN; } } <|endfocus|> txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) throws IllegalStateException { if (securedLSNs.containsKey(id)) { securedLSNs.remove(id); } else { throw new IllegalStateException(
code_review:  Refactor as getMinSecuredLsn and please use a better variable name than I. Also, make the check at the beginning of this method against checkpointTargetLSN to avoid scheduling the flushes (i.e. never move beyond the current secured low water mark). 
target code: final long minFirstLSN = txnSubsystem.getRecoveryManager().getMinFirstLSN(); boolean checkpointSucceeded = minFirstLSN >= checkpointTargetLSN; if (!checkpointSucceeded) { // Flush datasets with indexes behind target checkpoint LSN IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) throws IllegalStateException { if (securedLSNs.containsKey(id)) { securedLSNs.remove(id); } else { throw new IllegalStateException(
response: final long minSecuredLSN = txnSubsystem.getRecoveryManager().getMinFirstLSN(); boolean checkpointSucceeded = minSecuredLSN >= checkpointTargetLSN; if (!checkpointSucceeded) { // Flush datasets with indexes behind target checkpoint LSN IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minSecuredLSN, false); if (checkpointSucceeded) { for (Long securedLSN : securedLSNs.values()) { if (minSecuredLSN >= securedLSN) { return minSecuredLSN; } } txnSubsystem.getLogManager().deleteOldLogFiles(minSecuredLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minSecuredLSN)); } return minSecuredLSN; } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) throws IllegalStateException { if (securedLSNs.containsKey(id)) { securedLSNs.remove(id); } else { throw new IllegalStateException(...); } }

sample: 1163
buggy_code:  } } @Override public void abortTransaction(TxnId txnId) throws ACIDException { final ITransactionContext txnCtx = getTransactionContext(txnId); try { if (txnCtx.isWriteTxn()) { LogRecord logRecord = new LogRecord(); TransactionUtil.formJobTerminateLogRecord(txnCtx, logRecord, false); txnSubsystem.getLogManager().log(logRecord); txnSubsystem.getCheckpointManager().secure(txnId); txnSubsystem.getRecoveryManager().rollbackTransaction(txnCtx); txnCtx.setTxnState(ITransactionManager.ABORTED); } <|startfocus|> } catch (ACIDException | HyracksDataException e) { <|endfocus|> String msg = "Could not complete rollback! System is in an inconsistent state"; if (LOGGER.isErrorEnabled()) { LOGGER.log(Level.ERROR, msg, e); } throw new ACIDException(msg, e); } finally { txnCtx.complete(); txnSubsystem.getLockManager().releaseLocks(txnCtx); txnCtxRepository.remove(txnCtx.getTxnId()); txnSubsystem.getCheckpointManager().completed(txnId); } } @Override public long getMaxTxnId() { return maxTxnId.get(); } @Override public void start() {
code_review:  remove 
target code: } } @Override public void abortTransaction(TxnId txnId) throws ACIDException { final ITransactionContext txnCtx = getTransactionContext(txnId); try { if (txnCtx.isWriteTxn()) { LogRecord logRecord = new LogRecord(); TransactionUtil.formJobTerminateLogRecord(txnCtx, logRecord, false); txnSubsystem.getLogManager().log(logRecord); txnSubsystem.getCheckpointManager().secure(txnId); txnSubsystem.getRecoveryManager().rollbackTransaction(txnCtx); txnCtx.setTxnState(ITransactionManager.ABORTED); } } catch (HyracksDataException e) { String msg = "Could not complete rollback! System is in an inconsistent state"; if (LOGGER.isErrorEnabled()) { LOGGER.log(Level.ERROR, msg, e); } throw new ACIDException(msg, e); } finally { txnCtx.complete(); txnSubsystem.getLockManager().releaseLocks(txnCtx); txnCtxRepository.remove(txnCtx.getTxnId()); txnSubsystem.getCheckpointManager().completed(txnId); } } @Override public long getMaxTxnId() { return maxTxnId.get(); } @Override public void start() {
response: public void abortTransaction(TxnId txnId) throws ACIDException { final ITransactionContext txnCtx = getTransactionContext(txnId); try { if (txnCtx.isWriteTxn()) { LogRecord logRecord = new LogRecord(); TransactionUtil.formJobTerminateLogRecord(txnCtx, logRecord, false); txnSubsystem.getLogManager().log(logRecord); txnSubsystem.getCheckpointManager().secure(txnId); txnSubsystem.getRecoveryManager().rollbackTransaction(txnCtx); txnCtx.setTxnState(ITransactionManager.ABORTED); } } catch (ACIDException | HyracksDataException e) { String msg = "Could not complete rollback! System is in an inconsistent state"; if (LOGGER.isErrorEnabled()) { LOGGER.log(Level.ERROR, msg, e); } throw new ACIDException(msg, e); } finally { txnCtx.complete(); txnSubsystem.getLockManager().releaseLocks(txnCtx); txnCtxRepository.remove(txnCtx.getTxnId()); txnSubsystem.getCheckpointManager().completed(txnId); } } public long getMaxTxnId() { return maxTxnId.get(); } public void start() { // implementation }

sample: 1164
buggy_code:  */ public abstract class AbstractCheckpointManager implements ICheckpointManager { private static final Logger LOGGER = LogManager.getLogger(); private static final String CHECKPOINT_FILENAME_PREFIX = "checkpoint_"; public static final long SHARP_CHECKPOINT_LSN = -1; private static final FilenameFilter filter = (File dir, String name) -> name.startsWith(CHECKPOINT_FILENAME_PREFIX); private final File checkpointDir; private final int historyToKeep; private final int lsnThreshold; private final int pollFrequency; <|startfocus|> public Map<TxnId, Long> securedLSNs; <|endfocus|> protected final ITransactionSubsystem txnSubsystem; private CheckpointThread checkpointer; public AbstractCheckpointManager(ITransactionSubsystem txnSubsystem, CheckpointProperties checkpointProperties) { this.txnSubsystem = txnSubsystem; String checkpointDirPath = checkpointProperties.getCheckpointDirPath(); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory = " + checkpointDirPath); } if (!checkpointDirPath.endsWith(File.separator)) { checkpointDirPath += File.separator; } checkpointDir = new File(checkpointDirPath); // Create the checkpoint directory if missing if (!checkpointDir.exists()) {
code_review:  MAJOR SonarQube violation: Make securedLSNs a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck 
target code: */ public abstract class AbstractCheckpointManager implements ICheckpointManager { private static final Logger LOGGER = LogManager.getLogger(); private static final String CHECKPOINT_FILENAME_PREFIX = "checkpoint_"; public static final long SHARP_CHECKPOINT_LSN = -1; private static final FilenameFilter filter = (File dir, String name) -> name.startsWith(CHECKPOINT_FILENAME_PREFIX); private final File checkpointDir; private final int historyToKeep; private final int lsnThreshold; private final int pollFrequency; protected Map<TxnId, Long> securedLSNs; protected final ITransactionSubsystem txnSubsystem; private CheckpointThread checkpointer; public AbstractCheckpointManager(ITransactionSubsystem txnSubsystem, CheckpointProperties checkpointProperties) { this.txnSubsystem = txnSubsystem; String checkpointDirPath = checkpointProperties.getCheckpointDirPath(); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory = " + checkpointDirPath); } if (!checkpointDirPath.endsWith(File.separator)) { checkpointDirPath += File.separator; } checkpointDir = new File(checkpointDirPath); // Create the checkpoint directory if missing if (!checkpointDir.exists()) {
response: public abstract class AbstractCheckpointManager implements ICheckpointManager { private static final Logger LOGGER = LogManager.getLogger(); private static final String CHECKPOINT_FILENAME_PREFIX = "checkpoint_"; public static final long SHARP_CHECKPOINT_LSN = -1; private static final FilenameFilter filter = (File dir, String name) -> name.startsWith(CHECKPOINT_FILENAME_PREFIX); private final File checkpointDir; private final int historyToKeep; private final int lsnThreshold; private final int pollFrequency; private Map<TxnId, Long> securedLSNs; protected final ITransactionSubsystem txnSubsystem; private CheckpointThread checkpointer; public AbstractCheckpointManager(ITransactionSubsystem txnSubsystem, CheckpointProperties checkpointProperties) { this.txnSubsystem = txnSubsystem; String checkpointDirPath = checkpointProperties.getCheckpointDirPath(); if (LOGGER.isInfoEnabled()) { LOGGER.log(Level.INFO, "Checkpoint directory = " + checkpointDirPath); } if (!checkpointDirPath.endsWith(File.separator)) { checkpointDirPath += File.separator; } checkpointDir = new File(checkpointDirPath); // Create the checkpoint directory if missing if (!checkpointDir.exists()) { checkpointDir.mkdirs(); } // Initialize other properties historyToKeep = checkpointProperties.getHistoryToKeep(); lsnThreshold = checkpointProperties.getLsnThreshold(); pollFrequency = checkpointProperties.getPollFrequency(); securedLSNs = new HashMap<>(); } }

sample: 1165
buggy_code:  for (DatasetResourceReference indexRef : partitionResources) { long remoteIndexMaxLSN = idxCheckpointMgrProvider.get(indexRef).getLowWatermark(); minRemoteLSN = Math.min(minRemoteLSN, remoteIndexMaxLSN); } } return minRemoteLSN; } @Override public synchronized void replayReplicaPartitionLogs(Set<Integer> partitions, boolean flush) throws HyracksDataException { //replay logs > minLSN that belong to these partitions final TxnId randomDummyTxnId = new TxnId(ThreadLocalRandom.current().nextInt(Integer.MIN_VALUE, -1)); try { <|startfocus|> checkpointManager.secure(randomDummyTxnId); <|endfocus|> long minLSN = getPartitionsMinLSN(partitions); long readableSmallestLSN = logMgr.getReadableSmallestLSN(); if (minLSN < readableSmallestLSN) { minLSN = readableSmallestLSN; } replayPartitionsLogs(partitions, logMgr.getLogReader(true), minLSN); if (flush) { appCtx.getDatasetLifecycleManager().flushAllDatasets(); } } catch (IOException | ACIDException e) { throw HyracksDataException.create(e); } finally { checkpointManager.completed(randomDummyTxnId); } } @Override
code_review:  private static final TxnId recoveryTxnId = new TxnId(-1); 
target code: for (DatasetResourceReference indexRef : partitionResources) { long remoteIndexMaxLSN = idxCheckpointMgrProvider.get(indexRef).getLowWatermark(); minRemoteLSN = Math.min(minRemoteLSN, remoteIndexMaxLSN); } } return minRemoteLSN; } @Override public synchronized void replayReplicaPartitionLogs(Set<Integer> partitions, boolean flush) throws HyracksDataException { //replay logs > minLSN that belong to these partitions final TxnId randomDummyTxnId = new TxnId(ThreadLocalRandom.current().nextInt(Integer.MIN_VALUE, -1)); try { checkpointManager.secure(recoveryTxnId); long minLSN = getPartitionsMinLSN(partitions); long readableSmallestLSN = logMgr.getReadableSmallestLSN(); if (minLSN < readableSmallestLSN) { minLSN = readableSmallestLSN; } replayPartitionsLogs(partitions, logMgr.getLogReader(true), minLSN); if (flush) { appCtx.getDatasetLifecycleManager().flushAllDatasets(); } } catch (IOException | ACIDException e) { throw HyracksDataException.create(e); } finally { checkpointManager.completed(randomDummyTxnId); } } @Override
response: for (DatasetResourceReference indexRef : partitionResources) { long remoteIndexMaxLSN = idxCheckpointMgrProvider.get(indexRef).getLowWatermark(); minRemoteLSN = Math.min(minRemoteLSN, remoteIndexMaxLSN); } } return minRemoteLSN; } @Override public synchronized void replayReplicaPartitionLogs(Set<Integer> partitions, boolean flush) throws HyracksDataException { //replay logs > minLSN that belong to these partitions final TxnId randomDummyTxnId = new TxnId(ThreadLocalRandom.current().nextInt(Integer.MIN_VALUE, -1)); try { checkpointManager.secure(randomDummyTxnId); long minLSN = getPartitionsMinLSN(partitions); long readableSmallestLSN = logMgr.getReadableSmallestLSN(); if (minLSN < readableSmallestLSN) { minLSN = readableSmallestLSN; } replayPartitionsLogs(partitions, logMgr.getLogReader(true), minLSN); if (flush) { appCtx.getDatasetLifecycleManager().flushAllDatasets(); } } catch (IOException | ACIDException e) { throw HyracksDataException.create(e); } finally { checkpointManager.completed(randomDummyTxnId); } } @Override

sample: 1166
buggy_code:  void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; /** * Secures the current low-water mark until the transaction identified by {@code id} completes. * * @param id * @throws HyracksDataException */ <|startfocus|> <|endfocus|> void secure(TxnId id) throws HyracksDataException; /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ void completed(TxnId id); } 
code_review:  remove 
target code: void doSharpCheckpoint() throws HyracksDataException; /** * Attempts to perform a soft checkpoint at the specified {@code checkpointTargetLSN}. * * @param checkpointTargetLSN * @return The LSN recorded on the captured checkpoint. * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; /** * Secures the current low-water mark until the transaction identified by {@code id} completes. * * @param id * @throws HyracksDataException */ void secure(TxnId id) throws HyracksDataException; /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ void completed(TxnId id); }
response: package com.android.internal.telephony; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.BroadcastReceiver; import com.android.internal.telephony.CallForwardInfo; import com.android.internal.telephony.gsm.CommandException; import com.android.internal.telephony.gsm.NetworkInfo; import com.android.internal.telephony.gsm.PDPContextState; import com.android.internal.telephony.IccUtils; import com.android.internal.telephony.gsm.SmsResponse; import com.android.internal.telephony.gsm.SuppServiceNotification; import android.os.Parcel; import java.io.IOException; import android.os.Message; import android.os.Handler; import android.net.LocalSocketAddress; import android.net.LocalSocket; import com.android.internal.os.HandlerThread; import android.os.HandlerInterface; import java.util.ArrayList; import java.util.Collections; import java.io.InputStream; import android.telephony.PhoneNumberUtils; import android.telephony.gsm.SmsManager; public class PhoneSubInfo { private Phone mPhone; private Context mContext; public PhoneSubInfo(Phone phone) { mPhone = phone; mContext = phone.getContext(); } } void doSharpCheckpoint() throws HyracksDataException; long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void secure(TxnId id) throws HyracksDataException; void completed(TxnId id);

sample: 1167
buggy_code:  * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; /** * Secures the current low-water mark until the transaction identified by {@code id} completes. * * @param id * @throws HyracksDataException */ void secure(TxnId id) throws HyracksDataException; /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ <|startfocus|> <|endfocus|> void completed(TxnId id); } 
code_review:  remove 
target code: * @throws HyracksDataException */ long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; /** * Secures the current low-water mark until the transaction identified by {@code id} completes. * * @param id * @throws HyracksDataException */ void secure(TxnId id) throws HyracksDataException; /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ void completed(TxnId id); }
response: long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException; void secure(TxnId id) throws HyracksDataException; void completed(TxnId id);

sample: 1168
buggy_code:  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.transaction.management.service.recovery; import java.io.BufferedWriter; import java.io.File; import java.io.FilenameFilter; import java.io.IOException; import java.io.OutputStream; import java.nio.channels.ClosedByInterruptException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; <|startfocus|> import java.util.HashMap; <|endfocus|> import java.util.List; import java.util.Map; import org.apache.asterix.common.exceptions.ACIDException; import org.apache.asterix.common.transactions.Checkpoint; import org.apache.asterix.common.transactions.CheckpointProperties; import org.apache.asterix.common.transactions.ICheckpointManager; import org.apache.asterix.common.transactions.ILogManager; import org.apache.asterix.common.transactions.ITransactionManager; import org.apache.asterix.common.transactions.ITransactionSubsystem; import org.apache.asterix.common.transactions.TxnId; import org.apache.asterix.common.utils.StorageConstants; import org.apache.hyracks.api.exceptions.HyracksDataException;
code_review:  revert? 
target code: * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.transaction.management.service.recovery; import java.io.BufferedWriter; import java.io.File; import java.io.FilenameFilter; import java.io.IOException; import java.io.OutputStream; import java.nio.channels.ClosedByInterruptException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.Map; import org.apache.asterix.common.exceptions.ACIDException; import org.apache.asterix.common.transactions.Checkpoint; import org.apache.asterix.common.transactions.CheckpointProperties; import org.apache.asterix.common.transactions.ICheckpointManager; import org.apache.asterix.common.transactions.ILogManager; import org.apache.asterix.common.transactions.ITransactionManager; import org.apache.asterix.common.transactions.ITransactionSubsystem; import org.apache.asterix.common.transactions.TxnId; import org.apache.asterix.common.utils.StorageConstants; import org.apache.hyracks.api.exceptions.HyracksDataException;
response: package org.apache.asterix.transaction.management.service.recovery; import java.io.BufferedWriter; import java.io.File; import java.io.FilenameFilter; import java.io.IOException; import java.io.OutputStream; import java.nio.channels.ClosedByInterruptException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import org.apache.asterix.common.exceptions.ACIDException; import org.apache.asterix.common.transactions.Checkpoint; import org.apache.asterix.common.transactions.CheckpointProperties; import org.apache.asterix.common.transactions.ICheckpointManager; import org.apache.asterix.common.transactions.ILogManager; import org.apache.asterix.common.transactions.ITransactionManager; import org.apache.asterix.common.transactions.ITransactionSubsystem; import org.apache.asterix.common.transactions.TxnId; import org.apache.asterix.common.utils.StorageConstants; import org.apache.hyracks.api.exceptions.HyracksDataException; public class RecoveryService { // TODO: Add code here }

sample: 1169
buggy_code:  * log files that end with LSN < {@code checkpointTargetLSN} are deleted. */ @Override public synchronized long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException { LOGGER.info("Attemping soft checkpoint..."); final long minFirstLSN = txnSubsystem.getRecoveryManager().getMinFirstLSN(); final long minSecuredLSN = getMinSecuredLSN(); <|startfocus|> if (minSecuredLSN != -1 && minFirstLSN >= getMinSecuredLSN()) { return minFirstLSN; <|endfocus|> } boolean checkpointSucceeded = minFirstLSN >= checkpointTargetLSN; if (!checkpointSucceeded) { // Flush datasets with indexes behind target checkpoint LSN IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() {
code_review:  you shouldn't return this here since no checkpoint was actually captured at this lsn. Just check with the target before checking the current minFirstLSN: final long minSecuredLsn = getMinSecuredLsn(); if (checkpointTargetLSN >= minSecuredLsn) { return minSecuredLsn; } 
target code: * log files that end with LSN < {@code checkpointTargetLSN} are deleted. */ @Override public synchronized long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException { LOGGER.info("Attemping soft checkpoint..."); final long minFirstLSN = txnSubsystem.getRecoveryManager().getMinFirstLSN(); final long minSecuredLSN = getMinSecuredLSN(); if (minSecuredLSN != NO_SECURED_LSN && minFirstLSN >= getMinSecuredLSN()) { return minSecuredLSN; } boolean checkpointSucceeded = minFirstLSN >= checkpointTargetLSN; if (!checkpointSucceeded) { // Flush datasets with indexes behind target checkpoint LSN IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() {
response: @Override public synchronized long tryCheckpoint(long checkpointTargetLSN) throws HyracksDataException { LOGGER.info("Attempting soft checkpoint..."); final long minFirstLSN = txnSubsystem.getRecoveryManager().getMinFirstLSN(); final long minSecuredLSN = getMinSecuredLSN(); if (checkpointTargetLSN >= minSecuredLSN) { return minSecuredLSN; } boolean checkpointSucceeded = minFirstLSN >= checkpointTargetLSN; if (!checkpointSucceeded) { // Flush datasets with indexes behind target checkpoint LSN IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("Soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() { // implementation omitted }

sample: 1170
buggy_code:  IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() { <|startfocus|> return securedLSNs.isEmpty() ? -1 : Collections.min(securedLSNs.values()); <|endfocus|> } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) { securedLSNs.remove(id); } } 
code_review:  if you are going to use special values, define them as constants. I prefer that you replace this by the following and remove the special value: return securedTxn.values().stream().min(Long::compareTo).orElse(Long.MAX_VALUE); 
target code: IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); } capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; } private synchronized long getMinSecuredLSN() { return securedLSNs.isEmpty() ? NO_SECURED_LSN : Collections.min(securedLSNs.values()); } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) { securedLSNs.remove(id); } }
response: IDatasetLifecycleManager datasetLifecycleManager = txnSubsystem.getApplicationContext().getDatasetLifecycleManager(); datasetLifecycleManager.scheduleAsyncFlushForLaggingDatasets(checkpointTargetLSN); capture(minFirstLSN, false); if (checkpointSucceeded) { txnSubsystem.getLogManager().deleteOldLogFiles(minFirstLSN); LOGGER.info(String.format("soft checkpoint succeeded at LSN(%s)", minFirstLSN)); } return minFirstLSN; private synchronized long getMinSecuredLSN() { return securedLSNs.isEmpty() ? -1 : Collections.min(securedLSNs.values()); } @Override public synchronized void secure(TxnId id) throws HyracksDataException { securedLSNs.put(id, txnSubsystem.getRecoveryManager().getMinFirstLSN()); } @Override public synchronized void completed(TxnId id) { securedLSNs.remove(id); }

sample: 1171
buggy_code:  public void run() { Thread ct = Thread.currentThread(); <|startfocus|> String threadName = ct.getName(); <|endfocus|> // Calls synchronized addPendingThread(..) to make sure that in the abort() method, // the thread is not escaped from interruption. if (!addPendingThread(ct)) { exceptions.add(new InterruptedException("Task " + getTaskAttemptId() + " was aborted!")); ExceptionUtils.setNodeIds(exceptions, ncs.getId()); ncs.getWorkQueue().schedule(new NotifyTaskFailureWork(ncs, this, exceptions)); return; } try { ct.setName(displayName + ":" + taskAttemptId + ":" + 0); try { operator.initialize(); if (collectors.length > 0) { final Semaphore sem = new Semaphore(collectors.length - 1); for (int i = 1; i < collectors.length; ++i) { final IPartitionCollector collector = collectors[i]; final IFrameWriter writer = operator.getInputFrameWriter(i); sem.acquire(); final int cIdx = i; executorService.execute(new Runnable() { @Override
code_review:  MAJOR SonarQube violation: The return type of this method should be an interface such as "List" rather than the implementation "ArrayList". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 
target code: public void run() { Thread ct = Thread.currentThread(); String threadName = ct.getName(); ct.setName(displayName + ":" + taskAttemptId + ":" + 0); // Calls synchronized addPendingThread(..) to make sure that in the abort() method, // the thread is not escaped from interruption. if (!addPendingThread(ct)) { exceptions.add(new InterruptedException("Task " + getTaskAttemptId() + " was aborted!")); ExceptionUtils.setNodeIds(exceptions, ncs.getId()); ncs.getWorkQueue().schedule(new NotifyTaskFailureWork(ncs, this, exceptions)); return; } try { ct.setName(displayName + ":" + taskAttemptId + ":" + 0); try { operator.initialize(); if (collectors.length > 0) { final Semaphore sem = new Semaphore(collectors.length - 1); for (int i = 1; i < collectors.length; ++i) { final IPartitionCollector collector = collectors[i]; final IFrameWriter writer = operator.getInputFrameWriter(i); sem.acquire(); final int cIdx = i; executorService.execute(new Runnable() { @Override
response: public void run() { Thread ct = Thread.currentThread(); String threadName = ct.getName(); if (!addPendingThread(ct)) { exceptions.add(new InterruptedException("Task " + getTaskAttemptId() + " was aborted!")); ExceptionUtils.setNodeIds(exceptions, ncs.getId()); ncs.getWorkQueue().schedule(new NotifyTaskFailureWork(ncs, this, exceptions)); return; } try { ct.setName(displayName + ":" + taskAttemptId + ":" + 0); try { operator.initialize(); if (collectors.length > 0) { final Semaphore sem = new Semaphore(collectors.length - 1); for (int i = 1; i < collectors.length; ++i) { final IPartitionCollector collector = collectors[i]; final IFrameWriter writer = operator.getInputFrameWriter(i); sem.acquire(); final int cIdx = i; executorService.execute(new Runnable() { @Override public void run() { try { collector.open(); writer.open(); while (collector.hasNext()) { writer.nextFrame(collector.nextFrame()); } } catch (Exception e) { exceptions.add(e); } finally { writer.close(); collector.close(); sem.release(); } } }); } } operator.start(); } catch (Exception e) { exceptions.add(e); } finally { operator.close(); } } catch (Exception e) { exceptions.add(e); } finally { ct.setName(threadName); removePendingThread(ct); } }

sample: 1172
buggy_code:  int tzCount = tzIds.length; TIMEZONE_IDS = new byte[tzCount][]; TIMEZONE_OFFSETS = new int[tzCount]; for (int i = 0; i < tzCount; i++) { TIMEZONE_IDS[i] = encode(tzIds[i]); } Arrays.sort(TIMEZONE_IDS, byteArrayComparator); for (int i = 0; i < tzCount; i++) { <|startfocus|> String tzId; try { tzId = new String(TIMEZONE_IDS[i], ENCODING); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(ENCODING, e); } TIMEZONE_OFFSETS[i] = TimeZone.getTimeZone(tzId).getRawOffset(); <|endfocus|> } } private static final DateTimeFormatUtils INSTANCE = new DateTimeFormatUtils(); public static DateTimeFormatUtils getInstance() { return INSTANCE; } private DateTimeFormatUtils() { } private int parseFormatField(byte[] format, int formatStart, int formatLength, int formatPointer, char formatChar, int maxAllowedFormatCharCopied) { int formatCharCopies = 0; formatPointer++; formatCharCopies++;
code_review:  why not use Charset here and avoid the lookup? 
target code: int tzCount = tzIds.length; TIMEZONE_IDS = new byte[tzCount][]; TIMEZONE_OFFSETS = new int[tzCount]; for (int i = 0; i < tzCount; i++) { TIMEZONE_IDS[i] = encode(tzIds[i]); } Arrays.sort(TIMEZONE_IDS, byteArrayComparator); for (int i = 0; i < tzCount; i++) { TIMEZONE_OFFSETS[i] = TimeZone.getTimeZone(new String(TIMEZONE_IDS[i], ENCODING)).getRawOffset(); } } private static final DateTimeFormatUtils INSTANCE = new DateTimeFormatUtils(); public static DateTimeFormatUtils getInstance() { return INSTANCE; } private DateTimeFormatUtils() { } private int parseFormatField(byte[] format, int formatStart, int formatLength, int formatPointer, char formatChar, int maxAllowedFormatCharCopied) { int formatCharCopies = 0; formatPointer++; formatCharCopies++;
response: import java.nio.charset.Charset; import java.util.Arrays; import java.util.TimeZone; public class DateTimeFormatUtils { private static final byte[][] TIMEZONE_IDS; private static final int[] TIMEZONE_OFFSETS; private static final Charset ENCODING = Charset.forName("UTF-8"); static { String[] tzIds = TimeZone.getAvailableIDs(); int tzCount = tzIds.length; TIMEZONE_IDS = new byte[tzCount][]; TIMEZONE_OFFSETS = new int[tzCount]; for (int i = 0; i < tzCount; i++) { TIMEZONE_IDS[i] = encode(tzIds[i]); } Arrays.sort(TIMEZONE_IDS, byteArrayComparator); for (int i = 0; i < tzCount; i++) { String tzId; try { tzId = new String(TIMEZONE_IDS[i], ENCODING); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(ENCODING, e); } TIMEZONE_OFFSETS[i] = TimeZone.getTimeZone(tzId).getRawOffset(); } } private static byte[] encode(String tzId) { // implementation of encode method } private static int byteArrayComparator(byte[] a, byte[] b) { // implementation of byteArrayComparator method } private DateTimeFormatUtils() { } public static DateTimeFormatUtils getInstance() { return INSTANCE; } private int parseFormatField(byte[] format, int formatStart, int formatLength, int formatPointer, char formatChar, int maxAllowedFormatCharCopied) { int formatCharCopies = 0; formatPointer++; formatCharCopies++; // implementation of parseFormatField method } }

sample: 1173
buggy_code:  && data[dataStart + timezoneEndField] <= 'Z') || data[dataStart + timezoneEndField] == '/' || data[dataStart + timezoneEndField] == '_')) { timezoneEndField++; } int searchIdx = binaryTimezoneIDSearch(data, dataStart + dataStringPointer, timezoneEndField - dataStringPointer); if (searchIdx >= 0) { timezone = TIMEZONE_OFFSETS[searchIdx]; } else { if (raiseParseDataError) { <|startfocus|> throw new AsterixTemporalTypeParseException("Unexpected timezone string: " + decode(data, dataStart + dataStringPointer, dataStart + timezoneEndField)); <|endfocus|> } else { return false; } } dataStringPointer = timezoneEndField; } timezoneExists = true; break; case AMPM: if (dataStringPointer + 1 < dataLength) { if (hour > 12 || hour <= 0) { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException( "Hour " + hour + " cannot be a time for AM/PM.");
code_review:  MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 
target code: && data[dataStart + timezoneEndField] <= 'Z') || data[dataStart + timezoneEndField] == '/' || data[dataStart + timezoneEndField] == '_')) { timezoneEndField++; } int searchIdx = binaryTimezoneIDSearch(data, dataStart + dataStringPointer, timezoneEndField - dataStringPointer); if (searchIdx >= 0) { timezone = TIMEZONE_OFFSETS[searchIdx]; } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Unexpected timezone string: " + new String( data, dataStart + dataStringPointer, dataStart + timezoneEndField, ENCODING)); } else { return false; } } dataStringPointer = timezoneEndField; } timezoneExists = true; break; case AMPM: if (dataStringPointer + 1 < dataLength) { if (hour > 12 || hour <= 0) { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException( "Hour " + hour + " cannot be a time for AM/PM.");
response: && data[dataStart + timezoneEndField] <= 'Z') || data[dataStart + timezoneEndField] == '/' || data[dataStart + timezoneEndField] == '_') { timezoneEndField++; } int searchIdx = binaryTimezoneIDSearch(data, dataStart + dataStringPointer, timezoneEndField - dataStringPointer); if (searchIdx >= 0) { timezone = TIMEZONE_OFFSETS[searchIdx]; } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Unexpected timezone string: " + decode(data, dataStart + dataStringPointer, dataStart + timezoneEndField)); } else { return false; } } dataStringPointer = timezoneEndField; timezoneExists = true; break; case AMPM: if (dataStringPointer + 1 < dataLength) { if (hour > 12 || hour <= 0) { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Hour " + hour + " cannot be a time for AM/PM."); } else { return false; } } char ampm = data[dataStart + dataStringPointer]; if (ampm == 'A' || ampm == 'a') { if (hour == 12) { hour = 0; } } else if (ampm == 'P' || ampm == 'p') { if (hour < 12) { hour += 12; } } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Invalid AM/PM indicator: " + ampm); } else { return false; } } dataStringPointer++; break; }

sample: 1174
buggy_code:  } else { return false; } } if (byteArrayEqualToString(data, dataStart + dataStringPointer, 2, AM_BYTEARRAY)) { // do nothing } else if (byteArrayEqualToString(data, dataStart + dataStringPointer, 2, PM_BYTEARRAY)) { hour += 12; if (hour == 24) { hour = 0; } } else { if (raiseParseDataError) { <|startfocus|> throw new AsterixTemporalTypeParseException( "Unexpected string for AM/PM marker " + decode(data, dataStart + dataStringPointer, dataStart + dataStringPointer + 2)); <|endfocus|> } else { return false; } } dataStringPointer += 2; } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Cannot find valid AM/PM marker."); } else { return false; } } break; case SKIPPER: // just skip all continuous character and numbers
code_review:  MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 
target code: } else { return false; } } if (byteArrayEqualToString(data, dataStart + dataStringPointer, 2, AM_BYTEARRAY)) { // do nothing } else if (byteArrayEqualToString(data, dataStart + dataStringPointer, 2, PM_BYTEARRAY)) { hour += 12; if (hour == 24) { hour = 0; } } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Unexpected string for AM/PM marker " + new String(data, dataStart + dataStringPointer, dataStart + dataStringPointer + 2, ENCODING)); } else { return false; } } dataStringPointer += 2; } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Cannot find valid AM/PM marker."); } else { return false; } } break; case SKIPPER: // just skip all continuous character and numbers
response: } else { return false; } if (byteArrayEqualToString(data, dataStart + dataStringPointer, 2, AM_BYTEARRAY)) { // do nothing } else if (byteArrayEqualToString(data, dataStart + dataStringPointer, 2, PM_BYTEARRAY)) { hour += 12; if (hour == 24) { hour = 0; } } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Unexpected string for AM/PM marker " + decode(data, dataStart + dataStringPointer, dataStart + dataStringPointer + 2)); } else { return false; } } dataStringPointer += 2; } else { if (raiseParseDataError) { throw new AsterixTemporalTypeParseException("Cannot find valid AM/PM marker."); } else { return false; } } break; case SKIPPER: // just skip all continuous character and numbers

sample: 1175
buggy_code:  public long getWrites() { try { List<String> rows = getInfo(); long writes = extractRow(rows, 5); long cancelledWrites = extractRow(rows, 6); <|startfocus|> return (writes - cancelledWrites); <|endfocus|> } catch (Exception e) { LOGGER.log(failureCount++ > 0 ? Level.DEBUG : Level.WARN, "Failure getting writes", e); return IOCounterDefault.IO_COUNTER_UNAVAILABLE; }
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public long getWrites() { try { List<String> rows = getInfo(); long writes = extractRow(rows, 5); long cancelledWrites = extractRow(rows, 6); return writes - cancelledWrites; } catch (Exception e) { LOGGER.log(failureCount++ > 0 ? Level.DEBUG : Level.WARN, "Failure getting writes", e); return IOCounterDefault.IO_COUNTER_UNAVAILABLE; }
response: public long getWrites() { try { List<String> rows = getInfo(); long writes = extractRow(rows, 5); long cancelledWrites = extractRow(rows, 6); return writes - cancelledWrites; } catch (Exception e) { LOGGER.log(failureCount++ > 0 ? Level.DEBUG : Level.WARN, "Failure getting writes", e); return IOCounterDefault.IO_COUNTER_UNAVAILABLE; } }

sample: 1176
buggy_code:  "Input stream given to OnDiskInvertedIndex bulk load is not sorted."); } } // Remember last tuple by creating a copy. // TODO: This portion can be optimized by only copying the token when it changes, and using the last appended inverted-list element as a reference. lastTupleBuilder.reset(); for (int i = 0; i < tuple.getFieldCount(); i++) { lastTupleBuilder.addField(tuple.getFieldData(i), tuple.getFieldStart(i), tuple.getFieldLength(i)); <|startfocus|> } <|endfocus|> } @Override public void end() throws HyracksDataException { // The last tuple builder is empty if add() was never called. if (lastTupleBuilder.getSize() != 0) { createAndInsertBTreeTuple(); } btreeBulkloader.end(); if (currentPage != null) { queue.put(currentPage); } invListsMaxPageId = currentPageId; bufferCache.finishQueue(); } @Override public void abort() throws HyracksDataException { if (btreeBulkloader != null) { btreeBulkloader.abort(); } } } @Override
code_review:  MAJOR SonarQube violation: Merge this if statement with the enclosing one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1066 
target code: "Input stream given to OnDiskInvertedIndex bulk load is not sorted."); } } // Remember last tuple by creating a copy. // TODO: This portion can be optimized by only copying the token when it changes, and using the last appended inverted-list element as a reference. lastTupleBuilder.reset(); for (int i = 0; i < tuple.getFieldCount(); i++) { lastTupleBuilder.addField(tuple.getFieldData(i), tuple.getFieldStart(i), tuple.getFieldLength(i)); } lastTuple.reset(lastTupleBuilder.getFieldEndOffsets(), lastTupleBuilder.getByteArray()); } @Override public void end() throws HyracksDataException { // The last tuple builder is empty if add() was never called. if (lastTupleBuilder.getSize() != 0) { createAndInsertBTreeTuple(); } btreeBulkloader.end(); if (currentPage != null) { queue.put(currentPage); } invListsMaxPageId = currentPageId; bufferCache.finishQueue(); } @Override public void abort() throws HyracksDataException { if (btreeBulkloader != null) { btreeBulkloader.abort(); } } } @Override
response: "Input stream given to OnDiskInvertedIndex bulk load is not sorted."); } } // Remember last tuple by creating a copy. // TODO: This portion can be optimized by only copying the token when it changes, and using the last appended inverted-list element as a reference. lastTupleBuilder.reset(); for (int i = 0; i < tuple.getFieldCount(); i++) { lastTupleBuilder.addField(tuple.getFieldData(i), tuple.getFieldStart(i), tuple.getFieldLength(i)); } } @Override public void end() throws HyracksDataException { // The last tuple builder is empty if add() was never called. if (lastTupleBuilder.getSize() != 0) { createAndInsertBTreeTuple(); } btreeBulkloader.end(); if (currentPage != null) { queue.put(currentPage); } invListsMaxPageId = currentPageId; bufferCache.finishQueue(); } @Override public void abort() throws HyracksDataException { if (btreeBulkloader != null) { btreeBulkloader.abort(); } } } @Override

sample: 1177
buggy_code:  lastTupleBuilder.reset(); for (int i = 0; i < tuple.getFieldCount(); i++) { lastTupleBuilder.addField(tuple.getFieldData(i), tuple.getFieldStart(i), tuple.getFieldLength(i)); } } @Override public void end() throws HyracksDataException { // The last tuple builder is empty if add() was never called. if (lastTupleBuilder.getSize() != 0) { createAndInsertBTreeTuple(); <|startfocus|> } <|endfocus|> btreeBulkloader.end(); if (currentPage != null) { queue.put(currentPage); } invListsMaxPageId = currentPageId; bufferCache.finishQueue(); } @Override public void abort() throws HyracksDataException { if (btreeBulkloader != null) { btreeBulkloader.abort(); } } } @Override public IBufferCache getBufferCache() { return bufferCache; } public int getInvListsFileId() { return fileId; } public int getInvListsMaxPageId() { return invListsMaxPageId; } @Override public IBinaryComparatorFactory[] getInvListCmpFactories() {
code_review:  MAJOR SonarQube violation: Split this 163 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: lastTupleBuilder.reset(); for (int i = 0; i < tuple.getFieldCount(); i++) { lastTupleBuilder.addField(tuple.getFieldData(i), tuple.getFieldStart(i), tuple.getFieldLength(i)); } } @Override public void end() throws HyracksDataException { // The last tuple builder is empty if add() was never called. if (lastTupleBuilder.getSize() != 0) { createAndInsertBTreeTuple(); } btreeBulkloader.end(); if (currentPage != null) { queue.put(currentPage); } invListsMaxPageId = currentPageId; bufferCache.finishQueue(); } @Override public void abort() throws HyracksDataException { if (btreeBulkloader != null) { btreeBulkloader.abort(); } } } @Override public IBufferCache getBufferCache() { return bufferCache; } public int getInvListsFileId() { return fileId; } public int getInvListsMaxPageId() { return invListsMaxPageId; } @Override public IBinaryComparatorFactory[] getInvListCmpFactories() {
response: IRecordDescriptorProvider recordDescProvider, final int partition, int nPartitions) { final RecordDescriptor rd0 = recordDescProvider.getInputRecordDescriptor(hpaId, 0); final RecordDescriptor rd1 = recordDescProvider.getInputRecordDescriptor(getActivityId(), 0); final IBinaryComparator[] comparators = new IBinaryComparator[comparatorFactories.length]; for (int i = 0; i < comparatorFactories.length; ++i) { comparators[i] = comparatorFactories[i].createBinaryComparator(); } final IMissingWriter[] nullWriters1 = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories.length] : null; if (isLeftOuter) { for (int i = 0; i < nonMatchWriterFactories.length; i++) { nullWriters1[i] = nonMatchWriterFactories[i].createMissingWriter(); } } final IPredicateEvaluator predEvaluator = (predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator()); IOperatorNodePushable op = new AbstractUnaryInputSinkOperatorNodePushable() { private HashBuildTaskState state; @Override public void open() throws HyracksDataException { ITuplePartitionComputer hpc0 = new FieldHashPartitionComputerFactory(keys0, hashFunctionFactories) // ... } // ... }; // ... } long fileSize = fileChannel.size(); if (LSMComponentJob != null) { ILSMComponent diskComponent = LSMComponentJob.getLSMIndexOperationContext().getComponentsToBeReplicated().get(0); long LSNByteOffset = AsterixLSMIndexUtil.getComponentFileLSNOffset((AbstractLSMIndex) LSMComponentJob.getLSMIndex(), diskComponent, filePath); asterixFileProperties.initialize(filePath, fileSize, nodeId, isLSMComponentFile, LSNByteOffset, remainingFiles == 0); } else { asterixFileProperties.initialize(filePath, fileSize, nodeId, isLSMComponentFile, IMetaDataPageManager.INVALID_LSN_OFFSET, remainingFiles == 0); } requestBuffer = ReplicationProtocol.writeFileReplicationRequest(requestBuffer, asterixFileProperties, ReplicationRequestType.REPLICATE_FILE); Iterator<Map.Entry<String, SocketChannel>> iterator = replicasSockets.entrySet().iterator(); while (iterator.hasNext()) {

sample: 1178
buggy_code:  } public class OnDiskInvertedIndexAccessor implements IInvertedIndexAccessor { private final OnDiskInvertedIndex index; private final IInvertedIndexSearcher searcher; private final IIndexOperationContext opCtx = new OnDiskInvertedIndexOpContext(btree); public OnDiskInvertedIndexAccessor(OnDiskInvertedIndex index) throws HyracksDataException { this.index = index; this.searcher = new TOccurrenceSearcher(ctx, index); } // Let subclasses initialize. protected OnDiskInvertedIndexAccessor(OnDiskInvertedIndex index, IInvertedIndexSearcher searcher) { this.index = index; this.searcher = searcher; } @Override <|startfocus|> public IIndexCursor createSearchCursor(boolean exclusive) { return new OnDiskInvertedIndexSearchCursor(searcher, index.getInvListTypeTraits().length); <|endfocus|> } @Override public void search(IIndexCursor cursor, ISearchPredicate searchPred) throws HyracksDataException { searcher.search((OnDiskInvertedIndexSearchCursor) cursor, (InvertedIndexSearchPredicate) searchPred, opCtx); } @Override public IInvertedListCursor createInvertedListCursor() { return index.createInvertedListCursor(); } @Override public void openInvertedListCursor(IInvertedListCursor listCursor, ITupleReference searchKey) throws HyracksDataException {
code_review:  MAJOR SonarQube violation: Split this 163 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: } public class OnDiskInvertedIndexAccessor implements IInvertedIndexAccessor { private final OnDiskInvertedIndex index; private final IInvertedIndexSearcher searcher; private final IIndexOperationContext opCtx = new OnDiskInvertedIndexOpContext(btree); public OnDiskInvertedIndexAccessor(OnDiskInvertedIndex index) throws HyracksDataException { this.index = index; this.searcher = new TOccurrenceSearcher(ctx, index); } // Let subclasses initialize. protected OnDiskInvertedIndexAccessor(OnDiskInvertedIndex index, IInvertedIndexSearcher searcher) { this.index = index; this.searcher = searcher; } @Override public IIndexCursor createSearchCursor(boolean exclusive) throws HyracksDataException { if (searcher == null) { searcher = new TOccurrenceSearcher(index, ctx); } return new OnDiskInvertedIndexSearchCursor(searcher); } @Override public void search(IIndexCursor cursor, ISearchPredicate searchPred) throws HyracksDataException { searcher.search((OnDiskInvertedIndexSearchCursor) cursor, (InvertedIndexSearchPredicate) searchPred, opCtx); } @Override public IInvertedListCursor createInvertedListCursor() { return index.createInvertedListCursor(); } @Override public void openInvertedListCursor(IInvertedListCursor listCursor, ITupleReference searchKey) throws HyracksDataException {
response: public class OnDiskInvertedIndexAccessor implements IInvertedIndexAccessor { private final OnDiskInvertedIndex index; private final IInvertedIndexSearcher searcher; private final IIndexOperationContext opCtx = new OnDiskInvertedIndexOpContext(btree); public OnDiskInvertedIndexAccessor(OnDiskInvertedIndex index) throws HyracksDataException { this.index = index; this.searcher = new TOccurrenceSearcher(ctx, index); } protected OnDiskInvertedIndexAccessor(OnDiskInvertedIndex index, IInvertedIndexSearcher searcher) { this.index = index; this.searcher = searcher; } @Override public IIndexCursor createSearchCursor(boolean exclusive) { return new OnDiskInvertedIndexSearchCursor(searcher, index.getInvListTypeTraits().length); } @Override public void search(IIndexCursor cursor, ISearchPredicate searchPred) throws HyracksDataException { searcher.search((OnDiskInvertedIndexSearchCursor) cursor, (InvertedIndexSearchPredicate) searchPred, opCtx); } @Override public IInvertedListCursor createInvertedListCursor() { return index.createInvertedListCursor(); } @Override public void openInvertedListCursor(IInvertedListCursor listCursor, ITupleReference searchKey) throws HyracksDataException { index.openInvertedListCursor(listCursor, searchKey); } }

sample: 1179
buggy_code:  public void setKeyTuple(ITupleReference key) { <|startfocus|> newToken = (this.keyTuple == null); <|endfocus|> this.keyTuple = key;
code_review:  MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck 
target code: public void setKeyTuple(ITupleReference key) { newToken = this.keyTuple == null; this.keyTuple = key;
response: public void setKeyTuple(ITupleReference key) { boolean newToken = this.keyTuple == null; this.keyTuple = key; }

sample: 1180
buggy_code:  for (int i = 0; i < end; i++) { if (bloomFilters[i] != null && !bloomFilters[i].contains(keysOnlyTuple, hashes)) { continue; } deletedKeysBTreeAccessors.get(i).search(deletedKeysBTreeCursors[i], keySearchPred); try { if (deletedKeysBTreeCursors[i].hasNext()) { return true; } } finally { deletedKeysBTreeCursors[i].close(); } } return false; } @Override public void doClose() throws HyracksDataException { <|startfocus|> <<<<<<< HEAD <|endfocus|> try { super.doClose(); } finally { if (deletedKeysBTreeCursors != null) { for (int i = 0; i < deletedKeysBTreeCursors.length; i++) { deletedKeysBTreeCursors[i].close(); } } } ======= if (deletedKeysBTreeCursors != null) { for (int i = 0; i < deletedKeysBTreeCursors.length; i++) { deletedKeysBTreeCursors[i].close(); } } super.doClose(); >>>>>>> initial commit } @Override public void doDestroy() throws HyracksDataException {
code_review:  what's the rationale behind changing this method? 
target code: for (int i = 0; i < end; i++) { if (bloomFilters[i] != null && !bloomFilters[i].contains(keysOnlyTuple, hashes)) { continue; } deletedKeysBTreeAccessors.get(i).search(deletedKeysBTreeCursors[i], keySearchPred); try { if (deletedKeysBTreeCursors[i].hasNext()) { return true; } } finally { deletedKeysBTreeCursors[i].close(); } } return false; } @Override public void doClose() throws HyracksDataException { try { super.doClose(); } finally { if (deletedKeysBTreeCursors != null) { for (int i = 0; i < deletedKeysBTreeCursors.length; i++) { deletedKeysBTreeCursors[i].close(); } } } ======= if (deletedKeysBTreeCursors != null) { for (int i = 0; i < deletedKeysBTreeCursors.length; i++) { deletedKeysBTreeCursors[i].close(); } } super.doClose(); >>>>>>> initial commit } @Override public void doDestroy() throws HyracksDataException {
response: for (int i = 0; i < end; i++) { if (bloomFilters[i] != null && !bloomFilters[i].contains(keysOnlyTuple, hashes)) { continue; } deletedKeysBTreeAccessors.get(i).search(deletedKeysBTreeCursors[i], keySearchPred); try { if (deletedKeysBTreeCursors[i].hasNext()) { return true; } } finally { deletedKeysBTreeCursors[i].close(); } } return false; } @Override public void doClose() throws HyracksDataException { try { super.doClose(); } finally { if (deletedKeysBTreeCursors != null) { for (int i = 0; i < deletedKeysBTreeCursors.length; i++) { deletedKeysBTreeCursors[i].close(); } } } } @Override public void doDestroy() throws HyracksDataException { if (deletedKeysBTreeCursors != null) { for (int i = 0; i < deletedKeysBTreeCursors.length; i++) { deletedKeysBTreeCursors[i].close(); } } super.doClose(); }

sample: 1181
buggy_code:  IIndex invIndex = testCtx.getIndex(); if (LOGGER.isInfoEnabled()) { LOGGER.info("Validating index: " + invIndex); } // Validate index and compare against expected index. invIndex.validate(); if (invIndexType == InvertedIndexType.INMEMORY || invIndexType == InvertedIndexType.ONDISK) { // This comparison method exercises different features of these types of inverted indexes. LSMInvertedIndexTestUtils.compareActualAndExpectedIndexes(testCtx); } <|startfocus|> //LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesRangeSearch(testCtx); <|endfocus|> if (invIndexType == InvertedIndexType.LSM || invIndexType == InvertedIndexType.PARTITIONED_LSM) { LSMInvertedIndex lsmIndex = (LSMInvertedIndex) invIndex; if (!lsmIndex.isMemoryComponentsAllocated() || lsmIndex.isCurrentMutableComponentEmpty()) { LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesMergeSearch(testCtx); } } } /** * Runs a workload of queries using different search modifiers, and verifies the correctness of the results. */ protected void runTinySearchWorkload(LSMInvertedIndexTestContext testCtx, TupleGenerator tupleGen) throws IOException { for (IInvertedIndexSearchModifier searchModifier : TEST_SEARCH_MODIFIERS) {
code_review:  Remove this comment? 
target code: IIndex invIndex = testCtx.getIndex(); if (LOGGER.isInfoEnabled()) { LOGGER.info("Validating index: " + invIndex); } // Validate index and compare against expected index. invIndex.validate(); if (invIndexType == InvertedIndexType.INMEMORY || invIndexType == InvertedIndexType.ONDISK) { // This comparison method exercises different features of these types of inverted indexes. LSMInvertedIndexTestUtils.compareActualAndExpectedIndexes(testCtx); } LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesRangeSearch(testCtx); if (invIndexType == InvertedIndexType.LSM || invIndexType == InvertedIndexType.PARTITIONED_LSM) { LSMInvertedIndex lsmIndex = (LSMInvertedIndex) invIndex; if (!lsmIndex.isMemoryComponentsAllocated() || lsmIndex.isCurrentMutableComponentEmpty()) { LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesMergeSearch(testCtx); } } } /** * Runs a workload of queries using different search modifiers, and verifies the correctness of the results. */ protected void runTinySearchWorkload(LSMInvertedIndexTestContext testCtx, TupleGenerator tupleGen) throws IOException { for (IInvertedIndexSearchModifier searchModifier : TEST_SEARCH_MODIFIERS) {
response: import java.util.StringTokenizer; import android.content.Context; import android.hardware.Sensor; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.os.Build; import android.os.Bundle; import android.os.Message; import android.os.PowerManager; import android.provider.Settings; import android.provider.Settings.Global; import android.provider.Settings.SettingNotFoundException; import android.util.Log; import android.view.View; import android.widget.TextView; import com.android.cts.verifier.sensors.BaseSensorTestActivity.SensorTestResult; public class PowerTestHostLink { public class PowerTestHostLink { } } import java.util.StringTokenizer; import android.content.Context; import android.hardware.Sensor; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.os.Build; import android.os.Bundle; import android.os.Message; import android.os.PowerManager; import android.provider.Settings; import android.provider.Settings.Global; import android.provider.Settings.SettingNotFoundException; import android.util.Log; import android.view.View; import android.widget.TextView; import com.android.cts.verifier.sensors.BaseSensorTestActivity.SensorTestResult; public class PowerTestHostLink { public class PowerTestHostLink { } } IIndex invIndex = testCtx.getIndex(); if (LOGGER.isInfoEnabled()) { LOGGER.info("Validating index: " + invIndex); } // Validate index and compare against expected index. invIndex.validate(); if (invIndexType == InvertedIndexType.INMEMORY || invIndexType == InvertedIndexType.ONDISK) { // This comparison method exercises different features of these types of inverted indexes. LSMInvertedIndexTestUtils.compareActualAndExpectedIndexes(testCtx); } //LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesRangeSearch(testCtx); if (invIndexType == InvertedIndexType.LSM || invIndexType == InvertedIndexType.PARTITIONED_LSM) { LSMInvertedIndex lsmIndex = (LSMInvertedIndex) invIndex; if (!lsmIndex.isMemoryComponentsAllocated() || lsmIndex.isCurrentMutableComponentEmpty()) { LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesMergeSearch(testCtx); } } } protected void runTinySearchWorkload(LSMInvertedIndexTestContext testCtx, TupleGenerator tupleGen) throws IOException { for (IInverted

sample: 1182
buggy_code:  * @throws AlgebricksException */ public boolean isSubFieldNullable(List<String> subFieldName) throws AlgebricksException { IAType subRecordType = getFieldType(subFieldName.get(0)); boolean nullable = false; for (int i = 1; i < subFieldName.size(); i++) { if (subRecordType == null) { // open field is nullable return true; } if (subRecordType.getTypeTag().equals(ATypeTag.UNION)) { if (NonTaggedFormatUtil.isOptional(subRecordType)) { <|startfocus|> nullable = true; <|endfocus|> } subRecordType = ((AUnionType) subRecordType).getActualType(); if (subRecordType.getTypeTag() != ATypeTag.OBJECT) { throw new AsterixException( "Field accessor is not defined for values of type " + subRecordType.getTypeTag()); } } subRecordType = ((ARecordType) subRecordType).getFieldType(subFieldName.get(i)); } return nullable || subRecordType == null || NonTaggedFormatUtil.isOptional(subRecordType); } /**
code_review:  just return true? get rid of nullable variable? 
target code: * @throws AlgebricksException */ public boolean isSubFieldNullable(List<String> subFieldName) throws AlgebricksException { IAType subRecordType = getFieldType(subFieldName.get(0)); boolean nullable = false; for (int i = 1; i < subFieldName.size(); i++) { if (subRecordType == null) { // open field is nullable return true; } if (subRecordType.getTypeTag().equals(ATypeTag.UNION)) { if (NonTaggedFormatUtil.isOptional(subRecordType)) { return true; } subRecordType = ((AUnionType) subRecordType).getActualType(); if (subRecordType.getTypeTag() != ATypeTag.OBJECT) { throw new AsterixException( "Field accessor is not defined for values of type " + subRecordType.getTypeTag()); } } subRecordType = ((ARecordType) subRecordType).getFieldType(subFieldName.get(i)); } return nullable || subRecordType == null || NonTaggedFormatUtil.isOptional(subRecordType); } /**
response: public boolean isSubFieldNullable(List<String> subFieldName) throws AlgebricksException { IAType subRecordType = getFieldType(subFieldName.get(0)); for (int i = 1; i < subFieldName.size(); i++) { if (subRecordType == null) { return true; } if (subRecordType.getTypeTag().equals(ATypeTag.UNION)) { if (NonTaggedFormatUtil.isOptional(subRecordType)) { return true; } subRecordType = ((AUnionType) subRecordType).getActualType(); if (subRecordType.getTypeTag() != ATypeTag.OBJECT) { throw new AsterixException("Field accessor is not defined for values of type " + subRecordType.getTypeTag()); } } subRecordType = ((ARecordType) subRecordType).getFieldType(subFieldName.get(i)); } return subRecordType == null || NonTaggedFormatUtil.isOptional(subRecordType); }

sample: 1183
buggy_code:  boolean changed = changeRec(expr, arg); if (!checkArgs(expr) || !expr.isFunctional()) { return new Pair<>(changed, expr); } // Skip Constant Folding for the record-related functions. if (FUNC_ID_SET_THAT_SHOULD_NOT_BE_APPLIED.contains(expr.getFunctionIdentifier())) { return new Pair<>(false, null); } try { <|startfocus|> //Current List SerDe assumes a strongly typed list, so we do not constant fold the list constructors if they are not strongly typed <|endfocus|> if (expr.getFunctionIdentifier().equals(BuiltinFunctions.UNORDERED_LIST_CONSTRUCTOR) || expr.getFunctionIdentifier().equals(BuiltinFunctions.ORDERED_LIST_CONSTRUCTOR)) { AbstractCollectionType listType = (AbstractCollectionType) TypeCastUtils.getRequiredType(expr); if (listType != null && (listType.getItemType().getTypeTag() == ATypeTag.ANY || listType.getItemType() instanceof AbstractCollectionType)) { //case1: listType == null, could be a nested list inside a list<ANY> //case2: itemType = ANY //case3: itemType = a nested list
code_review:  MAJOR SonarQube violation: Split this 147 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 
target code: boolean changed = changeRec(expr, arg); if (!checkArgs(expr) || !expr.isFunctional()) { return new Pair<>(changed, expr); } // Skip Constant Folding for the record-related functions. if (FUNC_ID_SET_THAT_SHOULD_NOT_BE_APPLIED.contains(expr.getFunctionIdentifier())) { return new Pair<>(false, null); } try { // Current List SerDe assumes a strongly typed list, so we do not constant fold the list constructors // if they are not strongly typed if (expr.getFunctionIdentifier().equals(BuiltinFunctions.UNORDERED_LIST_CONSTRUCTOR) || expr.getFunctionIdentifier().equals(BuiltinFunctions.ORDERED_LIST_CONSTRUCTOR)) { AbstractCollectionType listType = (AbstractCollectionType) TypeCastUtils.getRequiredType(expr); if (listType != null && (listType.getItemType().getTypeTag() == ATypeTag.ANY || listType.getItemType() instanceof AbstractCollectionType)) { //case1: listType == null, could be a nested list inside a list<ANY> //case2: itemType = ANY //case3: itemType = a nested list
response: boolean changed = changeRec(expr, arg); if (!checkArgs(expr) || !expr.isFunctional()) { return new Pair<>(changed, expr); } // Skip Constant Folding for the record-related functions. if (FUNC_ID_SET_THAT_SHOULD_NOT_BE_APPLIED.contains(expr.getFunctionIdentifier())) { return new Pair<>(false, null); } try { if (expr.getFunctionIdentifier().equals(BuiltinFunctions.UNORDERED_LIST_CONSTRUCTOR) || expr.getFunctionIdentifier().equals(BuiltinFunctions.ORDERED_LIST_CONSTRUCTOR)) { AbstractCollectionType listType = (AbstractCollectionType) TypeCastUtils.getRequiredType(expr); if (listType != null && (listType.getItemType().getTypeTag() == ATypeTag.ANY || listType.getItemType() instanceof AbstractCollectionType)) { //case1: listType == null, could be a nested list inside a list<ANY> //case2: itemType = ANY //case3: itemType = a nested list

sample: 1184
buggy_code:  IScalarEvaluator eval = fact.createScalarEvaluator(null); eval.evaluate(null, p); Object t = _emptyTypeEnv.getType(expr); @SuppressWarnings("rawtypes") ISerializerDeserializer serde = jobGenCtx.getSerializerDeserializerProvider().getSerializerDeserializer(t); bbis.setByteBuffer(ByteBuffer.wrap(p.getByteArray(), p.getStartOffset(), p.getLength()), 0); IAObject o = (IAObject) serde.deserialize(dis); return new Pair<>(true, new ConstantExpression(new AsterixConstantValue(o))); <|startfocus|> } catch (HyracksDataException | AlgebricksException e) { <|endfocus|> return new Pair<>(false, null); } } @Override public Pair<Boolean, ILogicalExpression> visitAggregateFunctionCallExpression( AggregateFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); return new Pair<>(changed, expr); } @Override public Pair<Boolean, ILogicalExpression> visitStatefulFunctionCallExpression( StatefulFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); return new Pair<>(changed, expr); } @Override
code_review:  CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 
target code: IScalarEvaluator eval = fact.createScalarEvaluator(null); eval.evaluate(null, p); Object t = _emptyTypeEnv.getType(expr); @SuppressWarnings("rawtypes") ISerializerDeserializer serde = jobGenCtx.getSerializerDeserializerProvider().getSerializerDeserializer(t); bbis.setByteBuffer(ByteBuffer.wrap(p.getByteArray(), p.getStartOffset(), p.getLength()), 0); IAObject o = (IAObject) serde.deserialize(dis); return new Pair<>(true, new ConstantExpression(new AsterixConstantValue(o))); } catch (HyracksDataException | AlgebricksException e) { if (AlgebricksConfig.ALGEBRICKS_LOGGER.isDebugEnabled()) { AlgebricksConfig.ALGEBRICKS_LOGGER.debug("Exception caught at constant folding: " + e, e); } return new Pair<>(false, null); } } @Override public Pair<Boolean, ILogicalExpression> visitAggregateFunctionCallExpression( AggregateFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); return new Pair<>(changed, expr); } @Override public Pair<Boolean, ILogicalExpression> visitStatefulFunctionCallExpression( StatefulFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); return new Pair<>(changed, expr); } @Override
response: IScalarEvaluator eval = fact.createScalarEvaluator(null); eval.evaluate(null, p); Object t = _emptyTypeEnv.getType(expr); @SuppressWarnings("rawtypes") ISerializerDeserializer serde = jobGenCtx.getSerializerDeserializerProvider().getSerializerDeserializer(t); bbis.setByteBuffer(ByteBuffer.wrap(p.getByteArray(), p.getStartOffset(), p.getLength()), 0); IAObject o = null; try { o = (IAObject) serde.deserialize(dis); } catch (HyracksDataException | AlgebricksException e) { return new Pair<>(false, null); } return new Pair<>(true, new ConstantExpression(new AsterixConstantValue(o))); @Override public Pair<Boolean, ILogicalExpression> visitAggregateFunctionCallExpression(AggregateFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); return new Pair<>(changed, expr); } @Override public Pair<Boolean, ILogicalExpression> visitStatefulFunctionCallExpression(StatefulFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); return new Pair<>(changed, expr); }

sample: 1185
buggy_code:  empty-tuple-source -- |UNPARTITIONED| assign [$$29] <- [TRUE] -- |UNPARTITIONED| assign [$$26] <- [TRUE] -- |UNPARTITIONED| data-scan []<-[$$20, $$21, $$2] <- tpch:LineItems -- |UNPARTITIONED| empty-tuple-source -- |UNPARTITIONED| */ public class InlineSubplanInputForNestedTupleSourceRule implements IAlgebraicRewriteRule { @Override public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) <|startfocus|> throws AlgebricksException { <|endfocus|> if (context.checkIfInDontApplySet(this, opRef.getValue())) { return false; } Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> result = rewriteSubplanOperator(opRef, context); return result.first; } private Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> rewriteSubplanOperator( Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { AbstractLogicalOperator op = (AbstractLogicalOperator) opRef.getValue(); // Recursively traverses input operators as if the current operator before rewriting the current operator. Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> changedAndVarMap = traverseNonSubplanOperator(op, context);
code_review:  Why this was removed? the rule scans the whole plan starting from the root. why run rewritePre() on each operator? 
target code: empty-tuple-source -- |UNPARTITIONED| assign [$$29] <- [TRUE] -- |UNPARTITIONED| assign [$$26] <- [TRUE] -- |UNPARTITIONED| data-scan []<-[$$20, $$21, $$2] <- tpch:LineItems -- |UNPARTITIONED| empty-tuple-source -- |UNPARTITIONED| */ public class InlineSubplanInputForNestedTupleSourceRule implements IAlgebraicRewriteRule { @Override public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { if (hasRun) { return false; } if (context.checkIfInDontApplySet(this, opRef.getValue())) { return false; } Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> result = rewriteSubplanOperator(opRef, context); return result.first; } private Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> rewriteSubplanOperator( Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { AbstractLogicalOperator op = (AbstractLogicalOperator) opRef.getValue(); // Recursively traverses input operators as if the current operator before rewriting the current operator. Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> changedAndVarMap = traverseNonSubplanOperator(op, context);
response: empty-tuple-source -- |UNPARTITIONED| assign [$$29] <- [TRUE] -- |UNPARTITIONED| assign [$$26] <- [TRUE] -- |UNPARTITIONED| data-scan []<-[$$20, $$21, $$2] <- tpch:LineItems -- |UNPARTITIONED| */ public class InlineSubplanInputForNestedTupleSourceRule implements IAlgebraicRewriteRule { @Override public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { if (context.checkIfInDontApplySet(this, opRef.getValue())) { return false; } Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> result = rewriteSubplanOperator(opRef, context); return result.first; } private Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> rewriteSubplanOperator(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { AbstractLogicalOperator op = (AbstractLogicalOperator) opRef.getValue(); Pair<Boolean, LinkedHashMap<LogicalVariable, LogicalVariable>> changedAndVarMap = traverseNonSubplanOperator(op, context); return changedAndVarMap; } }

sample: 1186
buggy_code:  translator.addVariableToMetaScope(new VarIdentifier("$$RIGHT_" + i), rightInputVarCopy); for (int j = 0; j < rightInputPKs.size(); j++) { rightInputVarCopy = copyVisitor.varCopy(rightInputPKs.get(j)); translator.addVariableToMetaScope(new VarIdentifier("$$RIGHTPK_" + i + "_" + j), rightInputVarCopy); } copyVisitor.updatePrimaryKeys(context); copyVisitor.reset(); } <|startfocus|> int incrementedCounter = context.getVarCounter() - contextCounter; counter.set(counter.get() + incrementedCounter); <|endfocus|> AQLPlusParser parser = new AQLPlusParser(new StringReader(aqlPlus)); parser.initScope(); parser.setVarCounter(counter); List<Clause> clauses; try { clauses = parser.Clauses(); } catch (ParseException e) { throw new AlgebricksException(e); } // Step 4. The essential substitution with translator. ILogicalPlan plan; try { plan = translator.translate(clauses); } catch (AsterixException e) { throw new AlgebricksException(e); } context.setVarCounter(counter.get()); 
code_review:  counter.set(context.getVarCounter()) 
target code: translator.addVariableToMetaScope(new VarIdentifier("$$RIGHT_" + i), rightInputVarCopy); for (int j = 0; j < rightInputPKs.size(); j++) { rightInputVarCopy = copyVisitor.varCopy(rightInputPKs.get(j)); translator.addVariableToMetaScope(new VarIdentifier("$$RIGHTPK_" + i + "_" + j), rightInputVarCopy); } copyVisitor.updatePrimaryKeys(context); copyVisitor.reset(); } AQLPlusParser parser = new AQLPlusParser(new StringReader(aqlPlus)); parser.initScope(); parser.setVarCounter(counter); List<Clause> clauses; try { clauses = parser.Clauses(); } catch (ParseException e) { throw new AlgebricksException(e); } // Step 4. The essential substitution with translator. ILogicalPlan plan; try { plan = translator.translate(clauses); } catch (AsterixException e) { throw new AlgebricksException(e); } context.setVarCounter(counter.get());
response: translator.addVariableToMetaScope(new VarIdentifier("$$RIGHT_" + i), rightInputVarCopy); for (int j = 0; j < rightInputPKs.size(); j++) { rightInputVarCopy = copyVisitor.varCopy(rightInputPKs.get(j)); translator.addVariableToMetaScope(new VarIdentifier("$$RIGHTPK_" + i + "_" + j), rightInputVarCopy); } copyVisitor.updatePrimaryKeys(context); copyVisitor.reset(); counter.set(context.getVarCounter()); AQLPlusParser parser = new AQLPlusParser(new StringReader(aqlPlus)); parser.initScope(); parser.setVarCounter(counter); List<Clause> clauses; try { clauses = parser.Clauses(); } catch (ParseException e) { throw new AlgebricksException(e); } ILogicalPlan plan; try { plan = translator.translate(clauses); } catch (AsterixException e) { throw new AlgebricksException(e); } context.setVarCounter(counter.get());

sample: 1187
buggy_code:  } while (triggerCount == previousTriggerCount); return triggerCount; } /** * Test time-based invalidation in CatalogdTableInvalidator. */ @Test public void testCatalogdTableInvalidator() throws CatalogException, InterruptedException { Reference<Boolean> tblWasRemoved = new Reference<>(); Reference<Boolean> dbWasAdded = new Reference<>(); String dbName = "functional"; String tblName = "alltypes"; <|startfocus|> catalog_ .invalidateTable(new TTableName(dbName, tblName), tblWasRemoved, dbWasAdded); <|endfocus|> MockTicker ticker = new MockTicker(); CatalogdTableInvalidator.TIME_SOURCE = ticker; catalog_.setCatalogdTableInvalidator( new CatalogdTableInvalidator(catalog_, /*unusedTableTtlSec=*/ 2, /*invalidateTablesOnMemoryPressure=*/false, /*oldGenFullThreshold=*/ 0.6, /*gcInvalidationFraction=*/0.1)); Assert.assertFalse(catalog_.getDb(dbName).getTable(tblName).isLoaded()); Table table = catalog_.getOrLoadTable(dbName, tblName); Assert.assertTrue(table.isLoaded()); Assert.assertEquals(ticker.now_, table.getLastUsedTime()); long previousTriggerCount = catalog_.getCatalogdTableInvalidator().triggerCount_.get();
code_review:  nit: can now reformat this code in a less strange way 
target code: } while (triggerCount == previousTriggerCount); return triggerCount; } /** * Test time-based invalidation in CatalogdTableInvalidator. */ @Test public void testCatalogdTableInvalidator() throws CatalogException, InterruptedException { Reference<Boolean> tblWasRemoved = new Reference<>(); Reference<Boolean> dbWasAdded = new Reference<>(); String dbName = "functional"; String tblName = "alltypes"; catalog_.invalidateTable(new TTableName(dbName, tblName), tblWasRemoved, dbWasAdded); MockTicker ticker = new MockTicker(); CatalogdTableInvalidator.TIME_SOURCE = ticker; catalog_.setCatalogdTableInvalidator( new CatalogdTableInvalidator(catalog_, /*unusedTableTtlSec=*/ 2, /*invalidateTablesOnMemoryPressure=*/false, /*oldGenFullThreshold=*/ 0.6, /*gcInvalidationFraction=*/0.1)); Assert.assertFalse(catalog_.getDb(dbName).getTable(tblName).isLoaded()); Table table = catalog_.getOrLoadTable(dbName, tblName); Assert.assertTrue(table.isLoaded()); Assert.assertEquals(ticker.now_, table.getLastUsedTime()); long previousTriggerCount = catalog_.getCatalogdTableInvalidator().triggerCount_.get();
response: @Test public void testCatalogdTableInvalidator() throws CatalogException, InterruptedException { Reference<Boolean> tblWasRemoved = new Reference<>(); Reference<Boolean> dbWasAdded = new Reference<>(); String dbName = "functional"; String tblName = "alltypes"; catalog_.invalidateTable(new TTableName(dbName, tblName), tblWasRemoved, dbWasAdded); MockTicker ticker = new MockTicker(); CatalogdTableInvalidator.TIME_SOURCE = ticker; catalog_.setCatalogdTableInvalidator( new CatalogdTableInvalidator(catalog_, /*unusedTableTtlSec=*/ 2, /*invalidateTablesOnMemoryPressure=*/false, /*oldGenFullThreshold=*/ 0.6, /*gcInvalidationFraction=*/0.1)); Assert.assertFalse(catalog_.getDb(dbName).getTable(tblName).isLoaded()); Table table = catalog_.getOrLoadTable(dbName, tblName); Assert.assertTrue(table.isLoaded()); Assert.assertEquals(ticker.now_, table.getLastUsedTime()); long previousTriggerCount = catalog_.getCatalogdTableInvalidator().triggerCount_.get(); long triggerCount; do { triggerCount = catalog_.getCatalogdTableInvalidator().triggerCount_.get(); Thread.sleep(100); } while (triggerCount == previousTriggerCount); Assert.assertEquals(previousTriggerCount + 1, triggerCount); }

sample: 1188
buggy_code:  profile_ = new TRuntimeProfileNode("Frontend", /*num_children=*/ 0, /*counters=*/new ArrayList<>(), /*metadata=*/-1L, // TODO(todd) what is this used for? why is it required? /*indent=*/false, /*info_strings=*/new HashMap<>(), /*info_strings_display_order*/new ArrayList<>(), /*child_counters_map=*/ImmutableMap.of(ROOT_COUNTER_NAME, new HashSet<>())); } /** <|startfocus|> * Create a new profile, setting it as the current thread-lcoal profile for the <|endfocus|> * length of the current scope. This is meant to be used in a try-with-resources * statement. */ public static Scope createNewWithScope() { return new Scope(new FrontendProfile()); } /** * Get the profile attached to the current thread, throw IllegalStateException if there * is none. */ @Nonnull public static FrontendProfile getCurrent() { FrontendProfile prof = THREAD_LOCAL.get(); Preconditions.checkState(prof != null, "no profile in scope"); return prof; } /**
code_review:  spelling: thread-local 
target code: profile_ = new TRuntimeProfileNode("Frontend", /*num_children=*/ 0, /*counters=*/new ArrayList<>(), /*metadata=*/-1L, // TODO(todd) what is this used for? why is it required? /*indent=*/false, /*info_strings=*/new HashMap<>(), /*info_strings_display_order*/new ArrayList<>(), /*child_counters_map=*/ImmutableMap.of(ROOT_COUNTER_NAME, new HashSet<>())); } /** * Create a new profile, setting it as the current thread-local profile for the * length of the current scope. This is meant to be used in a try-with-resources * statement. */ public static Scope createNewWithScope() { return new Scope(new FrontendProfile()); } /** * Get the profile attached to the current thread, throw IllegalStateException if there * is none. */ @Nonnull public static FrontendProfile getCurrent() { FrontendProfile prof = THREAD_LOCAL.get(); Preconditions.checkState(prof != null, "no profile in scope"); return prof; } /**
response: profile_ = new TRuntimeProfileNode("Frontend", /*num_children=*/ 0, /*counters=*/new ArrayList<>(), /*metadata=*/-1L, /*indent=*/false, /*info_strings=*/new HashMap<>(), /*info_strings_display_order*/new ArrayList<>(), /*child_counters_map=*/ImmutableMap.of(ROOT_COUNTER_NAME, new HashSet<>())); public static Scope createNewWithScope() { return new Scope(new FrontendProfile()); } @Nonnull public static FrontendProfile getCurrent() { FrontendProfile prof = THREAD_LOCAL.get(); Preconditions.checkState(prof != null, "no profile in scope"); return prof; }

sample: 1189
buggy_code:  private boolean shouldEvictFromFullHeapAfterGc() { if (!invalidateTableOnMemoryPressure_) return false; long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { <|startfocus|> LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without " + "invalidating tables based on memory pressure this time."); <|endfocus|> return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false;
code_review:  How about: Table invalidation due to memory pressure was skipped. 
target code: private boolean shouldEvictFromFullHeapAfterGc() { if (!invalidateTableOnMemoryPressure_) return false; long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returned null. Table invalidation based on " + "memory pressure was skipped."); return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false;
response: private boolean shouldEvictFromFullHeapAfterGc() { if (!invalidateTableOnMemoryPressure_) { return false; } long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without invalidating tables based on memory pressure this time."); return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false; }

sample: 1190
buggy_code:  long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without " + "invalidating tables based on memory pressure this time."); return false; } <|startfocus|> MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); <|endfocus|> return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false;
code_review:  from the docs, getMemoryUsageAfterGc should be non-null and given that we found the pool on L163, this should also be non-null. add a precondition for this? 
target code: long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without " + "invalidating tables based on memory pressure this time."); return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); Preconditions.checkState(tenuredGenUsage != null); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false;
response: public long getGcCount() { return oldGenGcBean_.getCollectionCount(); } public boolean isMemoryPressure() { long gcCount = getGcCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without invalidating tables based on memory pressure this time."); return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); if (tenuredGenUsage == null) { throw new NullPointerException("Memory usage for tenured generation is null."); } return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false; }

sample: 1191
buggy_code:  if (removedDb == null) { // Nothing was removed from the catalogd's cache. resp.result.setVersion(catalog_.getCatalogVersion()); return; } // Make sure the cache directives, if any, of the underlying tables are removed for (String tableName: removedDb.getAllTableNames()) { uncacheTable(removedDb.getTable(tableName)); } removedObject = removedDb.toTCatalogObject(); } <|startfocus|> updateDatabasePrivileges(db.getName(), /* tableName */ null, params.server_name, <|endfocus|> db.getMetaStoreDb().getOwnerName(), db.getMetaStoreDb().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp); Preconditions.checkNotNull(removedObject); resp.result.setVersion(removedObject.getCatalog_version()); resp.result.addToRemoved_catalog_objects(removedObject); addSummary(resp, "Database has been dropped."); } /** * Drops all the Kudu tables of database 'db' from the Kudu storage engine. Retrieves * the Kudu table name of each table in 'db' from HMS. Throws an ImpalaException if
code_review:  Do we need to do this for CreateFunction? 
target code: if (removedDb == null) { // Nothing was removed from the catalogd's cache. resp.result.setVersion(catalog_.getCatalogVersion()); return; } // Make sure the cache directives, if any, of the underlying tables are removed for (String tableName: removedDb.getAllTableNames()) { uncacheTable(removedDb.getTable(tableName)); } removedObject = removedDb.toTCatalogObject(); } updateOwnerPrivileges(db.getName(), /* tableName */ null, params.server_name, db.getMetaStoreDb().getOwnerName(), db.getMetaStoreDb().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp); Preconditions.checkNotNull(removedObject); resp.result.setVersion(removedObject.getCatalog_version()); resp.result.addToRemoved_catalog_objects(removedObject); addSummary(resp, "Database has been dropped."); } /** * Drops all the Kudu tables of database 'db' from the Kudu storage engine. Retrieves * the Kudu table name of each table in 'db' from HMS. Throws an ImpalaException if
response: public FtraceEvent(ITmfTrace trace, long rank, FtraceField field) { super(trace, rank, TmfTimestamp.fromNanos(field.getTs()), FtraceEventTypeFactory.get(field.getName()), field.getContent()); fField = field; fName = field.getName(); fCallsite = null; } wifiMacAddressPref.setSummary(!TextUtils.isEmpty(macAddress) ? macAddress : getString(R.string.status_unavailable)); Preference wifiIpAddressPref = findPreference(KEY_CURRENT_IP_ADDRESS); String ipAddress = null; if (wifiInfo != null) { long addr = wifiInfo.getIpAddress(); if (addr != 0) { // handle negative values when first octet > 127 if (addr < 0) addr += 0x100000000L; ipAddress = String.format("%d.%d.%d.%d", addr & 0xFF, (addr >> 8) & 0xFF, (addr >> 16) & 0xFF, (addr >> 24) & 0xFF); } } wifiIpAddressPref.setSummary(ipAddress == null ? getString(R.string.status_unavailable) : ipAddress); // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.sshd; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.Target; /** * Annotation tagged on a concrete Command to describe what it is doing */ @Target({ElementType.TYPE}) @Retention(RUNTIME) public @interface CommandMetaData { String name(); String descr() default ""; } if (removedDb == null) { // Nothing was removed from the catalogd's cache. resp.result.setVersion(catalog_.getCatalogVersion()); return; } // Make sure the cache directives, if any, of the underlying tables are removed for (String tableName : removedDb.getAllTableNames()) { uncacheTable(removedDb.getTable(tableName)); } removedObject = removedDb.toTCatalogObject(); updateDatabasePrivileges(db.getName(), /* tableName */ null, params.server_name, db.getMetaStoreDb().getOwnerName(), db.getMetaStoreDb().getOwnerType(), /* newOwner */ null,

sample: 1192
buggy_code:  table = catalog_.removeTable(params.getTable_name().db_name, params.getTable_name().table_name); if (table == null) { // Nothing was removed from the catalogd's cache. resp.result.setVersion(catalog_.getCatalogVersion()); return; } resp.result.setVersion(table.getCatalogVersion()); uncacheTable(table); } if (table.getMetaStoreTable() != null) { <|startfocus|> updateDatabasePrivileges(table.getDb().getName(), table.getName(), params.server_name, table.getMetaStoreTable().getOwner(), table.getMetaStoreTable().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp); <|endfocus|> } removedObject.setType(TCatalogObjectType.TABLE); removedObject.setTable(new TTable()); removedObject.getTable().setTbl_name(tableName.getTbl()); removedObject.getTable().setDb_name(tableName.getDb()); removedObject.setCatalog_version(resp.result.getVersion()); resp.result.addToRemoved_catalog_objects(removedObject); } /**
code_review:  line too long (92 > 90) 
target code: table = catalog_.removeTable(params.getTable_name().db_name, params.getTable_name().table_name); if (table == null) { // Nothing was removed from the catalogd's cache. resp.result.setVersion(catalog_.getCatalogVersion()); return; } resp.result.setVersion(table.getCatalogVersion()); uncacheTable(table); } if (table.getMetaStoreTable() != null) { updateDatabasePrivileges(table.getDb().getName(), table.getName(), params.server_name, table.getMetaStoreTable().getOwner(), table.getMetaStoreTable().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp); } removedObject.setType(TCatalogObjectType.TABLE); removedObject.setTable(new TTable()); removedObject.getTable().setTbl_name(tableName.getTbl()); removedObject.getTable().setDb_name(tableName.getDb()); removedObject.setCatalog_version(resp.result.getVersion()); resp.result.addToRemoved_catalog_objects(removedObject); } /**
response: table = catalog_.removeTable(params.getTable_name().db_name, params.getTable_name().table_name); if (table == null) { resp.result.setVersion(catalog_.getCatalogVersion()); return; } resp.result.setVersion(table.getCatalogVersion()); uncacheTable(table); if (table.getMetaStoreTable() != null) { updateDatabasePrivileges(table.getDb().getName(), table.getName(), params.server_name, table.getMetaStoreTable().getOwner(), table.getMetaStoreTable().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp); } removedObject.setType(TCatalogObjectType.TABLE); removedObject.setTable(new TTable()); removedObject.getTable().setTbl_name(tableName.getTbl()); removedObject.getTable().setDb_name(tableName.getDb()); removedObject.setCatalog_version(resp.result.getVersion()); resp.result.addToRemoved_catalog_objects(removedObject); }

sample: 1193
buggy_code:  // list of the revoked privileges that contain the grant option. The rolePrivileges // parameter will contain a list of new privileges without the grant option that are // granted. If this is simply a revoke of a privilege without grant options, the // api will still return revoked privileges, but the rolePrivileges will be empty // since there will be no newly granted privileges. rolePrivileges = Lists.newArrayList(); <|startfocus|> removedGrantOptPrivileges = catalog_.getSentryProxy().revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), rolePrivileges); <|endfocus|> addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(rolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: rolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } 
code_review:  line too long (96 > 90) 
target code: // list of the revoked privileges that contain the grant option. The rolePrivileges // parameter will contain a list of new privileges without the grant option that are // granted. If this is simply a revoke of a privilege without grant options, the // api will still return revoked privileges, but the rolePrivileges will be empty // since there will be no newly granted privileges. rolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), rolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(rolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: rolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); }
response: // list of the revoked privileges that contain the grant option. The rolePrivileges // parameter will contain a list of new privileges without the grant option that are // granted. If this is simply a revoke of a privilege without grant options, the // api will still return revoked privileges, but the rolePrivileges will be empty // since there will be no newly granted privileges. rolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy().revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), rolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); Preconditions.checkNotNull(rolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: rolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); }

sample: 1194
buggy_code:  } resp.result.setVersion(role.getCatalogVersion()); } /** * Grants or revokes one or more privileges to/from a Sentry role on behalf of the * requestingUser. */ private void grantRevokeRolePrivilege(User requestingUser, TGrantRevokePrivParams grantRevokePrivParams, TDdlExecResponse resp) throws ImpalaException { Preconditions.checkNotNull(requestingUser); verifySentryServiceEnabled(); String roleName = grantRevokePrivParams.getRole_name(); List<TPrivilege> privileges = grantRevokePrivParams.getPrivileges(); <|startfocus|> List<PrincipalPrivilege> rolePrivileges = null; <|endfocus|> List<PrincipalPrivilege> removedGrantOptPrivileges = Lists.newArrayList(); if (grantRevokePrivParams.isIs_grant()) { rolePrivileges = catalog_.getSentryProxy().grantRolePrivileges(requestingUser, roleName, privileges); addSummary(resp, "Privilege(s) have been granted."); } else { // If this is a revoke of a privilege that contains the grant option, the privileges // with the grant option will be revoked and new privileges without the grant option
code_review:  are these meant to be 'added'? 
target code: } resp.result.setVersion(role.getCatalogVersion()); } /** * Grants or revokes one or more privileges to/from a Sentry role on behalf of the * requestingUser. */ private void grantRevokeRolePrivilege(User requestingUser, TGrantRevokePrivParams grantRevokePrivParams, TDdlExecResponse resp) throws ImpalaException { Preconditions.checkNotNull(requestingUser); verifySentryServiceEnabled(); String roleName = grantRevokePrivParams.getRole_name(); List<TPrivilege> privileges = grantRevokePrivParams.getPrivileges(); List<PrincipalPrivilege> addedRolePrivileges = null; List<PrincipalPrivilege> removedGrantOptPrivileges = Lists.newArrayList(); if (grantRevokePrivParams.isIs_grant()) { rolePrivileges = catalog_.getSentryProxy().grantRolePrivileges(requestingUser, roleName, privileges); addSummary(resp, "Privilege(s) have been granted."); } else { // If this is a revoke of a privilege that contains the grant option, the privileges // with the grant option will be revoked and new privileges without the grant option
response: import com.google.gerrit.extensions.restapi.NotImplementedException; import com.google.gerrit.extensions.restapi.PreconditionFailedException; import com.google.gerrit.extensions.restapi.RestApiException; import com.google.gerrit.extensions.restapi.RestReadView; import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.Project; import com.google.gerrit.reviewdb.client.RefNames; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.ChangeUtil; import com.google.gerrit.server.IdentifiedUser; import com.google.gerrit.server.change.ArchiveFormat; import com.google.gerrit.server.change.RevisionResource; import com.google.gerrit.server.config.GerritServerConfig; import com.google.gerrit.server.git.MergeOp; import com.google.gerrit.server.git.MergeOpRepoManager; import com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo; import com.google.gerrit.server.ioutil.LimitedByteArrayOutputStream; import com.google.gerrit.server.ioutil.LimitedByteArrayOutputStream.LimitExceededException; import com.google.gerrit.server.permissions.PermissionBackendException; import com.google.gerrit.server.project.NoSuchProjectException; import com.google.gerrit.server.update.UpdateException; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; public static native void arraycopy(Object src, int srcPos, Object dst, int dstPos, int length); private static final int ARRAYCOPY_SHORT_T_ARRAY_THRESHOLD = 32; public static <T> void arraycopy(T[] src, int srcPos, T[] dst, int dstPos, int length) { if (src.getClass() != dst.getClass() || dst.getClass() != Object[].class || dst.getClass().isAssignableFrom(src.getClass())) { arraycopy(src, srcPos, dst, dstPos, length); } } private long size = 0; private Path tmpFile; public CleanFilter(Repository db, InputStream in, OutputStream out) throws IOException { super(in, out); lfsUtil = new LfsUtil(db.getDirectory().toPath().resolve("lfs")); Files.createDirectories(lfsUtil.getLfsTmpDir()); tmpFile = lfsUtil.createTmpFile(); this.out = out; } resp.result.setVersion(role.getCatalogVersion()); private void grantRevoke

sample: 1195
buggy_code:  } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion( updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version()); <|startfocus|> } else if (privileges.get(0).isHas_grant_opt()) { <|endfocus|> resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion( updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version() > removedPrivs.get(removedPrivs.size() - 1).getCatalog_version() ? updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version() : removedPrivs.get(removedPrivs.size() - 1).getCatalog_version()); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion(
code_review:  what's special about the first one? is there some homogeneity assumption here that should rather be a param? 
target code: } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion( updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version()); } } else if (privileges.get(0).isHas_grant_opt()) { if (!updatedPrivs.isEmpty() && !removedPrivs.isEmpty()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion( updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version() > removedPrivs.get(removedPrivs.size() - 1).getCatalog_version() ? updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version() : removedPrivs.get(removedPrivs.size() - 1).getCatalog_version()); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion(
response: } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion(updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version()); } else if (privileges.get(0).isHas_grant_opt()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion(updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version() > removedPrivs.get(removedPrivs.size() - 1).getCatalog_version() ? updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version() : removedPrivs.get(removedPrivs.size() - 1).getCatalog_version()); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion(

sample: 1196
buggy_code:  private static final String ERROR_MSG_BAD_COLUMN_VALUE = "Raw value '" + ROW_BAD_COLUMN_VALUE + "' couldn't be parsed to type Type: int8 for column 'byteFld'"; private static final String POLICY_REJECT = "REJECT"; private static final String POLICY_WARN = "WARN"; private static final String POLICY_IGNORE = "IGNORE"; @Rule <|startfocus|> public ExpectedException thrown= ExpectedException.none(); <|endfocus|> @Test public void testMissingColumnThrowsExceptionDefaultConfig() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); } @Test public void testMissingColumnThrowsExceptionDeprecated() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); additionalContext.put(SKIP_MISSING_COLUMN_PROP, String.valueOf(false)); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); } @Test public void testMissingColumnThrowsException() throws Exception { Context additionalContext = new Context();
code_review:  nit: space before -= 
target code: private static final String ERROR_MSG_BAD_COLUMN_VALUE = "Raw value '" + ROW_BAD_COLUMN_VALUE + "' couldn't be parsed to type Type: int8 for column 'byteFld'"; private static final String POLICY_REJECT = "REJECT"; private static final String POLICY_WARN = "WARN"; private static final String POLICY_IGNORE = "IGNORE"; @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void testMissingColumnThrowsExceptionDefaultConfig() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); } @Test public void testMissingColumnThrowsExceptionDeprecated() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); additionalContext.put(SKIP_MISSING_COLUMN_PROP, String.valueOf(false)); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); } @Test public void testMissingColumnThrowsException() throws Exception { Context additionalContext = new Context();
response: private static final String ERROR_MSG_BAD_COLUMN_VALUE = "Raw value '" + ROW_BAD_COLUMN_VALUE + "' couldn't be parsed to type Type: int8 for column 'byteFld'"; private static final String POLICY_REJECT = "REJECT"; private static final String POLICY_WARN = "WARN"; private static final String POLICY_IGNORE = "IGNORE"; @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void testMissingColumnThrowsExceptionDefaultConfig() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); } @Test public void testMissingColumnThrowsExceptionDeprecated() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); additionalContext.put(SKIP_MISSING_COLUMN_PROP, String.valueOf(false)); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); } @Test public void testMissingColumnThrowsException() throws Exception { Context additionalContext = new Context(); additionalContext.put(PATTERN_PROP, TEST_REGEXP_MISSING_COLUMN); testThrowsException(additionalContext, ERROR_MSG_MISSING_COLUMN, ROW_MISSING_COLUMN); }

sample: 1197
buggy_code:  * The phases of aggregate computation are as follows. Also see AggregateInfo. * - Only a non-distinct class: * - Example: SELECT max(a) FROM... * - 1-phase aggregation * - One distinct class, and optionally a non-distinct class: * - Example: SELECT count(distinct a)[, max(b)] FROM... * - coalesced into a single AggregateInfo to preserve the pre-IMPALA-110 behavior <|startfocus|> * - 2-phase aggregation, 1st phase groups by GROUP BY ples DISTINCT exprs, 2nd phase <|endfocus|> * groups by GROUP BY * - the non-distinct class is carried along the two phases, aggregated in 1st phase and * merged in 2nd phase * - Multiple distinct classes, and optionally a non-distinct class * - Example: SELECT count(distinct a), count(distinct b)[, max(c)] FROM... * - 2-phase aggregation followed by a transposition aggregation * - aggregation nodes update and maintain the state of all aggregation classes at once
code_review:  nit: plus 
target code: * The phases of aggregate computation are as follows. Also see AggregateInfo. * - Only a non-distinct class: * - Example: SELECT max(a) FROM... * - 1-phase aggregation * - One distinct class, and optionally a non-distinct class: * - Example: SELECT count(distinct a)[, max(b)] FROM... * - coalesced into a single AggregateInfo to preserve the pre-IMPALA-110 behavior * - 2-phase aggregation, 1st phase groups by GROUP BY plus DISTINCT exprs, 2nd phase * groups by GROUP BY * - the non-distinct class is carried along the two phases, aggregated in 1st phase and * merged in 2nd phase * - Multiple distinct classes, and optionally a non-distinct class * - Example: SELECT count(distinct a), count(distinct b)[, max(c)] FROM... * - 2-phase aggregation followed by a transposition aggregation * - aggregation nodes update and maintain the state of all aggregation classes at once
response: * The phases of aggregate computation are as follows. Also see AggregateInfo. - Only a non-distinct class: - Example: SELECT max(a) FROM... - 1-phase aggregation - One distinct class, and optionally a non-distinct class: - Example: SELECT count(distinct a)[, max(b)] FROM... - coalesced into a single AggregateInfo to preserve the pre-IMPALA-110 behavior - 2-phase aggregation, 1st phase groups by GROUP BY ples DISTINCT exprs, 2nd phase groups by GROUP BY - the non-distinct class is carried along the two phases, aggregated in 1st phase and merged in 2nd phase - Multiple distinct classes, and optionally a non-distinct class - Example: SELECT count(distinct a), count(distinct b)[, max(c)] FROM... - 2-phase aggregation followed by a transposition aggregation - aggregation nodes update and maintain the state of all aggregation classes at once

sample: 1198
buggy_code:  */ final private Thread daemonThread_; /** * The threshold above which the old gen is considered almost full. */ final private double oldGenFullThreshold_; /** * The ratio of tables to invalidate when the old gen is almost full. */ final private double gcInvalidationFraction_; /** * The number of times the daemon thread wakes up and scans the tables for invalidation. <|startfocus|> * It's useful for tests to ensure that a scanning occurred and to proceed. <|endfocus|> */ @VisibleForTesting AtomicLong scanCount_ = new AtomicLong(); private GarbageCollectorMXBean oldGenGcBean_; /** * The name of the old gen memory pool. */ private String oldGcGenName_; /** * The value of oldGenGcBean_.getCollectionCount() when the last memory-based * invalidation was executed. */ private long lastObservedGcCount_; private boolean stopped_ = false; /** * Last time an time-based invalidation is executed in nanoseconds. */ private long lastInvalidationTime_; 
code_review:  nit, simplify: scan happened. 
target code: */ final private Thread daemonThread_; /** * The threshold above which the old gen is considered almost full. */ final private double oldGenFullThreshold_; /** * The ratio of tables to invalidate when the old gen is almost full. */ final private double gcInvalidationFraction_; /** * The number of times the daemon thread wakes up and scans the tables for invalidation. * It's useful for tests to ensure that a scan happened. */ @VisibleForTesting AtomicLong scanCount_ = new AtomicLong(); private GarbageCollectorMXBean oldGenGcBean_; /** * The name of the old gen memory pool. */ private String oldGcGenName_; /** * The value of oldGenGcBean_.getCollectionCount() when the last memory-based * invalidation was executed. */ private long lastObservedGcCount_; private boolean stopped_ = false; /** * Last time an time-based invalidation is executed in nanoseconds. */ private long lastInvalidationTime_;
response: final private Thread daemonThread_; final private double oldGenFullThreshold_; final private double gcInvalidationFraction_; @VisibleForTesting AtomicLong scanCount_ = new AtomicLong(); private GarbageCollectorMXBean oldGenGcBean_; private String oldGcGenName_; private long lastObservedGcCount_; private boolean stopped_ = false; private long lastInvalidationTime_;

sample: 1199
buggy_code:  private boolean shouldEvictFromFullHeapAfterGc() { if (!invalidateTableOnMemoryPressure_) return false; long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { <|startfocus|> LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without " + "invalidating tables based on memory pressure this time."); <|endfocus|> return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false;
code_review:  nit: returned 
target code: private boolean shouldEvictFromFullHeapAfterGc() { if (!invalidateTableOnMemoryPressure_) return false; long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returned null. Table invalidation based on " + "memory pressure was skipped."); return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false;
response: private boolean shouldEvictFromFullHeapAfterGc() { if (!invalidateTableOnMemoryPressure_) { return false; } long gcCount = oldGenGcBean_.getCollectionCount(); if (gcCount > lastObservedGcCount_) { lastObservedGcCount_ = gcCount; GcInfo lastGcInfo = oldGenGcBean_.getLastGcInfo(); if (lastGcInfo == null) { LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without invalidating tables based on memory pressure this time."); return false; } MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); return tenuredGenUsage.getMax() * oldGenFullThreshold_ < tenuredGenUsage.getUsed(); } return false; }

sample: 1200
buggy_code:  * If a user with the same name already exists it will be overwritten. */ public User addUser(String userName) { Principal user = addPrincipal(userName, Sets.<String>newHashSet(), TPrincipalType.USER); Preconditions.checkState(user instanceof User); return (User) user; } /** * Add a user to the catalog if it doesn't exist. This is necessary so privileges <|startfocus|> * can be added for a user. For example owner privileges. <|endfocus|> */ public org.apache.impala.catalog.User addUserIfNotExists(String owner) { versionLock_.writeLock().lock(); try { org.apache.impala.catalog.User user = getAuthPolicy().getUser(owner); if (user == null) { user = addUser(owner); } return user; } finally { versionLock_.writeLock().unlock(); } } private Principal addPrincipal(String principalName, Set<String> grantGroups, TPrincipalType type) { versionLock_.writeLock().lock(); try { Principal principal = Principal.newInstance(principalName, type, grantGroups);
code_review:  nit: condense to (example: owner pr..). 
target code: * If a user with the same name already exists it will be overwritten. */ public User addUser(String userName) { Principal user = addPrincipal(userName, Sets.<String>newHashSet(), TPrincipalType.USER); Preconditions.checkState(user instanceof User); return (User) user; } /** * Add a user to the catalog if it doesn't exist. This is necessary so privileges * can be added for a user. example: owner privileges. */ public org.apache.impala.catalog.User addUserIfNotExists(String owner) { versionLock_.writeLock().lock(); try { org.apache.impala.catalog.User user = getAuthPolicy().getUser(owner); if (user == null) { user = addUser(owner); } return user; } finally { versionLock_.writeLock().unlock(); } } private Principal addPrincipal(String principalName, Set<String> grantGroups, TPrincipalType type) { versionLock_.writeLock().lock(); try { Principal principal = Principal.newInstance(principalName, type, grantGroups);
response: * If a user with the same name already exists it will be overwritten. */ public User addUser(String userName) { Principal user = addPrincipal(userName, Sets.<String>newHashSet(), TPrincipalType.USER); Preconditions.checkState(user instanceof User); return (User) user; } /** * Add a user to the catalog if it doesn't exist. This is necessary so privileges * can be added for a user. For example owner privileges. */ public org.apache.impala.catalog.User addUserIfNotExists(String owner) { versionLock_.writeLock().lock(); try { org.apache.impala.catalog.User user = getAuthPolicy().getUser(owner); if (user == null) { user = addUser(owner); } return user; } finally { versionLock_.writeLock().unlock(); } } private Principal addPrincipal(String principalName, Set<String> grantGroups, TPrincipalType type) { versionLock_.writeLock().lock(); try { Principal principal = Principal.newInstance(principalName, type, grantGroups); // ... rest of the code } finally { versionLock_.writeLock().unlock(); } }

sample: 1201
buggy_code:  PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy() .removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege .toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { <|startfocus|> LOG.error("Error modifying privilege: ", e); <|endfocus|> } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER);
code_review:  removing 
target code: PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy() .removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege .toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER);
response: public FullPackageLoader(@Nonnull JackLibrary jackLibrary, @Nonnull JPhantomLookup lookup) { super(jackLibrary, jackLibrary.getLibraryVDir(), lookup, NodeLevel.FULL); } public synchronized static ReportManagerRegistry getInstance() { if (instance == null) { instance = new ReportManagerRegistry(); instance.subscribe(ReportManagerConstants.LOG_OUTPUT_DEFAULT); //$NON-NLS-1$ } return instance; } "refs/for/master"); private PushOneCommit.Result createChange(TestRepository<?> repo, String subject, String fileName, String content, List<RevCommit> parents) throws Exception { return createChange(repo, subject, fileName, content, parents, "refs/for/master"); } private PushOneCommit.Result createChange(String subject, List<RevCommit> parents) throws Exception { return createTestChange(testRepo, subject, "", "", parents, "refs/for/master"); } private PushOneCommit.Result createChange(String subject, String fileName, String content, List<RevCommit> parents) throws Exception { return createChange(testRepo, subject, fileName, content, parents, "refs/for/master"); } PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy().removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } catch (CatalogException e) { LOG.error("Error modifying privilege: ", e); } private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); } } catch (CatalogException e) { LOG.error("Error adding privilege to catalog: ", e); } }

sample: 1202
buggy_code:  } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { <|startfocus|> LOG.error("Error modifying privilege: ", e); <|endfocus|> } } /** * Create a new HMS Partition. */ private static Partition createHmsPartition(List<TPartitionKeyValue> partitionSpec, org.apache.hadoop.hive.metastore.api.Table msTbl, TableName tableName, String location) { List<String> values = Lists.newArrayList(); // Need to add in the values in the same order they are defined in the table. for (FieldSchema fs: msTbl.getPartitionKeys()) { for (TPartitionKeyValue kv: partitionSpec) {
code_review:  adding 
target code: } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } } /** * Create a new HMS Partition. */ private static Partition createHmsPartition(List<TPartitionKeyValue> partitionSpec, org.apache.hadoop.hive.metastore.api.Table msTbl, TableName tableName, String location) { List<String> values = Lists.newArrayList(); // Need to add in the values in the same order they are defined in the table. for (FieldSchema fs: msTbl.getPartitionKeys()) { for (TPartitionKeyValue kv: partitionSpec) {
response: import java.util.regex.Matcher; import java.util.regex.Pattern; import org.eclipse.osee.framework.core.enums.BranchType; import org.eclipse.osee.framework.jdk.core.type.IResourceRegistry; import org.eclipse.osee.framework.jdk.core.type.ResourceToken; import org.eclipse.osee.orcs.data.BranchReadable; import org.eclipse.osee.orcs.search.BranchQuery; import org.eclipse.osee.template.engine.CompositeRule; import org.eclipse.osee.template.engine.IdentifiableOptionsRule; import org.eclipse.osee.template.engine.PageCreator; import org.eclipse.osee.template.engine.PageFactory; public class OseeAppletPage { //example input for pattern: <input id="selected_branch" type="text" list="baselineBranches" required/><br /> private static final Pattern listAttributePattern = Pattern.compile("<input[^>]+?list=\"([^\"]+)"); private final BranchQuery query; public OseeAppletPage(BranchQuery query) { this.query = query; } public String realizeApplet(IResourceRegistry registry, ResourceToken valuesResource) { PageCreator page = PageFactory.newPageCreator(registry); return realizeApplet(valuesResource, page); } }

sample: 1203
buggy_code:  Map<String, Set<TSentryPrivilege>> allUsersPrivileges = sentryPolicyService_.listAllUsersPrivileges(processUser_); for (Map.Entry<String, Set<TSentryPrivilege>> userPrivilegesEntry: allUsersPrivileges.entrySet()) { String userName = userPrivilegesEntry.getKey(); // This user exists and should not be removed so remove it from the // usersToRemove set. usersToRemove.remove(userName); <|startfocus|> org.apache.impala.catalog.User user = catalog_.addUserIfNotExists(userName); if (resetVersions_) { <|endfocus|> user.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } refreshPrivilegesInCatalog(user, allUsersPrivileges); } return usersToRemove; } /** * Updates the privileges for a given principal in the catalog since the last Sentry * sync update. */ private void refreshPrivilegesInCatalog(Principal principal, Map<String, Set<TSentryPrivilege>> allPrincipalPrivileges) throws CatalogException { // Assume all privileges should be removed. Privileges that still exist are // deleted from this set and we are left with the set of privileges that need // to be removed.
code_review:  something looks off with this change: prior, this branch was run only when the user already existed. that can be fixed by adding a Reference bool parameter to the method indicating if the user was added or not. the other thing I'll note is that prior, there was less contention for the write lock. since we have multiple ways to add a user, this will compete with all other operations. this may be something to look at again when we stress it. 
target code: Map<String, Set<TSentryPrivilege>> allUsersPrivileges = sentryPolicyService_.listAllUsersPrivileges(processUser_); for (Map.Entry<String, Set<TSentryPrivilege>> userPrivilegesEntry: allUsersPrivileges.entrySet()) { String userName = userPrivilegesEntry.getKey(); // This user exists and should not be removed so remove it from the // usersToRemove set. usersToRemove.remove(userName); Reference<Boolean> existingUser = new Reference<>(); org.apache.impala.catalog.User user = catalog_.addUserIfNotExists(userName, existingUser); if (existingUser.getRef() && resetVersions_) { user.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } refreshPrivilegesInCatalog(user, allUsersPrivileges); } return usersToRemove; } /** * Updates the privileges for a given principal in the catalog since the last Sentry * sync update. */ private void refreshPrivilegesInCatalog(Principal principal, Map<String, Set<TSentryPrivilege>> allPrincipalPrivileges) throws CatalogException { // Assume all privileges should be removed. Privileges that still exist are // deleted from this set and we are left with the set of privileges that need // to be removed.
response: public void activate() { refresh(); } public Version getMinVersion() { List<Version> versions = getAllVersions(); if (versions.isEmpty()) { return Version.NO_VERSION; } else if (versions.size() == 1) { return versions.get(0); } else { Version minVersion = versions.get(0); for (Version version : versions) { if (version.compareTo(minVersion) < 0) { minVersion = version; } } return minVersion; } } boolean isFiltered = true; if (artifact != null) { if (FilterType.ONLY_DIRTIES == filter) { isFiltered = !artifact.isDirty(); } } Map<String, Set<TSentryPrivilege>> allUsersPrivileges = sentryPolicyService_.listAllUsersPrivileges(processUser_); for (Map.Entry<String, Set<TSentryPrivilege>> userPrivilegesEntry : allUsersPrivileges.entrySet()) { String userName = userPrivilegesEntry.getKey(); usersToRemove.remove(userName); org.apache.impala.catalog.User user = catalog_.addUserIfNotExists(userName); if (resetVersions_) { user.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } refreshPrivilegesInCatalog(user, allUsersPrivileges); } return usersToRemove; private void refreshPrivilegesInCatalog(Principal principal, Map<String, Set<TSentryPrivilege>> allPrincipalPrivileges) throws CatalogException { // Assume all privileges should be removed. Privileges that still exist are // deleted from this set and we are left with the set of privileges that need // to be removed. }

sample: 1204
buggy_code:  TableName tableName = table.getTableName(); PrivilegeRequestBuilder builder = new PrivilegeRequestBuilder() .onTable(tableName.getDb(), tableName.getTbl()) .allOf(priv); if (requireGrantOption) { builder.grantOption(); } registerPrivReq(builder.toRequest()); } /** * Returns the server name if authorization is enabled. Returns null when authorization * is not enabled. */ public String getServerName() { <|startfocus|> if (getAuthzConfig().isEnabled()) return getAuthzConfig().getServerName(); return null; <|endfocus|> } } 
code_review:  Style: if statements should always have {} braces and conform to normal Java formatting. That said you don't need an if statement here at all ands can use ? : construct. 
target code: TableName tableName = table.getTableName(); PrivilegeRequestBuilder builder = new PrivilegeRequestBuilder() .onTable(tableName.getDb(), tableName.getTbl()) .allOf(priv); if (requireGrantOption) { builder.grantOption(); } registerPrivReq(builder.toRequest()); } /** * Returns the server name if authorization is enabled. Returns null when authorization * is not enabled. */ public String getServerName() { return getAuthzConfig().isEnabled() ? getAuthzConfig().getServerName() : null; } }
response: TableName tableName = table.getTableName(); PrivilegeRequestBuilder builder = new PrivilegeRequestBuilder() .onTable(tableName.getDb(), tableName.getTbl()) .allOf(priv); if (requireGrantOption) { builder.grantOption(); } registerPrivReq(builder.toRequest()); public String getServerName() { return getAuthzConfig().isEnabled() ? getAuthzConfig().getServerName() : null; }

sample: 1205
buggy_code:  } } Preconditions.checkNotNull(newDb); // TODO(todd): if client is a 'v2' impalad, only send back invalidation resp.result.addToUpdated_catalog_objects(newDb.toTCatalogObject()); } updateOwnerPrivileges(newDb.getName(), /* tableName */ null, params.server_name, /* oldOwner */ null, /* oldOwnerType */ null, newDb.getMetaStoreDb().getOwnerName(), newDb.getMetaStoreDb().getOwnerType(), resp); resp.result.setVersion(newDb.getCatalogVersion()); } <|startfocus|> /** <|endfocus|> * If object ownership is enabled in Sentry, we need to update the owner privilege * in the catalog so that any subsequent statements that rely on that privilege, or * the absence, will function correctly without waiting for the next refresh. * If oldOwner is not null, the privilege will be removed. If newOwner is not null, * the privilege will be added. * The catalog will correctly reflect the owner in HMS, however because the owner
code_review:  Style: The first sentence of Javadoc is used in special ways - it should be a very short description of what the method is doing. 
target code: } } Preconditions.checkNotNull(newDb); // TODO(todd): if client is a 'v2' impalad, only send back invalidation resp.result.addToUpdated_catalog_objects(newDb.toTCatalogObject()); } updateOwnerPrivileges(newDb.getName(), /* tableName */ null, params.server_name, /* oldOwner */ null, /* oldOwnerType */ null, newDb.getMetaStoreDb().getOwnerName(), newDb.getMetaStoreDb().getOwnerType(), resp); resp.result.setVersion(newDb.getCatalogVersion()); } /** * Update the owner privileges for an object. * If object ownership is enabled in Sentry, we need to update the owner privilege * in the catalog so that any subsequent statements that rely on that privilege, or * the absence, will function correctly without waiting for the next refresh. * If oldOwner is not null, the privilege will be removed. If newOwner is not null, * the privilege will be added. * The catalog will correctly reflect the owner in HMS, however because the owner
response: } } Preconditions.checkNotNull(newDb); // TODO(todd): if client is a 'v2' impalad, only send back invalidation resp.result.addToUpdated_catalog_objects(newDb.toTCatalogObject()); } updateOwnerPrivileges(newDb.getName(), /* tableName */ null, params.server_name, /* oldOwner */ null, /* oldOwnerType */ null, newDb.getMetaStoreDb().getOwnerName(), newDb.getMetaStoreDb().getOwnerType(), resp); resp.result.setVersion(newDb.getCatalogVersion()); } /** * If object ownership is enabled in Sentry, we need to update the owner privilege * in the catalog so that any subsequent statements that rely on that privilege, or * the absence, will function correctly without waiting for the next refresh. * If oldOwner is not null, the privilege will be removed. If newOwner is not null, * the privilege will be added. * The catalog will correctly reflect the owner in HMS, however because the owner

sample: 1206
buggy_code:  String serverName, String oldOwner, PrincipalType oldOwnerType, String newOwner, PrincipalType newOwnerType, TDdlExecResponse resp) { if (catalog_.getSentryProxy() == null || !catalog_.getSentryProxy() .isObjectOwnershipEnabled()) return; Preconditions.checkNotNull(serverName); TPrivilege filter; if (tableName == null) { filter = createDatabaseOwnerPrivilegeFilter(databaseName, serverName); } else { filter = createTableOwnerPrivilegeFilter(databaseName, tableName, serverName); } <|startfocus|> if(oldOwner != null && oldOwner.length() > 0) { <|endfocus|> removePrivilegeFromCatalog(oldOwner, oldOwnerType, filter, resp); } if(newOwner != null && newOwner.length() > 0) { addPrivilegeToCatalog(newOwner, newOwnerType, filter, resp); } } private void createFunction(TCreateFunctionParams params, TDdlExecResponse resp) throws ImpalaException { Function fn = Function.fromThrift(params.getFn()); if (LOG.isTraceEnabled()) { LOG.trace(String.format("Adding %s: %s", fn.getClass().getSimpleName(), fn.signatureString())); }
code_review:  Style: it is better to use isEmpty() rather then compare size with 0. 
target code: String serverName, String oldOwner, PrincipalType oldOwnerType, String newOwner, PrincipalType newOwnerType, TDdlExecResponse resp) { if (catalog_.getSentryProxy() == null || !catalog_.getSentryProxy() .isObjectOwnershipEnabled()) return; Preconditions.checkNotNull(serverName); TPrivilege filter; if (tableName == null) { filter = createDatabaseOwnerPrivilegeFilter(databaseName, serverName); } else { filter = createTableOwnerPrivilegeFilter(databaseName, tableName, serverName); } if(oldOwner != null && !oldOwner.isEmpty()) { removePrivilegeFromCatalog(oldOwner, oldOwnerType, filter, resp); } if(newOwner != null && newOwner.length() > 0) { addPrivilegeToCatalog(newOwner, newOwnerType, filter, resp); } } private void createFunction(TCreateFunctionParams params, TDdlExecResponse resp) throws ImpalaException { Function fn = Function.fromThrift(params.getFn()); if (LOG.isTraceEnabled()) { LOG.trace(String.format("Adding %s: %s", fn.getClass().getSimpleName(), fn.signatureString())); }
response: String serverName, String oldOwner, PrincipalType oldOwnerType, String newOwner, PrincipalType newOwnerType, TDdlExecResponse resp) { if (catalog_.getSentryProxy() == null || !catalog_.getSentryProxy().isObjectOwnershipEnabled()) return; Preconditions.checkNotNull(serverName); TPrivilege filter; if (tableName == null) { filter = createDatabaseOwnerPrivilegeFilter(databaseName, serverName); } else { filter = createTableOwnerPrivilegeFilter(databaseName, tableName, serverName); } if (!oldOwner.isEmpty()) { removePrivilegeFromCatalog(oldOwner, oldOwnerType, filter, resp); } if (!newOwner.isEmpty()) { addPrivilegeToCatalog(newOwner, newOwnerType, filter, resp); } } private void createFunction(TCreateFunctionParams params, TDdlExecResponse resp) throws ImpalaException { Function fn = Function.fromThrift(params.getFn()); if (LOG.isTraceEnabled()) { LOG.trace(String.format("Adding %s: %s", fn.getClass().getSimpleName(), fn.signatureString())); } }

sample: 1207
buggy_code:  PrincipalType newOwnerType, TDdlExecResponse resp) { if (catalog_.getSentryProxy() == null || !catalog_.getSentryProxy() .isObjectOwnershipEnabled()) return; Preconditions.checkNotNull(serverName); TPrivilege filter; if (tableName == null) { filter = createDatabaseOwnerPrivilegeFilter(databaseName, serverName); } else { filter = createTableOwnerPrivilegeFilter(databaseName, tableName, serverName); } <|startfocus|> if(oldOwner != null && oldOwner.length() > 0) { <|endfocus|> removePrivilegeFromCatalog(oldOwner, oldOwnerType, filter, resp); } if(newOwner != null && newOwner.length() > 0) { addPrivilegeToCatalog(newOwner, newOwnerType, filter, resp); } } private void createFunction(TCreateFunctionParams params, TDdlExecResponse resp) throws ImpalaException { Function fn = Function.fromThrift(params.getFn()); if (LOG.isTraceEnabled()) { LOG.trace(String.format("Adding %s: %s", fn.getClass().getSimpleName(), fn.signatureString())); } boolean isPersistentJavaFn =
code_review:  Can this fail? 
target code: PrincipalType newOwnerType, TDdlExecResponse resp) { if (catalog_.getSentryProxy() == null || !catalog_.getSentryProxy() .isObjectOwnershipEnabled()) return; Preconditions.checkNotNull(serverName); TPrivilege filter; if (tableName == null) { filter = createDatabaseOwnerPrivilegeFilter(databaseName, serverName); } else { filter = createTableOwnerPrivilegeFilter(databaseName, tableName, serverName); } if(oldOwner != null && !oldOwner.isEmpty()) { removePrivilegeFromCatalog(oldOwner, oldOwnerType, filter, resp); } if(newOwner != null && newOwner.length() > 0) { addPrivilegeToCatalog(newOwner, newOwnerType, filter, resp); } } private void createFunction(TCreateFunctionParams params, TDdlExecResponse resp) throws ImpalaException { Function fn = Function.fromThrift(params.getFn()); if (LOG.isTraceEnabled()) { LOG.trace(String.format("Adding %s: %s", fn.getClass().getSimpleName(), fn.signatureString())); } boolean isPersistentJavaFn =
response: PrincipalType newOwnerType, TDdlExecResponse resp) { if (catalog_.getSentryProxy() == null || !catalog_.getSentryProxy().isObjectOwnershipEnabled()) return; Preconditions.checkNotNull(serverName); TPrivilege filter; if (tableName == null) { filter = createDatabaseOwnerPrivilegeFilter(databaseName, serverName); } else { filter = createTableOwnerPrivilegeFilter(databaseName, tableName, serverName); } if (oldOwner != null && oldOwner.length() > 0) { removePrivilegeFromCatalog(oldOwner, oldOwnerType, filter, resp); } if (newOwner != null && newOwner.length() > 0) { addPrivilegeToCatalog(newOwner, newOwnerType, filter, resp); } } private void createFunction(TCreateFunctionParams params, TDdlExecResponse resp) throws ImpalaException { Function fn = Function.fromThrift(params.getFn()); if (LOG.isTraceEnabled()) { LOG.trace(String.format("Adding %s: %s", fn.getClass().getSimpleName(), fn.signatureString())); } boolean isPersistentJavaFn = false; if (fn instanceof ScalarFunction) { isPersistentJavaFn = ((ScalarFunction) fn).isPersistentJavaFunction(); } else if (fn instanceof AggregateFunction) { isPersistentJavaFn = ((AggregateFunction) fn).isPersistentJavaFunction(); } if (isPersistentJavaFn) { // Add the function to the catalog catalog_.addJavaFunction((JavaFunction) fn); } else { // Add the function to the local catalog catalog_.addFunction(fn); } resp.setResult(new TCreateFunctionResult()); }

sample: 1208
buggy_code:  TPrivilege filter, TDdlExecResponse response) { try { Principal owner = catalog_.getAuthPolicy().getPrincipal(ownerString, ownerType == PrincipalType.ROLE ? TPrincipalType.ROLE : TPrincipalType.USER); if (owner != null) { PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy() .removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); <|startfocus|> owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); <|endfocus|> response.result.addToRemoved_catalog_objects(removedPrivilege .toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege;
code_review:  Why are we setting different version for owner and removedPrivilege? 
target code: TPrivilege filter, TDdlExecResponse response) { try { Principal owner = catalog_.getAuthPolicy().getPrincipal(ownerString, ownerType == PrincipalType.ROLE ? TPrincipalType.ROLE : TPrincipalType.USER); if (owner != null) { PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy() .removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege .toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege;
response: TPrivilege filter, TDdlExecResponse response) { try { Principal owner = catalog_.getAuthPolicy().getPrincipal(ownerString, ownerType == PrincipalType.ROLE ? TPrincipalType.ROLE : TPrincipalType.USER); if (owner != null) { PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy().removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; // code here } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } }

sample: 1209
buggy_code:  PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy() .removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege .toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { <|startfocus|> LOG.error("Error removing privilege: ", e); <|endfocus|> } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId());
code_review:  Is it Ok to eat this error? 
target code: PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy() .removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege .toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } finally { catalog_.getLock().writeLock().unlock(); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId());
response: PrincipalPrivilege privilege = owner.getPrivilege(filter.getPrivilege_name()); if (privilege != null) { PrincipalPrivilege removedPrivilege = catalog_.getAuthPolicy().removePrivilege(privilege); removedPrivilege.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToRemoved_catalog_objects(removedPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } else { LOG.error("Error removing privilege: Privilege not found"); } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); } else { owner = catalog_.addRoleIfNotExists(ownerString); filter.setPrincipal_id(owner.getId()); } cPrivilege = new PrincipalPrivilege(owner.getId(), filter); catalog_.getAuthPolicy().addPrivilege(cPrivilege); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } }

sample: 1210
buggy_code:  } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; <|startfocus|> Reference<Boolean> existingUser = new Reference<>(); <|endfocus|> if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); }
code_review:  Why do you need Reference here? 
target code: } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } /** * This is a helper method to take care of catalog related updates when removing * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); }
response: } } } catch (CatalogException e) { LOG.error("Error removing privilege: ", e); } } private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } } catch (CatalogException e) { LOG.error("Error adding privilege to catalog: ", e); } }

sample: 1211
buggy_code:  * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); <|startfocus|> cPrivilege = catalog_.addUserPrivilege(ownerString, filter); <|endfocus|> } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } } 
code_review:  What if there is owner type distinct from USER or ROLE? 
target code: * a privilege. */ private void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } }
response: public void addPrivilegeToCatalog(String ownerString, PrincipalType ownerType, TPrivilege filter, TDdlExecResponse response) { try { Principal owner; PrincipalPrivilege cPrivilege; Reference<Boolean> existingUser = new Reference<>(); if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else if (ownerType == PrincipalType.ROLE) { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); } else { throw new IllegalArgumentException("Invalid owner type: " + ownerType); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } }

sample: 1212
buggy_code:  if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); <|startfocus|> } if (!existingUser.getRef()) { <|endfocus|> owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } } /** * Create a new HMS Partition. */ private static Partition createHmsPartition(List<TPartitionKeyValue> partitionSpec, org.apache.hadoop.hive.metastore.api.Table msTbl, TableName tableName, String location) {
code_review:  Owner is a shared entity - others may access/modify it as well - do you need any locking/synchronization here? 
target code: if (ownerType == PrincipalType.USER) { owner = catalog_.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else { owner = catalog_.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog_.addRolePrivilege(ownerString, filter); owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } catch (CatalogException e) { LOG.error("Error adding privilege: ", e); } } /** * Create a new HMS Partition. */ private static Partition createHmsPartition(List<TPartitionKeyValue> partitionSpec, org.apache.hadoop.hive.metastore.api.Table msTbl, TableName tableName, String location) {
response: public void addPrivilegeAndCatalogObject(String ownerString, PrincipalType ownerType, Filter filter, User existingUser, Catalog catalog, Response response) { Principal owner; Privilege cPrivilege; if (ownerType == PrincipalType.USER) { owner = catalog.addUserIfNotExists(ownerString, existingUser); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.USER); cPrivilege = catalog.addUserPrivilege(ownerString, filter); } else { owner = catalog.getAuthPolicy().getRole(ownerString); filter.setPrincipal_id(owner.getId()); filter.setPrincipal_type(TPrincipalType.ROLE); cPrivilege = catalog.addRolePrivilege(ownerString, filter); } if (!existingUser.getRef()) { owner.setCatalogVersion(catalog.incrementAndGetCatalogVersion()); } response.result.addToUpdated_catalog_objects(cPrivilege.toTCatalogObject()); response.result.addToUpdated_catalog_objects(owner.toTCatalogObject()); } private static Partition createHmsPartition(List<TPartitionKeyValue> partitionSpec, org.apache.hadoop.hive.metastore.api.Table msTbl, TableName tableName, String location) { // implementation details }

sample: 1213
buggy_code:  } /** * Grants or revokes one or more privileges to/from a Sentry role on behalf of the * requestingUser. */ private void grantRevokeRolePrivilege(User requestingUser, TGrantRevokePrivParams grantRevokePrivParams, TDdlExecResponse resp) throws ImpalaException { Preconditions.checkNotNull(requestingUser); verifySentryServiceEnabled(); String roleName = grantRevokePrivParams.getRole_name(); List<TPrivilege> privileges = grantRevokePrivParams.getPrivileges(); List<PrincipalPrivilege> addedRolePrivileges = null; <|startfocus|> List<PrincipalPrivilege> removedGrantOptPrivileges = Lists.newArrayList(); <|endfocus|> if (grantRevokePrivParams.isIs_grant()) { addedRolePrivileges = catalog_.getSentryProxy().grantRolePrivileges(requestingUser, roleName, privileges); addSummary(resp, "Privilege(s) have been granted."); } else { // If this is a revoke of a privilege that contains the grant option, the privileges // with the grant option will be revoked and new privileges without the grant option // will be added. The privilege in the catalog cannot simply be updated since the
code_review:  Just use new ArrayList<>(), or better give an estimated size. Also you allocate it here but may overwrite later 
target code: } /** * Grants or revokes one or more privileges to/from a Sentry role on behalf of the * requestingUser. */ private void grantRevokeRolePrivilege(User requestingUser, TGrantRevokePrivParams grantRevokePrivParams, TDdlExecResponse resp) throws ImpalaException { Preconditions.checkNotNull(requestingUser); verifySentryServiceEnabled(); String roleName = grantRevokePrivParams.getRole_name(); List<TPrivilege> privileges = grantRevokePrivParams.getPrivileges(); List<PrincipalPrivilege> addedRolePrivileges = null; List<PrincipalPrivilege> removedGrantOptPrivileges = Lists.newArrayListWithExpectedSize(privileges.size()); if (grantRevokePrivParams.isIs_grant()) { addedRolePrivileges = catalog_.getSentryProxy().grantRolePrivileges(requestingUser, roleName, privileges); addSummary(resp, "Privilege(s) have been granted."); } else { // If this is a revoke of a privilege that contains the grant option, the privileges // with the grant option will be revoked and new privileges without the grant option // will be added. The privilege in the catalog cannot simply be updated since the
response: public List<IPresentationReconciler> getPresentationReconcilers(ISourceViewer sourceViewer, Set<IContentType> contentTypes) { if (this.outOfSync) { sync(); } List<IPresentationReconciler> res = new ArrayList<>(); for (PresentationReconcilerExtension ext : this.extensions.values()) { if (contentTypes.contains(ext.targetContentType)) { res.add(ext); } } return res; } public static void $noinline$foo(int a, int b, int c) { c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); c = c / 42; "".charAt(c); } private static String toLowerFirst(String word) { return word.substring(0, 1).toLowerCase() + word.substring(1); } private static void writeClassFile(Path outputFilePath, StringBuilder builder, boolean force) { File parentFolder = outputFilePath.toFile().getParentFile(); if (!parentFolder.exists()) { parentFolder.mkdirs(); } if (!outputFilePath.toFile().exists() || force) { try { Files.write(outputFilePath, builder.toString().getBytes()); } catch (IOException e) { e.printStackTrace(); } } } private void grantRevokeRolePrivilege(User requestingUser, TGrantRevokePrivParams grantRevokePrivParams, TDdlExecResponse resp) throws ImpalaException { Preconditions.checkNotNull(requestingUser); verifySentryServiceEnabled(); String roleName = grantRevokePrivParams.getRole_name(); List<TPrivilege> privileges = grantRevokePrivParams.getPrivileges(); List<PrincipalPrivilege> addedRolePrivileges = null; List<PrincipalPrivilege> removedGrantOptPrivileges = new ArrayList<>(); if (grantRevokePrivParams.isIs_grant()) { addedRolePrivileges = catalog_.getSentryProxy().grantRolePrivileges(requestingUser, roleName, privileges); addSummary(resp, "Privilege(s) have been granted

sample: 1214
buggy_code:  // list of the revoked privileges that contain the grant option. The // addedRolePrivileges parameter will contain a list of new privileges without the // grant option that are granted. If this is simply a revoke of a privilege without // grant options, the api will still return revoked privileges, but the // addedRolePrivileges will be empty since there will be no newly granted // privileges. <|startfocus|> addedRolePrivileges = Lists.newArrayList(); <|endfocus|> removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } 
code_review:  Just use new ArrayList<>() (or better specify the size) 
target code: // list of the revoked privileges that contain the grant option. The // addedRolePrivileges parameter will contain a list of new privileges without the // grant option that are granted. If this is simply a revoke of a privilege without // grant options, the api will still return revoked privileges, but the // addedRolePrivileges will be empty since there will be no newly granted // privileges. addedRolePrivileges = Lists.newArrayListWithExpectedSize(privileges.size()); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); }
response: private PluginConfigInfo getPluginInfo() { PluginConfigInfo info = new PluginConfigInfo(); info.hasAvatars = toBoolean(avatar.get() != null); info.jsResourcePaths = new ArrayList<>(); for (WebUiPlugin u : plugins) { info.jsResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath())); } return info; } private List<AccountExternalId.Key> filterKeysByScheme(String keyScheme, ResultSet<AccountExternalId> externalIds) { List<AccountExternalId.Key> filteredExternalIds = new ArrayList<>(); for (AccountExternalId accountExternalId : externalIds) { if (accountExternalId.isScheme(keyScheme)) { filteredExternalIds.add(accountExternalId.getKey()); } } return filteredExternalIds; } public List<IPresentationReconciler> getPresentationReconcilers(ISourceViewer sourceViewer, Set<IContentType> contentTypes) { if (this.outOfSync) { sync(); } List<IPresentationReconciler> res = new ArrayList<>(); for (PresentationReconcilerExtension ext : this.extensions.values()) { if (contentTypes.contains(ext.targetContentType)) { res.add(ext); } } return res; } // list of the revoked privileges that contain the grant option. The // addedRolePrivileges parameter will contain a list of new privileges without the // grant option that are granted. If this is simply a revoke of a privilege without // grant options, the api will still return revoked privileges, but the // addedRolePrivileges will be empty since there will be no newly granted // privileges. addedRolePrivileges = new ArrayList<>(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = new ArrayList<>(); for (PrincipalPrivilege rolePriv : addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = new ArrayList<>(); for (PrincipalPrivilege rolePriv : removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTC

sample: 1215
buggy_code:  // grant options, the api will still return revoked privileges, but the // addedRolePrivileges will be empty since there will be no newly granted // privileges. addedRolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(addedRolePrivileges); <|startfocus|> List<TCatalogObject> updatedPrivs = Lists.newArrayList(); <|endfocus|> for (PrincipalPrivilege rolePriv: addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog.
code_review:  Just use new ArrayList(addedRolePrivileges.size()). Also if you know that it will be an empty list or 1-element list you can avoid allocations at all. 
target code: // grant options, the api will still return revoked privileges, but the // addedRolePrivileges will be empty since there will be no newly granted // privileges. addedRolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayListWithExpectedSize(addedRolePrivileges.size()); for (PrincipalPrivilege rolePriv: addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog.
response: // grant options, the api will still return revoked privileges, but the // addedRolePrivileges will be empty since there will be no newly granted // privileges. addedRolePrivileges = new ArrayList<>(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = new ArrayList<>(addedRolePrivileges.size()); for (PrincipalPrivilege rolePriv : addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = new ArrayList<>(removedGrantOptPrivileges.size()); for (PrincipalPrivilege rolePriv : removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. }

sample: 1216
buggy_code:  // privileges. addedRolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } <|startfocus|> List<TCatalogObject> removedPrivs = Lists.newArrayList(); <|endfocus|> for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion(
code_review:  Same as above. 
target code: // privileges. addedRolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); } Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv: addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayListWithExpectedSize(removedGrantOptPrivileges.size()); for (PrincipalPrivilege rolePriv: removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion(
response: // privileges. addedRolePrivileges = Lists.newArrayList(); removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), addedRolePrivileges); addSummary(resp, "Privilege(s) have been revoked."); Preconditions.checkNotNull(addedRolePrivileges); List<TCatalogObject> updatedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv : addedRolePrivileges) { updatedPrivs.add(rolePriv.toTCatalogObject()); } List<TCatalogObject> removedPrivs = Lists.newArrayList(); for (PrincipalPrivilege rolePriv : removedGrantOptPrivileges) { removedPrivs.add(rolePriv.toTCatalogObject()); } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion(...); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion(...); } }

sample: 1217
buggy_code:  } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion( updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version()); <|startfocus|> } else if (privileges.get(0).isHas_grant_opt()) { <|endfocus|> resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion( getLastItemVersion(updatedPrivs) > getLastItemVersion(removedPrivs) ? getLastItemVersion(updatedPrivs) : getLastItemVersion(removedPrivs)); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion( removedPrivs.get(removedPrivs.size() - 1).getCatalog_version()); } } } /** * Returns the version from the last item in the list. This assumes that the items
code_review:  can privileges be empty? 
target code: } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { // If this is a REVOKE statement with hasGrantOpt, only the GRANT OPTION is removed // from the privileges. Otherwise the privileges are removed from the catalog. if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion( updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version()); } } else if (privileges.get(0).isHas_grant_opt()) { if (!updatedPrivs.isEmpty() && !removedPrivs.isEmpty()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion( getLastItemVersion(updatedPrivs) > getLastItemVersion(removedPrivs) ? getLastItemVersion(updatedPrivs) : getLastItemVersion(removedPrivs)); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion( removedPrivs.get(removedPrivs.size() - 1).getCatalog_version()); } } } /** * Returns the version from the last item in the list. This assumes that the items
response: } if (!updatedPrivs.isEmpty() || !removedPrivs.isEmpty()) { if (grantRevokePrivParams.isIs_grant()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setVersion(updatedPrivs.get(updatedPrivs.size() - 1).getCatalog_version()); } else if (!privileges.isEmpty() && privileges.get(0).isHas_grant_opt()) { resp.result.setUpdated_catalog_objects(updatedPrivs); resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion(getLastItemVersion(updatedPrivs) > getLastItemVersion(removedPrivs) ? getLastItemVersion(updatedPrivs) : getLastItemVersion(removedPrivs)); } else { resp.result.setRemoved_catalog_objects(removedPrivs); resp.result.setVersion(removedPrivs.get(removedPrivs.size() - 1).getCatalog_version()); } } } /** * Returns the version from the last item in the list. This assumes that the items */

sample: 1218
buggy_code:  } /** * Throws a CatalogException if the Sentry Service is not enabled. */ private void verifySentryServiceEnabled() throws CatalogException { if (catalog_.getSentryProxy() == null) { throw new CatalogException("Sentry Service is not enabled on the " + "CatalogServer."); } } /** * Checks if with grant is enabled for object ownership in Sentry. */ private boolean isObjectOwnershipGrantEnabled() { <|startfocus|> if (catalog_.getSentryProxy() == null) return false; return catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); <|endfocus|> } /** * Alters partitions in batches of size 'MAX_PARTITION_UPDATES_PER_RPC'. This * reduces the time spent in a single update and helps avoid metastore client * timeouts. */ private void bulkAlterPartitions(String dbName, String tableName, List<HdfsPartition> modifiedParts) throws ImpalaException { List<org.apache.hadoop.hive.metastore.api.Partition> hmsPartitions = Lists.newArrayList(); for (HdfsPartition p: modifiedParts) {
code_review:  Style: use ? : operator 
target code: } /** * Throws a CatalogException if the Sentry Service is not enabled. */ private void verifySentryServiceEnabled() throws CatalogException { if (catalog_.getSentryProxy() == null) { throw new CatalogException("Sentry Service is not enabled on the " + "CatalogServer."); } } /** * Checks if with grant is enabled for object ownership in Sentry. */ private boolean isObjectOwnershipGrantEnabled() { return catalog_.getSentryProxy() == null ? false : catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); } /** * Alters partitions in batches of size 'MAX_PARTITION_UPDATES_PER_RPC'. This * reduces the time spent in a single update and helps avoid metastore client * timeouts. */ private void bulkAlterPartitions(String dbName, String tableName, List<HdfsPartition> modifiedParts) throws ImpalaException { List<org.apache.hadoop.hive.metastore.api.Partition> hmsPartitions = Lists.newArrayList(); for (HdfsPartition p: modifiedParts) {
response: private boolean isObjectOwnershipGrantEnabled() { return catalog_.getSentryProxy() != null && catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); }

sample: 1219
buggy_code:  */ private void verifySentryServiceEnabled() throws CatalogException { if (catalog_.getSentryProxy() == null) { throw new CatalogException("Sentry Service is not enabled on the " + "CatalogServer."); } } /** * Checks if with grant is enabled for object ownership in Sentry. */ private boolean isObjectOwnershipGrantEnabled() { <|startfocus|> if (catalog_.getSentryProxy() == null) return false; return catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); <|endfocus|> } /** * Alters partitions in batches of size 'MAX_PARTITION_UPDATES_PER_RPC'. This * reduces the time spent in a single update and helps avoid metastore client * timeouts. */ private void bulkAlterPartitions(String dbName, String tableName, List<HdfsPartition> modifiedParts) throws ImpalaException { List<org.apache.hadoop.hive.metastore.api.Partition> hmsPartitions = Lists.newArrayList(); for (HdfsPartition p: modifiedParts) { org.apache.hadoop.hive.metastore.api.Partition msPart = p.toHmsPartition();
code_review:  Do we need any locking here? Can getSentryProxy() become null after the check? 
target code: */ private void verifySentryServiceEnabled() throws CatalogException { if (catalog_.getSentryProxy() == null) { throw new CatalogException("Sentry Service is not enabled on the " + "CatalogServer."); } } /** * Checks if with grant is enabled for object ownership in Sentry. */ private boolean isObjectOwnershipGrantEnabled() { return catalog_.getSentryProxy() == null ? false : catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); } /** * Alters partitions in batches of size 'MAX_PARTITION_UPDATES_PER_RPC'. This * reduces the time spent in a single update and helps avoid metastore client * timeouts. */ private void bulkAlterPartitions(String dbName, String tableName, List<HdfsPartition> modifiedParts) throws ImpalaException { List<org.apache.hadoop.hive.metastore.api.Partition> hmsPartitions = Lists.newArrayList(); for (HdfsPartition p: modifiedParts) { org.apache.hadoop.hive.metastore.api.Partition msPart = p.toHmsPartition();
response: private void verifySentryServiceEnabled() throws CatalogException { if (catalog_.getSentryProxy() == null) { throw new CatalogException("Sentry Service is not enabled on the CatalogServer."); } } private boolean isObjectOwnershipGrantEnabled() { if (catalog_.getSentryProxy() == null) { return false; } return catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); } private void bulkAlterPartitions(String dbName, String tableName, List<HdfsPartition> modifiedParts) throws ImpalaException { List<org.apache.hadoop.hive.metastore.api.Partition> hmsPartitions = Lists.newArrayList(); for (HdfsPartition p : modifiedParts) { org.apache.hadoop.hive.metastore.api.Partition msPart = p.toHmsPartition(); // perform bulk alter operation } }

sample: 1220
buggy_code:  originalOwnerName = msDb.getOwnerName(); originalOwnerType = msDb.getOwnerType(); msDb.setOwnerName(params.owner_name); msDb.setOwnerType(PrincipalType.valueOf(params.owner_type.name())); try { applyAlterDatabase(db); } catch (ImpalaRuntimeException e) { msDb.setOwnerName(originalOwnerName); msDb.setOwnerType(originalOwnerType); throw e; } } addDbToCatalogUpdate(db, response.result); <|startfocus|> updateOwnerPrivileges(db.getName(), /* tableName */ null, params.server_name, originalOwnerName, originalOwnerType, db.getMetaStoreDb().getOwnerName(), db.getMetaStoreDb().getOwnerType(), response); <|endfocus|> addSummary(response, "Updated database."); } private void addDbToCatalogUpdate(Db db, TCatalogUpdateResult result) { Preconditions.checkNotNull(db); // Updating the new catalog version and setting it to the DB catalog version while // holding the catalog version lock for an atomic operation. Most DB operations are // short-lived. It is unnecessary to have a fine-grained DB lock.
code_review:  Is there a chance that we do this for the wrong database in case of a race condition? 
target code: originalOwnerName = msDb.getOwnerName(); originalOwnerType = msDb.getOwnerType(); msDb.setOwnerName(params.owner_name); msDb.setOwnerType(PrincipalType.valueOf(params.owner_type.name())); try { applyAlterDatabase(db); } catch (ImpalaRuntimeException e) { msDb.setOwnerName(originalOwnerName); msDb.setOwnerType(originalOwnerType); throw e; } } addDbToCatalogUpdate(db, response.result); addSummary(response, "Updated database."); } private void addDbToCatalogUpdate(Db db, TCatalogUpdateResult result) { Preconditions.checkNotNull(db); // Updating the new catalog version and setting it to the DB catalog version while // holding the catalog version lock for an atomic operation. Most DB operations are // short-lived. It is unnecessary to have a fine-grained DB lock.
response: originalOwnerName = msDb.getOwnerName(); originalOwnerType = msDb.getOwnerType(); msDb.setOwnerName(params.owner_name); msDb.setOwnerType(PrincipalType.valueOf(params.owner_type.name())); try { applyAlterDatabase(db); } catch (ImpalaRuntimeException e) { msDb.setOwnerName(originalOwnerName); msDb.setOwnerType(originalOwnerType); throw e; } addDbToCatalogUpdate(db, response.result); updateOwnerPrivileges(db.getName(), /* tableName */ null, params.server_name, originalOwnerName, originalOwnerType, db.getMetaStoreDb().getOwnerName(), db.getMetaStoreDb().getOwnerType(), response); addSummary(response, "Updated database."); private void addDbToCatalogUpdate(Db db, TCatalogUpdateResult result) { Preconditions.checkNotNull(db); // Updating the new catalog version and setting it to the DB catalog version while // holding the catalog version lock for an atomic operation. Most DB operations are // short-lived. It is unnecessary to have a fine-grained DB lock. }

sample: 1221
buggy_code:  } throw new InternalException(String.format("Error making '%s' RPC to " + "Sentry Service: ", type == TPrincipalType.ROLE ? "listAllRolesPrivileges" : "listAllUsersPrivileges"), e); } finally { client.close(); } } /** * Returns the configuration value for the specified key. Will return an empty string * if no value is set. */ public String getConfigValue(String key) throws ImpalaException { <|startfocus|> SentryServiceClient client = new SentryServiceClient(); try { <|endfocus|> return client.get().getConfigValue(key, ""); } catch (SentryUserException e) { throw new InternalException("Error making 'getConfigValue' RPC to Sentry Service: ", e); } finally { client.close(); } } /** * Utility function that converts a TSentryPrivilege to an Impala TPrivilege object. */ public static TPrivilege sentryPrivilegeToTPrivilege(TSentryPrivilege sentryPriv, Principal principal) { TPrivilege privilege = new TPrivilege(); privilege.setServer_name(sentryPriv.getServerName());
code_review:  Use try-as-resource construct to open a client 
target code: } throw new InternalException(String.format("Error making '%s' RPC to " + "Sentry Service: ", type == TPrincipalType.ROLE ? "listAllRolesPrivileges" : "listAllUsersPrivileges"), e); } finally { client.close(); } } /** * Returns the configuration value for the specified key. Will return an empty string * if no value is set. */ public String getConfigValue(String key) throws ImpalaException { try (SentryServiceClient client = new SentryServiceClient()) { return client.get().getConfigValue(key, ""); } catch (SentryUserException e) { throw new InternalException("Error making 'getConfigValue' RPC to Sentry Service: ", e); } finally { client.close(); } } /** * Utility function that converts a TSentryPrivilege to an Impala TPrivilege object. */ public static TPrivilege sentryPrivilegeToTPrivilege(TSentryPrivilege sentryPriv, Principal principal) { TPrivilege privilege = new TPrivilege(); privilege.setServer_name(sentryPriv.getServerName());
response: public String getCommitSummary() { try (Repository git = args.server.openRepository(project); RevWalk rw = new RevWalk(git); RevWalk merged = new RevWalk(git)) { RevCommit oldId = rw.parseCommit(cmd.getOldId()); RevCommit newId = rw.parseCommit(cmd.getNewId()); rw.reset(); rw.setRevFilter(RevFilter.MERGE_BASE); rw.markStart(rw.parseCommit(oldId)); rw.markStart(rw.parseCommit(newId)); // Find a merge base RevCommit mergeBase = rw.next(); rw.reset(); rw.markStart(oldId); rw.markStart(newId); rw.markUninteresting(mergeBase); RevCommit c; String result = ""; while ((c = rw.next()) != null) { rw.parseBody(c); if (merged.isMergedInto(c, newId)) { result += "+" + c.abbreviate(12) + " " + c.getShortMessage() + "\n"; } else { // Handle other cases } } return result; } } int loopStart = expr.hasCaseExpr() ? 1 : 0; boolean canSimplify = false; for (int i = loopStart; i < numChildren - 1; i += 2) { if (expr.getChild(i).isLiteral()) { canSimplify = true; break; } } if (!canSimplify) { return expr; } List<CaseWhenClause> newWhenClauses = new ArrayList<CaseWhenClause>(); Expr elseExpr = null; for (int i = loopStart; i < numChildren - 1; i += 2) { Expr child = expr.getChild(i); if (child instanceof NullLiteral) { continue; } Expr whenExpr; if (expr.hasCaseExpr()) { if (child.isLiteral()) { BinaryPredicate pred = new BinaryPredicate( BinaryPredicate.Operator.EQ, caseExpr, expr.getChild(i)); // Handle other cases } } } Assert.assertEquals(2, getCount(helper.getCompilerStateFolder(), FileType.JAYCE)); Assert.assertEquals(2, getCount(outputJack, FileType.JAYCE)); @Nonnegative private int getCount(@Nonnull File lib, @Nonnull FileType fileType) throws LibraryIOException { int size =

sample: 1222
buggy_code:  public SentryProxy(SentryConfig sentryConfig, CatalogServiceCatalog catalog, String kerberosPrincipal) throws ImpalaException { Preconditions.checkNotNull(catalog); Preconditions.checkNotNull(sentryConfig); catalog_ = catalog; if (Strings.isNullOrEmpty(kerberosPrincipal)) { processUser_ = new User(System.getProperty("user.name")); } else { processUser_ = new User(kerberosPrincipal); } sentryPolicyService_ = new SentryPolicyService(sentryConfig); // For some tests, we create a config but may not have a config file. <|startfocus|> if (sentryConfig.getConfigFile() != null && sentryConfig.getConfigFile().length()>0) { <|endfocus|> objectOwnershipConfigValue_ = sentryPolicyService_ .getConfigValue(ServiceConstants.ServerConfig .SENTRY_DB_POLICY_STORE_OWNER_AS_PRIVILEGE); } else { objectOwnershipConfigValue_ = SentryOwnerPrivilegeType.NONE.toString(); } policyReader_.scheduleAtFixedRate(new PolicyReader(false), 0, BackendConfig.INSTANCE.getSentryCatalogPollingFrequency(), TimeUnit.SECONDS); } /** * Refreshes the authorization policy metadata by querying the Sentry Policy Service.
code_review:  Why do you need config file? 
target code: public SentryProxy(SentryConfig sentryConfig, CatalogServiceCatalog catalog, String kerberosPrincipal) throws ImpalaException { Preconditions.checkNotNull(catalog); Preconditions.checkNotNull(sentryConfig); catalog_ = catalog; if (Strings.isNullOrEmpty(kerberosPrincipal)) { processUser_ = new User(System.getProperty("user.name")); } else { processUser_ = new User(kerberosPrincipal); } sentryPolicyService_ = new SentryPolicyService(sentryConfig); // For some tests, we create a config but may not have a config file. if (sentryConfig.getConfigFile() != null && !sentryConfig.getConfigFile().isEmpty()) { objectOwnershipConfigValue_ = sentryPolicyService_ .getConfigValue(ServiceConstants.ServerConfig .SENTRY_DB_POLICY_STORE_OWNER_AS_PRIVILEGE); } else { objectOwnershipConfigValue_ = SentryOwnerPrivilegeType.NONE.toString(); } policyReader_.scheduleAtFixedRate(new PolicyReader(false), 0, BackendConfig.INSTANCE.getSentryCatalogPollingFrequency(), TimeUnit.SECONDS); } /** * Refreshes the authorization policy metadata by querying the Sentry Policy Service.
response: public SentryProxy(SentryConfig sentryConfig, CatalogServiceCatalog catalog, String kerberosPrincipal) throws ImpalaException { Preconditions.checkNotNull(catalog); Preconditions.checkNotNull(sentryConfig); catalog_ = catalog; if (Strings.isNullOrEmpty(kerberosPrincipal)) { processUser_ = new User(System.getProperty("user.name")); } else { processUser_ = new User(kerberosPrincipal); } sentryPolicyService_ = new SentryPolicyService(sentryConfig); if (sentryConfig.getConfigFile() != null && sentryConfig.getConfigFile().length() > 0) { objectOwnershipConfigValue_ = sentryPolicyService_ .getConfigValue(ServiceConstants.ServerConfig.SENTRY_DB_POLICY_STORE_OWNER_AS_PRIVILEGE); } else { objectOwnershipConfigValue_ = SentryOwnerPrivilegeType.NONE.toString(); } policyReader_.scheduleAtFixedRate(new PolicyReader(false), 0, BackendConfig.INSTANCE.getSentryCatalogPollingFrequency(), TimeUnit.SECONDS); } /** * Refreshes the authorization policy metadata by querying the Sentry Policy Service. */

sample: 1223
buggy_code:  Preconditions.checkNotNull(catalog); Preconditions.checkNotNull(sentryConfig); catalog_ = catalog; if (Strings.isNullOrEmpty(kerberosPrincipal)) { processUser_ = new User(System.getProperty("user.name")); } else { processUser_ = new User(kerberosPrincipal); } sentryPolicyService_ = new SentryPolicyService(sentryConfig); // For some tests, we create a config but may not have a config file. <|startfocus|> if (sentryConfig.getConfigFile() != null && sentryConfig.getConfigFile().length()>0) { <|endfocus|> objectOwnershipConfigValue_ = sentryPolicyService_ .getConfigValue(ServiceConstants.ServerConfig .SENTRY_DB_POLICY_STORE_OWNER_AS_PRIVILEGE); } else { objectOwnershipConfigValue_ = SentryOwnerPrivilegeType.NONE.toString(); } policyReader_.scheduleAtFixedRate(new PolicyReader(false), 0, BackendConfig.INSTANCE.getSentryCatalogPollingFrequency(), TimeUnit.SECONDS); } /** * Refreshes the authorization policy metadata by querying the Sentry Policy Service. * There is currently no way to get a snapshot of the policy from the Sentry Service,
code_review:  use isEmpty() 
target code: Preconditions.checkNotNull(catalog); Preconditions.checkNotNull(sentryConfig); catalog_ = catalog; if (Strings.isNullOrEmpty(kerberosPrincipal)) { processUser_ = new User(System.getProperty("user.name")); } else { processUser_ = new User(kerberosPrincipal); } sentryPolicyService_ = new SentryPolicyService(sentryConfig); // For some tests, we create a config but may not have a config file. if (sentryConfig.getConfigFile() != null && !sentryConfig.getConfigFile().isEmpty()) { objectOwnershipConfigValue_ = sentryPolicyService_ .getConfigValue(ServiceConstants.ServerConfig .SENTRY_DB_POLICY_STORE_OWNER_AS_PRIVILEGE); } else { objectOwnershipConfigValue_ = SentryOwnerPrivilegeType.NONE.toString(); } policyReader_.scheduleAtFixedRate(new PolicyReader(false), 0, BackendConfig.INSTANCE.getSentryCatalogPollingFrequency(), TimeUnit.SECONDS); } /** * Refreshes the authorization policy metadata by querying the Sentry Policy Service. * There is currently no way to get a snapshot of the policy from the Sentry Service,
response: Preconditions.checkNotNull(catalog); Preconditions.checkNotNull(sentryConfig); catalog_ = catalog; if (Strings.isNullOrEmpty(kerberosPrincipal)) { processUser_ = new User(System.getProperty("user.name")); } else { processUser_ = new User(kerberosPrincipal); } sentryPolicyService_ = new SentryPolicyService(sentryConfig); if (!sentryConfig.getConfigFile().isEmpty()) { objectOwnershipConfigValue_ = sentryPolicyService_ .getConfigValue(ServiceConstants.ServerConfig .SENTRY_DB_POLICY_STORE_OWNER_AS_PRIVILEGE); } else { objectOwnershipConfigValue_ = SentryOwnerPrivilegeType.NONE.toString(); } policyReader_.scheduleAtFixedRate(new PolicyReader(false), 0, BackendConfig.INSTANCE.getSentryCatalogPollingFrequency(), TimeUnit.SECONDS); } /** * Refreshes the authorization policy metadata by querying the Sentry Policy Service. * There is currently no way to get a snapshot of the policy from the Sentry Service, * so this method is called periodically to update the policy. */ private void refreshAuthorizationPolicy() { // Implementation goes here }

sample: 1224
buggy_code: // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.kudu.util; import javax.annotation.concurrent.NotThreadSafe; import java.nio.charset.StandardCharsets; import com.sangupta.murmur.Murmur2; import org.apache.yetus.audience.InterfaceAudience; import org.apache.yetus.audience.InterfaceStability; @InterfaceAudience.Public @InterfaceStability.Unstable @NotThreadSafe public class BloomFilter { <|startfocus|> private int nBits; private byte[] bitmap; private int nHashes; private byte[] byteBuffer; private HashFunction hashFunction; <|endfocus|> private BloomFilter(int nBits, byte[] bitmap, int nHashes, HashFunction hashFunction) { this.nBits = nBits; this.bitmap = bitmap; this.nHashes = nHashes; this.hashFunction = hashFunction; byteBuffer = new byte[8]; } public static BloomFilter BySizeAndFPRate(int nBytes, double fpRate) { return BySizeAndFPRate(nBytes, fpRate, HashFunctions.MURMUR2);
code_review:  Could you add Javadocs to the class as well as to all public non-visiblefortesting methods, explaining how they work and how to use them? 
target code: // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.kudu.util; import javax.annotation.concurrent.NotThreadSafe; import java.nio.charset.StandardCharsets; import com.sangupta.murmur.Murmur2; import org.apache.yetus.audience.InterfaceAudience; import org.apache.yetus.audience.InterfaceStability; @InterfaceAudience.Public @InterfaceStability.Unstable @NotThreadSafe public class BloomFilter { private final int nBits; private final BitSet bitSet; private final int nHashes; private final byte[] byteBuffer; private final HashFunction hashFunction; private BloomFilter(int nBits, byte[] bitmap, int nHashes, HashFunction hashFunction) { this.nBits = nBits; this.bitmap = bitmap; this.nHashes = nHashes; this.hashFunction = hashFunction; byteBuffer = new byte[8]; } public static BloomFilter BySizeAndFPRate(int nBytes, double fpRate) { return BySizeAndFPRate(nBytes, fpRate, HashFunctions.MURMUR2);
response: // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.kudu.util; import javax.annotation.concurrent.NotThreadSafe; import java.nio.charset.StandardCharsets; import com.sangupta.murmur.Murmur2; import org.apache.yetus.audience.InterfaceAudience; import org.apache.yetus.audience.InterfaceStability; /** * A Bloom filter implementation. */ @InterfaceAudience.Public @InterfaceStability.Unstable @NotThreadSafe public class BloomFilter { private int nBits; private byte[] bitmap; private int nHashes; private byte[] byteBuffer; private HashFunction hashFunction; private BloomFilter(int nBits, byte[] bitmap, int nHashes, HashFunction hashFunction) { this.nBits = nBits; this.bitmap = bitmap; this.nHashes = nHashes; this.hashFunction = hashFunction; byteBuffer = new byte[8]; } /** * Create a Bloom filter with the given size and false positive rate. * * @param nBytes the number of bytes for the Bloom filter * @param fpRate the desired false positive rate * @return the created Bloom filter */ public static BloomFilter BySizeAndFPRate(int nBytes, double fpRate) { return BySizeAndFPRate(nBytes, fpRate, HashFunctions.MURMUR2); } }

sample: 1225
buggy_code: // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.kudu.util; import javax.annotation.concurrent.NotThreadSafe; import java.nio.charset.StandardCharsets; import com.sangupta.murmur.Murmur2; import org.apache.yetus.audience.InterfaceAudience; import org.apache.yetus.audience.InterfaceStability; @InterfaceAudience.Public @InterfaceStability.Unstable @NotThreadSafe public class BloomFilter { <|startfocus|> private int nBits; private byte[] bitmap; private int nHashes; private byte[] byteBuffer; private HashFunction hashFunction; <|endfocus|> private BloomFilter(int nBits, byte[] bitmap, int nHashes, HashFunction hashFunction) { this.nBits = nBits; this.bitmap = bitmap; this.nHashes = nHashes; this.hashFunction = hashFunction; byteBuffer = new byte[8]; } public static BloomFilter BySizeAndFPRate(int nBytes, double fpRate) { return BySizeAndFPRate(nBytes, fpRate, HashFunctions.MURMUR2); } 
code_review:  Curious why you chose to implement your own bitmap instead of reusing java.util.BitSet? 
target code: // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.kudu.util; import javax.annotation.concurrent.NotThreadSafe; import java.nio.charset.StandardCharsets; import com.sangupta.murmur.Murmur2; import org.apache.yetus.audience.InterfaceAudience; import org.apache.yetus.audience.InterfaceStability; @InterfaceAudience.Public @InterfaceStability.Unstable @NotThreadSafe public class BloomFilter { private final int nBits; private final BitSet bitSet; private final int nHashes; private final byte[] byteBuffer; private final HashFunction hashFunction; private BloomFilter(int nBits, byte[] bitmap, int nHashes, HashFunction hashFunction) { this.nBits = nBits; this.bitmap = bitmap; this.nHashes = nHashes; this.hashFunction = hashFunction; byteBuffer = new byte[8]; } public static BloomFilter BySizeAndFPRate(int nBytes, double fpRate) { return BySizeAndFPRate(nBytes, fpRate, HashFunctions.MURMUR2); }
response: // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.kudu.util; import javax.annotation.concurrent.NotThreadSafe; import java.nio.charset.StandardCharsets; import com.sangupta.murmur.Murmur2; import org.apache.yetus.audience.InterfaceAudience; import org.apache.yetus.audience.InterfaceStability; import java.util.BitSet; @InterfaceAudience.Public @InterfaceStability.Unstable @NotThreadSafe public class BloomFilter { private BitSet bitmap; private int nHashes; private byte[] byteBuffer; private HashFunction hashFunction; private BloomFilter(BitSet bitmap, int nHashes, HashFunction hashFunction) { this.bitmap = bitmap; this.nHashes = nHashes; this.hashFunction = hashFunction; byteBuffer = new byte[8]; } public static BloomFilter BySizeAndFPRate(int nBytes, double fpRate) { return BySizeAndFPRate(nBytes, fpRate, HashFunctions.MURMUR2); } }

sample: 1226
buggy_code:  public static BloomFilter ByCountAndFPRate(int expectedCount, double fpRate, HashFunction hashFunction) { int nBytes = optimalNumOfBytes(expectedCount, fpRate); int nBits = nBytes * 8; <|startfocus|> byte[] bitmap = new byte[nBytes]; int nHashes = computeOptimalHashCount(nBytes, optimalExpectedCount(nBytes, fpRate)); return new BloomFilter(nBits, bitmap, nHashes, hashFunction); <|endfocus|>
code_review:  Shouldn't this be nBits? I'm surprised this worked as-is; could you add a unit test that would fail or malfunction when this is nBytes? 
target code: public static BloomFilter ByCountAndFPRate(int expectedCount, double fpRate, HashFunction hashFunction) { int nBytes = optimalNumOfBytes(expectedCount, fpRate); int nBits = nBytes * 8; int nHashes = computeOptimalHashCount(nBits, expectedCount); return new BloomFilter(new BitSet(nBits), nHashes, hashFunction);
response: public static BloomFilter ByCountAndFPRate(int expectedCount, double fpRate, HashFunction hashFunction) { int nBytes = optimalNumOfBytes(expectedCount, fpRate); int nBits = nBytes * 8; byte[] bitmap = new byte[nBits / 8]; int nHashes = computeOptimalHashCount(nBits, optimalExpectedCount(nBits, fpRate)); return new BloomFilter(nBits, bitmap, nHashes, hashFunction); }

sample: 1227
buggy_code:  public void put(boolean data) { <|startfocus|> if (data) { byteBuffer[0] = 1; } else { byteBuffer[0] = 0; } updateBitmap(byteBuffer, 1); <|endfocus|>
code_review:  Nit: byteBuffer[0] = data ? 1 : 0; 
target code: public void put(boolean data) { byteBuffer[0] = (byte)(data ? 1 : 0); updateBitset(byteBuffer, 1);
response: public void put(boolean data) { byteBuffer[0] = data ? 1 : 0; updateBitmap(byteBuffer, 1); }


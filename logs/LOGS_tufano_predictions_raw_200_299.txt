sample: 200
buggy_code: public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) { StorageType storageType = diskImage.getStorageTypes().get(0); String diskType = getDiskType(vm, diskImage, device); boolean isNativeIO = !"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion())); // marked as transient disk (file type) and uses cache when snapshotId is not null if <START> (device.getSnapshotId() != null) { <END> isNativeIO = false; } return isNativeIO; }
code_review: So why not just add it to the boolean expression in line #1377?
target code: public boolean shouldUseNativeIO ( VM vm , DiskImage diskImage , VmDevice device ) { StorageType storageType = diskImage . getStorageTypes ( ) . get ( 0 ) ; String diskType = getDiskType ( vm , diskImage , device ) ; return ( ! "file" . equals ( diskType ) || ( storageType == StorageType . GLUSTERFS && FeatureSupported . useNativeIOForGluster ( vm . getCompatibilityVersion ( ) ) ) ) && device . getSnapshotId ( ) == null ; // marked as transient disk ( file type ) and uses cache when snapshotId is not null // so native io should not be used }
response: public boolean shouldUseNativeIO ( VM vm , DiskImage diskImage , VmDevice device ) { StorageType storageType = diskImage . getStorageTypes ( ) . get ( 0 ) ; String diskType = getDiskType ( vm , diskImage , device ) ; boolean isNativeIO = ! "file" . equals ( diskType ) || ( storageType == StorageType . GLUSTERFS && FeatureSupported . useNativeIOForGluster ( vm . getCompatibilityVersion ( ) ) ) || ( device . getSnapshotId ( ) != null && ! "file" . equals ( diskType ) ) ; return isNativeIO ; }

sample: 201
buggy_code: public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException { if (!isAnonymous()) { return execute(request, true, monitor); } <START> return execute(request, false, monitor); <END> }
code_review: Lines 316-319 can be rewritten as return execute(request, !isAnonymous(), monitor);
target code: public < T > T execute ( Request < T > request , IProgressMonitor monitor ) throws IOException , GerritException { return execute ( request , ! isAnonymous ( ) , monitor ) ; }
response: public < T > T execute ( Request < T > request , IProgressMonitor monitor ) throws IOException , GerritException { return execute ( request , ! isAnonymous ( ) , monitor ) ; }

sample: 202
buggy_code: public HighlightingInlineHyperlink(final String text, final String token, final String toHighlight) { super(text, token); <START> highlight(text, toHighlight); <END> }
code_review: Maybe highlight should be called from setText instead? That way, if the text is changed after construction it will get highlighted too.
target code: public HighlightingInlineHyperlink ( final String text , final String token , final String toHighlight ) { super ( text , token ) ; this . toHighlight = toHighlight ; highlight ( text , toHighlight ) ; }
response: public HighlightingInlineHyperlink ( final String text , final String token , final String toHighlight ) { super ( text , token ) ; setText ( text ) ; highlight ( toHighlight ) ; } @Override public void setText ( String text ) { super . setText ( text ) ; highlight ( toHighlight ) ; } private void highlight ( String toHighlight ) { // code to highlight the specified text }

sample: 203
buggy_code: <START> String serializeInstallCmd(Collection<String> packages) { <END> if (packages.isEmpty()) { return ""; } else { return CommandInfo.CMD_INSTALL + " " + String.join(" ", packages); } }
code_review: Not sure if this is guideline, I would prefer to use `protected` visibility rather than package protected one.
target code: protected String serializeInstallCmd ( Collection < String > packages ) { if ( packages . isEmpty ( ) ) { return "" ; } else { return CommandInfo . CMD_INSTALL + " " + String . join ( " " , packages ) ; } }
response: protected String serializeInstallCmd ( Collection < String > packages ) { if ( packages . isEmpty ( ) ) { return "" ; } else { return CommandInfo . CMD_INSTALL + " " + String . join ( " " , packages ) ; } }

sample: 204
buggy_code: private List roundtrip(List vals, Map conf) { List ret = null; try { ret = deserialize(serialize(vals, conf), conf); <START> } catch (IOException e) { <END> LOG.error("Exception when serialize/deserialize ", e); } return ret; }
code_review: I would prefer to have the IOException thrown by roundtrip. Catching it will still cause the test to fail, but it will be harder to debug.
target code: private List roundtrip ( List vals , Map conf ) throws IOException { return deserialize ( serialize ( vals , conf ) , conf ) ; }
response: private List roundtrip ( List vals , Map conf ) throws IOException { List ret = null ; try { ret = deserialize ( serialize ( vals , conf ) , conf ) ; } catch ( IOException e ) { LOG . error ( "Exception when serialize / deserialize " , e ) ; throw e ; } return ret ; }

sample: 205
buggy_code: public GlobalDirectoryResourceDefinition() { super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY)) <START> .setAddRestartLevel(OperationEntry.Flag.RE<START>_JVM) <END> .setRemoveRestartLevel(OperationEntry.Flag.RE<START>_JVM) .setAddHandler(GlobalDirectoryResourceDefinition.ADD) .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE) .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY) ); }
code_review: Why RESTART_JVM? AFAICT if I add this after boot the service is installed immediately. You'd have to redeploy any app for it to use the module, but that doesn't even require a reload much less a process restart.
target code: public GlobalDirectoryResourceDefinition ( ) { super ( new SimpleResourceDefinition . Parameters ( PathElement . pathElement ( EESubsystemModel . GLOBAL_DIRECTORY ) , EeExtension . getResourceDescriptionResolver ( EESubsystemModel . GLOBAL_DIRECTORY ) ) . setAddHandler ( GlobalDirectoryResourceDefinition . ADD ) . setRemoveHandler ( GlobalDirectoryResourceDefinition . REMOVE ) . setCapabilities ( EE_GLOBAL_DIRECTORY_CAPABILITY ) ) ; }
response: public GlobalDirectoryResourceDefinition ( ) { super ( new SimpleResourceDefinition . Parameters ( PathElement . pathElement ( EESubsystemModel . GLOBAL_DIRECTORY ) , EeExtension . getResourceDescriptionResolver ( EESubsystemModel . GLOBAL_DIRECTORY ) ) . setAddRestartLevel ( OperationEntry . Flag . NONE ) . setRemoveRestartLevel ( OperationEntry . Flag . NONE ) . setAddHandler ( GlobalDirectoryResourceDefinition . ADD ) . setRemoveHandler ( GlobalDirectoryResourceDefinition . REMOVE ) . setCapabilities ( EE_GLOBAL_DIRECTORY_CAPABILITY ) ) ; }

sample: 206
buggy_code: public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); <START> this.fChartViewer <END> = chartViewer; }
code_review: You can remove the this
target code: public LockRangeDialog ( Shell parentShell , TmfXYChartViewer chartViewer ) { super ( parentShell ) ; fChartViewer = chartViewer ; }
response: public LockRangeDialog ( Shell parentShell , TmfXYChartViewer chartViewer ) { super ( parentShell ) ; fChartViewer = chartViewer ; }

sample: 207
buggy_code: public String toStringShort() { <START> return MoreObjects.toStringHelper("") <END> .add("ClientType", getStringFromOptional(mClientType)) .add("ClientHostname", mLocalHostName) .add("ServerAddress", mServerAddress) .add("ChannelId", mChannelId) .omitNullValues() .toString(); }
code_review: I am confused when this is supposed to be "" or `this`?
target code: public String toStringShort ( ) { return MoreObjects . toStringHelper ( this ) . add ( "ClientType" , getStringFromOptional ( mClientType ) ) . add ( "ClientHostname" , mLocalHostName ) . add ( "ServerAddress" , mServerAddress ) . add ( "ChannelId" , mChannelId ) . omitNullValues ( ) . toString ( ) ; }
response: public String toStringShort ( ) { return MoreObjects . toStringHelper ( this ) . add ( "ClientType" , getStringFromOptional ( mClientType ) ) . add ( "ClientHostname" , mLocalHostName ) . add ( "ServerAddress" , mServerAddress ) . add ( "ChannelId" , mChannelId ) . omitNullValues ( ) . toString ( ) ; }  In the refactored code , `this` is used instead of an empty string to pass the object instance to the `toStringHelper` method .

sample: 208
buggy_code: public CompilationUnit() { <START> this(null, false, null, new NodeList<>(), new NodeList<>(), null); <END> }
code_review: for the boolean parameter could be useful to use enums, so that it is more clear what it means
target code: public CompilationUnit ( ) { this ( null , null , new NodeList < > ( ) , new NodeList < > ( ) , null ) ; }
response: public CompilationUnit ( ) { this ( null , CompilationMode . DEFAULT , null , new NodeList < > ( ) , new NodeList < > ( ) , null ) ; } where CompilationMode is an enum with possible values such as DEFAULT , STRICT , etc .

sample: 209
buggy_code: public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); <START> description = (String) command.getParam(PARAM_DESC); <END> }
code_review: cast is not needed.
target code: public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; description = command . getParam ( PARAM_DESC ) ; }
response: public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; String description = command . getParam ( PARAM_DESC ) ; }

sample: 210
buggy_code: protected void executeQueryCommand() { <START> Provider provider = getDbFacade().getProviderDao().get(getParameters().getId()); <END> NetworkProviderProxy client = getProviderProxyFactory().create(provider); getQueryReturnValue().setReturnValue(client.getAll()); }
code_review: shouldn't provider be validated for existence prior to accessing it?
target code: protected void executeQueryCommand ( ) { Provider < ? > provider = getDbFacade ( ) . getProviderDao ( ) . get ( getParameters ( ) . getId ( ) ) ; NetworkProviderProxy client = getProviderProxyFactory ( ) . create ( provider ) ; getQueryReturnValue ( ) . setReturnValue ( client . getAll ( ) ) ; }
response: protected void executeQueryCommand ( ) { Provider provider = getDbFacade ( ) . getProviderDao ( ) . get ( getParameters ( ) . getId ( ) ) ; if ( provider == null ) { // handle error or throw exception } NetworkProviderProxy client = getProviderProxyFactory ( ) . create ( provider ) ; getQueryReturnValue ( ) . setReturnValue ( client . getAll ( ) ) ; }

sample: 211
buggy_code: public void testCrashlyticsUninitializedOnAnonymousReportDisabled() { Context context = InstrumentationRegistry.getTargetContext(); SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit(); editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false); <START> editor.clear(); <END> editor.commit(); CrashReporter crashReporter = new CrashReporter(context); assertFalse(crashReporter.initialize()); }
code_review: In some tests you're using `editor.clear()`, in some you don't. I guess it's better to use it in all tests. Assume that the tests are executed in a random order and should also start in a clean state. So using a [@Before method (setUp)](http://junit.sourceforge.net/javadoc/org/junit/Before.html) to clear the `SharedPreferences` seems like a good idea. Maybe create a static util method so others can benefit from it as well.
target code: public void testCrashlyticsUninitializedOnAnonymousReportDisabled ( ) { editor . putBoolean ( SettingsActivity . SETTINGS_CRASH_REPORTS , false ) ; editor . commit ( ) ; assertFalse ( CrashReporter . initialize ( context ) ) ; }
response: public void setUp ( ) { Context context = InstrumentationRegistry . getTargetContext ( ) ; SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( context ) . edit ( ) ; editor . clear ( ) ; editor . commit ( ) ; } public void testCrashlyticsUninitializedOnAnonymousReportDisabled ( ) { setUp ( ) ; Context context = InstrumentationRegistry . getTargetContext ( ) ; SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( context ) . edit ( ) ; editor . putBoolean ( SettingsActivity . SETTINGS_CRASH_REPORTS , false ) ; editor . clear ( ) ; editor . commit ( ) ; CrashReporter crashReporter = new CrashReporter ( context ) ; assertFalse ( crashReporter . initialize ( ) ) ; }

sample: 212
buggy_code: <START> protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { <END> if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages())) { return false; } else { return true; } }
code_review: it can be simplified to a single return statement protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages()); }
target code: protected boolean uniqueInterfaceName ( List < VmNetworkInterface > interfaces ) { return VmHandler . IsNotDuplicateInterfaceName ( interfaces , getInterfaceName ( ) , getReturnValue ( ) . getCanDoActionMessages ( ) ) ; }
response: protected boolean uniqueInterfaceName ( List < VmNetworkInterface > interfaces ) { return VmHandler . IsNotDuplicateInterfaceName ( interfaces , getInterfaceName ( ) , getReturnValue ( ) . getCanDoActionMessages ( ) ) ; }

sample: 213
buggy_code: private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException { log.info("Start Discovery Service."); CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>(); this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath()); // Start LogReplicationDiscovery Service, responsible for // acquiring lock, retrieving Site Manager Info and processing this info // so this node is initialized as Source (sender) or Sink (receiver) replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext, <START> clusterManagerAdapter, discoveryServiceCallback);; <END> return discoveryServiceCallback; }
code_review: typo --> ;;
target code: private CompletableFuture < CorfuInterClusterReplicationServerNode > startDiscoveryService ( ServerContext serverContext ) { log . info ( "Start Discovery Service . " ) ; CompletableFuture < CorfuInterClusterReplicationServerNode > discoveryServiceCallback = new CompletableFuture < > ( ) ; this . clusterManagerAdapter = buildClusterManagerAdapter ( serverContext . getPluginConfigFilePath ( ) ) ; // Start LogReplicationDiscovery Service , responsible for // acquiring lock , retrieving Site Manager Info and processing this info // so this node is initialized as Source ( sender ) or Sink ( receiver ) replicationDiscoveryService = new CorfuReplicationDiscoveryService ( serverContext , clusterManagerAdapter , discoveryServiceCallback ) ; replicationDiscoveryService . start ( ) ; return discoveryServiceCallback ; }
response: private CompletableFuture < CorfuInterClusterReplicationServerNode > startDiscoveryService ( ServerContext serverContext ) throws InterruptedException { log . info ( "Start Discovery Service . " ) ; CompletableFuture < CorfuInterClusterReplicationServerNode > discoveryServiceCallback = new CompletableFuture < > ( ) ; this . clusterManagerAdapter = buildClusterManagerAdapter ( serverContext . getPluginConfigFilePath ( ) ) ; // Start LogReplicationDiscovery Service , responsible for // acquiring lock , retrieving Site Manager Info and processing this info // so this node is initialized as Source ( sender ) or Sink ( receiver ) replicationDiscoveryService = new CorfuReplicationDiscoveryService ( serverContext , clusterManagerAdapter , discoveryServiceCallback ) ; return discoveryServiceCallback ; }

sample: 214
buggy_code: public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception { long prevChunk = mallocChunks(4); long middleChunk = mallocChunks(4); long nextChunk = mallocChunks(2); free(middleChunk); // This should be taken from the end of "middleChunk", since that's closer to the smaller neighbor long smallChunk1 = mallocChunks(1); // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks(1); <START> assertTrue("The small chunks should have been allocated from the end of the free block", smallChunk1 > smallChunk2); assertTrue("The small chunks should have been allocated from space before 'nextChunk'", smallChunk1 < nextChunk); assertTrue("The small chunks should have been allocated from space after 'prevChunk'", smallChunk2 > prevChunk); <END> }
code_review: I would change the order to: assertTrue(prevChunk < smallChunk2); assertTrue(smallChunk2 < smallChunk1); assertTrue(smallChunk1 < nextChunk);
target code: public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock ( ) throws Exception { long prevChunk = mallocChunks ( 4 ) ; long middleChunk = mallocChunks ( 4 ) ; long nextChunk = mallocChunks ( 2 ) ; free ( middleChunk ) ; // This should be taken from the end of "middleChunk" , since that's closer to the smaller neighbor long smallChunk1 = mallocChunks ( 1 ) ; // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks ( 1 ) ; assertTrue ( "The small chunks should have been allocated from space after 'prevChunk'" , prevChunk < smallChunk2 ) ; assertTrue ( "The small chunks should have been allocated from the end of the free block" , smallChunk2 < smallChunk1 ) ; assertTrue ( "The small chunks should have been allocated from space before 'nextChunk'" , smallChunk1 < nextChunk ) ; }
response: public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock ( ) throws Exception { long prevChunk = mallocChunks ( 4 ) ; long middleChunk = mallocChunks ( 4 ) ; long nextChunk = mallocChunks ( 2 ) ; free ( middleChunk ) ; long smallChunk1 = mallocChunks ( 1 ) ; long smallChunk2 = mallocChunks ( 1 ) ; assertTrue ( prevChunk < smallChunk2 ) ; assertTrue ( smallChunk2 < smallChunk1 ) ; assertTrue ( smallChunk1 < nextChunk ) ; }

sample: 215
buggy_code: public void shouldSetTempImagesPathAsCompleteDirectory() { URI path = URI.create("/pages/newImagesTemp/"); ConfigCore.setImagesPath(URI.create("/pages/newImagesTemp/")); <START> System.out.println(ConfigCore.getTempImagesPathAsCompleteDirectory()); <END> assertEquals("Temp images path was set incorrectly!", path, URI.create("/pages/newImagesTemp/")); }
code_review: Why did you add this `System.out.println()` call? Maybe a logger is a better solution.
target code: public void shouldSetTempImagesPathAsCompleteDirectory ( ) { URI path = URI . create ( " / pages / newImagesTemp / " ) ; ConfigCore . setImagesPath ( URI . create ( " / pages / newImagesTemp / " ) ) ; assertEquals ( "Temp images path was set incorrectly ! " , path , URI . create ( " / pages / newImagesTemp / " ) ) ; }
response: public void shouldSetTempImagesPathAsCompleteDirectory ( ) { URI path = URI . create ( " / pages / newImagesTemp / " ) ; ConfigCore . setImagesPath ( path ) ; logger . info ( "Temp images path set to : { } " , ConfigCore . getTempImagesPathAsCompleteDirectory ( ) ) ; assertEquals ( "Temp images path was set incorrectly ! " , path , ConfigCore . getImagesPath ( ) ) ; }

sample: 216
buggy_code: public MetadataHashAggPOP(@JsonProperty("child") PhysicalOperator child, @JsonProperty("context") MetadataAggregateContext context, @JsonProperty("phase") OperatorPhase phase) { super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F); <START> this.context = context; <END> this.phase = phase; Preconditions.checkArgument(context.createNewAggregations(), "Hash aggregate for metadata collecting should be used only for creating new aggregations."); }
code_review: Please move this check before assigning the variables.
target code: public MetadataHashAggPOP ( @JsonProperty ( "child" ) PhysicalOperator child , @JsonProperty ( "context" ) MetadataAggregateContext context , @JsonProperty ( "phase" ) OperatorPhase phase ) { super ( child , phase , context . groupByExpressions ( ) , Collections . emptyList ( ) , 1 . 0F ) ; Preconditions . checkArgument ( context . createNewAggregations ( ) , "Hash aggregate for metadata collecting should be used only for creating new aggregations . " ) ; this . context = context ; this . phase = phase ; }
response: public MetadataHashAggPOP ( @JsonProperty ( "child" ) PhysicalOperator child , @JsonProperty ( "context" ) MetadataAggregateContext context , @JsonProperty ( "phase" ) OperatorPhase phase ) { Preconditions . checkArgument ( context . createNewAggregations ( ) , "Hash aggregate for metadata collecting should be used only for creating new aggregations . " ) ; super ( child , phase , context . groupByExpressions ( ) , Collections . emptyList ( ) , 1 . 0F ) ; this . context = context ; this . phase = phase ; }

sample: 217
buggy_code: private void saveProcess(Process process) { try { serviceManager.getProcessService().save(process); } catch (DataException e) { <START> Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, "Error while saving process: " + process.getTitle(), e); <END> logger.error(KITODO_SCRIPT_FIELD + "Error while saving process: " + process.getTitle(), e); } }
code_review: Please first log the error and then inform the user.
target code: private void saveProcess ( Process process ) { try { serviceManager . getProcessService ( ) . save ( process ) ; } catch ( DataException e ) { logger . error ( KITODO_SCRIPT_FIELD + "Error while saving process : " + process . getTitle ( ) , e ) ; Helper . setFehlerMeldung ( KITODO_SCRIPT_FIELD , "Error while saving process : " + process . getTitle ( ) , e ) ; } }
response: private void saveProcess ( Process process ) { try { serviceManager . getProcessService ( ) . save ( process ) ; } catch ( DataException e ) { logger . error ( KITODO_SCRIPT_FIELD + "Error while saving process : " + process . getTitle ( ) , e ) ; Helper . setFehlerMeldung ( KITODO_SCRIPT_FIELD , "Error while saving process : " + process . getTitle ( ) , e ) ; } }

sample: 218
buggy_code: <START> private String toHexString(QuantileDigest qdigest) <END> { return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll("\\s+", " "); }
code_review: private static
target code: private static String toHexString ( QuantileDigest qdigest ) { return new SqlVarbinary ( qdigest . serialize ( ) . getBytes ( ) ) . toString ( ) . replaceAll ( "\\s + " , " " ) ; }
response: private static String toHexString ( QuantileDigest qdigest ) { return new SqlVarbinary ( qdigest . serialize ( ) . getBytes ( ) ) . toString ( ) . replaceAll ( "\\s + " , " " ) ; }

sample: 219
buggy_code: <START> public String getHeader(){ <END> return selectedPageHeader.getText(); }
code_review: this should be private method
target code: private String getHeader ( ) { return selectedPageHeader . getText ( ) ; }
response: private String getHeader ( ) { return selectedPageHeader . getText ( ) ; }

sample: 220
buggy_code: public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) { String userModelAttrName = getUserModelAttribute(); String attributeValue = getAttributeValue(); Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase()); if (userModelProperty != null) { <START> checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user); <END> setPropertyOnUserModel(userModelProperty, user, attributeValue); } else { user.setAttribute(userModelAttrName, Arrays.asList(attributeValue)); } }
code_review: Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute.
target code: public void onImportUserFromLDAP ( LDAPObject ldapUser , UserModel user , RealmModel realm , boolean isCreate ) { String userModelAttrName = getUserModelAttribute ( ) ; String attributeValue = getAttributeValue ( ) ; Property < Object > userModelProperty = userModelProperties . get ( userModelAttrName . toLowerCase ( ) ) ; if ( userModelProperty != null ) { setPropertyOnUserModel ( userModelProperty , user , attributeValue ) ; } else { user . setAttribute ( userModelAttrName , Arrays . asList ( attributeValue ) ) ; } }
response: public void onImportUserFromLDAP ( LDAPObject ldapUser , UserModel user , RealmModel realm , boolean isCreate ) { String userModelAttrName = getUserModelAttribute ( ) ; String attributeValue = getAttributeValue ( ) ; Property < Object > userModelProperty = userModelProperties . get ( userModelAttrName . toLowerCase ( ) ) ; if ( userModelProperty != null ) { setPropertyOnUserModel ( userModelProperty , user , attributeValue ) ; } else { user . setAttribute ( userModelAttrName , Arrays . asList ( attributeValue ) ) ; } }

sample: 221
buggy_code: <START> public Boolean delete( ProjectName projectName ) <END> { return callWithContext( () -> { final Boolean result = doDelete( projectName ); LOG.info( "Project deleted: " + projectName ); return result; } ); }
code_review: boolean instead of Boolean
target code: public boolean delete ( ProjectName projectName ) { return callWithContext ( ( ) - > { final boolean result = doDelete ( projectName ) ; LOG . info ( "Project deleted : " + projectName ) ; return result ; } ) ; }
response: < START > public boolean delete ( ProjectName projectName ) { return callWithContext ( ( ) - > { final boolean result = doDelete ( projectName ) ; LOG . info ( "Project deleted : " + projectName ) ; return result ; } ) ; } < END >

sample: 222
buggy_code: public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort) throws IOException, <START> InterruptedException, KeeperException.NoNodeException { <END> final int port = getPort(hostPort); LOG.info("<START>ING server instance 127.0.0.1:{}", port); ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000); factory.startup(zks); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure())); }
code_review: this isn't needed anymore right?
target code: public static void startServerInstance ( File dataDir , ServerCnxnFactory factory , String hostPort ) throws IOException , InterruptedException { final int port = getPort ( hostPort ) ; LOG . info ( "STARTING server instance 127 . 0 . 0 . 1 : { } " , port ) ; ZooKeeperServer zks = new ZooKeeperServer ( dataDir , dataDir , 3000 ) ; factory . startup ( zks ) ; Assert . assertTrue ( "waiting for server up" , ClientBase . waitForServerUp ( "127 . 0 . 0 . 1 : " + port , CONNECTION_TIMEOUT , factory . isSecure ( ) ) ) ; }
response: The Review without comments doesn't provide enough information to determine what changes need to be made to the code . Please provide more context or information .

sample: 223
buggy_code: public void shouldShowAllMusicsAsHTTP() { MockHttpResult mockHttpResult = new MockHttpResult(); controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics); when(dao.listAll()).thenReturn(Arrays.asList(music)); controller.showAllMusicsAsHTTP(); assertEquals("<p class=\"content\">"+ Arrays.asList(music).toString()+"</p>", mockHttpResult.getBody()); <START> } <END>
code_review: If you want, you can change to use hamcrest here too. The method `Matchers.is` compare if two objects are equals.
target code: public void shouldShowAllMusicsAsHTTP ( ) { MockHttpResult mockHttpResult = new MockHttpResult ( ) ; controller = new MusicController ( dao , userInfo , mockHttpResult , validator , musics ) ; when ( dao . listAll ( ) ) . thenReturn ( Arrays . asList ( music ) ) ; controller . showAllMusicsAsHTTP ( ) ; assertThat ( mockHttpResult . getBody ( ) , is ( " < p class = \"content\" > " + Arrays . asList ( music ) . toString ( ) + " </ p > " ) ) ; }
response: public void shouldShowAllMusicsAsHTTP ( ) { MockHttpResult mockHttpResult = new MockHttpResult ( ) ; controller = new MusicController ( dao , userInfo , mockHttpResult , validator , musics ) ; when ( dao . listAll ( ) ) . thenReturn ( Arrays . asList ( music ) ) ; controller . showAllMusicsAsHTTP ( ) ; assertThat ( mockHttpResult . getBody ( ) , is ( " < p class = \"content\" > " + Arrays . asList ( music ) . toString ( ) + " </ p > " ) ) ; }

sample: 224
buggy_code: public AttributeValueSearch(IAttributeType attributeType, String attributeValue) { this.attributeType = attributeType; this.attributeValue = attributeValue; <START> Conditions.checkNotNull(attributeType, "attributeType"); Conditions.checkNotNullOrEmpty(attributeValue, "attributeValue"); <END> }
code_review: wouldn't you want the conditions check prior to assignments?
target code: public AttributeValueSearch ( IAttributeType attributeType , String attributeValue ) { Conditions . checkNotNull ( attributeType , "attributeType" ) ; Conditions . checkNotNullOrEmpty ( attributeValue , "attributeValue" ) ; this . attributeType = attributeType ; this . attributeValue = attributeValue ; }
response: public AttributeValueSearch ( IAttributeType attributeType , String attributeValue ) { Conditions . checkNotNull ( attributeType , "attributeType" ) ; Conditions . checkNotNullOrEmpty ( attributeValue , "attributeValue" ) ; this . attributeType = attributeType ; this . attributeValue = attributeValue ; }

sample: 225
buggy_code: public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) { super(source); <START> this.idleTime = Duration.ofMillis(idleTime); <END> this.listenerId = id; this.queueNames = Arrays.asList(queueNames); }
code_review: What made you to wrap, when you still use a simple long afterwards?
target code: public ListenerContainerIdleEvent ( Object source , long idleTime , @Nullable String id , String . . . queueNames ) { super ( source ) ; this . idleTime = idleTime ; this . listenerId = id ; this . queueNames = Arrays . asList ( queueNames ) ; }
response: public ListenerContainerIdleEvent ( Object source , long idleTime , @Nullable String id , String . . . queueNames ) { super ( source ) ; this . idleTime = Duration . ofMillis ( idleTime ) ; this . listenerId = id ; this . queueNames = Arrays . asList ( queueNames ) ; }

sample: 226
buggy_code: public static XARecoveryModule getRegisteredXARecoveryModule () { if (registeredXARecoveryModule == null) { RecoveryManager recMan = RecoveryManager.manager(); Vector recoveryModules = recMan.getModules(); if (recoveryModules != null) { Enumeration modules = recoveryModules.elements(); while (modules.hasMoreElements()) { RecoveryModule m = (RecoveryModule) modules.nextElement(); if (m instanceof XARecoveryModule) { <START> registeredXARecoveryModule = (XARecoveryModule) m; <END> } } } } return registeredXARecoveryModule; }
code_review: you should break out of the loop early after finding the target module
target code: public static XARecoveryModule getRegisteredXARecoveryModule ( ) { if ( registeredXARecoveryModule == null ) { RecoveryManager recMan = RecoveryManager . manager ( ) ; Vector recoveryModules = recMan . getModules ( ) ; if ( recoveryModules != null ) { Enumeration modules = recoveryModules . elements ( ) ; while ( modules . hasMoreElements ( ) ) { RecoveryModule m = ( RecoveryModule ) modules . nextElement ( ) ; if ( m instanceof XARecoveryModule ) { registeredXARecoveryModule = ( XARecoveryModule ) m ; break ; } } } } return registeredXARecoveryModule ; }
response: public static XARecoveryModule getRegisteredXARecoveryModule ( ) { if ( registeredXARecoveryModule == null ) { RecoveryManager recMan = RecoveryManager . manager ( ) ; Vector recoveryModules = recMan . getModules ( ) ; if ( recoveryModules != null ) { Enumeration modules = recoveryModules . elements ( ) ; while ( modules . hasMoreElements ( ) ) { RecoveryModule m = ( RecoveryModule ) modules . nextElement ( ) ; if ( m instanceof XARecoveryModule ) { registeredXARecoveryModule = ( XARecoveryModule ) m ; break ; } } } } return registeredXARecoveryModule ; }

sample: 227
buggy_code: public String getUrl() { <START> return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent); <END> }
code_review: possible NPE
target code: public String getUrl ( ) { return url ; }
response: public String getUrl ( ) { PluginImpl plugin = PluginImpl . getInstance ( ) ; if ( plugin != null ) { Server server = plugin . getServer ( serverName ) ; if ( server != null ) { Config config = server . getConfig ( ) ; if ( config != null ) { return config . getGerritFrontEndUrlFor ( tEvent ) ; } } } return null ; }

sample: 228
buggy_code: public void testBoundarySignalProcessInstance() throws Exception { Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS); assertNotNull(processInstanceId); assertTrue(processInstanceId.longValue() > 0); try { <START> checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId); <END> } catch (Exception e){ processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); e.printStackTrace(); fail(e.getMessage()); } }
code_review: Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
target code: public void testBoundarySignalProcessInstance ( ) throws Exception { Long processInstanceId = processClient . startProcess ( CONTAINER_ID , PROCESS_ID_BOUNDARY_SIGNAL_PROCESS ) ; assertNotNull ( processInstanceId ) ; assertTrue ( processInstanceId . longValue ( ) > 0 ) ; try { checkAvailableBoundarySignals ( CONTAINER_ID , processInstanceId ) ; } finally { processClient . abortProcessInstance ( CONTAINER_ID , processInstanceId ) ; } }
response: public void testBoundarySignalProcessInstance ( ) throws Exception { Long processInstanceId = processClient . startProcess ( CONTAINER_ID , PROCESS_ID_BOUNDARY_SIGNAL_PROCESS ) ; assertNotNull ( processInstanceId ) ; assertTrue ( processInstanceId . longValue ( ) > 0 ) ; try { checkAvailableBoundarySignals ( CONTAINER_ID , processInstanceId ) ; } catch ( Exception e ) { processClient . abortProcessInstance ( CONTAINER_ID , processInstanceId ) ; throw e ; } }

sample: 229
buggy_code: private void validateAppConfig(String fileName) throws Exception { String appsDir = getAppsDirectory(); if (appsDir.equalsIgnoreCase("apps") && !isAppConfiguredInSourceServerXml(fileName)) { // add application configuration applicationXml.createWebApplicationElement(fileName); } <START> else if (appsDir.equalsIgnoreCase("dropins") && isAnyAppConfiguredInSourceServerXml()) <END> throw new MojoExecutionException(messages.getString("error.install.app.dropins.directory")); }
code_review: why not calling isAppConfiguredInSourceServerXml(fileName) to make sure the app installed to the dropins location is not configured?
target code: private void validateAppConfig ( String fileName ) throws Exception { String appsDir = getAppsDirectory ( ) ; if ( appsDir . equalsIgnoreCase ( "apps" ) && ! isAppConfiguredInSourceServerXml ( fileName ) ) { // add application configuration applicationXml . createWebApplicationElement ( fileName ) ; } else if ( appsDir . equalsIgnoreCase ( "dropins" ) && isAppConfiguredInSourceServerXml ( fileName ) ) throw new MojoExecutionException ( messages . getString ( "error . install . app . dropins . directory" ) ) ; }
response: private void validateAppConfig ( String fileName ) throws Exception { String appsDir = getAppsDirectory ( ) ; if ( appsDir . equalsIgnoreCase ( "apps" ) && ! isAppConfiguredInSourceServerXml ( fileName ) ) { // add application configuration applicationXml . createWebApplicationElement ( fileName ) ; } else if ( appsDir . equalsIgnoreCase ( "dropins" ) && isAppConfiguredInSourceServerXml ( fileName ) ) { throw new MojoExecutionException ( messages . getString ( "error . install . app . dropins . directory" ) ) ; } }

sample: 230
buggy_code: <START> static RequestContextDataHolder getRequestContext(Context ctx) { <END> return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null); }
code_review: Please add `private` modifier
target code: private static RequestContextDataHolder getRequestContext ( Context ctx ) { return ctx . getOrDefault ( REQUEST_CONTEXT_DATA_HOLDER , null ) ; }
response: < START > private static RequestContextDataHolder getRequestContext ( Context ctx ) { < END > return ctx . getOrDefault ( REQUEST_CONTEXT_DATA_HOLDER , null ) ; }

sample: 231
buggy_code: public long getNumberOfImagesInStorageDomain(Guid storageDomainId) { <START> MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId); <END> return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), params); }
code_review: I'd inline this to conform with the rest of the class.
target code: public long getNumberOfImagesInStorageDomain ( Guid storageDomainId ) { return getCallsHandler ( ) . executeRead ( "GetNumberOfImagesInStorageDomain" , getLongMapper ( ) , getCustomMapSqlParameterSource ( ) . addValue ( "storage_domain_id" , storageDomainId ) ) ; }
response: public long getNumberOfImagesInStorageDomain ( Guid storageDomainId ) { return getCallsHandler ( ) . executeRead ( "GetNumberOfImagesInStorageDomain" , getLongMapper ( ) , getCustomMapSqlParameterSource ( ) . addValue ( "storage_domain_id" , storageDomainId ) ) ; }

sample: 232
buggy_code: public TestObjectAsync() { try { <START> Thread.sleep(100); <END> Thread.sleep(100); counter = 1; } catch (InterruptedException ie) { throw new RuntimeException(ie); } }
code_review: Is it really necessary to wait 100 milliseconds? Why not `Thread.sleep(1)`. Why not `Thread.yield()`?
target code: public TestObjectAsync ( ) { try { Thread . sleep ( 1 ) ; Thread . sleep ( 1 ) ; counter = 1 ; } catch ( InterruptedException ie ) { throw new RuntimeException ( ie ) ; } }
response: public TestObjectAsync ( ) { try { Thread . yield ( ) ; counter = 1 ; } catch ( InterruptedException ie ) { throw new RuntimeException ( ie ) ; } }

sample: 233
buggy_code: private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) { Field field = getField(beanClass, beanProp.getName()); return field != null ? field.getAnnotationsByType(Optional.class).length > 0 <START> || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 <END> : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0; }
code_review: Maybe `beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0` should be checked before calling getField ? Method getField modifies field via reflection and optionally recursively calls itself, so it could be costly.
target code: private static boolean isOptionalProperty ( Class beanClass , PropertyDescriptor beanProp ) { if ( beanProp . getReadMethod ( ) . getAnnotationsByType ( Optional . class ) . length > 0 ) { return true ; } Field field = getField ( beanClass , beanProp . getName ( ) ) ; return field != null && field . getAnnotationsByType ( Optional . class ) . length > 0 ; }
response: private static boolean isOptionalProperty ( Class beanClass , PropertyDescriptor beanProp ) { if ( beanProp . getReadMethod ( ) . getAnnotationsByType ( Optional . class ) . length > 0 ) { return true ; } Field field = getField ( beanClass , beanProp . getName ( ) ) ; return field != null && field . getAnnotationsByType ( Optional . class ) . length > 0 ; }

sample: 234
buggy_code: public int getImageselector () { return imageSelectorIndex; <START> } <END>
code_review: Why is this method required? Didn't see it used anywhere in the code
target code: int getImageselector ( ) { return imageSelectorIndex ; }
response: public int getImageSelector ( ) { return imageSelectorIndex ; }

sample: 235
buggy_code: public InputStream getInputStream(FileHeader entry) throws IOException { if (entry == null) { return null; } InputStream inputStream = getEntryData(entry).getInputStream(); if (entry.getMethod() == ZipEntry.DEFLATED) { <START> inputStream = new ZipInflaterInputStream(inputStream, new Inflater(true), <END> (int) entry.getSize()); } return inputStream; }
code_review: I don't think we want to pass in an `Inflater` and than have `ZipInflaterInputStream` call `end()` on it.
target code: public InputStream getInputStream ( FileHeader entry ) throws IOException { if ( entry == null ) { return null ; } InputStream inputStream = getEntryData ( entry ) . getInputStream ( ) ; if ( entry . getMethod ( ) == ZipEntry . DEFLATED ) { inputStream = new ZipInflaterInputStream ( inputStream , ( int ) entry . getSize ( ) ) ; } return inputStream ; }
response: public InputStream getInputStream ( FileHeader entry ) throws IOException { if ( entry == null ) { return null ; } InputStream inputStream = getEntryData ( entry ) . getInputStream ( ) ; if ( entry . getMethod ( ) == ZipEntry . DEFLATED ) { Inflater inflater = new Inflater ( true ) ; inputStream = new ZipInflaterInputStream ( inputStream , inflater , ( int ) entry . getSize ( ) , true ) ; } return inputStream ; }

sample: 236
buggy_code: private org.eclipse.swt.graphics.Image createImage() { org.eclipse.swt.graphics.Image newImage; RenderedImage image = renderManager.getImage(); <START> this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform(); <END> if (image != null) newImage = AWTSWTImageUtils.createSWTImage(image, false); else { newImage = new Image(getDisplay(), getWidth(), getHeight()); } return newImage; }
code_review: Can you explain the idea behind storing transformation here and not anywhere else (at the very beginning of repaint())? Is it worth to keep this information and to compare it within getDoubleBufferGraphics() rather using the up-to-date viewportModel Transformation. is it because of a non-atomar opration betwenn getImage() and getDoubleBufferGraphics() calls?
target code: private org . eclipse . swt . graphics . Image createImage ( ) { org . eclipse . swt . graphics . Image newImage ; RenderedImage image = renderManager . getImage ( ) ; if ( image != null ) newImage = AWTSWTImageUtils . createSWTImage ( image , false ) ; else { newImage = new Image ( getDisplay ( ) , getWidth ( ) , getHeight ( ) ) ; } return newImage ; }
response: private org . eclipse . swt . graphics . Image createImage ( ) { org . eclipse . swt . graphics . Image newImage ; RenderedImage image = renderManager . getImage ( ) ; AffineTransform backBufferTrsf = renderManager . getMapInternal ( ) . getViewportModel ( ) . worldToScreenTransform ( ) ; if ( image != null ) { newImage = AWTSWTImageUtils . createSWTImage ( image , false ) ; } else { newImage = new Image ( getDisplay ( ) , getWidth ( ) , getHeight ( ) ) ; } return newImage ; }

sample: 237
buggy_code: public VirtualMachine getCurrentMachineBuild(ITmfEvent event) { VirtualMachine machine = innerGetCurrentMachine(event); if (machine == null) { synchronized (fStateSystem) { String hostId = event.getTrace().getHostId(); <START> machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName()); <END> fKnownMachines.put(hostId, machine); } } return machine; }
code_review: this is nullable
target code: public VirtualMachine getCurrentMachineBuild ( ITmfEvent event ) { VirtualMachine machine = innerGetCurrentMachine ( event ) ; if ( machine == null ) { synchronized ( fStateSystem ) { String hostId = event . getTrace ( ) . getHostId ( ) ; machine = createMachine ( fStateSystem , event . getTimestamp ( ) . toNanos ( ) , hostId , String . valueOf ( event . getTrace ( ) . getName ( ) ) ) ; fKnownMachines . put ( hostId , machine ) ; } } return machine ; }
response: public VirtualMachine getCurrentMachineBuild ( ITmfEvent event ) { VirtualMachine machine = innerGetCurrentMachine ( event ) ; if ( machine == null ) { synchronized ( fStateSystem ) { String hostId = event . getTrace ( ) . getHostId ( ) ; machine = createMachine ( fStateSystem , event . getTimestamp ( ) . toNanos ( ) , hostId , event . getTrace ( ) . getName ( ) ) ; fKnownMachines . put ( hostId , machine ) ; } } return machine ; }

sample: 238
buggy_code: public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && isDeterministic(expression) && !mayReturnNullOnNonNullInput(expression) && <START> !isDynamicFilter(expression)) { <END> ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }
code_review: Why do we need it here?
target code: public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }
response: public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) && ! isDynamicFilter ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }  Explanation : The code defines a static method `isInferenceCandidate ( ) ` that returns a `Predicate < Expression > ` object . The predicate checks if the given `Expression` object is a candidate for inference . The code first normalizes the given expression to an equality expression using the `normalizeInPredicateToEquality ( ) ` method . Then it checks if the expression is a `ComparisonExpression` , is deterministic , does not return null on non - null input , and is not a dynamic filter using the respective methods . If all the conditions are satisfied , the code checks if the comparison type is `EQUAL` and the left and right components of the comparison are distinct . If so , it returns `true` , indicating that the expression is a candidate for inference . Otherwise , it returns `false` .

sample: 239
buggy_code: private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates) throws DbException { for (int agg = 0; agg < aggregators.length; ++agg) { if (!(aggregators[agg] .getClass() .getName() <START> .equals(StatefulUserDefinedAggregator.class.getName()))) { <END> aggregators[agg].addRow(tb, row, curAggStates[agg]); } } }
code_review: instanceof
target code: private void updateGroup ( final TupleBatch tb , final int row , final Object [ ] curAggStates ) throws DbException { for ( int agg = 0 ; agg < aggregators . length ; ++ agg ) { if ( ! ( aggregators [ agg ] instanceof StatefulUserDefinedAggregator ) ) { aggregators [ agg ] . addRow ( tb , row , curAggStates [ agg ] ) ; } } }
response: private void updateGroup ( final TupleBatch tb , final int row , final Object [ ] curAggStates ) throws DbException { for ( int agg = 0 ; agg < aggregators . length ; ++ agg ) { if ( ! ( aggregators [ agg ] instanceof StatefulUserDefinedAggregator ) ) { aggregators [ agg ] . addRow ( tb , row , curAggStates [ agg ] ) ; } } }

sample: 240
buggy_code: protected void update(float delta) { int lengthInterpretation; try { <START> lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite); <END> } catch (InterpretationException interpretationException) { lengthInterpretation = 0; Log.d(getClass().getSimpleName(), "Formula interpretation for this specific Brick failed.", interpretationException); } this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation)); }
code_review: Please apply same changes as requested in first review here.
target code: protected void update ( float delta ) { int lengthInterpretation = 0 ; try { if ( length != null ) { lengthInterpretation = length . interpretInteger ( sprite ) ; } } catch ( InterpretationException interpretationException ) { lengthInterpretation = 0 ; Log . d ( getClass ( ) . getSimpleName ( ) , "Formula interpretation for this specific Brick failed . " , interpretationException ) ; } this . sprite . runningStitch . activateStitching ( sprite , new SimpleRunningStitch ( sprite , lengthInterpretation ) ) ; }
response: protected void update ( float delta ) { int lengthInterpretation = 0 ; try { lengthInterpretation = length == null ? 0 : length . interpretInteger ( sprite ) ; } catch ( InterpretationException e ) { Log . d ( getClass ( ) . getSimpleName ( ) , "Formula interpretation for this specific Brick failed . " , e ) ; } this . sprite . runningStitch . activateStitching ( sprite , new SimpleRunningStitch ( sprite , lengthInterpretation ) ) ; }

sample: 241
buggy_code: protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) { long sum = 0; for (String weaselParameterToSum : weaselParametersToSum) { final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters)); if (timing == null) { <START> discardSpan(span); <END> return; } else { sum += timing; } } span.setTag(TIMING_RESOURCE, sum); }
code_review: remove line
target code: protected void processSpanImpl ( Span span , Map < String , String [ ] > servletRequestParameters ) { long sum = 0 ; for ( String weaselParameterToSum : weaselParametersToSum ) { final Long timing = parsedLongOrNull ( getParameterValueOrNull ( weaselParameterToSum , servletRequestParameters ) ) ; if ( timing == null ) { return ; } else { sum += timing ; } } span . setTag ( TIMING_RESOURCE , sum ) ; }
response: protected void processSpanImpl ( Span span , Map < String , String [ ] > servletRequestParameters ) { long sum = 0 ; for ( String weaselParameterToSum : weaselParametersToSum ) { final Long timing = parsedLongOrNull ( getParameterValueOrNull ( weaselParameterToSum , servletRequestParameters ) ) ; if ( timing == null ) { discardSpan ( span ) ; return ; } sum += timing ; } span . setTag ( TIMING_RESOURCE , sum ) ; }

sample: 242
buggy_code: private void close(Path path) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent(); try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced)) { <START> s.filter(p -> !Files.isDirectory(p)).map(ThrowingFunction.unchecked(p -> p)) <END> .forEach(ThrowingConsumer.unchecked(Files::delete)); } }
code_review: `.map(ThrowingFunction.unchecked(p -> p))` unnecessary
target code: private void close ( Path path ) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path . getParent ( ) ; try ( Stream < Path > s = Files . list ( directoryWhereGeneratedArtifactsWasPlaced ) ) { s . filter ( p - > ! Files . isDirectory ( p ) ) . forEach ( ThrowingConsumer . unchecked ( Files : : delete ) ) ; } }
response: private void close ( Path path ) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path . getParent ( ) ; try ( Stream < Path > s = Files . list ( directoryWhereGeneratedArtifactsWasPlaced ) ) { s . filter ( p - > ! Files . isDirectory ( p ) ) . forEach ( ThrowingConsumer . unchecked ( Files : : delete ) ) ; } }

sample: 243
buggy_code: public void hashcodeVerifyEqualsContract() { <START> EqualsVerifier.forClass(MessageReference.class).suppress(Warning.NONFINAL_FIELDS).verify(); <END> }
code_review: As a general rule: If you're unsure whether or not to suppress a warning, don't! You discovered the principal problem of mutable objects. The easy fix is to use [immutable objects](http://en.wikipedia.org/wiki/Immutable_object) whenever possible. `MessageReference` looks like it could be easily made immutable. So you should definitely do that instead of suppressing the warning.
target code: public void hashcodeVerifyEqualsContract ( ) { EqualsVerifier . forClass ( MessageReference . class ) . verify ( ) ; }
response: public void verifyEqualsContract ( ) { EqualsVerifier . forClass ( MessageReference . class ) . withImmutableFields ( ) . verify ( ) ; }

sample: 244
buggy_code: public HttpRequest setUri(String uri) { ObjectUtil.checkNotNull(uri, "uri"); <START> this.uri = uri; <END> return this; }
code_review: nit: you can merge both lines above as `checkNotNull` will return the given argument
target code: public HttpRequest setUri ( String uri ) { this . uri = ObjectUtil . checkNotNull ( uri , "uri" ) ; return this ; }
response: public HttpRequest setUri ( String uri ) { this . uri = ObjectUtil . checkNotNull ( uri , "uri" ) ; return this ; }

sample: 245
buggy_code: <START> protected ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { <END> this.creds = creds; }
code_review: Make all Guice constructors package private by removing the method modifier. Just: ``` java @Inject ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { ```
target code: ServiceKeyAuthentication ( @Provider Supplier < Credentials > creds ) { this . creds = creds ; }
response: java @Inject ServiceKeyAuthentication ( @Provider Supplier < Credentials > creds ) { this . creds = creds ; }

sample: 246
buggy_code: protected int countChildrenOf(IResource checkResource) throws CoreException { if (checkResource.getType() == IResource.FILE) { return 1; } int count = 0; if (checkResource.isAccessible()) { for (IResource <START> resource : <END> ((IContainer) checkResource).members()) { count += countChildrenOf(resource); } } return count; }
code_review: rename 'child'
target code: protected int countChildrenOf ( IResource checkResource ) throws CoreException { if ( checkResource . getType ( ) == IResource . FILE ) { return 1 ; } int count = 0 ; if ( checkResource . isAccessible ( ) ) { for ( IResource child : ( ( IContainer ) checkResource ) . members ( ) ) { count += countChildrenOf ( child ) ; } } return count ; }
response: protected int countChildrenOf ( IResource resource ) throws CoreException { if ( resource . getType ( ) == IResource . FILE ) { return 1 ; } int count = 0 ; if ( resource . isAccessible ( ) ) { for ( IResource child : ( ( IContainer ) resource ) . members ( ) ) { count += countChildrenOf ( child ) ; } } return count ; }

sample: 247
buggy_code: public String getAppFolderToMonitor() { <START> if (folder == null) { <END> File f = new File("Applications"); folder = f.getAbsolutePath(); } return folder; }
code_review: If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The `startMonitor` method below also checks for the return value of this method being `null`. I guess `null` would then also be the default.
target code: public String getAppFolderToMonitor ( ) { return folder ; }
response: public String getAppFolderToMonitor ( ) { if ( folder == null ) { return null ; } File f = new File ( "Applications" ) ; folder = f . getAbsolutePath ( ) ; return folder ; }

sample: 248
buggy_code: private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts) { long input = inputAddress; Arrays.fill(counts, 0); <START> if (inputSize != 0) { <END> for (int i = 0; i < inputSize; i++) { int symbol = UNSAFE.getByte(inputBase, input) & 0xFF; input++; counts[symbol]++; } } }
code_review: I don't think you need this
target code: private static void count ( Object inputBase , long inputAddress , int inputSize , int [ ] counts ) { long input = inputAddress ; Arrays . fill ( counts , 0 ) ; for ( int i = 0 ; i < inputSize ; i ++ ) { int symbol = UNSAFE . getByte ( inputBase , input ) & 0xFF ; input ++ ; counts [ symbol ] ++ ; } }
response: private static void count ( Object inputBase , long inputAddress , int inputSize , int [ ] counts ) { Arrays . fill ( counts , 0 ) ; for ( int i = 0 ; i < inputSize ; i ++ ) { int symbol = UNSAFE . getByte ( inputBase , inputAddress + i ) & 0xFF ; counts [ symbol ] ++ ; } }

sample: 249
buggy_code: public void submit(List<LuceneWork> workList, IndexingMonitor monitor) { Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor ); transferQueue.add( changeset ); wakeUpConsumer(); boolean interrupted = false; while ( ! changeset.isProcessed() ) { LockSupport.park(); if ( Thread.interrupted() ) { <START> interrupted = true; <END> } } if ( interrupted ) { Thread.currentThread().interrupt(); } }
code_review: If it's interrupted you might want to return too, rather than getting stuck in another park.
target code: public void submit ( List < LuceneWork > workList , IndexingMonitor monitor ) { Changeset changeset = new Changeset ( workList , Thread . currentThread ( ) , monitor ) ; transferQueue . add ( changeset ) ; wakeUpConsumer ( ) ; boolean interrupted = false ; while ( ! changeset . isProcessed ( ) && ! interrupted ) { LockSupport . park ( ) ; if ( Thread . interrupted ( ) ) { interrupted = true ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } }
response: public void submit ( List < LuceneWork > workList , IndexingMonitor monitor ) { Changeset changeset = new Changeset ( workList , Thread . currentThread ( ) , monitor ) ; transferQueue . add ( changeset ) ; wakeUpConsumer ( ) ; boolean interrupted = false ; while ( ! changeset . isProcessed ( ) ) { LockSupport . park ( ) ; if ( Thread . interrupted ( ) ) { interrupted = true ; return ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } }

sample: 250
buggy_code: public void setHttpService(HttpService httpService) { <START> logger.info("setHttpService called"); <END> this.httpService = httpService; }
code_review: could we directly reduce this to debug level?
target code: public void setHttpService ( HttpService httpService ) { logger . debug ( "setHttpService called" ) ; this . httpService = httpService ; }
response: public void setHttpService ( HttpService httpService ) { logger . debug ( "setHttpService called" ) ; this . httpService = httpService ; }

sample: 251
buggy_code: public boolean isInternal() { return getParentNode() .filter(parent -> parent instanceof Name) .map(parent -> (Name) parent) .flatMap(Name::getQualifier) <START> .map(parentNameQualifier -> parentNameQualifier == this) <END> .orElse(false); }
code_review: Oh, yes, `Name` can only be qualified by another `Name`. I think it's a safe assumption to make :-)
target code: public boolean isInternal ( ) { return getParentNode ( ) . filter ( parent - > parent instanceof Name ) . isPresent ( ) ; }
response: public boolean isInternal ( ) { return getParentNode ( ) . filter ( parent - > parent instanceof Name ) . map ( parent - > ( Name ) parent ) . flatMap ( Name : : getQualifier ) . map ( parentNameQualifier - > parentNameQualifier == this . getQualifier ( ) . orElse ( null ) ) . orElse ( false ) ; }

sample: 252
buggy_code: private void logStart() { log(3, "Running test " + m_testName + " on " + m_classMap.size() + " " + " classes, " <START> + " included groups:[" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups()) <END> + "] excluded groups:[" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + "]"); if (getVerbose() >= 3) { for (ITestClass tc : m_classMap.values()) { ((TestClass) tc).dump(); } } }
code_review: `valueOf` looks more appropriate (like `String#valueOf`)
target code: private void logStart ( ) { log ( 3 , "Running test " + m_testName + " on " + m_classMap . size ( ) + " " + " classes , " + " included groups : [ " + Strings . valueOf ( m_xmlMethodSelector . getIncludedGroups ( ) ) + " ] excluded groups : [ " + Strings . valueOf ( m_xmlMethodSelector . getExcludedGroups ( ) ) + " ] " ) ; if ( getVerbose ( ) >= 3 ) { for ( ITestClass tc : m_classMap . values ( ) ) { ( ( TestClass ) tc ) . dump ( ) ; } } }
response: private void logStart ( ) { log ( 3 , "Running test " + m_testName + " on " + m_classMap . size ( ) + " " + " classes , " + String . valueOf ( " < START > " ) + " included groups : [ " + String . valueOf ( Strings . mapToString ( m_xmlMethodSelector . getIncludedGroups ( ) ) ) + " ] excluded groups : [ " + String . valueOf ( Strings . mapToString ( m_xmlMethodSelector . getExcludedGroups ( ) ) ) + " ] " ) ; if ( getVerbose ( ) >= 3 ) { for ( ITestClass tc : m_classMap . values ( ) ) { ( ( TestClass ) tc ) . dump ( ) ; } } }

sample: 253
buggy_code: public NutchJob(Configuration conf) throws IOException { <START> super(conf, "NutchJob"); <END> }
code_review: Does this mean that every Job will be named ```"NutchJob"```?
target code: public NutchJob ( Configuration conf ) { super ( conf , NutchJob . class ) ; }
response: java public NutchJob ( Configuration conf ) throws IOException { super ( conf , "NutchJob" ) ; }  Yes , the refactored code means that every Job will be named "NutchJob" .

sample: 254
buggy_code: private void loadMachineUUID() { if <START> (System.getProperty(PROP_UUID) != <END> null) return; String uuid = loadExistingUUID(); if (uuid == null) { uuid = UUID.randomUUID().toString(); saveUUID(uuid); } EnvironmentInfo environment = environmentTracker.getService(); if (environment != null) { environment.setProperty(PROP_UUID, uuid); } else { System.setProperty(PROP_UUID, uuid); } }
code_review: Should use BundleContext.getProperty here, or the EnvonmentInfo service.
target code: private void loadMachineUUID ( ) { EnvironmentInfo environment = environmentTracker . getService ( ) ; if ( environment != null ) { if ( environment . getProperty ( PROP_UUID ) != null ) return ; } String uuid = loadExistingUUID ( ) ; if ( uuid == null ) { uuid = UUID . randomUUID ( ) . toString ( ) ; saveUUID ( uuid ) ; } if ( environment != null ) { environment . setProperty ( PROP_UUID , uuid ) ; } else { System . setProperty ( PROP_UUID , uuid ) ; } }
response: private void loadMachineUUID ( BundleContext context ) { String uuid = context . getProperty ( PROP_UUID ) ; if ( uuid != null ) { return ; } uuid = loadExistingUUID ( ) ; if ( uuid == null ) { uuid = UUID . randomUUID ( ) . toString ( ) ; saveUUID ( uuid ) ; } EnvironmentInfo environment = environmentTracker . getService ( ) ; if ( environment != null ) { environment . setProperty ( PROP_UUID , uuid ) ; } else { System . setProperty ( PROP_UUID , uuid ) ; } }

sample: 255
buggy_code: public synchronized boolean retry(ITestResult result) { if (currentTry < maxreruntimes) { <START> ++currentTry; <END> return true; } return false; }
code_review: Maybe we can use `AtomicInteger` and get rid of `synchronized` keyword ? On a side note, I noticed that you haven't enabled the `parallel` attribute on `@DataProvider` annotation. So you can completely get rid of the need for ensuring Thread safety.
target code: public boolean retry ( ITestResult result ) { if ( currentTry < maxreruntimes ) { ++ currentTry ; return true ; } return false ; }
response: private AtomicInteger currentTry = new AtomicInteger ( 0 ) ; private int maxRerunTimes = 3 ; public boolean retry ( ITestResult result ) { if ( currentTry . getAndIncrement ( ) < maxRerunTimes ) { return true ; } return false ; }

sample: 256
buggy_code: public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException { <START> return (Statistics<T>)getStatistics(expr.getInt()); <END> }
code_review: It was much nicer when we did not have to explicitly cast everywhere to `(Statistics<T>)`. Please consider re-working this part your changes.
target code: public Statistics < T > visitIntConstant ( ValueExpressions . IntExpression expr , Void value ) throws RuntimeException { return getStatistics ( expr . getInt ( ) ) ; }
response: public Statistics < T > visitIntConstant ( ValueExpressions . IntExpression expr , Void value ) throws RuntimeException { return getStatistics ( expr . getInt ( ) ) ; }

sample: 257
buggy_code: public ServiceDate getEnd() { <START> return end == UNBOUNDED_<END> ? null : end; <END> }
code_review: It might even be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging.
target code: public ServiceDate getEnd ( ) { return end ; }
response: public static final ServiceDate UNBOUNDED_END = null ; public ServiceDate getEnd ( ) { return end == UNBOUNDED_END ? null : end ; }

sample: 258
buggy_code: <START> public boolean <END> isLoggedIn() { return token != null && hub != null; }
code_review: no public
target code: public boolean isLoggedIn ( ) { return token != null && user != null ; }
response: public boolean isLoggedIn ( ) { return token != null && hub != null ; }

sample: 259
buggy_code: <START> public void setBuildStatus(String buildStatus) { <END> StashBuildState overwrittenBuildState = null; try { overwrittenBuildState = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } this.buildStatus = overwrittenBuildState; }
code_review: The complete method could be stripped down to: ``` try { this.buildStatus = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } ```
target code: public void setBuildStatus ( String buildStatus ) { try { this . buildStatus = StashBuildState . valueOf ( buildStatus ) ; } catch ( Exception e ) { // ignore unknown or null values } }
response: public void setBuildStatus ( String buildStatus ) { try { this . buildStatus = StashBuildState . valueOf ( buildStatus ) ; } catch ( Exception e ) { // ignore unknown or null values } }

sample: 260
buggy_code: public void preInit(FMLPreInitializationEvent evt) { RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID); BCSiliconConfig.preInit(); BCSiliconItems.preInit(); BCSiliconBlocks.preInit(); // Reload after all of the definitions have been created. <START> BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME); <END> NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy()); BCSiliconProxy.getProxy().fmlPreInit(); }
code_review: Put this in the config preinit please
target code: public void preInit ( FMLPreInitializationEvent evt ) { RegistryHelper . useOtherModConfigFor ( MODID , BCCore . MODID ) ; BCSiliconConfig . preInit ( ) ; BCSiliconItems . preInit ( ) ; BCSiliconBlocks . preInit ( ) ; NetworkRegistry . INSTANCE . registerGuiHandler ( INSTANCE , BCSiliconProxy . getProxy ( ) ) ; BCSiliconProxy . getProxy ( ) . fmlPreInit ( ) ; }
response: public void preInit ( FMLPreInitializationEvent evt ) { BCSiliconConfig . preInit ( ) ; BCSiliconItems . preInit ( ) ; BCSiliconBlocks . preInit ( ) ; BCSiliconConfig . reloadConfig ( EnumRestartRequirement . GAME ) ; RegistryHelper . useOtherModConfigFor ( MODID , BCCore . MODID ) ; NetworkRegistry . INSTANCE . registerGuiHandler ( INSTANCE , BCSiliconProxy . getProxy ( ) ) ; BCSiliconProxy . getProxy ( ) . fmlPreInit ( ) ; }

sample: 261
buggy_code: public Hash(HashType type){ this.type = type; try { digest = type.get(); } finally { <START> type.recycle(digest); <END> } }
code_review: Recycling a digest to which we still have references (namely in the member variable`digest`) is bound to give problems at some point: another thread may obtain it by means of `HashType.get()` while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of `Hash`. Note that the semantics of `finally` don't have anything to do with finalizers!
target code: public Hash ( HashType type ) { this . type = type ; digest = type . get ( ) ; }
response: public Hash ( HashType type ) { this . type = type ; try { digest = type . get ( ) ; } finally { // Do not recycle digest here // Instead , rely on the finalizer to recycle it } } @Override protected void finalize ( ) throws Throwable { try { type . recycle ( digest ) ; } finally { super . finalize ( ) ; } }

sample: 262
buggy_code: private boolean validateExternalVnicProfileMapping() { <START> drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings()); <END> final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping( getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId()); return validate(validationResult); }
code_review: the mapping is still performed before the validation. it should be after it
target code: private boolean validateExternalVnicProfileMapping ( ) { final ValidationResult validationResult = externalVnicProfileMappingValidator . validateExternalVnicProfileMapping ( getParameters ( ) . getExternalVnicProfileMappings ( ) , getParameters ( ) . getClusterId ( ) ) ; return validate ( validationResult ) ; }
response: private boolean validateExternalVnicProfileMapping ( ) { final ValidationResult validationResult = externalVnicProfileMappingValidator . validateExternalVnicProfileMapping ( getParameters ( ) . getExternalVnicProfileMappings ( ) , getParameters ( ) . getClusterId ( ) ) ; drMappingHelper . mapVnicProfiles ( vmTemplateFromConfiguration . getInterfaces ( ) , getParameters ( ) . getExternalVnicProfileMappings ( ) ) ; return validate ( validationResult ) ; }

sample: 263
buggy_code: public void serDeTest() { <START> doSerDeTest(Collections.emptyList()); <END> doSerDeTest(Arrays.asList("a", "b", "/signedId/abcdef")); }
code_review: do we need a `null` case?
target code: public void serDeTest ( ) { doSerDeTest ( null ) ; doSerDeTest ( Collections . emptyList ( ) ) ; doSerDeTest ( Arrays . asList ( "a" , "b" , " / signedId / abcdef" ) ) ; }
response: public void serDeTest ( ) { List < String > testList = Arrays . asList ( "a" , "b" , " / signedId / abcdef" ) ; if ( testList != null ) { doSerDeTest ( testList ) ; } else { doSerDeTest ( Collections . emptyList ( ) ) ; } }

sample: 264
buggy_code: protected void buildVmVideoCards() { createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl createInfo.add(VdsProperties.num_of_monitors, <START> (new Integer(vm.getnum_of_monitors())).toString()); <END> }
code_review: use String.valueOf(vm.getnum_of_monitors()) instead.
target code: protected void buildVmVideoCards ( ) { createInfo . add ( VdsProperties . display , vm . getdisplay_type ( ) . toString ( ) ) ; // vnc , qxl createInfo . add ( VdsProperties . num_of_monitors , String . valueOf ( vm . getnum_of_monitors ( ) ) ) ; }
response: protected void buildVmVideoCards ( ) { createInfo . add ( VdsProperties . display , vm . getdisplay_type ( ) . toString ( ) ) ; // vnc , qxl createInfo . add ( VdsProperties . num_of_monitors , String . valueOf ( vm . getnum_of_monitors ( ) ) ) ; }

sample: 265
buggy_code: <START> String encode(String segment) { <END> return URL.encodeQueryString(type.replacePathSeparator(segment)); }
code_review: [optional] maybe this method can be static and should be moved to end of the class
target code: private String encode ( String segment ) { return URL . encodeQueryString ( type . replacePathSeparator ( segment ) ) ; }
response: Here's the   public class MyClass { // other methods and variables public static String encode ( String segment ) { return URL . encodeQueryString ( type . replacePathSeparator ( segment ) ) ; } }  I made the following changes : - Made the `encode` method static , as suggested in the review . - Moved the `encode` method to the end of the class , as suggested in the review .

sample: 266
buggy_code: public List<String> getStrongDependencies() { List<String> strongDependencies = new ArrayList<>(); <START> strongDependencies.add(A_U_D_preferredMail); <END> strongDependencies.add(A_U_D_ISMail); strongDependencies.add(A_U_D_publicAliasMails); strongDependencies.add(A_U_D_privateAliasMails); strongDependencies.add(A_U_D_o365EmailAddressesMU); return strongDependencies; }
code_review: This code is duplicate. Moreover, repeated "add" operations are not necessary. You can use something like this: ``` return Arrays.asList( A_U_D_preferredMail, A_U_D_ISMail, A_U_D_publicAliasMails, A_U_D_privateAliasMails, A_U_D_o365EmailAddressesMU); ```
target code: public List < String > getStrongDependencies ( ) { return Arrays . asList ( A_U_D_preferredMail , A_U_D_ISMail , A_U_D_publicAliasMails , A_U_D_privateAliasMails , A_U_D_o365EmailAddressesMU ) ; }
response: public List < String > getStrongDependencies ( ) { return Arrays . asList ( A_U_D_preferredMail , A_U_D_ISMail , A_U_D_publicAliasMails , A_U_D_privateAliasMails , A_U_D_o365EmailAddressesMU ) ; }

sample: 267
buggy_code: boolean isCacheable() { <START> return true; <END> }
code_review: `isCacheable` is now `true`? I guess this was supposed to be `false` for generic extractors. Or am I wrong?
target code: boolean isCacheable ( ) { return false ; }
response: boolean isCacheable ( ) { return false ; }

sample: 268
buggy_code: <START> protected static KeyManagerFactory buildKeyManagerFactory(File certChainFile, <END> String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf, String keyStore) throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidAlgorithmParameterException, IOException, CertificateException, KeyException, UnrecoverableKeyException { return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm, toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore); }
code_review: It does not make sense to expose a protected method and mark it as @Deprecated from the beginning. Maybe you should remove the annotation and make it package-private ?
target code: static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , String keyAlgorithm , File keyFile , String keyPassword , KeyManagerFactory kmf , String keyStore ) throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , CertificateException , KeyException , UnrecoverableKeyException { return buildKeyManagerFactory ( toX509Certificates ( certChainFile ) , keyAlgorithm , toPrivateKey ( keyFile , keyPassword ) , keyPassword , kmf , keyStore ) ; }
response: Code : static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , String keyAlgorithm , File keyFile , String keyPassword , KeyManagerFactory kmf , String keyStore ) throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , CertificateException , KeyException , UnrecoverableKeyException { return buildKeyManagerFactory ( toX509Certificates ( certChainFile ) , keyAlgorithm , toPrivateKey ( keyFile , keyPassword ) , keyPassword , kmf , keyStore ) ; }

sample: 269
buggy_code: public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { // send request channel.connect(); fail("should have thrown!"); } catch (IOException e) { <START> assertTrue(e.getMessage().contains("Connection refused")); <END> } }
code_review: It's probably a bad idea to be checking for exception messages in the first place.
target code: public void testWrongPortConnection ( ) throws Exception { BlockingChannel channel = new SSLBlockingChannel ( hostName , sslPort + 1 , new MetricRegistry ( ) , 10000 , 10000 , 10000 , 2000 , sslSocketFactory , clientSSLConfig ) ; try { // send request channel . connect ( ) ; fail ( "should have thrown ! " ) ; } catch ( IOException e ) { } }
response: public void testWrongPortConnection ( ) throws Exception { BlockingChannel channel = new SSLBlockingChannel ( hostName , sslPort + 1 , new MetricRegistry ( ) , 10000 , 10000 , 10000 , 2000 , sslSocketFactory , clientSSLConfig ) ; try { // send request channel . connect ( ) ; fail ( "should have thrown ! " ) ; } catch ( IOException e ) { assertTrue ( e instanceof ConnectException ) ; } }

sample: 270
buggy_code: public void notifyParameterChanged(String name) { if (!fParameterNames.contains(name)) { throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName())); } <START> synchronized (fParameters) { <END> Object oldValue = fParameters.get(name); Object value = getParameter(name); if ((value != null) && !(value.equals(oldValue))) { parameterChanged(name); } } }
code_review: the .contains() should probably be in the synchronized block too
target code: public void notifyParameterChanged ( String name ) { synchronized ( fParameters ) { if ( ! fParameterNames . contains ( name ) ) { throw new RuntimeException ( String . format ( Messages . TmfAbstractAnalysisModule_InvalidParameter , name , getName ( ) ) ) ; } Object oldValue = fParameters . get ( name ) ; Object value = getParameter ( name ) ; if ( ( value != null ) && ! ( value . equals ( oldValue ) ) ) { parameterChanged ( name ) ; } } }
response: public void notifyParameterChanged ( String name ) { synchronized ( fParameters ) { if ( ! fParameterNames . contains ( name ) ) { throw new RuntimeException ( String . format ( Messages . TmfAbstractAnalysisModule_InvalidParameter , name , getName ( ) ) ) ; } Object oldValue = fParameters . get ( name ) ; Object value = getParameter ( name ) ; if ( ( value != null ) && ! ( value . equals ( oldValue ) ) ) { parameterChanged ( name ) ; } } }

sample: 271
buggy_code: public void testUnrecognizedSpec() { when(authentication.getAttributes().get(any(String.class))).thenReturn("strong_two_factor"); spec.setAuthenticationMethod("weak_two_factor"); <START> assertTrue(this.spec.isSatisfiedBy(this.assertion)); <END> }
code_review: Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue?
target code: public void testUnrecognizedSpec ( ) { when ( authentication . getAttributes ( ) . get ( any ( String . class ) ) ) . thenReturn ( "strong_two_factor" ) ; spec . setAuthenticationMethod ( "weak_two_factor" ) ; spec . isSatisfiedBy ( this . assertion ) ; }
response: public void testUnrecognizedSpec ( ) { when ( authentication . getAttributes ( ) . get ( any ( String . class ) ) ) . thenReturn ( "strong_two_factor" ) ; spec . setAuthenticationMethod ( "weak_two_factor" ) ; this . spec . isSatisfiedBy ( this . assertion ) ; }

sample: 272
buggy_code: <START> public static Bundle updateBundleConfig(Connection connection, Bundle bundle) <END> throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"; try (final PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, bundle.config); statement.setLong(2, bundle.bundle); statement.setLong(3, bundle.view); statement.execute(); } return null; }
code_review: Why does this claim to return Bundle? Doesn't really matter though :)
target code: private void updateBundleConfig ( Connection connection , Bundle bundle ) throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config = ? WHERE bundle_id = ? AND view_id = ? " ; try ( final PreparedStatement statement = connection . prepareStatement ( sql ) ) { statement . setString ( 1 , bundle . config ) ; statement . setLong ( 2 , bundle . bundle ) ; statement . setLong ( 3 , bundle . view ) ; statement . execute ( ) ; } }
response: Here's the  java public static void updateBundleConfig ( Connection connection , Bundle bundle ) throws SQLException { String sql = "UPDATE portti_view_bundle_seq SET config = ? WHERE bundle_id = ? AND view_id = ? " ; try ( PreparedStatement statement = connection . prepareStatement ( sql ) ) { statement . setString ( 1 , bundle . getConfig ( ) ) ; statement . setLong ( 2 , bundle . getBundleId ( ) ) ; statement . setLong ( 3 , bundle . getViewId ( ) ) ; statement . executeUpdate ( ) ; } }  Changes made : - Removed the `return null` statement as it was not necessary . - Changed the method signature to return `void` instead of `Bundle` . - Used the getter methods ( `getConfig ( ) ` , `getBundleId ( ) ` , `getViewId ( ) ` ) to access the fields of the `Bundle` object . - Changed `execute ( ) ` to `executeUpdate ( ) ` as we are performing an update operation .

sample: 273
buggy_code: protected int getOverProvisioningFactor() { <START> return Integer.valueOf(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING)); <END> }
code_review: `Integer.parseInt`
target code: protected int getOverProvisioningFactor ( ) { return Integer . parseInt ( Framework . getProperty ( WORKMANAGER_OVERPROVISIONING_PROP , DEFAULT_WORKMANAGER_OVERPROVISIONING ) ) ; }
response: protected int getOverProvisioningFactor ( ) { return Integer . parseInt ( Framework . getProperty ( WORKMANAGER_OVERPROVISIONING_PROP , DEFAULT_WORKMANAGER_OVERPROVISIONING ) ) ; }

sample: 274
buggy_code: protected void onDestroy() { <START> super.onDestroy(); <END> webView.setDownloadListener(null); }
code_review: Please move `super.onDestroy` to the end of the method.
target code: protected void onDestroy ( ) { webView . setDownloadListener ( null ) ; super . onDestroy ( ) ; }
response: protected void onDestroy ( ) { webView . setDownloadListener ( null ) ; super . onDestroy ( ) ; }

sample: 275
buggy_code: <START> public void closeTest() { <END> // request is keep-alive by default. HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString()); EmbeddedChannel channel = createEmbeddedChannel(); channel.writeInbound(request); // drain the channel of content. while (channel.readOutbound() != null) { ; } assertFalse("Channel should be closed", channel.isOpen()); }
code_review: Which part in this test calls `NettyResponseChannel.close()`?
target code: public void closeTest ( ) { // request is keep - alive by default . HttpRequest request = createRequestWithHeaders ( HttpMethod . GET , TestingUri . Close . toString ( ) ) ; EmbeddedChannel channel = createEmbeddedChannel ( ) ; channel . writeInbound ( request ) ; // drain the channel of content . while ( channel . readOutbound ( ) != null ) { } assertFalse ( "Channel should be closed" , channel . isOpen ( ) ) ; }
response: public void testClose ( ) { HttpRequest request = createRequestWithHeaders ( HttpMethod . GET , TestingUri . Close . toString ( ) ) ; EmbeddedChannel channel = createEmbeddedChannel ( ) ; channel . writeInbound ( request ) ; while ( channel . readOutbound ( ) != null ) { ; } assertFalse ( "Channel should be closed" , channel . isOpen ( ) ) ; assertTrue ( "Response channel should be closed" , channel . pipeline ( ) . get ( NettyResponseChannel . class ) . isClosed ( ) ) ; }  The `assertTrue` statement checks if the `NettyResponseChannel` is closed .

sample: 276
buggy_code: public String getRuleLogsForVms() { <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("get_rule_logs_for_vms"); final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser(); final String result = cmd.execute(parser); if (result == null) { return parser.getLine(); } return null; }
code_review: Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion.
target code: public String getRuleLogsForVms ( ) { final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "get_rule_logs_for_vms" ) ; final OutputInterpreter . OneLineParser parser = new OutputInterpreter . OneLineParser ( ) ; final String result = cmd . execute ( parser ) ; if ( result == null ) { return parser . getLine ( ) ; } return null ; }
response: public String getRuleLogsForVms ( ) { final Script cmd = new Script ( _securityGroupPath , _timeout . toMillis ( ) , s_logger ) ; cmd . add ( "get_rule_logs_for_vms" ) ; final OutputInterpreter . OneLineParser parser = new OutputInterpreter . OneLineParser ( ) ; final String result = cmd . execute ( parser ) ; if ( result == null ) { return parser . getLine ( ) ; } return null ; }

sample: 277
buggy_code: private void addReporter(Class<? extends IReporter> r) { <START> m_reporters.put(r, ClassHelper.newInstance(r)); <END> }
code_review: We can avoid the instance creation if the reporter already exist
target code: private void addReporter ( Class < ? extends IReporter > r ) { if ( ! m_reporters . containsKey ( r ) ) { m_reporters . put ( r , ClassHelper . newInstance ( r ) ) ; } }
response: private void addReporter ( Class < ? extends IReporter > r ) { if ( ! m_reporters . containsKey ( r ) ) { m_reporters . put ( r , ClassHelper . newInstance ( r ) ) ; } }

sample: 278
buggy_code: <START> public final synchronized void addFunctions(List<? extends SqlFunction> functions) <END> { addFunctions(TEMP_DEFAULT_CATALOG, functions); }
code_review: Don't mark methods as `final`.
target code: public void addFunctions ( List < ? extends SqlFunction > functions ) { addFunctions ( TEMP_DEFAULT_CATALOG , functions ) ; }
response: < START > public synchronized void addFunctions ( List < ? extends SqlFunction > functions ) { addFunctions ( TEMP_DEFAULT_CATALOG , functions ) ; } < END >

sample: 279
buggy_code: public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) { <START> if (oldInput != newInput) { <END> if (newInput != null) { ImportTraceContentProvider input = (ImportTraceContentProvider) newInput; clearCandidates(); fTraceTypes.putAll(input.fTraceTypes); fTraceFiles.putAll(fTraceFiles); } } }
code_review: You can join the ifs. There's a content assist for that, it's awesome.
target code: public synchronized void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( oldInput != newInput && newInput != null ) { ImportTraceContentProvider input = ( ImportTraceContentProvider ) newInput ; clearCandidates ( ) ; fTraceTypes . putAll ( input . fTraceTypes ) ; fTraceFiles . putAll ( fTraceFiles ) ; } }
response: public synchronized void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( oldInput != newInput && newInput != null ) { ImportTraceContentProvider input = ( ImportTraceContentProvider ) newInput ; clearCandidates ( ) ; fTraceTypes . putAll ( input . fTraceTypes ) ; fTraceFiles . putAll ( fTraceFiles ) ; } }

sample: 280
buggy_code: <START> boolean isPowerManagementLegal() { <END> return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup() .getcompatibility_version().toString()); }
code_review: please set a modifier - protected seem suitable
target code: protected boolean isPowerManagementLegal ( ) { return IsPowerManagementLegal ( getParameters ( ) . getVdsStaticData ( ) , getVdsGroup ( ) . getcompatibility_version ( ) . toString ( ) ) ; }
response: protected boolean isPowerManagementLegal ( ) { return IsPowerManagementLegal ( getParameters ( ) . getVdsStaticData ( ) , getVdsGroup ( ) . getcompatibility_version ( ) . toString ( ) ) ; }

sample: 281
buggy_code: public void info(String message) { <START> System.out.println(message); <END> info.add(message); }
code_review: Should avoid `System.out` in tests. Instead can you write to log4j
target code: public void info ( String message ) { info . add ( message ) ; }
response: public void info ( String message ) { logger . info ( message ) ; info . add ( message ) ; }

sample: 282
buggy_code: public static File makeNumericDimFile(File dir, String dimension, ByteOrder order) { <START> return new File(dir, StringUtils.safeFormat("numeric_dim_%s_%s.drd", dimension, order)); <END> }
code_review: Probably should crash if bad format string
target code: public static File makeNumericDimFile ( File dir , String dimension , ByteOrder order ) { return new File ( dir , StringUtils . format ( "numeric_dim_ % s_ % s . drd" , dimension , order ) ) ; }
response: public static File makeNumericDimFile ( File dir , String dimension , ByteOrder order ) { String fileName = String . format ( "numeric_dim_ % s_ % s . drd" , dimension , order ) ; if ( fileName . contains ( " % " ) ) { throw new IllegalArgumentException ( "Bad format string" ) ; } return new File ( dir , fileName ) ; }

sample: 283
buggy_code: private AuditLogableBase createAuditLog(final VmNic iface) { AuditLogableBase logable = new AuditLogableBase(); <START> logable.setVmId(iface.getVmId()); <END> logable.addCustomValue("MACAddr", iface.getMacAddress()); logable.addCustomValue("IfaceName", iface.getName()); return logable; }
code_review: Is there any longer a need for the VM ID ?
target code: private AuditLogableBase createAuditLog ( final VmNic iface ) { AuditLogableBase logable = new AuditLogableBase ( ) ; logable . addCustomValue ( "MACAddr" , iface . getMacAddress ( ) ) ; logable . addCustomValue ( "IfaceName" , iface . getName ( ) ) ; return logable ; }
response: private AuditLogableBase createAuditLog ( final VmNic iface ) { AuditLogableBase logable = new AuditLogableBase ( ) ; logable . addCustomValue ( "MACAddr" , iface . getMacAddress ( ) ) ; logable . addCustomValue ( "IfaceName" , iface . getName ( ) ) ; return logable ; }  Since there is no longer a need for the VM ID , the line of code that sets the VM ID has been removed from the original code .

sample: 284
buggy_code: public boolean equals( VirtualValue other ) { <START> if ( other == null || !(other instanceof MapValue) ) <END> { return false; } MapValue that = (MapValue) other; return size() == that.size() && Arrays.equals( keys, that.keys ) && Arrays.equals( values, that.values ); }
code_review: same here, redundant?
target code: public boolean equals ( VirtualValue other ) { if ( other == null || other . getClass ( ) != MapValue . class ) { return false ; } MapValue that = ( MapValue ) other ; return map . equals ( that . map ) ; }
response: public boolean equals ( Object other ) { if ( other == null || ! ( other instanceof MapValue ) ) { return false ; } MapValue that = ( MapValue ) other ; return size ( ) == that . size ( ) && Arrays . equals ( keys , that . keys ) && Arrays . equals ( values , that . values ) ; }

sample: 285
buggy_code: private void processSingleClusterChanges(ManageNetworkClustersParameters param) { final List<ActionParametersBase> setupNetworksParams = new ArrayList<>( createNetworkClustersToSetupNetworksParametersTransformer().transform( param.getAttachments(), param.getDetachments(), param.getUpdates()) ); HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams); setupNetworksParams.forEach(this::withRootCommandInfo); <START> runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext()); <END> }
code_review: nit: Formatting
target code: private void processSingleClusterChanges ( ManageNetworkClustersParameters param ) { final List < ActionParametersBase > setupNetworksParams = new ArrayList < > ( createNetworkClustersToSetupNetworksParametersTransformer ( ) . transform ( param . getAttachments ( ) , param . getDetachments ( ) , param . getUpdates ( ) ) ) ; HostSetupNetworksParametersBuilder . updateParametersSequencing ( setupNetworksParams ) ; setupNetworksParams . forEach ( this : : withRootCommandInfo ) ; runInternalMultipleActions ( ActionType . PersistentHostSetupNetworks , setupNetworksParams ) ; }
response: private void processSingleClusterChanges ( ManageNetworkClustersParameters param ) { final List < ActionParametersBase > setupNetworksParams = new ArrayList < > ( createNetworkClustersToSetupNetworksParametersTransformer ( ) . transform ( param . getAttachments ( ) , param . getDetachments ( ) , param . getUpdates ( ) ) ) ; HostSetupNetworksParametersBuilder . updateParametersSequencing ( setupNetworksParams ) ; setupNetworksParams . forEach ( this : : withRootCommandInfo ) ; runInternalMultipleActions ( ActionType . PersistentHostSetupNetworks , setupNetworksParams , getContext ( ) . getExecutionContext ( ) ) ; }

sample: 286
buggy_code: <START> private void setFixedLengthStreamingMode(HttpURLConnection connection, long length) { <END> try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter! HttpURLConnection.class.getMethod("setFixedLengthStreamingMode", long.class).invoke(connection, length); } catch (Exception e) { throw new IllegalArgumentException("Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations." + " Use chunked encoding or multi-part upload, if possible, or use a different http driver." + " For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"); } }
code_review: [minor] Can be static?
target code: private static void setFixedLengthStreamingMode ( HttpURLConnection connection , long length ) { try { // Not caching method as invocation is literally sending > 2GB , which means reflection isn't a limiter ! HttpURLConnection . class . getMethod ( "setFixedLengthStreamingMode" , long . class ) . invoke ( connection , length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Cannot transfer 2 GB or larger chunks due to JDK 1 . 6 limitations . " + " Use chunked encoding or multi - part upload , if possible , or use a different http driver . " + " For more information : http :/ / bugs . sun . com / bugdatabase / view_bug . do ? bug_id = 6755625" ) ; } }
response: < START > private static void setFixedLengthStreamingMode ( HttpURLConnection connection , long length ) { < END > try { HttpURLConnection . class . getMethod ( "setFixedLengthStreamingMode" , long . class ) . invoke ( connection , length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Cannot transfer 2 GB or larger chunks due to JDK 1 . 6 limitations . " + " Use chunked encoding or multi - part upload , if possible , or use a different http driver . " + " For more information : http :/ / bugs . sun . com / bugdatabase / view_bug . do ? bug_id = 6755625" ) ; } }

sample: 287
buggy_code: <START> String getErrorMessage(ClientResponse clientResponse) { <END> String response = clientResponse.getEntity(String.class); try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser().readValue(response, ApiError.class); return error.getMessage(); } catch (IOException e) { // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever) int statusCode = clientResponse.getStatus(); ClientResponse.Status status = clientResponse.getClientResponseStatus(); String responseText = clientResponse.getEntity(String.class); return "Server returned "+status+"("+statusCode+"); "+responseText; } }
code_review: Method should probably be protected, given writing this for sub-classing.
target code: protected String getErrorMessage ( ClientResponse clientResponse ) { String response = clientResponse . getEntity ( String . class ) ; try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser ( ) . readValue ( response , ApiError . class ) ; return error . getMessage ( ) ; } catch ( IOException e ) { // If not , inform the user of the underlying response ( e . g . if server threw NPE or whatever ) int statusCode = clientResponse . getStatus ( ) ; ClientResponse . Status status = clientResponse . getClientResponseStatus ( ) ; String responseText = clientResponse . getEntity ( String . class ) ; return "Server returned " + status + " ( " + statusCode + " ) ; " + responseText ; } }
response: protected String getErrorMessage ( ClientResponse clientResponse ) { String response = clientResponse . getEntity ( String . class ) ; try { ApiError error = getJsonParser ( ) . readValue ( response , ApiError . class ) ; return error . getMessage ( ) ; } catch ( IOException e ) { int statusCode = clientResponse . getStatus ( ) ; ClientResponse . Status status = clientResponse . getClientResponseStatus ( ) ; String responseText = clientResponse . getEntity ( String . class ) ; return "Server returned " + status + " ( " + statusCode + " ) ; " + responseText ; } }

sample: 288
buggy_code: public int hashCode() { int bits = 1; bits = 31 * bits + this.type.ordinal(); bits = 31 * bits + getToX(); bits = 31 * bits + getToY(); bits = 31 * bits + getToZ(); bits = 31 * bits + getFromX(); bits = 31 * bits + getFromY(); bits = 31 * bits + getFromZ(); <START> return bits; <END> }
code_review: `b ^ (b >> 31)` is missed here.
target code: public int hashCode ( ) { int bits = 1 ; bits = 31 * bits + this . type . ordinal ( ) ; bits = 31 * bits + getToX ( ) ; bits = 31 * bits + getToY ( ) ; bits = 31 * bits + getToZ ( ) ; bits = 31 * bits + getFromX ( ) ; bits = 31 * bits + getFromY ( ) ; bits = 31 * bits + getFromZ ( ) ; return bits ^ ( bits > > 31 ) ; }
response: public int hashCode ( ) { int bits = 1 ; bits = 31 * bits + this . type . ordinal ( ) ; bits = 31 * bits + getToX ( ) ; bits = 31 * bits + getToY ( ) ; bits = 31 * bits + getToZ ( ) ; bits = 31 * bits + getFromX ( ) ; bits = 31 * bits + getFromY ( ) ; bits = 31 * bits + getFromZ ( ) ; return bits ^ ( bits > > 31 ) ; }

sample: 289
buggy_code: public static AccountCollection all(Map<String, Object> params) throws AuthenticationException, InvalidRequestException, APIConnectionException, CardException, APIException { <START> return request(RequestMethod.GET, classURL(Account.class), params, AccountCollection.class, (RequestOptions) null); <END> }
code_review: This should call all ``` java return all(params, (RequestOptions) null); ```
target code: public static AccountCollection all ( Map < String , Object > params ) throws AuthenticationException , InvalidRequestException , APIConnectionException , CardException , APIException { return all ( params , ( RequestOptions ) null ) ; }
response: java public static AccountCollection all ( Map < String , Object > params ) throws AuthenticationException , InvalidRequestException , APIConnectionException , CardException , APIException { return all ( params , ( RequestOptions ) null ) ; }

sample: 290
buggy_code: public void onSaveClick() { editView.setSaveState(true); WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient(); <START> client.submitDescription(pageTitle, editView.getDescription(), <END> new WikidataDescriptionEditDataClient.Callback() { @Override public void success() { editView.setSaveState(false); L.i("WD description edit successful"); // TODO: go to success fragment } @Override public void failure(@NonNull Throwable caught) { editView.setSaveState(false); L.e("WD description edit failed: ", caught); // TODO: go to failure fragment } }); }
code_review: Since this is a Fragment with a lifecycle, consider holding a reference to Call<?> and canceling it in onDestroy() if Call<?> is nonnull.
target code: public void onSaveClick ( ) { editView . setSaveState ( true ) ; if ( client == null ) { client = new WikidataDescriptionEditDataClient ( ) ; } client . request ( pageTitle , editView . getDescription ( ) , new WikidataDescriptionEditDataClient . Callback ( ) { @Override public void success ( ) { editView . setSaveState ( false ) ; L . i ( "WD description edit successful" ) ; // TODO : go to success fragment } @Override public void failure ( @NonNull Throwable caught ) { editView . setSaveState ( false ) ; L . e ( "WD description edit failed : " , caught ) ; // TODO : go to failure fragment } } ) ; }
response: public void onSaveClick ( ) { editView . setSaveState ( true ) ; WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient ( ) ; call = client . submitDescription ( pageTitle , editView . getDescription ( ) , new WikidataDescriptionEditDataClient . Callback ( ) { @Override public void success ( ) { editView . setSaveState ( false ) ; L . i ( "WD description edit successful" ) ; // TODO : go to success fragment } @Override public void failure ( @NonNull Throwable caught ) { editView . setSaveState ( false ) ; L . e ( "WD description edit failed : " , caught ) ; // TODO : go to failure fragment } } ) ; } @Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( call != null ) { call . cancel ( ) ; } }

sample: 291
buggy_code: protected ResourceSet loadResource(IEditorInput editorInput) { <START> final URI resourceURI = EditUIUtil.getURI(getEditorInput(), null); <END> return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack()); }
code_review: why not use the passed in editorInput
target code: protected ResourceSet loadResource ( IEditorInput editorInput ) { final URI resourceURI = EditUIUtil . getURI ( editorInput , null ) ; return ResourceSetHelpers . loadResourceSetWithProxies ( resourceURI , getCommandStack ( ) ) ; }
response: protected ResourceSet loadResource ( IEditorInput editorInput ) { final URI resourceURI = EditUIUtil . getURI ( editorInput , null ) ; return ResourceSetHelpers . loadResourceSetWithProxies ( resourceURI , getCommandStack ( ) ) ; }

sample: 292
buggy_code: FileReftableStack.CompactionStats getCompactionStats() <START> throws IOException { <END> return reftableStack.getStats(); }
code_review: declared exception isn't thrown
target code: FileReftableStack . CompactionStats getCompactionStats ( ) { return reftableStack . getStats ( ) ; }
response: Code Refactored :  FileReftableStack . CompactionStats getCompactionStats ( ) throws IOException { return reftableStack . getStats ( ) ; }

sample: 293
buggy_code: public OnlineBackup incremental( String targetDirectory ) { outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ), <START> getConsistencyCheck( true ), timeoutMillis, defaultConfig() ); <END> return this; }
code_review: This changes default behaviour, right? Should it?
target code: public OnlineBackup incremental ( String targetDirectory ) { outcome = new BackupService ( ) . doIncrementalBackup ( hostNameOrIp , port , new File ( targetDirectory ) , getConsistencyCheck ( false ) , timeoutMillis , defaultConfig ( ) ) ; return this ; }
response: public OnlineBackup incremental ( String targetDirectory ) { outcome = new BackupService ( ) . doIncrementalBackup ( hostNameOrIp , port , new File ( targetDirectory ) , getConsistencyCheck ( true ) , timeoutMillis , defaultConfig ( ) ) ; return this ; } // Review : This code changes the default behavior by calling the getConsistencyCheck method with a true parameter . It is unclear if this is intentional or not . If it is intentional , it should be documented and reviewed for potential impact on the system . If it is not intentional , the parameter should be changed to false or removed altogether to maintain the default behavior .

sample: 294
buggy_code: private boolean isValidConfiguration() { if (isDiscarding() || isCalleeData()) { return isAsync(); } else { return true; <START> } <END> }
code_review: This could just be `return !(isDiscarding() || isCalleeData()) || isAsync();`
target code: private boolean isValidConfiguration ( ) { return ! ( isDiscarding ( ) || isCalleeData ( ) ) || isAsync ( ) ; }
response: private boolean isValidConfiguration ( ) { return ! ( isDiscarding ( ) || isCalleeData ( ) ) || isAsync ( ) ; }

sample: 295
buggy_code: public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException { boolean ret = super.setTrace(trace); if (!ret) { return ret; } ret = fCriticalPathModule.setTrace(trace); <START> fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); <END> return ret; }
code_review: should this be set if ret is false? I don't know.
target code: public boolean setTrace ( @NonNull ITmfTrace trace ) throws TmfAnalysisException { boolean ret = super . setTrace ( trace ) ; if ( ! ret ) { return ret ; } ret = fCriticalPathModule . setTrace ( trace ) ; if ( ret ) { fCriticalPathModule . setParameter ( CriticalPathModule . PARAM_GRAPH , getId ( ) ) ; } return ret ; }
response: public boolean setTrace ( @NonNull ITmfTrace trace ) throws TmfAnalysisException { boolean ret = super . setTrace ( trace ) ; if ( ! ret ) { return ret ; } ret = fCriticalPathModule . setTrace ( trace ) ; if ( ret ) { fCriticalPathModule . setParameter ( CriticalPathModule . PARAM_GRAPH , getId ( ) ) ; } return ret ; }

sample: 296
buggy_code: public void fillContextMenu(final IMenuManager menu) { super.fillContextMenu(menu); final ISelection selection = getContext().getSelection(); if (selection.isEmpty()) { return; } // Wait the end of the loading of the representations file try { Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor()); } catch (InterruptedException e) { <START> throw new RuntimeException(e); <END> } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown. // Fill the context menu contextMenuFiller.fillContextMenu(menu, selection); }
code_review: Before, with waitOtherJobs, we "Do nothing" in case of InterruptedException. Why do you change that? Have you test the difference?
target code: public void fillContextMenu ( final IMenuManager menu ) { super . fillContextMenu ( menu ) ; final ISelection selection = getContext ( ) . getSelection ( ) ; if ( selection . isEmpty ( ) ) { return ; } // Wait the end of the loading of the representations file try { Job . getJobManager ( ) . join ( AbstractRepresentationsFileJob . FAMILY , new NullProgressMonitor ( ) ) ; } catch ( InterruptedException e ) { // Do nothing } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown . // Fill the context menu contextMenuFiller . fillContextMenu ( menu , selection ) ; }
response: public void fillContextMenu ( final IMenuManager menu ) { super . fillContextMenu ( menu ) ; final ISelection selection = getContext ( ) . getSelection ( ) ; if ( selection . isEmpty ( ) ) { return ; } try { Job . getJobManager ( ) . join ( AbstractRepresentationsFileJob . FAMILY , new NullProgressMonitor ( ) ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } contextMenuFiller . fillContextMenu ( menu , selection ) ; }

sample: 297
buggy_code: public void dispose() { // run super. super.dispose(); // remove ourselves as a selection and registry listener getSite().getPage().removePostSelectionListener(this); RegistryFactory.getRegistry().removeListener(this); SaveablesList saveables = <START> (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); <END> if (saveables != null) { saveables.removeModelLifecycleListener(saveablesTracker); } currentPart = null; currentSelection = null; pinPropertySheetAction = null; }
code_review: Are you sure about that cast operation? You are asking for a service interface and cast it to a concrete implementation without instanceof check. You perform that check in the tracker that is only added to a SaveablesList.
target code: public void dispose ( ) { // run super . super . dispose ( ) ; // remove ourselves as a selection and registry listener getSite ( ) . getPage ( ) . removePostSelectionListener ( this ) ; RegistryFactory . getRegistry ( ) . removeListener ( this ) ; ISaveablesLifecycleListener saveables = getSite ( ) . getService ( ISaveablesLifecycleListener . class ) ; if ( saveables instanceof SaveablesList ) { ( ( SaveablesList ) saveables ) . removeModelLifecycleListener ( saveablesTracker ) ; } currentPart = null ; currentSelection = null ; pinPropertySheetAction = null ; }
response: public void dispose ( ) { // run super . super . dispose ( ) ; // remove ourselves as a selection and registry listener getSite ( ) . getPage ( ) . removePostSelectionListener ( this ) ; RegistryFactory . getRegistry ( ) . removeListener ( this ) ; ISaveablesLifecycleListener saveables = getSite ( ) . getService ( ISaveablesLifecycleListener . class ) ; if ( saveables instanceof SaveablesList ) { ( ( SaveablesList ) saveables ) . removeModelLifecycleListener ( saveablesTracker ) ; } currentPart = null ; currentSelection = null ; pinPropertySheetAction = null ; }

sample: 298
buggy_code: public void setBaseballCard(BaseballCard card) { Locale locale = Locale.getDefault(); brand.setText(card.brand); year.setText(String.format(locale, "%d", card.year)); <START> number.setText(String.format(locale, "%s", card.number)); <END> player.setText(card.playerName); }
code_review: `String.format()` is no longer necessary here.
target code: public void setBaseballCard ( BaseballCard card ) { Locale locale = Locale . getDefault ( ) ; brand . setText ( card . brand ) ; year . setText ( String . format ( locale , " % d" , card . year ) ) ; number . setText ( card . number ) ; player . setText ( card . playerName ) ; }
response: public void setBaseballCard ( BaseballCard card ) { Locale locale = Locale . getDefault ( ) ; brand . setText ( card . brand ) ; year . setText ( String . valueOf ( card . year ) ) ; number . setText ( card . number ) ; player . setText ( card . playerName ) ; }

sample: 299
buggy_code: <START> private String capitalize(String word) { <END> return Character.toUpperCase(word.charAt(0)) + word.substring(1); }
code_review: Can be static
target code: private static String capitalize ( String word ) { return Character . toUpperCase ( word . charAt ( 0 ) ) + word . substring ( 1 ) ; }
response: private static String capitalize ( String word ) { return Character . toUpperCase ( word . charAt ( 0 ) ) + word . substring ( 1 ) ; }


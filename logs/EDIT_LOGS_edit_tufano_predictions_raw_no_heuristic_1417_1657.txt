sample: 1417
buggy_code: public HllSketchMergeBufferAggregator( final ColumnValueSelector<HllSketch> selector, final int lgK, final TgtHllType tgtHllType, final int size ) { this.selector = selector; this.lgK = lgK; this.tgtHllType = tgtHllType; this.size = size; this.emptyUnion = new byte[size]; //noinspection ResultOfObjectAllocationIgnored (Union writes to "emptySketch" as a side effect of construction) <START> new Union(lgK, WritableMemory.wrap(emptyUnion, ByteOrder.LITTLE_<END>IAN)); <END> }
code_review: No need to force byte order when wrapping byte[]
target code: public HllSketchMergeBufferAggregator ( final ColumnValueSelector < HllSketch > selector , final int lgK , final TgtHllType tgtHllType , final int size ) { this . selector = selector ; this . lgK = lgK ; this . tgtHllType = tgtHllType ; this . size = size ; this . emptyUnion = new byte [ size ] ; // noinspection ResultOfObjectAllocationIgnored ( Union writes to "emptyUnion" as a side effect of construction ) new Union ( lgK , WritableMemory . wrap ( emptyUnion ) ) ; }
response: public HllSketchMergeBufferAggregator( final ColumnValueSelector<HllSketch> selector, final int lgK, final TgtHllType tgtHllType, final int size ) { this.selector = selector; this.lgK = lgK; this.tgtHllType = tgtHllType; this.size = size; this.emptyUnion = new byte[size]; //noinspection ResultOfObjectAllocationIgnored (Union writes to "emptySketch" as a side effect of construction) <START> new Union(lgK, WritableMemory.wrap(emptyUnion)); <END> }

sample: 1418
buggy_code: public void checkIPAdress() { Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address)); <START> assertEquals(validate.isEmpty(), expectedResult); <END> }
code_review: The expected value should be 1st, it affects error messages by junit
target code: public void checkIPAdress ( ) { Set < ConstraintViolation < IPAdress > > validate = validator . validate ( new IPAdress ( address ) ) ; assertEquals ( expectedResult , validate . isEmpty ( ) ) ; }
response: public void checkIPAdress() { Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address)); <START> assertEquals(expectedResult, validate.isEmpty()); <END> }

sample: 1419
buggy_code: public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { try { // Ignore first call, which comes from onCreate() if (currentFormat != null) calc(); } catch (GeopointException e) { <START> context.showToast(e.getMessage()); <END> spinner.setSelection(currentFormat.ordinal()); return; } currentFormat = coordInputFormatEnum.fromInt(pos); settings.setCoordInputFormat(currentFormat); updateGUI(); }
code_review: No good idea. ;)
target code: public void onItemSelected ( AdapterView < ? > parent , View view , int pos , long id ) { // Ignore first call , which comes from onCreate ( ) if ( currentFormat != null && ! calc ( ) ) { // An error occurred , reset spinner to current format spinner . setSelection ( currentFormat . ordinal ( ) ) ; return ; } currentFormat = coordInputFormatEnum . fromInt ( pos ) ; settings . setCoordInputFormat ( currentFormat ) ; updateGUI ( ) ; }
response: public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { try { // Ignore first call, which comes from onCreate() if (currentFormat != null) calc(); } catch (GeopointException e) { context.showToast(e.getMessage()); spinner.setSelection(currentFormat.ordinal()); return; } currentFormat = coordInputFormatEnum.fromInt(pos); settings.setCoordInputFormat(currentFormat); updateGUI(); }

sample: 1420
buggy_code: public boolean visitTableWithType(String schemaName, String tableName, TableType type) { Preconditions .checkNotNull(type, "Error. Type information for table %s.%s provided is null.", schemaName, tableName); records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString())); <START> return false; <END> }
code_review: why return `false`?
target code: private void visitTableWithType ( String schemaName , String tableName , TableType type ) { Preconditions . checkNotNull ( type , "Error . Type information for table % s . % s provided is null . " , schemaName , tableName ) ; records . add ( new Records . Table ( IS_CATALOG_NAME , schemaName , tableName , type . toString ( ) ) ) ; return ; }
response: public boolean visitTableWithType(String schemaName, String tableName, TableType type) { Preconditions .checkNotNull(type, "Error. Type information for table %s.%s provided is null.", schemaName, tableName); records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString())); <START> return true; <END> }

sample: 1421
buggy_code: public boolean add(XWikiAttachment attachment) { <START> return set(attachment) != null; <END> }
code_review: Comparing with null is not enough. You might replace an existing attachment with a different instance in which case you should return true. In short if the return is different from the input then something changed.
target code: public boolean add ( XWikiAttachment attachment ) { XWikiAttachment set = set ( attachment ) ; return set != attachment ; }
response: public boolean add(XWikiAttachment attachment) { <START> return set(attachment) != attachment; <END> }

sample: 1422
buggy_code: public String toString() { <START> return Objects.toStringHelper(this).add("liveWorkerNum", mLiveWorkerNum) <END> .add("lostWorkerNum", mLostWorkerNum).add("capacityBytes", mCapacityBytes) .add("usedBytes", mUsedBytes).add("freeBytes", mFreeBytes) .add("capacityBytesOnTiers", mCapacityBytesOnTiers) .add("usedBytesOnTiers", mUsedBytesOnTiers).toString(); }
code_review: ditto: sort by name please
target code: public String toString ( ) { return Objects . toStringHelper ( this ) . add ( "capacityBytes" , mCapacityBytes ) . add ( "capacityBytesOnTiers" , mCapacityBytesOnTiers ) . add ( "freeBytes" , mFreeBytes ) . add ( "liveWorkerNum" , mLiveWorkerNum ) . add ( "lostWorkerNum" , mLostWorkerNum ) . add ( "usedBytes" , mUsedBytes ) . add ( "usedBytesOnTiers" , mUsedBytesOnTiers ) . toString ( ) ; }
response: public String toString() { <START> return Objects.toStringHelper(this).add("capacityBytes", mCapacityBytes) <END> .add("capacityBytesOnTiers", mCapacityBytesOnTiers) .add("freeBytes", mFreeBytes).add("liveWorkerNum", mLiveWorkerNum) .add("lostWorkerNum", mLostWorkerNum).add("usedBytes", mUsedBytes) .add("usedBytesOnTiers", mUsedBytesOnTiers).toString(); }

sample: 1423
buggy_code: public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) { await().pollInterval(250, TimeUnit.MILLISECONDS) .atMost(10, TimeUnit.SECONDS) <START> .until(() -> !j.jenkins.get().getQueue().isBlockedByShutdown(task)); <END> }
code_review: ```suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task)); ```
target code: public static final void assertJenkinsNotInQuietMode ( final JenkinsRule j ) { await ( ) . pollInterval ( 250 , TimeUnit . MILLISECONDS ) . atMost ( 10 , TimeUnit . SECONDS ) . until ( ( ) - > ! j . jenkins . getQueue ( ) . isBlockedByShutdown ( task ) ) ; }
response: public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) { await().pollInterval(250, TimeUnit.MILLISECONDS) .atMost(10, TimeUnit.SECONDS) <START> .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task)); <END> }

sample: 1424
buggy_code: private TreeLayer <START> getTreeLayer() <END> { NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class); ILayer layer = natTable.getLayer(); if (layer instanceof PapyrusGridLayer) { PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer; ILayer rowLayer = gridLayer.getRowHeaderLayer(); if (rowLayer instanceof RowHeaderHierarchicalLayerStack) { return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer(); } } throw new UnknownError("TreeLayer has not been found"); //$NON-NLS-1$ }
code_review: The method signature doesn't specify the Exception which could be thrown.
target code: private TreeLayer getTreeLayer ( ) throws Exception { NatTable natTable = ( NatTable ) getTableManager ( ) . getAdapter ( NatTable . class ) ; ILayer layer = natTable . getLayer ( ) ; if ( layer instanceof PapyrusGridLayer ) { PapyrusGridLayer gridLayer = ( PapyrusGridLayer ) layer ; ILayer rowLayer = gridLayer . getRowHeaderLayer ( ) ; if ( rowLayer instanceof RowHeaderHierarchicalLayerStack ) { return ( ( RowHeaderHierarchicalLayerStack ) rowLayer ) . getTreeLayer ( ) ; } } throw new UnknownError ( "TreeLayer has not been found" ) ; // $NON - NLS - 1$ }
response: private TreeLayer <START> getTreeLayer() throws UnknownError <END> { NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class); ILayer layer = natTable.getLayer(); if (layer instanceof PapyrusGridLayer) { PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer; ILayer rowLayer = gridLayer.getRowHeaderLayer(); if (rowLayer instanceof RowHeaderHierarchicalLayerStack) { return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer(); } } throw new UnknownError("TreeLayer has not been found"); //$NON-NLS-1$ }

sample: 1425
buggy_code: public boolean equals(@Nullable Object obj) { <START> if (!(obj instanceof DataDrivenValueSelf)) { <END> return false; } return true; }
code_review: return directly
target code: public boolean equals ( @Nullable Object obj ) { if ( ! ( obj instanceof DataDrivenValueSelf ) ) { return false ; } return super . equals ( obj ) ; }
response: public boolean equals(@Nullable Object obj) { <START> if (!(obj instanceof DataDrivenValueSelf)) { <END> return false; } return true; }

sample: 1426
buggy_code: public void differentUrlForPostsAndVideo() { <START> SearchInput searchInput = new SearchInput().searchInputValue(); <END> SearchInput searchInputSubmit = new SearchInput().searchInputSubmit(); String URL = driver.getCurrentUrl(); Assert.assertEquals(URL, "http://qa.fandom.wikia.com/?s=TEST"); SearchInput postsResult = new SearchInput().searchResultsPosts(); String postUrl = driver.getCurrentUrl(); SearchInput videosResult = new SearchInput().searchResultsVideos(); String videoUrl = driver.getCurrentUrl(); Assert.assertNotEquals(postUrl, videoUrl); }
code_review: ![MAJOR](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-major.png) Remove this unused "searchInput" local variable. [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](http://sonar-s1/coding_rules#rule_key=squid%3AS1481)
target code: public void differentUrlForPostsAndVideo ( ) { SearchInput searchInput = new SearchInput ( ) . searchInputValue ( ) ; SearchInput searchInputSubmit = new SearchInput ( ) . searchInputSubmit ( ) ; SearchInput postsResult = new SearchInput ( ) . searchResultsPosts ( ) ; String postUrl = driver . getCurrentUrl ( ) ; SearchInput videosResult = new SearchInput ( ) . searchResultsVideos ( ) ; String videoUrl = driver . getCurrentUrl ( ) ; Assert . assertNotEquals ( postUrl , videoUrl ) ; }
response: public void differentUrlForPostsAndVideo() { <START> SearchInput searchInputSubmit = new SearchInput().searchInputSubmit(); String URL = driver.getCurrentUrl(); Assert.assertEquals(URL, "http://qa.fandom.wikia.com/?s=TEST"); SearchInput postsResult = new SearchInput().searchResultsPosts(); String postUrl = driver.getCurrentUrl(); SearchInput videosResult = new SearchInput().searchResultsVideos(); String videoUrl = driver.getCurrentUrl(); Assert.assertNotEquals(postUrl, videoUrl); }

sample: 1427
buggy_code: <START> String convert(Blob blob) { <END> if (blob.getLength() == 0L) { return ""; } try (InputStream stream = blob.getStream()) { Xml2TextHandler xml2text = new Xml2TextHandler(); return xml2text.parse(stream); } catch (IOException | SAXException | ParserConfigurationException e) { throw new ConversionException("Error during XML2Text conversion", e); } }
code_review: I would deprecate it and add a new one.
target code: protected String convert ( Blob blob ) { if ( blob . getLength ( ) == 0L ) { return "" ; } try ( InputStream stream = blob . getStream ( ) ) { Xml2TextHandler xml2text = new Xml2TextHandler ( ) ; return xml2text . parse ( stream ) ; } catch ( IOException | SAXException | ParserConfigurationException e ) { throw new ConversionException ( "Error during XML2Text conversion" , blob , e ) ; } }
response: <START> String convert(Blob blob) { <END> if (blob.getLength() == 0L) { return ""; } try (InputStream stream = blob.getStream()) { Xml2TextHandler xml2text = new Xml2TextHandler(); return xml2text.parse(stream); } catch (IOException | SAXException | ParserConfigurationException e) { throw new ConversionException("Error during XML2Text conversion", e); } }

sample: 1428
buggy_code: <START> public static void validateHeaderConfigAction(String action) { <END> if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) { throw new ConfigException(String.format("Invalid header config action: '%s'. " + "Expected one of %s", action, HEADER_ACTIONS)); } }
code_review: This should be package-level protected: ```suggestion // Visible for testing static void validateHeaderConfigAction(String action) { ```
target code: static void validateHeaderConfigAction ( String action ) { if ( ! HEADER_ACTIONS . stream ( ) . anyMatch ( action : : equalsIgnoreCase ) ) { throw new ConfigException ( String . format ( "Invalid header config action : ' % s' . " + "Expected one of % s" , action , HEADER_ACTIONS ) ) ; } }
response: // Visible for testing static void validateHeaderConfigAction(String action) { if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) { throw new ConfigException(String.format("Invalid header config action: '%s'. " + "Expected one of %s", action, HEADER_ACTIONS)); } }

sample: 1429
buggy_code: private String getVariableLabel(VariableMetadata variableMetadata) { if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) { return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + " " + <START> variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length(), variableMetadata.getName().length()); <END> } else { return variableMetadata.getName(); } }
code_review: `variableMetadata.getName().length()` invocation is redundant.
target code: private String getVariableLabel ( VariableMetadata variableMetadata ) { if ( variableMetadata . getName ( ) . startsWith ( CASE_VARIABLE_PREFIX ) ) { return translationService . getValue ( CASE_VARIABLE_LABEL_PREFIX ) + " " + variableMetadata . getName ( ) . substring ( CASE_VARIABLE_PREFIX . length ( ) ) ; } else { return variableMetadata . getName ( ) ; } }
response: private String getVariableLabel(VariableMetadata variableMetadata) { if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) { return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + " " + <START> variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length()); <END> } else { return variableMetadata.getName(); } }

sample: 1430
buggy_code: private Long findFreeId(){ <START> while(personRepository.findOne(lastId) != null){ // New person <END> lastId++; } return lastId; }
code_review: [existsById(long id)](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#existsById-ID-) ðŸ’¯
target code: private Long findFreeId ( ) { while ( personRepository . exists ( lastId ) ) { // New person lastId ++ ; } return lastId ; }
response: private Long findFreeId(){ <START> while(personRepository.existsById(lastId)){ // New person <END> lastId++; } return lastId; }

sample: 1431
buggy_code: public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { <START> Assume.assumeTrue(mCameraId != null); <END> mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); // Wait for the CameraDevice.onOpened callback. mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); // Wait for the CameraDevice.onClosed callback. mUseCase.mDeviceStateCallback.waitForOnClosed(1); }
code_review: Move to setUp(). You can make mCameraId a local variable again.
target code: public void cameraDeviceCallsAreForwardedToCallback ( ) throws InterruptedException { mUseCase . addStateChangeListener ( mCameraRepository . getCamera ( getCameraIdForLensFacingUnchecked ( mConfig . getLensFacing ( ) ) ) ) ; mUseCase . doNotifyActive ( ) ; mCameraRepository . onGroupActive ( mUseCaseGroup ) ; // Wait for the CameraDevice . onOpened callback . mUseCase . mDeviceStateCallback . waitForOnOpened ( 1 ) ; mCameraRepository . onGroupInactive ( mUseCaseGroup ) ; // Wait for the CameraDevice . onClosed callback . mUseCase . mDeviceStateCallback . waitForOnClosed ( 1 ) ; }
response: public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { Assume.assumeTrue(mCameraId != null); mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); // Wait for the CameraDevice.onOpened callback. mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); // Wait for the CameraDevice.onClosed callback. mUseCase.mDeviceStateCallback.waitForOnClosed(1); }

sample: 1432
buggy_code: public String getDescription() { <START> return getStatuteType().getName().getContent(I18N.getLocale()) <END> + (studentStatute instanceof SeniorStatute ? (" (" + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + ") ") : ""); }
code_review: Beware that invoking [`getContent(I18N.getLocale())`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L461-L475) is different than just invoking [`getContent()`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L480-L496).
target code: public String getDescription ( ) { return getStatuteType ( ) . getName ( ) . getContent ( ) + ( studentStatute instanceof SeniorStatute ? ( " ( " + ( ( SeniorStatute ) studentStatute ) . getRegistration ( ) . getDegree ( ) . getPresentationName ( ) + " ) " ) : "" ) ; }
response: public String getDescription() { <START> return getStatuteType().getName().getContent() <END> + (studentStatute instanceof SeniorStatute ? (" (" + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + ") ") : ""); }

sample: 1433
buggy_code: <START> public boolean teleportToSpawn() { <END> Location target = server.getWorlds().get(0).getSpawnLocation(); EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null)); if (event.isCancelled()) { return false; } target = event.getTo(); teleport(target); return true; }
code_review: Do this and the other method need to be public? Would `protected` suffice?
target code: protected boolean teleportToSpawn ( ) { Location target = server . getWorlds ( ) . get ( 0 ) . getSpawnLocation ( ) ; EntityPortalEvent event = EventFactory . callEvent ( new EntityPortalEvent ( this , location . clone ( ) , target , null ) ) ; if ( event . isCancelled ( ) ) { return false ; } target = event . getTo ( ) ; teleport ( target ) ; return true ; }
response: <START> protected boolean teleportToSpawn() { <END> Location target = server.getWorlds().get(0).getSpawnLocation(); EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null)); if (event.isCancelled()) { return false; } target = event.getTo(); teleport(target); return true; }

sample: 1434
buggy_code: public String[] getGroupFilters() { <START> String[] result = null; <END> IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class); if (before != null) { result = ((ConfigurationAnnotation) before).getGroupFilters(); } return result; }
code_review: Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ?
target code: public String [ ] getGroupFilters ( ) { IBeforeMethod before = m_annotationFinder . findAnnotation ( getConstructorOrMethod ( ) , IBeforeMethod . class ) ; if ( before == null ) { return new String [ 0 ] ; } return before . getGroupFilters ( ) ; }
response: public String[] getGroupFilters() { <START> String[] result = new String[0]; <END> IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class); if (before != null) { result = ((ConfigurationAnnotation) before).getGroupFilters(); } return result; }

sample: 1435
buggy_code: <START> protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, <END> long defaultValue, long base ) throws IOException { this.pagedFile = pagedFile; this.entrySize = entrySize; this.entriesPerPage = pagedFile.pageSize() / entrySize; this.length = length; this.defaultValue = defaultValue; this.base = base; try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) ) { setLength( cursorToSetLength, length ); } if ( defaultValue != 0 ) { setDefaultValue( defaultValue ); } }
code_review: some of the protected items here can be package private
target code: PageCacheNumberArray ( PagedFile pagedFile , int entrySize , long length , long defaultValue , long base ) throws IOException { this . pagedFile = pagedFile ; this . entrySize = entrySize ; this . entriesPerPage = pagedFile . pageSize ( ) / entrySize ; this . length = length ; this . defaultValue = defaultValue ; this . base = base ; try ( PageCursor cursorToSetLength = pagedFile . io ( 0 , PF_SHARED_WRITE_LOCK ) ) { setLength ( cursorToSetLength , length ) ; } if ( defaultValue != 0 ) { setDefaultValue ( defaultValue ) ; } }
response: <START> protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, <END> long defaultValue, long base ) throws IOException { this.pagedFile = pagedFile; this.entrySize = entrySize; this.entriesPerPage = pagedFile.pageSize() / entrySize; this.length = length; this.defaultValue = defaultValue; this.base = base; try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) ) { setLength( cursorToSetLength, length ); } if ( defaultValue != 0 ) { setDefaultValue( defaultValue ); } }

sample: 1436
buggy_code: public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions) { this.yieldSignal = requireNonNull(yieldSignal, "yieldSignal is null"); this.blocks = requireNonNull(page, "page is null").getBlocks(); this.selectedPositions = requireNonNull(selectedPositions, "selectedPositions is null"); this.nextIndexOrPosition = selectedPositions.getOffset(); if (selectedPositions.isList()) { this.positions = selectedPositions.getPositions(); } else { this.positions = null; <START> } <END> }
code_review: Don't precompute `selectedPositions.getPositions`. It is unnecessary. And it makes the code harder to follow.
target code: public InterpretedPageProjectionOutput ( DriverYieldSignal yieldSignal , Page page , SelectedPositions selectedPositions ) { this . yieldSignal = requireNonNull ( yieldSignal , "yieldSignal is null" ) ; this . blocks = requireNonNull ( page , "page is null" ) . getBlocks ( ) ; this . selectedPositions = requireNonNull ( selectedPositions , "selectedPositions is null" ) ; this . nextIndexOrPosition = selectedPositions . getOffset ( ) ; }
response: public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions) { this.yieldSignal = requireNonNull(yieldSignal, "yieldSignal is null"); this.blocks = requireNonNull(page, "page is null").getBlocks(); this.selectedPositions = requireNonNull(selectedPositions, "selectedPositions is null"); this.nextIndexOrPosition = selectedPositions.getOffset(); if (selectedPositions.isList()) { this.positions = selectedPositions.getPositions(); } else { this.positions = null; <START> } <END> }

sample: 1437
buggy_code: public String getDicomViewerUrl(Study study) { if (study == null) throw new IllegalArgumentException("study cannot be null"); else if (study.getStudyInstanceUid() == null) throw new IllegalArgumentException("studyInstanceUid cannot be null"); <START> return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + "studyUID=" <END> + study.getStudyInstanceUid() : null; }
code_review: this ternary will not behave as stated in the 1. should annotation
target code: public String getDicomViewerUrl ( Study study ) { if ( study == null ) throw new IllegalArgumentException ( "study cannot be null" ) ; else if ( study . getStudyInstanceUid ( ) == null ) throw new IllegalArgumentException ( "studyInstanceUid cannot be null" ) ; return radiologyProperties . getDicomViewerUrl ( ) + "studyUID = " + study . getStudyInstanceUid ( ) ; }
response: public String getDicomViewerUrl(Study study) { if (study == null) throw new IllegalArgumentException("study cannot be null"); else if (study.getStudyInstanceUid() == null) throw new IllegalArgumentException("studyInstanceUid cannot be null"); <START> return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + "studyUID=" + study.getStudyInstanceUid() : null; <END> }

sample: 1438
buggy_code: private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) { <START> Declaration declFromXpath = null; <END> if (!isXPath && pattern.hasXPath()) { Declaration xPathDecl = pattern.getXPathDeclaration(); if (xPathDecl != null) { for ( Declaration decl : constraint.getRequiredDeclarations() ) { if (xPathDecl.equals( decl )) { declFromXpath = decl; break; } } } } return declFromXpath; }
code_review: ..and change as well the variable name `declFromXpath` to `declCorrXpath` also here.
target code: private Declaration getDeclarationCorrespondingToXpath ( Pattern pattern , boolean isXPath , Constraint constraint ) { if ( ! isXPath && pattern . hasXPath ( ) ) { Declaration xPathDecl = pattern . getXPathDeclaration ( ) ; if ( xPathDecl != null ) { for ( Declaration decl : constraint . getRequiredDeclarations ( ) ) { if ( xPathDecl . equals ( decl ) ) { return decl ; } } } } return null ; }
response: private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) { <START> Declaration declCorrXpath = null; <END> if (!isXPath && pattern.hasXPath()) { Declaration xPathDecl = pattern.getXPathDeclaration(); if (xPathDecl != null) { for ( Declaration decl : constraint.getRequiredDeclarations() ) { if (xPathDecl.equals( decl )) { declCorrXpath = decl; break; } } } } return declCorrXpath; }

sample: 1439
buggy_code: public void setQueryTimeout( int seconds ) throws AlreadyClosedSqlException, <START> InvalidParameterSqlException, <END> SQLException { throwIfClosed(); super.setQueryTimeout(seconds); }
code_review: the parent setQueryTimeout will throw a SQLException if the parameter is invalid, so this method now no longer throws an InvalidParameterSqlException
target code: public void setQueryTimeout ( int seconds ) throws AlreadyClosedSqlException , SQLException { throwIfClosed ( ) ; super . setQueryTimeout ( seconds ) ; }
response: public void setQueryTimeout( int seconds ) throws AlreadyClosedSqlException, <START> SQLException <END> { throwIfClosed(); super.setQueryTimeout(seconds); }

sample: 1440
buggy_code: private List<Disk> manualAggregateSnapshots() { List<Disk> <START> Param = <END> new ArrayList<>(); DiskImage diskWithSnaps = diskWithSnapshots; diskWithSnaps.getSnapshots().addAll(snapshotsList); Param.add(diskWithSnapshots); Param.add(diskWithoutSnapshots); Param.add(ovfImage); Param.add(cinderDisk); return Param; }
code_review: Please use Java conventions - param
target code: private List < DiskImage > manualAggregateSnapshots ( ) { DiskImage diskWithSnaps = diskWithSnapshots ; diskWithSnaps . getSnapshots ( ) . addAll ( snapshotsList ) ; return Arrays . asList ( diskWithSnapshots , diskWithoutSnapshots , ovfImage , cinderDisk ) ; }
response: private List<Disk> manualAggregateSnapshots() { List<Disk> <START> param = <END> new ArrayList<>(); DiskImage diskWithSnaps = diskWithSnapshots; diskWithSnaps.getSnapshots().addAll(snapshotsList); param.add(diskWithSnapshots); param.add(diskWithoutSnapshots); param.add(ovfImage); param.add(cinderDisk); return param; }

sample: 1441
buggy_code: public IndexingConfigurationBuilder autoConfig(boolean autoConfig) { <START> enable(); <END> attributes.attribute(AUTO_CONFIG).set(autoConfig); return this; }
code_review: Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true?
target code: public IndexingConfigurationBuilder autoConfig ( boolean autoConfig ) { if ( autoConfig ) enable ( ) ; attributes . attribute ( AUTO_CONFIG ) . set ( autoConfig ) ; return this ; }
response: public IndexingConfigurationBuilder autoConfig(boolean autoConfig) { <START> if (autoConfig) enable(); <END> attributes.attribute(AUTO_CONFIG).set(autoConfig); return this; }

sample: 1442
buggy_code: private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) { return <START> CollectionUtils .isNotEmpty(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, <END> VmDeviceGeneralType.HOSTDEV, vfName)); }
code_review: dao will return either an empty list or populated one, but never null.
target code: private boolean shouldBeDirectlyAttached ( String vfName , Guid vmId ) { return ! vmDeviceDao . getVmDeviceByVmIdTypeAndDevice ( vmId , VmDeviceGeneralType . HOSTDEV , vfName ) . isEmpty ( ) ; }
response: private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) { return <START> !vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, <END> VmDeviceGeneralType.HOSTDEV, vfName).isEmpty(); }

sample: 1443
buggy_code: <START> private void safeCloseStream(Closeable stream) { <END> if (stream != null) { try { stream.close(); } catch (IOException e) { // swallow error in this case Logger.e(TAG, "Failed to close the stream: ", "", ADALError.IO_EXCEPTION, e); } } }
code_review: static
target code: private static void safeCloseStream ( Closeable stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { // swallow error in this case Logger . e ( TAG , "Failed to close the stream : " , "" , ADALError . IO_EXCEPTION , e ) ; } } }
response: <START> private static void safeCloseStream(Closeable stream) { <END> if (stream != null) { try { stream.close(); } catch (IOException e) { // swallow error in this case Logger.e(TAG, "Failed to close the stream: ", "", ADALError.IO_EXCEPTION, e); } } }

sample: 1444
buggy_code: public static String zkSecuritySysConfigString() { String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM); String clientEnabled = System.getProperty(ZK_SASL_CLIENT); <START> String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY); <END> return "[" + JAVA_LOGIN_CONFIG_PARAM + "=" + loginConfig + ", " + ZK_SASL_CLIENT + "=" + (clientEnabled == null ? "default:" + DEFAULT_ZK_SASL_CLIENT : clientEnabled) + ", " + ZK_LOGIN_CONTEXT_NAME_KEY + "=" + (contextName == null ? "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME : contextName) + "]"; }
code_review: How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
target code: public static String zkSecuritySysConfigString ( ) { String loginConfig = System . getProperty ( JAVA_LOGIN_CONFIG_PARAM ) ; String clientEnabled = System . getProperty ( ZK_SASL_CLIENT , "default : " + DEFAULT_ZK_SASL_CLIENT ) ; String contextName = System . getProperty ( ZK_LOGIN_CONTEXT_NAME_KEY , "default : " + DEFAULT_ZK_LOGIN_CONTEXT_NAME ) ; return " [ " + JAVA_LOGIN_CONFIG_PARAM + " = " + loginConfig + " , " + ZK_SASL_CLIENT + " = " + clientEnabled + " , " + ZK_LOGIN_CONTEXT_NAME_KEY + " = " + contextName + " ] " ; }
response: public static String zkSecuritySysConfigString() { String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM); String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); <START> String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); <END> return "[" + JAVA_LOGIN_CONFIG_PARAM + "=" + loginConfig + ", " + ZK_SASL_CLIENT + "=" + clientEnabled + ", " + ZK_LOGIN_CONTEXT_NAME_KEY + "=" + contextName + "]"; }

sample: 1445
buggy_code: <START> public void updateNode(final @Nonnull Node node) throws IOException { <END> if (node == nodes.get(node.getNodeName())) { Queue.withLock(new Runnable() { @Override public void run() { jenkins.trimLabels(); } }); persistNode(node); } }
code_review: I would recommend returning a boolean, `true` for a successful update and `false` for the "no-op" case
target code: public boolean updateNode ( final @Nonnull Node node ) throws IOException { if ( node == nodes . get ( node . getNodeName ( ) ) ) { Queue . withLock ( new Runnable ( ) { @Override public void run ( ) { jenkins . trimLabels ( ) ; } } ) ; persistNode ( node ) ; return true ; } return false ; }
response: <START> public boolean updateNode(final @Nonnull Node node) throws IOException { <END> if (node == nodes.get(node.getNodeName())) { Queue.withLock(new Runnable() { @Override public void run() { jenkins.trimLabels(); } }); persistNode(node); return true; } return false; }

sample: 1446
buggy_code: public void onSaveInstanceState(Bundle outState) { <START> if (backStack != null) { <END> // update the topmost entry in the backstack updateCurrentBackStackItem(); outState.putParcelableArrayList("backStack", backStack); } }
code_review: The rest of this class expects backStack to be nonnull. I recommend we initialize backStack to an empty mutable list and specify @NonNull in the setter.
target code: public void onSaveInstanceState ( Bundle outState ) { // update the topmost entry in the back stack updateCurrentBackStackItem ( ) ; outState . putParcelableArrayList ( "backStack" , backStack ) ; }
response: public void onSaveInstanceState(Bundle outState) { <START> // update the topmost entry in the backstack updateCurrentBackStackItem(); outState.putParcelableArrayList("backStack", backStack); <END> }

sample: 1447
buggy_code: public Trader(String name, double cashInHand) { <START> super(); <END> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }
code_review: Is this necessary?
target code: public Trader ( String name , double cashInHand ) { // super ( ) ; this . name = name ; this . cashInHand = cashInHand ; this . position = new ArrayList < Order > ( ) ; this . ordersPlaced = new ArrayList < Order > ( ) ; }
response: public Trader(String name, double cashInHand) { <START> super(); <END> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }

sample: 1448
buggy_code: <START> private Iterable<ITask> getTasksAssosciatedWithReviewTask(ITask reviewTask) { <END> String lookupUrl = reviewTask.getUrl(); // TODO: Fetch from mapping with the lookupUrl String taskUrl = "http://someurl"; AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager() .getConnectorForRepositoryTaskUrl(taskUrl); String taskId = repository.getTaskIdFromTaskUrl(taskUrl); String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl); ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId); if (assosciatedTask == null) { return Collections.emptyList(); } return ImmutableSet.of(assosciatedTask); }
code_review: There can only be one associated task.
target code: private ITask getTasksAssosciatedWithReviewTask ( ITask reviewTask ) { String lookupUrl = reviewTask . getUrl ( ) ; // TODO : Fetch from mapping with the lookupUrl String taskUrl = "http :/ / someurl" ; AbstractRepositoryConnector repository = TasksUiPlugin . getRepositoryManager ( ) . getConnectorForRepositoryTaskUrl ( taskUrl ) ; String taskId = repository . getTaskIdFromTaskUrl ( taskUrl ) ; String repositoryUrl = repository . getRepositoryUrlFromTaskUrl ( taskUrl ) ; ITask assosciatedTask = taskList . getTask ( repositoryUrl , taskId ) ; return assosciatedTask ; }
response: <START> private ITask getTasksAssosciatedWithReviewTask(ITask reviewTask) { <END> String lookupUrl = reviewTask.getUrl(); // TODO: Fetch from mapping with the lookupUrl String taskUrl = "http://someurl"; AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager() .getConnectorForRepositoryTaskUrl(taskUrl); String taskId = repository.getTaskIdFromTaskUrl(taskUrl); String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl); ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId); return assosciatedTask; }

sample: 1449
buggy_code: <START> protected void toLegacyText(StringBuilder builder) <END> { builder.append(this.value); }
code_review: Override
target code: protected void toLegacyText ( StringBuilder builder ) { builder . append ( this . value ) ; super . toLegacyText ( builder ) ; }
response: <START> protected void toLegacyText(StringBuilder builder) <END> { builder.append(this.value); }

sample: 1450
buggy_code: <START> public static boolean isRoute(URL url) { <END> return ROUTE_PROTOCOL.equals(url.getProtocol()) || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY)); }
code_review: `public static boolean isRoute(final URL url)`
target code: public static boolean isRoute ( URL url ) { return ROUTE_PROTOCOL . equals ( url . getProtocol ( ) ) || ROUTERS_CATEGORY . equals ( url . getParameter ( CATEGORY_KEY , DEFAULT_CATEGORY ) ) ; }
response: <START> public static boolean isRoute(final URL url) { <END> return ROUTE_PROTOCOL.equals(url.getProtocol()) || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY)); }

sample: 1451
buggy_code: void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); // Busy loop. int[] vs2; <START> synchronized (lock) { <END> vs2 = values; } int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); }
code_review: I would delete this synchronized block. Values cannot be modified while we're reading it since we already saw state as 2. It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that.
target code: void thread2 ( ) { int [ ] vs1 ; synchronized ( lock ) { vs1 = values ; state = 1 ; } int s ; do { synchronized ( lock ) { s = state ; } } while ( s != 2 ) ; // Busy loop . int [ ] vs2 = values ; int v1 = vs1 [ 0 ] ; int v2 = vs2 [ 0 ] ; System . out . println ( "b17689750TestMonitor failed : " + v1 + " , " + v2 ) ; }
response: void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); // Busy loop. int[] vs2; <START> synchronized (lock) { <END> vs2 = values; } int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); }

sample: 1452
buggy_code: public void testWriteAndReadObject() throws Exception { <START> InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); <END> String expected = "test input"; String actual = (String) writeAndReadObject(serializationService, expected); assertNotNull(actual); assertEquals(expected, actual); }
code_review: Isn't it easier to have the serializationService as a field on this test? Are there any serializationServices created with different settings? Having it as field instead of local variable, will simplify the test methods.
target code: public void testWriteAndReadObject ( ) throws Exception { String expected = "test input" ; String actual = ( String ) writeAndReadObject ( expected ) ; assertNotNull ( actual ) ; assertEquals ( expected , actual ) ; }
response: public void testWriteAndReadObject() throws Exception { <START> InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); <END> String expected = "test input"; String actual = (String) writeAndReadObject(serializationService, expected); assertNotNull(actual); assertEquals(expected, actual); }

sample: 1453
buggy_code: public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } final ArArchiveEntry other = (ArArchiveEntry) obj; if (name == null) { return other.name == null; <START> } else return name.equals(other.name); <END> }
code_review: please add braces for the else block.
target code: public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } final ArArchiveEntry other = ( ArArchiveEntry ) obj ; if ( name == null ) { return other . name == null ; } else { return name . equals ( other . name ) ; } }
response: public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } final ArArchiveEntry other = (ArArchiveEntry) obj; if (name == null) { return other.name == null; <START> } else { return name.equals(other.name); <END> } }

sample: 1454
buggy_code: public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) { if (bufferList == null || bufferList.isEmpty()) { throw new IllegalArgumentException("Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"); } <START> buffers = new ArrayList<>(bufferList); <END> size = computeSize(bufferList); }
code_review: why do you need to wrap it in a new `ArrayList`? Seems wasteful.
target code: public ByteBufferReadableStreamChannel ( List < ByteBuffer > bufferList ) { if ( bufferList == null || bufferList . isEmpty ( ) ) { throw new IllegalArgumentException ( "Input List of ByteBuffer cannot be null / empty for ByteBufferReadableStreamChannel" ) ; } buffers = bufferList ; size = computeSize ( bufferList ) ; }
response: public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) { if (bufferList == null || bufferList.isEmpty()) { throw new IllegalArgumentException("Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"); } <START> buffers = bufferList; <END> size = computeSize(bufferList); }

sample: 1455
buggy_code: boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces, final List<VdsNetworkInterface> allInterfacesForVds) { for (final VmNetworkInterface vmIf : vmNetworkInterfaces) { boolean found = false; for (final VdsNetworkInterface vdsIf : allInterfacesForVds) { if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) { found = true; break; } } if (!found) { <START> log.debug("VDS is not ok for running the VM as network is missing"); <END> return false; } } return true; }
code_review: I don't know if it's necessary to log this message for each host, since for other unmet conditions we don't log anything. If it looks necessary to you then at least VDS ID would be helpful to know (assuming VM ID is already printed elsewehere).
target code: boolean areRequiredNetworksAvailable ( final List < VmNetworkInterface > vmNetworkInterfaces , final List < VdsNetworkInterface > allInterfacesForVds ) { for ( final VmNetworkInterface vmIf : vmNetworkInterfaces ) { boolean found = false ; for ( final VdsNetworkInterface vdsIf : allInterfacesForVds ) { if ( StringUtils . equals ( vmIf . getNetworkName ( ) , vdsIf . getNetworkName ( ) ) ) { found = true ; break ; } } if ( ! found ) { return false ; } } return true ; }
response: boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces, final List<VdsNetworkInterface> allInterfacesForVds) { for (final VmNetworkInterface vmIf : vmNetworkInterfaces) { boolean found = false; for (final VdsNetworkInterface vdsIf : allInterfacesForVds) { if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) { found = true; break; } } if (!found) { <START> log.debug("VDS is not ok for running the VM as network is missing"); <END> return false; } } return true; }

sample: 1456
buggy_code: public void testStash() { try { // 1) call stash create command git.stashCreate().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); // 2) call stash list git.stashList().call(); // 3) apply stash git.stashApply().call(); // 4) verify stash applied by outputting file readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); <START> } catch (Exception e) { <END> e.printStackTrace(); } }
code_review: Never catch exceptions in test code unless you actually want to do something use. Just declare that this method throws Exception
target code: public void testStash ( ) throws Exception { // 1 ) call stash create command git . stashCreate ( ) . call ( ) ; readFile ( "Stash Created" , git . getRepository ( ) . getWorkTree ( ) + " / File1 . txt" ) ; // 2 ) call stash list git . stashList ( ) . call ( ) ; // 3 ) apply stash git . stashApply ( ) . call ( ) ; // 4 ) verify stash applied by outputting file readFile ( "Stash Created" , git . getRepository ( ) . getWorkTree ( ) + " / File1 . txt" ) ; }
response: public void testStash() throws Exception { // 1) call stash create command git.stashCreate().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); // 2) call stash list git.stashList().call(); // 3) apply stash git.stashApply().call(); // 4) verify stash applied by outputting file readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); <START> }

sample: 1457
buggy_code: public List<WorkerInfo> getWorkerInfoList() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } try { return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY); } catch (ExecutionException e) { <START> throw new UnavailableException("Unable to get worker info list from cache"); <END> } }
code_review: Can we include the information from `e` in this exception message?
target code: public List < WorkerInfo > getWorkerInfoList ( ) throws UnavailableException { if ( mSafeModeManager . isInSafeMode ( ) ) { throw new UnavailableException ( ExceptionMessage . MASTER_IN_SAFEMODE . getMessage ( ) ) ; } try { return mWorkerInfoCache . get ( WORKER_INFO_CACHE_KEY ) ; } catch ( ExecutionException e ) { throw new UnavailableException ( "Unable to get worker info list from cache" , e ) ; } }
response: public List<WorkerInfo> getWorkerInfoList() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } try { return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY); } catch (ExecutionException e) { <START> throw new UnavailableException("Unable to get worker info list from cache", e); <END> } }

sample: 1458
buggy_code: public static void tearDownTestCase() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } }
code_review: Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
target code: public static void tearDownTestCase ( ) throws Exception { }
response: public static void tearDownTestCase() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } } public void tearDown() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } }

sample: 1459
buggy_code: public void checkSelectFilter(final String label, final String value) { selectInputs.computeIfPresent(label, (key, values) -> { values.forEach(i -> { <START> if ((i.getValue().equals(value) || i.getValue() == value) && i.getChecked() == false) { <END> i.setChecked(true); } }); return values; }); }
code_review: Why do we have equality check here? it should have been done by the equals.
target code: public void checkSelectFilter ( final String label , final String value ) { selectInputs . computeIfPresent ( label , ( key , values ) - > { values . forEach ( i - > { if ( i . getValue ( ) . equals ( value ) && i . getChecked ( ) == false ) { i . setChecked ( true ) ; } } ) ; return values ; } ) ; }
response: public void checkSelectFilter(final String label, final String value) { selectInputs.computeIfPresent(label, (key, values) -> { values.forEach(i -> { <START> if (i.getValue().equals(value) && i.getChecked() == false) { <END> i.setChecked(true); } }); return values; }); }

sample: 1460
buggy_code: public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) { <START> super(); <END> this.storageJobId = storageJobId; this.subchainInfo = subchainInfo; }
code_review: needed?
target code: public ColdMergeVDSCommandParameters ( Guid storageJobId , SubchainInfo subchainInfo ) { this . storageJobId = storageJobId ; this . subchainInfo = subchainInfo ; }
response: public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) { <START> super(); <END> this.storageJobId = storageJobId; this.subchainInfo = subchainInfo; }

sample: 1461
buggy_code: private void putResize (K key, V value) { K[] keyTable = this.keyTable; V[] valueTable = this.valueTable; for (int i = place(key); ; i = (i + 1) & mask) { // space is available so we insert and break (resize is later) if (keyTable[i] == null) { keyTable[i] = key; valueTable[i] = value; break; } } <START> if (++size >= threshold) { <END> resize(keyTable.length << 1); } }
code_review: I think we don't need to check this, as we know that the resize will not result in the threshold being exceeded.
target code: private void putResize ( K key , V value ) { K [ ] keyTable = this . keyTable ; V [ ] valueTable = this . valueTable ; for ( int i = place ( key ) ; ; i = ( i + 1 ) & mask ) { // space is available so we insert and break if ( keyTable [ i ] == null ) { keyTable [ i ] = key ; valueTable [ i ] = value ; break ; } } ++ size ; }
response: private void putResize (K key, V value) { K[] keyTable = this.keyTable; V[] valueTable = this.valueTable; for (int i = place(key); ; i = (i + 1) & mask) { // space is available so we insert and break (resize is later) if (keyTable[i] == null) { keyTable[i] = key; valueTable[i] = value; break; } } <START> resize(keyTable.length << 1); <END> }

sample: 1462
buggy_code: protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() { public void onSuccess(final ProjectDetail result) { enableForm(true); display(result); <START> addPanel.setVisible(result.canModifyData); <END> delRight.setVisible(result.canModifyData); } }); }
code_review: This isn't canModifyData. I think you've overloaded the variable for too many meanings. What we need is: * canModifyDescription * canModifyMergeType * canModifyAgreements * canModifyAccess The first 3 are true only if projectControl.isOwner() is true. The last one is true if projectControl.isOwnerAnyRef() is true, and is what you want to be using here for addPanel.
target code: protected void onLoad ( ) { enableForm ( false ) ; super . onLoad ( ) ; Util . PROJECT_SVC . projectDetail ( projectName , new GerritCallback < ProjectDetail > ( ) { public void onSuccess ( final ProjectDetail result ) { enableForm ( true ) ; display ( result ) ; } } ) ; }
response: protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() { public void onSuccess(final ProjectDetail result) { enableForm(true); display(result); <START> addPanel.setVisible(result.canModifyData); <END> delRight.setVisible(result.canModifyData); } }); }

sample: 1463
buggy_code: public static EncodeFormat checkedValueOf(String name) { try { <START> return Enum.valueOf(EncodeFormat.class, name); <END> } catch (Exception ex) { VoltDB.crashLocalVoltDB("Illegal encoding format " + name, true, ex); } return null; }
code_review: Why not use `EncodeFormat.valueOf`
target code: public static EncodeFormat checkedValueOf ( String name ) { try { return valueOf ( EncodeFormat . class , name ) ; } catch ( Exception ex ) { VoltDB . crashLocalVoltDB ( "Illegal encoding format " + name , true , ex ) ; } return null ; }
response: public static EncodeFormat checkedValueOf(String name) { try { <START> return EncodeFormat.valueOf(name); <END> } catch (Exception ex) { VoltDB.crashLocalVoltDB("Illegal encoding format " + name, true, ex); } return null; }

sample: 1464
buggy_code: public Set<K> keySet(Predicate predicate) { checkNotNull(predicate, "Predicate cannot be null!"); Set<K> resultingSet = new HashSet<K>(); Set<QueryableEntry> query = indexes.query(predicate); if (query != null) { for (QueryableEntry entry : query) { <START> K key = (K) serializationService.toObject(entry.getKeyData()); <END> resultingSet.add(key); } } else { doFullKeyScan(predicate, resultingSet); } return resultingSet; }
code_review: Minor: there is a shortcut `toObject()` method for doing the deserialization in this class and in `DefaultQueryCache`. Maybe that should be used to be consistent at all places.
target code: public Set < K > keySet ( Predicate predicate ) { checkNotNull ( predicate , "Predicate cannot be null ! " ) ; Set < K > resultingSet = new HashSet < K > ( ) ; Set < QueryableEntry > query = indexes . query ( predicate ) ; if ( query != null ) { for ( QueryableEntry entry : query ) { K key = toObject ( entry . getKeyData ( ) ) ; resultingSet . add ( key ) ; } } else { doFullKeyScan ( predicate , resultingSet ) ; } return resultingSet ; }
response: public Set<K> keySet(Predicate predicate) { checkNotNull(predicate, "Predicate cannot be null!"); Set<K> resultingSet = new HashSet<K>(); Set<QueryableEntry> query = indexes.query(predicate); if (query != null) { for (QueryableEntry entry : query) { <START> K key = (K) entry.getKey(); <END> resultingSet.add(key); } } else { doFullKeyScan(predicate, resultingSet); } return resultingSet; }

sample: 1465
buggy_code: public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter(); oo.setMyLocations(new HashSet<>()); <START> Assertions.assertThrows(APIException.class,() ->RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField("locations"))); <END> }
code_review: also a tiny thing, but sometimes you miss a whitespace after the `->`
target code: public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound ( ) throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter ( ) ; oo . setMyLocations ( new HashSet < > ( ) ) ; RequiredDataAdvice . getChildCollection ( oo , ClassWithBadGetter . class . getDeclaredField ( "locations" ) ) ; }
response: public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter(); oo.setMyLocations(new HashSet<>()); <START> Assertions.assertThrows(APIException.class,() -> RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField("locations"))); <END> }

sample: 1466
buggy_code: protected void configure() { <START> DynamicSet.setOf(binder(), CacheRemovalListener.class); <END> install(new FactoryModule() { @Override protected void configure() { factory(ForwardingRemovalListener.Factory.class); } }); bind(DefaultCacheFactory.class); bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class); bind(PersistentCacheFactory.class).to(H2CacheFactory.class); listener().to(H2CacheFactory.class); }
code_review: This should be declared in GerritGlobalModule.
target code: protected void configure ( ) { install ( new FactoryModule ( ) { @Override protected void configure ( ) { factory ( ForwardingRemovalListener . Factory . class ) ; } } ) ; bind ( DefaultCacheFactory . class ) ; bind ( MemoryCacheFactory . class ) . to ( DefaultCacheFactory . class ) ; bind ( PersistentCacheFactory . class ) . to ( H2CacheFactory . class ) ; listener ( ) . to ( H2CacheFactory . class ) ; }
response: protected void configure() { DynamicSet.setOf(binder(), CacheRemovalListener.class); install(new FactoryModule() { @Override protected void configure() { factory(ForwardingRemovalListener.Factory.class); } }); bind(DefaultCacheFactory.class); bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class); bind(PersistentCacheFactory.class).to(H2CacheFactory.class); listener().to(H2CacheFactory.class); }

sample: 1467
buggy_code: private void createDisabledImage() { <START> if (this.disabledImage != null && !this.disabledImage.isDisposed()) <END> disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); }
code_review: This doesn't seem right: we're building `disabledImage` from `image`, so we need to check that `image` has not been disabled. I think something like the following? if (this.image != null && !this.image.isDisposed()) { if (this.disabledImage != null && !this.disabledImage.isDisposed()) { this.disabledImage.dispose(); } disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); }
target code: private void createDisabledImage ( ) { // Only create a new disabledImage when the disabledImage == null or // disposed to avoid a GDI Handler leak See Bug 486531 if ( this . disabledImage == null || this . disabledImage . isDisposed ( ) ) if ( this . image != null && ! this . image . isDisposed ( ) ) disabledImage = new Image ( this . image . getDevice ( ) , this . image , SWT . IMAGE_DISABLE ) ; }
response: private void createDisabledImage() { if (this.image != null && !this.image.isDisposed()) { if (this.disabledImage != null && !this.disabledImage.isDisposed()) { this.disabledImage.dispose(); } disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); } }

sample: 1468
buggy_code: public synchronized void releaseSample(DecoderInputBuffer sample) { <START> sample.data.clear(); <END> mSamplePool.offerLast(sample); }
code_review: Should probably be sample.clear().
target code: public synchronized void releaseSample ( DecoderInputBuffer sample ) { sample . clear ( ) ; mSamplePool . offerLast ( sample ) ; }
response: public synchronized void releaseSample(DecoderInputBuffer sample) { <START> sample.clear(); <END> mSamplePool.offerLast(sample); }

sample: 1469
buggy_code: private String buildClipboardMessage(Row row) { <START> StringBuilder builder = new StringBuilder(); <END> builder.append(row.getLevel()) .append(", ") .append(row.getMessage()); return builder.toString(); }
code_review: Looks like this builder just concatenate 3 strings without any loops. I guess, it is unnecessary here.
target code: private String buildClipboardMessage ( Row row ) { return row . getLevel ( ) + " , " + row . getMessage ( ) ; }
response: private String buildClipboardMessage(Row row) { <START> StringBuilder builder = new StringBuilder(); <END> builder.append(row.getLevel()) .append(", ") .append(row.getMessage()); return builder.toString(); }

sample: 1470
buggy_code: <START> public RepositoryObject getParent() { <END> return driver.getParentObject(this); }
code_review: Since a Tombstone is no longer in the hierarchy (result of removing the proxy), this method should probably either return a null or throw an exception
target code: public RepositoryObject getParent ( ) { // tombstone is not in the hierarchy , so doesn't have a parent return null ; }
response: <START> public RepositoryObject getParent() { <END> return null; }

sample: 1471
buggy_code: private void setLastUsedBranch() { String lastBranch = settings.get(lastBranchKey); <START> if (lastBranch != null) { <END> branchText.setText(lastBranch); } }
code_review: no braces here, more occurrences in this file
target code: private void setLastUsedBranch ( ) { String lastBranch = settings . get ( lastBranchKey ) ; if ( lastBranch != null ) branchText . setText ( lastBranch ) ; }
response: private void setLastUsedBranch() { String lastBranch = settings.get(lastBranchKey); <START> if (lastBranch != null) <END> branchText.setText(lastBranch); }

sample: 1472
buggy_code: public String toString() { return toStringHelper(this) .omitNullValues() <START> .add("equiCriteria", this.equiCriteria) <END> .add("filter", filter.orElse(null)) .toString(); }
code_review: `this` is not needed?
target code: public String toString ( ) { return toStringHelper ( this ) . omitNullValues ( ) . add ( "equiCriteria" , equiCriteria ) . add ( "filter" , filter . orElse ( null ) ) . toString ( ) ; }
response: public String toString() { return toStringHelper(this) .omitNullValues() <START> .add("equiCriteria", equiCriteria) <END> .add("filter", filter.orElse(null)) .toString(); }

sample: 1473
buggy_code: private void validateKeyPatternsInConfig(Dictionary<String, ?> config) { Enumeration<String> keys = config.keys(); while (keys.hasMoreElements()) { String key = keys.nextElement(); // the config-key enumeration contains additional keys that we // don't want to process here ... if ("service.pid".equals(key)) { continue; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key); if (!matcher.matches()) { logger.error("Given plugwise-config-key '" + key <START> + "' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"); <END> continue; } } }
code_review: Seems more appropriately `logger.warn`.
target code: private void validateKeyPatternsInConfig ( Dictionary < String , ? > config ) { Enumeration < String > keys = config . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = keys . nextElement ( ) ; // the config - key enumeration contains additional keys that we // don't want to process here . . . if ( "service . pid" . equals ( key ) ) { continue ; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN . matcher ( key ) ; if ( ! matcher . matches ( ) ) { logger . warn ( "Given plugwise - config - key '" + key + "' does not follow the expected pattern ' < PlugwiseId > . < mac|type|port|interval > '" ) ; continue ; } } }
response: private void validateKeyPatternsInConfig(Dictionary<String, ?> config) { Enumeration<String> keys = config.keys(); while (keys.hasMoreElements()) { String key = keys.nextElement(); // the config-key enumeration contains additional keys that we // don't want to process here ... if ("service.pid".equals(key)) { continue; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key); if (!matcher.matches()) { logger.warn("Given plugwise-config-key '" + key <START> + "' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"); <END> continue; } } }

sample: 1474
buggy_code: public Void visitFilter(FilterNode node, Void context) { <START> String expression = isExpression(node.getPredicate()) ? node.getPredicate().toString() : formatter.formatRowExpression(node.getPredicate()); <END> printNode(node, "Filter", expression, NODE_COLORS.get(NodeType.FILTER)); return node.getSource().accept(this, context); }
code_review: `GraphvizPrinter` (and all other plan printer) should not expect an `Expression`. Rather than having `isExpression` here, let's fix the tests if they are failing.
target code: public Void visitFilter ( FilterNode node , Void context ) { String expression = formatter . formatRowExpression ( node . getPredicate ( ) ) ; printNode ( node , "Filter" , expression , NODE_COLORS . get ( NodeType . FILTER ) ) ; return node . getSource ( ) . accept ( this , context ) ; }
response: public Void visitFilter(FilterNode node, Void context) { <START> String expression = formatter.formatRowExpression(node.getPredicate()); <END> printNode(node, "Filter", expression, NODE_COLORS.get(NodeType.FILTER)); return node.getSource().accept(this, context); }

sample: 1475
buggy_code: public void run() { resetGlobalProgress(); indexingAll = true; for (ObjectType objectType : ObjectType.values()) { startIndexing(objectType); } try { sleep(pause); } catch (InterruptedException e) { <START> Thread.currentThread().interrupt(); <END> logger.error("Thread interrupted: " + e.getMessage()); } currentIndexState = ObjectType.NONE; indexingAll = false; pollingChannel.send(INDEXING_FINISHED_MESSAGE); }
code_review: Move this line after logging the error, so in any case the error get logged.
target code: public void run ( ) { resetGlobalProgress ( ) ; indexingAll = true ; for ( ObjectType objectType : ObjectType . values ( ) ) { startIndexing ( objectType ) ; } try { sleep ( pause ) ; } catch ( InterruptedException e ) { logger . error ( "Thread interrupted : " + e . getMessage ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; } currentIndexState = ObjectType . NONE ; indexingAll = false ; pollingChannel . send ( INDEXING_FINISHED_MESSAGE ) ; }
response: public void run() { resetGlobalProgress(); indexingAll = true; for (ObjectType objectType : ObjectType.values()) { startIndexing(objectType); } try { sleep(pause); } catch (InterruptedException e) { <START> logger.error("Thread interrupted: " + e.getMessage()); Thread.currentThread().interrupt(); <END> } currentIndexState = ObjectType.NONE; indexingAll = false; pollingChannel.send(INDEXING_FINISHED_MESSAGE); }

sample: 1476
buggy_code: public boolean isAC3() { <START> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".equals(getCodecA()) || "liba52".equals(getCodecA())); <END> }
code_review: `return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));`
target code: public boolean isAC3 ( ) { return getCodecA ( ) != null && ( "ac3" . equals ( getCodecA ( ) ) || getCodecA ( ) . contains ( "a52" ) ) ; }
response: public boolean isAC3() { <START> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA())); <END> }

sample: 1477
buggy_code: ShardRewriter createShardRewriter( FileSystemContext fileSystemContext, FileSystem fileSystem, long transactionId, OptionalInt bucketNumber, UUID shardUuid, int shardRowCount, Optional<UUID> deltaShardUuid, boolean tableSupportsDeltaDelete, Map<String, Type> columns) { if (tableSupportsDeltaDelete) { return new DeltaShardRewriter( shardUuid, shardRowCount, deltaShardUuid, deletionExecutor, transactionId, bucketNumber, this, fileSystemContext, fileSystem); } <START> else { <END> return new InplaceShardRewriter( shardUuid, columns, deletionExecutor, transactionId, bucketNumber, nodeId, this, fileSystem, storageService, shardRecorder, backupManager); } }
code_review: redundant
target code: ShardRewriter createShardRewriter ( FileSystemContext fileSystemContext , FileSystem fileSystem , long transactionId , OptionalInt bucketNumber , UUID shardUuid , int shardRowCount , Optional < UUID > deltaShardUuid , boolean tableSupportsDeltaDelete , Map < String , Type > columns ) { if ( tableSupportsDeltaDelete ) { return new DeltaShardRewriter ( shardUuid , shardRowCount , deltaShardUuid , deletionExecutor , transactionId , bucketNumber , this , fileSystemContext , fileSystem ) ; } return new InplaceShardRewriter ( shardUuid , columns , deletionExecutor , transactionId , bucketNumber , nodeId , this , fileSystem , storageService , shardRecorder , backupManager ) ; }
response: ShardRewriter createShardRewriter( FileSystemContext fileSystemContext, FileSystem fileSystem, long transactionId, OptionalInt bucketNumber, UUID shardUuid, int shardRowCount, Optional<UUID> deltaShardUuid, boolean tableSupportsDeltaDelete, Map<String, Type> columns) { if (tableSupportsDeltaDelete) { return new DeltaShardRewriter( shardUuid, shardRowCount, deltaShardUuid, deletionExecutor, transactionId, bucketNumber, this, fileSystemContext, fileSystem); } <START> else { <END> return new InplaceShardRewriter( shardUuid, columns, deletionExecutor, transactionId, bucketNumber, nodeId, this, fileSystem, storageService, shardRecorder, backupManager); } }

sample: 1478
buggy_code: public void init() { setLabel("Plugin"); addAttribute(ID, ROLE_ID).setLabel("Identifier"); addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel("Label"); <START> addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel("Description").setDataType(HTML); <END> }
code_review: TEXT datatype would be more appropriate.
target code: public void init ( ) { setLabel ( "Plugin" ) ; addAttribute ( ID , ROLE_ID ) . setLabel ( "Identifier" ) ; addAttribute ( LABEL , ROLE_LABEL , ROLE_LOOKUP ) . setNillable ( false ) . setUnique ( true ) . setLabel ( "Label" ) ; addAttribute ( DESCRIPTION , ROLE_LOOKUP ) . setLabel ( "Description" ) ; }
response: public void init() { setLabel("Plugin"); addAttribute(ID, ROLE_ID).setLabel("Identifier"); addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel("Label"); <START> addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel("Description").setDataType(TEXT); <END> }

sample: 1479
buggy_code: <START> @Override public Long call() throws IOException{ <END> String oldname = Thread.currentThread().getName(); Thread.currentThread().setName(oldname+"Decode-"+this.parent.columnChunkMetaData.toString()); this.parent.processPages(recordsToReadInThisPass); Thread.currentThread().setName(oldname); return recordsToReadInThisPass; }
code_review: Space between IOException and {
target code: @Override public Long call ( ) throws IOException { String oldname = Thread . currentThread ( ) . getName ( ) ; try { Thread . currentThread ( ) . setName ( oldname + "Decode - " + this . parent . columnChunkMetaData . toString ( ) ) ; this . parent . processPages ( recordsToReadInThisPass ) ; return recordsToReadInThisPass ; } finally { Thread . currentThread ( ) . setName ( oldname ) ; } }
response: <START> @Override public Long call() throws IOException { <END> String oldname = Thread.currentThread().getName(); Thread.currentThread().setName(oldname+"Decode-"+this.parent.columnChunkMetaData.toString()); this.parent.processPages(recordsToReadInThisPass); Thread.currentThread().setName(oldname); return recordsToReadInThisPass; }

sample: 1480
buggy_code: public CompositeMetricsCollector(MetricsCollector... collectors) { <START> this.collectors = new ArrayList<>(asList(collectors)); <END> }
code_review: Does additional list creation (`new ArrayList<>()`) provide any benefits when compared with the following? ```java this.collectors = asList(collectors); ```
target code: public CompositeMetricsCollector ( MetricsCollector . . . collectors ) { this . collectors = asList ( collectors ) ; }
response: public CompositeMetricsCollector(MetricsCollector... collectors) { <START> this.collectors = asList(collectors); <END> }

sample: 1481
buggy_code: @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { loadContacts(); } else { <START> Toast.makeText(getApplicationContext(), "Read contacts permission denied", <END> Toast.LENGTH_LONG).show(); finish(); } } else { super.onRequestPermissionsResult(requestCode, permissions, grantResults); } }
code_review: to nitpick: just use `this` instead of the application.
target code: @Override public void onRequestPermissionsResult ( int requestCode , @NonNull String [ ] permissions , @NonNull int [ ] grantResults ) { if ( requestCode == REQUEST_READ_CONTACTS ) { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { loadContacts ( ) ; } else { Toast . makeText ( this , "Read contacts permission denied" , Toast . LENGTH_LONG ) . show ( ) ; finish ( ) ; } } else { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; } }
response: @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { loadContacts(); } else { <START> Toast.makeText(this, "Read contacts permission denied", <END> Toast.LENGTH_LONG).show(); finish(); } } else { super.onRequestPermissionsResult(requestCode, permissions, grantResults); } }

sample: 1482
buggy_code: private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) { StringBuilder fg= new StringBuilder(); appendColor(fg, fgRGB); StringBuilder bg= new StringBuilder(); appendColor(bg, bgRGB); <START> buffer.append("body {color:" + fg.toString() + "; background-color:" + bg.toString() + ";}"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ <END> }
code_review: I must be missing something. Why not simply buffer.append("body {color:"); appendColor(buffer, fgRGB); buffer.append("; background-color:"); appendColor(buffer, bgRGB); buffer.append(";}"); ?
target code: private static void appendBodyColorsRule ( StringBuilder buffer , RGB fgRGB , RGB bgRGB ) { StringBuilder fg = new StringBuilder ( ) ; appendColor ( fg , fgRGB ) ; StringBuilder bg = new StringBuilder ( ) ; appendColor ( bg , bgRGB ) ; buffer . append ( "body { color : " ) ; // $NON - NLS - 1$ appendColor ( buffer , fgRGB ) ; buffer . append ( " ; background - color : " ) ; // $NON - NLS - 1$ appendColor ( buffer , bgRGB ) ; buffer . append ( " ; } " ) ; // $NON - NLS - 1$ }
response: private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) { StringBuilder fg= new StringBuilder(); appendColor(fg, fgRGB); StringBuilder bg= new StringBuilder(); appendColor(bg, bgRGB); <START> buffer.append("body {color:"); appendColor(buffer, fgRGB); buffer.append("; background-color:"); appendColor(buffer, bgRGB); buffer.append(";}"); <END> }

sample: 1483
buggy_code: <START> public static synchronized VoltDBInterface instance() { <END> if (singleton == null) { singleton = new RealVoltDB(); } return singleton; }
code_review: what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this
target code: public static VoltDBInterface instance ( ) { return singleton ; }
response: <START> public static VoltDBInterface instance() { <END> if (singleton == null) { singleton = new RealVoltDB(); } return singleton; }

sample: 1484
buggy_code: public int getRenderState() { int state = speed.ordinal(); if (getReverse()) state = 14; if (isPowered()) { if (getReverse()) state += 1; else state += 7; <START> } <END> return state; }
code_review: You can simplify this by reordering the states.
target code: public int getRenderState ( ) { int state = speed . ordinal ( ) ; if ( getReverse ( ) ) state = 4 ; if ( isPowered ( ) ) state += 5 ; return state ; }
response: public int getRenderState() { int state = speed.ordinal(); if (getReverse()) state = 14; if (isPowered()) { if (getReverse()) state += 1; else state += 7; } <START> <END> return state; }

sample: 1485
buggy_code: public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception { doAnswer(invocation -> { <START> Errors errors = (Errors) invocation.getArgument(1); <END> errors.rejectValue("absenceSettings", "error"); return null; }).when(settingsValidator).validate(any(), any()); perform(post("/web/settings")) .andExpect(view().name("settings/settings_form")); }
code_review: Den cast auf (Errors) ist hier Ã¼berflÃ¼ssig.
target code: public void ensureSettingsSavedShowsFormIfValidationFails ( ) throws Exception { doAnswer ( invocation - > { Errors errors = invocation . getArgument ( 1 ) ; errors . rejectValue ( "absenceSettings" , "error" ) ; return null ; } ) . when ( settingsValidator ) . validate ( any ( ) , any ( ) ) ; perform ( post ( " / web / settings" ) ) . andExpect ( view ( ) . name ( "settings / settings_form" ) ) ; }
response: public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception { doAnswer(invocation -> { <START> Errors errors = invocation.getArgument(1); <END> errors.rejectValue("absenceSettings", "error"); return null; }).when(settingsValidator).validate(any(), any()); perform(post("/web/settings")) .andExpect(view().name("settings/settings_form")); }

sample: 1486
buggy_code: private String extractConnectionKey(final iOSVariant iOSVariant) { final StringBuilder sb = new StringBuilder() <START> .append(iOSVariant.getVariantID()) <END> .append(iOSVariant.isProduction() ? "-prod" : "-dev"); return sb.toString(); }
code_review: I know this is not directly part of this PR, but this could be changed to `new StringBuilder(iOSVariant.getVariantID())` to avoid one useless `append` (the `StringBuilder()` constructor create StringBuilder with capacity 16, that we immediately expand with the next append)
target code: private String extractConnectionKey ( final iOSVariant iOSVariant ) { final StringBuilder sb = new StringBuilder ( iOSVariant . getVariantID ( ) ) . append ( iOSVariant . isProduction ( ) ? " - prod" : " - dev" ) ; return sb . toString ( ) ; }
response: private String extractConnectionKey(final iOSVariant iOSVariant) { final StringBuilder sb = new StringBuilder(iOSVariant.getVariantID()) <START> .append(iOSVariant.isProduction() ? "-prod" : "-dev"); return sb.toString(); }

sample: 1487
buggy_code: public void printCertificates() { DefaultTable table = new DefaultTable(); for (int i = 0; i < table.rowCount(); i++) { <START> System.out.println("On index " + i + " is : " + table.getItem(i).getText(1)); <END> } }
code_review: Use logger instead for sysout for logging.
target code: public void printCertificates ( ) { DefaultTable table = new DefaultTable ( ) ; for ( int i = 0 ; i < table . rowCount ( ) ; i ++ ) { log . info ( "On index " + i + " is : " + table . getItem ( i ) . getText ( 1 ) ) ; } }
response: public void printCertificates() { DefaultTable table = new DefaultTable(); for (int i = 0; i < table.rowCount(); i++) { <START> logger.info("On index " + i + " is : " + table.getItem(i).getText(1)); <END> } }

sample: 1488
buggy_code: public void lockEdge() throws Exception { edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.READ, true); edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.WRITE, true); edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.WRITE, true); <START> edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.READ, false); <END> }
code_review: can we revert back to using `LockMode.X` instead of `LockResource.LockMode.X`?
target code: public void lockEdge ( ) throws Exception { edgeLockTest ( LockMode . WRITE , LockMode . READ , true ) ; edgeLockTest ( LockMode . READ , LockMode . WRITE , true ) ; edgeLockTest ( LockMode . WRITE , LockMode . WRITE , true ) ; edgeLockTest ( LockMode . READ , LockMode . READ , false ) ; }
response: public void lockEdge() throws Exception { edgeLockTest(LockMode.WRITE, LockMode.READ, true); edgeLockTest(LockMode.READ, LockMode.WRITE, true); edgeLockTest(LockMode.WRITE, LockMode.WRITE, true); <START> edgeLockTest(LockMode.READ, LockMode.READ, false); <END> }

sample: 1489
buggy_code: private String getClientId() { <START> return ( (ClientMessageBusImpl) clientMessageBus ).getClientId(); <END> }
code_review: cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no?
target code: String getClientId ( ) { return clientMessageBus . getClientId ( ) ; }
response: private String getClientId() { <START> return clientMessageBus.getClientId(); <END> }

sample: 1490
buggy_code: private void configureManagementNetwork() { final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds()); if (networkConfigurator.awaitVdsmResponse()) { try { networkConfigurator.refreshNetworkConfiguration(); networkConfigurator.createManagementNetworkIfRequired(); } catch (VDSNetworkException e) { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); <START> } catch (VdsInstallException e) { <END> throw new VdsInstallException(VDSStatus.NonOperational, "Failed to configure manamgent network on the host"); } } else { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); } }
code_review: Are you sure VdsInstallException is the right exception here?
target code: private void configureManagementNetwork ( ) { final NetworkConfigurator networkConfigurator = new NetworkConfigurator ( getVds ( ) ) ; if ( ! networkConfigurator . awaitVdsmResponse ( ) ) { throw new VdsInstallException ( VDSStatus . NonResponsive , "Network error during communication with the host" ) ; } try { networkConfigurator . refreshNetworkConfiguration ( ) ; networkConfigurator . createManagementNetworkIfRequired ( ) ; } catch ( VDSNetworkException e ) { throw new VdsInstallException ( VDSStatus . NonResponsive , "Network error during communication with the host" , e ) ; } catch ( Exception e ) { throw new VdsInstallException ( VDSStatus . NonOperational , "Failed to configure manamgent network on the host" , e ) ; } }
response: private void configureManagementNetwork() { final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds()); if (networkConfigurator.awaitVdsmResponse()) { try { networkConfigurator.refreshNetworkConfiguration(); networkConfigurator.createManagementNetworkIfRequired(); } catch (VDSNetworkException e) { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); <START> } catch (VdsInstallException e) { <END> throw new VdsInstallException(VDSStatus.NonOperational, "Failed to configure management network on the host"); } } else { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); } }

sample: 1491
buggy_code: <START> public static Response newResetResponse(Header header) { return newRestartResponse(header, newNoServerError()); } <END>
code_review: I think you forgot to change this to - `return newResetResponse(header, newNoServerError());`
target code: public static Response newResetResponse ( Header header ) { return newResetResponse ( header , newNoServerError ( ) ) ; }
response: <START> public static Response newResetResponse(Header header) { return newResetResponse(header, newNoServerError()); } <END>

sample: 1492
buggy_code: <START> private static Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { <END> if (!primaryValue.isPresent()) { return safetyValue; } return primaryValue; }
code_review: Why does this need to be `static`?
target code: private Optional < TimeValue > getTimeValue ( Optional < TimeValue > primaryValue , Optional < TimeValue > safetyValue ) { if ( ! primaryValue . isPresent ( ) ) { return safetyValue ; } return primaryValue ; }
response: <START> private Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { <END> if (!primaryValue.isPresent()) { return safetyValue; } return primaryValue; }

sample: 1493
buggy_code: public Uris(String scheme, String host) { this.scheme = scheme; this.host = host; this.port = 0; <START> this.rcnamespace = "0|120"; <END> }
code_review: This should be a constant, not a magic string.
target code: public Uris ( String scheme , String host ) { this . scheme = scheme ; this . host = host ; this . port = 0 ; }
response: public Uris(String scheme, String host) { this.scheme = scheme; this.host = host; this.port = 0; <START> this.rcnamespace = "0|120"; <END> }

sample: 1494
buggy_code: private void carryOntoHistory(RevCommit c, int carry) { stack = null; for (;;) { carryOntoHistoryInnerLoop(c, carry); CarryStack s = stack; if (s != null) { <START> stack = s.prev; c = s.c; carry = s.carry; <END> continue; } break; } }
code_review: can change the order to save a temp variable s.
target code: private void carryOntoHistory ( RevCommit c , int carry ) { stack = null ; for ( ; ; ) { carryOntoHistoryInnerLoop ( c , carry ) ; if ( stack != null ) { c = stack . c ; carry = stack . carry ; stack = stack . prev ; continue ; } break ; } }
response: private void carryOntoHistory(RevCommit c, int carry) { stack = null; for (;;) { carryOntoHistoryInnerLoop(c, carry); CarryStack s = stack; if (s != null) { <START> c = s.c; carry = s.carry; stack = s.prev; <END> continue; } break; } }

sample: 1495
buggy_code: private FactHandle[] insertFacts(KieSession ksession, int n) { FactHandle[] fhs = new FactHandle[n]; for (int i = 0; i < n; i++) { fhs[i] = ksession.insert(i); <START> ksession.insert("" + String.valueOf(i)); <END> } return fhs; }
code_review: Could be just ksession.insert(String.valueOf(i));
target code: private FactHandle [ ] insertFacts ( KieSession ksession , int n ) { FactHandle [ ] fhs = new FactHandle [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { fhs [ i ] = ksession . insert ( i ) ; ksession . insert ( String . valueOf ( i ) ) ; } return fhs ; }
response: private FactHandle[] insertFacts(KieSession ksession, int n) { FactHandle[] fhs = new FactHandle[n]; for (int i = 0; i < n; i++) { fhs[i] = ksession.insert(i); <START> ksession.insert(String.valueOf(i)); <END> } return fhs; }

sample: 1496
buggy_code: public SecureStore get() { <START> return injector.getInstance(getSecureStoreImpl()); <END> }
code_review: This will create a new instance every time. Cache the instance in a member variable?
target code: public SecureStore get ( ) { if ( instance == null ) { instance = injector . getInstance ( getSecureStoreImpl ( ) ) ; } return instance ; }
response: public SecureStore get() { <START> return injector.getInstance(getSecureStoreImpl()); <END> }

sample: 1497
buggy_code: protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) { if (getUpdateSwingFromScoutLock().isAcquired()) { return; } // if (swingTransferable != null) { <START> if (getScoutObject() != null) { <END> final ITreeNode scoutNode = treePathToScoutNode(path); // notify Scout (asynchronous !) Runnable t = new Runnable() { @Override public void run() { getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode); } }; getSwingEnvironment().invokeScoutLater(t, 0); // end notify } } }
code_review: if (swingTransferable != null && getScoutObject() != null) {...}
target code: protected void handleSwingDropTargetChanged ( TreePath path , Transferable swingTransferable ) { if ( getUpdateSwingFromScoutLock ( ) . isAcquired ( ) ) { return ; } // if ( swingTransferable != null && getScoutObject ( ) != null ) { final ITreeNode scoutNode = treePathToScoutNode ( path ) ; // notify Scout ( asynchronous ! ) Runnable t = new Runnable ( ) { @Override public void run ( ) { getScoutObject ( ) . getUIFacade ( ) . fireNodeDropTargetChangedFromUI ( scoutNode ) ; } } ; getSwingEnvironment ( ) . invokeScoutLater ( t , 0 ) ; // end notify } }
response: protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) { if (getUpdateSwingFromScoutLock().isAcquired()) { return; } // if (swingTransferable != null) { <START> if (getScoutObject() != null) { <END> final ITreeNode scoutNode = treePathToScoutNode(path); // notify Scout (asynchronous !) Runnable t = new Runnable() { @Override public void run() { getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode); } }; getSwingEnvironment().invokeScoutLater(t, 0); // end notify } } }

sample: 1498
buggy_code: <START> public void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { <END> validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold); this.diskUsageThreshold = diskSpaceThreshold; this.diskUsageWarnThreshold = diskUsageWarnThreshold; }
code_review: I don't see this called anywhere in the patch. Is there a reason to make it public?
target code: void setDiskSpaceThreshold ( float diskSpaceThreshold , float diskUsageWarnThreshold ) { validateThreshold ( diskSpaceThreshold , diskUsageWarnThreshold ) ; this . diskUsageThreshold = diskSpaceThreshold ; this . diskUsageWarnThreshold = diskUsageWarnThreshold ; }
response: <START> void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { <END> validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold); this.diskUsageThreshold = diskSpaceThreshold; this.diskUsageWarnThreshold = diskUsageWarnThreshold; }

sample: 1499
buggy_code: public static void setInstance(Object source, @MappingTarget Object target) { Integer level = LEVEL.get(); fireMethodCalled( level, "setInstance", source, target ); if ( level == null ) { LEVEL.set( 1 ); MAPPING.set( new IdentityHashMap<Object, Object>() ); } else { <START> LEVEL.set( level.intValue() + 1 ); <END> } MAPPING.get().put( source, target ); }
code_review: not needed unboxing
target code: public static void setInstance ( Object source , @MappingTarget Object target ) { Integer level = LEVEL . get ( ) ; fireMethodCalled ( level , "setInstance" , source , target ) ; if ( level == null ) { LEVEL . set ( 1 ) ; MAPPING . set ( new IdentityHashMap < Object , Object > ( ) ) ; } else { LEVEL . set ( level + 1 ) ; } MAPPING . get ( ) . put ( source , target ) ; }
response: public static void setInstance(Object source, @MappingTarget Object target) { Integer level = LEVEL.get(); fireMethodCalled( level, "setInstance", source, target ); if ( level == null ) { LEVEL.set( 1 ); MAPPING.set( new IdentityHashMap<Object, Object>() ); } else { <START> LEVEL.set( level + 1 ); <END> } MAPPING.get().put( source, target ); }

sample: 1500
buggy_code: <START> public List<StandardPreset> getAllStandardPresets() throws MiddlewareQueryException { <END> return this.workbenchDataManager.getStandardPresetDAO().getAll(); }
code_review: Remove throws MiddlewareQueryException
target code: public List < StandardPreset > getAllStandardPresets ( ) { return this . workbenchDataManager . getStandardPresetDAO ( ) . getAll ( ) ; }
response: <START> public List<StandardPreset> getAllStandardPresets() { <END> return this.workbenchDataManager.getStandardPresetDAO().getAll(); }

sample: 1501
buggy_code: protected void executeVDSCommand() { if (_vdsManager != null) { try { <START> _vdsManager.getLockObj().lock(); <END> executeVdsIdCommand(); } finally { _vdsManager.getLockObj().unlock(); } } else { executeVdsIdCommand(); } }
code_review: why did you change this?
target code: protected void executeVDSCommand ( ) { if ( _vdsManager != null ) { synchronized ( _vdsManager . getLockObj ( ) ) { executeVdsIdCommand ( ) ; } } else { executeVdsIdCommand ( ) ; } }
response: protected void executeVDSCommand() { if (_vdsManager != null) { try { <START> _vdsManager.getLockObj().lock(); <END> executeVdsIdCommand(); } finally { _vdsManager.getLockObj().unlock(); } } else { executeVdsIdCommand(); } }

sample: 1502
buggy_code: public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc("We are introducing ${myStringInCtxt} !", WEBVIEW_R<END>ITION); TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc()); <START> List<TemplateInput> params = Arrays.asList( <END> factory("myStringInCtxt", StringValue, "Beautiful String") ); templateBase.saveParams(TEMPLATE_NAME, params, true); Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME); assertNotNull(result); assertEquals("We are introducing Beautiful String !", result.getString()); }
code_review: Could you use `List#of` or `Collections#singletonList`?
target code: public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt ( ) throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc ( "We are introducing $ { myStringInCtxt } ! " , WEBVIEW_RENDITION ) ; TemplateBasedDocument templateBase = createTemplateBasedDoc ( templateSrc . getAdaptedDoc ( ) ) ; List < TemplateInput > params = List . of ( factory ( "myStringInCtxt" , StringValue , "Beautiful String" ) ) ; templateBase . saveParams ( TEMPLATE_NAME , params , true ) ; Blob result = templateBase . renderWithTemplate ( TEMPLATE_NAME ) ; assertNotNull ( result ) ; assertEquals ( "We are introducing Beautiful String ! " , result . getString ( ) ) ; }
response: public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc("We are introducing ${myStringInCtxt} !", WEBVIEW_R<END>ITION); TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc()); <START> List<TemplateInput> params = Collections.singletonList( <END> factory("myStringInCtxt", StringValue, "Beautiful String") ); templateBase.saveParams(TEMPLATE_NAME, params, true); Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME); assertNotNull(result); assertEquals("We are introducing Beautiful String !", result.getString()); }

sample: 1503
buggy_code: public static PDPrintStyle getLineStyle (JSONObject oskariStyle) { PDPrintStyle style = new PDPrintStyle(); <START> JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, "stroke", () -> new JSONObject()); <END> setStrokeStyle(style, stroke); // polygon doesn't have cap style setLabelStyle(style, oskariStyle); style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,"lineCap"), 0)); return style; }
code_review: Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the code work properly.
target code: public static PDPrintStyle getLineStyle ( JSONObject oskariStyle ) { JSONObject stroke = oskariStyle . optJSONObject ( "stroke" ) ; PDPrintStyle style = new PDPrintStyle ( ) ; setStrokeStyle ( style , stroke ) ; setLabelStyle ( style , oskariStyle ) ; return style ; }
response: public static PDPrintStyle getLineStyle (JSONObject oskariStyle) { PDPrintStyle style = new PDPrintStyle(); <START> JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, "stroke", () -> new JSONObject()); if (stroke.length() == 0) { return style; } <END> setStrokeStyle(style, stroke); // polygon doesn't have cap style setLabelStyle(style, oskariStyle); style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,"lineCap"), 0)); return style; }

sample: 1504
buggy_code: public static void init(Configuration conf) { if (!initDone) { DefaultConfiguration.conf = conf; DefaultConfiguration.initDone = true; <START> } <END> }
code_review: All of the methods on this class should be `synchronized`. Otherwise this change looks good.
target code: public static synchronized void init ( Configuration conf ) { if ( ! initDone ) { DefaultConfiguration . conf = conf ; DefaultConfiguration . initDone = true ; } }
response: public static synchronized void init(Configuration conf) { if (!initDone) { DefaultConfiguration.conf = conf; DefaultConfiguration.initDone = true; <START> } <END> }

sample: 1505
buggy_code: private void rollBackToTimestamp(long timestamp) { if (getVersionUnsafe() > timestamp) { try { rollbackObjectUnsafe(timestamp); // Rollback successfully got us to the right // version, we're done. <START> if (getVersionUnsafe() == timestamp) { <END> return; } } catch (NoRollbackException nre) { log.warn("Rollback[{}] to {} failed {}", this, timestamp, nre); resetUnsafe(); } } }
code_review: We return even if this is false. Should we do something in the else case?
target code: private void rollBackToTimestamp ( long timestamp ) { if ( getVersionUnsafe ( ) > timestamp ) { try { rollbackObjectUnsafe ( timestamp ) ; } catch ( NoRollbackException nre ) { log . warn ( "Rollback [ { } ] to { } failed { } " , this , timestamp , nre ) ; resetUnsafe ( ) ; } } }
response: private void rollBackToTimestamp(long timestamp) { if (getVersionUnsafe() > timestamp) { try { rollbackObjectUnsafe(timestamp); // Rollback successfully got us to the right // version, we're done. <START> if (getVersionUnsafe() == timestamp) { <END> return; } else { // We return even if this is false. Should we do something in the else case? } } catch (NoRollbackException nre) { log.warn("Rollback[{}] to {} failed {}", this, timestamp, nre); resetUnsafe(); } } }

sample: 1506
buggy_code: public void prepare(Properties options) { Objects.requireNonNull(mapper, "mapper can not be null"); Objects.requireNonNull(topicSelector, "topicSelector can not be null"); <START> producer = new KafkaProducer<K, V>(options); <END> }
code_review: Nit: I think `new KafkaProducer<>(options)` will work here
target code: public void prepare ( Properties options ) { Objects . requireNonNull ( mapper , "mapper can not be null" ) ; Objects . requireNonNull ( topicSelector , "topicSelector can not be null" ) ; producer = new KafkaProducer < > ( options ) ; }
response: public void prepare(Properties options) { Objects.requireNonNull(mapper, "mapper can not be null"); Objects.requireNonNull(topicSelector, "topicSelector can not be null"); <START> producer = new KafkaProducer<>(options); <END> }

sample: 1507
buggy_code: protected Control createSWTControl(Composite parent) throws DatabindingFailedException { final Control control = super.createSWTControl(parent); <START> final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { <END> new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory); return control; }
code_review: this must be disposed
target code: protected Control createSWTControl ( Composite parent ) throws DatabindingFailedException { final Control control = super . createSWTControl ( parent ) ; composedAdapterFactory = new ComposedAdapterFactory ( new AdapterFactory [ ] { new ReflectiveItemProviderAdapterFactory ( ) , new ComposedAdapterFactory ( ComposedAdapterFactory . Descriptor . Registry . INSTANCE ) } ) ; adapterFactoryItemDelegator = new AdapterFactoryItemDelegator ( composedAdapterFactory ) ; return control ; }
response: protected Control createSWTControl(Composite parent) throws DatabindingFailedException { final Control control = super.createSWTControl(parent); <START> final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { <END> new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory); return control; }

sample: 1508
buggy_code: public boolean isRegistered(VeluxProduct product) { logger.trace("isRegistered(VeluxProduct {}) called.", product.toString()); if (product.isV2()) { return isRegistered(product.getSerialNumber()); <START> } else { <END> return isRegistered(product.getProductUniqueIndex()); } }
code_review: `else` is redundant here.
target code: public boolean isRegistered ( VeluxProduct product ) { logger . trace ( "isRegistered ( VeluxProduct { } ) called . " , product . toString ( ) ) ; if ( product . isV2 ( ) ) { return isRegistered ( product . getSerialNumber ( ) ) ; } return isRegistered ( product . getProductUniqueIndex ( ) ) ; }
response: public boolean isRegistered(VeluxProduct product) { logger.trace("isRegistered(VeluxProduct {}) called.", product.toString()); if (product.isV2()) { return isRegistered(product.getSerialNumber()); <START> } <END> return isRegistered(product.getProductUniqueIndex()); }

sample: 1509
buggy_code: public void tearDown() throws Exception { FileUtils.deleteQuietly(nuxeoHome); // Restore or clear all the system properties manipulated by the current test <START> originSystemProps.forEach((key, originValue) -> { <END> if (originValue == null) { System.clearProperty(key); } else { System.setProperty(key, originValue); } }); originSystemProps.clear(); }
code_review: You can call the value just `value`
target code: public void tearDown ( ) throws Exception { FileUtils . deleteQuietly ( nuxeoHome ) ; // Restore or clear all the system properties manipulated by the current test originSystemProps . forEach ( ( key , value ) - > { if ( value == null ) { System . clearProperty ( key ) ; } else { System . setProperty ( key , value ) ; } } ) ; originSystemProps . clear ( ) ; }
response: public void tearDown() throws Exception { FileUtils.deleteQuietly(nuxeoHome); // Restore or clear all the system properties manipulated by the current test <START> originSystemProps.forEach((key, value) -> { <END> if (value == null) { System.clearProperty(key); } else { System.setProperty(key, value); } }); originSystemProps.clear(); }

sample: 1510
buggy_code: private void checkDeployedProject(String projectName) { ServersView2 serversView = new ServersView2(); serversView.open(); ServerModule module = serversView.getServer(FULL_SERVER_NAME) .getModule(new RegexMatcher(".*" + projectName + ".*")); new WaitUntil(new ServerModuleHasState(module, ServerState.<START>ED), TimePeriod.getCustom(30)); ModuleLabel moduleLabel = module.getLabel(); ServerState moduleState = moduleLabel.getState(); <START> assertTrue("Module has not been started!", moduleState == ServerState.<START>ED); <END> }
code_review: Are these two lines of definitions necessary? Isn't it shorter to just use module.getLabel().getState() in assert?
target code: private void checkDeployedProject ( String projectName ) { ServersView2 serversView = new ServersView2 ( ) ; serversView . open ( ) ; ServerModule module = serversView . getServer ( FULL_SERVER_NAME ) . getModule ( new RegexMatcher ( " .* " + projectName + " .* " ) ) ; new WaitUntil ( new ServerModuleHasState ( module , ServerState . STARTED ) , TimePeriod . getCustom ( 30 ) ) ; ModuleLabel moduleLabel = module . getLabel ( ) ; assertTrue ( "Module has not been started ! " , moduleLabel . getState ( ) == ServerState . STARTED ) ; }
response: private void checkDeployedProject(String projectName) { ServersView2 serversView = new ServersView2(); serversView.open(); ServerModule module = serversView.getServer(FULL_SERVER_NAME) .getModule(new RegexMatcher(".*" + projectName + ".*")); new WaitUntil(new ServerModuleHasState(module, ServerState.<START>ED), TimePeriod.getCustom(30)); <START> assertTrue("Module has not been started!", module.getLabel().getState() == ServerState.<START>ED); <END> }

sample: 1511
buggy_code: SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) { <START> return new StandardSlackService(baseUrl, teamDomain, null, authTokenCredentialId, botUser, room); <END> }
code_review: Oh please, no! Don't ship a null object! :cry:
target code: SlackService getSlackService ( final String baseUrl , final String teamDomain , final String authTokenCredentialId , final boolean botUser , final String room ) { return new StandardSlackService ( baseUrl , teamDomain , authTokenCredentialId , botUser , room ) ; }
response: SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) { <START> return new StandardSlackService(baseUrl, teamDomain, authTokenCredentialId, botUser, room); <END> }

sample: 1512
buggy_code: private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) { if ( isAnnotationPresent( type, processedAnnotations ) ) { return true; } } } <START> if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { <END> return true; } return false; }
code_review: I would move this one first.
target code: private boolean isAnnotationPresent ( AnnotatedType annotatedType , Set < Annotation > processedAnnotations ) { if ( isAnnotationPresentIn ( annotatedType . getDeclaredAnnotations ( ) , processedAnnotations ) ) { return true ; } if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( ( AnnotatedParameterizedType ) annotatedType ) . getAnnotatedActualTypeArguments ( ) ) { if ( isAnnotationPresent ( type , processedAnnotations ) ) { return true ; } } } return false ; }
response: private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) { if ( isAnnotationPresent( type, processedAnnotations ) ) { return true; } } } <START> if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { return true; } <END> return false; }

sample: 1513
buggy_code: static int staticFunc() { InvokeStatic f = new InvokeStatic() { // Noncompliant @Override <START> public String func(int n) { <END> unknown(); staticFunc(); return 0; } }; return f.func(); }
code_review: int func();
target code: static int staticFunc ( ) { InvokeStatic f = new InvokeStatic ( ) { // Noncompliant @Override public int func ( ) { unknown ( ) ; staticFunc ( ) ; return 0 ; } } ; return f . func ( ) ; }
response: static int staticFunc() { InvokeStatic f = new InvokeStatic() { // Noncompliant @Override <START> public int func() { <END> unknown(); staticFunc(); return 0; } }; return f.func(); }

sample: 1514
buggy_code: private synchronized void resetGeneration() { this.generation = Generation.NO_GENERATION; rejoinNeeded = true; // only reset the state to un-joined when it is not already in rebalancing <START> if (state != MemberState.REBALANCING) <END> state = MemberState.UNJOINED; }
code_review: But we are moving to UNJOINED anyway, so it won't affect the result right?
target code: private synchronized void resetGeneration ( ) { this . rejoinNeeded = true ; this . generation = Generation . NO_GENERATION ; }
response: private synchronized void resetGeneration() { this.generation = Generation.NO_GENERATION; rejoinNeeded = true; // only reset the state to un-joined when it is not already in rebalancing <START> if (state != MemberState.REBALANCING) <END> state = MemberState.UNJOINED; }

sample: 1515
buggy_code: public Path generateArtifact(URI uri, int size) throws IOException { <START> new NpmPackageGenerator(Paths.get(uri)); <END> buildPublishJson(); return getPackagePath(); }
code_review: why you need this here?
target code: public Path generateArtifact ( URI uri , int size ) throws IOException { buildPublishJson ( ) ; return getPackagePath ( ) ; }
response: public Path generateArtifact(URI uri, int size) throws IOException { <START> new NpmPackageGenerator(Paths.get(uri)); <END> buildPublishJson(); return getPackagePath(); }

sample: 1516
buggy_code: public void nextTuple() { Utils.sleep(100); <START> Random rand = new Random(); <END> Integer value = rand.nextInt(1000); collector.emit(new Values(value)); }
code_review: Minor nit, declaring a new Random each time is not really good practice.
target code: public void nextTuple ( ) { Utils . sleep ( 100 ) ; collector . emit ( new Values ( rand . nextInt ( 1000 ) ) ) ; }
response: public void nextTuple() { Utils.sleep(100); <START> Random rand = new Random(); <END> Integer value = rand.nextInt(1000); collector.emit(new Values(value)); }

sample: 1517
buggy_code: <START> public void register(final Class<?> clazz, final Object converter) { <END> otherWord = ""; }
code_review: these 3 methods are `public` do you really need them?
target code: private void register ( final Class < ? > clazz , final Object converter ) { otherWord = "" ; }
response: <START> private void register(final Class<?> clazz, final Object converter) { <END> otherWord = ""; }

sample: 1518
buggy_code: public void testMarkerOnLastLineNoNewline_495842() throws Exception { try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("", false)))) { writer.write(getAboveComment().trim()); } <START> PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); <END> indexFiles(); PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false); String result = runQuickFixOneFile(); assertContainedIn("int func() { } // @suppress(\"No return\")", result); }
code_review: Why are we setting it to true during indexing?
target code: public void testMarkerOnLastLineNoNewline_495842 ( ) throws Exception { try ( BufferedWriter writer = new BufferedWriter ( new FileWriter ( loadcode ( "" , false ) ) ) ) { writer . write ( getAboveComment ( ) . trim ( ) ) ; } PreferenceConstants . getPreferenceStore ( ) . setValue ( PreferenceConstants . ENSURE_NEWLINE_AT_EOF , false ) ; indexFiles ( ) ; String result = runQuickFixOneFile ( ) ; PreferenceConstants . getPreferenceStore ( ) . setValue ( PreferenceConstants . ENSURE_NEWLINE_AT_EOF , true ) ; assertContainedIn ( "int func ( ) { } // @suppress ( \"No return\" ) " , result ) ; }
response: public void testMarkerOnLastLineNoNewline_495842() throws Exception { try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("", false)))) { writer.write(getAboveComment().trim()); } <START> PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); <END> indexFiles(); PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false); String result = runQuickFixOneFile(); assertContainedIn("int func() { } // @suppress(\"No return\")", result); }

sample: 1519
buggy_code: public void onLanguageTabSelected(String selectedLanguageCode) { <START> Log.e("####", "HERE"); <END> searchLanguageCode = selectedLanguageCode; startSearch(query, query != null && query.length() > 1); }
code_review: What is the Log.e for?
target code: public void onLanguageTabSelected ( String selectedLanguageCode ) { searchLanguageCode = selectedLanguageCode ; startSearch ( query , query != null && query . length ( ) > 1 ) ; }
response: public void onLanguageTabSelected(String selectedLanguageCode) { <START> Log.e("####", "HERE"); <END> searchLanguageCode = selectedLanguageCode; startSearch(query, query != null && query.length() > 1); }

sample: 1520
buggy_code: public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter) { <START> Log.d("Logging EntityProcessor", "before insert"); <END> T result = mDelegate.insert(db, entityAdapter, isSyncAdapter); Log.d("Logging EntityProcessor", "after insert on " + entityAdapter.id()); return result; }
code_review: Move the tag to a constant?
target code: public T insert ( SQLiteDatabase db , T entityAdapter , boolean isSyncAdapter ) { Log . d ( TAG , "before insert" ) ; T result = mDelegate . insert ( db , entityAdapter , isSyncAdapter ) ; Log . d ( TAG , "after insert on " + entityAdapter . id ( ) ) ; return result ; }
response: public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter) { <START> Log.d(TAG, "before insert"); <END> T result = mDelegate.insert(db, entityAdapter, isSyncAdapter); Log.d(TAG, "after insert on " + entityAdapter.id()); return result; }

sample: 1521
buggy_code: protected UfsStatus(UfsStatus status) { mIsDirectory = status.mIsDirectory; mName = status.mName; mOwner = status.mOwner; mGroup = status.mGroup; mMode = status.mMode; mLastModifiedTimeMs = status.mLastModifiedTimeMs; <START> mXAttr = status.mXAttr; <END> }
code_review: This won't copy the map?
target code: protected UfsStatus ( UfsStatus status ) { mIsDirectory = status . mIsDirectory ; mName = status . mName ; mOwner = status . mOwner ; mGroup = status . mGroup ; mMode = status . mMode ; mLastModifiedTimeMs = status . mLastModifiedTimeMs ; mXAttr = status . mXAttr == null ? null : new HashMap < > ( status . mXAttr ) ; }
response: protected UfsStatus(UfsStatus status) { mIsDirectory = status.mIsDirectory; mName = status.mName; mOwner = status.mOwner; mGroup = status.mGroup; mMode = status.mMode; mLastModifiedTimeMs = status.mLastModifiedTimeMs; <START> mXAttr = new HashMap<>(status.mXAttr); <END> }

sample: 1522
buggy_code: boolean isProjectStyle() { if (myIsFrameworkStyle) { return false; } ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true); assert repository != null : <START> repository.getDisplayName(); <END> return repository.hasResourceItem(ResourceType.STYLE, myStyleName); }
code_review: if repository is null, this will throw an NPE.
target code: boolean isProjectStyle ( ) { if ( myIsFrameworkStyle ) { return false ; } ProjectResourceRepository repository = ProjectResourceRepository . getProjectResources ( myConfiguration . getModule ( ) , true ) ; assert repository != null : myConfiguration . getModule ( ) . getName ( ) ; return repository . hasResourceItem ( ResourceType . STYLE , myStyleName ) ; }
response: boolean isProjectStyle() { if (myIsFrameworkStyle) { return false; } ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true); assert repository != null : <START> repository.getDisplayName(); <END> return repository.hasResourceItem(ResourceType.STYLE, myStyleName); }

sample: 1523
buggy_code: public void setUserProperty(String prop, String value) { getUserProperties().put(prop, value); <START> Context.clearCacheForCurrentUser(); <END> }
code_review: Let's use @CacheEvict(value="userSearchLocales") public User saveUser(User user, String password) instead. We will get rid of CacheManager in Context as well. It would be better to evict just for the specified user, but our key consists of user and currentLocale. SaveUser is not called that often so invalidating all entries is no issue anyway.
target code: public void setUserProperty ( String prop , String value ) { getUserProperties ( ) . put ( prop , value ) ; }
response: public void setUserProperty(String prop, String value) { getUserProperties().put(prop, value); <START> Context.clearCacheForCurrentUser(); <END> }

sample: 1524
buggy_code: JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) { this.processor = processor; this.xmlPathInJar = xmlPathInJar; //Ensure that dynamic list operations supported <START> this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); <END> }
code_review: You can revert this change because you don't need it in this specific class.
target code: JarFileUtils ( IPostProcessor processor , String xmlPathInJar , List < String > testNames ) { this . processor = processor ; this . xmlPathInJar = xmlPathInJar ; this . testNames = testNames ; }
response: JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) { this.processor = processor; this.xmlPathInJar = xmlPathInJar; //Ensure that dynamic list operations supported <START> this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); <END> }

sample: 1525
buggy_code: public String resolve(String variable, String defaultValue) { IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver(); //ignoring argument here, as we want to fall back on the propertiesProvider. String result = delegate.resolve(variable, null); if (result == null) { try { <START> result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); <END> } catch (CoreException e) { throw new ExpressionResolutionException(e); } } return result; }
code_review: will properties provider return the defaultValue in case of no network or value not found ?
target code: public String resolve ( String variable , String defaultValue ) { IVariableResolver delegate = new ExpressionResolver . SystemPropertiesVariableResolver ( ) ; // ignoring default value first , as we want to fall back on the // propertiesProvider later . String result = delegate . resolve ( variable , null ) ; if ( result == null ) { result = propertiesProvider . getValue ( variable , defaultValue ) ; } return result ; }
response: public String resolve(String variable, String defaultValue) { IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver(); //ignoring argument here, as we want to fall back on the propertiesProvider. String result = delegate.resolve(variable, null); if (result == null) { try { <START> result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); <END> } catch (CoreException e) { throw new ExpressionResolutionException(e); } } return result; }

sample: 1526
buggy_code: public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) { if (vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId()) .getDiskInterface() == DiskInterface.VirtIO_SCSI)) { return true; } <START> return false; <END> }
code_review: you can simply return the result of anyMatch without the 'if' and 'return true/false' statements. imo, it would also be nicer to extract the "i -> i.getDiskVmElementForVm(vmBase.getId()).getDiskInterface() == DiskInterface.VirtIO_SCSI" part to a separate method "isVirtioScsiDisk" to make it easier to read
target code: public static boolean isVirtIoScsiDiskInterfaceExists ( VmBase vmBase ) { return vmBase . getImages ( ) . stream ( ) . anyMatch ( i - > i . getDiskVmElementForVm ( vmBase . getId ( ) ) . getDiskInterface ( ) == DiskInterface . VirtIO_SCSI ) ; }
response: public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) { return vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId()) .getDiskInterface() == DiskInterface.VirtIO_SCSI); }

sample: 1527
buggy_code: public void setContext(String context){ <START> typingRule.setContext(BloodTestContext.valueOf(context.replaceAll("\\s","").toUpperCase(Locale.FRENCH))); <END> }
code_review: Is there a reason for using `Locale.FRENCH`? Also, why is it needed to remove all spaces? Are you just trying to do a `trim()`, or are you removing spaces between words?
target code: public void setContext ( String context ) { typingRule . setContext ( BloodTestContext . valueOf ( context . replaceAll ( "\\s" , "" ) . toUpperCase ( ) ) ) ; }
response: public void setContext(String context){ <START> typingRule.setContext(BloodTestContext.valueOf(context.trim().toUpperCase())); <END> }

sample: 1528
buggy_code: private String readClasspathResource(String c) throws IOException { InputStream is = getClass().getResourceAsStream(c); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }
code_review: close already done in Util.read(..)
target code: private String readClasspathResource ( String c ) throws IOException { InputStream is = getClass ( ) . getResourceAsStream ( c ) ; return Util . read ( is ) ; }
response: private String readClasspathResource(String c) throws IOException { InputStream is = getClass().getResourceAsStream(c); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }

sample: 1529
buggy_code: protected void build(UnitVmModel frontend, VM backend) { <START> String name = (String) frontend.getName().getEntity(); <END> VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem(); backend.setVmtGuid(template.getId()); backend.setName(name); backend.setVmDescription((String) frontend.getDescription().getEntity()); backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity()); }
code_review: can be inlined
target code: protected void build ( UnitVmModel frontend , VM backend ) { VmTemplate template = ( VmTemplate ) frontend . getTemplate ( ) . getSelectedItem ( ) ; backend . setVmtGuid ( template . getId ( ) ) ; backend . setName ( ( String ) frontend . getName ( ) . getEntity ( ) ) ; backend . setVmDescription ( ( String ) frontend . getDescription ( ) . getEntity ( ) ) ; backend . setCustomProperties ( frontend . getCustomPropertySheet ( ) . getEntity ( ) ) ; }
response: protected void build(UnitVmModel frontend, VM backend) { VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem(); backend.setVmtGuid(template.getId()); backend.setName((String) frontend.getName().getEntity()); backend.setVmDescription((String) frontend.getDescription().getEntity()); backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity()); }

sample: 1530
buggy_code: public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception { int resultWhenTrue = 4; int resultWhenFalse = 2; List<Drug> allDrugs = conceptService.getAllDrugs(); assertEquals(resultWhenTrue, allDrugs.size()); <START> allDrugs = conceptService.getAllDrugs(false); <END> assertEquals(resultWhenFalse, allDrugs.size()); }
code_review: @mavrk one test should only be for one method and one combination of parameters. and the goal is that every public method in the service layer is tested. so you should write tests for the methods * getAllDrugs() * getAllDrugs(includeRetired) and for the latter you need one test passing true and one passing false. another case is also what if there are no drugs will it return an empty list? I know this is tedious but thats because when this was written [TDD|https://en.wikipedia.org/wiki/Test-driven_development] which would start with tests wasnt used.
target code: public void getAllDrugs_shouldReturnAListOfAllDrugs ( ) throws Exception { int resultWhenTrue = 4 ; List < Drug > allDrugs = conceptService . getAllDrugs ( ) ; assertEquals ( resultWhenTrue , allDrugs . size ( ) ) ; }
response: public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception { int resultWhenTrue = 4; int resultWhenFalse = 2; List<Drug> allDrugs = conceptService.getAllDrugs(); assertEquals(resultWhenTrue, allDrugs.size()); allDrugs = conceptService.getAllDrugs(false); assertEquals(resultWhenFalse, allDrugs.size()); }

sample: 1531
buggy_code: public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades( CurrencyPair currencyPair) throws IOException { <START> final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> <END> transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair)); return transactionHistory.getData(); }
code_review: those inner classes make reading all of this much worse
target code: public List < BithumbTransactionHistory > getBithumbTrades ( CurrencyPair currencyPair ) throws IOException { final BithumbResponse < List < BithumbTransactionHistory > > transactionHistory = bithumb . transactionHistory ( BithumbUtils . getBaseCurrency ( currencyPair ) ) ; return transactionHistory . getData ( ) ; }
response: public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades( CurrencyPair currencyPair) throws IOException { <START> final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair)); <END> return transactionHistory.getData(); }

sample: 1532
buggy_code: public void addChild(String name, Long id) { <START> if (mChildren.put(name, id) == null) { <END> mWeight.incrementAndGet(); } }
code_review: `mChildren` could be `null`
target code: public void addChild ( String name , Long id ) { if ( mChildren != null && mChildren . put ( name , id ) == null ) { mWeight . incrementAndGet ( ) ; } }
response: public void addChild(String name, Long id) { <START> if (mChildren != null && mChildren.put(name, id) == null) { <END> mWeight.incrementAndGet(); } }

sample: 1533
buggy_code: static void reTryKerberos(boolean enabled) { if (enabled) { log.debug("Try relogin kerberos at first!"); try { if (UserGroupInformation.isLoginKeytabBased()) { UserGroupInformation.getLoginUser().reloginFromKeytab(); } else if (UserGroupInformation.isLoginTicketBased()) { UserGroupInformation.getLoginUser().reloginFromTicketCache(); } } catch (IOException e) { <START> log.error("Try relogin kerberos failed!"); <END> throw new RuntimeException(e); } } }
code_review: nit: This will result in double logging
target code: static void reTryKerberos ( boolean enabled ) { if ( enabled ) { log . debug ( "Try relogin kerberos at first ! " ) ; try { if ( UserGroupInformation . isLoginKeytabBased ( ) ) { UserGroupInformation . getLoginUser ( ) . reloginFromKeytab ( ) ; } else if ( UserGroupInformation . isLoginTicketBased ( ) ) { UserGroupInformation . getLoginUser ( ) . reloginFromTicketCache ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }
response: static void reTryKerberos(boolean enabled) { if (enabled) { log.debug("Try relogin kerberos at first!"); try { if (UserGroupInformation.isLoginKeytabBased()) { UserGroupInformation.getLoginUser().reloginFromKeytab(); } else if (UserGroupInformation.isLoginTicketBased()) { UserGroupInformation.getLoginUser().reloginFromTicketCache(); } } catch (IOException e) { <START> log.error("Try relogin kerberos failed!", e); <END> throw new RuntimeException(e); } } }

sample: 1534
buggy_code: void resetLogic() { for (int i = 0; i < fieldSize; i++) <START> for (int j = 0; j < fieldSize; j++) fieldArray[i][j] = 0; <END> playerMark = CROSS_MARK; aIMark = ZERO_MARK; turn = 0; //first turn autoGameEnabled = false; }
code_review: braces
target code: void resetLogic ( ) { for ( int i = 0 ; i < fieldSize ; i ++ ) for ( int j = 0 ; j < fieldSize ; j ++ ) { fieldArray [ i ] [ j ] = 0 ; } playerMark = CROSS_MARK ; aIMark = ZERO_MARK ; turn = 0 ; // first turn autoGameEnabled = false ; }
response: void resetLogic() { for (int i = 0; i < fieldSize; i++) { for (int j = 0; j < fieldSize; j++) fieldArray[i][j] = 0; } playerMark = CROSS_MARK; aIMark = ZERO_MARK; turn = 0; //first turn autoGameEnabled = false; }

sample: 1535
buggy_code: protected Stream<URL> listBundleComponents(Bundle bundle) { String list = OSGiRuntimeService.getComponentsList(bundle); String name = bundle.getSymbolicName(); log.debug("PartialBundle: " + name + " components: " + list); if (list == null) { return Stream.empty(); } else { <START> return Arrays.stream(list.split("[, \t\n\r\f]")).map(bundle::getEntry).filter(Objects::nonNull); <END> } }
code_review: Could you replace `Arrays#stream` by `Stream#of` for consistency ?
target code: protected Stream < URL > listBundleComponents ( Bundle bundle ) { String list = OSGiRuntimeService . getComponentsList ( bundle ) ; String name = bundle . getSymbolicName ( ) ; log . debug ( "PartialBundle : " + name + " components : " + list ) ; if ( list == null ) { return Stream . empty ( ) ; } else { return Stream . of ( list . split ( " [ , \t\n\r\f ] " ) ) . map ( bundle : : getEntry ) . filter ( Objects : : nonNull ) ; } }
response: protected Stream<URL> listBundleComponents(Bundle bundle) { String list = OSGiRuntimeService.getComponentsList(bundle); String name = bundle.getSymbolicName(); log.debug("PartialBundle: " + name + " components: " + list); if (list == null) { return Stream.empty(); } else { <START> return Stream.of(list.split("[, \t\n\r\f]")).map(bundle::getEntry).filter(Objects::nonNull); <END> } }

sample: 1536
buggy_code: public void testLoadDataObjectsWithNonNullWorkspaceProject() { <START> assertTrue(dataObjectsService.loadDataObjects(workspaceProject).isEmpty()); <END> }
code_review: Please use assertj assertion. In case of fail it gives error message explaining different list sizes. Current implementation will just print assertion error, expected true but was false with no reference to list size.
target code: public void testLoadDataObjectsWithNonNullWorkspaceProject ( ) { assertThat ( dataObjectsService . loadDataObjects ( workspaceProject ) ) . isEmpty ( ) ; }
response: public void testLoadDataObjectsWithNonNullWorkspaceProject() { <START> assertThat(dataObjectsService.loadDataObjects(workspaceProject)).isEmpty(); <END> }

sample: 1537
buggy_code: <START> public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { <END> Graphics2D g2 = img.createGraphics(); if (backgroundColor != null) { g2.setBackground(backgroundColor); g2.clearRect(0, 0, width, height); } ImageRenderer renderer = new ImageRenderer(); renderer.draw(mt, g2, width, height, rootLayer, pm); return g2; }
code_review: Why this function is public ? It will be used outside of this class ?
target code: private Graphics2D prepareImageRenderer ( MapTransform mt , BufferedImage img , ProgressMonitor pm ) { Graphics2D g2 = img . createGraphics ( ) ; if ( backgroundColor != null ) { g2 . setBackground ( backgroundColor ) ; g2 . clearRect ( 0 , 0 , width , height ) ; } ImageRenderer renderer = new ImageRenderer ( ) ; renderer . draw ( mt , g2 , width , height , rootLayer , pm ) ; return g2 ; }
response: <START> public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { <END> Graphics2D g2 = img.createGraphics(); if (backgroundColor != null) { g2.setBackground(backgroundColor); g2.clearRect(0, 0, width, height); } ImageRenderer renderer = new ImageRenderer(); renderer.draw(mt, g2, width, height, rootLayer, pm); return g2; }

sample: 1538
buggy_code: public static void refreshResources(IResource[] resources, IProgressMonitor monitor) throws CoreException { try { SubMonitor progress = SubMonitor.convert(monitor, CoreText.ProjectUtil_refreshing, resources.length); for (IResource resource : resources) { if (progress.isCanceled()) break; resource.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); <START> progress.worked(1); <END> } } finally { monitor.done(); } }
code_review: Not needed, delete.
target code: public static void refreshResources ( IResource [ ] resources , IProgressMonitor monitor ) throws CoreException { try { SubMonitor progress = SubMonitor . convert ( monitor , CoreText . ProjectUtil_refreshing , resources . length ) ; for ( IResource resource : resources ) { if ( progress . isCanceled ( ) ) break ; resource . refreshLocal ( IResource . DEPTH_INFINITE , progress . newChild ( 1 ) ) ; } } finally { monitor . done ( ) ; } }
response: public static void refreshResources(IResource[] resources, IProgressMonitor monitor) throws CoreException { try { SubMonitor progress = SubMonitor.convert(monitor, CoreText.ProjectUtil_refreshing, resources.length); for (IResource resource : resources) { if (progress.isCanceled()) break; resource.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); <START> <END> } } finally { monitor.done(); } }

sample: 1539
buggy_code: private boolean isInSelection(Event event) { if (selection.x == selection.y) return false; int offset = getOffsetAtPoint(event.x, event.y, null, true); if (selection.x <= offset && offset < selection.y) return true; <START> else return false; <END> }
code_review: we can just use 'return false' instead of 'else return false'
target code: private boolean isInSelection ( Event event ) { if ( selection . x == selection . y ) return false ; int offset = getOffsetAtPoint ( event . x , event . y , null , true ) ; if ( selection . x <= offset && offset < selection . y ) return true ; return false ; }
response: private boolean isInSelection(Event event) { if (selection.x == selection.y) return false; int offset = getOffsetAtPoint(event.x, event.y, null, true); if (selection.x <= offset && offset < selection.y) return true; <START> return false; <END> }

sample: 1540
buggy_code: <START> public void setUp() throws Exception { cuMarshalService = new CUMarshalServiceImpl(); xmlFile = new File(EXAMPLE_FILE_NAME); } <END>
code_review: Is the throws Exception needed here?
target code: public void setUp ( ) { cuMarshalService = new CUMarshalServiceImpl ( ) ; xmlFile = new File ( EXAMPLE_FILE_NAME ) ; }
response: <START> public void setUp() { cuMarshalService = new CUMarshalServiceImpl(); xmlFile = new File(EXAMPLE_FILE_NAME); } <END>

sample: 1541
buggy_code: public void actionPerformed(ActionEvent e) { if(e.getSource() == okButton){ //controller should be passed to this class only if there is need to modification content of Keystore. <START> System.out.println(certControll); <END> if (certControll != null) { certControll.setAddToKeystore(true); } this.dispose(); }else if(e.getSource() == cancelButton){ if (certControll != null) { certControll.setAddToKeystore(false); } this.dispose(); } }
code_review: System.out? Booh!
target code: public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == okButton ) { // controller should be passed to this class only if there is need to modification content of Keystore . if ( certControll != null ) { certControll . setAddToKeystore ( true ) ; } this . dispose ( ) ; } else if ( e . getSource ( ) == cancelButton ) { if ( certControll != null ) { certControll . setAddToKeystore ( false ) ; } this . dispose ( ) ; } }
response: public void actionPerformed(ActionEvent e) { if(e.getSource() == okButton){ //controller should be passed to this class only if there is need to modification content of Keystore. <START> if (certControll != null) { certControll.setAddToKeystore(true); } <END> this.dispose(); }else if(e.getSource() == cancelButton){ if (certControll != null) { certControll.setAddToKeystore(false); } this.dispose(); } }

sample: 1542
buggy_code: public FilteredSourceFiles( List<Path> rawSrcFiles, BuildTarget buildTarget, GoToolchain goToolchain, GoPlatform platform, List<FileType> fileTypes) { this.rawSrcFiles = rawSrcFiles; this.extraSrcFiles = new ArrayList<>(); <START> initFilterSteps(buildTarget, goToolchain, platform, fileTypes); <END> }
code_review: instead of initializing `filterSteps` in `initFilterSteps` could you do the following? ``` filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes); ```
target code: public FilteredSourceFiles ( List < Path > rawSrcFiles , BuildTarget buildTarget , GoToolchain goToolchain , GoPlatform platform , List < FileType > fileTypes ) { this ( rawSrcFiles , ImmutableList . of ( ) , buildTarget , goToolchain , platform , fileTypes ) ; }
response: public FilteredSourceFiles( List<Path> rawSrcFiles, BuildTarget buildTarget, GoToolchain goToolchain, GoPlatform platform, List<FileType> fileTypes) { this.rawSrcFiles = rawSrcFiles; this.extraSrcFiles = new ArrayList<>(); <START> filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes); <END> }

sample: 1543
buggy_code: <START> public static char complementBase(char base, boolean RNA) { <END> if (base == 'A' && RNA) return 'U'; if (base == 'A') return 'T'; if (base == 'T' && !RNA) return 'A'; if (base == 'U' && RNA) return 'A'; if (base == 'C') return 'G'; if (base == 'G') return 'C'; return ' '; }
code_review: Isn't this already present elsewhere in biojava?
target code: protected static char complementBase ( char base , boolean RNA ) { if ( base == 'A' && RNA ) return 'U' ; if ( base == 'A' ) return 'T' ; if ( base == 'T' && ! RNA ) return 'A' ; if ( base == 'U' && RNA ) return 'A' ; if ( base == 'C' ) return 'G' ; if ( base == 'G' ) return 'C' ; return ' ' ; }
response: <START> public static char complementBase(char base, boolean RNA) { <END> if (base == 'A' && RNA) return 'U'; if (base == 'A') return 'T'; if (base == 'T' && !RNA) return 'A'; if (base == 'U' && RNA) return 'A'; if (base == 'C') return 'G'; if (base == 'G') return 'C'; return ' '; }

sample: 1544
buggy_code: public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this.classLoader = Thread.currentThread().getContextClassLoader(); <END> }
code_review: Replace with `this(in, null)`
target code: public TCCLObjectInputStream ( InputStream in ) throws IOException { this ( in , null ) ; }
response: public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this(in, null); <END> }

sample: 1545
buggy_code: private void run() { try { boolean valid = connectionSanityCheck.isValid(); if (!valid) { onInvalidConnection.run(); } } catch (Exception e) { <START> logger.warn("Impossible to correctly monitor the Axon Server connection state."); <END> } }
code_review: Add the cause to the log.
target code: private void run ( ) { try { boolean valid = connectionSanityCheck . isValid ( ) ; if ( ! valid ) { onInvalidConnection . run ( ) ; } } catch ( Exception e ) { logger . warn ( "Impossible to correctly monitor the Axon Server connection state . " , e ) ; } }
response: private void run() { try { boolean valid = connectionSanityCheck.isValid(); if (!valid) { onInvalidConnection.run(); } } catch (Exception e) { <START> logger.warn("Impossible to correctly monitor the Axon Server connection state.", e); <END> } }

sample: 1546
buggy_code: protected String getStateParameter(final WebContext context) { <START> final String stateParameter; <END> final String stateData = getState(); if (CommonHelper.isNotBlank(stateData)) { stateParameter = stateData; } else { stateParameter = CommonHelper.randomString(10); } return stateParameter; }
code_review: Why did you remove the `stateData`?
target code: protected String getStateParameter ( final WebContext context ) { final String stateParameter ; if ( CommonHelper . isNotBlank ( stateData ) ) { stateParameter = stateData ; } else { stateParameter = CommonHelper . randomString ( 10 ) ; } return stateParameter ; }
response: protected String getStateParameter(final WebContext context) { <START> final String stateData = getState(); <END> if (CommonHelper.isNotBlank(stateData)) { return stateData; } else { return CommonHelper.randomString(10); } }

sample: 1547
buggy_code: public DSpaceCommandLineParameter(String parameter) { <START> this(StringUtils.substringBefore(parameter, " "), StringUtils.substringAfter(parameter, " ")); <END> }
code_review: This logic seems potentially fragile. What if someone accidentally types in *two spaces*, e.g. `-c[space][space]test`. Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)? If we could just use that CLI API directly, it'd be better than rewriting it ourselves.
target code: protected DSpaceCommandLineParameter ( String parameter ) { this ( StringUtils . substringBefore ( parameter , " " ) , StringUtils . substringAfter ( parameter , " " ) ) ; }
response: public DSpaceCommandLineParameter(String parameter) { <START> this(StringUtils.substringBefore(parameter, " "), StringUtils.substringAfter(parameter, " ")); <END> }

sample: 1548
buggy_code: protected Transferable createTransferable(JComponent c) { indices = list.getSelectedIndices(); <START> if (list.isSelectionEmpty()) return null; <END> return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList()); }
code_review: Does this have to be after the above line? Seems like it may as well be right before. Or you could just check that the returned list is empty. Or you can do both.
target code: protected Transferable createTransferable ( JComponent c ) { if ( list . isSelectionEmpty ( ) ) return null ; indices = list . getSelectedIndices ( ) ; return new ActionTransferable ( ( ArrayList < Action > ) list . getSelectedValuesList ( ) ) ; }
response: protected Transferable createTransferable(JComponent c) { indices = list.getSelectedIndices(); <START> if (list.isSelectionEmpty()) return null; <END> return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList()); }

sample: 1549
buggy_code: public List<NimbusInfo> getAllNimbuses() { List<NimbusInfo> nimbusInfos = new ArrayList<>(); try { Collection<Participant> participants = leaderLatch.get().getParticipants(); for (Participant participant : participants) { nimbusInfos.add(Zookeeper.toNimbusInfo(participant)); } } catch (Exception e) { LOG.warn("failed to get nimbuses", e); <START> } <END> return nimbusInfos; }
code_review: Again don't eat the exception throw it, and wrap it if you cannot update the interface.
target code: public List < NimbusInfo > getAllNimbuses ( ) throws Exception { List < NimbusInfo > nimbusInfos = new ArrayList < > ( ) ; Collection < Participant > participants = leaderLatch . get ( ) . getParticipants ( ) ; for ( Participant participant : participants ) { nimbusInfos . add ( Zookeeper . toNimbusInfo ( participant ) ) ; } return nimbusInfos ; }
response: public List<NimbusInfo> getAllNimbuses() { List<NimbusInfo> nimbusInfos = new ArrayList<>(); try { Collection<Participant> participants = leaderLatch.get().getParticipants(); for (Participant participant : participants) { nimbusInfos.add(Zookeeper.toNimbusInfo(participant)); } } catch (Exception e) { LOG.warn("failed to get nimbuses", e); throw new RuntimeException(e); } return nimbusInfos; }

sample: 1550
buggy_code: <START> protected void doBegin() throws TransactionException { <END> if (txManager == null) { throw new IllegalStateException(CoreMessages .objectNotRegistered("javax.transaction.TransactionManager", "Transaction Manager").getMessage()); } try { txManager.setTransactionTimeout(getTimeoutInSeconds()); txManager.begin(); synchronized (this) { transaction = txManager.getTransaction(); } } catch (Exception e) { throw new TransactionException(cannotStartTransaction("XA"), e); } }
code_review: deprecate this
target code: protected void doBegin ( ) throws TransactionException { if ( txManager == null ) { throw new IllegalStateException ( objectNotRegistered ( "javax . transaction . TransactionManager" , "Transaction Manager" ) . getMessage ( ) ) ; } try { txManager . setTransactionTimeout ( getTimeoutInSeconds ( ) ) ; txManager . begin ( ) ; synchronized ( this ) { transaction = txManager . getTransaction ( ) ; } } catch ( Exception e ) { throw new TransactionException ( cannotStartTransaction ( "XA" ) , e ) ; } }
response: <START> protected void doBegin() throws TransactionException { <END> if (txManager == null) { throw new IllegalStateException(CoreMessages .objectNotRegistered("javax.transaction.TransactionManager", "Transaction Manager").getMessage()); } try { txManager.setTransactionTimeout(getTimeoutInSeconds()); txManager.begin(); synchronized (this) { transaction = txManager.getTransaction(); } } catch (Exception e) { throw new TransactionException(cannotStartTransaction("XA"), e); } }

sample: 1551
buggy_code: public int hashCode() { int hash = 7; hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0); <START> return hash; <END> }
code_review: Why not use `org.modeshape.common.util.HashCode.compute(...)` instead of this? Or better yet, why not just return `name.hashCode()`? (When can `name` be null?)
target code: public int hashCode ( ) { return name . hashCode ( ) ; }
response: public int hashCode() { int hash = 7; hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0); return hash; }

sample: 1552
buggy_code: public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) { Exception exception = null; frontendMetrics.securityServicePostProcessRequestRate.mark(); long startTimeMs = System.currentTimeMillis(); if (!isOpen) { exception = new RestServiceException("SecurityService is closed", RestServiceErrorCode.ServiceUnavailable); } else if (restRequest == null || callback == null) { throw new IllegalArgumentException("RestRequest or Callback is null"); } <START> callback.onCompletion(null, exception); <END> frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs); }
code_review: this should be before the callback I think
target code: public void postProcessRequest ( RestRequest restRequest , Callback < Void > callback ) { Exception exception = null ; frontendMetrics . securityServicePostProcessRequestRate . mark ( ) ; long startTimeMs = System . currentTimeMillis ( ) ; if ( ! isOpen ) { exception = new RestServiceException ( "SecurityService is closed" , RestServiceErrorCode . ServiceUnavailable ) ; } else if ( restRequest == null || callback == null ) { throw new IllegalArgumentException ( "RestRequest or Callback is null" ) ; } frontendMetrics . securityServicePostProcessRequestTimeInMs . update ( System . currentTimeMillis ( ) - startTimeMs ) ; callback . onCompletion ( null , exception ) ; }
response: public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) { Exception exception = null; frontendMetrics.securityServicePostProcessRequestRate.mark(); long startTimeMs = System.currentTimeMillis(); if (!isOpen) { exception = new RestServiceException("SecurityService is closed", RestServiceErrorCode.ServiceUnavailable); } else if (restRequest == null || callback == null) { throw new IllegalArgumentException("RestRequest or Callback is null"); } <START> frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs); callback.onCompletion(null, exception); <END> }

sample: 1553
buggy_code: <START> private IMethod[] <END> toArray(List<IMethod> methods) { return methods.toArray(new IMethod[methods.size()]); }
code_review: static
target code: private static IMethod [ ] toArray ( List < IMethod > methods ) { return methods . toArray ( new IMethod [ methods . size ( ) ] ) ; }
response: <START> private static IMethod[] <END> toArray(List<IMethod> methods) { return methods.toArray(new IMethod[methods.size()]); }

sample: 1554
buggy_code: public UserProfileParameters() { <START> profile.setId(Guid.newGuid()); <END> }
code_review: update wouldn't work if the id is always a new id setting a new id is the job of add command
target code: public UserProfileParameters ( ) { }
response: public UserProfileParameters() { <START> profile.setId(Guid.newGuid()); <END> }

sample: 1555
buggy_code: public void onActivityPaused(Activity activity) { if (null != mCurInAppNotification) { <START> mCurInAppNotification.dismiss(); <END> } }
code_review: It is safe to call dismiss multiple times, in the source for dismiss(), there's a nice global if check along the lines of (mView != null && isVisible()) or something.
target code: public void onActivityPaused ( Activity activity ) { }
response: public void onActivityPaused(Activity activity) { if (null != mCurInAppNotification) { <START> mCurInAppNotification.dismiss(); <END> } }

sample: 1556
buggy_code: <START> public void createReplyReplyDone() { <END> createButton(buttonparent, buttonReply_ID, buttonReply_caption, true); createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true); buttonBar.pack(); }
code_review: Done
target code: private void createReplyReplyDone ( ) { createButton ( buttonparent , buttonReply_ID , buttonReply_caption , true ) ; createButton ( buttonparent , buttonReplyDone_ID , buttonReplyDone_caption , true ) ; buttonBar . pack ( ) ; }
response: <START> public void createReplyReplyDone() { <END> createButton(buttonparent, buttonReply_ID, buttonReply_caption, true); createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true); buttonBar.pack(); }

sample: 1557
buggy_code: public void noMoreBubble() { config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), "1"); initExecutor(); final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory(); taskFactory.delayMs = 1000; executor.executeOnPartitions(taskFactory, newPartitions()); final DummyOperation op = new DummyOperation(); executor.execute(op); assertTrueEventually(new AssertTask() { @Override public void run() { assertTrue(op.completed); } <START> }, SECONDS.toMillis(5)); <END> }
code_review: `SECONDS.toMillis(5)` -> `5`. Timeout parameter of `assertTrueEventually(..)` is in seconds, not milliseconds.
target code: public void noMoreBubble ( ) { config . setProperty ( PARTITION_OPERATION_THREAD_COUNT . getName ( ) , "1" ) ; initExecutor ( ) ; final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory ( ) ; taskFactory . delayMs = 1000 ; executor . executeOnPartitions ( taskFactory , newPartitions ( ) ) ; final DummyOperation op = new DummyOperation ( ) ; executor . execute ( op ) ; assertTrueEventually ( new AssertTask ( ) { @Override public void run ( ) { assertTrue ( op . completed ) ; } } , 5 ) ; }
response: public void noMoreBubble() { config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), "1"); initExecutor(); final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory(); taskFactory.delayMs = 1000; executor.executeOnPartitions(taskFactory, newPartitions()); final DummyOperation op = new DummyOperation(); executor.execute(op); assertTrueEventually(new AssertTask() { @Override public void run() { assertTrue(op.completed); } <START> }, 5); <END> }

sample: 1558
buggy_code: public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() { CohortMembership cohortMembership = new CohortMembership(12); <START> boolean result = cohortMembership.equals(cohortMembership); <END> assertTrue(result); }
code_review: I guess we could just assert without the temporary variable.
target code: public void equal_shouldReturnTrueIfObjectReferenceAreTheSame ( ) { CohortMembership cohortMembership = new CohortMembership ( 12 ) ; assertTrue ( cohortMembership . equals ( cohortMembership ) ) ; }
response: public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() { CohortMembership cohortMembership = new CohortMembership(12); <START> assertTrue(cohortMembership.equals(cohortMembership)); <END> }

sample: 1559
buggy_code: <START> public DynamicState withPendingLocalization(Future<Void> pendingDownload) { <END> return new DynamicState(this.state, this.newAssignment, this.container, this.currentAssignment, this.pendingLocalization, this.startTime, pendingDownload, this.profileActions, this.pendingStopProfileActions); }
code_review: nit, could return: withPendingLocalization(this.pendingLocalization, pendingDownload);
target code: public DynamicState withPendingLocalization ( Future < Void > pendingDownload ) { return withPendingLocalization ( this . pendingLocalization , pendingDownload ) ; }
response: <START> public DynamicState withPendingLocalization(Future<Void> pendingDownload) { <END> return withPendingLocalization(this.pendingLocalization, pendingDownload); }

sample: 1560
buggy_code: public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) { try { final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password, clientVersionInfo); if (!information.isPresent()) { /* to many bad attempts, otherwise we get an exception */ ModelUtil.logWarning( MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay)); } return <START> information.isPresent(); <END> } catch (final AccessControlException ex) { /* regular bad attempt */ return false; } }
code_review: We could also return true here, which seems to be more obvious to me
target code: public boolean verifyUser ( String username , String password , ESClientVersionInfo clientVersionInfo ) { try { final Optional < ESAuthenticationInformation > information = doVerifyUser ( username , password , clientVersionInfo ) ; if ( ! information . isPresent ( ) ) { /* too many bad attempts , otherwise we get an exception */ ModelUtil . logWarning ( MessageFormat . format ( Messages . LoginService_VerifyUserTooManyFailedRequests , username , delay ) ) ; } return true ; } catch ( final AccessControlException ex ) { /* regular bad attempt */ return false ; } }
response: public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) { try { final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password, clientVersionInfo); if (!information.isPresent()) { /* to many bad attempts, otherwise we get an exception */ ModelUtil.logWarning( MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay)); } return <START> true; <END> } catch (final AccessControlException ex) { /* regular bad attempt */ return false; } }

sample: 1561
buggy_code: public void test() throws Exception { ExternalBuildReport report = new ExternalBuildReport("http://some.url.com"); assertEquals("View External Report", report.getDisplayName()); assertEquals("graph.gif", report.getIconFileName()); <START> assertEquals("graph.gif", report.getIconFileName()); <END> assertEquals("http://some.url.com", report.getUrlName()); assertEquals(null, report.getTarget()); }
code_review: duplicate assert
target code: public void test ( ) throws Exception { ExternalBuildReport report = new ExternalBuildReport ( "http :/ / some . url . com" ) ; assertEquals ( "View External Report" , report . getDisplayName ( ) ) ; assertEquals ( "graph . gif" , report . getIconFileName ( ) ) ; assertEquals ( "http :/ / some . url . com" , report . getUrlName ( ) ) ; assertEquals ( null , report . getTarget ( ) ) ; }
response: public void test() throws Exception { ExternalBuildReport report = new ExternalBuildReport("http://some.url.com"); assertEquals("View External Report", report.getDisplayName()); assertEquals("graph.gif", report.getIconFileName()); <START> assertEquals("http://some.url.com", report.getUrlName()); <END> assertEquals(null, report.getTarget()); }

sample: 1562
buggy_code: public void publishEvent(Object event) { <START> publishEvent(new PayloadApplicationEvent<Object>(null, event)); <END> }
code_review: The null `source` looks odd.
target code: public void publishEvent ( Object event ) { publishEvent ( new PayloadApplicationEvent < > ( this , event ) ) ; }
response: public void publishEvent(Object event) { <START> publishEvent(new PayloadApplicationEvent<Object>(this, event)); <END> }

sample: 1563
buggy_code: public boolean isList() { <START> if (isProperty) <END> return prop.isList(); else return false; }
code_review: Personally for all these simple things, I would simple it down to a ternary operation for code simplicity. Always keep in mind code size.
target code: public boolean isList ( ) { return isProperty && prop . isList ( ) ; }
response: public boolean isList() { <START> return isProperty ? prop.isList() : false; <END> }

sample: 1564
buggy_code: private GlusterGeoRepSession getGeoRepSession() { if (getParameters().getGeoRepSessionId() != null) { return geoRepDao.getById(getParameters().getGeoRepSessionId()); } <START> return null; <END> }
code_review: I don't think we need this check nor this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) when needed, if getParameters().getGeoRepSessionId() we will simply won't get any result
target code: private GlusterGeoRepSession getGeoRepSession ( ) { return geoRepDao . getById ( getParameters ( ) . getGeoRepSessionId ( ) ) ; }
response: private GlusterGeoRepSession getGeoRepSession() { return geoRepDao.getById(getParameters().getGeoRepSessionId()); }

sample: 1565
buggy_code: protected Statement createFailOnTimeoutStatement( <START> Statement statement, Description description) throws Exception { <END> return FailOnTimeout.builder() .withTimeout(timeout, timeUnit) .withLookingForStuckThread(lookForStuckThread) .withDescription(description) .build(statement); }
code_review: Unfortunately this method is protected. Changing the signature may break someone. @junit-team/junit-committers how should we handle this? We could not add the new feature without breaking the extension point. I'm in favour of modifying the methods signature and making it private. Users should create a new rule instead of extending Timeout. They could use the builder for creating the statement.
target code: private Statement createFailOnTimeoutStatement ( Statement statement , Description description ) throws Exception { return FailOnTimeout . builder ( ) . withDescription ( description ) . build ( createFailOnTimeoutStatement ( statement ) ) ; }
response: private Statement createFailOnTimeoutStatement( <START> Statement statement, Description description) throws Exception { <END> return FailOnTimeout.builder() .withTimeout(timeout, timeUnit) .withLookingForStuckThread(lookForStuckThread) .withDescription(description) .build(statement); }

sample: 1566
buggy_code: @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator( IntIterator stops ) { Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); int stopIndex = stops.next(); while (stopIndex > 0) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stopIndex)); stopIndex = stops.next(); } <START> return activeTripPatternsForGivenStops.iterator(); <END> }
code_review: The loop fails if `stops` contains _the first_ stop (`0`). The method should be: ``` Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); while (stops.hasNext()) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next())); } return activeTripPatternsForGivenStops.iterator(); ```
target code: @Override public Iterator < ? extends TripPatternInfo < TripSchedule > > patternIterator ( IntIterator stops ) { Set < TripPatternInfo < TripSchedule > > activeTripPatternsForGivenStops = new HashSet < > ( ) ; while ( stops . hasNext ( ) ) { activeTripPatternsForGivenStops . addAll ( activeTripPatternsPerStop . get ( stops . next ( ) ) ) ; } return activeTripPatternsForGivenStops . iterator ( ) ; }
response: @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator( IntIterator stops ) { Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); <START> while (stops.hasNext()) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next())); } <END> return activeTripPatternsForGivenStops.iterator(); }

sample: 1567
buggy_code: public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) { this.context = context; this.type = type; <START> this.qualifiers = asSet(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE); <END> this.qualifiers.addAll(qualifiers); }
code_review: This is likely unnecessary. The set of qualifiers is expected to contain all elements. See also `org.jboss.weld.bootstrap.WeldStartup.createContexts(ServiceRegistry)` and other places where this constructor is used.
target code: public ContextHolder ( T context , Class < T > type , Set < Annotation > qualifiers ) { this . context = context ; this . type = type ; this . qualifiers = qualifiers ; }
response: public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) { this.context = context; this.type = type; <START> this.qualifiers = qualifiers; <END> this.qualifiers.addAll(qualifiers); }

sample: 1568
buggy_code: public void setUp() { <START> jenkins.CLI.get().setEnabled(true); <END> Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols()); agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName()); j.jenkins.setAgentProtocols(agentProtocols); }
code_review: Unnecessary; it is still enabled by default in core, disabled in wizard.
target code: public void setUp ( ) { Set < String > agentProtocols = new HashSet < > ( j . jenkins . getAgentProtocols ( ) ) ; agentProtocols . add ( ExtensionList . lookupSingleton ( CliProtocol2 . class ) . getName ( ) ) ; j . jenkins . setAgentProtocols ( agentProtocols ) ; }
response: public void setUp() { Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols()); agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName()); j.jenkins.setAgentProtocols(agentProtocols); }

sample: 1569
buggy_code: public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = <START> 1; <END> }
code_review: There is a lack of symmetry here. `positionGap` should be initialized in both ctors.
target code: public FieldWrapper ( HighlightExecutionContext executionContext , HighlighterContext context , BasicQueryWeigher weigher ) { this . executionContext = executionContext ; this . context = context ; this . weigher = weigher ; }
response: public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = <START> 1; <END> } public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher, int positionGap) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = positionGap; }

sample: 1570
buggy_code: public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups) { this.streams = ImmutableList.copyOf(requireNonNull(streams, "streams is null")); this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, "columnEncodings is null")); <START> this.stripeEncryptionGroups = requireNonNull(stripeEncryptionGroups, "stripeEncryptionGroups is null"); <END> }
code_review: `ImmutableList.copyOf`
target code: public StripeFooter ( List < Stream > streams , List < ColumnEncoding > columnEncodings , List < Slice > stripeEncryptionGroups ) { this . streams = ImmutableList . copyOf ( requireNonNull ( streams , "streams is null" ) ) ; this . columnEncodings = ImmutableList . copyOf ( requireNonNull ( columnEncodings , "columnEncodings is null" ) ) ; this . stripeEncryptionGroups = ImmutableList . copyOf ( requireNonNull ( stripeEncryptionGroups , "stripeEncryptionGroups is null" ) ) ; }
response: public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups) { this.streams = ImmutableList.copyOf(requireNonNull(streams, "streams is null")); this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, "columnEncodings is null")); <START> this.stripeEncryptionGroups = ImmutableList.copyOf(requireNonNull(stripeEncryptionGroups, "stripeEncryptionGroups is null")); <END> }

sample: 1571
buggy_code: public Double getValue() { //do not miss the last tuple try { <START> estimator.accumulate(cx); <END> } catch (ExecException ex) { throw new RuntimeException("Error while accumulating sample frequency: " + ex); } return estimator.getEntropy(); }
code_review: i'm not sure how getValue() is supposed to be called, but I would make it work correctly even if it is called twice. that is, set cx back to zero after you accumulate.
target code: public Double getValue ( ) { // do not miss the last tuple try { this . estimator . accumulate ( this . cx ) ; } catch ( ExecException ex ) { throw new RuntimeException ( "Error while accumulating sample frequency : " + ex ) ; } return this . estimator . getEntropy ( ) ; }
response: public Double getValue() { //do not miss the last tuple try { <START> estimator.accumulate(cx); cx = 0; <END> } catch (ExecException ex) { throw new RuntimeException("Error while accumulating sample frequency: " + ex); } return estimator.getEntropy(); }

sample: 1572
buggy_code: private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) { boolean result = true; ResultSet rs = null; try { rs = metaData.getSchemas(); while (rs.next() && result) { result = false; } } catch (SQLException e) { throw JdbcUtils.wrapException(e, "retrieve schema and catalog metadata", JdbcActionType.METADATA); } finally { FileHelper.safeClose(rs); <START> close(null); <END> } return result; }
code_review: Hmm I think we should remove this line. Seems like it's not needed since `close(null)` will just do nothing. Maybe it's a left-over line from some previous version of the file where the result set got closed properly or something :-)
target code: private boolean usesCatalogsAsSchemas ( DatabaseMetaData metaData ) { boolean result = true ; ResultSet rs = null ; try { rs = metaData . getSchemas ( ) ; while ( rs . next ( ) && result ) { result = false ; } } catch ( SQLException e ) { throw JdbcUtils . wrapException ( e , "retrieve schema and catalog metadata" , JdbcActionType . METADATA ) ; } finally { FileHelper . safeClose ( rs ) ; } return result ; }
response: private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) { boolean result = true; ResultSet rs = null; try { rs = metaData.getSchemas(); while (rs.next() && result) { result = false; } } catch (SQLException e) { throw JdbcUtils.wrapException(e, "retrieve schema and catalog metadata", JdbcActionType.METADATA); } finally { FileHelper.safeClose(rs); <START> close(null); <END> } return result; }

sample: 1573
buggy_code: public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) { if (!event.isPre()) { emitSessionDestroyedEvent((String) event.getKey()); } <START> } <END>
code_review: those `if (!event.isPre())` can be avoided by adding `@Listener(observation = Observation.POST)` at class level
target code: public void processCacheEntryDestroyed ( CacheEntryRemovedEvent event ) { emitSessionDestroyedEvent ( ( String ) event . getKey ( ) ) ; }
response: public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) { emitSessionDestroyedEvent((String) event.getKey()); <START> } <END>

sample: 1574
buggy_code: public void invalidate(@Nullable String path) { if (path == null) { <START> return; <END> } invalidate(Uri.parse(path)); }
code_review: Flip the `if` and move the invalidate call up inside
target code: public void invalidate ( @Nullable String path ) { if ( path != null ) { invalidate ( Uri . parse ( path ) ) ; } }
response: public void invalidate(@Nullable String path) { if (path != null) { invalidate(Uri.parse(path)); } <START> return; <END> }

sample: 1575
buggy_code: public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null && disconnectableRegisterer == null) { return this.withConnectableCallbacks().withDisconnectableCallbacks(); } else if (connectableRegisterer == null) { return this.withConnectableCallbacks(); } else if (disconnectableRegisterer == null) { return this.withDisconnectableCallbacks(); } <START> return this; <END> }
code_review: could this block be simplified? ``` java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; } ```
target code: public MerlinBuilder withRxCallbacks ( ) { rxCallbacksManager = new RxCallbacksManager ( ) ; if ( connectableRegisterer == null ) { withConnectableCallbacks ( ) ; } if ( disconnectableRegisterer == null ) { withDisconnectableCallbacks ( ) ; } return this ; }
response: public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } <START> return this; <END> }

sample: 1576
buggy_code: public static String localizeProvider(String name) { if (name==null) { Assert.isTrue(false); return null; <START> } <END> switch (name) { case DIRECT_PROVIDER: return Messages.ProxySelector_0; case ECLIPSE_PROVIDER: return Messages.ProxySelector_1; case NATIVE_PROVIDER: return Messages.ProxySelector_2; default: break; } Assert.isTrue(false); return null; }
code_review: I don't like this code duplication. How about if (name != null) { switch (name) { ... } } Assert.isTrue(false); return null;
target code: public static String localizeProvider ( String name ) { if ( name != null ) { switch ( name ) { case DIRECT_PROVIDER : return Messages . ProxySelector_0 ; case ECLIPSE_PROVIDER : return Messages . ProxySelector_1 ; case NATIVE_PROVIDER : return Messages . ProxySelector_2 ; default : break ; } } Assert . isTrue ( false ) ; return null ; }
response: public static String localizeProvider(String name) { if (name==null) { Assert.isTrue(false); return null; } switch (name) { case DIRECT_PROVIDER: return Messages.ProxySelector_0; case ECLIPSE_PROVIDER: return Messages.ProxySelector_1; case NATIVE_PROVIDER: return Messages.ProxySelector_2; default: break; } Assert.isTrue(false); return null; }

sample: 1577
buggy_code: <START> public String removeSuffix(String loaderFileName, char suffixTerm) { <END> return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm)); }
code_review: Does this need to be public?
target code: private String removeSuffix ( String loaderFileName , char suffixTerm ) { return loaderFileName . substring ( 0 , loaderFileName . lastIndexOf ( suffixTerm ) ) ; }
response: <START> String removeSuffix(String loaderFileName, char suffixTerm) { <END> return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm)); }

sample: 1578
buggy_code: private BootstrapConfigurationImpl() { this.defaultProviderClassName = null; this.constraintValidatorFactoryClassName = null; this.messageInterpolatorClassName = null; this.traversableResolverClassName = null; this.parameterNameProviderClassName = null; this.clockProviderClassName = null; <START> this.valueExtractorClassNames = new HashSet<>( 0 ); <END> this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES; this.isExecutableValidationEnabled = true; this.constraintMappingResourcePaths = newHashSet(); this.properties = newHashMap(); }
code_review: Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
target code: private BootstrapConfigurationImpl ( ) { this . defaultProviderClassName = null ; this . constraintValidatorFactoryClassName = null ; this . messageInterpolatorClassName = null ; this . traversableResolverClassName = null ; this . parameterNameProviderClassName = null ; this . clockProviderClassName = null ; this . valueExtractorClassNames = new HashSet < > ( ) ; this . validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES ; this . isExecutableValidationEnabled = true ; this . constraintMappingResourcePaths = new HashSet < > ( ) ; this . properties = new HashMap < > ( ) ; }
response: private BootstrapConfigurationImpl() { this.defaultProviderClassName = null; this.constraintValidatorFactoryClassName = null; this.messageInterpolatorClassName = null; this.traversableResolverClassName = null; this.parameterNameProviderClassName = null; this.clockProviderClassName = null; <START> this.valueExtractorClassNames = newHashSet(); <END> this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES; this.isExecutableValidationEnabled = true; this.constraintMappingResourcePaths = newHashSet(); this.properties = newHashMap(); }

sample: 1579
buggy_code: public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException { file.getParentFile().mkdirs(); try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) { ByteStreams.copy(is, os); } finally { CloseQuietly.close(is); } <START> return FileUtils.FileCopyResult.buildResult(file.toPath()); <END> }
code_review: I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions.
target code: public static long copyToFileAndClose ( InputStream is , File file ) throws IOException { file . getParentFile ( ) . mkdirs ( ) ; try ( OutputStream os = new BufferedOutputStream ( new FileOutputStream ( file ) ) ) { return ByteStreams . copy ( is , os ) ; } finally { CloseQuietly . close ( is ) ; } }
response: public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException { file.getParentFile().mkdirs(); try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) { ByteStreams.copy(is, os); } finally { CloseQuietly.close(is); } <START> return FileUtils.FileCopyResult.buildResult(file.toPath()); <END> }

sample: 1580
buggy_code: <START> @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) { <END> return canceled.compareAndSet( false, true ); }
code_review: If you are using an AtomicBoolean (and dont do anything else), you no longer need the synchronized keyword here.
target code: @Override public boolean cancel ( final boolean mayInterruptIfRunning ) { return canceled . compareAndSet ( false , true ) ; }
response: <START> @Override public boolean cancel( final boolean mayInterruptIfRunning ) { <END> return canceled.compareAndSet( false, true ); }

sample: 1581
buggy_code: protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) { return items .entrySet() .stream() .filter(e -> e.getKey().equals(command)) .findFirst() .orElse(null) <START> .getValue(); <END> }
code_review: hey @manstis , quick looking at this seems that a potential NPE can be produced here? I mean for `orElse(null).getValue()`?
target code: protected AbstractToolbarItem < S > getItem ( final ToolbarCommand < ? > command ) { return items . entrySet ( ) . stream ( ) . filter ( e - > e . getKey ( ) . equals ( command ) ) . findFirst ( ) . map ( Map . Entry : : getValue ) . orElse ( null ) ; }
response: protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) { return items .entrySet() .stream() .filter(e -> e.getKey().equals(command)) .findFirst() .orElse(null) .getValue(); }

sample: 1582
buggy_code: public CellIdentityCdma() { <START> super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, <END> null, null); mNetworkId = Integer.MAX_VALUE; mSystemId = Integer.MAX_VALUE; mBasestationId = Integer.MAX_VALUE; mLongitude = Integer.MAX_VALUE; mLatitude = Integer.MAX_VALUE; mAlphaLong = null; mAlphaShort = null; }
code_review: TAG
target code: public CellIdentityCdma ( ) { super ( TAG , TYPE_CDMA , null , null ) ; mNetworkId = Integer . MAX_VALUE ; mSystemId = Integer . MAX_VALUE ; mBasestationId = Integer . MAX_VALUE ; mLongitude = Integer . MAX_VALUE ; mLatitude = Integer . MAX_VALUE ; mAlphaLong = null ; mAlphaShort = null ; }
response: public CellIdentityCdma() { <START> super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, <END> null, null); mNetworkId = Integer.MAX_VALUE; mSystemId = Integer.MAX_VALUE; mBasestationId = Integer.MAX_VALUE; mLongitude = Integer.MAX_VALUE; mLatitude = Integer.MAX_VALUE; mAlphaLong = null; mAlphaShort = null; } <REVIEW>

sample: 1583
buggy_code: private void header(@NonNull final BecauseYouReadCard card) { CardLargeHeaderView header = new CardLargeHeaderView(getContext()) .setTitle(card.title()) .setSubtitle(card.subtitle()) <START> .setPageTitle(card.pageTitle().getDisplayText()) <END> .setImage(card.image()); header(header); }
code_review: Would encapsulating the underlying implementation of BecauseYouReadCard be better or do we need the PageTitle elsewhere? I'm thinking of my recent PageTitle.getText() bug where I meant to call getDisplayText(). At least the bug could only live in one place. If we expose a large object like PageTitle, we have lots of flexibility to do things beyond what a Card is really meant for. There's some notes on some of the tradeoffs here: https://en.wikipedia.org/wiki/Law_of_Demeter.
target code: private void header ( @NonNull final BecauseYouReadCard card ) { CardLargeHeaderView header = new CardLargeHeaderView ( getContext ( ) ) . setTitle ( card . title ( ) ) . setSubtitle ( card . subtitle ( ) ) . setPageTitle ( card . pageTitle ( ) ) . setImage ( card . image ( ) ) ; header ( header ) ; }
response: private void header(@NonNull final BecauseYouReadCard card) { CardLargeHeaderView header = new CardLargeHeaderView(getContext()) .setTitle(card.title()) .setSubtitle(card.subtitle()) <START> .setPageTitle(card.getPageTitle()) <END> .setImage(card.image()); header(header); }

sample: 1584
buggy_code: private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS; try { <START> checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString())); <END> } catch (NumberFormatException e) { log.warn(String.format("Invalid format for %s parameter, using default value instead", PARAM_MONGODB_CHECK_TIMEOUT), e); } return checkTimeout; }
code_review: `DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString()` -> `String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS)` now that it's an `int`
target code: private int getCheckTimeoutInSeconds ( ConfigurationGenerator cg ) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS ; try { checkTimeout = Integer . parseInt ( cg . getUserConfig ( ) . getProperty ( PARAM_MONGODB_CHECK_TIMEOUT , String . valueOf ( DEFAULT_CHECK_TIMEOUT_IN_SECONDS ) ) ) ; } catch ( NumberFormatException e ) { log . warn ( String . format ( "Invalid format for % s parameter , using default value instead" , PARAM_MONGODB_CHECK_TIMEOUT ) , e ) ; } return checkTimeout ; }
response: private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS; try { <START> checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS))); <END> } catch (NumberFormatException e) { log.warn(String.format("Invalid format for %s parameter, using default value instead", PARAM_MONGODB_CHECK_TIMEOUT), e); } return checkTimeout; }

sample: 1585
buggy_code: private void closeConnection(String deviceId) { DeviceConfig device = deviceConfigCache.get(deviceId); if (device == null) { <START> logger.error("Could not find device '{}'", deviceId); <END> return; } EpsonProjectorDevice remoteController = device.getConnection(); if (remoteController != null) { try { logger.debug("Closing connection to device '{}' ", deviceId); remoteController.disconnect(); } catch (EpsonProjectorException e) { logger.debug("Error occurred when closing connection to device '{}'", deviceId); } } }
code_review: This should be a WARN instead of an ERROR.
target code: private void closeConnection ( String deviceId ) { DeviceConfig device = deviceConfigCache . get ( deviceId ) ; if ( device == null ) { logger . warn ( "Could not find device ' { } '" , deviceId ) ; return ; } EpsonProjectorDevice remoteController = device . getConnection ( ) ; if ( remoteController != null ) { try { logger . debug ( "Closing connection to device ' { } ' " , deviceId ) ; remoteController . disconnect ( ) ; } catch ( EpsonProjectorException e ) { logger . debug ( "Error occurred when closing connection to device ' { } '" , deviceId ) ; } } }
response: private void closeConnection(String deviceId) { DeviceConfig device = deviceConfigCache.get(deviceId); if (device == null) { <START> logger.warn("Could not find device '{}'", deviceId); <END> return; } EpsonProjectorDevice remoteController = device.getConnection(); if (remoteController != null) { try { logger.debug("Closing connection to device '{}' ", deviceId); remoteController.disconnect(); } catch (EpsonProjectorException e) { logger.debug("Error occurred when closing connection to device '{}'", deviceId); } } }

sample: 1586
buggy_code: public void testSimpleAnnotation() { assertGeneratedMatches( <START> Lists.newArrayList("import javax.annotation.Nullable;"), <END> Lists.newArrayList("@Nullable"), Lists.newArrayList("@javax.annotation.Nullable")); }
code_review: I'd prefer ImmutableList.of throughout.
target code: public void testSimpleAnnotation ( ) { assertGeneratedMatches ( ImmutableList . of ( "import javax . annotation . Nullable ; " ) , ImmutableList . of ( "@Nullable" ) , ImmutableList . of ( "@javax . annotation . Nullable" ) ) ; }
response: public void testSimpleAnnotation() { assertGeneratedMatches( <START> ImmutableList.of("import javax.annotation.Nullable;"), <END> ImmutableList.of("@Nullable"), ImmutableList.of("@javax.annotation.Nullable")); }

sample: 1587
buggy_code: public void testUnionPointWithEmptyLineString() { <START> assertUnion("POINT (1 2)", "LINESTRING EMPTY", "GEOMETRYCOLLECTION (POINT (1 2))"); <END> }
code_review: I'd expect the union of `POINT (1, 2)` and `LINESTRING EMPTY` to be `POINT (1, 2)`, but this test asserts the result to be `GEOMETRYCOLLECTION (POINT (1 2))`.
target code: public void testUnionPointWithEmptyLineString ( ) { assertUnion ( "POINT ( 1 2 ) " , "LINESTRING EMPTY" , "POINT ( 1 2 ) " ) ; }
response: public void testUnionPointWithEmptyLineString() { <START> assertUnion("POINT (1 2)", "LINESTRING EMPTY", "POINT (1 2)"); <END> }

sample: 1588
buggy_code: <START> public Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) <END> { super(entity, entityRenderer, x, y, z); this.layerRenderer = layerRenderer; }
code_review: protected?
target code: protected Layers ( EntityLivingBase entity , RenderLivingBase < T > entityRenderer , LayerRenderer < T > layerRenderer , double x , double y , double z ) { super ( entity , entityRenderer , x , y , z ) ; this . layerRenderer = layerRenderer ; }
response: <START> protected Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) <END> { super(entity, entityRenderer, x, y, z); this.layerRenderer = layerRenderer; }

sample: 1589
buggy_code: public void deleteOldDeployments(final IServer server) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder(); Arrays.stream(server.getModules()) <START> .forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); <END> }
code_review: Seems the output name cache should be reset here, not below.
target code: public void deleteOldDeployments ( final IServer server ) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder ( ) ; Arrays . stream ( server . getModules ( ) ) . forEach ( module - > deleteOldDeployment ( module , deploymentsRootFolder , server ) ) ; }
response: public void deleteOldDeployments(final IServer server) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder(); Arrays.stream(server.getModules()) <START> .forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); <END> }

sample: 1590
buggy_code: public CronTab(String format, int line, Hash hash) throws ANTLRException { <START> set(format, line, hash); <END> }
code_review: I would recommend to use <code>this()</code> in this constructor
target code: public CronTab ( String format , int line , Hash hash ) throws ANTLRException { this ( format , line , hash , null ) ; }
response: public CronTab(String format, int line, Hash hash) throws ANTLRException { <START> this(format, line, hash); <END> }

sample: 1591
buggy_code: public boolean isKeyFrame(byte[] buff, int off, int len) { <START> if (buff == null || len < 1 || buff.length < len) <END> { return false; } int nalType = buff[off] & kTypeMask; // Single NAL Unit Packet if (nalType == kFuA) { // Fragmented NAL units (FU-A). if (parseFuaNaluForKeyFrame(buff, off, len)) { return true; } } else { if (parseSingleNaluForKeyFrame(buff, off, len)) { return true; } } return false; }
code_review: @mdaneshi, do you think it would make sense to have something like this in every static methods that you wrote? ``` if (buf == null || Math.min(buf.length, len) < off + 1 /* required array length for this method to work correctly */) { return false; } ``` I know this is not a common practice currently in libjitsi and we sometimes are a little sloppy when we access arrays, but I believe we should change this and write more defensive code whenever possible.
target code: public static boolean isKeyFrame ( byte [ ] buff , int off , int len ) { if ( buff == null || buff . length < off + Math . max ( len , 1 ) ) { return false ; } int nalType = buff [ off ] & kTypeMask ; // Single NAL Unit Packet if ( nalType == kFuA ) { // Fragmented NAL units ( FU - A ) . if ( parseFuaNaluForKeyFrame ( buff , off , len ) ) { return true ; } } else { if ( parseSingleNaluForKeyFrame ( buff , off , len ) ) { return true ; } } return false ; }
response: public boolean isKeyFrame(byte[] buff, int off, int len) { <START> if (buff == null || len < 1 || buff.length < len) <END> { return false; } int nalType = buff[off] & kTypeMask; // Single NAL Unit Packet if (nalType == kFuA) { // Fragmented NAL units (FU-A). if (parseFuaNaluForKeyFrame(buff, off, len)) { return true; } } else { if (parseSingleNaluForKeyFrame(buff, off, len)) { return true; } } return false; }

sample: 1592
buggy_code: <START> public ResponseEntity<?> delete(@RequestBody List<Long> printerIds) throws IOException { <END> for (long id : printerIds) { Printer printer = printerService.get(id); if (printer != null) { printerService.remove(printer); } } return new ResponseEntity<>(HttpStatus.OK); }
code_review: `@ResponseStatus(HttpStatus.NO_RESPONSE)` Then you can change return type to void and remove the return statement
target code: public void delete ( @RequestBody List < Long > printerIds ) throws IOException { for ( long id : printerIds ) { Printer printer = printerService . get ( id ) ; if ( printer != null ) { printerService . remove ( printer ) ; } } }
response: <START> @ResponseStatus(HttpStatus.NO_RESPONSE) public void delete(@RequestBody List<Long> printerIds) throws IOException { <END> for (long id : printerIds) { Printer printer = printerService.get(id); if (printer != null) { printerService.remove(printer); } } }

sample: 1593
buggy_code: public DiskWriteModel getDisk(int deviceId) { return fDisks.computeIfAbsent(deviceId, k -> new <START> DiskWriteModel(deviceId, checkNotNull(getStateSystemBuilder()))); <END> }
code_review: Use k, like you did in the other files
target code: public DiskWriteModel getDisk ( int deviceId ) { return fDisks . computeIfAbsent ( deviceId , k - > new DiskWriteModel ( k , checkNotNull ( getStateSystemBuilder ( ) ) ) ) ; }
response: public DiskWriteModel getDisk(int deviceId) { return fDisks.computeIfAbsent(deviceId, k -> new <START> DiskWriteModel(k, checkNotNull(getStateSystemBuilder()))); <END> }

sample: 1594
buggy_code: public void testIsConditionValidWhenHeaderIsValid() throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52("header1"); final ConditionCol52 conditionCol2 = fakeConditionCol52("header2"); final Validator validator = new Validator(fakeCompositeColumn(conditionCol1, conditionCol2)); <START> assertFalse(validator.isConditionValid(conditionCol2)); <END> }
code_review: In the context of GUVNOR-2821 I would expect `assertTrue` here, can you please update the `fakeConditionCol52` method to achieve this? Let me know if you don't see my point.
target code: public void testIsConditionValidWhenHeaderIsValid ( ) throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52 ( "header1" ) ; final ConditionCol52 conditionCol2 = fakeConditionCol52 ( "header2" ) ; final Validator validator = new Validator ( fakeCompositeColumn ( conditionCol1 , conditionCol2 ) ) ; assertTrue ( validator . isConditionValid ( conditionCol2 ) ) ; }
response: public void testIsConditionValidWhenHeaderIsValid() throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52("header1"); final ConditionCol52 conditionCol2 = fakeConditionCol52("header2"); final Validator validator = new Validator(fakeCompositeColumn(conditionCol1, conditionCol2)); <START> assertTrue(validator.isConditionValid(conditionCol2)); <END> }

sample: 1595
buggy_code: public StatsManagerMetrics(MetricRegistry registry) { <START> this.registry = registry; <END> statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, "StatsPublishFailureCount")); totalFetchAndAggregateTime = registry.histogram(MetricRegistry.name(StatsManager.class, "TotalFetchAndAggregateTime")); fetchAndAggregateTimePerStore = registry.histogram(MetricRegistry.name(StatsManager.class, "FetchAndAggregateTimePerStore")); }
code_review: does this need to be a class member?
target code: public StatsManagerMetrics ( MetricRegistry registry ) { statsPublishFailureCount = registry . counter ( MetricRegistry . name ( StatsManager . class , "StatsPublishFailureCount" ) ) ; totalFetchAndAggregateTime = registry . histogram ( MetricRegistry . name ( StatsManager . class , "TotalFetchAndAggregateTime" ) ) ; fetchAndAggregateTimePerStore = registry . histogram ( MetricRegistry . name ( StatsManager . class , "FetchAndAggregateTimePerStore" ) ) ; }
response: public StatsManagerMetrics(MetricRegistry registry) { <START> this.registry = registry; <END> statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, "StatsPublishFailureCount")); totalFetchAndAggregateTime = registry.histogram(MetricRegistry.name(StatsManager.class, "TotalFetchAndAggregateTime")); fetchAndAggregateTimePerStore = registry.histogram(MetricRegistry.name(StatsManager.class, "FetchAndAggregateTimePerStore")); }

sample: 1596
buggy_code: BlobStatus(List<String> replicaList) { if (replicaList != null && replicaList.size() > 0) { unavailable.addAll(replicaList); } <START> } <END>
code_review: minor: the `replicaList.size() > 0` check isn't really needed
target code: BlobStatus ( List < String > replicaList ) { if ( replicaList != null ) { unavailable . addAll ( replicaList ) ; } }
response: BlobStatus(List<String> replicaList) { if (replicaList != null) { unavailable.addAll(replicaList); } <START> } <END>

sample: 1597
buggy_code: <START> protected MemcachedClientCallback createMemcachedClientCallback() { <END> return new MemcachedClientCallback() { @Override public byte[] get(final String key) throws IOException { return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key )); } }; }
code_review: MemcachedClientCallback should be renamed to StorageClientCallback
target code: protected MemcachedClientCallback createMemcachedClientCallback ( ) { return new MemcachedClientCallback ( ) { @Override public byte [ ] get ( final String key ) { return _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; } } ; }
response: <START> protected StorageClientCallback createMemcachedClientCallback() { <END> return new StorageClientCallback() { @Override public byte[] get(final String key) throws IOException { return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key )); } }; }

sample: 1598
buggy_code: public void clientId() throws IOException { <START> Stripe.clientId = "ca_test"; <END> chargeBody = resource("charge.json"); }
code_review: Your tests don't rely on `Stripe.clientId` at all, so you should remove this line, rename the method, and get rid of `tearDownMockAndClientId()` entirely.
target code: public void clientId ( ) throws IOException { chargeBody = resource ( "charge . json" ) ; }
response: public void setUp() throws IOException { <START> chargeBody = resource("charge.json"); <END> }

sample: 1599
buggy_code: private XADataSource createXaDataSourceInstance(String className) { try { Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader()); Object instance = BeanUtils.instantiate(dataSourceClass); Assert.isInstanceOf(XADataSource.class, instance); return (XADataSource) instance; } catch (Exception ex) { throw new IllegalStateException( <START> "Unable to create XADataSource instance from '" + className + "'"); <END> } }
code_review: Maybe it would be good to include the causing exception so user knows why it couldn't be created.
target code: private XADataSource createXaDataSourceInstance ( String className ) { try { Class < ? > dataSourceClass = ClassUtils . forName ( className , this . getClass ( ) . getClassLoader ( ) ) ; Object instance = BeanUtils . instantiate ( dataSourceClass ) ; Assert . isInstanceOf ( XADataSource . class , instance ) ; return ( XADataSource ) instance ; } catch ( Exception ex ) { throw new IllegalStateException ( "Unable to create XADataSource instance from '" + className + "'" , ex ) ; } }
response: private XADataSource createXaDataSourceInstance(String className) { try { Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader()); Object instance = BeanUtils.instantiate(dataSourceClass); Assert.isInstanceOf(XADataSource.class, instance); return (XADataSource) instance; } catch (Exception ex) { throw new IllegalStateException( <START> "Unable to create XADataSource instance from '" + className + "'", ex); <END> } }

sample: 1600
buggy_code: protected Optional<ExampleProjectError> getError(Path projectPath) { POM pom = this.getPom(pomService, projectPath); <START> if (pom.getModules().isEmpty() || pom.getModules() == null) { <END> return Optional.empty(); } else { return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(), "")); } }
code_review: You need to swap the order of nullcheck / isEmpty, otherwise it will lead to NPE (if getModules returns null, not sure that's possible) and this validator will fail.
target code: protected Optional < ExampleProjectError > getError ( Path projectPath ) { POM pom = this . getPom ( pomService , projectPath ) ; if ( pom . getModules ( ) == null || pom . getModules ( ) . isEmpty ( ) ) { return Optional . empty ( ) ; } else { return Optional . of ( new ExampleProjectError ( CheckModulesValidator . class . getCanonicalName ( ) , "" ) ) ; } }
response: protected Optional<ExampleProjectError> getError(Path projectPath) { POM pom = this.getPom(pomService, projectPath); <START> if (pom.getModules() == null || pom.getModules().isEmpty()) { <END> return Optional.empty(); } else { return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(), "")); } }

sample: 1601
buggy_code: public boolean isOpen() { <START> return mBaseTransport.isOpen() && mTransport != null && mTransport.isOpen(); <END> }
code_review: When is `mTransport == null`? Isn't it always set to something in `open()`? Also, why do you need to check `mBaseTransport`?
target code: public boolean isOpen ( ) { return mTransport != null && mTransport . isOpen ( ) ; }
response: public boolean isOpen() { <START> return mTransport != null && mTransport.isOpen(); <END> }

sample: 1602
buggy_code: public static void restoreSystemProperties() { System.clearProperty("org.uberfire.nio.git.daemon.enabled"); <START> System.clearProperty("org.uberfire.nio.git.ssh.enabled"); <END> System.clearProperty("org.uberfire.sys.repo.monitor.disabled"); }
code_review: why enabled? why restore those?
target code: public static void restoreSystemProperties ( ) { System . clearProperty ( "org . uberfire . sys . repo . monitor . disabled" ) ; System . clearProperty ( "org . uberfire . nio . git . daemon . enabled" ) ; System . clearProperty ( "org . uberfire . nio . git . ssh . enabled" ) ; System . clearProperty ( "org . uberfire . sys . repo . monitor . disabled" ) ; }
response: public static void restoreSystemProperties() { System.clearProperty("org.uberfire.nio.git.daemon.enabled"); System.clearProperty("org.uberfire.nio.git.ssh.enabled"); System.clearProperty("org.uberfire.sys.repo.monitor.disabled"); }

sample: 1603
buggy_code: protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id, Patch patch) throws AuthorizeException, SQLException { final Group group = dsoService.find(context, id); if (group != null && isPatchUnprocessable(context, group)) { <START> throw new UnprocessableEntityException("This group cannot be patched."); <END> } patchDSpaceObject(apiCategory, model, id, patch); }
code_review: I'd rather see more specific error messages here, as there's a few different scenarios here we should be aware of: * A permanent group's name can *never* be patched. But, its description can be updated. * Same with a Community/Collection group's name (not editable) & description (editable), unless it's detached. In which case it can be patched. So, at a minimum, it seems like we need different errors & checks here. Permanent groups can *never* have name updates, but can have description updates. Community/Collection groups can be updated if the Community/Collection is deleted, but are otherwise considered "permanent".
target code: protected void patch ( Context context , HttpServletRequest request , String apiCategory , String model , UUID id , Patch patch ) throws AuthorizeException , SQLException { patchDSpaceObject ( apiCategory , model , id , patch ) ; }
response: protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id, Patch patch) throws AuthorizeException, SQLException { final Group group = dsoService.find(context, id); if (group != null && isPatchUnprocessable(context, group)) { <START> throw new UnprocessableEntityException("This group cannot be patched."); <END> } patchDSpaceObject(apiCategory, model, id, patch); }

sample: 1604
buggy_code: protected String computeMetricName(Message<?> message) { <START> String counterName = nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); <END> return counterName; }
code_review: no need to assign to counterName just to return on next line. However, we probably should add a null check for the evaluationContext.
target code: protected String computeMetricName ( Message < ? > message ) { return nameExpression . getValue ( evaluationContext , message , CharSequence . class ) . toString ( ) ; }
response: protected String computeMetricName(Message<?> message) { <START> return nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); <END> }

sample: 1605
buggy_code: public boolean supportsBitmapIndex(final BitmapIndexSelector selector) { // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has // an index and does not have multiple values. The lack of multiple values is important because expression // filters treat multi-value arrays as nulls, which doesn't permit index based filtering. <START> return requiredBindings.isEmpty() <END> || (requiredBindings.size() == 1 && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings))); }
code_review: Could you break this statement into multiple for readability?
target code: public boolean supportsBitmapIndex ( final BitmapIndexSelector selector ) { if ( requiredBindings . isEmpty ( ) ) { // Constant expression . return true ; } else if ( requiredBindings . size ( ) == 1 ) { // Single - column expression . We can use bitmap indexes if this column has an index and does not have // multiple values . The lack of multiple values is important because expression filters treat multi - value // arrays as nulls , which doesn't permit index based filtering . final String column = Iterables . getOnlyElement ( requiredBindings ) ; return selector . getBitmapIndex ( column ) != null && ! selector . hasMultipleValues ( column ) ; } else { // Multi - column expression . return false ; } }
response: public boolean supportsBitmapIndex(final BitmapIndexSelector selector) { // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has // an index and does not have multiple values. The lack of multiple values is important because expression // filters treat multi-value arrays as nulls, which doesn't permit index based filtering. <START> return requiredBindings.isEmpty() || (requiredBindings.size() == 1 && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings))); <END> }

sample: 1606
buggy_code: <START> public <END> void setM(Market currentMarket) { this.currentMarket = currentMarket; }
code_review: this method should be changed to private
target code: private void setM ( Market currentMarket ) { this . currentMarket = currentMarket ; }
response: <START> private <END> void setM(Market currentMarket) { this.currentMarket = currentMarket; }

sample: 1607
buggy_code: private long countMapWithAtleastOneQueryCache(Node node) { return maps.stream().filter(distributedObject -> { MapConfig config = node.getConfig().getMapConfig(distributedObject.getName()); if (config != null) { <START> return config.getQueryCacheConfigs().size() >= 1; <END> } return false; }).count(); }
code_review: Please write it as `!config.getQueryCacheConfigs().isEmpty()` instead of checking the size.
target code: private long countMapWithAtleastOneQueryCache ( Node node ) { return maps . stream ( ) . filter ( distributedObject - > { MapConfig config = node . getConfig ( ) . getMapConfig ( distributedObject . getName ( ) ) ; if ( config != null ) { return ! config . getQueryCacheConfigs ( ) . isEmpty ( ) ; } return false ; } ) . count ( ) ; }
response: private long countMapWithAtleastOneQueryCache(Node node) { return maps.stream().filter(distributedObject -> { MapConfig config = node.getConfig().getMapConfig(distributedObject.getName()); if (config != null) { <START> return !config.getQueryCacheConfigs().isEmpty(); <END> } return false; }).count(); }

sample: 1608
buggy_code: public void addModifiedColumns( GlobalConfiguration globalCfg, Value value, Element parent, PropertyAuditingData propertyAuditingData) { String columnName = propertyAuditingData.getModifiedFlagName(); if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); <START> } <END> MetadataTools.addModifiedFlagProperty( parent, propertyAuditingData.getName(), globalCfg.getModifiedFlagSuffix(), columnName ); }
code_review: probably it is better to change it to ``` String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); } else { columnName = propertyAuditingData.getModifiedFlagName(); } ```
target code: public void addModifiedColumns ( GlobalConfiguration globalCfg , Value value , Element parent , PropertyAuditingData propertyAuditingData ) { final String columnName ; if ( propertyAuditingData . isModifiedFlagNameExplicitlySpecified ( ) ) { columnName = propertyAuditingData . getExplicitModifiedFlagName ( ) ; } else { columnName = propertyAuditingData . getModifiedFlagName ( ) ; } MetadataTools . addModifiedFlagProperty ( parent , propertyAuditingData . getName ( ) , globalCfg . getModifiedFlagSuffix ( ) , columnName ) ; }
response: public void addModifiedColumns( GlobalConfiguration globalCfg, Value value, Element parent, PropertyAuditingData propertyAuditingData) { String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); <START> } <END> MetadataTools.addModifiedFlagProperty( parent, propertyAuditingData.getName(), globalCfg.getModifiedFlagSuffix(), columnName ); }

sample: 1609
buggy_code: private boolean isFailedEqualityComparison(Throwable exception) { if (!(exception instanceof ConditionNotSatisfiedError)) return false; <START> final ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; <END> Condition condition = conditionNotSatisfiedError.getCondition(); ExpressionInfo expr = condition.getExpression(); return expr != null && expr.isEqualityComparison() && // it is equality conditionNotSatisfiedError.getCause() == null; // and it is not failed because of exception }
code_review: Why is this final and condition not? Same issue on line 130. Since final is normally not used for local variables in spock, I'd remove it.
target code: private boolean isFailedEqualityComparison ( Throwable exception ) { if ( ! ( exception instanceof ConditionNotSatisfiedError ) ) return false ; ConditionNotSatisfiedError conditionNotSatisfiedError = ( ConditionNotSatisfiedError ) exception ; Condition condition = conditionNotSatisfiedError . getCondition ( ) ; ExpressionInfo expr = condition . getExpression ( ) ; return expr != null && expr . isEqualityComparison ( ) && // it is equality conditionNotSatisfiedError . getCause ( ) == null ; // and it is not failed because of exception }
response: private boolean isFailedEqualityComparison(Throwable exception) { if (!(exception instanceof ConditionNotSatisfiedError)) return false; <START> ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; <END> Condition condition = conditionNotSatisfiedError.getCondition(); ExpressionInfo expr = condition.getExpression(); return expr != null && expr.isEqualityComparison() && // it is equality conditionNotSatisfiedError.getCause() == null; // and it is not failed because of exception }

sample: 1610
buggy_code: public final RedirectAction getLogoutRedirectAction(final WebContext context) { // it's an AJAX request -> unauthorized (instead of a redirection) <START> if (ajaxRequestResolver.isAjax(context)) { <END> logger.info("AJAX request detected -> returning 401"); cleanRequestedUrl(context); return null; } // authentication has already been tried -> unauthorized final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX); if (CommonHelper.isNotBlank(attemptedAuth)) { return null; } init(context); return retrieveLogoutRedirectAction(context); }
code_review: These checks are not necessary for logout.
target code: public final RedirectAction getLogoutRedirectAction ( final WebContext context ) { init ( context ) ; return retrieveLogoutRedirectAction ( context ) ; }
response: public final RedirectAction getLogoutRedirectAction(final WebContext context) { // it's an AJAX request -> unauthorized (instead of a redirection) <START> if (ajaxRequestResolver.isAjax(context)) { <END> logger.info("AJAX request detected -> returning 401"); cleanRequestedUrl(context); return null; } // authentication has already been tried -> unauthorized final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX); if (CommonHelper.isNotBlank(attemptedAuth)) { return null; } init(context); return retrieveLogoutRedirectAction(context); } // Review: These checks are not necessary for logout.

sample: 1611
buggy_code: public void setMainTabSelectedItem(Erratum selectedItem) { <START> logger.info("setMainTabSelectedItem"); //$NON-NLS-1$ <END> updateErrataDetailFormPanel(selectedItem); }
code_review: debug/trace/remove?
target code: public void setMainTabSelectedItem ( Erratum selectedItem ) { updateErrataDetailFormPanel ( selectedItem ) ; }
response: public void setMainTabSelectedItem(Erratum selectedItem) { <START> logger.debug("setMainTabSelectedItem"); //$NON-NLS-1$ <END> updateErrataDetailFormPanel(selectedItem); }

sample: 1612
buggy_code: public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) { this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION); this.namespace = namespace; this.config = config.getPrefixedView(namespace); this.dcInfo = dcInfo; // TODO: Remove this when DiscoveryManager is finally no longer used <START> DiscoveryManager.getInstance().setEurekaInstanceConfig(this); <END> }
code_review: If we need to do this, I feel like we can at least do this somewhere else. A binding for something like DiscoveryManagerInitializer with dependencies on these Config classes might work.
target code: public EurekaArchaius2InstanceConfig ( Config config , String namespace , DataCenterInfo dcInfo ) { this . defaultAppGroup = config . getString ( FALLBACK_APP_GROUP_KEY , Values . UNKNOWN_APPLICATION ) ; this . namespace = namespace ; this . config = config . getPrefixedView ( namespace ) ; this . dcInfo = dcInfo ; }
response: public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) { this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION); this.namespace = namespace; this.config = config.getPrefixedView(namespace); this.dcInfo = dcInfo; // TODO: Remove this when DiscoveryManager is finally no longer used <START> DiscoveryManager.getInstance().setEurekaInstanceConfig(this); <END> }

sample: 1613
buggy_code: public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) { AssertionType assertion = getAssertion(context, null); if (assertion != null) { assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString()); } <START> return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, this.getWebContextProperties(context)); <END> }
code_review: Right here (and in the equivalent 3.0 class) is the only place you're using "this" where a field isn't shadowed, is this intentional?
target code: public AdhocQueryResponse respondingGatewayCrossGatewayQuery ( AdhocQueryRequest body , WebServiceContext context ) { AssertionType assertion = getAssertion ( context , null ) ; if ( assertion != null ) { assertion . setImplementsSpecVersion ( UDDI_SPEC_VERSION . SPEC_2_0 . toString ( ) ) ; } return inboundDocQuery . respondingGatewayCrossGatewayQuery ( body , assertion , getWebContextProperties ( context ) ) ; }
response: public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) { AssertionType assertion = getAssertion(context, null); if (assertion != null) { assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString()); } <START> return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, getWebContextProperties(context)); <END> }

sample: 1614
buggy_code: public void allBindingsChanged(BindingProvider provider) { logger.trace("allBindingsChanged() called."); <START> if (provider instanceof VeluxBindingProvider) { <END> } super.allBindingsChanged(provider); }
code_review: Drop this empty block.
target code: public void allBindingsChanged ( BindingProvider provider ) { logger . trace ( "allBindingsChanged ( ) called . " ) ; super . allBindingsChanged ( provider ) ; }
response: public void allBindingsChanged(BindingProvider provider) { logger.trace("allBindingsChanged() called."); <START> if (provider instanceof VeluxBindingProvider) { <END> } super.allBindingsChanged(provider); }

sample: 1615
buggy_code: private Map<String, String> makeParserFields() { final Map<String, String> fieldMapping = Maps.newHashMap(); for (final SchemaPath sp : getColumns()) { final String drillField = sp.getRootSegment().getPath(); try { <START> final String parserField = HttpdParser.parserFormattedFieldName(drillField); <END> fieldMapping.put(drillField, parserField); } catch (Exception e) { LOG.info("Putting field: " + drillField + " into map", e); } } return fieldMapping; }
code_review: Please, remove `final` modifiers as they seem to be redundant.
target code: private Map < String , String > makeParserFields ( ) { Map < String , String > fieldMapping = new HashMap < > ( ) ; for ( final SchemaPath sp : getColumns ( ) ) { String drillField = sp . getRootSegment ( ) . getPath ( ) ; try { String parserField = HttpdParser . parserFormattedFieldName ( drillField ) ; fieldMapping . put ( drillField , parserField ) ; } catch ( Exception e ) { LOG . info ( "Putting field : " + drillField + " into map" , e ) ; } } return fieldMapping ; }
response: private Map<String, String> makeParserFields() { final Map<String, String> fieldMapping = Maps.newHashMap(); for (final SchemaPath sp : getColumns()) { final String drillField = sp.getRootSegment().getPath(); try { <START> String parserField = HttpdParser.parserFormattedFieldName(drillField); <END> fieldMapping.put(drillField, parserField); } catch (Exception e) { LOG.info("Putting field: " + drillField + " into map", e); } } return fieldMapping; }

sample: 1616
buggy_code: public Builder client(@NonNull OkHttpClient client) { if (client == null) { throw new NullPointerException("client == null"); } if (downloader != null) { throw new IllegalArgumentException("Downloader already set."); } downloader = new OkHttp3Downloader(client, client.cache(), true); return this; <START> } <END>
code_review: Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your `newBuilder()` desire.
target code: public Builder client ( @NonNull OkHttpClient client ) { if ( client == null ) { throw new NullPointerException ( "client == null" ) ; } downloader = new OkHttp3Downloader ( client , client . cache ( ) , true ) ; return this ; }
response: public Builder client(@NonNull OkHttpClient client) { if (client == null) { throw new NullPointerException("client == null"); } downloader = new OkHttp3Downloader(client, client.cache(), true); return this; <START> } <END>

sample: 1617
buggy_code: protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) { final Activity activity = placeManager.getActivity(placeRequest); <START> if (activity != null) { <END> final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } else { return Optional.empty(); } }
code_review: Just a small remark feel free to skip it. It would have a nicer look if you keep if else logic direct like if (activity == null) { return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); }
target code: protected Optional < CoverageReportView > getCoverageReportView ( PlaceRequest placeRequest ) { final Activity activity = placeManager . getActivity ( placeRequest ) ; if ( activity == null ) { return Optional . empty ( ) ; } else { final AbstractWorkbenchActivity coverageActivity = ( AbstractWorkbenchActivity ) activity ; return Optional . of ( ( CoverageReportView ) coverageActivity . getWidget ( ) ) ; } }
response: protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) { final Activity activity = placeManager.getActivity(placeRequest); <START> if (activity == null) { <END> return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } }

sample: 1618
buggy_code: private void edit() { if (getWindow() != null) { return; } AffinityGroup affinityGroup = getSelectedItem(); if (affinityGroup == null) { return; } <START> sortVms(affinityGroup); <END> AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver()); model.init(); setWindow(model); }
code_review: Generally you don't sort the VMs, and in the one case where you do - you don't really sort them either, but just move one to the top of the list. So firstly, consider dropping this method, making edit() protected and add the logic only in VmAffinityGroupListModel. Secondly, you could drop the comparator there and just iterate over the items to find the specific ID and move it to the top of the list, the comparator thing isn't necessary.
target code: private void edit ( ) { if ( getWindow ( ) != null ) { return ; } AffinityGroup affinityGroup = getSelectedItem ( ) ; if ( affinityGroup == null ) { return ; } AffinityGroupModel model = new EditAffinityGroupModel ( affinityGroup , this , getClusterResolver ( ) ) ; model . init ( ) ; setWindow ( model ) ; }
response: private void edit() { if (getWindow() != null) { return; } AffinityGroup affinityGroup = getSelectedItem(); if (affinityGroup == null) { return; } AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver()); model.init(); setWindow(model); }

sample: 1619
buggy_code: public void testIteratorCloses() throws Exception { Kabob bob = db.getJdbi().onDemand(Kabob.class); Iterator<Something> itty = bob.iterateAll(); <START> assertThat(itty.hasNext()).isFalse(); <END> }
code_review: Considering the expected exception for this test, it seems like the `assertThat` is superfluous, and all we really want is `itty.hasNext();`
target code: public void testIteratorCloses ( ) throws Exception { Kabob bob = db . getJdbi ( ) . onDemand ( Kabob . class ) ; Iterator < Something > itty = bob . iterateAll ( ) ; itty . hasNext ( ) ; }
response: public void testIteratorCloses() throws Exception { Kabob bob = db.getJdbi().onDemand(Kabob.class); Iterator<Something> itty = bob.iterateAll(); <START> itty.hasNext(); <END> }

sample: 1620
buggy_code: public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) { Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing); Boolean match = true; <START> assertEquals(swappedIngredients.size(), ings.size()); <END> for (String i : ings) { if (!swappedIngredients.contains(i)) { match = false; break; } } assertTrue(match); }
code_review: Cant the class name be included here so we know where this method is being called from.
target code: public static void assertSwappedIngredientsMatch ( ObjectInstance ing , State s , List < String > ings ) { Set < String > swappedIngredients = IngredientFactory . getRecursiveContentsAndSwapped ( s , ing ) ; Boolean match = true ; Assert . assertEquals ( swappedIngredients . size ( ) , ings . size ( ) ) ; for ( String i : ings ) { if ( ! swappedIngredients . contains ( i ) ) { match = false ; break ; } } Assert . assertTrue ( match ) ; }
response: public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) { Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing); Boolean match = true; <START> assertEquals(swappedIngredients.size(), ings.size()); <END> for (String i : ings) { if (!swappedIngredients.contains(i)) { match = false; break; } } assertTrue(match); }

sample: 1621
buggy_code: public List<Document> getClientDocuments(String clientId) throws MambuApiException { <START> if (clientId == null || clientId.trim().isEmpty()) { <END> throw new IllegalArgumentException("ClientId ID must not be null or empty"); } return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId); }
code_review: Edge case of duplicate code ;) It could be extracted to a common private method with two params for id and type. Up to you if you want to change it or not ;)
target code: public List < Document > getClientDocuments ( String clientId ) throws MambuApiException { if ( clientId == null || clientId . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "ClientId ID must not be null or empty" ) ; } return new DocumentsService ( mambuAPIService ) . getDocuments ( CLIENTS , clientId ) ; }
response: public List<Document> getClientDocuments(String clientId) throws MambuApiException { <START> if (clientId == null || clientId.trim().isEmpty()) { <END> throw new IllegalArgumentException("ClientId ID must not be null or empty"); } return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId); }

sample: 1622
buggy_code: public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertFalse("checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain", <END> command.checkDisksInBackupStorage()); }
code_review: Now this should return true, since there are disks on the storage domain (Remember that you don't check the validate only the method checkDisksInBackupStorage) Change to assertTrue
target code: public void testFailForCheckDisksNotInBackupStorage ( ) { final VM vm = new VM ( ) ; command . setVm ( vm ) ; when ( vmDao . get ( command . getParameters ( ) . getVmId ( ) ) ) . thenReturn ( vm ) ; command . setCluster ( new Cluster ( ) ) ; Guid storageDomainId = initDiskImage ( vm ) ; when ( storageDomainStaticDao . get ( storageDomainId ) ) . thenReturn ( backupStorageDomain ( true ) ) ; assertTrue ( "checkDisksNotInBackupStorage ( ) fails to run because one or more disk is in backup domain" , command . checkDisksInBackupStorage ( ) ) ; }
response: public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertTrue("checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain", <END> command.checkDisksInBackupStorage()); }

sample: 1623
buggy_code: public long skip(long n) { if (n > 0) { long skip = bytes.length - pos; if (skip > n) skip = n; pos += skip; return skip; } else { int idx = Math.min(bytes.length, pos); long skip = idx + n; <START> pos = (int) skip; <END> return skip; } }
code_review: shouldn't be the ```max()``` between ```offset``` and ```skip``` to avoid the ```pos``` to be previous than ```offset```?
target code: public long skip ( long n ) { if ( n > 0 ) { long skip = bytes . length - pos ; if ( skip > n ) skip = n ; pos += skip ; return skip ; } else { int idx = Math . min ( bytes . length , pos ) ; long skip = idx + n ; // Calculate max to avoid skipping before offset pos = ( int ) Math . max ( skip , offset ) ; return skip ; } }
response: public long skip(long n) { if (n > 0) { long skip = bytes.length - pos; if (skip > n) skip = n; pos += skip; return skip; } else { int idx = Math.min(bytes.length, pos); long skip = idx + n; <START> pos = (int) Math.max(offset, skip); <END> return skip; } }

sample: 1624
buggy_code: public void actionPerformed(AnActionEvent e) { BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); <START> s.cleanup(); <END> }
code_review: You may want to put this into a try/finally block.
target code: public void actionPerformed ( AnActionEvent e ) { BaseAction . State s = setupAction ( e ) ; try { List < String > lastTask = Collections . singletonList ( s . getLastRanTask ( ) ) ; s . performTasks ( lastTask ) ; } finally { s . cleanup ( ) ; } }
response: public void actionPerformed(AnActionEvent e) { BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); <START> try { s.cleanup(); } finally { s.cleanup(); } <END> }

sample: 1625
buggy_code: public void addAll(SerializableStatus status) { Assert.isLegal(status != null); SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren(); for (SerializableStatus <START> statuse : <END> statuses) { add(statuse); } }
code_review: rename to s
target code: public void addAll ( SerializableStatus status ) { Assert . isLegal ( status != null ) ; SerializableStatus [ ] statuses = ( SerializableStatus [ ] ) status . getChildren ( ) ; for ( SerializableStatus s : statuses ) { add ( s ) ; } }
response: public void addAll(SerializableStatus status) { Assert.isLegal(status != null); SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren(); for (SerializableStatus <START> s : <END> statuses) { add(s); } }

sample: 1626
buggy_code: protected boolean canDoAction() { <START> return super.canDoAction() && VdsGroupExists() && logicalNetworkExists() && changesAreClusterCompatible(); <END> }
code_review: how about moving logicalNetworkExists() after changesAreClusterCompatible() ? in case changesAreClusterCompatible() returns false, it will save one DB call :)
target code: protected boolean canDoAction ( ) { return super . canDoAction ( ) && VdsGroupExists ( ) && changesAreClusterCompatible ( ) && logicalNetworkExists ( ) ; }
response: protected boolean canDoAction() { <START> return super.canDoAction() && VdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists(); <END> }

sample: 1627
buggy_code: protected void reloadCache() { schemaMappingCache.invalidateAll(); // this preloads the list of schema names Set<String> schemas = getSchemaNames(); // invalidate and remove from the schema table mapping all records, start from scratch for (String key : schemaTableMapping.keySet()) { schemaTableMapping.get(key).invalidateAll(); schemaTableMapping.remove(key); <START> } <END> for (final String schema : schemas) { // this preloads the list of table names for each schema getTableNames(schema); } }
code_review: any reason you can't just iterate through the values? schemaTableMapping.values().foreach(v -> v.invalidateAll()); schemaTableMapping.clear();
target code: protected void reloadCache ( ) { schemaMappingCache . invalidateAll ( ) ; // this preloads the list of schema names Set < String > schemas = getSchemaNames ( ) ; // invalidate and remove from the schema table mapping all records , start from scratch schemaTableMapping . keySet ( ) . forEach ( key - > { schemaTableMapping . get ( key ) . invalidateAll ( ) ; } ) ; schemaTableMapping . clear ( ) ; for ( final String schema : schemas ) { // this preloads the list of table names for each schema getTableNames ( schema ) ; } }
response: protected void reloadCache() { schemaMappingCache.invalidateAll(); // this preloads the list of schema names Set<String> schemas = getSchemaNames(); // invalidate and remove from the schema table mapping all records, start from scratch for (String key : schemaTableMapping.keySet()) { schemaTableMapping.get(key).invalidateAll(); schemaTableMapping.remove(key); <START> } <END> for (final String schema : schemas) { // this preloads the list of table names for each schema getTableNames(schema); } }

sample: 1628
buggy_code: public void testSetUser() { Configuration configuration = generateConfiguration(); configuration.setUser("24601", "m@rp.fr", "MM"); <START> assertEquals(User.class, configuration.getUser().getClass()); <END> assertEquals("24601", configuration.getUser().getId()); assertEquals("m@rp.fr", configuration.getUser().getEmail()); assertEquals("MM", configuration.getUser().getName()); }
code_review: This assertion could be removed as it seems to test the Java type system rather than our code
target code: public void testSetUser ( ) { Configuration configuration = generateConfiguration ( ) ; configuration . setUser ( "24601" , "m@rp . fr" , "MM" ) ; assertEquals ( "24601" , configuration . getUser ( ) . getId ( ) ) ; assertEquals ( "m@rp . fr" , configuration . getUser ( ) . getEmail ( ) ) ; assertEquals ( "MM" , configuration . getUser ( ) . getName ( ) ) ; }
response: public void testSetUser() { Configuration configuration = generateConfiguration(); configuration.setUser("24601", "m@rp.fr", "MM"); <START> assertEquals("24601", configuration.getUser().getId()); <END> assertEquals("m@rp.fr", configuration.getUser().getEmail()); assertEquals("MM", configuration.getUser().getName()); }

sample: 1629
buggy_code: private void writeStringToFile(File file, String str) throws IOException { <START> try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.toString()))) { <END> bw.write(str); } }
code_review: No need to call `file.toString()` -> `FileWriter` can take `File` in the constructor as well.
target code: private void writeStringToFile ( File file , String str ) throws IOException { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ) { bw . write ( str ) ; } }
response: private void writeStringToFile(File file, String str) throws IOException { <START> try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) { <END> bw.write(str); } }

sample: 1630
buggy_code: private RelNode possiblyWrapRootWithOuterLimitFromContext( RelRoot root ) { Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT); if (outerLimitObj == null) { return root.rel; } <START> Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); <END> if (outerLimit == null) { return root.rel; } return LogicalSort.create( root.rel, root.collation, makeBigIntLiteral(0), makeBigIntLiteral(outerLimit) ); }
code_review: Minor: the two calls could be collapsed, since `DimensionHandlerUtils.convertObjectToLong` handles nulls just fine.
target code: private RelNode possiblyWrapRootWithOuterLimitFromContext ( RelRoot root ) { Object outerLimitObj = plannerContext . getQueryContext ( ) . get ( PlannerContext . CTX_SQL_OUTER_LIMIT ) ; Long outerLimit = DimensionHandlerUtils . convertObjectToLong ( outerLimitObj , true ) ; if ( outerLimit == null ) { return root . rel ; } return LogicalSort . create ( root . rel , root . collation , makeBigIntLiteral ( 0 ) , makeBigIntLiteral ( outerLimit ) ) ; }
response: private RelNode possiblyWrapRootWithOuterLimitFromContext( RelRoot root ) { Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT); <START> Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); <END> if (outerLimit == null) { return root.rel; } return LogicalSort.create( root.rel, root.collation, makeBigIntLiteral(0), makeBigIntLiteral(outerLimit) ); }

sample: 1631
buggy_code: <START> public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException { <END> QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig(); try { Properties zkProp = getDefaultZKProperties(); zkProp.setProperty("server.1", "localhost:2888:2888"); quorumPeerConfig.parseProperties(zkProp); fail("ConfigException is expected"); } catch (ConfigException ce) { String expectedMessage = "Client and election port must be different! Please update the configuration file on server.1"; assertEquals(expectedMessage, ce.getMessage()); } }
code_review: nit - ConfigException is unused
target code: public void testSamePortConfiguredForClientAndElection ( ) throws IOException , ConfigException { QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig ( ) ; Properties zkProp = getDefaultZKProperties ( ) ; zkProp . setProperty ( "server . 1" , "localhost : 2888 : 2888" ) ; quorumPeerConfig . parseProperties ( zkProp ) ; }
response: <START> public void testSamePortConfiguredForClientAndElection() throws IOException { <END> QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig(); try { Properties zkProp = getDefaultZKProperties(); zkProp.setProperty("server.1", "localhost:2888:2888"); quorumPeerConfig.parseProperties(zkProp); fail("ConfigException is expected"); } catch (ConfigException ce) { String expectedMessage = "Client and election port must be different! Please update the configuration file on server.1"; assertEquals(expectedMessage, ce.getMessage()); } }

sample: 1632
buggy_code: public static URLConnection openURLConnection(URL url) <START> throws IOException, ConnectException { <END> return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT); }
code_review: ConnectException is not actually thrown by anything... it shouldn't be declared in the `throws`
target code: public static URLConnection openURLConnection ( URL url ) throws IOException { return openURLConnection ( url , DEFAULT_CONNECTION_TIMEOUT ) ; }
response: public static URLConnection openURLConnection(URL url) <START> throws IOException { <END> return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT); }

sample: 1633
buggy_code: public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) { <START> for (VdcActionParametersBase param : parameters) { <END> param.setParentCommand(command.getActionType()); param.setParentParameters(command.getParameters()); } }
code_review: 1. let's replace with params.forEach 2. it makes more sense that this method will reside in HostSetupNetworksParametersBuilder - I don't see how its related to "ReportFailedChildHostOperationsUtil"
target code: public void updateParentCommandId ( ArrayList < VdcActionParametersBase > parameters , CommandBase command ) { parameters . forEach ( param - > { param . setParentCommand ( command . getActionType ( ) ) ; param . setParentParameters ( command . getParameters ( ) ) ; } ) ; }
response: public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) { <START> parameters.forEach(param -> { <END> param.setParentCommand(command.getActionType()); param.setParentParameters(command.getParameters()); }); }

sample: 1634
buggy_code: public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) { RollupType rollupType = null; String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey); if ( rollupTypeStr != null ) { rollupType = RollupType.fromString(rollupTypeStr); } if ( rollupType == null ) { rollupType = RollupType.BF_BASIC; } <START> return getNumericMetricDataForRange(locator, range, gran, rollupType); <END> }
code_review: nm. I misread the diff. I thought ```getDatapointsForRange()``` only called ```getNumericMetricDataForRange()```
target code: public MetricData getDatapointsForRange ( Locator locator , Range range , Granularity gran ) { RollupType rollupType = RollupType . BF_BASIC ; String rollupTypeStr = metaCache . safeGet ( locator , rollupTypeCacheKey ) ; if ( rollupTypeStr != null ) { rollupType = RollupType . fromString ( rollupTypeStr ) ; } return getNumericMetricDataForRange ( locator , range , gran , rollupType ) ; }
response: public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) { RollupType rollupType = null; String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey); if ( rollupTypeStr != null ) { rollupType = RollupType.fromString(rollupTypeStr); } if ( rollupType == null ) { rollupType = RollupType.BF_BASIC; } <START> return getNumericMetricDataForRange(locator, range, gran, rollupType); <END> }

sample: 1635
buggy_code: public boolean shouldProcessRequestedCashAdvancesFromSaeData() { <START> return (getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND).equalsIgnoreCase(KFSConstants.ParameterValues.YES)); <END> }
code_review: to be null safe on here, I would suggest using stringutils.equalsignorecase or start the expression with the constant
target code: public boolean shouldProcessRequestedCashAdvancesFromSaeData ( ) { return ( StringUtils . equalsIgnoreCase ( getConcurParameterValue ( ConcurParameterConstants . CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND ) , KFSConstants . ParameterValues . YES ) ) ; }
response: public boolean shouldProcessRequestedCashAdvancesFromSaeData() { <START> return (KFSConstants.ParameterValues.YES.equalsIgnoreCase(getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND))); <END> }

sample: 1636
buggy_code: static Path resolvePath(Path file, String workingDirectory) { <START> return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, <END> file.getFileName().toString())))); }
code_review: Looks that works OK, but for me it's hard to read. I would rather see better readable return.
target code: static Path resolvePath ( Path file , String workingDirectory ) { if ( file == null ) { return null ; } else if ( file . isAbsolute ( ) ) { return file ; } else if ( file . getFileName ( ) . startsWith ( File . separator ) ) { return file . toAbsolutePath ( ) ; } else { return Paths . get ( workingDirectory , file . getFileName ( ) . toString ( ) ) ; } }
response: static Path resolvePath(Path file, String workingDirectory) { <START> return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, file.getFileName().toString())))); }

sample: 1637
buggy_code: public void removeServiceEventListener(Object listener) { assert getExecutor().isInExecutorThread(); ListenerEntry entry = new ListenerEntry(listener, null); <START> if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_LISTENERS) { <END> String msg = new Formatter().format( "%s %s removed as a service listener to %s (id=%s)", //$NON-NLS-1$ DsfPlugin.getDebugTime(), LoggingUtils.toString(listener), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fListeners.remove(entry); }
code_review: Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.
target code: public void removeServiceEventListener ( Object listener ) { assert getExecutor ( ) . isInExecutorThread ( ) ; ListenerEntry entry = new ListenerEntry ( listener , null ) ; if ( DsfDebugOptions . DEBUG_SESSION_LISTENERS ) { String msg = new Formatter ( ) . format ( " % s % s removed as a service listener to % s ( id = % s ) " , // $NON - NLS - 1$ DsfPlugin . getDebugTime ( ) , LoggingUtils . toString ( listener ) , LoggingUtils . toString ( this ) , getId ( ) ) . toString ( ) ; DsfDebugOptions . trace ( msg ) ; } fListeners . remove ( entry ) ; }
response: public void removeServiceEventListener(Object listener) { assert getExecutor().isInExecutorThread(); ListenerEntry entry = new ListenerEntry(listener, null); <START> if (DsfDebugOptions.DEBUG_SESSION_LISTENERS) { <END> String msg = new Formatter().format( "%s %s removed as a service listener to %s (id=%s)", //$NON-NLS-1$ DsfPlugin.getDebugTime(), LoggingUtils.toString(listener), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fListeners.remove(entry); }

sample: 1638
buggy_code: private static void validateEntityLabel(EntityType entityType) { String label = entityType.getLabel(); <START> if (label.isEmpty()) <END> { throw new MolgenisValidationException( new ConstraintViolation(format("Label of EntityType [%s] is empty", entityType.getId()))); } else if (label.trim().equals("")) { throw new MolgenisValidationException(new ConstraintViolation( format("Label of EntityType [%s] contains only white space", entityType.getId()))); } }
code_review: I smell an incoming NPE here...
target code: private static void validateEntityLabel ( EntityType entityType ) { String label = entityType . getLabel ( ) ; if ( label != null ) { if ( label . isEmpty ( ) ) { throw new MolgenisValidationException ( new ConstraintViolation ( format ( "Label of EntityType [ % s ] is empty" , entityType . getId ( ) ) ) ) ; } else if ( label . trim ( ) . equals ( "" ) ) { throw new MolgenisValidationException ( new ConstraintViolation ( format ( "Label of EntityType [ % s ] contains only white space" , entityType . getId ( ) ) ) ) ; } } }
response: private static void validateEntityLabel(EntityType entityType) { String label = entityType.getLabel(); <START> if (label == null || label.isEmpty()) <END> { throw new MolgenisValidationException( new ConstraintViolation(format("Label of EntityType [%s] is empty", entityType.getId()))); } else if (label.trim().equals("")) { throw new MolgenisValidationException(new ConstraintViolation( format("Label of EntityType [%s] contains only white space", entityType.getId()))); } }

sample: 1639
buggy_code: public void deleteIfExists(File path, String user, String logPrefix) throws IOException { <START> LOG.info("Deleting path {}", path); <END> Path p = path.toPath(); if (Files.exists(p)) { try { FileUtils.forceDelete(path); } catch (FileNotFoundException ignored) {} } }
code_review: We could just call deleteIfExists(path) since it's same.
target code: public void deleteIfExists ( File path , String user , String logPrefix ) throws IOException { // by default no need to do this as a different user deleteIfExists ( path ) ; }
response: public void deleteIfExists(File path, String user, String logPrefix) throws IOException { <START> LOG.info("Deleting path {}", path); <END> Path p = path.toPath(); if (Files.exists(p)) { try { FileUtils.forceDelete(path); } catch (FileNotFoundException ignored) {} } }

sample: 1640
buggy_code: protected void releaseTransport(Transport transport) { <START> if (dedicatedTransport == null) { <END> //we aren't using this transport. we can release it super.releaseTransport(transport); } }
code_review: This could be even `if (dedicatedTransport != transport)`
target code: protected void releaseTransport ( Transport transport ) { if ( dedicatedTransport != transport ) { // we aren't using this transport . we can release it super . releaseTransport ( transport ) ; } }
response: protected void releaseTransport(Transport transport) { <START> if (dedicatedTransport != transport) { <END> //we aren't using this transport. we can release it super.releaseTransport(transport); } }

sample: 1641
buggy_code: String prepare(String name, Map<String, Map<String, String>> domain) { StringBuilder builder = new StringBuilder(name); while (domain.containsKey(name)) { <START> builder.append("~"); <END> } domain.put(builder.toString(), new LinkedHashMap<>()); return builder.toString(); }
code_review: You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized.
target code: String prepare ( String name , Map < String , Map < String , String > > domain ) { StringBuilder builder = new StringBuilder ( name ) ; while ( domain . containsKey ( name ) ) { builder . append ( "~" ) ; } String val = builder . toString ( ) ; domain . put ( val , new LinkedHashMap < > ( ) ) ; return val ; }
response: String prepare(String name, Map<String, Map<String, String>> domain) { while (domain.containsKey(name)) { <START> name += "~"; <END> } domain.put(name, new LinkedHashMap<>()); return name; }

sample: 1642
buggy_code: public synchronized void deleteFile() { closeFile(); File historyTreeFile = fConfig.getStateFile(); try { if (!historyTreeFile.delete()) { /* We didn't succeed in deleting the file */ Activator.getDefault().logError("Failed to delete" + historyTreeFile.getName()); //$NON-NLS-1$ } <START> } catch (SecurityException e) { <END> Activator.getDefault().logError(e.getMessage(), e); } }
code_review: is this a RuntimeException? In which case you probably don't want to catch it.
target code: public synchronized void deleteFile ( ) { closeFile ( ) ; File historyTreeFile = fConfig . getStateFile ( ) ; if ( ! historyTreeFile . delete ( ) ) { /* We didn't succeed in deleting the file */ Activator . getDefault ( ) . logError ( "Failed to delete" + historyTreeFile . getName ( ) ) ; // $NON - NLS - 1$ } }
response: public synchronized void deleteFile() { closeFile(); File historyTreeFile = fConfig.getStateFile(); try { if (!historyTreeFile.delete()) { /* We didn't succeed in deleting the file */ Activator.getDefault().logError("Failed to delete" + historyTreeFile.getName()); //$NON-NLS-1$ } <START> } catch (SecurityException e) { <END> Activator.getDefault().logError(e.getMessage(), e); } }

sample: 1643
buggy_code: public void delete(UserEntityFile userEntityFile) { <START> getEntityManager().remove(userEntityFile); <END> }
code_review: Replace method content with... super.delete(userEntityFile); ...as the underlying code will not only delete the entity but also fire an event about it.
target code: public void delete ( UserEntityFile userEntityFile ) { super . delete ( userEntityFile ) ; }
response: public void delete(UserEntityFile userEntityFile) { <START> super.delete(userEntityFile); <END> }

sample: 1644
buggy_code: <START> public void init() { <END> if (dubboConfigBinder == null) { try { dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); } catch (BeansException ignored) { if (log.isDebugEnabled()) { log.debug("DubboConfigBinder Bean can't be found in ApplicationContext."); } // Use Default implementation dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); } } dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); }
code_review: If we allow to create sub class of this **DubboConfigBindingBeanPostProcessor ** and some **init method** get override then it might cause issue. So better to make init final or provide. What do you say?
target code: private void init ( ) { if ( dubboConfigBinder == null ) { try { dubboConfigBinder = applicationContext . getBean ( DubboConfigBinder . class ) ; } catch ( BeansException ignored ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DubboConfigBinder Bean can't be found in ApplicationContext . " ) ; } // Use Default implementation dubboConfigBinder = createDubboConfigBinder ( applicationContext . getEnvironment ( ) ) ; } } dubboConfigBinder . setIgnoreUnknownFields ( ignoreUnknownFields ) ; dubboConfigBinder . setIgnoreInvalidFields ( ignoreInvalidFields ) ; }
response: <START> public final void init() { <END> if (dubboConfigBinder == null) { try { dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); } catch (BeansException ignored) { if (log.isDebugEnabled()) { log.debug("DubboConfigBinder Bean can't be found in ApplicationContext."); } // Use Default implementation dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); } } dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); }

sample: 1645
buggy_code: public static void removeDuplicateImages(Feed feed) { Set<String> known = new HashSet<String>(); for (FeedItem item : feed.getItems()) { <START> String url = (item.hasItemImage()) ? item.getImage().getDownload_url() : null; <END> if (url != null) { if (known.contains(url)) { item.setImage(null); } else { known.add(url); } } } }
code_review: I find it even easier to read without the `(...)`
target code: public static void removeDuplicateImages ( Feed feed ) { Set < String > known = new HashSet < String > ( ) ; for ( FeedItem item : feed . getItems ( ) ) { String url = item . hasItemImage ( ) ? item . getImage ( ) . getDownload_url ( ) : null ; if ( url != null ) { if ( known . contains ( url ) ) { item . setImage ( null ) ; } else { known . add ( url ) ; } } } }
response: public static void removeDuplicateImages(Feed feed) { Set<String> known = new HashSet<String>(); for (FeedItem item : feed.getItems()) { <START> String url = item.hasItemImage() ? item.getImage().getDownload_url() : null; <END> if (url != null) { if (known.contains(url)) { item.setImage(null); } else { known.add(url); } } } }

sample: 1646
buggy_code: protected void selectedItemsChanged() { <START> super.onSelectedItemChanged(); <END> updateActionAvailability(); }
code_review: Shouldn't this also be changed to super.selectedItemsChanged()?
target code: protected void selectedItemsChanged ( ) { super . selectedItemsChanged ( ) ; updateActionAvailability ( ) ; }
response: protected void selectedItemsChanged() { <START> super.selectedItemsChanged(); <END> updateActionAvailability(); }

sample: 1647
buggy_code: public int[] borrowIntArray(int positionCount) { int[] array; <START> while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { <END> estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length); --intArraysTop; } if (intArraysTop < 0) { array = new int[positionCount]; estimatedSizeInBytes += sizeOfIntArray(positionCount); } else { array = intArrays[intArraysTop]; --intArraysTop; } ++borrowedIntArrays; return array; }
code_review: Shouldn't this loop release memory of "discarded" arrays? E.g. intArrays[intArraysTop] = null?
target code: public int [ ] borrowIntArray ( int positionCount ) { int [ ] array ; while ( intArraysTop >= 0 && intArrays [ intArraysTop ] . length < positionCount ) { estimatedSizeInBytes -= sizeOfIntArray ( intArrays [ intArraysTop ] . length ) ; intArrays [ intArraysTop ] = null ; -- intArraysTop ; } if ( intArraysTop < 0 ) { array = new int [ positionCount ] ; estimatedSizeInBytes += sizeOfIntArray ( positionCount ) ; } else { array = intArrays [ intArraysTop ] ; -- intArraysTop ; } ++ borrowedIntArrays ; return array ; }
response: public int[] borrowIntArray(int positionCount) { int[] array; <START> while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { <END> estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length); intArrays[intArraysTop] = null; --intArraysTop; } if (intArraysTop < 0) { array = new int[positionCount]; estimatedSizeInBytes += sizeOfIntArray(positionCount); } else { array = intArrays[intArraysTop]; --intArraysTop; } ++borrowedIntArrays; return array; }

sample: 1648
buggy_code: <START> public Collection<MergeStrategySection> getAllMergeStrategySections() { <END> List<MergeStrategySection> all = new ArrayList<MergeStrategySection>(); all.addAll(getLocalMergeStrategySections()); all.addAll(getInheritedMergeStrategySections()); return all; }
code_review: I suspect that you want to preserve order here and return a List?
target code: public List < MergeStrategySection > getAllMergeStrategySections ( ) { List < MergeStrategySection > all = new ArrayList < MergeStrategySection > ( ) ; all . addAll ( getLocalMergeStrategySections ( ) ) ; all . addAll ( getInheritedMergeStrategySections ( ) ) ; return all ; }
response: <START> public List<MergeStrategySection> getAllMergeStrategySections() { <END> List<MergeStrategySection> all = new ArrayList<MergeStrategySection>(); all.addAll(getLocalMergeStrategySections()); all.addAll(getInheritedMergeStrategySections()); return all; }

sample: 1649
buggy_code: public String getDeleteDescription() { <START> return getName() + (getAlias() == null ? "" : " (" + getAlias() + ")"); <END> }
code_review: Alias should never be null.
target code: public String getDeleteDescription ( ) { return getName ( ) + " ( " + getAlias ( ) + " ) " ; }
response: public String getDeleteDescription() { <START> return getName() + " (" + getAlias() + ")"; <END> }

sample: 1650
buggy_code: boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) <START> throws CouchbaseLiteException { <END> if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID())) return false; setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision return true; }
code_review: Is CouchbaseLiteException thrown from anything in this method? Or it should return void but throw CouchbaseLiteException instead?
target code: boolean selectCommonAncestor ( ReadOnlyDocument doc1 , ReadOnlyDocument doc2 ) { if ( ! c4doc . getRawDoc ( ) . selectCommonAncestorRevision ( doc1 . getRevID ( ) , doc2 . getRevID ( ) ) ) return false ; setC4Doc ( c4doc ) ; // self . c4Doc = _c4Doc ; // This will update to the selected revision return true ; }
response: boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) <START> throws CouchbaseLiteException { <END> if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID())) return false; setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision return true; }

sample: 1651
buggy_code: <START> public void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { <END> this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId; }
code_review: `protected`. It would be bad to allow end-user to mutate on this local property.
target code: protected void setHazelcastRegisteredEventListenerId ( String hazelcastRegisteredEventListenerId ) { this . hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId ; }
response: <START> protected void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { <END> this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId; }

sample: 1652
buggy_code: protected String getFileName(ITask task, Predicate<String> fileExists) { String encodedFileName = CoreUtil.asFileName(task.getTaskId()); // for backwards-compatibility with versions that always encoded file names, // we will use an encoded name if the file with an encoded name already exists <START> if (encodedFileName.length() <= FILENAME_MAX_LEN && fileExists.test(encodedFileName)) { <END> return encodedFileName; } // if file with encoded name does not exist, we will only encode file name if it is required String fileName; if (requiresEncoding(task.getTaskId())) { fileName = encodedFileName; } else { fileName = task.getTaskId(); } // trim the file name if it is too long return trimFilenameIfRequired(fileName); }
code_review: In what case can the file exist but be too long? If we are on a system with a longer filename limit, we should just use the existing file and not worry about the length, I think.
target code: protected String getFileName ( ITask task , Predicate < String > fileExists ) { String encodedFileName = CoreUtil . asFileName ( task . getTaskId ( ) ) ; // for backwards - compatibility with versions that always encoded file names , // we will use an encoded name if the file with an encoded name already exists if ( fileExists . test ( encodedFileName ) ) { return encodedFileName ; } // if file with encoded name does not exist , we will only encode file name if it is required String fileName ; if ( requiresEncoding ( task . getTaskId ( ) ) ) { fileName = encodedFileName ; } else { fileName = task . getTaskId ( ) ; } // trim the file name if it is too long return trimFilenameIfRequired ( fileName ) ; }
response: protected String getFileName(ITask task, Predicate<String> fileExists) { String encodedFileName = CoreUtil.asFileName(task.getTaskId()); // for backwards-compatibility with versions that always encoded file names, // we will use an encoded name if the file with an encoded name already exists <START> if (fileExists.test(encodedFileName)) { <END> return encodedFileName; } // if file with encoded name does not exist, we will only encode file name if it is required String fileName; if (requiresEncoding(task.getTaskId())) { fileName = encodedFileName; } else { fileName = task.getTaskId(); } // trim the file name if it is too long return trimFilenameIfRequired(fileName); }

sample: 1653
buggy_code: public boolean createIndex(String indexName) { Assert.notNull(indexName, "No index defined for Query"); try { CreateIndexRequest indexRequest = createIndexRequest(indexName); <START> return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); <END> } catch (Exception e) { throw new ElasticsearchException("Failed to create index " + indexName, e); } }
code_review: why the extraction to a variable? I would keep it inlined: ``` return client.indices().create(createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged(); ```
target code: public boolean createIndex ( String indexName ) { Assert . notNull ( indexName , "No index defined for Query" ) ; try { return client . indices ( ) . create ( createIndexRequest ( indexName ) , RequestOptions . DEFAULT ) . isAcknowledged ( ) ; } catch ( Exception e ) { throw new ElasticsearchException ( "Failed to create index " + indexName , e ) ; } }
response: public boolean createIndex(String indexName) { Assert.notNull(indexName, "No index defined for Query"); try { CreateIndexRequest indexRequest = createIndexRequest(indexName); return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); } catch (Exception e) { throw new ElasticsearchException("Failed to create index " + indexName, e); } }

sample: 1654
buggy_code: public static Properties defaultProperties() { Properties properties = BaseHttpApiMetadata.defaultProperties(); <START> properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, "<remote-service-key-given-by-shipyard-cli>"); <END> return properties; }
code_review: What is this property used for?
target code: public static Properties defaultProperties ( ) { return BaseHttpApiMetadata . defaultProperties ( ) ; }
response: public static Properties defaultProperties() { Properties properties = BaseHttpApiMetadata.defaultProperties(); <START> properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, "<remote-service-key-given-by-shipyard-cli>"); <END> return properties; }

sample: 1655
buggy_code: protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) { if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) { return false; } if (ctx.isOriginLocal()) { // The return value only matters on the originator. // Conditional commands also check the previous value only on the originator. if (!command.readsExistingValues()) { return false; } // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues(); <START> if (command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) { <END> return false; } } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well? if (!command.alwaysReadsExistingValues()) { return false; } } return true; }
code_review: It seems this could be changed to `return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP))`
target code: protected boolean writeNeedsRemoteValue ( InvocationContext ctx , WriteCommand command , Object key ) { if ( command . hasFlag ( Flag . CACHE_MODE_LOCAL ) ) { return false ; } if ( ctx . isOriginLocal ( ) ) { // The return value only matters on the originator . // Conditional commands also check the previous value only on the originator . if ( ! command . readsExistingValues ( ) ) { return false ; } // TODO Could make DELTA_WRITE / ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return ! command . hasFlag ( Flag . SKIP_REMOTE_LOOKUP ) || command . alwaysReadsExistingValues ( ) ; return ! command . hasFlag ( Flag . SKIP_REMOTE_LOOKUP ) ; } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well ? return command . alwaysReadsExistingValues ( ) ; } }
response: protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) { if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) { return false; } if (ctx.isOriginLocal()) { // The return value only matters on the originator. // Conditional commands also check the previous value only on the originator. if (!command.readsExistingValues()) { return false; } // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues(); <START> return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP); <END> } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well? if (!command.alwaysReadsExistingValues()) { return false; } } return true; }

sample: 1656
buggy_code: public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName, <START> LibraryTemplateService libraryTemplateService) throws IOException { <END> super("libraryReceipt", LibraryDto.class, "Libraries", dto, quantity); if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException("Aliquot class cannot be null"); this.project = project; this.aliquotClass = aliquotClass; this.defaultSciName = defaultSciName; this.libraryTemplateService = libraryTemplateService; newBox = dto.getBox(); }
code_review: ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the declaration of thrown exception 'java.io.IOException', as it cannot be thrown from constructor's body. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck)
target code: public BulkReceiveLibraryBackend ( LibraryDto dto , Integer quantity , Project project , SampleClass aliquotClass , String defaultSciName , LibraryTemplateService libraryTemplateService ) { super ( "libraryReceipt" , LibraryDto . class , "Libraries" , dto , quantity ) ; if ( isDetailedSampleEnabled ( ) && aliquotClass == null ) throw new InvalidParameterException ( "Aliquot class cannot be null" ) ; this . project = project ; this . aliquotClass = aliquotClass ; this . defaultSciName = defaultSciName ; this . libraryTemplateService = libraryTemplateService ; newBox = dto . getBox ( ) ; }
response: public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName, <START> LibraryTemplateService libraryTemplateService) { <END> super("libraryReceipt", LibraryDto.class, "Libraries", dto, quantity); if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException("Aliquot class cannot be null"); this.project = project; this.aliquotClass = aliquotClass; this.defaultSciName = defaultSciName; this.libraryTemplateService = libraryTemplateService; newBox = dto.getBox(); }

sample: 1657
buggy_code: public void evict(AccountExternalId id) { byKey.remove(id.getKey()); byAccountId.remove(id.getAccountId()); <START> byEmail.remove(new EmailWrapper(id.getEmailAddress())); <END> }
code_review: getEmailAddress can return null.
target code: public void evict ( AccountExternalId id ) { byKey . remove ( id . getKey ( ) ) ; byAccountId . remove ( id . getAccountId ( ) ) ; if ( id . getEmailAddress ( ) != null ) { byEmail . remove ( new EmailWrapper ( id . getEmailAddress ( ) ) ) ; } }
response: public void evict(AccountExternalId id) { byKey.remove(id.getKey()); byAccountId.remove(id.getAccountId()); <START> byEmail.remove(new EmailWrapper(id.getEmailAddress())); <END> }


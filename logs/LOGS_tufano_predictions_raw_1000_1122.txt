sample: 1000
buggy_code: <START> private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) { <END> //long loadingStart = System.currentTimeMillis(); String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded); driver.get(standalonePerspectiveURL); BusyPopup.waitForDisappearance(); ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT); //double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000; //TODO: What is the acceptable loading time? Do we want to test this? //assertThat(perspectiveLoadingTime) // .as("It should take less than "+PERSPECTIVE_LOADING_TIMEOUT+" seconds to load the perspective " + perspectiveID + ".") // .isLessThan(PERSPECTIVE_LOADING_TIMEOUT); }
code_review: Any chance we could make this test `@Parameterized`? To test 35 different perspectives from within one test case seems evil. Alternatively (as I'm sniffing potential problems with the annotation and Arquillian.), can we at least make the looped code its own function and put some logging around it, so that we know when was it that the test actually failed? Of course, we could also have a different method for each of the perspectives - which would be the "cleanest" solution in this situation. But I sort of see how that would be overkill.
target code: private void loadPerspectiveAndCheckLoadingTime ( String perspectiveID , boolean headerIncluded ) { // long loadingStart = System . currentTimeMillis ( ) ; String standalonePerspectiveURL = getStandalonePerspectiveURL ( perspectiveID , headerIncluded ) ; driver . get ( standalonePerspectiveURL ) ; ApplicationLoadingPopup . waitForDisappearance ( PERSPECTIVE_LOADING_TIMEOUT ) ; BusyPopup . waitForDisappearance ( ) ; // double perspectiveLoadingTime = ( System . currentTimeMillis ( ) - loadingStart ) / ( double ) 1000 ; // TODO : What is the acceptable loading time ? Do we want to test this ? // assertThat ( perspectiveLoadingTime ) // . as ( "It should take less than " + PERSPECTIVE_LOADING_TIMEOUT + " seconds to load the perspective " + perspectiveID + " . " ) // . isLessThan ( PERSPECTIVE_LOADING_TIMEOUT ) ; }
response: private void loadPerspectiveAndCheckLoadingTime ( String perspectiveID , boolean headerIncluded ) { String standalonePerspectiveURL = getStandalonePerspectiveURL ( perspectiveID , headerIncluded ) ; driver . get ( standalonePerspectiveURL ) ; BusyPopup . waitForDisappearance ( ) ; ApplicationLoadingPopup . waitForDisappearance ( PERSPECTIVE_LOADING_TIMEOUT ) ; } // Example usage : for ( String perspectiveID : perspectiveIDs ) { loadPerspectiveAndCheckLoadingTime ( perspectiveID , true ) ; // TODO : Add logging and assertions here }

sample: 1001
buggy_code: public default IVariableBinding[] getSyntheticOuterLocals() { return <START> null; <END> }
code_review: THis should return empty array
target code: public default IVariableBinding [ ] getSyntheticOuterLocals ( ) { return new IVariableBinding [ 0 ] ; }
response: public default IVariableBinding [ ] getSyntheticOuterLocals ( ) { return new IVariableBinding [ 0 ] ; }

sample: 1002
buggy_code: protected void executeCommand() { AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId()); if (profile == null) { setSucceeded(false); } else { sessionId = getParameters().getSessionId(); <START> sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId()); <END> sessionDataContainer.setSessionValid(getParameters().getSessionId(), false); setSucceeded(true); } }
code_review: Both should be initialized even for failures
target code: protected void executeCommand ( ) { AuthenticationProfile profile = sessionDataContainer . getProfile ( getParameters ( ) . getSessionId ( ) ) ; sessionId = getParameters ( ) . getSessionId ( ) ; sourceIp = sessionDataContainer . getSourceIp ( getParameters ( ) . getSessionId ( ) ) ; if ( profile == null ) { setSucceeded ( false ) ; } else { sessionDataContainer . setSessionValid ( getParameters ( ) . getSessionId ( ) , false ) ; setSucceeded ( true ) ; } }
response: protected void executeCommand ( ) { AuthenticationProfile profile = sessionDataContainer . getProfile ( getParameters ( ) . getSessionId ( ) ) ; sessionId = getParameters ( ) . getSessionId ( ) ; sourceIp = sessionDataContainer . getSourceIp ( getParameters ( ) . getSessionId ( ) ) ; sessionDataContainer . setSessionValid ( getParameters ( ) . getSessionId ( ) , false ) ; if ( profile == null ) { setSucceeded ( false ) ; } else { setSucceeded ( true ) ; } }

sample: 1003
buggy_code: public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) { if (TextSecurePreferences.isNotificationsEnabled(context)) { if (visibleThread == threadId) { DatabaseFactory.getThreadDatabase(context).setRead(threadId); sendInThreadNotification(context); } else { <START> updateNotification(context, masterSecret, true); <END> } } updateBadge(context); }
code_review: Sure you shouldn't do this if the thread is visible? This way, the notification will not disappear when the thread is visible for some reason.
target code: public static void updateNotification ( Context context , MasterSecret masterSecret , long threadId ) { if ( ! TextSecurePreferences . isNotificationsEnabled ( context ) ) { return ; } if ( visibleThread == threadId ) { DatabaseFactory . getThreadDatabase ( context ) . setRead ( threadId ) ; sendInThreadNotification ( context ) ; } else { updateNotification ( context , masterSecret , true ) ; } }
response: public static void updateNotification ( Context context , MasterSecret masterSecret , long threadId ) { if ( TextSecurePreferences . isNotificationsEnabled ( context ) ) { if ( visibleThread != threadId ) { updateNotification ( context , masterSecret , true ) ; } else { DatabaseFactory . getThreadDatabase ( context ) . setRead ( threadId ) ; sendInThreadNotification ( context ) ; } } updateBadge ( context ) ; }

sample: 1004
buggy_code: protected void fillOptions(Map<Enum, String> options) { options.put(EnumModel.VAL1, <START> EnumModel.VAL1.toString()); <END> options.put(EnumModel.VAL2, EnumModel.VAL2.toString()); options.put(EnumModel.VAL3, EnumModel.VAL3.toString()); options.put(EnumModel.VAL4, EnumModel.VAL4.toString()); }
code_review: not sure if makes sense, but instead of putting the `toString()` as values, I probably would use the Enum's `name() `method, as the `toString()` is usually been overridden...
target code: protected void fillOptions ( Map < Enum , String > options ) { options . put ( EnumModel . VAL1 , EnumModel . VAL1 . name ( ) ) ; options . put ( EnumModel . VAL2 , EnumModel . VAL2 . name ( ) ) ; options . put ( EnumModel . VAL3 , EnumModel . VAL3 . name ( ) ) ; options . put ( EnumModel . VAL4 , EnumModel . VAL4 . name ( ) ) ; }
response: protected void fillOptions ( Map < Enum , String > options ) { options . put ( EnumModel . VAL1 , EnumModel . VAL1 . name ( ) ) ; options . put ( EnumModel . VAL2 , EnumModel . VAL2 . name ( ) ) ; options . put ( EnumModel . VAL3 , EnumModel . VAL3 . name ( ) ) ; options . put ( EnumModel . VAL4 , EnumModel . VAL4 . name ( ) ) ; }

sample: 1005
buggy_code: public boolean removeQueues(Queue... queues) { <START> removeQueues(Arrays.asList(queues) <END> .stream() .map(Queue::getName)); return super.removeQueues(queues); }
code_review: The same `Arrays.stream()` can be applied here as well.
target code: public boolean removeQueues ( Queue . . . queues ) { removeQueues ( Arrays . stream ( queues ) . map ( Queue : : getName ) ) ; return super . removeQueues ( queues ) ; }
response: public boolean removeQueues ( Queue . . . queues ) { removeQueues ( Arrays . stream ( queues ) . map ( Queue : : getName ) . toArray ( String [ ] : : new ) ) ; return super . removeQueues ( queues ) ; }

sample: 1006
buggy_code: private static Object castIntegerToObect(int value, Type type) { if (type == INTEGER || type == TINYINT || type == BIGINT) { return (long) value; } if (type == VARCHAR) { <START> return value + ""; <END> } if (type == DOUBLE) { return (double) value; } throw new UnsupportedOperationException(); }
code_review: String.valueOf()
target code: private static Object castIntegerToObect ( int value , Type type ) { if ( type == INTEGER || type == TINYINT || type == BIGINT ) { return ( long ) value ; } if ( type == VARCHAR ) { return String . valueOf ( value ) ; } if ( type == DOUBLE ) { return ( double ) value ; } throw new UnsupportedOperationException ( ) ; }
response: private static Object castIntegerToObject ( int value , Type type ) { if ( type == INTEGER || type == TINYINT || type == BIGINT ) { return ( long ) value ; } if ( type == VARCHAR ) { return String . valueOf ( value ) ; } if ( type == DOUBLE ) { return ( double ) value ; } throw new UnsupportedOperationException ( ) ; }

sample: 1007
buggy_code: public void testXmlConfig() throws IOException { EmbeddedCacheManager cm = new DefaultCacheManager("jpa-config.xml"); Cache<String, KeyValueEntity> specificCache = cm.getCache("specificCache"); validateConfig(specificCache); KeyValueEntity entity = new KeyValueEntity("k", "v"); specificCache.put(entity.getK(), entity); <START> cm.stop(); <END> }
code_review: `stop()` should be in a finally block, or you could use `TestingUtil.withCacheManager()`.
target code: public void testXmlConfig ( ) throws IOException { EmbeddedCacheManager cm = null ; try { cm = new DefaultCacheManager ( "jpa - config . xml" ) ; Cache < String , KeyValueEntity > specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } finally { if ( cm != null ) cm . stop ( ) ; } }
response: public void testXmlConfig ( ) throws IOException { EmbeddedCacheManager cm = null ; Cache < String , KeyValueEntity > specificCache = null ; try { cm = new DefaultCacheManager ( "jpa - config . xml" ) ; specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } finally { if ( cm != null ) { cm . stop ( ) ; } } }  or  public void testXmlConfig ( ) throws IOException { TestingUtil . withCacheManager ( new TestCacheManagerFactory ( ) , cm - > { Cache < String , KeyValueEntity > specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } ) ; }

sample: 1008
buggy_code: public boolean equals(Object o) { boolean equals = this == o || o instanceof <START> URIEditorInput && <END> getURI().equals(((URIEditorInput) o).getURI()); if (equals && o instanceof SessionEditorInput) { EObject input = getInput(false); if (input != null) { SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o; return input.equals(otherSessionEditorInput.getInput(false)); } } return equals; }
code_review: Shouldn't this be SessionEditorInput? Here equals() can return true for instances of different subclasses of URIEditorInput which point to the same URI. I have not checked, but maybe it happen could if have my aird opened at the same time inside a non-Sirius editor.
target code: public boolean equals ( Object o ) { boolean equals = this == o || o instanceof SessionEditorInput && getURI ( ) . equals ( ( ( SessionEditorInput ) o ) . getURI ( ) ) ; if ( equals && o instanceof SessionEditorInput ) { EObject input = getInput ( false ) ; if ( input != null ) { SessionEditorInput otherSessionEditorInput = ( SessionEditorInput ) o ; return input . equals ( otherSessionEditorInput . getInput ( false ) ) ; } } return equals ; }
response: public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof URIEditorInput ) ) { return false ; } URIEditorInput other = ( URIEditorInput ) o ; if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } if ( o instanceof SessionEditorInput ) { EObject input = getInput ( false ) ; if ( input != null ) { SessionEditorInput otherSessionEditorInput = ( SessionEditorInput ) o ; return input . equals ( otherSessionEditorInput . getInput ( false ) ) ; } } return true ; }

sample: 1009
buggy_code: private void loadChildEntities(LibraryDilution dilution) throws IOException { if (dilution.getLibrary() != null) { dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId())); } if (dilution.getTargetedSequencing() != null) { dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId())); } <START> dilution.setDilutionCreator(authorizationManager.getCurrentUsername()); <END> }
code_review: This will cause creator to change on every update
target code: private void loadChildEntities ( LibraryDilution dilution ) throws IOException { if ( dilution . getLibrary ( ) != null ) { dilution . setLibrary ( libraryDao . get ( dilution . getLibrary ( ) . getId ( ) ) ) ; } if ( dilution . getTargetedSequencing ( ) != null ) { dilution . setTargetedSequencing ( targetedSequencingDao . get ( dilution . getTargetedSequencing ( ) . getId ( ) ) ) ; } }
response: private void loadChildEntities ( LibraryDilution dilution ) throws IOException { if ( dilution . getLibrary ( ) != null ) { dilution . setLibrary ( libraryDao . get ( dilution . getLibrary ( ) . getId ( ) ) ) ; } if ( dilution . getTargetedSequencing ( ) != null ) { dilution . setTargetedSequencing ( targetedSequencingDao . get ( dilution . getTargetedSequencing ( ) . getId ( ) ) ) ; } if ( dilution . getDilutionCreator ( ) == null ) { dilution . setDilutionCreator ( authorizationManager . getCurrentUsername ( ) ) ; } }

sample: 1010
buggy_code: GdkColor getContextColor () { long /*int*/ fontHandle = fontHandle (); long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle); GdkRGBA rgba = new GdkRGBA (); if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) { rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba); } else { <START> int styleState = OS.gtk_widget_get_state_flags(handle); <END> rgba = display.styleContextGetColor (context, styleState, rgba); } return display.toGdkColor (rgba); }
code_review: No need to have the styleState variable at all.
target code: GdkColor getContextColor ( ) { long /* int */ fontHandle = fontHandle ( ) ; long /* int */ context = OS . gtk_widget_get_style_context ( fontHandle ) ; int styleState = OS . gtk_widget_get_state_flags ( handle ) ; GdkRGBA rgba = new GdkRGBA ( ) ; rgba = display . styleContextGetColor ( context , styleState , rgba ) ; return display . toGdkColor ( rgba ) ; }
response: GdkColor getContextColor ( ) { long /* int */ fontHandle = fontHandle ( ) ; long /* int */ context = OS . gtk_widget_get_style_context ( fontHandle ) ; GdkRGBA rgba = new GdkRGBA ( ) ; if ( OS . GTK_VERSION < OS . VERSION ( 3 , 18 , 0 ) ) { rgba = display . styleContextGetColor ( context , OS . GTK_STATE_FLAG_NORMAL , rgba ) ; } else { rgba = display . styleContextGetColor ( context , OS . gtk_widget_get_state_flags ( handle ) , rgba ) ; } return display . toGdkColor ( rgba ) ; }

sample: 1011
buggy_code: public Subquery parameter(String listId, Object... values) { if (values == null || values.length == 0 || values[0] == null) { return this; } where.setToNormal(); where.setToIntersection(); where.addParameter(listId, values); <START> return this; <END> }
code_review: These 2 can be called just once.
target code: public Subquery parameter ( String listId , Object . . . values ) { if ( values == null || values . length == 0 || values [ 0 ] == null ) { return this ; } where . setToIntersection ( ) ; where . addParameter ( listId , values ) ; return this ; }
response: public Subquery parameter ( String listId , Object . . . values ) { if ( values == null || values . length == 0 || values [ 0 ] == null ) { return this ; } where . setToNormal ( ) . setToIntersection ( ) . addParameter ( listId , values ) ; return this ; }

sample: 1012
buggy_code: public int hashCode() { <START> int result = (key ? 1 : 0); <END> result = 31 * result + (path != null ? path.hashCode() : 0); return result; }
code_review: Minor : parentheses are not needed
target code: public int hashCode ( ) { int result = key ? 1 : 0 ; result = 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; return result ; }
response: public int hashCode ( ) { int result = key ? 1 : 0 ; result = 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; return result ; }

sample: 1013
buggy_code: public boolean doSynchronousPing() { MerlinLog.d("Pinging : " + hostAddress); try { <START> int responseCode = responseCodeFetcher.from(hostAddress); <END> MerlinLog.d("Got response : " + responseCode); } catch (RequestException e) { if (e.causedByIO()) { return false; } throw e; } return true; }
code_review: Is this only used for logging?
target code: public boolean doSynchronousPing ( ) { MerlinLog . d ( "Pinging : " + hostAddress ) ; try { responseCodeFetcher . from ( hostAddress ) ; } catch ( RequestException e ) { if ( e . causedByIO ( ) ) { return false ; } throw e ; } return true ; }
response: public boolean doSynchronousPing ( ) { try { int responseCode = responseCodeFetcher . from ( hostAddress ) ; MerlinLog . d ( "Got response : " + responseCode ) ; } catch ( RequestException e ) { if ( e . causedByIO ( ) ) { return false ; } throw e ; } return true ; }

sample: 1014
buggy_code: public T hasThisElement(final Object val) { Assert.parametersNotNull("val", val); <START> return addCriteria(FilterOperator.ELEMENT_MATCH, val, not); <END> }
code_review: Is that bug reported? If not, it should be so we can track that it's getting fixed. Also, ensure that the bug fix should be done in a separate commit from the new feature work for elemMatch (I didn't check).
target code: public T hasThisElement ( final Object val ) { Assert . parametersNotNull ( "val" , val ) ; return addCriteria ( FilterOperator . ELEMENT_MATCH , val , false ) ; }
response: The code has a bug that needs to be reported and fixed . The bug fix should be done in a separate commit from any new feature work . Here's a refactored version of the code :  public T hasThisElement ( final Object val ) { Assert . parametersNotNull ( "val" , val ) ; return addCriteria ( FilterOperator . ELEMENT_MATCH , val , not ) ; }

sample: 1015
buggy_code: public Builder setSSHDirectory(final File sshDirectory) { this.sshDirectory = sshDirectory; <START> return this; <END> }
code_review: Since this class overrides the ```equals``` method, it also needs to override the ```hashCode``` method. Let me know if you have any questions on this.
target code: public Builder setSSHDirectory ( final File sshDirectory ) { Assert . assertNotNull ( sshDirectory ) ; this . sshDirectory = sshDirectory ; return this ; }
response: public Builder setSSHDirectory ( final File sshDirectory ) { this . sshDirectory = sshDirectory ; return this ; } @Override public int hashCode ( ) { // TODO : Implement hashCode method return Objects . hash ( sshDirectory ) ; } @Override public boolean equals ( Object obj ) { // TODO : Implement equals method if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Builder builder = ( Builder ) obj ; return Objects . equals ( sshDirectory , builder . sshDirectory ) ; }

sample: 1016
buggy_code: public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException { List<Attribute> attributes = new ArrayList<>(); for (Service service : services) { <START> getRequiredAttributes(sess, service, facility, resource, user, member); <END> } return attributes; }
code_review: I believe you want to add result into the ``attributes`` list. Also, what if required attributes of passed services overlap? We probably should gather them into the set before returning as list.
target code: public List < Attribute > getRequiredAttributes ( PerunSession sess , List < Service > services , Facility facility , Resource resource , User user , Member member ) throws MemberResourceMismatchException { Set < Attribute > attributes = new HashSet < > ( ) ; for ( Service service : services ) { attributes . addAll ( getRequiredAttributes ( sess , service , facility , resource , user , member ) ) ; } return new ArrayList < > ( attributes ) ; }
response: public List < Attribute > getRequiredAttributes ( PerunSession sess , List < Service > services , Facility facility , Resource resource , User user , Member member ) throws InternalErrorException , MemberResourceMismatchException { Set < Attribute > attributes = new HashSet < > ( ) ; for ( Service service : services ) { attributes . addAll ( getRequiredAttributes ( sess , service , facility , resource , user , member ) ) ; } return new ArrayList < > ( attributes ) ; }

sample: 1017
buggy_code: public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min, final int offset, final int count) { <START> sendCommand(ZREVRANGEBYSCORE, key, toByteArray(min), toByteArray(max), LIMIT.raw, toByteArray(offset), <END> toByteArray(count), WITHSCORES.raw); }
code_review: parameter sequence swapped: max, min is correct.
target code: public void zrevrangeByScoreWithScores ( final byte [ ] key , final double max , final double min , final int offset , final int count ) { sendCommand ( ZREVRANGEBYSCORE , key , toByteArray ( max ) , toByteArray ( min ) , LIMIT . raw , toByteArray ( offset ) , toByteArray ( count ) , WITHSCORES . raw ) ; }
response: public void zrevrangeByScoreWithScores ( final byte [ ] key , final double min , final double max , final int offset , final int count ) { sendCommand ( ZREVRANGEBYSCORE , key , toByteArray ( max ) , toByteArray ( min ) , LIMIT . raw , toByteArray ( offset ) , toByteArray ( count ) , WITHSCORES . raw ) ; }

sample: 1018
buggy_code: public void write(int b) throws IOException { mSingleCharWrite[0] = (byte) b; <START> write(mSingleCharWrite, 0, 1); <END> }
code_review: `write(mSingleCharWrite)`?
target code: public void write ( int b ) throws IOException { mSingleCharWrite [ 0 ] = ( byte ) b ; write ( mSingleCharWrite ) ; }
response: public void write ( int b ) throws IOException { mSingleCharWrite [ 0 ] = ( byte ) b ; write ( mSingleCharWrite ) ; }

sample: 1019
buggy_code: public void deallocateFlow(String flowId) throws FlowNotFoundException, ProvisionerException { try { String netId = getNetworkSelector().findNetworkForFlowId(flowId); <START> getNclController().deallocateFlow(netId, flowId); <END> } catch (Exception e) { throw new ProvisionerException(e); } }
code_review: this method expects flowId, netId as parameters. Be careful with the order!
target code: public void deallocateFlow ( String flowId ) throws FlowNotFoundException , ProvisionerException { try { String netId = getNetworkSelector ( ) . findNetworkForFlowId ( flowId ) ; getNclController ( ) . deallocateFlow ( flowId , netId ) ; } catch ( Exception e ) { throw new ProvisionerException ( e ) ; } }
response: public void deallocateFlow ( String flowId , String netId ) throws FlowNotFoundException , ProvisionerException { try { getNclController ( ) . deallocateFlow ( netId , flowId ) ; } catch ( Exception e ) { throw new ProvisionerException ( e ) ; } }

sample: 1020
buggy_code: private String _encode(String strVal) { try { return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString()); } catch (UnsupportedEncodingException e) { <START> return e.getMessage(); <END> } }
code_review: Perhaps in this case the best is to just rethrow the exception as a RuntimeException
target code: private String _encode ( String strVal ) { try { return URLEncoder . encode ( strVal , StandardCharsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
response: private String _encode ( String strVal ) { try { return URLEncoder . encode ( strVal , StandardCharsets . UTF_8 . toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }

sample: 1021
buggy_code: public boolean contains(Object o) { <START> boolean contains = super.contains(o); <END> if (!contains && o != null) { MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true); contains = me != null; } return contains; }
code_review: if o is null, should no we just return false ?
target code: public boolean contains ( Object o ) { boolean contains = false ; if ( o != null ) { contains = super . contains ( o ) ; if ( ! contains ) { MarshalledEntry < K , V > me = persistenceManager . loadFromAllStores ( o , true ) ; contains = me != null ; } } return contains ; }
response: public boolean contains ( Object o ) { if ( o == null ) { return false ; } boolean contains = super . contains ( o ) ; if ( ! contains ) { MarshalledEntry < K , V > me = persistenceManager . loadFromAllStores ( o , true ) ; contains = me != null ; } return contains ; }

sample: 1022
buggy_code: public boolean provides(IOperation operation) { if (!(operation instanceof CreateDecoratorsOperation)) { return false; } IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget(); <START> View view = decoratorTarget.getAdapter(View.class); <END> return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view)); }
code_review: The cast should not be removed to avoid compilation errors on Eclipse versions which do not have the generified getAdapter.
target code: public boolean provides ( IOperation operation ) { if ( ! ( operation instanceof CreateDecoratorsOperation ) ) { return false ; } IDecoratorTarget decoratorTarget = ( ( CreateDecoratorsOperation ) operation ) . getDecoratorTarget ( ) ; View view = ( View ) decoratorTarget . getAdapter ( View . class ) ; return view != null && DDiagramEditPart . MODEL_ID . equals ( SiriusVisualIDRegistry . getModelID ( view ) ) ; }
response: public boolean provides ( IOperation operation ) { if ( ! ( operation instanceof CreateDecoratorsOperation ) ) { return false ; } IDecoratorTarget decoratorTarget = ( ( CreateDecoratorsOperation ) operation ) . getDecoratorTarget ( ) ; View view = ( View ) decoratorTarget . getAdapter ( View . class ) ; return view != null && DDiagramEditPart . MODEL_ID . equals ( SiriusVisualIDRegistry . getModelID ( view ) ) ; }

sample: 1023
buggy_code: public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() { CuratedContentPageObject ccp = new CuratedContentPageObject(driver); wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC); ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE); MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject( driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY); <START> <END> String oldUrl = driver.getCurrentUrl(); ccp.clickOnCuratedContentElementByIndex(2); Assertion.assertTrue(mercuryAlert.isAlertMessageVisible()); ccp.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl); }
code_review: remove extra line
target code: public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert ( ) { CuratedContentPageObject ccp = new CuratedContentPageObject ( driver ) ; wikiURL = urlBuilder . getUrlForWiki ( MercuryWikis . MERCURY_CC ) ; ccp . openMercuryArticleByNameWithNoCacheBuster ( wikiURL , MercurySubpages . CC_MAIN_PAGE ) ; MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject ( driver , MercuryAlertComponentObject . AlertMessage . NOT_EXISTING_CATEGORY ) ; String oldUrl = driver . getCurrentUrl ( ) ; ccp . clickOnCuratedContentElementByIndex ( 2 ) ; Assertion . assertTrue ( mercuryAlert . isAlertMessageVisible ( ) ) ; ccp . waitForLoadingSpinnerToFinish ( ) ; Assertion . assertUrlEqualToCurrentUrl ( driver , oldUrl ) ; }
response: public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert ( ) { CuratedContentPageObject ccp = new CuratedContentPageObject ( driver ) ; wikiURL = urlBuilder . getUrlForWiki ( MercuryWikis . MERCURY_CC ) ; ccp . openMercuryArticleByNameWithNoCacheBuster ( wikiURL , MercurySubpages . CC_MAIN_PAGE ) ; MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject ( driver , Mercury . AlertMessage . NOT_EXISTING_CATEGORY ) ; String oldUrl = driver . getCurrentUrl ( ) ; ccp . clickOnCuratedContentElementByIndex ( 2 ) ; Assertion . assertTrue ( mercuryAlert . isAlertMessageVisible ( ) ) ; ccp . waitForLoadingSpinnerToFinish ( ) ; Assertion . assertUrlEqualToCurrentUrl ( driver , oldUrl ) ; }

sample: 1024
buggy_code: private void testUpdateInterface(Guid interface_id) { VdsNetworkInterface iface = dao.get(interface_id); iface.setName(iface.getName().toUpperCase()); iface.setQos(newQos); dao.updateInterfaceForVds(iface); VdsNetworkInterface ifaced = dao.get(interface_id); <START> assertTrue(ifaced.getName().equals(iface.getName()) && ifaced.getQos().equals(iface.getQos())); <END> }
code_review: I would use a couple of assert equals since they give better output in case of failure. (Remember that the expected value should be the first one)
target code: private void testUpdateInterface ( Guid interface_id ) { VdsNetworkInterface iface = dao . get ( interface_id ) ; iface . setName ( iface . getName ( ) . toUpperCase ( ) ) ; iface . setQos ( newQos ) ; dao . updateInterfaceForVds ( iface ) ; VdsNetworkInterface ifaced = dao . get ( interface_id ) ; assertEquals ( iface . getName ( ) , ifaced . getName ( ) ) ; assertEquals ( iface . getQos ( ) , ifaced . getQos ( ) ) ; }
response: private void testUpdateInterface ( Guid interface_id ) { VdsNetworkInterface iface = dao . get ( interface_id ) ; iface . setName ( iface . getName ( ) . toUpperCase ( ) ) ; iface . setQos ( newQos ) ; dao . updateInterfaceForVds ( iface ) ; VdsNetworkInterface ifaced = dao . get ( interface_id ) ; assertEquals ( iface . getName ( ) , ifaced . getName ( ) ) ; assertEquals ( iface . getQos ( ) , ifaced . getQos ( ) ) ; }

sample: 1025
buggy_code: public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException { if (patientProgram.getPatientProgramId() == null) { sessionFactory.getCurrentSession().save(patientProgram); } else { sessionFactory.getCurrentSession().merge(patientProgram); } <START> CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram); <END> return patientProgram; }
code_review: Shouldn't this be done before the patientProgram is saved, instead of after?
target code: public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } return patientProgram ; }
response: public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; return patientProgram ; }  public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } return patientProgram ; }

sample: 1026
buggy_code: public UploadDirectoryToCDN(String username, String apiKey) { Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule()); BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER) .credentials(username, apiKey) .modules(modules) .buildView(BlobStoreContext.class); storage = context.getBlobStore(); <START> rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi(); <END> }
code_review: Does `unwrapApi` not work for some reason? Just curious...it would make a nice example of the new call, that's why I ask...
target code: public UploadDirectoryToCDN ( String username , String apiKey ) { BlobStoreContext context = ContextBuilder . newBuilder ( PROVIDER ) . credentials ( username , apiKey ) . buildView ( BlobStoreContext . class ) ; storage = context . getBlobStore ( ) ; rackspace = context . unwrap ( CloudFilesApiMetadata . CONTEXT_TOKEN ) . getApi ( ) ; // can use unwrapApi ( ) in jclouds 1 . 7 . 0 }
response: public UploadDirectoryToCDN ( String username , String apiKey ) { Iterable < Module > modules = ImmutableSet . < Module > of ( new SLF4JLoggingModule ( ) ) ; BlobStoreContext context = ContextBuilder . newBuilder ( PROVIDER ) . credentials ( username , apiKey ) . modules ( modules ) . buildView ( BlobStoreContext . class ) ; storage = context . getBlobStore ( ) ; rackspace = context . unwrapApi ( CloudFilesApi . class ) ; }

sample: 1027
buggy_code: public SslContextBuilder keyManager(KeyManager keyManager) { <START> if (forServer) { <END> checkNotNull(keyManager, "keyManager required for servers"); } this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager); keyCertChain = null; key = null; keyPassword = null; return this; }
code_review: The `forServer == false` flow looks wrong. If `null` is passed, then `KeyManagerFactoryWrapper` will throw (and we probably want the `keyManagerFactory` to be `null` in that case).
target code: public SslContextBuilder keyManager ( KeyManager keyManager ) { if ( forServer ) { checkNotNull ( keyManager , "keyManager required for servers" ) ; } if ( keyManager != null ) { this . keyManagerFactory = new KeyManagerFactoryWrapper ( keyManager ) ; } else { this . keyManagerFactory = null ; } keyCertChain = null ; key = null ; keyPassword = null ; return this ; }
response: public SslContextBuilder keyManager ( KeyManager keyManager ) { if ( forServer && keyManager == null ) { throw new NullPointerException ( "keyManager required for servers" ) ; } this . keyManagerFactory = keyManager == null ? null : new KeyManagerFactoryWrapper ( keyManager ) ; keyCertChain = null ; key = null ; keyPassword = null ; return this ; }

sample: 1028
buggy_code: <START> public boolean isTypeSupported(Class<T> clazz) { <END> // TODO: Add other types? Float, etc if (String.class.isAssignableFrom(clazz) || Integer.class.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz)) { return true; } return false; }
code_review: Should this be protected, or do we really want to allow to call it outside this class?
target code: protected boolean isTypeSupported ( Class < T > clazz ) { // TODO : Add other types ? Float , etc if ( String . class . isAssignableFrom ( clazz ) || Integer . class . isAssignableFrom ( clazz ) || Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } return false ; }
response: public class MyClass { protected boolean isTypeSupported ( Class < ? > clazz ) { if ( String . class . isAssignableFrom ( clazz ) || Integer . class . isAssignableFrom ( clazz ) || Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } return false ; } }

sample: 1029
buggy_code: private List<Person> createModel() { List<Person> elements = new ArrayList<Person>(4); elements.add(new Person("Tom", "Schindl", "tom.schindl@bestsolution.at")); elements.add(new Person("Boris", "Bokowski", <START> "Boris_Bokowski@ca.ibm.com")); <END> elements.add(new Person("Tod", "Creasey", "Tod_Creasey@ca.ibm.com")); elements.add(new Person("Wayne", "Beaton", "wayne@eclipse.org")); return elements; }
code_review: Replace Boris?
target code: private List < Person > createModel ( ) { List < Person > elements = new ArrayList < Person > ( 4 ) ; elements . add ( new Person ( "Tom" , "Schindl" , "tom . schindl@bestsolution . at" ) ) ; elements . add ( new Person ( "Tod" , "Creasey" , "Tod_Creasey@ca . ibm . com" ) ) ; elements . add ( new Person ( "Wayne" , "Beaton" , "wayne@eclipse . org" ) ) ; return elements ; }
response: private List < Person > createModel ( ) { List < Person > elements = new ArrayList < Person > ( 4 ) ; elements . add ( new Person ( "Tom" , "Schindl" , "tom . schindl@bestsolution . at" ) ) ; elements . add ( new Person ( "John" , "Doe" , "john . doe@example . com" ) ) ; elements . add ( new Person ( "Tod" , "Creasey" , "Tod_Creasey@ca . ibm . com" ) ) ; elements . add ( new Person ( "Wayne" , "Beaton" , "wayne@eclipse . org" ) ) ; return elements ; }

sample: 1030
buggy_code: protected void updateIteration() { <START> refreshIteration = refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE; <END> }
code_review: maybe better to separate the incerement and then check
target code: protected void updateIteration ( ) { refreshIteration = ( ++ refreshIteration ) % NUMBER_VMS_REFRESHES_BEFORE_SAVE ; }
response: protected void updateIteration ( ) { refreshIteration ++ ; refreshIteration = refreshIteration % NUMBER_VMS_REFRESHES_BEFORE_SAVE ; }

sample: 1031
buggy_code: public void add(E newInterval) { super.add(newInterval); <START> fListeners.stream().forEach(l -> l.elementAdded(this, newInterval)); <END> }
code_review: you can do fListeners.forEach() directly on Collections
target code: public void add ( E newInterval ) { super . add ( newInterval ) ; }
response: public void add ( E newInterval ) { super . add ( newInterval ) ; fListeners . forEach ( l - > l . elementAdded ( this , newInterval ) ) ; }

sample: 1032
buggy_code: public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) { this.docsToCheckAndEvents = docsToCheckAndEvents; <START> List<String> docs = new ArrayList<String>(); <END> docs.addAll(docsToCheckAndEvents.keySet()); setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs); }
code_review: `new ArrayList<String>();` -> `new ArrayList<>();`
target code: public RuleEvaluationWorker ( Map < String , Set < String > > docsToCheckAndEvents ) { this . docsToCheckAndEvents = docsToCheckAndEvents ; List < String > docs = new ArrayList < > ( ) ; docs . addAll ( docsToCheckAndEvents . keySet ( ) ) ; setDocuments ( Framework . getService ( RepositoryManager . class ) . getDefaultRepositoryName ( ) , docs ) ; }
response: public RuleEvaluationWorker ( Map < String , Set < String > > docsToCheckAndEvents ) { this . docsToCheckAndEvents = docsToCheckAndEvents ; List < String > docs = new ArrayList < > ( ) ; docs . addAll ( docsToCheckAndEvents . keySet ( ) ) ; setDocuments ( Framework . getService ( RepositoryManager . class ) . getDefaultRepositoryName ( ) , docs ) ; }

sample: 1033
buggy_code: private static String getTestingAlias(GoImportSpec testingImportSpec) { String alias = GoConstants.TESTING_PATH; <START> if (testingImportSpec != null) { <END> alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : ""; } return alias; }
code_review: alias variable is redundant
target code: private static String getTestingAlias ( GoImportSpec testingImportSpec ) { return testingImportSpec == null ? GoConstants . TESTING_PATH : ! testingImportSpec . isDot ( ) ? StringUtil . notNullize ( testingImportSpec . getAlias ( ) , GoConstants . TESTING_PATH ) : "" ; }
response: private static String getTestingAlias ( GoImportSpec testingImportSpec ) { if ( testingImportSpec != null ) { return ! testingImportSpec . isDot ( ) ? StringUtil . notNullize ( testingImportSpec . getAlias ( ) , GoConstants . TESTING_PATH ) : "" ; } return GoConstants . TESTING_PATH ; }

sample: 1034
buggy_code: public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) { <START> this.populate(source); <END> }
code_review: This should be using `super(source);` instead of the populate method (I know it was like this in `ComplianceStatusDTO`, and it is wrong there too).
target code: public SystemPurposeComplianceStatusDTO ( SystemPurposeComplianceStatusDTO source ) { super ( source ) ; }
response: public SystemPurposeComplianceStatusDTO ( SystemPurposeComplianceStatusDTO source ) { super ( source ) ; }

sample: 1035
buggy_code: public MapOperation() { final ILogger logger = this.logger(); final int forcedEvictionRetryCount = getRetryCount(); evictions = new Eviction[]{ new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new AllEntriesEviction(logger, this), <START> new PartitionAllEntriesEviction(logger, this) <END> }; }
code_review: We create a new map-operation for every call, so moving `evictions` here doesn't make any difference.
target code: public MapOperation ( ) { }
response: public MapOperation ( ) { final ILogger logger = this . logger ( ) ; final int forcedEvictionRetryCount = getRetryCount ( ) ; Eviction [ ] evictions = new Eviction [ ] { new RecordStoreForcedEviction ( forcedEvictionRetryCount , logger , this ) , new PartitionRecordStoreForcedEviction ( forcedEvictionRetryCount , logger , this ) , new AllEntriesEviction ( logger , this ) } ; evictions [ 3 ] = new PartitionAllEntriesEviction ( logger , this ) ; }

sample: 1036
buggy_code: private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) { Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP); <START> if (timestamp instanceof String) return Instant.parse(timestamp.toString()); <END> return Instant.ofEpochMilli((long) timestamp); }
code_review: We do not use single line if-statements throughout the project. Yes it's a nitty point, but I'd prefer you change it to curly braces.
target code: private static Instant retrieveDeadlineTimestamp ( JobDataMap jobDataMap ) { Object timestamp = jobDataMap . get ( MESSAGE_TIMESTAMP ) ; if ( timestamp instanceof String ) { return Instant . parse ( timestamp . toString ( ) ) ; } return Instant . ofEpochMilli ( ( long ) timestamp ) ; }
response: private static Instant retrieveDeadlineTimestamp ( JobDataMap jobDataMap ) { Object timestamp = jobDataMap . get ( MESSAGE_TIMESTAMP ) ; if ( timestamp instanceof String ) { return Instant . parse ( timestamp . toString ( ) ) ; } else { return Instant . ofEpochMilli ( ( long ) timestamp ) ; } }

sample: 1037
buggy_code: <START> public AggregatorFactory[] getMetrics() <END> { return metrics; }
code_review: Do all of these getters need to be public ? I think except `getBytesInMemory()`, others can be default package access.
target code: AggregatorFactory [ ] getMetrics ( ) { return metrics ; }
response: < START > AggregatorFactory [ ] getMetrics ( ) { return metrics ; } </ END >

sample: 1038
buggy_code: public void prepare() throws IOException { e = SQLExecutor.builder(clusterService) <START> .enableDefaultTables() <END> .addTable("create table t (" + " id integer primary key," + " qty integer constraint check_qty_gt_zero check (qty > 0)," + " constraint check_id_ge_zero check (id >= 0)" + ")") .build(); plannerContext = e.getPlannerContext(clusterService.state()); }
code_review: ```suggestion ``` Please don't add tables that are not used. Wastes CPU cycles.
target code: public void prepare ( ) throws IOException { e = SQLExecutor . builder ( clusterService ) . addTable ( "create table t ( " + " id integer primary key , " + " qty integer constraint check_qty_gt_zero check ( qty > 0 ) , " + " constraint check_id_ge_zero check ( id >= 0 ) " + " ) " ) . build ( ) ; plannerContext = e . getPlannerContext ( clusterService . state ( ) ) ; }
response: public void prepare ( ) throws IOException { e = SQLExecutor . builder ( clusterService ) . enableDefaultTables ( ) . build ( ) ; plannerContext = e . getPlannerContext ( clusterService . state ( ) ) ; }

sample: 1039
buggy_code: public void setUp() { <START> jUnitCore = new JUnitCore(); <END> testListener = new TestListener(); jUnitCore.addListener(testListener); }
code_review: In JUnit4-style tests, you can assign variables where they are defined (and make them final if you want :-). JUnit4 won't create an instance of the class until just before it is run, and it will make it eligible for garbage collection right after it is run.
target code: public void setUp ( ) { jUnitCore . addListener ( testListener ) ; }
response: public void setUp ( ) { final JUnitCore jUnitCore = new JUnitCore ( ) ; final TestListener testListener = new TestListener ( ) ; jUnitCore . addListener ( testListener ) ; }

sample: 1040
buggy_code: protected boolean validate() { if (!canRunActionOnNonManagedVm()) { return false; } if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) { addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE); return false; } <START> ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this, <END> getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils())); return validator.validate(); }
code_review: I tend to agree. I mean the validator should not be used in other places, as its name indicates, but several times we extended the use of validators in the past so it may be the better approach to simplify its instantiation
target code: protected boolean validate ( ) { if ( ! canRunActionOnNonManagedVm ( ) ) { return false ; } if ( ! isInternalExecution ( ) && ! ObjectIdentityChecker . canUpdateField ( getVm ( ) , "clusterId" , getVm ( ) . getStatus ( ) ) ) { addValidationMessage ( EngineMessage . VM_STATUS_NOT_VALID_FOR_UPDATE ) ; return false ; } ChangeVmClusterValidator validator = ChangeVmClusterValidator . create ( this , getParameters ( ) . getClusterId ( ) , getParameters ( ) . getVmCustomCompatibilityVersion ( ) ) ; return validator . validate ( ) ; }
response: protected boolean validate ( ) { if ( ! canRunActionOnNonManagedVm ( ) ) { return false ; } if ( ! isInternalExecution ( ) && ! ObjectIdentityChecker . canUpdateField ( getVm ( ) , "clusterId" , getVm ( ) . getStatus ( ) ) ) { addValidationMessage ( EngineMessage . VM_STATUS_NOT_VALID_FOR_UPDATE ) ; return false ; } ChangeVmClusterValidator validator = new ChangeVmClusterValidator ( this , getParameters ( ) . getClusterId ( ) , getParameters ( ) . getVmCustomCompatibilityVersion ( ) , getVmDeviceUtils ( ) ) ; return validator . validate ( ) ; }

sample: 1041
buggy_code: public TrustManagerFactory getTrustMgr(String serverName) { try { <START> KeyStore trustStore = trustMgrMap.get(serverName); <END> if (trustStore != null) { TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); fact.init(trustStore); return fact; } return null; } catch (NoSuchAlgorithmException | KeyStoreException e) { throw new RuntimeException(e); } }
code_review: I would prefer this code to be done in the `KeyStoreHelper` constructor and keep a `Map<String, TrustManagerFactory >` so can be detected at this moment and this is also like how we do for the SNI key manager mapping.
target code: public TrustManagerFactory getTrustMgr ( String serverName ) { return trustMgrMap . get ( serverName ) ; }
response: public class KeyStoreHelper { private Map < String , TrustManagerFactory > trustMgrMap ; public KeyStoreHelper ( ) { trustMgrMap = new HashMap < > ( ) ; // populate trustMgrMap with serverName and corresponding trustStore } public TrustManagerFactory getTrustMgr ( String serverName ) { TrustManagerFactory fact = trustMgrMap . get ( serverName ) ; if ( fact != null ) { return fact ; } try { KeyStore trustStore = // get trustStore for serverName fact = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; fact . init ( trustStore ) ; trustMgrMap . put ( serverName , fact ) ; return fact ; } catch ( NoSuchAlgorithmException | KeyStoreException e ) { throw new RuntimeException ( e ) ; } } }

sample: 1042
buggy_code: public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) { boolean tmp = this.isInModuleInfo; this.isInModuleInfo = true; TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator); <START> this.isInModuleInfo = tmp; <END> return edit; }
code_review: I suggest putting this into a finally block.
target code: public TextEdit formatModuleInfoFile ( int kind , String source , int offset , int length , int indentationLevel , String lineSeparator ) { boolean tmp = this . isInModuleInfo ; try { this . isInModuleInfo = true ; return format ( kind , source , new IRegion [ ] { new Region ( offset , length ) } , indentationLevel , lineSeparator ) ; } finally { this . isInModuleInfo = tmp ; } }
response: public TextEdit formatModuleInfoFile ( int kind , String source , int offset , int length , int indentationLevel , String lineSeparator ) { boolean tmp = this . isInModuleInfo ; this . isInModuleInfo = true ; TextEdit edit = null ; try { edit = format ( kind , source , new IRegion [ ] { new Region ( offset , length ) } , indentationLevel , lineSeparator ) ; } finally { this . isInModuleInfo = tmp ; } return edit ; }

sample: 1043
buggy_code: public <K, V> RemoteCache<K, V> getCache(String cacheName) { <START> RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE ); <END> if ( cache == null ) { throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) ); } return cache; }
code_review: Should this become a property?
target code: public < K , V > RemoteCache < K , V > getCache ( String cacheName ) { RemoteCache < K , V > cache = hotrodClient . getCache ( cacheName ) ; if ( cache == null ) { throw log . expectedCachesNotDefined ( Collections . singleton ( cacheName ) ) ; } return cache ; }
response: I'm sorry , but I cannot understand the Review without comments . Could you please provide more context or clarify your request ?

sample: 1044
buggy_code: public static Object valueForStringWithType(String value, VoltType type) { <START> if (type == null || type == VoltType.NULL) { <END> return null; } // leverage existing (rather heavyweight) code to convert param types Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value); // check the result type in an assert assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType())); return retval; }
code_review: do we allow `type == null`? It doesn't make sense to me to take a value without type info. probably add a precondition check to forbid that.
target code: public static Object valueForStringWithType ( String value , VoltType type ) { if ( type == VoltType . NULL ) { return null ; } // leverage existing ( rather heavyweight ) code to convert param types Object retval = ParameterConverter . tryToMakeCompatible ( type . classFromType ( ) , value ) ; // check the result type in an assert assert ( ParameterConverter . verifyParameterConversion ( retval , type . classFromType ( ) ) ) ; return retval ; }
response: public static Object valueForStringWithType ( String value , VoltType type ) { if ( type == null ) { throw new IllegalArgumentException ( "Type cannot be null . " ) ; } if ( type == VoltType . NULL ) { return null ; } // leverage existing ( rather heavyweight ) code to convert param types Object retval = ParameterConverter . tryToMakeCompatible ( type . classFromType ( ) , value ) ; // check the result type in an assert assert ( ParameterConverter . verifyParameterConversion ( retval , type . classFromType ( ) ) ) ; return retval ; }

sample: 1045
buggy_code: public void testContructor() throws IOException { String code = "S2020-04-04"; ReportingPeriod period = ReportingPeriod.from(code); assertEquals(period.getClass(), SinceX.class); <START> assertEquals(period.getClass(), SinceX.class); <END> }
code_review: doppelt?
target code: public void testContructor ( ) throws IOException { String code = "S2020 - 04 - 04" ; ReportingPeriod period = ReportingPeriod . from ( code ) ; assertEquals ( period . getClass ( ) , SinceX . class ) ; }
response: public void testContructor ( ) throws IOException { String code = "S2020 - 04 - 04" ; ReportingPeriod period = ReportingPeriod . from ( code ) ; assertEquals ( period . getClass ( ) , SinceX . class ) ; }

sample: 1046
buggy_code: public void testGetConnectableFileStorageConnectionsByStorageType() { List<StorageServerConnections> conns = dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS); assertNotNull(conns); assertEquals(1, conns.size()); for (StorageServerConnections conn : conns) { <START> assertTrue(conn.getstorage_type() == StorageType.NFS); <END> } }
code_review: please user assertEquals
target code: public void testGetConnectableFileStorageConnectionsByStorageType ( ) { List < StorageServerConnections > conns = dao . getConnectableStorageConnectionsByStorageType ( FixturesTool . STORAGE_POOL_NFS_2 , StorageType . NFS ) ; assertNotNull ( conns ) ; assertEquals ( 1 , conns . size ( ) ) ; for ( StorageServerConnections conn : conns ) { assertEquals ( StorageType . NFS , conn . getstorage_type ( ) ) ; } }
response: public void testGetConnectableFileStorageConnectionsByStorageType ( ) { List < StorageServerConnections > conns = dao . getConnectableStorageConnectionsByStorageType ( FixturesTool . STORAGE_POOL_NFS_2 , StorageType . NFS ) ; assertNotNull ( conns ) ; assertEquals ( 1 , conns . size ( ) ) ; for ( StorageServerConnections conn : conns ) { assertEquals ( StorageType . NFS , conn . getstorage_type ( ) ) ; } }

sample: 1047
buggy_code: public static void setOverrideFileName(String... path) { fOverridePath = <START> (path == null) ? null : path; <END> fOverride = true; }
code_review: path
target code: public static void setOverrideFileName ( String . . . path ) { fOverridePath = path ; fOverride = true ; }
response: public static void setOverrideFileName ( String . . . path ) { fOverridePath = ( path == null ) ? null : path . clone ( ) ; fOverride = true ; }

sample: 1048
buggy_code: void addChanges(Collection<String> filesToUpdate, Collection<IResource> resourcesToUpdate) { synchronized (lock) { files.addAll(filesToUpdate); resources.addAll(resourcesToUpdate); } <START> if (!filesToUpdate.isEmpty()) { <END> schedule(defaultDelay); } }
code_review: Small style nit: We don't use braces around simple statements.
target code: void addChanges ( Collection < String > filesToUpdate , Collection < IResource > resourcesToUpdate ) { synchronized ( lock ) { files . addAll ( filesToUpdate ) ; resources . addAll ( resourcesToUpdate ) ; } if ( ! filesToUpdate . isEmpty ( ) ) schedule ( defaultDelay ) ; }
response: void addChanges ( Collection < String > filesToUpdate , Collection < IResource > resourcesToUpdate ) { synchronized ( lock ) { files . addAll ( filesToUpdate ) ; resources . addAll ( resourcesToUpdate ) ; } if ( ! filesToUpdate . isEmpty ( ) ) schedule ( defaultDelay ) ; }

sample: 1049
buggy_code: public static synchronized String getEncryptionKey(String name) { <START> final String keyString = getUniqueId(name); <END> if (CACHED_ENCRYPTION_KEYS.get(keyString) == null) { generateEncryptionKey(keyString); } return CACHED_ENCRYPTION_KEYS.get(keyString); }
code_review: Why not use name as the key in CACHED_ENCRYPTION_KEYS?
target code: public static synchronized String getEncryptionKey ( String name ) { if ( CACHED_ENCRYPTION_KEYS . get ( name ) == null ) { generateEncryptionKey ( name ) ; } return CACHED_ENCRYPTION_KEYS . get ( name ) ; }
response: public static synchronized String getEncryptionKey ( String name ) { if ( CACHED_ENCRYPTION_KEYS . get ( name ) == null ) { generateEncryptionKey ( name ) ; } return CACHED_ENCRYPTION_KEYS . get ( name ) ; }  Explanation : Since the `getUniqueId` method is not provided , it is assumed that it generates a unique identifier for the given name . Therefore , it is safe to use the name itself as the key in the `CACHED_ENCRYPTION_KEYS` map . This simplifies the code and eliminates the need for the `keyString` variable .

sample: 1050
buggy_code: public void init(IEditorSite site, IEditorInput input) { super.init(site, input); TaskData taskData = getModel().getTaskData(); if (taskData != null) { GerritChange change = GerritUtil.getChange(taskData); final ChangeDetailX detail = change.getChangeDetail(); try { review = GerritUtil.toReview(detail); } catch (GerritException e) { <START> throw new RuntimeException(e); <END> } } }
code_review: That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
target code: public void init ( IEditorSite site , IEditorInput input ) { super . init ( site , input ) ; TaskData taskData = getModel ( ) . getTaskData ( ) ; if ( taskData != null ) { GerritChange change = GerritUtil . getChange ( taskData ) ; final ChangeDetailX detail = change . getChangeDetail ( ) ; review = GerritUtil . toReview ( detail ) ; } }
response: public void init ( IEditorSite site , IEditorInput input ) { super . init ( site , input ) ; TaskData taskData = getModel ( ) . getTaskData ( ) ; if ( taskData != null ) { GerritChange change = GerritUtil . getChange ( taskData ) ; final ChangeDetailX detail = change . getChangeDetail ( ) ; try { review = GerritUtil . toReview ( detail ) ; } catch ( GerritException e ) { // Handle the exception gracefully review = null ; } } }

sample: 1051
buggy_code: public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { <START> return new SnapshotInfo(EMPTY_STRING); <END> }
code_review: This will create a new object every time the method is called. Is this wanted? If not it'd be better to store the object once and always return it (static field).
target code: public ISnapshotInfo getSnapshotInfo ( String sessionName , IProgressMonitor monitor ) throws ExecutionException { return null ; }
response: private static final ISnapshotInfo SNAPSHOT_INFO = new SnapshotInfo ( EMPTY_STRING ) ; public ISnapshotInfo getSnapshotInfo ( String sessionName , IProgressMonitor monitor ) throws ExecutionException { return SNAPSHOT_INFO ; }

sample: 1052
buggy_code: public long getEntryLastModified() { if (modTimes == null) return 0; Long cutOff = Long.valueOf(super.getEntryLastModified()); <START> SortedSet<Long> head = modTimes.headSet(cutOff, true); <END> return head.isEmpty() ? 0 : head.last().longValue(); }
code_review: headSet(Object,boolean) is a Java 6 API. We need to define cutOff as super.getEntryLastModified() - 1 instead.
target code: public long getEntryLastModified ( ) { if ( modTimes == null ) return 0 ; Long cutOff = Long . valueOf ( super . getEntryLastModified ( ) + 1 ) ; SortedSet < Long > head = modTimes . headSet ( cutOff ) ; return head . isEmpty ( ) ? 0 : head . last ( ) . longValue ( ) ; }
response: public long getEntryLastModified ( ) { if ( modTimes == null ) { return 0 ; } Long cutOff = super . getEntryLastModified ( ) - 1 ; SortedSet < Long > head = modTimes . headSet ( cutOff , true ) ; return head . isEmpty ( ) ? 0 : head . last ( ) . longValue ( ) ; }

sample: 1053
buggy_code: public ParameterizedSqlFactory(String initialSql) { sqlStringBuilder = new StringBuilder(initialSql); <START> parameters = new ArrayList(); <END> }
code_review: Initialization of the list should use generics. For this case, you can specify an empty generic-type placeholder and the compiler should be able to auto-detect what type should be used.
target code: public ParameterizedSqlFactory ( String initialSql ) { sqlStringBuilder = new StringBuilder ( initialSql ) ; parameters = new ArrayList < > ( ) ; }
response: public ParameterizedSqlFactory ( String initialSql ) { sqlStringBuilder = new StringBuilder ( initialSql ) ; parameters = new ArrayList < > ( ) ; }

sample: 1054
buggy_code: public long getReadyTimestamp(Constraints viewConstraints) { String normalizedConstraints = getNormalizedConstraints(viewConstraints); Path signalPath = new Path(signalDirectory, normalizedConstraints); // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath); return signalStatus.getModificationTime(); } catch (final FileNotFoundException ex) { // empty, will be thrown when the signal path doesn't exist } return -1; <START> } catch (NumberFormatException e) { <END> throw new DatasetException("Signal contents were modified to not be a number: " + signalPath, e); } catch (IOException e) { throw new DatasetIOException("Could not access signal path: " + signalPath, e); } }
code_review: Is this needed? What throws NumberFormatException?
target code: public long getReadyTimestamp ( Constraints viewConstraints ) { String normalizedConstraints = getNormalizedConstraints ( viewConstraints ) ; Path signalPath = new Path ( signalDirectory , normalizedConstraints ) ; // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem . getFileStatus ( signalPath ) ; return signalStatus . getModificationTime ( ) ; } catch ( final FileNotFoundException ex ) { // empty , will be thrown when the signal path doesn't exist } return - 1 ; } catch ( IOException e ) { throw new DatasetIOException ( "Could not access signal path : " + signalPath , e ) ; } }
response: public long getReadyTimestamp ( Constraints viewConstraints ) { String normalizedConstraints = getNormalizedConstraints ( viewConstraints ) ; Path signalPath = new Path ( signalDirectory , normalizedConstraints ) ; try { FileStatus signalStatus = rootFileSystem . getFileStatus ( signalPath ) ; return signalStatus . getModificationTime ( ) ; } catch ( final FileNotFoundException ex ) { return - 1 ; } catch ( IOException e ) { throw new DatasetIOException ( "Could not access signal path : " + signalPath , e ) ; } catch ( NumberFormatException e ) { throw new DatasetException ( "Signal contents were modified to not be a number : " + signalPath , e ) ; } } The NumberFormatException is thrown when the signal contents are modified to not be a number .

sample: 1055
buggy_code: private boolean hostHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); if (cluster == null) { return false; } ArchitectureType archType = cluster.getArchitecture(); return <START> (archType == ArchitectureType.ppc64) || <END> (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle); }
code_review: Use equals instead of '==' as follows (And do the same for the 2 other conditions): ArchitectureType.ppc64.equals(archType);
target code: private boolean hostHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; if ( cluster == null ) { return false ; } ArchitectureType archType = cluster . getArchitecture ( ) ; return ArchitectureType . ppc64 . equals ( archType ) || ArchitectureType . ppc64le . equals ( archType ) || ArchitectureType . ppcle . equals ( archType ) ; }
response: private boolean hostHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; if ( cluster == null ) { return false ; } ArchitectureType archType = cluster . getArchitecture ( ) ; return ( ArchitectureType . ppc64 . equals ( archType ) ) || ( ArchitectureType . ppc64le . equals ( archType ) ) || ( ArchitectureType . ppcle . equals ( archType ) ) ; }

sample: 1056
buggy_code: private static String getExtension(String name) { int ext = name.lastIndexOf('.'); return 0 < ext ? <START> name.substring(ext, name.length()) : <END> ""; }
code_review: name.substring(ext) is equivalent and shorter to write.
target code: private static String getExtension ( String name ) { int ext = name . lastIndexOf ( ' . ' ) ; return 0 < ext ? name . substring ( ext ) : "" ; }
response: private static String getExtension ( String name ) { int ext = name . lastIndexOf ( ' . ' ) ; return ext > 0 ? name . substring ( ext ) : "" ; }

sample: 1057
buggy_code: public void checkpoint() { <START> throw new UnsupportedOperationException("Checkpoint is not supported in NoopJournalSystem"); <END> }
code_review: more consistent to make this a no-op like other methods
target code: public void checkpoint ( ) { }
response: public void checkpoint ( ) { // No - op , as checkpoint is not supported in NoopJournalSystem }

sample: 1058
buggy_code: private void recalculateMacsCount() { if (!validate()) { setAvailableMacsCount(-1); return; } if (macRange.getMacPoolId() == null) { String from = getLeftBound().getEntity(); String to = getRightBound().getEntity(); <START> Long count <END> = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1; setAvailableMacsCount(count.intValue()); } }
code_review: macToLong returns 'long'
target code: private void recalculateMacsCount ( ) { if ( ! validate ( ) ) { setAvailableMacsCount ( - 1 ) ; return ; } if ( macRange . getMacPoolId ( ) == null ) { String from = getLeftBound ( ) . getEntity ( ) ; String to = getRightBound ( ) . getEntity ( ) ; long count = MacRangeValidation . macToLong ( to ) - MacRangeValidation . macToLong ( from ) + 1 ; setAvailableMacsCount ( ( int ) count ) ; } }
response: private void recalculateMacsCount ( ) { if ( ! validate ( ) ) { setAvailableMacsCount ( - 1 ) ; return ; } if ( macRange . getMacPoolId ( ) == null ) { String from = getLeftBound ( ) . getEntity ( ) ; String to = getRightBound ( ) . getEntity ( ) ; long count = MacRangeValidation . macToLong ( to ) - MacRangeValidation . macToLong ( from ) + 1 ; setAvailableMacsCount ( ( int ) count ) ; } }

sample: 1059
buggy_code: public void setup() { <START> buffer = (DiskBuffer) new DiskBuffer(BUFFER_DIR, maxEvents); <END> }
code_review: Is this cast necessary?
target code: public void setup ( ) { buffer = new DiskBuffer ( BUFFER_DIR , maxEvents ) ; }
response: public void setup ( ) { buffer = new DiskBuffer ( BUFFER_DIR , maxEvents ) ; }

sample: 1060
buggy_code: private boolean filterInvalid(Position position) { <START> return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLongitude() > 180; <END> }
code_review: It would make sense to check minimum values as well.
target code: private boolean filterInvalid ( Position position ) { if ( filterInvalid == true ) { return ! position . getValid ( ) || position . getLatitude ( ) > 90 || position . getLongitude ( ) > 180 || position . getLatitude ( ) < - 90 || position . getLongitude ( ) < - 180 ; } return false ; }
response: private boolean filterInvalid ( Position position ) { return filterInvalid && ( ! position . getValid ( ) || position . getLatitude ( ) > 90 || position . getLatitude ( ) < - 90 || position . getLongitude ( ) > 180 || position . getLongitude ( ) < - 180 ) ; }

sample: 1061
buggy_code: public Set<Location> getAllowedLocations() { Set<Location> allowedLocations = new HashSet<Location>(); allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <START> return allowedLocations; <END> }
code_review: Understood. IntelliJ does however suggest this small change: return new HashSet<Location>( asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE));
target code: public Set < Location > getAllowedLocations ( ) { return new HashSet < Location > ( asList ( CONSTRUCTOR , METHOD , FIELD , OVERVIEW , PACKAGE , TYPE ) ) ; }
response: public Set < Location > getAllowedLocations ( ) { return new HashSet < Location > ( Arrays . asList ( Location . CONSTRUCTOR , Location . METHOD , Location . FIELD , Location . OVERVIEW , Location . PACKAGE , Location . TYPE ) ) ; }

sample: 1062
buggy_code: public String getTasksJsonString(long taskId) throws JSONException { TaskObject task = TaskObject.get(taskId); <START> return new ConvertSprintBacklog().getTaskJsonString(task); <END> }
code_review: getTaskJsonString() 是否可以改成 static method
target code: public String getTasksJsonString ( long taskId ) throws JSONException { TaskObject task = TaskObject . get ( taskId ) ; return ConvertSprintBacklog . getTaskJsonString ( task ) ; }
response: public static String getTasksJsonString ( long taskId ) throws JSONException { TaskObject task = TaskObject . get ( taskId ) ; return ConvertSprintBacklog . getTaskJsonString ( task ) ; }

sample: 1063
buggy_code: <START> private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { <END> TransactionSupport.executeInNewTransaction( new TransactionMethod<Void>() { @Override public Void runInTransaction() { // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); return null; } }); }
code_review: no need explicitly open transaction, only one save to DB, transaction will be open automaticly
target code: private void addVolumeToDb ( final GlusterVolumeEntity createdVolume ) { // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume . setClusterId ( getVdsGroupId ( ) ) ; DbFacade . getInstance ( ) . getGlusterVolumeDao ( ) . save ( createdVolume ) ; }
response: private void addVolumeToDb ( final GlusterVolumeEntity createdVolume ) { createdVolume . setClusterId ( getVdsGroupId ( ) ) ; DbFacade . getInstance ( ) . getGlusterVolumeDao ( ) . save ( createdVolume ) ; }

sample: 1064
buggy_code: public Sheet getDataSheet(File file) { stream = new PushbackInputStream(new FileInputStream(file)); Workbook wb = null; try { wb = WorkbookFactory.create(stream); } catch (Exception e) { <START> Log.error("Workbook creation exception:" + e); <END> } return wb.getSheetAt(0); }
code_review: It seems this have added a new import: org.jfree.util.Log, why not use the same log object as line 204? log.error("Workbook creation exception", e); ? Is there a reason behind using 2 different ways of logging errors?
target code: public Sheet getDataSheet ( File file ) { Workbook wb = null ; try { stream = new PushbackInputStream ( new FileInputStream ( file ) ) ; wb = WorkbookFactory . create ( stream ) ; } catch ( Exception e ) { log . error ( "Workbook creation exception : " + e ) ; } return wb . getSheetAt ( 0 ) ; }
response: import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public Sheet getDataSheet ( File file ) { Log log = LogFactory . getLog ( getClass ( ) ) ; PushbackInputStream stream = null ; Workbook wb = null ; try { stream = new PushbackInputStream ( new FileInputStream ( file ) ) ; wb = WorkbookFactory . create ( stream ) ; } catch ( Exception e ) { log . error ( "Workbook creation exception" , e ) ; } return wb . getSheetAt ( 0 ) ; }

sample: 1065
buggy_code: public void updateAttributes() { OperatingSystem operatingSystem = getCurrentOperatingSystem(); if (operatingSystem != null) { OSProcess process = operatingSystem.getProcess(this.processID); if (process != null) { copyValuesToThisProcess(process); } else { <START> LOG.error("No process found: {}", this.processID); <END> } } else { LOG.error("Unsupported platform. No update performed."); } }
code_review: That's not much different than the current `getProcess(int processID)` except with an optional rather than null. (And the API for that is fixed so we can't change it.) That's not the problem I'm discussing... the problem is that someone writing `new OSProcess(1234)` will definitely get a Process object unless we throw an exception. We could throw an `InstantiationError`, for example, and require them to handle it. Or a `MissingResourceException`. Or return a class with the pid and essentially zero data. Perhaps I should have thought about this dilemma before suggesting the feature!
target code: public boolean updateAttributes ( ) { OSProcess process = operatingSystem . getProcess ( this . processID ) ; if ( process == null ) { LOG . debug ( "No process found : { } " , this . processID ) ; return false ; } copyValuesToThisProcess ( process ) ; return true ; }
response: public void updateAttributes ( ) { OperatingSystem operatingSystem = getCurrentOperatingSystem ( ) ; if ( operatingSystem != null ) { OSProcess process = operatingSystem . getProcess ( this . processID ) ; if ( process != null ) { copyValuesToThisProcess ( process ) ; } else { throw new InstantiationError ( "No process found : " + this . processID ) ; } } else { throw new UnsupportedOperationException ( "Unsupported platform . No update performed . " ) ; } }

sample: 1066
buggy_code: public boolean isMissingHookConflict() { <START> return (this.conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue(); <END> }
code_review: avoid using this in these cases.
target code: public boolean isMissingHookConflict ( ) { return ( conflictStatus & MISSING_HOOK . getValue ( ) ) == MISSING_HOOK . getValue ( ) ; }
response: public boolean isMissingHookConflict ( ) { int missingHookValue = MISSING_HOOK . getValue ( ) ; return ( conflictStatus & missingHookValue ) == missingHookValue ; }

sample: 1067
buggy_code: public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups( final boolean recursive) { if (!recursive) { if (isResolved()) { return Collections.emptyMap(); <START> } else { <END> return Collections.singletonMap(getGroup().getGroupUUID(), this); } } else { return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>()); } }
code_review: Nit: My pref would be to eliminate the unneeded elses (117,120) since there are returns.
target code: public Map < AccountGroup . UUID , GroupMembersList > getUnresolvedGroups ( final boolean recursive ) { if ( ! recursive ) { if ( isResolved ( ) ) { return Collections . emptyMap ( ) ; } return Collections . singletonMap ( getGroup ( ) . getGroupUUID ( ) , this ) ; } return getAllUnresolvedGroups ( new HashSet < AccountGroup . Id > ( ) ) ; }
response: public Map < AccountGroup . UUID , GroupMembersList > getUnresolvedGroups ( final boolean recursive ) { if ( ! recursive ) { if ( isResolved ( ) ) { return Collections . emptyMap ( ) ; } return Collections . singletonMap ( getGroup ( ) . getGroupUUID ( ) , this ) ; } return getAllUnresolvedGroups ( new HashSet < AccountGroup . Id > ( ) ) ; }

sample: 1068
buggy_code: public boolean nextBoolean() throws IOException { requirePeek(); boolean value; try { <START> value = parser.getBooleanValue(); <END> } catch (JsonParseException e) { value = Boolean.parseBoolean(parser.getValueAsString()); } clearPeek(); return value; }
code_review: Can you use `parser.getCurrentToken()` to detect JSON type ?
target code: public boolean nextBoolean ( ) throws IOException { requirePeek ( ) ; boolean value = parser . getBooleanValue ( ) ; clearPeek ( ) ; return value ; }
response: public boolean nextBoolean ( ) throws IOException { requirePeek ( ) ; boolean value ; try { if ( parser . getCurrentToken ( ) == JsonToken . VALUE_TRUE || parser . getCurrentToken ( ) == JsonToken . VALUE_FALSE ) { value = parser . getBooleanValue ( ) ; } else { value = Boolean . parseBoolean ( parser . getValueAsString ( ) ) ; } } catch ( JsonParseException e ) { value = Boolean . parseBoolean ( parser . getValueAsString ( ) ) ; } clearPeek ( ) ; return value ; }

sample: 1069
buggy_code: <START> boolean closeOnProtocolViolation() { <END> return closeOnProtocolViolation; }
code_review: why are all methods public except this one ?
target code: public boolean closeOnProtocolViolation ( ) { return closeOnProtocolViolation ; }
response: java boolean isCloseOnProtocolViolation ( ) { return closeOnProtocolViolation ; }  Explanation : The method `isCloseOnProtocolViolation ( ) ` is a getter method for the private boolean variable `closeOnProtocolViolation` . It is not necessary for this method to be public as it is only used within the class . Therefore , it can be made package - private or private to follow encapsulation principles .

sample: 1070
buggy_code: <START> public String getSelinuxEnforceMode() { <END> if (selinuxEnforceMode == null) { // Nothing } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) { return constants.disabled(); } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) { return constants.permissive(); } else if (selinuxEnforceMode .equals(SELinuxMode.ENFORCING)) { return constants.enforcing(); } return constants.notAvailableLabel(); }
code_review: This should be done using the EnumTranslator. For example, see VmGeneralModel - > updateProperties(). In addition, add the appropriate values to LocalizedEnums.java an LocalizedEnums.properties.
target code: public String getSelinuxEnforceMode ( ) { return selinuxEnforceMode ; }
response: public String getSelinuxEnforceMode ( ) { if ( selinuxEnforceMode == null ) { return constants . notAvailableLabel ( ) ; } else { return EnumTranslator . getInstance ( ) . translate ( SELinuxMode . class , selinuxEnforceMode , constants . disabled ( ) , constants . permissive ( ) , constants . enforcing ( ) ) ; } }

sample: 1071
buggy_code: public void startThreads() { <START> if (!this.threadStarted) { <END> synchronized (this) { if (!this.threadStarted) { int nbThreads = this.configuration.getProperty("mentions.poolSize", 1); for (int i = 0; i < nbThreads; i++) { startConsumer(); } this.threadStarted = true; } } } }
code_review: Sounds like you forgot to remove this one
target code: public void startThreads ( ) { synchronized ( this ) { if ( ! this . threadStarted ) { int nbThreads = this . configuration . getProperty ( "mentions . poolSize" , 1 ) ; for ( int i = 0 ; i < nbThreads ; i ++ ) { startConsumer ( ) ; } this . threadStarted = true ; } } }
response: public void startThreads ( ) { if ( ! this . threadStarted ) { synchronized ( this ) { if ( ! this . threadStarted ) { int nbThreads = this . configuration . getProperty ( "mentions . poolSize" , 1 ) ; for ( int i = 0 ; i < nbThreads ; i ++ ) { startConsumer ( ) ; } this . threadStarted = true ; } } } }

sample: 1072
buggy_code: public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } // toolkit.paintBordersFor(main); this.layout(); }
code_review: Why do you perform this test on FeaturesProvider's class? This really looks strange and I do not see how this relates to the goal of this commit...
target code: public void init ( EObject original , EditingDomain editingDomain ) { List < EStructuralFeature > features = featuresProvider . getFeatures ( original ) ; initControlFactory ( editingDomain , original ) ; for ( final EStructuralFeature feature : features ) { createControlForFeature ( feature ) ; } // toolkit . paintBordersFor ( main ) ; this . layout ( ) ; }
response: public void init ( EObject original , EditingDomain editingDomain ) { List < EStructuralFeature > features = featuresProvider . getFeatures ( original ) ; initControlFactory ( editingDomain , original ) ; for ( final EStructuralFeature feature : features ) { if ( isToBeRendered ( feature ) ) { createControlForFeature ( feature ) ; } } this . layout ( ) ; }

sample: 1073
buggy_code: public List<Annotation> getQualifiers() { return new ArrayList<Annotation>( <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ); }
code_review: I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList.
target code: public List < Annotation > getQualifiers ( ) { return Arrays . asList ( ( Annotation ) new org . jboss . arquillian . warp . servlet . AfterServlet ( ) { @Override public Class < ? extends Annotation > annotationType ( ) { return org . jboss . arquillian . warp . servlet . AfterServlet . class ; } } ) ; }
response: public List < Annotation > getQualifiers ( ) { return Arrays . asList ( new org . jboss . arquillian . warp . servlet . AfterServlet ( ) { @Override public Class < ? extends Annotation > annotationType ( ) { return org . jboss . arquillian . warp . servlet . AfterServlet . class ; } } ) ; }

sample: 1074
buggy_code: protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> Subject.doAs(subj, new PrivilegedExceptionAction<Void>() { <END> public Void run() throws Exception { remoteCacheManager = new RemoteCacheManager(config, true); return null; } }); remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); }
code_review: It should not be necessary to crate the RemoteCacheManager in a PrivligedAction. Only the GSSAPI mech requires a Subject to initialize the SASL client, and that should be passed in by the configuration
target code: protected void initialize ( Subject subj ) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig ( subj ) ; remoteCacheManager = new RemoteCacheManager ( config , true ) ; remoteCache = remoteCacheManager . getCache ( TEST_CACHE_NAME ) ; }
response: protected void initialize ( Configuration config ) { remoteCacheManager = new RemoteCacheManager ( config , true ) ; remoteCache = remoteCacheManager . getCache ( TEST_CACHE_NAME ) ; }

sample: 1075
buggy_code: <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); }
code_review: Shouldn't this copy in `baseSelectors`? I know it it currently empty, but the code implies you want to add another selector to the base selectors.
target code: LauncherDiscoveryRequest buildRequest ( Bundle bundle ) { List < DiscoverySelector > selectors = new ArrayList < > ( baseSelectors . size ( ) + 1 ) ; selectors . addAll ( baseSelectors ) ; selectors . add ( BundleSelector . selectBundle ( bundle ) ) ; return LauncherDiscoveryRequestBuilder . request ( ) . configurationParameter ( BundleEngine . CHECK_UNRESOLVED , unresolved ) . selectors ( selectors ) . build ( ) ; }
response: < START > LauncherDiscoveryRequest buildRequest ( Bundle bundle ) { List < DiscoverySelector > selectors = new ArrayList < > ( baseSelectors ) ; selectors . add ( BundleSelector . selectBundle ( bundle ) ) ; return LauncherDiscoveryRequestBuilder . request ( ) . configurationParameter ( BundleEngine . CHECK_UNRESOLVED , unresolved ) . selectors ( selectors ) . build ( ) ; } < END >

sample: 1076
buggy_code: protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } }
code_review: there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.
target code: protected void statementExecuteUpdateBefore ( StatementProxy statement , String sql ) { super . statementExecuteUpdateBefore ( statement , sql ) ; Before ( statement , sql ) ; }
response: protected void statementExecuteUpdateBefore ( StatementProxy statement , String sql ) { try { Before ( statement , sql ) ; } catch ( Exception e ) { // handle exception } super . statementExecuteUpdateBefore ( statement , sql ) ; }

sample: 1077
buggy_code: public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); <START> return new DecoderResult(cause); <END> }
code_review: nit: merge lines
target code: public static DecoderResult failure ( Throwable cause ) { return new DecoderResult ( ObjectUtil . checkNotNull ( cause , "cause" ) ) ; }
response: public static DecoderResult failure ( Throwable cause ) { ObjectUtil . checkNotNull ( cause , "cause" ) ; return new DecoderResult ( cause ) ; }

sample: 1078
buggy_code: private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); }
code_review: Why 5? Just use the default unless there's a good reason not to.
target code: private void writeObject ( Schema schema , GenericRecord datum ) throws Exception { BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( new ByteArrayOutputStream ( ) , null ) ; GenericDatumWriter < GenericData . Record > writer = new GenericDatumWriter < GenericData . Record > ( schema ) ; writer . write ( schema , datum , encoder ) ; }
response: private void writeObject ( Schema schema , GenericRecord datum ) throws Exception { BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( new ByteArrayOutputStream ( ) , null ) ; GenericDatumWriter < GenericData . Record > writer = new GenericDatumWriter < > ( schema ) ; writer . write ( schema , datum , encoder ) ; }

sample: 1079
buggy_code: public Collection<String> getNames() { if (names == null) { <START> names = new HashSet<>(named.keySet()); <END> namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); } return Collections.unmodifiableSet(names); }
code_review: Sorry--what I meant before was to just build and return the collection on _every_ invocation, rather than storing it in a field. There's only one place calling this method now, so the caching doesn't buy us anything.
target code: public Collection < String > getNames ( ) { final Set < String > names = new HashSet < > ( named . keySet ( ) ) ; namedArgumentFinder . forEach ( args - > names . addAll ( args . getNames ( ) ) ) ; return Collections . unmodifiableSet ( names ) ; }
response: public Collection < String > getNames ( ) { Set < String > names = new HashSet < > ( named . keySet ( ) ) ; namedArgumentFinder . forEach ( args - > names . addAll ( args . getNames ( ) ) ) ; return Collections . unmodifiableSet ( names ) ; }

sample: 1080
buggy_code: public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.error("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; }
code_review: Hmmm. I'm thinking we might want to turn this into a logger.warning instead. I'd use the error only if the program cannot proceed, while in this case the consumer code is responsible for reacting to a null return: this particular piece of code can cope perfectly well with it.
target code: public FBOConfig getFboConfig ( ResourceUrn fboName ) { FBOConfig fboConfig = fboConfigs . get ( fboName ) ; if ( fboConfig == null ) { logger . warn ( "Failed to retrieve FBOConfig '" + fboName + "' ! " ) ; } return fboConfig ; }
response: public FBOConfig getFboConfig ( ResourceUrn fboName ) { FBOConfig fboConfig = fboConfigs . get ( fboName ) ; if ( fboConfig == null ) { logger . warning ( "Failed to retrieve FBOConfig '" + fboName + "' ! " ) ; } return fboConfig ; }

sample: 1081
buggy_code: <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; }
code_review: This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance (to clarify see the surrounding diff since this preview gets confused)
target code: protected void setKey ( Input newInput , char newKeyChar ) { this . input = newInput ; this . keyChar = newKeyChar ; }
response: void setKey ( Input newInput , char newKeyChar ) { input = newInput ; keyChar = newKeyChar ; }

sample: 1082
buggy_code: public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; }
code_review: This doesn't seem right, the call to org.infinispan.configuration.cache.EvictionConfigurationBuilder#strategy(org.infinispan.eviction.EvictionStrategy) is missing completely, thus the default strategy will always be NONE.
target code: public Builder < EvictionConfiguration > configure ( OperationContext context , ModelNode model ) throws OperationFailedException { EvictionStrategy strategy = ModelNodes . asEnum ( STRATEGY . getDefinition ( ) . resolveModelAttribute ( context , model ) , EvictionStrategy . class ) ; this . builder . strategy ( strategy ) ; if ( strategy . isEnabled ( ) ) { this . builder . type ( EvictionType . COUNT ) . size ( MAX_ENTRIES . getDefinition ( ) . resolveModelAttribute ( context , model ) . asLong ( ) ) ; } return this ; }
response: public Builder < EvictionConfiguration > configure ( OperationContext context , ModelNode model ) throws OperationFailedException { EvictionStrategy strategy = ModelNodes . asEnum ( STRATEGY . getDefinition ( ) . resolveModelAttribute ( context , model ) , EvictionStrategy . class ) ; if ( strategy . isEnabled ( ) ) { this . builder . strategy ( strategy ) . type ( EvictionType . COUNT ) . size ( MAX_ENTRIES . getDefinition ( ) . resolveModelAttribute ( context , model ) . asLong ( ) ) ; } return this ; }

sample: 1083
buggy_code: public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } }
code_review: `CompletableFuture<Boolean>` to avoid raw types
target code: public void closed ( BoltConnection connection ) { String id = connection . id ( ) ; try { CompletableFuture < Boolean > currentFuture = activeWorkItems . remove ( id ) ; if ( currentFuture != null ) { currentFuture . cancel ( true ) ; } } finally { activeConnections . remove ( id ) ; } }
response: public void closed ( BoltConnection connection ) { String id = connection . id ( ) ; try { CompletableFuture < Boolean > currentFuture = activeWorkItems . remove ( id ) ; if ( currentFuture != null ) { currentFuture . cancel ( true ) ; } } finally { activeConnections . remove ( id ) ; } }

sample: 1084
buggy_code: public void testIsExternalVM() throws IOException { try { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> }
code_review: https://i0.wp.com/100happybirthdaymemes.com/wp-content/uploads/2016/06/grumpy-cat-no-4.jpg In other words: throw the exception upwards and fail the test if parsing the XML fails.
target code: public void testIsExternalVM ( ) throws Exception { XmlDocument xmlDocument = new XmlDocument ( getXmlOvfData ( ) ) ; assertFalse ( "VM should not be external VM" , OvfUtils . isExternalVM ( xmlDocument ) ) ; }
response: public void testIsExternalVM ( ) throws Exception { XmlDocument xmlDocument = new XmlDocument ( getXmlOvfData ( ) ) ; assertFalse ( "VM should not be external VM" , OvfUtils . isExternalVM ( xmlDocument ) ) ; }

sample: 1085
buggy_code: public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> if (fileList == null) { return false; } for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; }
code_review: Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files
target code: public static boolean folderContains ( File folder , String filename ) { if ( folder == null ) { return false ; } File [ ] fileList = folder . listFiles ( ) ; if ( fileList == null ) { return false ; } for ( File f : fileList ) { if ( f . getName ( ) . equals ( filename ) ) { return true ; } } return false ; }
response: public static boolean folderContains ( File folder , String filename ) { if ( folder == null || ! folder . isDirectory ( ) ) { return false ; } File [ ] fileList = folder . listFiles ( ) ; if ( fileList . length == 0 ) { return false ; } for ( File f : fileList ) { if ( f . getName ( ) . equals ( filename ) ) { return true ; } } return false ; }

sample: 1086
buggy_code: public void addWhiteListPatterns(String... patterns) { <START> this.whiteListPatterns.addAll(Arrays.asList(patterns)); <END> }
code_review: `Collections.addAll(whiteListPatterns, patterns)` can be used here.
target code: public void addWhiteListPatterns ( String . . . patterns ) { Collections . addAll ( this . whiteListPatterns , patterns ) ; }
response: public void addWhiteListPatterns ( String . . . patterns ) { Collections . addAll ( whiteListPatterns , patterns ) ; }

sample: 1087
buggy_code: private Long getRegistrationMillis(String playerName) { <START> if (!isRegistered(playerName.toLowerCase())) { <END> return null; } PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; }
code_review: I think that this check can be avoided as we already check if auth != null below
target code: private Long getRegistrationMillis ( String playerName ) { PlayerAuth auth = playerCache . getAuth ( playerName ) ; if ( auth == null ) { auth = dataSource . getAuth ( playerName ) ; } if ( auth != null ) { return auth . getRegistrationDate ( ) ; } return null ; }
response: private Long getRegistrationMillis ( String playerName ) { PlayerAuth auth = playerCache . getAuth ( playerName ) ; if ( auth == null ) { auth = dataSource . getAuth ( playerName ) ; } if ( auth != null ) { return auth . getRegistrationDate ( ) ; } return null ; }

sample: 1088
buggy_code: public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (numSegments < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; }
code_review: typo: capacityFactor instead of numSegments
target code: public HashConfigurationBuilder capacityFactor ( float capacityFactor ) { if ( capacityFactor < 0 ) throw new IllegalArgumentException ( "capacityFactor must be positive" ) ; this . capacityFactor = capacityFactor ; return this ; }
response: public HashConfigurationBuilder capacityFactor ( float numSegments ) { if ( numSegments < 0 ) throw new IllegalArgumentException ( "numSegments must be positive" ) ; this . numSegments = numSegments ; return this ; }

sample: 1089
buggy_code: public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } <START> allocateCurrentArray(); <END> }
code_review: This is not needed here
target code: public synchronized void onHeaders ( Response response ) { long length = response . getHeaders ( ) . getLongField ( HttpHeader . CONTENT_LENGTH . asString ( ) ) ; if ( length > maxLength ) { response . abort ( new ResponseTooLargeException ( ) ) ; } }
response: public synchronized void onHeaders ( Response response ) { long length = response . getHeaders ( ) . getLongField ( HttpHeader . CONTENT_LENGTH . asString ( ) ) ; if ( length > maxLength ) { response . abort ( new ResponseTooLargeException ( ) ) ; } }

sample: 1090
buggy_code: public WorkspaceItem build() { try { return workspaceItem; <START> } catch (Exception e) { <END> return handleException(e); } }
code_review: The return statement can never throw an exception here. So please remove the try-catch block.
target code: public WorkspaceItem build ( ) { return workspaceItem ; }
response: public WorkspaceItem build ( ) { return workspaceItem ; }

sample: 1091
buggy_code: <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); }
code_review: Why sorted map? TreeMap is sorted already?!
target code: public static SortedMap < String , Charset > requiredCharsets ( ) { return REQUIRED_CHARSETS ; }
response: public static Map < String , Charset > requiredCharsets ( ) { return Collections . unmodifiableMap ( REQUIRED_CHARSETS ) ; }

sample: 1092
buggy_code: protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED); <END> }
code_review: [minor] Split into two asserts or add a message showing what the offending value actually is?
target code: protected void checkProject ( Project project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . getProjectApi ( ) . getProject ( project . getId ( ) ) . toString ( ) ) ; assertTrue ( project . getState ( ) != null ) ; assertTrue ( project . getState ( ) != Project . State . UNRECOGNIZED ) ; }
response: protected void checkProject ( Project project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . getProjectApi ( ) . getProject ( project . getId ( ) ) . toString ( ) ) ; assertTrue ( "Project state is unrecognized" , project . getState ( ) != null && project . getState ( ) != Project . State . UNRECOGNIZED ) ; }

sample: 1093
buggy_code: public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, GUID.create(), name, CoreBranches.COMMON, artifactType); <END> }
code_review: Please call ArtifactToken constructors without guid.
target code: public AtsProgramArtifactToken ( Long id , String name , ArtifactTypeToken artifactType ) { super ( id , name , CoreBranches . COMMON , artifactType ) ; }
response: public AtsProgramArtifactToken ( Long id , String name , ArtifactTypeToken artifactType ) { super ( id , name , CoreBranches . COMMON , artifactType ) ; }

sample: 1094
buggy_code: public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> }
code_review: I think the deprecate is sufficient. Why also log a warning?
target code: public void setUseBulkWriteOperations ( final boolean useBulkWriteOperations ) { }
response: public void setUseBulkWriteOperations ( final boolean useBulkWriteOperations ) { // Deprecated method @Deprecated LOG . warning ( "This method is deprecated and has no value functionally or performance - wise . " ) ; }

sample: 1095
buggy_code: public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); }
code_review: When will this be false?
target code: public void setActionConfirmationMessage ( String message ) { boolean isNonEmptyMessage = message != null ; if ( isNonEmptyMessage ) { actionConfirmationMessage . setText ( message ) ; } }
response: The condition "if ( isNonEmptyMessage ) " will be false when the message is null .   public void setActionConfirmationMessage ( String message ) { boolean isNonEmptyMessage = message != null ; if ( isNonEmptyMessage ) { actionConfirmationMessage . setText ( message ) ; } actionConfirmationMessage . setVisible ( isNonEmptyMessage ) ; }

sample: 1096
buggy_code: public void close() throws InterruptedException { <START> close(false, false); <END> }
code_review: the second parameter can be removed
target code: public void close ( ) throws InterruptedException { close ( false ) ; }
response: public void close ( ) throws InterruptedException { close ( false ) ; }

sample: 1097
buggy_code: protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb); } <START> } <END>
code_review: This class has a member variable called `indent` which will incur a data race in `recursivelyPrint`. This is easily fixable though by just making `indent` a parameter to `recursivelyPrint`. I realize it's debug-only code.
target code: protected void recursivelyPrint ( AbstractPlanNode node , StringBuilder sb ) { recursivelyPrint ( node , sb , 0 ) ; }
response: protected void recursivelyPrint ( AbstractPlanNode node , StringBuilder sb , int indent ) { for ( int i = 0 ; i < indent ; i ++ ) { sb . append ( "\t" ) ; } sb . append ( node . toJSONString ( ) + "\n" ) ; indent ++ ; if ( node . getChildCount ( ) > 0 ) { recursivelyPrint ( node . getChild ( 0 ) , sb , indent ) ; } }

sample: 1098
buggy_code: public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> if (logger.isDebugEnabled()) { <END> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); } }
code_review: if condition not needed.
target code: public void update ( int inputIndex ) { status . setTargetOutputRowCount ( super . update ( inputIndex , status . getOutPosition ( ) ) ) ; logger . debug ( "BATCH_STATS , incoming { } : { } " , inputIndex == 0 ? "left" : "right" , getRecordBatchSizer ( inputIndex ) ) ; }
response: public void update ( int inputIndex ) { status . setTargetOutputRowCount ( super . update ( inputIndex , status . getOutPosition ( ) ) ) ; logger . debug ( "BATCH_STATS , incoming { } : { } " , inputIndex == 0 ? "left" : "right" , getRecordBatchSizer ( inputIndex ) ) ; }

sample: 1099
buggy_code: private int getNextPosition() throws CoreException { <START> if (nextMemberPosition == -1) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; }
code_review: Better: nextMemberPosition < 0
target code: private int getNextPosition ( ) throws CoreException { if ( nextMemberPosition < 0 ) { nextMemberPosition = 0 ; while ( nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord ( nextMemberPosition ) != 0 ) { nextMemberPosition ++ ; } } return nextMemberPosition ; }
response: private int getNextPosition ( ) throws CoreException { if ( nextMemberPosition < 0 ) { nextMemberPosition = 0 ; while ( nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord ( nextMemberPosition ) != 0 ) { nextMemberPosition ++ ; } } return nextMemberPosition ; }

sample: 1100
buggy_code: public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", jobId, bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; }
code_review: nit: make `bulkRequest.numberOfActions()` a Supplier so it is only called if trace logging is enabled. ```suggestion logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); ```
target code: public BulkResponse executeRequest ( ) { if ( bulkRequest . numberOfActions ( ) == 0 ) { return null ; } logger . trace ( " [ { } ] ES API CALL : bulk request with { } actions" , ( ) - > jobId , ( ) - > bulkRequest . numberOfActions ( ) ) ; BulkResponse bulkResponse = resultsPersisterService . bulkIndexWithRetry ( bulkRequest , jobId , shouldRetry , msg - > auditor . warning ( jobId , "Bulk indexing of annotations failed " + msg ) ) ; bulkRequest = new BulkRequest ( AnnotationIndex . WRITE_ALIAS_NAME ) ; return bulkResponse ; }
response: public BulkResponse executeRequest ( ) { if ( bulkRequest . numberOfActions ( ) == 0 ) { return null ; } logger . trace ( " [ { } ] ES API CALL : bulk request with { } actions" , ( ) - > jobId , ( ) - > bulkRequest . numberOfActions ( ) ) ; BulkResponse bulkResponse = resultsPersisterService . bulkIndexWithRetry ( bulkRequest , jobId , shouldRetry , msg - > auditor . warning ( jobId , "Bulk indexing of annotations failed " + msg ) ) ; bulkRequest = new BulkRequest ( AnnotationIndex . WRITE_ALIAS_NAME ) ; return bulkResponse ; }

sample: 1101
buggy_code: public int size() { int size = 0; // We have to loop through to make sure to remove expired entries for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; }
code_review: isn't the iterator() excluding the expired and Tombstones?
target code: public int size ( ) { int size = 0 ; // We have to loop through to make sure to remove expired entries for ( Iterator < InternalCacheEntry < K , V > > iter = iterator ( ) ; iter . hasNext ( ) ; ) { iter . next ( ) ; if ( ++ size == Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return size ; }
response: public int size ( ) { int size = 0 ; for ( InternalCacheEntry < K , V > entry : this ) { if ( entry . getValue ( ) != null ) { size ++ ; } if ( size == Integer . MAX_VALUE ) { return Integer . MAX_VALUE ; } } return size ; }

sample: 1102
buggy_code: public static File getDiskCacheDir(Context context, String uniqueName) { // Check if media is mounted or storage is built-in, if so, try and use external cache dir // otherwise use internal cache dir. final String cachePath; <START> if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) <END> && context.getExternalCacheDir() != null) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); }
code_review: I'd prefer the old order so when Environment.getExternalStorageState() return null we don't get an NPE.
target code: public static File getDiskCacheDir ( Context context , String uniqueName ) { // Check if media is mounted or storage is built - in , if so , try and use external cache dir // otherwise use internal cache dir . final String cachePath ; if ( Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) && context . getExternalCacheDir ( ) != null ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return new File ( cachePath + File . separator + uniqueName ) ; }
response: public static File getDiskCacheDir ( Context context , String uniqueName ) { final String cachePath ; if ( context . getExternalCacheDir ( ) != null && Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return new File ( cachePath + File . separator + uniqueName ) ; }

sample: 1103
buggy_code: <START> String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); }
code_review: mark this method private as this is only used in this class.
target code: public static String getBucketName ( URI uri ) { if ( uri . getHost ( ) != null ) { return uri . getHost ( ) ; } if ( uri . getUserInfo ( ) == null ) { return uri . getAuthority ( ) ; } throw new IllegalArgumentException ( "Unable to determine S3 bucket from URI . " ) ; }
response: private String getBucketName ( URI uri ) { if ( uri . getHost ( ) != null ) { return uri . getHost ( ) ; } else if ( uri . getUserInfo ( ) == null ) { return uri . getAuthority ( ) ; } throw new IllegalArgumentException ( "Unable to determine S3 bucket from URI . " ) ; }

sample: 1104
buggy_code: private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot)) <END> : new DefaultMustacheFactory(new PerClassMustacheResolver(key)); }
code_review: I think we could make this initialization more terse if we initialize `MustacheResolver` with the ternary operator and pass it to `DefaultMustacheFactory`. ```java new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)) ```
target code: private MustacheFactory createNewMustacheFactory ( Class < ? extends View > key ) { return new DefaultMustacheFactory ( fileRoot . isPresent ( ) ? new FileSystemResolver ( fileRoot . get ( ) ) : new PerClassMustacheResolver ( key ) ) ; }
response: private MustacheFactory createNewMustacheFactory ( Class < ? extends View > key ) { return new DefaultMustacheFactory ( fileRoot . isPresent ( ) ? new FileSystemResolver ( fileRoot . get ( ) ) : new PerClassMustacheResolver ( key ) ) ; }

sample: 1105
buggy_code: public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && <START> !SystemElementsUtils.isSystemProtocol((Collaboration) eObject) && <END> !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; }
code_review: If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition.
target code: public boolean isValidValue ( final Object element ) { boolean result = super . isValidValue ( element ) ; if ( result ) { EObject eObject = EMFHelper . getEObject ( element ) ; result = ( ProtocolUtils . isProtocol ( eObject ) && ! SystemElementsUtils . isBaseProtocol ( ( Collaboration ) eObject ) ) ; } return result ; }
response: public boolean isValidValue ( final Object element ) { boolean result = super . isValidValue ( element ) ; if ( result ) { EObject eObject = EMFHelper . getEObject ( element ) ; result = ProtocolUtils . isProtocol ( eObject ) ; } return result ; }

sample: 1106
buggy_code: public void testLogin() throws Throwable { <START> InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); }
code_review: Very minor: consider another helper method for runOnMainSync() so we can focus on the interesting bit (loginTestTask.execute()). As a side note, executing from the main thread doesn't seem to be a requirement of "SaneAsyncTask" for whatever reason. However, it seems more proper to call execute on the main thread[0] since we think of it as a normal AsyncTask so I think we should keep it. [0] http://developer.android.com/reference/android/os/AsyncTask.html#execute(Params...)
target code: public void testLogin ( ) throws Throwable { runOnMainSync ( new Runnable ( ) { @Override public void run ( ) { loginTestTask . execute ( ) ; } } ) ; completionLatch . await ( ) ; }
response: public void testLogin ( ) throws Throwable { InstrumentationRegistry . getInstrumentation ( ) . runOnMainSync ( new Runnable ( ) { @Override public void run ( ) { runLoginTestTaskOnMainThread ( ) ; } } ) ; assertThat ( completionLatch . await ( ) , is ( true ) ) ; } private void runLoginTestTaskOnMainThread ( ) { loginTestTask . execute ( ) ; }

sample: 1107
buggy_code: public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(), <END> ClientDnsLookup.USE_ALL_DNS_IPS); }
code_review: We don't need to call `toString()`
target code: public static void warnIfDeprecatedDnsLookupValue ( AbstractConfig config ) { String clientDnsLookupValue = config . getString ( CLIENT_DNS_LOOKUP_CONFIG ) ; if ( clientDnsLookupValue . equals ( ClientDnsLookup . DEFAULT . toString ( ) ) ) log . warn ( "Configuration ' { } ' with value ' { } ' is deprecated and will be removed in " + "future version . Please use ' { } ' or another non - deprecated value . " , CLIENT_DNS_LOOKUP_CONFIG , ClientDnsLookup . DEFAULT , ClientDnsLookup . USE_ALL_DNS_IPS ) ; }
response: public static void warnIfDeprecatedDnsLookupValue ( AbstractConfig config ) { String clientDnsLookupValue = config . getString ( CLIENT_DNS_LOOKUP_CONFIG ) ; if ( clientDnsLookupValue . equals ( ClientDnsLookup . DEFAULT ) ) { log . warn ( "Configuration ' { } ' with value ' { } ' is deprecated and will be removed in future version . Please use ' { } ' or another non - deprecated value . " , CLIENT_DNS_LOOKUP_CONFIG , ClientDnsLookup . DEFAULT , ClientDnsLookup . USE_ALL_DNS_IPS ) ; } }

sample: 1108
buggy_code: public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.getStats(); <END> }
code_review: I would like to remove the method getStats and would like to make the aggStats static.
target code: public HdfsCopyStats ( String source , File destination , boolean enableStatsFile , int maxVersionsStatsFile , boolean isFileCopy , HdfsPathInfo pathInfo ) { this . sourceFile = source ; this . totalBytesTransferred = 0L ; this . bytesTransferredSinceLastReport = 0L ; this . pathInfo = pathInfo ; this . lastReportNs = System . nanoTime ( ) ; this . startTimeMS = System . currentTimeMillis ( ) ; initializeStatsFile ( destination , enableStatsFile , maxVersionsStatsFile , isFileCopy ) ; }
response: public HdfsCopyStats ( String source , File destination , boolean enableStatsFile , int maxVersionsStatsFile , boolean isFileCopy , HdfsPathInfo pathInfo ) { this . sourceFile = source ; this . totalBytesTransferred = 0L ; this . bytesTransferredSinceLastReport = 0L ; this . pathInfo = pathInfo ; this . lastReportNs = System . nanoTime ( ) ; this . startTimeMS = System . currentTimeMillis ( ) ; initializeStatsFile ( destination , enableStatsFile , maxVersionsStatsFile , isFileCopy ) ; aggStats = HdfsFetcherAggStats . stats ; } private static HdfsFetcherAggStats aggStats ;

sample: 1109
buggy_code: private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId().toString())); <END> writer.writeEndElement(); }
code_review: toString() is not needed here, AFAIK.
target code: private void writeAlias ( VmDevice device ) { writer . writeStartElement ( "alias" ) ; writer . writeAttributeString ( "name" , String . format ( "ua - % s" , device . getId ( ) . getDeviceId ( ) ) ) ; writer . writeEndElement ( ) ; }
response: private void writeAlias ( VmDevice device ) { writer . writeStartElement ( "alias" ) ; writer . writeAttributeString ( "name" , String . format ( "ua - % s" , device . getId ( ) . getDeviceId ( ) ) ) ; writer . writeEndElement ( ) ; }

sample: 1110
buggy_code: public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = checkNotNull(ImmutableList.copyOf(series)); <END> }
code_review: You shouldn't need the checkNotNull
target code: public ChartData ( IDataChartProvider < ? > provider , List < ChartSeries > series ) { fProvider = provider ; fSeries = ImmutableList . copyOf ( series ) ; }
response: public ChartData ( IDataChartProvider < ? > provider , List < ChartSeries > series ) { fProvider = provider ; fSeries = ImmutableList . copyOf ( series ) ; }

sample: 1111
buggy_code: protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); <END> }
code_review: can this case be given? I mean having an entry for the given `uuid` but with no registrations?
target code: protected boolean isRegistered ( final String uuid ) { return handlers . containsKey ( uuid ) ; }
response: protected boolean isRegistered ( final String uuid ) { return handlers . containsKey ( uuid ) && handlers . get ( uuid ) != null && ! handlers . get ( uuid ) . isEmpty ( ) ; }  This code checks if the `uuid` exists in the `handlers` map and if it has any registrations associated with it . It also checks if the value associated with the `uuid` is not null before checking if it is empty . This ensures that the code does not throw a `NullPointerException` if the value associated with the `uuid` is null .

sample: 1112
buggy_code: <START> public synchronized Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); }
code_review: @manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed.
target code: public Class < ? > defineClass ( String name , byte [ ] bytecode ) { return defineClass ( name , convertClassToResourcePath ( name ) , bytecode ) ; }
response: < START > public Class < ? > defineClass ( String name , byte [ ] bytecode ) { < END > return defineClass ( name , convertClassToResourcePath ( name ) , bytecode ) ; }

sample: 1113
buggy_code: public boolean onOptionsItemSelected(MenuItem item) { // home references the app icon if (item.getItemId() == android.R.id.home) { toggle(); // toggles the state of the sliding menu <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; }
code_review: Could we get brackets around this if {}
target code: public boolean onOptionsItemSelected ( MenuItem item ) { // home references the app icon if ( item . getItemId ( ) == android . R . id . home ) { toggle ( ) ; // toggles the state of the sliding menu if ( getSlidingMenu ( ) . isMenuShowing ( ) && menu . isAdded ( ) ) { setTitle ( ( ( ITitleable ) menu ) . getTitle ( ) ) ; } return true ; } return false ; }
response: public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { toggle ( ) ; if ( getSlidingMenu ( ) . isMenuShowing ( ) && menu . isAdded ( ) ) { setTitle ( ( ( ITitleable ) menu ) . getTitle ( ) ) ; } return true ; } return false ; }

sample: 1114
buggy_code: public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> ex) { <END> throw new UncheckedIOException(ex); } }
code_review: super nit (okay to ignore): Here and below: For consistency, consider "e" rather than "ex". Typically we only use "ex" for nested catch blocks where the name "e" is already being used by the enclosing block.
target code: public static ParcelFileDescriptor fromSocket ( Socket socket ) { FileDescriptor fd = socket . getFileDescriptor$ ( ) ; try { return fd != null ? ParcelFileDescriptor . dup ( fd ) : null ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
response: public static ParcelFileDescriptor fromSocket ( Socket socket ) { FileDescriptor fd = socket . getFileDescriptor$ ( ) ; try { return fd != null ? ParcelFileDescriptor . dup ( fd ) : null ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }

sample: 1115
buggy_code: private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); //$NON-NLS-1$ if (prefix.length() == 0) { return null; } <START> return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path; <END> }
code_review: Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?
target code: private String getThemePrefixedPath ( String path ) { String prefix = themeProperties != null ? themeProperties . get ( IntroTheme . ATT_ID ) : null ; prefix = prefix == null ? "" : prefix . trim ( ) ; // $NON - NLS - 1$ if ( prefix . length ( ) == 0 ) { return null ; } return prefix + Path . SEPARATOR + path ; }
response: private String getThemePrefixedPath ( String path ) { String prefix = themeProperties != null ? themeProperties . get ( IntroTheme . ATT_ID ) : null ; prefix = prefix == null ? "" : prefix . trim ( ) ; if ( prefix . isEmpty ( ) ) { return null ; } return prefix + ( prefix . charAt ( prefix . length ( ) - 1 ) == Path . SEPARATOR ? "" : Path . SEPARATOR ) + path ; }

sample: 1116
buggy_code: protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> m_os.write(bytes); <END> }
code_review: what about the null case?
target code: protected void writeString ( int majorType , byte [ ] bytes ) throws IOException { int len = ( bytes == null ) ? 0 : bytes . length ; writeType ( majorType , len ) ; if ( len > 0 ) { m_os . write ( bytes ) ; } }
response: protected void writeString ( int majorType , byte [ ] bytes ) throws IOException { int len = ( bytes == null ) ? 0 : bytes . length ; writeType ( majorType , len ) ; if ( bytes != null ) { m_os . write ( bytes ) ; } }

sample: 1117
buggy_code: private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } else if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END>
code_review: extra `else` statement, please remove
target code: private void checkLogData ( long address , ILogData logData ) { if ( logData == null || logData . getType ( ) == DataType . EMPTY ) { throw new RuntimeException ( "Unexpected return of empty data at address " + address + " on read" ) ; } if ( logData . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } }
response: private void checkLogData ( long address , ILogData logData ) { if ( logData == null || logData . getType ( ) == DataType . EMPTY ) { throw new RuntimeException ( "Unexpected return of empty data at address " + address + " on read" ) ; } if ( logData . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } // code to be executed after the if statements }

sample: 1118
buggy_code: private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), <END> sourceSelfTime); // merge the children callees. mergeChildren(destination, source); }
code_review: - space after comma - you need to pass the source duration as well
target code: private static void merge ( AggregatedCalledFunction destination , AggregatedCalledFunction source ) { long sourceDuration = source . getDuration ( ) ; long sourceSelfTime = source . getSelfTime ( ) ; destination . addToDuration ( sourceDuration ) ; destination . addToSelfTime ( sourceSelfTime ) ; destination . fStatistics . update ( source . fStatistics . getMaxSegment ( ) , source . fStatistics . getMinSegment ( ) , sourceDuration , sourceSelfTime ) ; // merge the children callees . mergeChildren ( destination , source ) ; }
response: private static void merge ( AggregatedCalledFunction destination , AggregatedCalledFunction source ) { long sourceDuration = source . getDuration ( ) ; long sourceSelfTime = source . getSelfTime ( ) ; destination . addToDuration ( sourceDuration ) ; destination . addToSelfTime ( sourceSelfTime ) ; destination . fStatistics . update ( source . fStatistics . getMaxSegment ( ) , source . fStatistics . getMinSegment ( ) , sourceDuration , sourceSelfTime ) ; mergeChildren ( destination , source ) ; }

sample: 1119
buggy_code: @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); <END> } return null; }); }
code_review: Think this needs to go right below line 91. `parseResponse` can return `null` (line 133), which will cause this future to never complete.
target code: @Override protected void doEnqueue ( Callback < V > callback ) { sendRequest ( ) . handle ( ( response , t ) - > { if ( t != null ) { callback . onError ( t ) ; } else { try { V value = parseResponse ( response , bodyConverter ) ; callback . onSuccess ( value ) ; } catch ( Throwable t1 ) { propagateIfFatal ( t1 ) ; callback . onError ( t1 ) ; } } return null ; } ) ; }
response: @Override protected void doEnqueue ( Callback < V > callback ) { sendRequest ( ) . handle ( ( response , t ) - > { if ( t != null ) { callback . onError ( t ) ; } else { V value = null ; try { value = parseResponse ( response , bodyConverter ) ; } catch ( Throwable t1 ) { propagateIfFatal ( t1 ) ; callback . onError ( t1 ) ; } if ( value != null ) { callback . onSuccess ( value ) ; } else { callback . onError ( new NullPointerException ( "Response was null" ) ) ; } } return null ; } ) ; }

sample: 1120
buggy_code: public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } return t; }
code_review: if (!isExplicit) { // ... around the try
target code: public SpiTransaction createServerTransaction ( boolean isExplicit , int isolationLevel ) { SpiTransaction t = transactionManager . createTransaction ( isExplicit , isolationLevel ) ; if ( isExplicit ) { try { transactionScopeManager . set ( t ) ; } catch ( PersistenceException existingTransactionError ) { t . end ( ) ; throw existingTransactionError ; } } return t ; }
response: public SpiTransaction createServerTransaction ( boolean isExplicit , int isolationLevel ) { SpiTransaction t = transactionManager . createTransaction ( isExplicit , isolationLevel ) ; if ( ! isExplicit ) { try { transactionScopeManager . set ( t ) ; } catch ( PersistenceException existingTransactionError ) { t . end ( ) ; throw existingTransactionError ; } } return t ; }

sample: 1121
buggy_code: C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.put(t, child); <START> return child; <END> } else return children.get(t); }
code_review: What about thread safety here? I might be mistaken, but by just looking at this code snippet it looks like more than one thread could check the condition, receive `false` from the `contains()` method and execute the above code block. That might be the reason the blocking `putIfAbsent` method is used here?
target code: C baseApply ( ) { final TreeMap < String , String > t = new TreeMap < String , String > ( validate ( ) ) ; C child = children . get ( t ) ; if ( child == null ) { child = newChild ( ) ; children . put ( t , child ) ; } return child ; }
response: Code Refactored :  C baseApply ( ) { final TreeMap < String , String > t = new TreeMap < String , String > ( validate ( ) ) ; synchronized ( children ) { if ( ! children . containsKey ( t ) ) { C child = newChild ( ) ; children . put ( t , child ) ; return child ; } else { return children . get ( t ) ; } } }  The code has been refactored to make it thread - safe by adding a synchronized block to ensure that only one thread can access the `children` map at a time . The `contains ( ) ` method has been replaced with `containsKey ( ) ` to improve readability . The `putIfAbsent ( ) ` method could also be used instead of the `containsKey ( ) ` and `put ( ) ` methods to make the code more concise .

sample: 1122
buggy_code: public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.startListeningForDirection(); <END> }
code_review: i'd maybe just "forward" the `onConnect` to the presenter instead
target code: public void onConnect ( String message ) { debugView . showPermanently ( getString ( R . string . connected ) ) ; switchableView . setDisplayedChild ( 1 ) ; }
response: public void onConnect ( String message ) { debugView . showPermanently ( getString ( R . string . connected ) ) ; switchableView . setDisplayedChild ( 1 ) ; presenter . onConnect ( ) ; }

An Exception occurred at sample: 1123. Error details: Error communicating with OpenAI: ('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))
BLEU: 72.57 ; EM: 23.58
Python file executed successfully.
Cloning into 'tree-sitter-java'...
ngram match: 0.7257301675312164, weighted ngram match: 0.7341005136362052, syntax_match: 0.7347872913301023, dataflow_match: 0.5933806146572104
CodeBLEU score: 69.70
Python file executed successfully.
sample: 0
buggy_code:  import java.util.ArrayList; /** * This class provides helper functions for Wifi connectivity related modules to * access WifiNative. It starts with firmware roaming. TODO(b/34819513): Move operations * such as connection to network and legacy framework roaming here. */ public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; <|startfocus|> private int mMaxNumBlacklistBssid = -1; private int mMaxNumWhitelistSsid = -1; <|endfocus|> WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } /** * Query firmware if it supports * {@link android.net.wifi.WifiManager#WIFI_FEATURE_CONTROL_ROAMING}. If yes, get the firmware * roaming capabilities. */ public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0;
code_review:  it would probably be a good idea to define this as a static, then use that anywhere you need to return -1. 
target code: import java.util.ArrayList; /** * This class provides helper functions for Wifi connectivity related modules to * access WifiNative. It starts with firmware roaming. TODO(b/34819513): Move operations * such as connection to network and legacy framework roaming here. */ public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; private int mMaxNumBlacklistBssid = INVALID_LIST_SIZE; private int mMaxNumWhitelistSsid = INVALID_LIST_SIZE; WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } /** * Query firmware if it supports * {@link android.net.wifi.WifiManager#WIFI_FEATURE_CONTROL_ROAMING}. If yes, get the firmware * roaming capabilities. */ public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0;
response: import java.util.ArrayList; public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; private static final int DEFAULT_VALUE = -1; private int mMaxNumBlacklistBssid = DEFAULT_VALUE; private int mMaxNumWhitelistSsid = DEFAULT_VALUE; WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0; } }

sample: 1
buggy_code:  mMaxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); <|startfocus|> } <|endfocus|> }
code_review:  there is no way for the caller to know if this failed. What should the proper operation be? What could cause the getRoamingCapabilities to fail? Should this then report that firmware roaming is not supported so the framework code can do the roams instead of relying on faulty firmware? or is this a sign that something major happened? Do we need to restart anything? 
target code: mMaxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } if (fallbackToFrameworkRoaming) { Log.e(TAG, "Fall back to framework roaming"); mFirmwareRoamingSupported = false; return false; } }
response: int maxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; maxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + maxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); // Report that firmware roaming is not supported so the framework code can do the roams instead of relying on faulty firmware mFirmwareRoamingSupported = false; // Restart the wifi service mWifiService.restart(); } } mMaxNumWhitelistSsid = maxNumWhitelistSsid;

sample: 2
buggy_code:  mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } } } /** * Return if firmware roaming is supported. */ public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } /** <|startfocus|> * Return the maximum size of BSSID blacklist. <|endfocus|> */ public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /** * Return the maximum size of SSID whitelist. */ public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /**
code_review:  would be good to document the return value. 
target code: mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } } } /** * Return if firmware roaming is supported. */ public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } /** * Get the maximum size of BSSID blacklist firmware supports. * * @return INVALID_LIST_SIZE if firmware roaming is not supported, or * maximum size of the BSSID blacklist firmware supports. */ public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /** * Return the maximum size of SSID whitelist. */ public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /**
response: int maxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + maxNumWhitelistSsid); public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /** * Returns the maximum size of BSSID blacklist. * @return the maximum size of BSSID blacklist if firmware roaming is supported, otherwise -1 */ public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return maxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } }

sample: 3
buggy_code:  public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { <|startfocus|> Log.e(TAG, "Firmware roaming is not supported"); return -1; <|endfocus|> }
code_review:  else not needed here. the normal case will return 
target code: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "getMaxNumBlacklistBssid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; }
response: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } Log.e(TAG, "Firmware roaming is not supported"); return -1; }

sample: 4
buggy_code:  public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { <|startfocus|> Log.e(TAG, "Firmware roaming is not supported"); return -1; <|endfocus|> }
code_review:  maybe add something like "MaxNumBlacklistBssid invalid: "... then what you have here. 
target code: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "getMaxNumBlacklistBssid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; }
response: public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { String errorMsg = "MaxNumBlacklistBssid invalid: Firmware roaming is not supported"; Log.e(TAG, errorMsg); return -1; } }

sample: 5
buggy_code:  public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { <|startfocus|> Log.e(TAG, "Firmware roaming is not supported"); return -1; <|endfocus|> }
code_review:  else not needed since the normal case will return the value 
target code: public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } else { Log.e(TAG, "getMaxNumWhitelistSsid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; }
response: public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } Log.e(TAG, "Firmware roaming is not supported"); return -1; }

sample: 6
buggy_code:  /** Sets up test. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } /** Cleans up test. */ @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private int mFeatureSetValue; <|startfocus|> private static final String TAG = "WifiConnectivityHelper Unit Test"; <|endfocus|> private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { // Return firmware roaming feature as supported by default. when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true;
code_review:  WifiConnectivityHelperTest 
target code: /** Sets up test. */ @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } /** Cleans up test. */ @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private int mFeatureSetValue; private static final String TAG = "WifiConnectivityHelperTest"; private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { // Return firmware roaming feature as supported by default. when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true;
response: @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private static final String TAG = "WifiConnectivityHelper Unit Test"; private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true; } }).when(mWifiNative).getRoamingCapabilities(any(WifiNative.RoamingCapabilities.class)); }

sample: 7
buggy_code:  public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; }}).when(mWifiNative).getRoamingCapabilities(anyObject()); <|startfocus|> mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertEquals(-1, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(-1, mWifiConnectivityHelper.getMaxNumWhitelistSsid()); <|endfocus|>
code_review:  you shouldn't need to set this, correct? the false should prevent you from attempting to read the values. 
target code: public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; }}).when(mWifiNative).getRoamingCapabilities(anyObject()); assertFalse(mWifiConnectivityHelper.getFirmwareRoamingInfo()); assertFalse(mWifiConnectivityHelper.isFirmwareRoamingSupported()); assertEquals(WifiConnectivityHelper.INVALID_LIST_SIZE, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(WifiConnectivityHelper.INVALID_LIST_SIZE, mWifiConnectivityHelper.getMaxNumWhitelistSsid());
response: Refactored Code: public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; } }).when(mWifiNative).getRoamingCapabilities(anyObject()); mWifiConnectivityHelper.getFirmwareRoamingInfo(); }

sample: 8
buggy_code:  public void verifySetFirmwareRoamingConfigurationWithGoodInput() { <|startfocus|> mWifiConnectivityHelper.getFirmwareRoamingInfo(); <|endfocus|> ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist));
code_review:  can you also please verify that sizes below the max are written? 
target code: public void verifySetFirmwareRoamingConfigurationWithGoodInput() { assertTrue(mWifiConnectivityHelper.getFirmwareRoamingInfo()); ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist));
response: public void testSetFirmwareRoamingConfigurationWithGoodInput() { mWifiConnectivityHelper.getFirmwareRoamingInfo(); ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE - 1); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE - 1); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist)); }

sample: 9
buggy_code:  * [or other varieties of that API]. * * * @hide */ public String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; <|startfocus|> } else { WifiAwareManager mgr = mMgr.get(); if (mgr == null) { Log.w(TAG, "createNetworkSpecifierPassphrase: called post GC on WifiAwareManager"); return null; } <|endfocus|> int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); } } /** * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(String)} for an
code_review:  Consider dropping the else, and just moving the remainder of the function up one level. (Functionally equivalent; I just find less nesting easier to read.) 
target code: * [or other varieties of that API]. * * * @hide */ public String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; } int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); } } /** * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(String)} for an
response: public String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; } WifiAwareManager mgr = mMgr.get(); if (mgr == null) { Log.w(TAG, "createNetworkSpecifierPassphrase: called post GC on WifiAwareManager"); return null; } int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); }

sample: 10
buggy_code: <|startfocus|> * Copyright (C) 2016 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } } 
code_review:  2017 
target code: * Copyright (C) 2017 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } }
response: ``` /* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } } ```

sample: 11
buggy_code:  boolean waitForCallback(int callback) { synchronized (mLocalLock) { <|startfocus|> Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { it.remove(); return true; } <|endfocus|> } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; }
code_review:  Maybe use ArrayDeque<>.remove(), instead? (Just a little bit shorter.) 
target code: boolean waitForCallback(int callback) { synchronized (mLocalLock) { boolean found = mCallbackQueue.remove(callback); if (found) { return true; } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; }
response: boolean waitForCallback(int callback) { synchronized (mLocalLock) { Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { mCallbackQueue.remove(callback); return true; } } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; } }

sample: 12
buggy_code:  boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { <|startfocus|> Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { return true; } } <|endfocus|> } return false;
code_review:  Maybe use ArrayDeque<>.contains(), instead? 
target code: boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { return mCallbackQueue.contains(callback); } return false;
response: boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { return mCallbackQueue.contains(callback); } }

sample: 13
buggy_code:  public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); <|startfocus|> // 1. publish <|endfocus|> session.subscribe(subscribeConfig, discoveryCb, null); assertTrue("Subscribe started", discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull("Subscribe session", discoverySession); // 2. update-subscribe subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).setServiceSpecificInfo("extras".getBytes()).build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue("Subscribe update", discoveryCb.waitForCallback( DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); // 3. destroy assertFalse("Subscribe not terminated", discoveryCb.hasCallbackAlreadyHappened( DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy(); 
code_review:  Maybe "subscribe"? 
target code: public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); // 1. subscribe session.subscribe(subscribeConfig, discoveryCb, null); assertTrue("Subscribe started", discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull("Subscribe session", discoverySession); // 2. update-subscribe subscribeConfig = new SubscribeConfig.Builder().setServiceName( serviceName).setServiceSpecificInfo("extras".getBytes()).build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue("Subscribe update", discoveryCb.waitForCallback( DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); // 3. destroy assertFalse("Subscribe not terminated", discoveryCb.hasCallbackAlreadyHappened( DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy();
response: public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder() .setServiceName(serviceName) .build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); session.subscribe(subscribeConfig, discoveryCb, null); assertTrue(discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull(discoverySession); subscribeConfig = new SubscribeConfig.Builder() .setServiceName(serviceName) .setServiceSpecificInfo("extras".getBytes()) .build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue(discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); assertFalse(discoveryCb.hasCallbackAlreadyHappened(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy(); }

sample: 14
buggy_code:  assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
code_review:  Should we call mMediaRecorder.setCamera(mCamera) here? I mean it looks more strait forward to set the camera for MediaRecorder after we query/setup the resolution. 
target code: assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
response: assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mMediaRecorder = new MediaRecorder(); mMediaRecorder.setCamera(mCamera); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setOutputFile(OUTPUT_PATH2); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); mCamera.release(); mCamera = null; }

sample: 15
buggy_code:  assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024); } private void testSetMaxFileSize( long fileSize, long tolerance) throws Exception { if (!hasMicrophone() || !hasCamera() || !hasAmrNb() || !hasH264()) { MediaUtils.skipTest("no microphone, camera, or codecs"); return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setVideoEncodingBitRate(256000); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); 
code_review:  ditto. 
target code: assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024); } private void testSetMaxFileSize( long fileSize, long tolerance) throws Exception { if (!hasMicrophone() || !hasCamera() || !hasAmrNb() || !hasH264()) { MediaUtils.skipTest("no microphone, camera, or codecs"); return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setVideoEncodingBitRate(256000); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start();
response: Code Refactored: ``` assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024); } private void testSetMaxFileSize(long fileSize, long tolerance) throws Exception { if (!hasMicrophone() || !hasCamera() || !hasAmrNb() || !hasH264()) { MediaUtils.skipTest("no microphone, camera, or codecs"); return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.release(); mCamera = null; mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setVideoEncodingBitRate(256000); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); } ```

sample: 16
buggy_code:  // Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // Get package info via packagemanager PackageInfo appInfo; try { // XXX this is lossy- apps can share a UID appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, <|startfocus|> mContext.getUserId()); <|endfocus|> } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // checkDestination() returns true if the destination is not a premium short code or the // sending app is approved to send to short codes. Otherwise, a message is sent to our // handler with the SmsTracker to request user confirmation before sending. if (checkDestination(tracker)) {
code_review:  LGTM. Actually there are 2 instances of getPackageInfo in SMSDispatcher.java and 2 in SmsApplication.java as well, should we fix them as well? Also not sure if this change will fail unit test or not because there is 1 instance in TelephonyTest.java as well. 
target code: // Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // Get package info via packagemanager PackageInfo appInfo; try { // XXX this is lossy- apps can share a UID appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, Binder.getCallingUid()); } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // checkDestination() returns true if the destination is not a premium short code or the // sending app is approved to send to short codes. Otherwise, a message is sent to our // handler with the SmsTracker to request user confirmation before sending. if (checkDestination(tracker)) {
response: // Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; // Get package info via packagemanager PackageInfo appInfo; try { appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, mContext.getUserId()); } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // checkDestination() returns true if the destination is not a premium short code or the // sending app is approved to send to short codes. Otherwise, a message is sent to our // handler with the SmsTracker to request user confirmation before sending. if (checkDestination(tracker)) {

sample: 17
buggy_code:  mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> } public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); }
code_review:  nit: no need, we will release the camera in tear down. 
target code: mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); } public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat( MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); }
response: mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); mCamera = null; public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); } }

sample: 18
buggy_code:  mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); // Recording a scene with moving objects would greatly help reduce // the time for waiting. if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); <|startfocus|> mCamera.release(); mCamera = null; <|endfocus|> } private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
code_review:  ditto 
target code: mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); // Recording a scene with moving objects would greatly help reduce // the time for waiting. if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); } private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
response: mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); mCamera.release(); mCamera = null; private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); }

sample: 19
buggy_code:  assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); <|startfocus|> mMediaRecorder.setCamera(mCamera); <|endfocus|> mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
code_review:  Calling .setCamera significantly changes the codepath executed in the media service, so this substantially changes code coverage, etc; I don't think you want to change that. Without this, media service will instantiate its own camera client in the mediaserver process; otherwise, it will proxy through the app's camera client. Both routes need testing, so we don't want to switch from one to the other without making sure both routes are still covered sufficiently. 
target code: assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; } private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2);
response: // Check if output file exists and has content private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } // Test recording video public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); // Set camera for media recorder mMediaRecorder.setCamera(mCamera); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); // Set output file descriptor for media recorder FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); // Record media with maximum file size long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); }

sample: 20
buggy_code:  || regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int)Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } } <|startfocus|> mGsmRoaming = regCodeIsRoaming(regState); mNewSS.setVoiceRegState(regCodeToServiceState(regState)); mNewSS.setRilVoiceRadioTechnology(type); mNewRejectCode = rejectCode; <|endfocus|> boolean isVoiceCapable = mPhone.getContext().getResources() .getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED
code_review:  Hal (not caps) 
target code: || regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int)Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } } mGsmRoaming = regCodeIsRoaming(registrationState); mNewRejectCode = reasonForDenial; boolean isVoiceCapable = mPhone.getContext().getResources() .getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED
response: int rejectCode = 0; int type = 0; int regState = 0; int psc = -1; try { String[] states = response.split(","); if (states.length >= 14) { regState = Integer.parseInt(states[0]); type = Integer.parseInt(states[3]); if (regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int) Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } mGsmRoaming = regCodeIsRoaming(regState); mNewSS.setVoiceRegState(regCodeToServiceState(regState)); mNewSS.setRilVoiceRadioTechnology(type); mNewRejectCode = rejectCode; boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED)) { mEmergencyOnly = true;

sample: 21
buggy_code: <|startfocus|> private int convertHalRegStateToServiceState(int regState) { <|endfocus|> switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; }
code_review:  If the HalRegState is really constrained to Hal it should get translated before it leaves Ril.java. If it's not it should probably be just convertRegStateToServiceState Looking at this furtuer this appear to not be regState -> ServiceState but Hal -> AOSP. Does anybody above RIL.java need the RegState version? 
target code: private int getRegStateFromHalRegState(int regState) { switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; }
response: private int convertRegStateToServiceState(int regState) { switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; } }

sample: 22
buggy_code:  if (DBG) { log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat); } break; } case EVENT_POLL_STATE_GPRS: { DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; <|startfocus|> int oldDataRAT = mSS.getRilDataRadioTechnology(); <|endfocus|> mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) { 
code_review:  why did you move this if nobody else in-scope is using? Please put back to tightest scoping.. 
target code: if (DBG) { log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat); } break; } case EVENT_POLL_STATE_GPRS: { DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) {
response: DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; int oldDataRAT = mSS.getRilDataRadioTechnology(); mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) { // code for CDMA }

sample: 23
buggy_code:  * <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> * <td>1&ndash;8</td> * <td>1&ndash;8</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>9&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> <|startfocus|> * <td>20&ndash;26+</td> <|endfocus|> * <td></td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> * <td>20&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated">
code_review:  26+? I suspect it's TBD, same as other lines in this change. 
target code: * <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> * <td>1&ndash;8</td> * <td>1&ndash;8</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>9&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> * <td>20&ndash;TBD</td> * <td></td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> * <td>20&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated"> * <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> * <td>9&ndash;TBD</td> * <td>20&ndash;TBD</td> * </tr> * <tr class="deprecated">
response: <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> <td>1&ndash;8</td> <td>1&ndash;8</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> <td>9&ndash;TBD</td> <td>9&ndash;TBD</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> <td>TBD</td> <td></td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> <td>20&ndash;TBD</td> <td>20&ndash;TBD</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> <td>9&ndash;TBD</td> <td>20&ndash;TBD</td> </tr>

sample: 24
buggy_code:  } } } @Test public void testSocketConnectTimeout() throws Exception { // #connect(SocketAddress endpoint, int timeout) checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); // Setting SO_TIMEOUT should not affect connect timeout. checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test <|startfocus|> public void testSocketIOStreamTimeout() throws Exception { <|endfocus|> // #read() try (ServerSocket ss = new ServerSocket(0)) { // The server socket will accept the connection without explicitly calling accept() due // to TCP backlog. checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception {
code_review:  Nit: Could probably be called ReadTimeout again. 
target code: } } } @Test public void testSocketConnectTimeout() throws Exception { // #connect(SocketAddress endpoint, int timeout) checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); // Setting SO_TIMEOUT should not affect connect timeout. checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test public void testSocketReadTimeout() throws Exception { // #read() try (ServerSocket ss = new ServerSocket(0)) { // The server socket will accept the connection without explicitly calling accept() due // to TCP backlog. checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception {
response: @Test public void testSocketConnectTimeout() throws Exception { checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test public void testSocketIOStreamTimeout() throws Exception { try (ServerSocket ss = new ServerSocket(0)) { checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception { // test code here }

sample: 25
buggy_code:  writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); } }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = <|startfocus|> !writeCompleted.await((long) (TIMEOUT_MILLIS * 1.2f), TimeUnit.MILLISECONDS); <|endfocus|> assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(5000, TimeUnit.MILLISECONDS)); } } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {
code_review:  We can wait a reasonable time here to be sure. I'd personally do an absolute of + 1000 for this. 100 millis doesn't seem like much to me, and we'd end up passing if we didn't actually wait long enough. 
target code: writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); } }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = !writeCompleted.await(TIMEOUT_MILLIS * 2, TimeUnit.MILLISECONDS); assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(5000, TimeUnit.MILLISECONDS)); } } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {
response: writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = !writeCompleted.await((long) ((TIMEOUT_MILLIS + 1000) * 1.2f), TimeUnit.MILLISECONDS); assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(5000, TimeUnit.MILLISECONDS)); } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {

sample: 26
buggy_code:  if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; <|startfocus|> Log.d(TAG, "Firmware roaming is supported"); Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" <|endfocus|> + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); return true; } } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } return false;
code_review:  could probably combine these into one log line: maybe something like "Firmware roaming supported with capabilities:..." 
target code: if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming supported with capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); return true; } } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); } return false;
response: if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming supported with capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); return true; } Log.e(TAG, "Failed to get firmware roaming capabilities"); return false;

sample: 27
buggy_code:  public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, <|startfocus|> ArrayList<String> whitelistSsids) { <|endfocus|> if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig);
code_review:  indent here looks off, either 8 spaces in from the line start above or lined up with the A in ArrayList above. 
target code: public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, ArrayList<String> whitelistSsids) { if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig);
response: public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, ArrayList<String> whitelistSsids) { if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig); }

sample: 28
buggy_code:  public boolean requestIcon(String bssid, String fileName) { <|startfocus|> if (bssid == null || fileName == null) return false; <|endfocus|> return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName);
code_review:  should have an error message 
target code: public boolean requestIcon(String bssid, String fileName) { if (bssid == null || fileName == null) { Log.e(mTAG, "Invalid arguments for Icon request."); return false; } return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName);
response: public boolean requestIcon(String bssid, String fileName) { if (bssid == null || fileName == null) { System.out.println("Error: BSSID or file name is null"); return false; } return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName); }

sample: 29
buggy_code:  * limitations under the License. */ package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; /** * Creates a mock WifiMonitor. * WARNING: This does not perfectly mock the behavior of WifiMonitor at the moment <|startfocus|> * ex. startMoniroting does nothing and will not send a connection/disconnection event <|endfocus|> */ public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override
code_review:  startMonitoring 
target code: * limitations under the License. */ package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; /** * Creates a mock WifiMonitor. * WARNING: This does not perfectly mock the behavior of WifiMonitor at the moment * ex. startMonitoring does nothing and will not send a connection/disconnection event */ public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override
response: ``` package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; /** * Creates a mock WifiMonitor. * WARNING: This does not perfectly mock the behavior of WifiMonitor at the moment * ex. startMonitoring does nothing and will not send a connection/disconnection event */ public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override public void startMonitoring() { // Do nothing } } ```

sample: 30
buggy_code:  result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } } /** * Initiate WPS Pin Display setup. * * @param groupIfName Group interface name to use. * @param bssid BSSID of the AP. Use zero'ed bssid to indicate wildcard. <|startfocus|> * @return true, if operation was successful. <|endfocus|> */ public String startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) return null; synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) return null; if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return null; } // Null values should be fine, since bssid can be empty. byte[] macAddress = null; if (bssid != null) {
code_review:  This returns a string 
target code: result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } } /** * Initiate WPS Pin Display setup. * * @param groupIfName Group interface name to use. * @param bssid BSSID of the AP. Use zero'ed bssid to indicate wildcard. * @return generated pin if operation was successful, null otherwise. */ public String startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) return null; synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) return null; if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return null; } // Null values should be fine, since bssid can be empty. byte[] macAddress = null; if (bssid != null) {
response: public boolean startWpsPinKeypad(String groupIfName, String pin) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(pin)) { return false; } synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinKeypad")) { return false; } if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return false; } SupplicantResult<Void> result = new SupplicantResult<>("startWpsPinKeypad(" + groupIfName + ", " + pin + ")"); try { result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } } public boolean startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) { return false; } synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) { return false; } if (groupIfName == null

sample: 31
buggy_code:  public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mTAG = "WifiNative-" + interfaceName; mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } <|startfocus|> // Note this affects logging on for all interfaces <|endfocus|> public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0 ? true : false); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } /******************************************************** * Native Initialization/Deinitialization ********************************************************/ /** * Setup wifi native for Client mode operations. * * 1. Starts the Wifi HAL and configures it in client/STA mode. * 2. Setup Wificond to operate in client mode and retrieve the handle to use for client * operations. *
code_review:  This comment is not true anymore, is it? 
target code: public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mTAG = "WifiNative-" + interfaceName; mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } /** * Enable verbose logging for all sub modules. */ public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0 ? true : false); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } /******************************************************** * Native Initialization/Deinitialization ********************************************************/ /** * Setup wifi native for Client mode operations. * * 1. Starts the Wifi HAL and configures it in client/STA mode. * 2. Setup Wificond to operate in client mode and retrieve the handle to use for client * operations. *
response: public class WifiNative { private final String mTAG; private final String mInterfaceName; private final WifiVendorHal mWifiVendorHal; private final SupplicantStaIfaceHal mSupplicantStaIfaceHal; private final SupplicantP2pIfaceHal mSupplicantP2pIfaceHal; private final WificondControl mWificondControl; public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mTAG = "WifiNative-" + interfaceName; mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } public void setupForClientMode() { mWifi

sample: 32
buggy_code:  public boolean startFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  This should be a 'start' shouldn't it? 
target code: public boolean startFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: Refactored Code: public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter(); }

sample: 33
buggy_code:  public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  Start? 
target code: public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: I'm sorry, but I cannot see any review comments to refactor the code. Can you please provide me with the review comments?

sample: 34
buggy_code:  public boolean startFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  start 
target code: public boolean startFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: public boolean startFilteringMulticastV6Packets() { boolean stopFilterResult = mSupplicantStaIfaceHal.stopRxFilter(); boolean removeFilterResult = mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST); boolean startFilterResult = mSupplicantStaIfaceHal.startRxFilter(); return stopFilterResult && removeFilterResult && startFilterResult; }

sample: 35
buggy_code:  public boolean stopFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) <|startfocus|> && mSupplicantStaIfaceHal.stopRxFilter(); <|endfocus|>
code_review:  start 
target code: public boolean stopFilteringMulticastV6Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter( SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
response: public boolean stopFilteringMulticastV6Packets() { boolean stopFilterResult = mSupplicantStaIfaceHal.stopRxFilter(); boolean addFilterResult = mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST); boolean startFilterResult = mSupplicantStaIfaceHal.startRxFilter(); return stopFilterResult && addFilterResult && startFilterResult; }

sample: 36
buggy_code:  public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } /** * "sta" prioritizes STA connection over P2P and "p2p" prioritizes * P2P connection over STA */ public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } <|startfocus|> /** WifiSupplicantControl methods. TODO: These should use HIDL soon. */ <|endfocus|> /** * Migrate all the configured networks from wpa_supplicant. * * @param configs Map of configuration key to configuration objects corresponding to all * the networks. * @param networkExtras Map of extra configuration parameters stored in wpa_supplicant.conf * @return Max priority of all the configs. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); } /**
code_review:  soon is now? 
target code: public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } /** * "sta" prioritizes STA connection over P2P and "p2p" prioritizes * P2P connection over STA */ public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } /** * Migrate all the configured networks from wpa_supplicant. * * @param configs Map of configuration key to configuration objects corresponding to all * the networks. * @param networkExtras Map of extra configuration parameters stored in wpa_supplicant.conf * @return Max priority of all the configs. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); } /**
response: public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } /** WifiSupplicantControl methods. TODO: These should use HIDL soon. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); }

sample: 37
buggy_code:  /** * Handler to notify the occurrence of various events during PNO scan. */ public interface PnoEventHandler { /** * Callback to notify when one of the shortlisted networks is found during PNO scan. * @param results List of Scan results received. */ void onPnoNetworkFound(ScanResult[] results); /** * Callback to notify when the PNO scan schedule fails. */ void onPnoScanFailed(); } <|startfocus|> /* scan status, keep these values in sync with gscan.h */ <|endfocus|> public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); } 
code_review:  no longer necessary. 
target code: /** * Handler to notify the occurrence of various events during PNO scan. */ public interface PnoEventHandler { /** * Callback to notify when one of the shortlisted networks is found during PNO scan. * @param results List of Scan results received. */ void onPnoNetworkFound(ScanResult[] results); /** * Callback to notify when the PNO scan schedule fails. */ void onPnoScanFailed(); } public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); }
response: public interface PnoEventHandler { void onPnoNetworkFound(ScanResult[] results); void onPnoScanFailed(); } public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); }

sample: 38
buggy_code:  public void setWifiLinkLayerStats(String iface, int enable) { <|startfocus|> // Nothing to do here. Link layer stats is enabled when the HAL is started. <|endfocus|>
code_review:  Maybe add a TODO w/ a bugid to rm calling code. 
target code: public void setWifiLinkLayerStats(String iface, int enable) { // TODO(b//36087365) Remove this. Link layer stats is enabled when the HAL is started.
response: public void setWifiLinkLayerStats(String iface, int enable) { // TODO: BugID - Remove calling code as link layer stats is enabled when the HAL is started. }

sample: 39
buggy_code: <|startfocus|> public boolean isGetChannelsForBandSupported(){ <|endfocus|> return mWifiVendorHal.isGetChannelsForBandSupported();
code_review:  If you add the missing space, will checkstyle punish you by requiring javadoc? :-) 
target code: /** * Indicates whether getChannelsForBand is supported. * * @return true if it is. */ public boolean isGetChannelsForBandSupported() { return mWifiVendorHal.isGetChannelsForBandSupported();
response: ``` public boolean isGetChannelsForBandSupported() { return mWifiVendorHal.isGetChannelsForBandSupported(); } ``` Note: The missing space has been added and the code has been refactored according to the review.

sample: 40
buggy_code:  void onWifiAlert(int errorCode, byte[] buffer); } public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName){ return mWifiVendorHal.startLoggingRingBuffer( verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } <|startfocus|> <|endfocus|> public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus{ String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0);
code_review:  My comment on line 1151 belongs here. 
target code: void onWifiAlert(int errorCode, byte[] buffer); } public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName){ return mWifiVendorHal.startLoggingRingBuffer( verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } /** * Stops all logging and resets the logger callback. * This stops both the alerts and ring buffer data collection. */ public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus{ String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0);
response: ``` public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName) { return mWifiVendorHal.startLoggingRingBuffer(verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus { String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0); } ```

sample: 41
buggy_code:  * @hide */ public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. <|startfocus|> * Unit of this value should be in MHz. <|endfocus|> * @hide */ public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
code_review:  why call it earfcn then? Shouldn't it be freq? 
target code: * @hide */ public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * @hide */ public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
response: public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EARFCN_THRESHOLD_INT = "signal_strength_freq_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); }

sample: 42
buggy_code:  "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * Unit of this value should be in MHz. * @hide */ <|startfocus|> public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = <|endfocus|> "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false);
code_review:  typo 
target code: "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * Threshold of EARFCN above which signal_strength_offset_int will be applied. * Unit of this value should be in MHz. * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCN_THRESHOLD_INT = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false);
response: public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOLD_INT = "signal_strength_earfcn_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false); }

sample: 43
buggy_code:  * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ <|startfocus|> public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { <|endfocus|> return iccOpenLogicalChannel(getSubId(), AID, p2); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220.
code_review:  There are a number of apps that use this API. It should be deprecated and a new one added with p2. 
target code: * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, int p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220.
response: /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String AID, byte p2) { return iccOpenLogicalChannel(subId, AID, 0, p2); }

sample: 44
buggy_code:  * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API <|startfocus|> * The gscan API is used to perform background scans and wificond is used for onehot scans. <|endfocus|> * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative);
code_review:  oneshot 
target code: * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for oneshot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative);
response: package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for onehot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative); mWificondScannerDelegate = new WificondScannerImpl(context, wifiNative, looper); mHalBasedPnoSupported = wifiNative.isHalPnoSupported(); mHandler = new Handler(looper, this); } @Override

sample: 45
buggy_code:  * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiMonitor; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API <|startfocus|> * The gscan API is used to perform background scans and wificond is used for onehot scans. <|endfocus|> * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, WifiMonitor wifiMonitor, Looper looper, Clock clock) {
code_review:  looks like this slipped back in 
target code: * limitations under the License. */ package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiMonitor; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for oneshot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, WifiMonitor wifiMonitor, Looper looper, Clock clock) {
response: Here's the refactored code: ``` package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiMonitor; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for onehot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, WifiMonitor wifiMonitor, Looper looper, Clock clock) { super(context, wifiMonitor, looper, clock); mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(mWifiNative); mWificondScannerDelegate = new WificondScannerImpl(context, wifiNative

sample: 46
buggy_code:  public void describeTo(Description description) { <|startfocus|> description.appendText(toString()); <|endfocus|>
code_review:  Nit: formatting. 
target code: public void describeTo(Description description) { description.appendText(toString());
response: public void describeTo(Description description) { description.appendText(toString()); }

sample: 47
buggy_code:  String[] s; s = params.getCipherSuites(); if (s != null) { setEnabledCipherSuites(s); } s = params.getProtocols(); if (s != null) { setEnabledProtocols(s); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } } <|startfocus|> // Android-added: Make toString explicit that this is an SSLServerSocket (see b/6602228) <|endfocus|> @Override public String toString() { return "SSL" + super.toString(); } } 
code_review:  Just nits. Personal preference: The "see " is implicit. I personally prefer a leading http://b/ so I can click on it in an IDE (for sure) & gerrit (I think). The bug reference is probably superfluous in this case; not sure what people would gain from looking at the bug. Judgement call, though. Would apply to both. 
target code: String[] s; s = params.getCipherSuites(); if (s != null) { setEnabledCipherSuites(s); } s = params.getProtocols(); if (s != null) { setEnabledProtocols(s); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } } // Android-added: Make toString explicit that this is an SSLServerSocket (http://b/6602228) @Override public String toString() { return "SSL" + super.toString(); } }
response: String[] cipherSuites = params.getCipherSuites(); if (cipherSuites != null) { setEnabledCipherSuites(cipherSuites); } String[] protocols = params.getProtocols(); if (protocols != null) { setEnabledProtocols(protocols); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } // Android-added: Make toString explicit that this is an SSLServerSocket (http://b/6602228) @Override public String toString() { return "SSL" + super.toString(); }

sample: 48
buggy_code:  */ public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** <|startfocus|> * Lookup the ANQP elements associated with the given AP from the cache. An empty map <|endfocus|> * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(
code_review:  Nit: extra white space. 
target code: */ public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** * Lookup the ANQP elements associated with the given AP from the cache. An empty map * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(
response: public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(bssid, vsa.anqpDomainID, vsa.hessid)); return (anqpEntry != null) ? anqpEntry.getANQPElements() : new HashMap<Constants.ANQPElementType, ANQPElement>(); }

sample: 49
buggy_code:  mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** <|startfocus|> * Lookup the ANQP elements associated with the given AP from the cache. An empty map <|endfocus|> * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey( scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID));
code_review:  Maybe move this to @return? 
target code: mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** * Lookup the ANQP elements associated with the given AP from the cache. An empty map * will be returned if no match found in the cache. * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { // Retrieve the Hotspot 2.0 Vendor Specific IE. InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); // Lookup ANQP data in the cache. long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey( scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID));
response: public void notifyWnmFrameReceived(byte[] data) { mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** * Lookup the ANQP elements associated with the given AP from the cache. An empty map will be returned if no match found in the cache. * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID)); return anqpEntry != null ? anqpEntry.getANQPElements() : Collections.emptyMap(); }

sample: 50
buggy_code:  public void enter() { super.enter(); <|startfocus|> if (!mBluetoothRouteManager.isInbandRingingEnabled()) { setSpeakerphoneOn(false); } <|endfocus|> CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState();
code_review:  no need to do this. At this stage setSpeakerphoneOn(true/false) should not be called as this only applies to in call state. Hall, Why was it called in the first place? Is it a way to reset speakerphone state before starting the call? 
target code: public void enter() { super.enter(); setSpeakerphoneOn(false); // Do not enable SCO audio here, since RING is being sent to the headset. CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState();
response: public void enter() { super.enter(); if (!mBluetoothRouteManager.isInbandRingingEnabled()) { CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState(); } }

sample: 51
buggy_code:  * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { <|startfocus|> return iccOpenLogicalChannel(getSubId(), AID, (byte) 0x00); <|endfocus|> } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00
code_review:  this is ok as long as the behavior is going to be the same as earlier when API didn't have p2 as a parameter. 
target code: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { return iccOpenLogicalChannel(getSubId(), AID, -1); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00
response: public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { return iccOpenLogicalChannel(getSubId(), AID, (byte) 0x00); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); }

sample: 52
buggy_code:  private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); <|startfocus|> // Use 16 bits of the hashCode of the interface name as the Subnet ID. final IpPrefix local64 = getUniqueLocalPrefix(ulp, (short) ifname.hashCode(), 64); <|endfocus|> lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp;
code_review:  16 bits might not be long enough to ensure no collisions. If we currently only support one downstream, then you could use 0 everywhere. If not, then perhaps this code should keep state? 
target code: private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); final IpPrefix local64 = getUniqueLocalPrefix(ulp, subnetId, 64); lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp;
response: private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); int subnetId = 0; // Use 16 bits of the hashCode of the interface name as the Subnet ID. if (ifname != null) { subnetId = ifname.hashCode() & 0xFFFF; } final IpPrefix local64 = getUniqueLocalPrefix(ulp, (short) subnetId, 64); lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp; }

sample: 53
buggy_code:  private int mEvdoDbm; // This value is the EVDO RSSI value private int mEvdoEcio; // This value is the EVDO Ec/Io private int mEvdoSnr; // Valid values are 0-8. 8 is the highest signal to noise ratio private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; <|startfocus|> private int mLteOffset; // offset to be reduced from the rsrp threshold while calculating // signal strength level <|endfocus|> private int mTdScdmaRscp; private boolean isGsm; // This value is set by the ServiceStateTracker onSignalStrengthResult /** * Create a new SignalStrength from a intent notifier Bundle * * This method is used by PhoneStateIntentReceiver and maybe by * external applications. * * @param m Bundle from intent notifier * @return newly created SignalStrength * * @hide */ public static SignalStrength newFromBundle(Bundle m) { SignalStrength ret; ret = new SignalStrength(); ret.setFromNotifierBundle(m);
code_review:  mLteRsrpOffset. Actually not too happy with Offset either - it doesn't give an indication of direction. If a positive number here is better would this be an mLteRsrpBoost? 
target code: private int mEvdoDbm; // This value is the EVDO RSSI value private int mEvdoEcio; // This value is the EVDO Ec/Io private int mEvdoSnr; // Valid values are 0-8. 8 is the highest signal to noise ratio private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; private int mLteRsrpBoost; // offset to be reduced from the rsrp threshold while calculating // signal strength level private int mTdScdmaRscp; private boolean isGsm; // This value is set by the ServiceStateTracker onSignalStrengthResult /** * Create a new SignalStrength from a intent notifier Bundle * * This method is used by PhoneStateIntentReceiver and maybe by * external applications. * * @param m Bundle from intent notifier * @return newly created SignalStrength * * @hide */ public static SignalStrength newFromBundle(Bundle m) { SignalStrength ret; ret = new SignalStrength(); ret.setFromNotifierBundle(m);
response: private int mEvdoDbm; private int mEvdoEcio; private int mEvdoSnr; private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; private int mLteRsrpBoost; private int mTdScdmaRscp; private boolean isGsm; public static SignalStrength newFromBundle(Bundle bundle) { SignalStrength ret = new SignalStrength(); ret.setFromNotifierBundle(bundle); return ret; }

sample: 54
buggy_code: <|startfocus|> public void setLteOffset(int lteOffset) { mLteOffset = lteOffset; <|endfocus|>
code_review:  setLteRsrpOffset? 
target code: public void setLteRsrpBoost(int lteRsrpBoost) { mLteRsrpBoost = lteRsrpBoost;
response: public void setLteRsrpOffset(int lteRsrpOffset) { mLteRsrpOffset = lteRsrpOffset; }

sample: 55
buggy_code:  */ int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray( com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal."); } else { if (mLteRsrp > threshRsrp[5]) { rsrpIconLevel = -1; <|startfocus|> } else if (mLteRsrp >= (threshRsrp[4] - mLteOffset)) { <|endfocus|> rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } else if (mLteRsrp >= (threshRsrp[3] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_GOOD; } else if (mLteRsrp >= (threshRsrp[2] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_MODERATE; } else if (mLteRsrp >= (threshRsrp[1] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_POOR; } else if (mLteRsrp >= threshRsrp[0]) {
code_review:  are you certain this is what's desired? It would be nice if the offset applied throughout the range, but you're still keeping the upper and lower ends fixed which makes this more complicated. 
target code: */ int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray( com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal."); } else { if (mLteRsrp > threshRsrp[5]) { rsrpIconLevel = -1; } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) { rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } else if (mLteRsrp >= (threshRsrp[3] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_GOOD; } else if (mLteRsrp >= (threshRsrp[2] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_MODERATE; } else if (mLteRsrp >= (threshRsrp[1] - mLteOffset)) { rsrpIconLevel = SIGNAL_STRENGTH_POOR; } else if (mLteRsrp >= threshRsrp[0]) {
response: int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN; int rsrpIconLevel = -1; int snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements. Cannot evaluate RSRP signal."); } else { int offset = mLteOffset; for (int i = 5; i >= 0; i--) { int thresh = threshRsrp[i] - offset; if (mLteRsrp >= thresh) { rsrpIconLevel = i; break; } } if (rsrpIconLevel >= 0) { rsrpIconLevel++; } if (rsrpIconLevel > SIGNAL_STRENGTH_GREAT) { rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } }

sample: 56
buggy_code:  "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * List of EARFCN ranges on which signal_strength_offset_int will be applied. <|startfocus|> * Format of the String array is expected to be {"erafcn1_start", earfcn1_end", * "earfcn2_start", "earfcn2_end" ... } <|endfocus|> * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
code_review:  I thought the format was going to be "start-end" for each string in the array. 
target code: "notify_international_call_on_wfc_bool"; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; /** * List of EARFCN ranges on which signal_strength_offset_int will be applied. * Format of the String array is expected to be {"erafcn1_start-earfcn1_end", * "earfcn2_start-earfcn2_end" ... } * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; /** The default value for every variable. */ private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true);
response: public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); } /** * List of EARFCN ranges on which signal_strength_offset_int will be applied. * Format of the String array is expected to be {"start1-end1", "start2-end2", ... } * @hide */ public static final String[] SIGNAL_STRENGTH_EARFCNS_LIST_DEFAULT = { "0-65535" }; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final int SIGNAL_STRENGTH_OFFSET_INT_DEFAULT = 0; /** * The default value for every variable. */ public static PersistableBundle getDefaultValues() { PersistableBundle bundle = new PersistableBundle(); bundle.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); bundle.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true);

sample: 57
buggy_code:  * @return error a {@code TETHER_ERROR} value indicating success or failure type * * {@hide} */ public int setUsbTethering(boolean enable) { try { return mService.setUsbTethering(enable); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /** * Request that a local-only Wi-Fi hotspot be started. The supplied Wi-Fi <|startfocus|> * configuration will be used after switch to station mode (STA), and must * be non-null. <|endfocus|> * * Local-only Wi-Fi hotspot functionality is currently mutually exclusive * with other tethering functionality. * * @param cfg The {@link android.net.wifi.WifiConfiguration} to use. * @return error a {@code TETHER_ERROR} value indicating success or failure * * @hide */ public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { try { return mService.startLocalOnlyWifiHotspot(cfg); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /**
code_review:  this is confusing... something like "to start the wifi hotspot" ? 
target code: * @return error a {@code TETHER_ERROR} value indicating success or failure type * * {@hide} */ public int setUsbTethering(boolean enable) { try { return mService.setUsbTethering(enable); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /** * Request that a local-only Wi-Fi hotspot be started. The supplied Wi-Fi * configuration is used to start the Wi-Fi hotspot, and must be non-null. * * Local-only Wi-Fi hotspot functionality is currently mutually exclusive * with other tethering functionality. * * @param cfg The {@link android.net.wifi.WifiConfiguration} to use. * @return error a {@code TETHER_ERROR} value indicating success or failure * * @hide */ public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { try { return mService.startLocalOnlyWifiHotspot(cfg); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } /**
response: Code: ``` public int startWifiHotspot(WifiConfiguration config) { try { return mService.startLocalOnlyWifiHotspot(config); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } public int setUsbTethering(boolean enable) { try { return mService.setUsbTethering(enable); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } ``` Description: The `startWifiHotspot` method starts a local-only Wi-Fi hotspot using the provided `WifiConfiguration`. This functionality is currently mutually exclusive with other tethering functionality. The `setUsbTethering` method sets the USB tethering state to either enabled or disabled. It returns a `TETHER_ERROR` value indicating success or failure.

sample: 58
buggy_code:  public void getFirmwareRoamingInfo() { <|startfocus|> reset(mWifiConnectivityHelper); <|endfocus|> mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo();
code_review:  a more accurate name here would be helpful. verifyGetFirmwareRoamingInfoIsCalledWhenWifiEnabled() (it is long, but you get the point - otherwise this might be a helper of some sort) 
target code: public void getFirmwareRoamingInfo() { reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo();
response: public void verifyGetFirmwareRoamingInfoIsCalledWhenWifiEnabled() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); }

sample: 59
buggy_code:  // SSID as the one to be selected. WifiConfiguration currentNetwork = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); <|startfocus|> verify(mWifiStateMachine).startRoamToNetwork( anyInt(), anyObject()); <|endfocus|>
code_review:  this can either fit on one line or, better yet, check the int and config. make sure you get the right values. 
target code: // SSID as the one to be selected. WifiConfiguration currentNetwork = generateWifiConfig( 0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine).startRoamToNetwork(eq(CANDIDATE_NETWORK_ID), mCandidateScanResultCaptor.capture()); assertEquals(mCandidateScanResultCaptor.getValue().BSSID, CANDIDATE_BSSID);
response: WifiConfiguration currentNetwork = generateWifiConfig(0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine).startRoamToNetwork(anyInt(), anyObject());

sample: 60
buggy_code:  public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); <|startfocus|> verify(mWifiStateMachine, times(0)).startRoamToNetwork( anyInt(), anyObject()); <|endfocus|>
code_review:  does this actually check the right thing? you are connected.. but does it know the correct network? I am not as familiar with this test, but it seems like you might not call this anyway. 
target code: public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged( WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject());
response: public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Verify that startRoamToNetwork is not called verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject()); }

sample: 61
buggy_code:  * 6. "San Francisco" location card opens. * 7. Select "San Francisco". * 8. Tap on the Drive icon. * Verify: * 1. Map points to San Francisco location. * 2. Navigation overview is displayed. * </pre> */ @Test @TestInfo(id = "145493594") public void testMapsApp() throws Exception { <|startfocus|> String QUERY_STRING = "San Francisco"; <|endfocus|> Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); AppLauncher.launch(instrumentation, "Maps"); UiObject acceptButton = mDevice.findObject(new UiSelector().textContains("ACCEPT & CONTINUE")); // "Accept & Continue" occurs only on first time Maps gets launched. if (acceptButton.exists()) { acceptButton.clickAndWaitForNewWindow(); } // SKIP button only exist's occurs only on first time Maps gets launched. UiObject skipText = mDevice.findObject(new UiSelector().textContains("SKIP")); if (skipText.exists()) {
code_review:  Move to class's constants (private static final) 
target code: * 6. "San Francisco" location card opens. * 7. Select "San Francisco". * 8. Tap on the Drive icon. * Verify: * 1. Map points to San Francisco location. * 2. Navigation overview is displayed. * </pre> */ @Test @TestInfo(id = "145493594") public void testMapsApp() throws Exception { Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); AppLauncher.launch(instrumentation, "Maps"); UiObject acceptButton = mDevice.findObject(new UiSelector().textContains("ACCEPT & CONTINUE")); // "Accept & Continue" occurs only on first time Maps gets launched. if (acceptButton.exists()) { acceptButton.clickAndWaitForNewWindow(); } // SKIP button only exist's occurs only on first time Maps gets launched. UiObject skipText = mDevice.findObject(new UiSelector().textContains("SKIP")); if (skipText.exists()) {
response: Here's the refactored code: ```java private static final String QUERY_STRING = "San Francisco"; @Test @TestInfo(id = "145493594") public void testMapsApp() throws Exception { Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); AppLauncher.launch(instrumentation, "Maps"); UiObject acceptButton = mDevice.findObject(new UiSelector().textContains("ACCEPT & CONTINUE")); if (acceptButton.exists()) { acceptButton.clickAndWaitForNewWindow(); } UiObject skipText = mDevice.findObject(new UiSelector().textContains("SKIP")); if (skipText.exists()) { skipText.clickAndWaitForNewWindow(); } UiObject searchBox = mDevice.findObject(new UiSelector().descriptionContains("Search")); searchBox.clickAndWaitForNewWindow(); UiObject searchEditText = mDevice.findObject(new UiSelector().className("android.widget.EditText")); searchEditText.setText(QUERY_STRING); mDevice.pressEnter(); UiObject sanFranciscoCard = mDevice.findObject(new UiSelector().textContains(QUERY_STRING)); sanFranciscoCard.clickAndWaitForNewWindow(); UiObject driveIcon = mDevice.findObject(new UiSelector().descriptionContains("Drive")); driveIcon.clickAndWaitForNewWindow(); UiObject map = mDevice.findObject(new UiSelector().descriptionContains(QUERY_STRING)); assertTrue(map.exists

sample: 62
buggy_code:  scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. UiObject searchTextView = searchUiObject.getChild(new UiSelector().className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); <|startfocus|> } else{ <|endfocus|> searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); } 
code_review:  nit: add a space 
target code: scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. UiObject searchTextView = searchUiObject.getChild(new UiSelector().className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); } else { searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector() .className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); // Verify the Query String is present after completing search. Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); }
response: scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector().className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); UiObject searchTextView = searchUiObject.getChild(new UiSelector().className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); if(condition){ searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector().className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); } else{ // do something else }

sample: 63
buggy_code:  private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = <|startfocus|> "com.google.android.clockwork.cmas.intent.extra.ID"; <|endfocus|> @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver())
code_review:  since we are moving from wear, should we also use the new namespace? 
target code: private static final String TAG = "CellBroadcastReceiver"; static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.android.cellbroadcastreceiver.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver())
response: private static final String TAG = "CellBroadcastReceiver"; private static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.google.android.clockwork.cmas.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) { Log.d(TAG, "onReceive " + intent); } String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()); } }

sample: 64
buggy_code:  protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); <|startfocus|> final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); <|endfocus|> if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
code_review:  consider moving this down to the if block. 
target code: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
response: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); if (ACTION_MARK_AS_READ.equals(action)) { final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done. } }

sample: 65
buggy_code:  protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); <|startfocus|> if (ACTION_MARK_AS_READ.equals(action)) { <|endfocus|> new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
code_review:  do you need to register in the manifest? 
target code: protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done.
response: protected void onReceive(Context context, Intent intent) { String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done. } }

sample: 66
buggy_code:  /** Intent action to display alert dialog/notification, after verifying the alert is new. */ static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; /** Use the same notification ID for non-emergency alerts. */ static final int NOTIFICATION_ID = 1; /** Sticky broadcast for latest area info broadcast received. */ static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; <|startfocus|> /** * Intent extra */ <|endfocus|> private static final String EXTRA_MESSAGE = "message"; /** * Container for service category, serial number, location, body hash code, and ETWS primary/ * secondary information for duplication detection. */ private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory;
code_review:  nit: probably one line since others above follow that format? Also, should probably add some description, e.g. something like: "Intent extra for passing an SmsCbMessage" 
target code: /** Intent action to display alert dialog/notification, after verifying the alert is new. */ static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; /** Use the same notification ID for non-emergency alerts. */ static final int NOTIFICATION_ID = 1; /** Sticky broadcast for latest area info broadcast received. */ static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; /** Intent extra for passing a SmsCbMessage */ private static final String EXTRA_MESSAGE = "message"; /** * Container for service category, serial number, location, body hash code, and ETWS primary/ * secondary information for duplication detection. */ private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory;
response: static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; static final int NOTIFICATION_ID = 1; static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; private static final String EXTRA_MESSAGE = "message"; private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory; mSerialNumber = serialNumber; mLocation = location; mBodyHash = bodyHash; mIsEtwsPrimary = isEtwsPrimary; } }

sample: 67
buggy_code:  ArrayList<CellBroadcastMessage> messageList, Context context, boolean fromSaveState) { int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); // Create intent to show the new messages when user selects the notification. Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { <|startfocus|> // For wear we want to mark as read intent = createWearDeleteIntent(context, message.getDeliveryTime()); <|endfocus|> } else { // For phone we handle it differently intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent,
code_review:  nit: Wear 
target code: ArrayList<CellBroadcastMessage> messageList, Context context, boolean fromSaveState) { int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); // Create intent to show the new messages when user selects the notification. Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { // For FEATURE_WATCH we want to mark as read intent = createMarkAsReadIntent(context, message.getDeliveryTime()); } else { // For phone we handle it differently intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent,
response: ArrayList<CellBroadcastMessage> messageList; Context context; boolean fromSaveState; int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { intent = createWearDeleteIntent(context, message.getDeliveryTime()); } else { intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT); }

sample: 68
buggy_code: <|startfocus|> static Intent createWearDeleteIntent(Context context, long deliveryTime) { <|endfocus|> Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent;
code_review:  hmm, lets name createMarkAsReadIntent? Can probably leave Wear out since it could possibly be used in other contexts. 
target code: static Intent createMarkAsReadIntent(Context context, long deliveryTime) { Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent;
response: static Intent createMarkAsReadIntent(Context context, long deliveryTime) { Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent; }

sample: 69
buggy_code:  /** * @hide */ public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; /** * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if, for example, netd dies and is restarted. <|startfocus|> * <|endfocus|> * @return an INetd instance or null. */ public static INetd getInstance() { // NOTE: ServiceManager does no caching for the netd service, // because netd is not one of the defined common services. final INetd netdInstance = INetd.Stub.asInterface( ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. *
code_review:  comment that INetd should never be cached outside of this interface? 
target code: /** * @hide */ public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; /** * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if, for example, netd dies and is restarted. * * Returned instances of INetd should not be cached. * * @return an INetd instance or null. */ public static INetd getInstance() { // NOTE: ServiceManager does no caching for the netd service, // because netd is not one of the defined common services. final INetd netdInstance = INetd.Stub.asInterface( ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. *
response: public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; /** * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if, for example, netd dies and is restarted. * * @return an INetd instance or null. */ public static INetd getInstance() { // NOTE: ServiceManager does no caching for the netd service, // because netd is not one of the defined common services. final INetd netdInstance = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. */ public static synchronized INetd waitForInstance() { INetd netdInstance = null; int timeoutMs = BASE_TIMEOUT_MS; while (netdInstance == null && timeoutMs <= MAX_TIMEOUT_MS) { netdInstance = getInstance(); if (netdInstance == null) {

sample: 70
buggy_code:  if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. * * It is the caller's responsibility to handle RemoteException errors * from invocations on the returned interface if, for example, netd * dies after this interface was returned. * * Returned instances of INetd should not be cached. * * @return an INetd instance or null. */ <|startfocus|> public static INetd get() { for (int i = 0; ; i++) { <|endfocus|> final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } } 
code_review:  Can this actually happen ? It looks like the loop goes on until getInstance is not null. 
target code: if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. * * It is the caller's responsibility to handle RemoteException errors * from invocations on the returned interface if, for example, netd * dies after this interface was returned. * * Returned instances of INetd should not be cached. * * @return an INetd instance or null. */ public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; for (int i = 0; i > -1; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } }
response: public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } }

sample: 71
buggy_code:  public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); <|startfocus|> } catch (InterruptedException e) {} <|endfocus|> }
code_review:  Is the timeout arithmetics needed for doing linear backoff ? I would like to suggest the following alternative that does not include arithmetics per say, or at least less of it: timeoutMs = BASE_TIME_MS; while (true) { ... Thread.sleep(timeoutMs); timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); } 
target code: public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } // No netdInstance was received; sleep and retry. final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; }
response: public static INetd get() { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); } }

sample: 72
buggy_code: <|startfocus|> void run(INetd netd) throws RemoteException, ServiceSpecificException; <|endfocus|> } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */
code_review:  ServiceSpecificException is a runtime exception, no need to declare it in the signature (it doesn't really have any effect because callers don't have to catch). 
target code: void run(INetd netd) throws RemoteException; } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */
response: void run(INetd netd) throws RemoteException { /** * Blocks until an INetd instance is available, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */ }

sample: 73
buggy_code:  void run(INetd netd) throws RemoteException, ServiceSpecificException; } /** * Blocks until an INetd instance is availabe, and retries until either <|startfocus|> * the command succeeds or a ServiceSpecificError is thrown. <|endfocus|> */
code_review:  -> runtime 
target code: void run(INetd netd) throws RemoteException, ServiceSpecificException; } /** * Blocks until an INetd instance is availabe, and retries until either * the command succeeds or a runtime exception is thrown. */
response: void run(INetd netd) throws RemoteException, ServiceSpecificException; /** * Blocks until an INetd instance is available, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */

sample: 74
buggy_code:  public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; <|startfocus|> } catch (RemoteException re) {} <|endfocus|> }
code_review:  Is this a good idea to pass in INed to cmd even if it is null ? With the current usage in IpManager, this immediately triggers an NPE that's not caught. That seemed to be the case before, but if I understand correctly this patch tries to correct this issue right ? I suggest: INetd netd = get(); if (netd == null) { continue; } cmd.run(netd) (this is assuming that get() can indeed returns null based on its doc) 
target code: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "error communicated with netd: " + re); } }
response: public static void run(NetdCommand cmd) { while (true) { INetd netd = get(); if (netd == null) { continue; } try { cmd.run(netd); return; } catch (RemoteException re) {} } }

sample: 75
buggy_code:  public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; <|startfocus|> } catch (RemoteException re) {} <|endfocus|> }
code_review:  Shouldn't the error be logged ? 
target code: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "error communicated with netd: " + re); } }
response: public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "Error occurred while running command", re); } } }

sample: 76
buggy_code:  ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); } @TimeoutReq(minutes = 80) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } <|startfocus|> final int NUMBER_REPETITION = 6; <|endfocus|> FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis();
code_review:  let's reduce this to 3. A test taking over hour is not ok. 
target code: ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); } @TimeoutReq(minutes = 80) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } final int NUMBER_REPETITION = 3; FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis();
response: Refactored Code: ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); @TimeoutReq(minutes = 30) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } final int NUMBER_REPETITION = 3; FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis(); // rest of the code }

sample: 77
buggy_code:  private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { /** <|startfocus|> * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are managed <|endfocus|> * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); // If a configuration is temporarily disabled, re-enable it before trying // to connect to it. mWifiConfigManager.tryEnableNetwork(network.networkId); //TODO(b/30928589): Enable "permanently" disabled networks if we are in DISCONNECTED // state. // Clear the cached candidate, score and seen. mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId); 
code_review:  Extra white space? 
target code: private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { /** * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are managed * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); // If a configuration is temporarily disabled, re-enable it before trying // to connect to it. mWifiConfigManager.tryEnableNetwork(network.networkId); //TODO(b/30928589): Enable "permanently" disabled networks if we are in DISCONNECTED // state. // Clear the cached candidate, score and seen. mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId);
response: private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); mWifiConfigManager.tryEnableNetwork(network.networkId); mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId); } }

sample: 78
buggy_code:  List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration == null) { continue; } else { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { /** <|startfocus|> * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are being evaluated <|endfocus|> * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (!status.isNetworkEnabled()) { continue; } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate.
code_review:  Nit: extra white space? 
target code: List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration == null) { continue; } else { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { /** * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are being evaluated * by {@link PasspointNetworkEvaluator}. */ if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (!status.isNetworkEnabled()) { continue; } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate.
response: List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration != null) { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { if (!network.isPasspoint()) { WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (status.isNetworkEnabled()) { if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate. } } } }

sample: 79
buggy_code:  "am stack move-top-activity-to-pinned-stack 1 0 0 500 500"; protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; <|startfocus|> private static final String AM_NO_HOME_SCREEN = "am no-home-screen"; <|endfocus|> private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; /** A reference to the device under test. */ protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) {
code_review:  is this am command already supported in the aosp ? 
target code: "am stack move-top-activity-to-pinned-stack 1 0 0 500 500"; protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; /** A reference to the device under test. */ protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) {
response: protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; private static final String AM_NO_HOME_SCREEN = "am no-home-screen"; private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; /** A reference to the device under test. */ protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) { return activityName; }

sample: 80
buggy_code:  public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { <|startfocus|> if (mMode == Mode.LOCAL_HOTSPOT) { <|endfocus|> if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
code_review:  We probably need to check for mode being TETHERING here. 
target code: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { final Mode current = mMode; if (current != Mode.IDLE) { if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
response: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.TETHERING) { if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true); }

sample: 81
buggy_code:  public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { <|startfocus|> Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); <|endfocus|> } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
code_review:  Nit: "Local hotspot already started"? 
target code: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Already in mode: " + current.description); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true);
response: public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot already started"); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true); }

sample: 82
buggy_code:  public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { if (VDBG) { <|startfocus|> Log.e(TAG, "Attempt to stopLocalOnlyWifiHotspot absent corresponding start."); <|endfocus|> } return; } setWifiTethering(null, false);
code_review:  "Local hotspot not running"? 
target code: public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot not running."); } return; } setWifiTethering(null, false);
response: public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot not running"); } return; } setWifiTethering(null, false); }

sample: 83
buggy_code:  protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode == Mode.TETHERING) { try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } <|startfocus|> } else { // Reset to tethering mode (default mode). mMode = Mode.TETHERING; <|endfocus|> } transitionTo(mInitialState); return true;
code_review:  I would say put it unconditionally after the if branch if this is a condition that needs to be ensured. 
target code: protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode == Mode.TETHERING) { try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } } transitionTo(mInitialState); return true;
response: protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode != Mode.TETHERING) { // Reset to tethering mode (default mode). mMode = Mode.TETHERING; } try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } transitionTo(mInitialState); return true; }

sample: 84
buggy_code: import java.util.Random; /** * IPv6 tethering is rather different from IPv4 owing to the absence of NAT. * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces. * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; <|startfocus|> private static class DownstreamState { <|endfocus|> public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<DownstreamState> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>();
code_review:  Nit: "drop the State, it's cleaner"? 
target code: import java.util.Random; /** * IPv6 tethering is rather different from IPv4 owing to the absence of NAT. * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces. * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class Downstream { public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<DownstreamState> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>();
response: import java.util.ArrayList; import java.util.LinkedList; import java.util.Random; /** * IPv6 tethering is rather different from IPv4 owing to the absence of NAT. * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces. * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class Downstream { public final TetherInterfaceStateMachine tism; public final short subnetId; Downstream(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<Downstream> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); } }

sample: 85
buggy_code:  */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class DownstreamState { public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; <|startfocus|> private final LinkedList<DownstreamState> mActiveDownstreams; <|endfocus|> private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect.
code_review:  Nit: could/should this be a Map from subnet ID to TetherInterfaceStateMachine? If so I think you would't need the DownstreamState class. Equivalently it could be a SparseArray keyed off subnet ID But this is fine too. 
target code: */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class DownstreamState { public final TetherInterfaceStateMachine tism; public final short subnetId; DownstreamState(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<Downstream> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect.
response: public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final HashMap<Short, TetherInterfaceStateMachine> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new HashMap<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (!mActiveDownstreams.containsValue(downstream)) { mActiveDownstreams.put(mNextSubnetId, downstream); mNextSubnetId++; } } }

sample: 86
buggy_code:  public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. <|startfocus|> mActiveDownstreams.offer(new DownstreamState(downstream, mNextSubnetId++)); <|endfocus|> updateIPv6TetheringInterfaces(); }
code_review:  Do you need to do something when mNextSubnetId goes from 32767 to -32768? 
target code: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { // Adding a new downstream appends it to the list. Adding a // downstream a second time without first removing it has no effect. mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId++)); updateIPv6TetheringInterfaces(); }
response: public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { int subnetId = mNextSubnetId++; if (subnetId == Short.MAX_VALUE) { mNextSubnetId = Short.MIN_VALUE; } mActiveDownstreams.offer(new DownstreamState(downstream, subnetId)); updateIPv6TetheringInterfaces(); } }

sample: 87
buggy_code:  private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; // 6 = 48bits / 8bits/byte (new Random()).nextBytes(ulp); <|startfocus|> final byte[] in6addr = new byte[NetworkConstants.IPV6_ADDR_LEN]; System.arraycopy(ulp, 0, in6addr, 0, ulp.length); <|endfocus|> in6addr[0] = (byte) 0xfd; // fc00::/7 and L=1 return in6addr;
code_review:  I think it can be folded into: Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN) that would return an array of length NetworkConstants.IPV6_ADDR_LEN padded with 0s. 
target code: private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; // 6 = 48bits / 8bits/byte (new Random()).nextBytes(ulp); final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN); in6addr[0] = (byte) 0xfd; // fc00::/7 and L=1 return in6addr;
response: private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; (new Random()).nextBytes(ulp); final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN); in6addr[0] = (byte) 0xfd; // fc00::/7 and L=1 return in6addr; }

sample: 88
buggy_code:  ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); // The filter for the time event. ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); // Run the activity. mContext.startActivity(intent, options.toBundle()); // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { <|startfocus|> // At this time the timerReceiver should not fire, even though the activity has shut <|endfocus|> // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the reciever then.
code_review:  nit: whitespace 
target code: ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); // The filter for the time event. ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); // Run the activity. mContext.startActivity(intent, options.toBundle()); // Wait until it finishes and end the reciever then. assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen. assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } // Issuing now another activity will trigger the timing information release. final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent); // Wait until it finishes and end the reciever then.
response: ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); mContext.startActivity(intent, options.toBundle()); assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent);

sample: 89
buggy_code:  private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; /* Used only for debugging purposes. */ private String mRegistrationDeniedReason; private String mCurrentCarrier = null; /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) <|startfocus|> * pairs for which the lte rsrp boost is applied */ <|endfocus|> private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. private final Object mLteRsrpBoostLock = new Object(); // mLteRsrpBoost lock public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable);
code_review:  range. Also is it inclusive? Inclusiveness should also appear in the carrierconfig comments. 
target code: private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; /* Used only for debugging purposes. */ private String mRegistrationDeniedReason; private String mCurrentCarrier = null; /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) * inclusive ranges for which the lte rsrp boost is applied */ private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. private final Object mLteRsrpBoostLock = new Object(); // mLteRsrpBoost lock public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable);
response: private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; private String mRegistrationDeniedReason; private String mCurrentCarrier = null; private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; private final Object mLteRsrpBoostLock = new Object(); public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); }

sample: 90
buggy_code:  /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) * pairs for which the lte rsrp boost is applied */ private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. <|startfocus|> private final Object mLteRsrpBoostLock = new Object(); // mLteRsrpBoost lock <|endfocus|> public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance();
code_review:  don't need (it's the name..) 
target code: /* list of LTE EARFCNs (E-UTRA Absolute Radio Frequency Channel Number, * Reference: 3GPP TS 36.104 5.4.3) * pairs for which the lte rsrp boost is applied */ private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; // offset which is reduced from the rsrp threshold // while calculating signal strength level. private final Object mLteRsrpBoostLock = new Object(); private static final int INVALID_LTE_EARFCN = -1; public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean( com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance();
response: private ArrayList<Pair<Integer, Integer>> earfcnPairListForRsrpBoost = null; private int lteRsrpBoost = 0; private final Object lteRsrpBoostLock = new Object(); public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance(); }

sample: 91
buggy_code:  && ServiceState.isCdma(newDataRat))) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (DBG) { log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } <|startfocus|> updateLteEarfcnBoost(getLteEarfcn(dataRegStateResult)); <|endfocus|> break; } case EVENT_POLL_STATE_OPERATOR: { if (mPhone.isPhoneTypeGsm()) { String opNames[] = (String[]) ar.result; if (opNames != null && opNames.length >= 3) { // FIXME: Giving brandOverride higher precedence, is this desired? String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null; if (brandOverride != null) {
code_review:  pass in ServiceState so it's clear what's getting updated. The name doesn't suggested mNewSS is altered. 
target code: && ServiceState.isCdma(newDataRat))) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (DBG) { log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult)); break; } case EVENT_POLL_STATE_OPERATOR: { if (mPhone.isPhoneTypeGsm()) { String opNames[] = (String[]) ar.result; if (opNames != null && opNames.length >= 3) { // FIXME: Giving brandOverride higher precedence, is this desired? String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null; if (brandOverride != null) {
response: if (dataRegStateResult != null) { int dataRegState = dataRegStateResult.getDataRegState(); int newDataRat = dataRegStateResult.getRilDataRadioTechnology(); int voiceRegState = mSS.getVoiceRegState(); int dataRegState = dataRegStateResult.getDataRegState(); int regState = dataRegStateResult.getRegState(); mNewSS.setVoiceRegState(voiceRegState); mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); mNewSS.setRilVoiceRadioTechnology(newVoiceRat); mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (ServiceState.isCdma(newDataRat)) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } updateLteEarfcnBoost(getLteEarfcn(dataRegStateResult)); } else { log("handlePollStateResultMessage: EVENT_POLL_STATE_REGISTRATION_CDMA newSS=null"); } if (mPhone.isPhoneTypeGsm()) { String opNames[] = (String[]) ar.result; if (opNames != null && opNames.length >= 3) { String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() :

sample: 92
buggy_code:  private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if ((lteEarfcn != -1) && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { <|startfocus|> mNewSS.setLteEarfcnRsrpBoost(mLteRsrpBoost); <|endfocus|> } else { mNewSS.setLteEarfcnRsrpBoost(0); } }
code_review:  this should be a defined constant used here and in getLteEarfcn when not found. 
target code: private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if ((lteEarfcn != -1) && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { serviceState.setLteEarfcnRsrpBoost(mLteRsrpBoost); } else { mNewSS.setLteEarfcnRsrpBoost(0); } }
response: private static final int LTE_EARFCN_NOT_FOUND = -1; private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if ((lteEarfcn != LTE_EARFCN_NOT_FOUND) && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { mNewSS.setLteEarfcnRsrpBoost(mLteRsrpBoost); } else { mNewSS.setLteEarfcnRsrpBoost(0); } } }

sample: 93
buggy_code:  && mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if(conn != null) { <|startfocus|> conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); <|endfocus|> } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo); }
code_review:  Wrap to 100 chars. 
target code: && mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if(conn != null) { conn.setPreciseDisconnectCause( getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo); }
response: && mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if(conn != null) { conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo);

sample: 94
buggy_code:  * onFeatureCapabilityChanged(int, int[], int[])} callbacks, or values received via the * {@link ImsCallProfile#EXTRA_CALL_RAT_TYPE} extra. Util we receive a value via the extras, * we will use the wifi state based on the {@code onFeatureCapabilityChanged}. Once a value * is received via the extras, we will prefer those values going forward. */ private boolean mIsWifiStateFromExtras = false; <|startfocus|> private int mPreciseCause = 0; <|endfocus|> //***** Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; //***** Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60*1000; //***** Inner Classes class MyHandler extends Handler {
code_review:  mPreciseDisconnectCause 
target code: * onFeatureCapabilityChanged(int, int[], int[])} callbacks, or values received via the * {@link ImsCallProfile#EXTRA_CALL_RAT_TYPE} extra. Util we receive a value via the extras, * we will use the wifi state based on the {@code onFeatureCapabilityChanged}. Once a value * is received via the extras, we will prefer those values going forward. */ private boolean mIsWifiStateFromExtras = false; private int mPreciseDisconnectCause = 0; //***** Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; //***** Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60*1000; //***** Inner Classes class MyHandler extends Handler {
response: private int mPreciseDisconnectCause = 0; // Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; // Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60 * 1000; // Inner Classes class MyHandler extends Handler { // implementation }

sample: 95
buggy_code:  /** Not a preempted call */ public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state <|startfocus|> public static final int ILLEGAL_STATE = 1201; <|endfocus|> // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206;
code_review:  ImsReasonInfo is CODE_LOCAL_ILLEGAL_ARGUMENT. Should we keep the LOCAL part? 
target code: /** Not a preempted call */ public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int LOCAL_ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206;
response: public static final int CDMA_PREEMPTED = 1007; public static final int CDMA_NOT_EMERGENCY = 1008; public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206;

sample: 96
buggy_code:  public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error <|startfocus|> public static final int INTERNAL_ERROR = 1202; <|endfocus|> // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state)
code_review:  ImsReasonInfo is CODE_LOCAL_ILLEGAL_STATE. Should we keep the LOCAL part? 
target code: public static final int CDMA_PREEMPTED = 1007; /** Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008; /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int LOCAL_INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state)
response: public static final int CDMA_PREEMPTED = 1007; public static final int CDMA_NOT_EMERGENCY = 1008; public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206; public static final int OUT_OF_SERVICE = 1207;

sample: 97
buggy_code:  /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) <|startfocus|> public static final int IMS_SERVICE_DOWN = 1203; <|endfocus|> // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered)
code_review:  Should we keep the LOCAL part (similar to ImsReasonInfo)? 
target code: /** Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009; /** Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int LOCAL_IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered)
response: public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206; public static final int NETWORK_NO_SERVICE = 1207;

sample: 98
buggy_code:  public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off <|startfocus|> public static final int POWER_OFF = 1205; <|endfocus|> // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered) */ public static final int NETWORK_NO_LTE_COVERAGE = 1208; /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209;
code_review:  Should we keep the "LOCAL" prefix similar to in ImsReasonInfo? 
target code: public static final int ILLEGAL_ARGUMENT = 1200; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201; // IMS service internal error public static final int INTERNAL_ERROR = 1202; // IMS service goes down (service connection is lost) public static final int IMS_SERVICE_DOWN = 1203; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204; // Service unavailable; by power off public static final int LOCAL_POWER_OFF = 1205; // Service unavailable; by low battery public static final int LOW_BATTERY = 1206; // Service unavailable; by out of service (data service state) public static final int NETWORK_NO_SERVICE = 1207; /* Service unavailable; by no LTE coverage * (VoLTE is not supported even though IMS is registered) */ public static final int NETWORK_NO_LTE_COVERAGE = 1208; /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209;
response: public static final int LOCAL_ILLEGAL_ARGUMENT = 1200; public static final int LOCAL_ILLEGAL_STATE = 1201; public static final int LOCAL_INTERNAL_ERROR = 1202; public static final int LOCAL_IMS_SERVICE_DOWN = 1203; public static final int LOCAL_NO_PENDING_CALL = 1204; public static final int LOCAL_POWER_OFF = 1205; public static final int LOCAL_LOW_BATTERY = 1206; public static final int LOCAL_NETWORK_NO_SERVICE = 1207; public static final int LOCAL_NETWORK_NO_LTE_COVERAGE = 1208; public static final int LOCAL_NETWORK_ROAMING = 1209;

sample: 99
buggy_code:  /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209; /** Service unavailable; by IP changed */ public static final int NETWORK_IP_CHANGED = 1210; /** Service unavailable; other */ public static final int SERVICE_UNAVAILABLE = 1211; /* Service unavailable; IMS connection is lost (IMS is not registered) */ public static final int NOT_REGISTERED = 1212; /** Max call exceeded */ <|startfocus|> public static final int CALL_EXCEEDED = 1213; <|endfocus|> /** Call decline */ public static final int LOCAL_CALL_DECLINE = 1214; /** SRVCC is in progress */ public static final int VCC_ON_PROGRESSING = 1215; /** Resource reservation is failed (QoS precondition) */ public static final int RESOURCE_RESERVATION_FAILED = 1216; /** Retry CS call; VoLTE service can't be provided by the network or remote end * Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set */
code_review:  I'm curious, the ImsReasonInfo version of this (and some others) is LOCAL_CALL_EXCEEDED; does it make sense to call this one LOCAL_CALL_EXCEEDED as well? This is especially confusing when you consider MAXIMUM_NUMBER_OF_CALLS_REACHED, which is used for multi-endpoint. Suggest: MAX_LOCAL_CALLS_EXCEEDED for this one? 
target code: /** Service unavailable; by located in roaming area */ public static final int NETWORK_ROAMING = 1209; /** Service unavailable; by IP changed */ public static final int NETWORK_IP_CHANGED = 1210; /** Service unavailable; other */ public static final int SERVICE_UNAVAILABLE = 1211; /* Service unavailable; IMS connection is lost (IMS is not registered) */ public static final int NOT_REGISTERED = 1212; /** Max call exceeded */ public static final int LOCAL_MAX_CALL_EXCEEDED = 1213; /** Call decline */ public static final int LOCAL_CALL_DECLINE = 1214; /** SRVCC is in progress */ public static final int VCC_ON_PROGRESSING = 1215; /** Resource reservation is failed (QoS precondition) */ public static final int RESOURCE_RESERVATION_FAILED = 1216; /** Retry CS call; VoLTE service can't be provided by the network or remote end * Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set */
response: public static final int NETWORK_ROAMING = 1209; public static final int NETWORK_IP_CHANGED = 1210; public static final int SERVICE_UNAVAILABLE = 1211; public static final int NOT_REGISTERED = 1212; public static final int MAX_LOCAL_CALLS_EXCEEDED = 1213; public static final int LOCAL_CALL_DECLINE = 1214; public static final int VCC_ON_PROGRESSING = 1215; public static final int RESOURCE_RESERVATION_FAILED = 1216; // Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set // Retry CS call; VoLTE service can't be provided by the network or remote end.


sample: 0
buggy_code: private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) { return resourceTypes.getRoots().stream() .map(ResourceType::getQualifier) <START> .filter(q -> !DEPRECATED_QUALIFIERS.contains(q)) <END> .collect(Collectors.toCollection(TreeSet::new)); }
code_review: I think LIBRARY are no more used
target code: private static Set < String > getRootQualifiers ( ResourceTypes resourceTypes ) { return resourceTypes . getRoots ( ) . stream ( ) . map ( ResourceType : : getQualifier ) . collect ( Collectors . toCollection ( TreeSet : : new ) ) ; }
response: private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) { return resourceTypes.getRoots().stream() .map(ResourceType::getQualifier) <START> .filter(q -> !DEPRECATED_QUALIFIERS.contains(q)) .filter(q -> !LIBRARY_QUALIFIERS.contains(q)) <END> .collect(Collectors.toCollection(TreeSet::new)); }

sample: 1
buggy_code: public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) { this.rootWrapper = workUnit.getRootWrapper(); this.drillbitContext = drillbitContext; <START> lineSeparator = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction("line.separator")); <END> }
code_review: Consider using `System.lineSeparator()` instead.
target code: public RuntimeFilterManager ( QueryWorkUnit workUnit , DrillbitContext drillbitContext ) { this . rootWrapper = workUnit . getRootWrapper ( ) ; this . drillbitContext = drillbitContext ; }
response: public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) { this.rootWrapper = workUnit.getRootWrapper(); this.drillbitContext = drillbitContext; <START> lineSeparator = System.lineSeparator(); <END> }

sample: 2
buggy_code: private void activateMarkers() { if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) { String value = NLS.bind(Messages.ChangeDetailEditor_EGerriTipValue, <START> fChangeInfo.getUserSelectedRevision().get_number()); <END> UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, value); } }
code_review: ChangeDetailEditor_EGerriTipValue has no more arguments, should we just use it directly , no need to set the arguments ?
target code: private void activateMarkers ( ) { if ( ! fGerritClient . getRepository ( ) . getServerInfo ( ) . isAnonymous ( ) ) { UIUtils . showDialogTip ( MARKERS_KEY , headerSection . getShell ( ) , Messages . EGerriTip , Messages . ChangeDetailEditor_EGerriTipValue ) ; } }
response: private void activateMarkers() { if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) { String value = <START> Messages.ChangeDetailEditor_EGerriTipValue <END> UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, value); } }

sample: 3
buggy_code: public void testCreate() throws StripeException { Map<String, Object> params = new HashMap<String, Object>(); params.put("currency", "usd"); final Order order = Order.create(params); assertNotNull(order); verifyRequest( APIResource.RequestMethod.POST, <START> "/v1/orders", <END> params ); }
code_review: should be called `resource`
target code: public void testCreate ( ) throws StripeException { final Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( "currency" , "usd" ) ; final Order order = Order . create ( params ) ; assertNotNull ( order ) ; verifyRequest ( APIResource . RequestMethod . POST , " / v1 / orders" , params ) ; }
response: public void testCreate() throws StripeException { Map<String, Object> params = new HashMap<String, Object>(); params.put("currency", "usd"); final Order order = Order.create(params); assertNotNull(order); verifyRequest( APIResource.RequestMethod.POST, <START> "/v1/orders", <END> params ); }

sample: 4
buggy_code: private FirewallRule findById(List<FirewallRule> collection, String id) { FirewallRule result = null; for (FirewallRule rule : collection) { if (rule.id().equals(id)) { <START> result = rule; <END> } } return result; }
code_review: Just `return rule`.
target code: private FirewallRule findById ( List < FirewallRule > collection , String id ) { for ( FirewallRule rule : collection ) { if ( rule . id ( ) . equals ( id ) ) { return rule ; } } return null ; }
response: private FirewallRule findById(List<FirewallRule> collection, String id) { FirewallRule result = null; for (FirewallRule rule : collection) { if (rule.id().equals(id)) { <START> return rule; <END> } } return result; }

sample: 5
buggy_code: public void addDownload(String download){ <START> if(!downloads.contains(download)) { <END> downloads.add(download); } }
code_review: Should probably use a Set<String> instead of a List<String> so that the intention of the code is clear by first glance.
target code: public void addDownload ( String download ) { downloads . add ( download ) ; }
response: public void addDownload(String download){ <START> if(!downloads.contains(download)) { <END> downloads.add(download); } }

sample: 6
buggy_code: public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) { for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) { CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail); newDetail.setObjectId(null); newDetail.setDocumentNumber(getDocumentNumber()); <START> newDetail.setVersionNumber(new Long(0)); <END> getObjectCodeGlobalDetails().add(newDetail); } }
code_review: Should this be 1 or null instead of 0?
target code: public void copyDetailsFromOtherCuObjectCodeActivationGlobal ( CuObjectCodeActivationGlobal oldGlobal ) { for ( CuObjectCodeGlobalDetail oldDetail : oldGlobal . getObjectCodeGlobalDetails ( ) ) { CuObjectCodeGlobalDetail newDetail = ( CuObjectCodeGlobalDetail ) ObjectUtils . deepCopy ( oldDetail ) ; newDetail . setObjectId ( null ) ; newDetail . setDocumentNumber ( getDocumentNumber ( ) ) ; newDetail . setVersionNumber ( new Long ( 1 ) ) ; getObjectCodeGlobalDetails ( ) . add ( newDetail ) ; } }
response: public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) { for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) { CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail); newDetail.setObjectId(null); newDetail.setDocumentNumber(getDocumentNumber()); <START> newDetail.setVersionNumber(null); <END> getObjectCodeGlobalDetails().add(newDetail); } }

sample: 7
buggy_code: private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) { if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) { return; } model.setSelectedProtocol(ConsoleProtocol.VNC); asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode <START> .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE)))); <END> }
code_review: You can not be sure that the value is present in the local storage (see the storeVncData). Please wrap the ...valueOf(...) by try-catch
target code: private void loadVncData ( HasConsoleModel model , KeyMaker keyMaker ) { if ( ! ( model . getDefaultConsoleModel ( ) instanceof VncConsoleModel ) ) { return ; } model . setSelectedProtocol ( ConsoleProtocol . VNC ) ; try { asVncConsoleModel ( model ) . setVncImplementation ( VncConsoleModel . ClientConsoleMode . valueOf ( clientStorage . getLocalItem ( keyMaker . make ( VNC_CLIENT_MODE ) ) ) ) ; } catch ( Exception e ) { } }
response: private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) { if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) { return; } model.setSelectedProtocol(ConsoleProtocol.VNC); asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode <START> .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE)))); <END> }

sample: 8
buggy_code: private RuleApplication applyRule() { SymbolAllocator symbolAllocator = new SymbolAllocator(symbols); Memo memo = new Memo(idAllocator, plan); Lookup lookup = Lookup.from(memo::resolve); Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session)); <START> return new RuleApplication( <END> memo, lookup, symbolAllocator.getTypes(), result); }
code_review: These arguments can all go on the same line
target code: private RuleApplication applyRule ( ) { SymbolAllocator symbolAllocator = new SymbolAllocator ( symbols ) ; Memo memo = new Memo ( idAllocator , plan ) ; Lookup lookup = Lookup . from ( memo : : resolve ) ; Optional < PlanNode > result = inTransaction ( session - > rule . apply ( memo . getNode ( memo . getRootGroup ( ) ) , lookup , idAllocator , symbolAllocator , session ) ) ; return new RuleApplication ( lookup , symbolAllocator . getTypes ( ) , result ) ; }
response: private RuleApplication applyRule() { SymbolAllocator symbolAllocator = new SymbolAllocator(symbols); Memo memo = new Memo(idAllocator, plan); Lookup lookup = Lookup.from(memo::resolve); Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session)); <START> return new RuleApplication(memo, lookup, symbolAllocator.getTypes(), result); <END> }

sample: 9
buggy_code: public void testPushDownArray() throws Exception { testParquetFilterPushDown("t.`user`.hobby_ids[0] = 1", 3, 2); testParquetFilterPushDown("t.`user`.hobby_ids[0] = 100", 0, 1); <START> testParquetFilterPushDown("t.`user`.hobby_ids[0] <> 1", 8, 7); <END> testParquetFilterPushDown("t.`user`.hobby_ids[2] > 20", 5, 4); testParquetFilterPushDown("t.`user`.hobby_ids[0] between 10 and 20", 5, 5); testParquetFilterPushDown("t.`user`.hobby_ids[4] = 15", 1, 3); testParquetFilterPushDown("t.`user`.hobby_ids[2] is not null", 11, 6); testParquetFilterPushDown("t.`user`.hobby_ids[3] is null", 11, 7); }
code_review: Why the expected output was changed?
target code: public void testPushDownArray ( ) throws Exception { testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] = 1" , 3 , 2 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] = 100" , 0 , 1 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] < > 1" , 8 , 6 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 2 ] > 20" , 5 , 3 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] between 10 and 20" , 5 , 4 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 4 ] = 15" , 1 , 3 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 2 ] is not null" , 11 , 6 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 3 ] is null" , 11 , 7 ) ; }
response: public void testPushDownArray() throws Exception { testParquetFilterPushDown("t.`user`.hobby_ids[0] = 1", 3, 2); testParquetFilterPushDown("t.`user`.hobby_ids[0] = 100", 0, 1); testParquetFilterPushDown("t.`user`.hobby_ids[0] <> 1", 8, 7); testParquetFilterPushDown("t.`user`.hobby_ids[2] > 20", 5, 4); testParquetFilterPushDown("t.`user`.hobby_ids[0] between 10 and 20", 5, 5); testParquetFilterPushDown("t.`user`.hobby_ids[4] = 15", 1, 3); testParquetFilterPushDown("t.`user`.hobby_ids[2] is not null", 11, 6); testParquetFilterPushDown("t.`user`.hobby_ids[3] is null", 11, 7); }

sample: 10
buggy_code: default Direction getBubbleElevatorDirection() { Block block = this.getBlockState().getBlock(); if (block == Blocks.BUBBLE_COLUMN) { <START> return this.getBlockState().get(BubbleColumnBlock.DRAG) ? Direction.DOWN : Direction.UP; <END> } else { return block.getBubbleElevatorDirection(this.getBlockState()); } }
code_review: This logic should be in the default implementation.
target code: default Direction getBubbleElevatorDirection ( ) { return this . getBlockState ( ) . getBlock ( ) . getBubbleElevatorDirection ( this . getBlockState ( ) ) ; }
response: default Direction getBubbleElevatorDirection() { Block block = this.getBlockState().getBlock(); if (block == Blocks.BUBBLE_COLUMN) { <START> return this.getBlockState().get(BubbleColumnBlock.DRAG) ? Direction.DOWN : Direction.UP; <END> } else { return block.getBubbleElevatorDirection(this.getBlockState()); } }

sample: 11
buggy_code: public void testSystemPropertiesOverrideConfigurationValues() { final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString(); Configuration config = Configuration.getInstance(); try { Assert.assertEquals("75", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); System.setProperty(keyName, "something else"); Assert.assertEquals("something else", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); } finally { System.clearProperty(keyName); <START> Configuration.clearProperty(keyName); <END> } }
code_review: Why access this method staticly?
target code: public void testSystemPropertiesOverrideConfigurationValues ( ) { final String keyName = CoreConfig . MAX_CASSANDRA_CONNECTIONS . toString ( ) ; Configuration config = Configuration . getInstance ( ) ; try { Assert . assertEquals ( "75" , config . getStringProperty ( CoreConfig . MAX_CASSANDRA_CONNECTIONS ) ) ; System . setProperty ( keyName , "something else" ) ; Assert . assertEquals ( "something else" , config . getStringProperty ( CoreConfig . MAX_CASSANDRA_CONNECTIONS ) ) ; } finally { System . clearProperty ( keyName ) ; config . clearProperty ( keyName ) ; } }
response: public void testSystemPropertiesOverrideConfigurationValues() { final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString(); Configuration config = Configuration.getInstance(); try { Assert.assertEquals("75", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); System.setProperty(keyName, "something else"); Assert.assertEquals("something else", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); } finally { System.clearProperty(keyName); <START> config.clearProperty(keyName); <END> } }

sample: 12
buggy_code: public void onSubscribe(Subscription inner) { <START> SubscriptionHelper.setOnce(this, inner); <END> o.onSubscribe(this); inner.request(Long.MAX_VALUE); }
code_review: You can set it on a plain field, no need for atomics: ``` java this.inner = inner; o.onSubscribe(this); inner.request(Long.MAX_VALUE); ```
target code: public void onSubscribe ( Subscription inner ) { this . inner = inner ; o . onSubscribe ( this ) ; inner . request ( Long . MAX_VALUE ) ; }
response: public void onSubscribe(Subscription inner) { <START> this.inner = inner; <END> o.onSubscribe(this); inner.request(Long.MAX_VALUE); }

sample: 13
buggy_code: public WebElement forElementPresent(By by) { changeImplicitWait(250, TimeUnit.MILLISECONDS); try { return wait.until(ExpectedConditions.presenceOfElementLocated(by)); } catch(TimeoutException e) { PageObjectLogging.log( ELEMENT_PRESENT_MESSAGE, String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()), <START> true <END> ); throw e; } finally { restoreDeaultImplicitWait(); } }
code_review: `true` -> `false` ?
target code: public WebElement forElementPresent ( By by ) { changeImplicitWait ( 250 , TimeUnit . MILLISECONDS ) ; try { return wait . until ( ExpectedConditions . presenceOfElementLocated ( by ) ) ; } catch ( TimeoutException e ) { PageObjectLogging . log ( ELEMENT_PRESENT_MESSAGE , String . format ( ELEMENT_PRESENT_ERROR_FORMAT , by . toString ( ) ) , false ) ; throw e ; } finally { restoreDeaultImplicitWait ( ) ; } }
response: public WebElement forElementPresent(By by) { changeImplicitWait(250, TimeUnit.MILLISECONDS); try { return wait.until(ExpectedConditions.presenceOfElementLocated(by)); } catch(TimeoutException e) { PageObjectLogging.log( ELEMENT_PRESENT_MESSAGE, String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()), <START> false <END> ); throw e; } finally { restoreDeaultImplicitWait(); } }

sample: 14
buggy_code: public boolean accept(Issue issue) { <START> if (issueShouldNotBeReported(issue, excludedLinesByRule())) { <END> return false; } return true; }
code_review: could be simplified.
target code: public boolean accept ( Issue issue ) { return ! issueShouldNotBeReported ( issue , excludedLinesByRule ( ) ) ; }
response: public boolean accept(Issue issue) { <START> return !issueShouldNotBeReported(issue, excludedLinesByRule()); <END> }

sample: 15
buggy_code: <START> public HashMap<String, <END> ArrayList<Order>> getBuyOrders() { return buyOrders; }
code_review: this method should be changed to private
target code: private HashMap < String , ArrayList < Order > > getBuyOrders ( ) { return buyOrders ; }
response: <START> private HashMap<String, <END> ArrayList<Order>> getBuyOrders() { return buyOrders; }

sample: 16
buggy_code: <START> public static <END> Color getSystemForegroundColor(Display display) { ColorRegistry colorRegistry = JFaceResources.getColorRegistry(); Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR); if (foreground == null) { return JFaceColors.getInformationViewerForegroundColor(display); } return foreground; }
code_review: There's no need to make these public, even if the package is internal.
target code: private static Color getSystemForegroundColor ( Display display ) { ColorRegistry colorRegistry = JFaceResources . getColorRegistry ( ) ; Color foreground = colorRegistry . get ( JFacePreferences . INFORMATION_FOREGROUND_COLOR ) ; if ( foreground == null ) { return JFaceColors . getInformationViewerForegroundColor ( display ) ; } return foreground ; }
response: <START> static <END> Color getSystemForegroundColor(Display display) { ColorRegistry colorRegistry = JFaceResources.getColorRegistry(); Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR); if (foreground == null) { return JFaceColors.getInformationViewerForegroundColor(display); } return foreground; }

sample: 17
buggy_code: public void visitNode(Tree tree) { if (!hasSemantic()) { return; } SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree; <START> Optional<CaseLabelTree> defaultLabel = getDefaultLabel(switchStatementTree); <END> if (!defaultLabel.isPresent()) { if (!isSwitchOnEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Add a default case to this switch."); } else if (missingCasesOfEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Complete cases by adding the missing enum constants or add a default case to this switch."); } } }
code_review: You should go one step more in simplifying the rule: Change this method to return a boolean: `hasNoDefault(switchStatementTree)` ``` return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault); ```
target code: public void visitNode ( Tree tree ) { if ( ! hasSemantic ( ) ) { return ; } SwitchStatementTree switchStatementTree = ( SwitchStatementTree ) tree ; if ( getDefaultLabel ( switchStatementTree ) ) { if ( ! isSwitchOnEnum ( switchStatementTree ) ) { reportIssue ( switchStatementTree . switchKeyword ( ) , "Add a default case to this switch . " ) ; } else if ( missingCasesOfEnum ( switchStatementTree ) ) { reportIssue ( switchStatementTree . switchKeyword ( ) , "Complete cases by adding the missing enum constants or add a default case to this switch . " ) ; } } }
response: public void visitNode(Tree tree) { if (!hasSemantic()) { return; } SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree; <START> if (hasNoDefault(switchStatementTree)) { if (!isSwitchOnEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Add a default case to this switch."); } else if (missingCasesOfEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Complete cases by adding the missing enum constants or add a default case to this switch."); } } <END> }

sample: 18
buggy_code: <START> public String getAttribute() { <END> if (fAttribute.equals(NOT_SET)) { setAttribute(); } return fAttribute; }
code_review: This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute.
target code: public synchronized String getAttribute ( ) { if ( fAttribute . equals ( NOT_SET ) ) { setAttribute ( ) ; } return fAttribute ; }
response: <START> public synchronized String getAttribute() { <END> if (fAttribute.equals(NOT_SET)) { setAttribute(); } return fAttribute; }

sample: 19
buggy_code: public DotRunnableThread(final List<DotRunnable> allListeners) { this.listeners = getListeners(allListeners); this.flushers = getFlushers(allListeners); <START> this.networkCacheFlushThread.start(); <END> }
code_review: ![BLOCKER](https://sonarsource.github.io/sonar-github/severity-blocker.png 'Severity: BLOCKER') Move this "start" call to another method. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3AS2693)
target code: public DotRunnableThread ( final List < DotRunnable > allListeners ) { this . listeners = getListeners ( allListeners ) ; this . flushers = getFlushers ( allListeners ) ; }
response: public DotRunnableThread(final List<DotRunnable> allListeners) { this.listeners = getListeners(allListeners); this.flushers = getFlushers(allListeners); <START> start(); <END> }

sample: 20
buggy_code: private void createIndex() { lastFoundElementPosition = 0; filteredPlan.clear(); for (PlanElement element : plan.getList()) { <START> if (!element.isComment()) { <END> filteredPlan.add(element); } } }
code_review: style nit: no braces around single line blocks
target code: private void createIndex ( ) { lastFoundElementPosition = 0 ; filteredPlan . clear ( ) ; for ( PlanElement element : plan . getList ( ) ) { if ( ! element . isComment ( ) ) filteredPlan . add ( element ) ; } }
response: private void createIndex() { lastFoundElementPosition = 0; filteredPlan.clear(); for (PlanElement element : plan.getList()) { <START> if (!element.isComment()) <END> filteredPlan.add(element); } }

sample: 21
buggy_code: public Collection<Map.Entry<K, V>> scanAndFilterByEntry( Predicate<? super Map.Entry<K, V>> entryPredicate) { <START> return mainMap.entryStream().parallel() <END> .filter(entryPredicate) .collect(Collectors.toCollection(ArrayList::new)); }
code_review: is there a difference between parallelStream() and entryStream().parallel() ?
target code: public Collection < Map . Entry < K , V > > scanAndFilterByEntry ( Predicate < ? super Map . Entry < K , V > > entryPredicate ) { return mainMap . entryStream ( ) . filter ( entryPredicate ) . collect ( Collectors . toCollection ( ArrayList : : new ) ) ; }
response: public Collection<Map.Entry<K, V>> scanAndFilterByEntry( Predicate<? super Map.Entry<K, V>> entryPredicate) { <START> return mainMap.entryStream().parallel() <END> .filter(entryPredicate) .collect(Collectors.toCollection(ArrayList::new)); }

sample: 22
buggy_code: <START> protected boolean isValidChar(final char c) { <END> return isValidChar(regExp, c); }
code_review: can be `private`? or at least package protected access?
target code: private boolean isValidChar ( final char c ) { return isValidChar ( regExp , c ) ; }
response: <START> private boolean isValidChar(final char c) { <END> return isValidChar(regExp, c); }

sample: 23
buggy_code: public boolean verifyEventIdentifier(AbstractPlaceEvent event) { boolean equals = Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier()); boolean equals1 = Objects.equals(editorPlaceRequest, event.getPlace()); return (equals && <START> equals1); <END> }
code_review: Toni, could we please choose better variable names here? `equals` and `equals1` do not say much for newcomer to the codebase. Or we could avoid storing partial results by: ```java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true; ``` Please let me know what do you think.
target code: public boolean verifyEventIdentifier ( AbstractPlaceEvent event ) { return ( Objects . equals ( getEditorIdentifier ( ) , event . getPlace ( ) . getIdentifier ( ) ) && Objects . equals ( editorPlaceRequest , event . getPlace ( ) ) ) ; }
response: public boolean verifyEventIdentifier(AbstractPlaceEvent event) { boolean equals = Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier()); boolean equals1 = Objects.equals(editorPlaceRequest, event.getPlace()); return (equals && <START> equals1); <END> }

sample: 24
buggy_code: public void star() throws IOException { this.entry.uri() <START> .path(RtGist.PATH_ELEMENT_STAR).back().method("PUT") <END> .fetch().as(RestResponse.class) .assertStatus(HttpURLConnection.HTTP_NO_CONTENT); }
code_review: It's an obvious code duplication. We can save this new request with a modified URI into `this.request`, and use it in all methods. This is how it works in other classes, take a look
target code: public void star ( ) throws IOException { this . request . method ( "PUT" ) . fetch ( ) . as ( RestResponse . class ) . assertStatus ( HttpURLConnection . HTTP_NO_CONTENT ) ; }
response: public void star() throws IOException { this.entry.uri() <START> .path(RtGist.PATH_ELEMENT_STAR).back().method("PUT") <END> .fetch().as(RestResponse.class) .assertStatus(HttpURLConnection.HTTP_NO_CONTENT); }

sample: 25
buggy_code: public IssueOutputView(Issue issue) { <START> this(issue, null, null); <END> }
code_review: What is the need to make `issueArticles` nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference.
target code: public IssueOutputView ( Issue issue ) { this ( issue , null ) ; }
response: public IssueOutputView(Issue issue) { <START> this(issue, null, null); <END> }

sample: 26
buggy_code: <START> public ProcessEngineConfiguration setDefaultNumberOfRetries(int defaultNumberOfRetries) { <END> this.defaultNumberOfRetries = defaultNumberOfRetries; return this; }
code_review: not 100% sure, but this breaks binary compatibility, right?
target code: public void setDefaultNumberOfRetries ( int defaultNumberOfRetries ) { this . defaultNumberOfRetries = defaultNumberOfRetries ; }
response: <START> public ProcessEngineConfiguration setDefaultNumberOfRetries(int defaultNumberOfRetries) { <END> this.defaultNumberOfRetries = defaultNumberOfRetries; return this; }

sample: 27
buggy_code: <START> public void testSequenceFlowSupplier() throws Exception { <END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }
code_review: The Exception is never thrown.
target code: public void testSequenceFlowSupplier ( ) { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand ( parent , candidate , index , originalParent , originalIndex ) ; final Supplier < ViewConnector < SequenceFlow > > supplier = command . sequenceFlowSupplier ( ) ; final ViewConnector < SequenceFlow > viewConnector = supplier . get ( ) ; assertNotNull ( viewConnector ) ; assertNotNull ( viewConnector . getSourceConnection ( ) ) ; assertNotNull ( viewConnector . getTargetConnection ( ) ) ; assertNotNull ( viewConnector . getBounds ( ) ) ; assertNotNull ( viewConnector . getDefinition ( ) ) ; }
response: <START> public void testSequenceFlowSupplier() { <END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }

sample: 28
buggy_code: public long getSessionSeqId() { if (sessionSeqId == null) { <START> sessionSeqId = -1L; <END> String sessionId = getContext().getEngineContext().getSessionId(); // The session may not exists for quartz jobs if (getSessionDataContainer().isSessionExists(sessionId)) { sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId); } } return sessionSeqId; }
code_review: instead of an early assignment which might be overridden in line 2355, it can be set as the 'else' part of the if statement below (line 2356).
target code: public long getSessionSeqId ( ) { if ( sessionSeqId == null ) { String sessionId = getContext ( ) . getEngineContext ( ) . getSessionId ( ) ; // The session may not exists for quartz jobs sessionSeqId = getSessionDataContainer ( ) . isSessionExists ( sessionId ) ? getSessionDataContainer ( ) . getEngineSessionSeqId ( sessionId ) : - 1L ; } return sessionSeqId ; }
response: public long getSessionSeqId() { if (sessionSeqId == null) { String sessionId = getContext().getEngineContext().getSessionId(); // The session may not exists for quartz jobs if (getSessionDataContainer().isSessionExists(sessionId)) { sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId); } <START> else { sessionSeqId = -1L; } <END> } return sessionSeqId; }

sample: 29
buggy_code: private boolean isTxnRelatedEvent(final NotificationEvent event) { return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)) || <START> (event.getEventType().equals(MessageFactory.ALLOC_WRITE_ID_EVENT)) <END> ); }
code_review: Allocate write ID is a DB/table related event and should be ignored if not lookup on this DB/table.
target code: private boolean isTxnRelatedEvent ( final NotificationEvent event ) { return ( ( event . getEventType ( ) . equals ( MessageFactory . OPEN_TXN_EVENT ) ) || ( event . getEventType ( ) . equals ( MessageFactory . COMMIT_TXN_EVENT ) ) || ( event . getEventType ( ) . equals ( MessageFactory . ABORT_TXN_EVENT ) ) ) ; }
response: private boolean isTxnRelatedEvent(final NotificationEvent event) { return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)) || <START> (event.getEventType().equals(MessageFactory.ALLOC_WRITE_ID_EVENT) && event.getDbName().equals(dbName) && event.getTableName().equals(tableName)) <END> ); }

sample: 30
buggy_code: public static void setBackground(boolean async) { background = async; <START> } <END>
code_review: Can't we have this static flag on FS instead? Then we wouldn't need to make FileStoreAttributeCache public.
target code: private static void setBackground ( boolean async ) { background . set ( async ) ; }
response: public static void setBackground(boolean async) { background = async; }

sample: 31
buggy_code: public V put(@NonNull K key, @NonNull V value) { map.put(key, new Entry<>(key, value, ++time)); <START> if (map.size() >= maximumSize) { <END> purge(); } return value; }
code_review: For a small maximuSize, like 1, it may be more reasonable to check for: map.size() > maximumSize
target code: public V put ( @NonNull K key , @NonNull V value ) { map . put ( key , new Entry < > ( key , value , ++ time ) ) ; if ( map . size ( ) > maximumSize ) { purge ( ) ; } return value ; }
response: public V put(@NonNull K key, @NonNull V value) { map.put(key, new Entry<>(key, value, ++time)); <START> if (map.size() > maximumSize) { <END> purge(); } return value; }

sample: 32
buggy_code: private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) { if ( value != null && value.trim().length() > 0 ) { boolean isPassword = MongoProp.PASSWORD.equals( prop ); <START> boolean isEncrypted = value.startsWith( Encr.PASSWORD_ENCRYPTED_PREFIX ); <END> if ( isPassword && isEncrypted ) { value = Encr.decryptPasswordOptionallyEncrypted( value ); } builder.set( prop, value ); } }
code_review: Shouldn't do this line - it's handled by the ...Optionally... bit in the Encr class. https://github.com/pentaho/pentaho-kettle/blob/master/core/src/org/pentaho/di/core/encryption/KettleTwoWayPasswordEncoder.java#L86-L91
target code: private static void setIfNotNullOrEmpty ( MongoProperties . Builder builder , MongoProp prop , String value ) { if ( value != null && value . trim ( ) . length ( ) > 0 ) { boolean isPassword = MongoProp . PASSWORD . equals ( prop ) ; if ( isPassword ) { value = Encr . decryptPasswordOptionallyEncrypted ( value ) ; } builder . set ( prop , value ) ; } }
response: private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) { if ( value != null && value.trim().length() > 0 ) { boolean isPassword = MongoProp.PASSWORD.equals( prop ); <START> if ( isPassword ) { value = Encr.decryptPasswordOptionallyEncrypted( value ); } <END> builder.set( prop, value ); } }

sample: 33
buggy_code: public Mutation toMutation(K key) { <START> V valueFromStorage = (V) valueDataConversion.fromStorage(value); <END> return new Mutations.ReadWriteWithValue<>(valueFromStorage, f); }
code_review: One use/test case is, a non-serializable pojo (user type) that is encoded as a UTF-8 byte[ ] with some string representation of it.
target code: public Mutation toMutation ( K key ) { return new Mutations . ReadWriteWithValue < > ( value , f ) ; }
response: public Mutation toMutation(K key) { <START> V valueFromStorage = (V) valueDataConversion.fromStorage(value); <END> return new Mutations.ReadWriteWithValue<>(valueFromStorage, f); }

sample: 34
buggy_code: <START> public Entry(Map.Entry<String,String> e) { <END> this(e.getKey(), e.getValue()); }
code_review: IMHO it does not need to be public
target code: private Entry ( Map . Entry < String , String > e ) { this ( e . getKey ( ) , e . getValue ( ) ) ; }
response: <START> Entry(Map.Entry<String,String> e) { <END> this(e.getKey(), e.getValue()); }

sample: 35
buggy_code: private String parsePath() throws URISyntaxException { String[] parts = uri.split("\\?")[0].split(":", 2); <START> if (parts.length < 2 || parts[1].length() < 1) throw new URISyntaxException(uri, "invalid path"); <END> else return parts[1]; }
code_review: parts[1].isEmpty
target code: private String parsePath ( ) throws URISyntaxException { String [ ] parts = uri . split ( "\\ ? " ) [ 0 ] . split ( " : " , 2 ) ; if ( parts . length < 2 || parts [ 1 ] . isEmpty ( ) ) throw new URISyntaxException ( uri , "invalid path" ) ; else return parts [ 1 ] ; }
response: private String parsePath() throws URISyntaxException { String[] parts = uri.split("\\?")[0].split(":", 2); <START> if (parts.length < 2 || parts[1].isEmpty()) throw new URISyntaxException(uri, "invalid path"); <END> else return parts[1]; }

sample: 36
buggy_code: public void setItems(Collection value) { genVersionToBaseTemplate(value); <START> final List<VmTemplate> sortedValues = sortTemplates(value); <END> super.setItems(sortedValues); }
code_review: this will affect the sorting also on the webadmin - but on webadmin we support sortable columns. Please move this logic to UserPortalTemplateListModel.
target code: public void setItems ( Collection value ) { genVersionToBaseTemplate ( value ) ; super . setItems ( value ) ; }
response: public void setItems(Collection value) { genVersionToBaseTemplate(value); <START> final List<VmTemplate> sortedValues = sortTemplates(value); <END> super.setItems(sortedValues); }

sample: 37
buggy_code: public void edit(VolumeBrickModel object) { <START> table.setRowData(new ArrayList<ListModel>()); <END> table.edit(object.getBricks()); Driver.driver.edit(object); }
code_review: why you need this line? table.setRowData(new ArrayList<ListModel>());
target code: public void edit ( VolumeBrickModel object ) { table . edit ( object . getBricks ( ) ) ; Driver . driver . edit ( object ) ; }
response: public void edit(VolumeBrickModel object) { table.edit(object.getBricks()); Driver.driver.edit(object); }

sample: 38
buggy_code: public List<QuickFilter> getQuickFilters() { <START> return this.quickFilters; <END> }
code_review: `return quickFilters`
target code: public List < QuickFilter > getQuickFilters ( ) { return quickFilters ; }
response: public List<QuickFilter> getQuickFilters() { <START> return quickFilters; <END> }

sample: 39
buggy_code: public void testBounds() { int low = fCondition.min(); <START> assertEquals(LOW, low); <END> int high = fCondition.max(); assertEquals(HIGH, high); }
code_review: why not directly assertEquals(LOW, fCondition.min()); ?
target code: public void testBounds ( ) { assertEquals ( LOW , ( int ) fCondition . min ( ) ) ; assertEquals ( HIGH , ( int ) fCondition . max ( ) ) ; }
response: public void testBounds() { <START> assertEquals(LOW, fCondition.min()); <END> int high = fCondition.max(); assertEquals(HIGH, high); }

sample: 40
buggy_code: public String weather() { <START> String result = this.restTemplate.getForObject("http://" + WEATHER_SERVICE + "/weather", String.class); <END> return "Weather Service Response: " + result; }
code_review: `this` is redundant here.
target code: public String weather ( ) { String result = restTemplate . getForObject ( "http :/ / " + WEATHER_SERVICE + " / weather" , String . class ) ; return "Weather Service Response : " + result ; }
response: public String weather() { <START> String result = restTemplate.getForObject("http://" + WEATHER_SERVICE + "/weather", String.class); <END> return "Weather Service Response: " + result; }

sample: 41
buggy_code: public boolean isExtensionEnabled() { if (enablement != null) { try { <START> return enablement.getExpression().evaluate(new EvaluationContext(null, new Object())) <END> .equals(EvaluationResult.TRUE); } catch (CoreException e) { // TODO: handle exception } } return true; }
code_review: Let's move this into an EnablementTester.evaluate(...) method.
target code: public boolean isExtensionEnabled ( ) { return enablement != null ? enablement . evaluate ( ) : true ; }
response: public boolean isExtensionEnabled() { if (enablement != null) { try { <START> return new EnablementTester().evaluate(enablement) <END> .equals(EvaluationResult.TRUE); } catch (CoreException e) { // TODO: handle exception } } return true; }

sample: 42
buggy_code: public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) { <START> if (manager != null) { <END> return manager; } manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) { @Override protected void registerListeners() { // TODO install listener on allocation(Abstraction) of the model. } }; return manager; }
code_review: 'null' must be first operande
target code: public ProviderNotificationManager createProviderNotificationManager ( final DiagramEventBroker diagramEventBroker , final EObject view , final NotificationListener notificationListener ) { if ( null != manager ) { return manager ; } manager = new ProviderNotificationManager ( diagramEventBroker , view , notificationListener ) { @Override protected void registerListeners ( ) { // TODO install listener on allocation ( Abstraction ) of the model . } } ; return manager ; }
response: public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) { <START> if (null != manager) { <END> return manager; } manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) { @Override protected void registerListeners() { // TODO install listener on allocation(Abstraction) of the model. } }; return manager; }

sample: 43
buggy_code: <START> public void startSyncFolderOperation(OCFile folder) { <END> long currentSyncTime = System.currentTimeMillis(); mSyncInProgress = true; // perform folder synchronization RemoteOperation synchFolderOp = new RefreshFolderOperation( folder, currentSyncTime, false, false, false, getStorageManager(), getAccount(), getApplicationContext() ); synchFolderOp.execute(getAccount(), this, null, null); }
code_review: This method can be`private`.
target code: private void startSyncFolderOperation ( OCFile folder ) { long currentSyncTime = System . currentTimeMillis ( ) ; mSyncInProgress = true ; // perform folder synchronization RemoteOperation synchFolderOp = new RefreshFolderOperation ( folder , currentSyncTime , false , false , false , getStorageManager ( ) , getAccount ( ) , getApplicationContext ( ) ) ; synchFolderOp . execute ( getAccount ( ) , this , null , null ) ; }
response: <START> private void startSyncFolderOperation(OCFile folder) { <END> long currentSyncTime = System.currentTimeMillis(); mSyncInProgress = true; // perform folder synchronization RemoteOperation synchFolderOp = new RefreshFolderOperation( folder, currentSyncTime, false, false, false, getStorageManager(), getAccount(), getApplicationContext() ); synchFolderOp.execute(getAccount(), this, null, null); }

sample: 44
buggy_code: <START> public static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) { <END> if (cacheManager == null) { throw new IllegalArgumentException("cacheManager cannot be null"); } ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class); if (metadataManager == null) { throw new IllegalStateException("ProtobufMetadataManager not initialised yet!"); } return metadataManager; }
code_review: This can be private again.
target code: private static ProtobufMetadataManagerImpl getProtobufMetadataManager ( EmbeddedCacheManager cacheManager ) { if ( cacheManager == null ) { throw new IllegalArgumentException ( "cacheManager cannot be null" ) ; } ProtobufMetadataManagerImpl metadataManager = ( ProtobufMetadataManagerImpl ) cacheManager . getGlobalComponentRegistry ( ) . getComponent ( ProtobufMetadataManager . class ) ; if ( metadataManager == null ) { throw new IllegalStateException ( "ProtobufMetadataManager not initialised yet ! " ) ; } return metadataManager ; }
response: <START> private static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) { <END> if (cacheManager == null) { throw new IllegalArgumentException("cacheManager cannot be null"); } ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class); if (metadataManager == null) { throw new IllegalStateException("ProtobufMetadataManager not initialised yet!"); } return metadataManager; }

sample: 45
buggy_code: public void onSessionKeyUpdate(SessionKey sessionKey) { <START> log.info("Session key updated"); <END> synchronized (DistributedHerder.this) { DistributedHerder.this.sessionKey = sessionKey.key(); if (isLeader() && keyRotationIntervalMs > 0) { DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs; } } }
code_review: Should this log message be before or after we actually do update the session key?
target code: public void onSessionKeyUpdate ( SessionKey sessionKey ) { log . info ( "Session key updated" ) ; synchronized ( DistributedHerder . this ) { DistributedHerder . this . sessionKey = sessionKey . key ( ) ; // Track the expiration of the key if and only if this worker is the leader // Followers will receive rotated keys from the follower and won't be responsible for // tracking expiration and distributing new keys themselves if ( isLeader ( ) && keyRotationIntervalMs > 0 ) { DistributedHerder . this . keyExpiration = sessionKey . creationTimestamp ( ) + keyRotationIntervalMs ; } } }
response: public void onSessionKeyUpdate(SessionKey sessionKey) { synchronized (DistributedHerder.this) { <START> log.info("Session key updated"); <END> DistributedHerder.this.sessionKey = sessionKey.key(); if (isLeader() && keyRotationIntervalMs > 0) { DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs; } } }

sample: 46
buggy_code: public String getAuthorizationUrl(OAuthConfig config) { <START> System.out.print("Authorisation URL: "); <END> // User must provide these 5 elements to the service builder String url = String.format(AUTHORIZE_URL, OAuthEncoder.encode(config.getApiKey()), OAuthEncoder.encode(config.getCallback()), OAuthEncoder.encode(config.getScope()), OAuthEncoder.encode(config.getState())); return url; }
code_review: forgotten line of code?
target code: public String getAuthorizationUrl ( OAuthConfig config ) { // User must provide these 4 elements to the service builder String url = String . format ( AUTHORIZE_URL , OAuthEncoder . encode ( config . getApiKey ( ) ) , OAuthEncoder . encode ( config . getCallback ( ) ) , OAuthEncoder . encode ( config . getScope ( ) ) , OAuthEncoder . encode ( config . getState ( ) ) ) ; return url ; }
response: public String getAuthorizationUrl(OAuthConfig config) { // User must provide these 5 elements to the service builder String url = String.format(AUTHORIZE_URL, OAuthEncoder.encode(config.getApiKey()), OAuthEncoder.encode(config.getCallback()), OAuthEncoder.encode(config.getScope()), OAuthEncoder.encode(config.getState())); return url; }

sample: 47
buggy_code: public Object getParameter(String name) { <START> final HostThread currentHostThread = fCurrentHostThread; <END> if (currentHostThread == null) { return null; } if (name.equals(CriticalPathModule.PARAM_WORKER)) { /* Try to find the worker for the critical path */ IAnalysisModule mod = getModule(); if ((mod != null) && (mod instanceof CriticalPathModule)) { LttngWorker worker = new LttngWorker(currentHostThread, "", 0); //$NON-NLS-1$ return worker; } return currentHostThread; } return null; }
code_review: This code here should be inside the if, because we don't need to do anything if the parameter request is not PARAM_WORKER
target code: public Object getParameter ( String name ) { if ( name . equals ( CriticalPathModule . PARAM_WORKER ) ) { final HostThread currentHostThread = fCurrentHostThread ; if ( currentHostThread == null ) { return null ; } /* Try to find the worker for the critical path */ IAnalysisModule mod = getModule ( ) ; if ( ( mod != null ) && ( mod instanceof CriticalPathModule ) ) { LttngWorker worker = new LttngWorker ( currentHostThread , "" , 0 ) ; // $NON - NLS - 1$ return worker ; } return currentHostThread ; } return null ; }
response: public Object getParameter(String name) { <START> final HostThread currentHostThread = fCurrentHostThread; <END> if (currentHostThread == null) { return null; } if (name.equals(CriticalPathModule.PARAM_WORKER)) { /* Try to find the worker for the critical path */ IAnalysisModule mod = getModule(); if ((mod != null) && (mod instanceof CriticalPathModule)) { LttngWorker worker = new LttngWorker(currentHostThread, "", 0); //$NON-NLS-1$ return worker; } } return null; }

sample: 48
buggy_code: public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) { <START> return expectException( runnable.toString(), runnable ); <END> }
code_review: Maybe `expectThrowable` for consistency?
target code: public static ExceptionThrowingSubTest expectThrowable ( Runnable runnable ) { return expectThrowable ( runnable . toString ( ) , runnable ) ; }
response: public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) { <START> return expectException( runnable.toString(), runnable ); <END> }

sample: 49
buggy_code: protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion, ServicePortBuilder<T> portBuilder) { serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url, assertion != null ? assertion.getTransactionTimeout() : null); <START> configCNCheck(); <END> }
code_review: remove this
target code: protected CONNECTCXFClient ( ServicePortDescriptor < T > portDescriptor , String url , AssertionType assertion , ServicePortBuilder < T > portBuilder ) { serviceEndpoint = super . configureBasePort ( portBuilder . createPort ( ) , url , assertion != null ? assertion . getTransactionTimeout ( ) : null ) ; }
response: protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion, ServicePortBuilder<T> portBuilder) { serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url, assertion != null ? assertion.getTransactionTimeout() : null); <START> configCNCheck(); <END> }

sample: 50
buggy_code: public <V> Setting<V> get(SimpleUri id, Class<V> valueType) { Setting setting = settings.get(id); Class settingValueClass = setting.getValueClass(); if (!settingValueClass.equals(valueType)) { throw new ClassCastException( "Expected a Setting of type " + valueType.getName() + ", found a Setting of type " + settingValueClass.getName() <START> ); <END> } return (Setting<V>) setting; }
code_review: Can we add the name of the setting in there somewhere as well?
target code: public < V > Setting < V > get ( SimpleUri id , Class < V > valueType ) { Setting setting = settings . get ( id ) ; if ( setting == null ) { return null ; } Class settingValueClass = setting . getValueClass ( ) ; if ( ! settingValueClass . equals ( valueType ) ) { throw new ClassCastException ( "Expected a Setting of type " + valueType . getName ( ) + " , found a Setting of type " + settingValueClass . getName ( ) ) ; } return ( Setting < V > ) setting ; }
response: public <V> Setting<V> get(SimpleUri id, Class<V> valueType) { Setting setting = settings.get(id); Class settingValueClass = setting.getValueClass(); if (!settingValueClass.equals(valueType)) { throw new ClassCastException( "Expected a Setting of type " + valueType.getName() + ", found a Setting of type " + settingValueClass.getName() + " for setting " + id.toString() <START> ); <END> } return (Setting<V>) setting; }

sample: 51
buggy_code: public String getCustomField(String fieldName) { <START> if(customFields == null) return null; <END> for (CustomField f : customFields) { if (f.getName().equals(fieldName)) { return f.getValue(); } } return null; }
code_review: it's better to init customFields with an empty collection to avoid "==null"
target code: public String getCustomField ( String fieldName ) { for ( CustomField f : customFields ) { if ( f . getName ( ) . equals ( fieldName ) ) { return f . getValue ( ) ; } } return null ; }
response: public String getCustomField(String fieldName) { <START> if(customFields == null) return null; <END> for (CustomField f : customFields) { if (f.getName().equals(fieldName)) { return f.getValue(); } } return null; }

sample: 52
buggy_code: private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) { String expression = commandCall.getExpression(); <START> if (expression.equals("")) { <END> expression = element.getText(); } return new CommandCall(null, commandCall.getCommand(), element, expression, commandCall.getResource()); }
code_review: Any way we can clean this up? It seems to only be needed for example commands, but hard to check what the command is here since it's wrapped in decorators.
target code: private CommandCall duplicateCommandForDifferentElement ( CommandCall commandCall , Element element ) { return new CommandCall ( null , commandCall . getCommand ( ) , element , commandCall . getExpression ( ) , commandCall . getResource ( ) ) ; }
response: private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) { String expression = commandCall.getExpression(); <START> if (expression.equals("")) { expression = element.getText(); } <END> return new CommandCall(null, commandCall.getCommand(), element, expression, commandCall.getResource()); }

sample: 53
buggy_code: public M fromBytes(byte[] messageBuffer) { if (deserializer == null) deserializer = new ThriftBinaryDeserializer(); try { M message = typeRef.safeNewInstance(); deserializer.deserialize(message, messageBuffer); return message; } catch (TException e) { logWarning("failed to deserialize", e); return null; <START> } catch (Throwable e) { <END> // Arbitrary bytes can cause a runtime exception in Thrift logWarning("failed to deserialize", e); return null; } }
code_review: TException is throwable, too, and treated the same -- combine the catch clauses?
target code: public M fromBytes ( byte [ ] messageBuffer ) { if ( deserializer == null ) deserializer = new ThriftBinaryDeserializer ( ) ; try { M message = typeRef . safeNewInstance ( ) ; deserializer . deserialize ( message , messageBuffer ) ; return message ; } catch ( Throwable e ) { // normally a TException . but some corrupt records can cause // other runtime exceptions ( e . g . IndexOutOfBoundsException ) . logWarning ( "failed to deserialize" , e ) ; return null ; } }
response: public M fromBytes(byte[] messageBuffer) { if (deserializer == null) deserializer = new ThriftBinaryDeserializer(); try { M message = typeRef.safeNewInstance(); deserializer.deserialize(message, messageBuffer); return message; } catch (TException e) { <START> logWarning("failed to deserialize", e); return null; } catch (Throwable e) { <END> // Arbitrary bytes can cause a runtime exception in Thrift logWarning("failed to deserialize", e); return null; } }

sample: 54
buggy_code: public void showPage(Control page) { if (page.isDisposed() || page.getParent() != this) { return; } currentPage = page; // show new page page.setVisible(true); layout(true); // hide old (and all others) *after* new page has been made visible in // order to avoid flashing Control[] children = getChildren(); for (Control element : children) { <START> Control child = element; <END> if (child != page && !child.isDisposed()) { child.setVisible(false); } } }
code_review: remove
target code: public void showPage ( Control page ) { if ( page . isDisposed ( ) || page . getParent ( ) != this ) { return ; } currentPage = page ; // show new page page . setVisible ( true ) ; layout ( true ) ; // hide old ( and all others ) * after * new page has been made visible in // order to avoid flashing for ( Control child : getChildren ( ) ) { if ( child != page && ! child . isDisposed ( ) ) { child . setVisible ( false ) ; } } }
response: public void showPage(Control page) { if (page.isDisposed() || page.getParent() != this) { return; } currentPage = page; // show new page page.setVisible(true); layout(true); // hide old (and all others) *after* new page has been made visible in // order to avoid flashing Control[] children = getChildren(); for (Control element : children) { if (element != page && !element.isDisposed()) { element.setVisible(false); } } }

sample: 55
buggy_code: public void info(String message, Object... objects) { <START> LOG.warn(message, objects); <END> }
code_review: info vs warn
target code: public void info ( String message , Object . . . objects ) { LOG . info ( message , objects ) ; }
response: public void info(String message, Object... objects) { <START> LOG.info(message, objects); <END> }

sample: 56
buggy_code: public String getLinkAt(int offset) { // Check if there is a link at the offset for (int i = 0; i < linkRanges.size(); i++) { if (linkRanges.get(i).isOffsetInRange(offset)) { return hrefs.get(i); } } <START> return null; <END> }
code_review: Let's avoid `null` and rework to empty string
target code: public Optional < String > getLinkAt ( int offset ) { // Check if there is a link at the offset for ( int i = 0 ; i < linkRanges . size ( ) ; i ++ ) { if ( linkRanges . get ( i ) . contains ( offset ) ) { return Optional . of ( hrefs . get ( i ) ) ; } } return Optional . empty ( ) ; }
response: public String getLinkAt(int offset) { // Check if there is a link at the offset for (int i = 0; i < linkRanges.size(); i++) { if (linkRanges.get(i).isOffsetInRange(offset)) { return hrefs.get(i); } } <START> return ""; <END> }

sample: 57
buggy_code: public String toString() { readLock.lock(); try { <START> return "FileListCacheValue{fileNames=" + getFileNames() + "}"; <END> } finally { readLock.unlock(); } }
code_review: This change I requested was supposed to remove the need for a read lock
target code: public String toString ( ) { return "FileListCacheValue { fileNames = " + getFileNames ( ) + " } " ; }
response: public String toString() { <START> return "FileListCacheValue{fileNames=" + getFileNames() + "}"; <END> }

sample: 58
buggy_code: protected Control createControl(Composite parent) { // Configure table CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID); config.setHorizontalAlignment(SWT.CENTER); config.setCellSelectionEnabled(false); config.setColumnSelectionEnabled(false); config.setRowSelectionEnabled(false); config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL); config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT); <START> this.table = new ComponentTable(parent, SWT.FULL_SELECTION, config); <END> return this.table.getControl(); }
code_review: Please not here. This is not a standard SWT table.
target code: protected Control createControl ( Composite parent ) { // Configure table CTConfiguration config = new CTConfiguration ( parent , CTConfiguration . STYLE_GRID ) ; config . setHorizontalAlignment ( SWT . CENTER ) ; config . setCellSelectionEnabled ( false ) ; config . setColumnSelectionEnabled ( false ) ; config . setRowSelectionEnabled ( false ) ; config . setColumnHeaderLayout ( CTConfiguration . COLUMN_HEADER_LAYOUT_FILL_EQUAL ) ; config . setRowHeaderLayout ( CTConfiguration . ROW_HEADER_LAYOUT_DEFAULT ) ; this . table = new ComponentTable ( parent , SWT . NONE , config ) ; return this . table . getControl ( ) ; }
response: protected Control createControl(Composite parent) { // Configure table CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID); config.setHorizontalAlignment(SWT.CENTER); config.setCellSelectionEnabled(false); config.setColumnSelectionEnabled(false); config.setRowSelectionEnabled(false); config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL); config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT); <START> this.table = new ComponentTable(parent, SWT.FULL_SELECTION, config); <END> return this.table.getControl(); } // Review: Please not here. This is not a standard SWT table.

sample: 59
buggy_code: public boolean isEnabled() { return <START> getActiveTextEditor() != null; <END> }
code_review: return 'true'
target code: public boolean isEnabled ( ) { return true ; }
response: public boolean isEnabled() { return <START> true; <END> }

sample: 60
buggy_code: void verifyMetadata(MessageMetadata metadata) throws Exception { if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) { log.error("Wrong message metadata {}, expecting type {} snapshot {}", metadata, MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot); <START> throw new Exception("wrong type of message"); <END> } }
code_review: maybe you need a specific Exception Type
target code: void verifyMetadata ( MessageMetadata metadata ) throws Exception { if ( metadata . getMessageMetadataType ( ) != MessageType . LOG_ENTRY_MESSAGE ) { log . error ( "Wrong message metadata { } , expecting type { } snapshot { } " , metadata , MessageType . LOG_ENTRY_MESSAGE , srcGlobalSnapshot ) ; throw new Exception ( "wrong type of message" ) ; } }
response: void verifyMetadata(MessageMetadata metadata) throws Exception { if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) { log.error("Wrong message metadata {}, expecting type {} snapshot {}", metadata, MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot); <START> throw new IllegalArgumentException("wrong type of message"); <END> } }

sample: 61
buggy_code: public void setVmBackup(VmBackup value) { <START> vmBackup = value; <END> }
code_review: This is a bug, the setter does nothing, use 'this'
target code: public void setVmBackup ( VmBackup value ) { this . vmBackup = value ; }
response: public void setVmBackup(VmBackup value) { <START> this.vmBackup = value; <END> }

sample: 62
buggy_code: public void setPrice1(int price3) { if (price3 < 0 || price3 > 10000) { <START> throw new IllegalArgumentException("Invalid price: " + price3); // Compliant <END> } if (true) { assert price3 > 1000; // Noncompliant } }
code_review: what is this part for? you are not checking throw statements.
target code: public void setPrice1 ( int price3 ) { if ( true ) { assert price3 > 1000 ; // Noncompliant } }
response: public void setPrice1(int price3) { if (price3 < 0 || price3 > 10000) { throw new IllegalArgumentException("Invalid price: " + price3); // Compliant } if (true) { assert price3 > 1000; // Noncompliant } }

sample: 63
buggy_code: public String evaluate(TransactionContext txnCtx, Input<Object>[] args) { assert args.length == 2 : "repeat takes exactly two arguments"; var text = (String) args[0].value(); if (text == null) { return null; } <START> var repetitions = (int) args[1].value(); <END> if (repetitions <= 0) { return ""; } else { return text.repeat(repetitions); } }
code_review: This will fail on `null`
target code: public String evaluate ( TransactionContext txnCtx , Input < Object > [ ] args ) { assert args . length == 2 : "repeat takes exactly two arguments" ; var text = ( String ) args [ 0 ] . value ( ) ; var repetitions = ( Integer ) args [ 1 ] . value ( ) ; if ( text == null || repetitions == null ) { return null ; } if ( repetitions <= 0 ) { return "" ; } else { return text . repeat ( repetitions ) ; } }
response: public String evaluate(TransactionContext txnCtx, Input<Object>[] args) { assert args.length == 2 : "repeat takes exactly two arguments"; var text = (String) args[0].value(); if (text == null) { return null; } var repetitions = (int) args[1].value(); if (repetitions <= 0) { return ""; } else { return text.repeat(repetitions); } }

sample: 64
buggy_code: <START> public void setActionBarNotificationBarColor(MaterialColor color) { <END> getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this))); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { getWindow().setStatusBarColor(color.toStatusBarColor(this)); } }
code_review: why is this public?
target code: private void setActionBarNotificationBarColor ( MaterialColor color ) { getSupportActionBar ( ) . setBackgroundDrawable ( new ColorDrawable ( color . toActionBarColor ( this ) ) ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { getWindow ( ) . setStatusBarColor ( color . toStatusBarColor ( this ) ) ; } }
response: <START> void setActionBarNotificationBarColor(MaterialColor color) { <END> getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this))); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { getWindow().setStatusBarColor(color.toStatusBarColor(this)); } }

sample: 65
buggy_code: public static ProjectBuildType getProjectType(IProject project) { // ------------ AUTOTOOLS // Autotools has an 'Autotools' nature by which we can identify it. <START> if (isAutoTools(project)) <END> return ProjectBuildType.AUTO_TOOLS; IConfiguration defaultConfiguration = helper_getActiveConfiguration(project); IBuilder builder = defaultConfiguration.getBuilder(); Boolean projIsManaged = builder.isManagedBuildOn(); if (projIsManaged) return ProjectBuildType.MANAGED_MAKEFILE; else return ProjectBuildType.OTHER; //E.g a manual makefile. }
code_review: Please use {} for every if/else/for/etc. block.
target code: public static ProjectBuildType getProjectType ( IProject project ) { // -- -- -- -- -- AUTOTOOLS // Autotools has an 'Autotools' nature by which we can identify it . if ( isAutoTools ( project ) ) { return ProjectBuildType . AUTO_TOOLS ; } IConfiguration defaultConfiguration = helper_getActiveConfiguration ( project ) ; IBuilder builder = defaultConfiguration . getBuilder ( ) ; Boolean projIsManaged = builder . isManagedBuildOn ( ) ; // -- -- -- -- -- MANAGED PROJECT if ( projIsManaged ) { return ProjectBuildType . MANAGED_MAKEFILE ; } else { return ProjectBuildType . OTHER ; // E . g a manual makefile . } }
response: public static ProjectBuildType getProjectType(IProject project) { // ------------ AUTOTOOLS // Autotools has an 'Autotools' nature by which we can identify it. <START> if (isAutoTools(project)) { <END> return ProjectBuildType.AUTO_TOOLS; } IConfiguration defaultConfiguration = helper_getActiveConfiguration(project); IBuilder builder = defaultConfiguration.getBuilder(); Boolean projIsManaged = builder.isManagedBuildOn(); if (projIsManaged) return ProjectBuildType.MANAGED_MAKEFILE; else return ProjectBuildType.OTHER; //E.g a manual makefile. }

sample: 66
buggy_code: protected long download(T object, File outFile) throws IOException { try { openObjectFunction.open(object, outFile); } <START> catch (IOException e) { <END> throw new RuntimeException(e); } return outFile.length(); }
code_review: This isn't necessary.
target code: protected long download ( T object , File outFile ) throws IOException { openObjectFunction . open ( object , outFile ) ; return outFile . length ( ) ; }
response: protected long download(T object, File outFile) throws IOException { try { openObjectFunction.open(object, outFile); } <START> catch (IOException e) { <END> throw e; } return outFile.length(); }

sample: 67
buggy_code: private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) { Collection<VCastResult> results = null; try { results = dataStore.getAllResults(); } catch (OseeCoreException ex) { <START> throw new OseeCoreException(ex, "SQL error while reading results"); <END> } return results; }
code_review: what's the point of catching and then throwing the same exception type?
target code: private Collection < VCastResult > getResultFiles ( VCastDataStore dataStore ) { Collection < VCastResult > results = null ; results = dataStore . getAllResults ( ) ; return results ; }
response: private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) { Collection<VCastResult> results = null; try { results = dataStore.getAllResults(); } catch (OseeCoreException ex) { <START> throw ex; <END> } return results; }

sample: 68
buggy_code: public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context) <START> { <END> context = node.getSource().accept(this, context); requireNonNull(context, "context is null"); LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections(); String filter = node.getPredicate().accept(pinotFilterExpressionConverter, (var) -> selections.get(var)).getDefinition(); return context.withFilter(filter).withOutputColumns(node.getOutputVariables()); }
code_review: public
target code: public PinotQueryGeneratorContext visitFilter ( FilterNode node , PinotQueryGeneratorContext context ) { context = node . getSource ( ) . accept ( this , context ) ; requireNonNull ( context , "context is null" ) ; LinkedHashMap < VariableReferenceExpression , Selection > selections = context . getSelections ( ) ; String filter = node . getPredicate ( ) . accept ( pinotFilterExpressionConverter , selections : : get ) . getDefinition ( ) ; return context . withFilter ( filter ) . withOutputColumns ( node . getOutputVariables ( ) ) ; }
response: public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context) <START> { <END> context = node.getSource().accept(this, context); requireNonNull(context, "context is null"); LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections(); String filter = node.getPredicate().accept(pinotFilterExpressionConverter, (var) -> selections.get(var)).getDefinition(); return context.withFilter(filter).withOutputColumns(node.getOutputVariables()); }

sample: 69
buggy_code: <START> private Space(String enumeratedValue) { <END> this.enumeratedValue = enumeratedValue; }
code_review: JavaDoc and method signature did not match. Please update the JavaDoc!
target code: Space ( String enumeratedValue ) { this . enumeratedValue = enumeratedValue ; }
response: <START> private Space(String enumeratedValue) { <END> this.enumeratedValue = enumeratedValue; }

sample: 70
buggy_code: public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) { Guid returnValue = Guid.Empty; List<storage_domains> domains = getAllForStoragePool(pool); for (storage_domains domain : domains) { <START> if (domain.getstorage_domain_type() == StorageDomainType.Master) { <END> returnValue = domain.getId(); break; } } return returnValue; }
code_review: still requires fix: domain.getstorage_domain_type() == type
target code: public Guid getStorageDomainIdForPoolByType ( Guid pool , StorageDomainType type ) { Guid returnValue = Guid . Empty ; List < storage_domains > domains = getAllForStoragePool ( pool ) ; for ( storage_domains domain : domains ) { if ( domain . getstorage_domain_type ( ) == type ) { returnValue = domain . getId ( ) ; break ; } } return returnValue ; }
response: public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) { Guid returnValue = Guid.Empty; List<storage_domains> domains = getAllForStoragePool(pool); for (storage_domains domain : domains) { if (domain.getstorage_domain_type() == type) { returnValue = domain.getId(); break; } } return returnValue; }

sample: 71
buggy_code: public void lock(T id) throws InterruptedException { <START> threadsLocked.inc(); <END> idsLocked.update(1); lockInternal(id); threadsLocked.dec(); }
code_review: For this it's better to do: ``` threadsLocked.inc(); try { // other stuff } finally { threadsLocked.dec(); } ``` This way if an exception is thrown we still decrement the threadsLocked counter.
target code: public void lock ( T id ) throws InterruptedException { threadsLocked . inc ( ) ; try { idsLocked . update ( 1 ) ; lockInternal ( id ) ; } finally { threadsLocked . dec ( ) ; } }
response: public void lock(T id) throws InterruptedException { <START> threadsLocked.inc(); try { <END> idsLocked.update(1); lockInternal(id); } finally { threadsLocked.dec(); } }

sample: 72
buggy_code: public RunLengthEncodedBlock(Block value, int positionCount) { requireNonNull(value, "value is null"); if (value.getPositionCount() != 1) { throw new IllegalArgumentException(format("Expected value to contain a single position but has %s positions", value.getPositionCount())); } // value can not be a RunLengthEncodedBlock because this could cause stack overflow in some of the methods if (value instanceof RunLengthEncodedBlock) { throw new IllegalArgumentException(format("Value can not be an instance of a %s", getClass().getName())); } if (positionCount < 0) { throw new IllegalArgumentException("positionCount is negative"); } <START> this.value = value <END> this.positionCount = positionCount; }
code_review: looks like syntax typo (`Add position checks in RunLenghtEncodedBlock` commit)
target code: public RunLengthEncodedBlock ( Block value , int positionCount ) { requireNonNull ( value , "value is null" ) ; if ( value . getPositionCount ( ) != 1 ) { throw new IllegalArgumentException ( format ( "Expected value to contain a single position but has % s positions" , value . getPositionCount ( ) ) ) ; } if ( value instanceof RunLengthEncodedBlock ) { this . value = ( ( RunLengthEncodedBlock ) value ) . getValue ( ) ; } else { this . value = value ; } if ( positionCount < 0 ) { throw new IllegalArgumentException ( "positionCount is negative" ) ; } this . positionCount = positionCount ; }
response: public RunLengthEncodedBlock(Block value, int positionCount) { requireNonNull(value, "value is null"); if (value.getPositionCount() != 1) { throw new IllegalArgumentException(format("Expected value to contain a single position but has %s positions", value.getPositionCount())); } // value can not be a RunLengthEncodedBlock because this could cause stack overflow in some of the methods if (value instanceof RunLengthEncodedBlock) { throw new IllegalArgumentException(format("Value can not be an instance of a %s", getClass().getName())); } if (positionCount < 0) { throw new IllegalArgumentException("positionCount is negative"); } this.value = value; this.positionCount = positionCount; }

sample: 73
buggy_code: public Message.Request request() { <START> Message.Request request = callback.request(); <END> if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency()) return request.copy(retryConsistencyLevel); else return request; }
code_review: Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
target code: public Message . Request request ( ) { if ( retryConsistencyLevel != null && retryConsistencyLevel != request . consistency ( ) ) return request . copy ( retryConsistencyLevel ) ; else return request ; }
response: public Message.Request request() { <START> Message.Request request = callback.request(); <END> if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency()) return request.copy(retryConsistencyLevel); else return request; }

sample: 74
buggy_code: public void init(FilterConfig filterConfig) throws ServletException { <START> dirAllowed = Context.getConfig().getBoolean("media.dirAllowed"); <END> }
code_review: I would prefer to use full words. For example `directoryAllow`.
target code: public void init ( FilterConfig filterConfig ) throws ServletException { }
response: public void init(FilterConfig filterConfig) throws ServletException { <START> directoryAllowed = Context.getConfig().getBoolean("media.directoryAllowed"); <END> }

sample: 75
buggy_code: public ExtentBufferedCompositePattern(Extent extent, Pattern... patterns) { super(extent); <START> checkArgument(patterns.length == 0, "patterns cannot be empty"); <END> this.patterns = patterns; }
code_review: This is backwards, you want the expected condition to be here.
target code: public ExtentBufferedCompositePattern ( Extent extent , Pattern . . . patterns ) { super ( extent ) ; checkArgument ( patterns . length != 0 , "patterns cannot be empty" ) ; this . patterns = patterns ; }
response: public void testGet() { <START> assertEquals(1, cache.get(1, new Callable<Integer>() { @Override public Integer call() { return 2; } })); <END> }

sample: 76
buggy_code: public boolean isValid(Object[] value, ConstraintValidatorContext context) { if ( value.length != 3 ) { <START> throw new IllegalStateException( "Unexpected method signature" ); <END> } // one or both limits are unbounded => always consistent if ( value[1] == null || value[2] == null ) { return true; } return ( (Date) value[1] ).before( (Date) value[2] ); }
code_review: It's tangential, but `IllegalArgumentException` seems more reasonable.
target code: public boolean isValid ( Object [ ] value , ConstraintValidatorContext context ) { if ( value . length != 3 ) { throw new IllegalArgumentException ( "Unexpected method signature" ) ; } // one or both limits are unbounded = > always consistent if ( value [ 1 ] == null || value [ 2 ] == null ) { return true ; } return ( ( Date ) value [ 1 ] ) . before ( ( Date ) value [ 2 ] ) ; }
response: public boolean isValid(Object[] value, ConstraintValidatorContext context) { if ( value.length != 3 ) { <START> throw new IllegalArgumentException( "Unexpected method signature" ); <END> } // one or both limits are unbounded => always consistent if ( value[1] == null || value[2] == null ) { return true; } return ( (Date) value[1] ).before( (Date) value[2] ); }

sample: 77
buggy_code: <START> private static boolean monoNativeFailure(Either<Utils.CommandResult> result) { <END> if (result == null || !result.isSuccess()) { return true; } else { Utils.CommandResult commandResult = result.get(); return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error); } }
code_review: maybe check for start of file or newline also?
target code: static boolean monoNativeFailure ( Either < Utils . CommandResult > result ) { if ( result == null || ! result . isSuccess ( ) ) { return true ; } else { Utils . CommandResult commandResult = result . get ( ) ; return monoNativeFailure ( commandResult . output ) || monoNativeFailure ( commandResult . error ) ; } }
response: <START> private static boolean monoNativeFailure(Either<Utils.CommandResult> result) { <END> if (result == null || !result.isSuccess()) { return true; } else { Utils.CommandResult commandResult = result.get(); return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error); } }

sample: 78
buggy_code: private void removeAppBar() { DWORD dwABM = new DWORD(); APPBARDATA ABData = new APPBARDATA.ByReference(); ABData.cbSize.setValue( ABData.size() ); dwABM.setValue(ShellAPI.ABM_REMOVE); UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage( dwABM, ABData); <START> assertNotNull(result ); <END> }
code_review: Another extra space, can you plese cleanup all these similar things? There're a few others, some functions have spaces in parameters, some don't like `queryPos( APPBARDATA ABData )` vs. `dwABM.setValue(ShellAPI.ABM_QUERYPOS);`. Sorry to be a pest, just looks messy and inconsistent.
target code: private void removeAppBar ( ) { APPBARDATA data = new APPBARDATA . ByReference ( ) ; data . cbSize . setValue ( data . size ( ) ) ; UINT_PTR result = Shell32 . INSTANCE . SHAppBarMessage ( new DWORD ( ShellAPI . ABM_REMOVE ) , data ) ; assertNotNull ( result ) ; }
response: private void removeAppBar() { DWORD dwABM = new DWORD(); APPBARDATA ABData = new APPBARDATA.ByReference(); ABData.cbSize.setValue( ABData.size() ); dwABM.setValue(ShellAPI.ABM_REMOVE); UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage( dwABM, ABData); <START> assertNotNull(result); <END> }

sample: 79
buggy_code: public boolean couldMatch(ScriptPath path) { <START> return (path.eventLower.startsWith("mythicmob") && (path.eventArgLowerAt(2).equals("spawns"))); <END> }
code_review: stray parens Also, use the standard couldMatch format used through Denizen, not this weird inline thing.
target code: public boolean couldMatch ( ScriptPath path ) { if ( ! path . eventLower . startsWith ( "mythicmob" ) ) { return false ; } if ( ! path . eventArgLowerAt ( 2 ) . equals ( "spawns" ) ) { return false ; } return true ; }
response: public boolean couldMatch(ScriptPath path) { String event = path.eventLower; return event.startsWith("mythicmob") && path.eventArgLowerAt(2).equals("spawns"); }

sample: 80
buggy_code: void init() { <START> controllerHomeDir = resolveControllerHomeDir(); <END> this.initAccessOfDirectories(); this.initAccessOfHosts(); }
code_review: Why does it resolve controller home? is it better to name it with HomeDir? It's because this class not only called from controller but agent.
target code: void init ( ) { this . initAccessOfDirectories ( ) ; this . initAccessOfHosts ( ) ; }
response: void init() { <START> homeDir = resolveHomeDir(); <END> this.initAccessOfDirectories(); this.initAccessOfHosts(); }

sample: 81
buggy_code: protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) { if (launch instanceof GdbLaunch) { return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm); } return null; <START> } <END>
code_review: It is always expected that launch would be an instance of GdbLaunch, I don't think the check is required.
target code: protected Sequence getServicesSequence ( DsfSession session , ILaunch launch , IProgressMonitor rm ) { return new ServicesLaunchSequence ( session , ( GdbLaunch ) launch , rm ) ; }
response: protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) { return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm); <START> } <END>

sample: 82
buggy_code: <START> public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, MiddlewareQueryException, FieldbookException { <END> return this.namingConventionService.advanceNursery(advanceInfo, workbook); }
code_review: `MiddlewareQueryException` is now a run time exception so it is not required to be part of the method signature. Not invalid to have it in signature, but Sonar will report it as a _Major_ category violation.
target code: public AdvanceResult advanceNursery ( final AdvancingNursery advanceInfo , final Workbook workbook ) throws RuleException , FieldbookException { return this . namingConventionService . advanceNursery ( advanceInfo , workbook ) ; }
response: <START> public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, FieldbookException { <END> return this.namingConventionService.advanceNursery(advanceInfo, workbook); }

sample: 83
buggy_code: public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) { //TODO MM: Dear code reviewer! I'm not sure if this is really cool. I'd assume mapping should happen in mappers, but their powers are limited. Please advise. MacPool macPool = incoming.getMacPool(); <START> macPool.setId(MacPoolIdByIdOrName.get(macPool.getId(), <END> macPool.getName(), this)); return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class), VdcActionType.UpdateCluster, new UpdateParametersProvider()); }
code_review: Please make it non-static, similar to what is done with ManagementNetworkFinder
target code: public org . ovirt . engine . api . model . Cluster update ( org . ovirt . engine . api . model . Cluster incoming ) { return performUpdate ( incoming , new QueryIdResolver < > ( VdcQueryType . GetClusterById , IdQueryParameters . class ) , VdcActionType . UpdateCluster , new UpdateParametersProvider ( this ) ) ; }
response: public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) { //TODO MM: Dear code reviewer! I'm not sure if this is really cool. I'd assume mapping should happen in mappers, but their powers are limited. Please advise. MacPool macPool = incoming.getMacPool(); <START> macPool.setId(MacPoolIdByIdOrName.get(macPool.getId(), <END> macPool.getName(), this)); return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class), VdcActionType.UpdateCluster, new UpdateParametersProvider()); }

sample: 84
buggy_code: protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) <START> { String analysisId = NonNullUtils.nullToEmptyString(getViewSite().getSecondaryId()); <END> return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) { IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId); if (module instanceof ISegmentStoreProvider) { return (ISegmentStoreProvider) module; } return null; } }; }
code_review: handle this with an error log and returning null instead of a viewer? as the view won't work with an incorrect id?
target code: protected @NonNull TmfViewer createLeftChildViewer ( @Nullable Composite parent ) { String analysisId = String . valueOf ( getViewSite ( ) . getSecondaryId ( ) ) ; return new AbstractSegmentStoreScatterChartTreeViewer ( Objects . requireNonNull ( parent ) ) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider ( ITmfTrace trace ) { IAnalysisModule module = TmfTraceUtils . getAnalysisModuleOfClass ( trace , IAnalysisModule . class , analysisId ) ; if ( module instanceof ISegmentStoreProvider ) { return ( ISegmentStoreProvider ) module ; } return null ; } } ; }
response: protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) <START> { String analysisId = NonNullUtils.nullToEmptyString(getViewSite().getSecondaryId()); <END> return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) { IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId); if (module instanceof ISegmentStoreProvider) { return (ISegmentStoreProvider) module; } else { Activator.getDefault().logError("Analysis module " + analysisId + " is not a segment store provider"); //$NON-NLS-1$ //$NON-NLS-2$ return null; } } }; }

sample: 85
buggy_code: public void testReservedSkippableBeforeStreamIdentifier() throws Exception { ByteBuf in = Unpooled.wrappedBuffer(new byte[] { -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y' }); <START> assertFalse(channel.writeInbound(in)); <END> }
code_review: I think it makes more sense to omit this assert in the expected exception cases?
target code: public void testReservedSkippableBeforeStreamIdentifier ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { - 0x7f , 0x06 , 0x00 , 0x00 , 's' , 'n' , 'e' , 't' , 't' , 'y' } ) ; channel . writeInbound ( in ) ; }
response: public void testReservedSkippableBeforeStreamIdentifier() throws Exception { ByteBuf in = Unpooled.wrappedBuffer(new byte[] { -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y' }); <START> assertFalse(channel.writeInbound(in)); <END> }

sample: 86
buggy_code: public void set(String name, Property property) throws PropertyNotFoundException { Field field = getType().getField(name); if (field == null) { Property removedProperty = computeRemovedProperty(name); if (removedProperty != null) { removedProperty.set(name, property); } return; } <START> children.put(field.getName().getPrefixedName(), property); <END> setIsModified(); }
code_review: In the `get` method which calls `getChild` we use `property.getName()` instead of `field.getName().getPrefixedName()` as the key in the `children` map. Can you make this consistent so that we're sure there's no discrepancy between prefixed/unprefixed?
target code: public void set ( String name , Property property ) throws PropertyNotFoundException { Field field = getType ( ) . getField ( name ) ; if ( field == null ) { Property removedProperty = computeRemovedProperty ( name ) ; if ( removedProperty != null ) { removedProperty . set ( name , property ) ; } return ; } children . put ( property . getName ( ) , property ) ; setIsModified ( ) ; }
response: public void set(String name, Property property) throws PropertyNotFoundException { Field field = getType().getField(name); if (field == null) { Property removedProperty = computeRemovedProperty(name); if (removedProperty != null) { removedProperty.set(name, property); } return; } <START> children.put(property.getName(), property); <END> setIsModified(); }

sample: 87
buggy_code: public int andCardinality(Container x) { if (this.getCardinality() == 0) return 0; else if (x.getCardinality() ==0) return 0; else { if (x instanceof ArrayContainer) <START> return and((ArrayContainer) x).getCardinality(); <END> else if (x instanceof BitmapContainer) return and((BitmapContainer) x).getCardinality(); return and((RunContainer) x).getCardinality(); } }
code_review: `andCardinality(Container)` should be called here instead of `and(Container).getCardinality()`
target code: public int andCardinality ( Container x ) { if ( this . getCardinality ( ) == 0 ) return 0 ; else if ( x . getCardinality ( ) == 0 ) return 0 ; else { if ( x instanceof ArrayContainer ) return andCardinality ( ( ArrayContainer ) x ) ; else if ( x instanceof BitmapContainer ) return andCardinality ( ( BitmapContainer ) x ) ; return andCardinality ( ( RunContainer ) x ) ; } }
response: public int andCardinality(Container x) { if (this.getCardinality() == 0) return 0; else if (x.getCardinality() ==0) return 0; else { if (x instanceof ArrayContainer) <START> return andCardinality((ArrayContainer) x); <END> else if (x instanceof BitmapContainer) return andCardinality((BitmapContainer) x); return andCardinality((RunContainer) x); } }

sample: 88
buggy_code: public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } <START> Set<WorkerNetAddress> workerAddresses = new HashSet<>(); <END> for (MasterWorkerInfo worker : mWorkers) { // worker net address is unmodifiable after initialization, no locking is needed workerAddresses.add(worker.getWorkerAddress()); } return workerAddresses; }
code_review: (nit) Initialize with initial capacity to be the number of workers.
target code: public Set < WorkerNetAddress > getWorkerAddresses ( ) throws UnavailableException { if ( mSafeModeManager . isInSafeMode ( ) ) { throw new UnavailableException ( ExceptionMessage . MASTER_IN_SAFEMODE . getMessage ( ) ) ; } Set < WorkerNetAddress > workerAddresses = new HashSet < > ( mWorkers . size ( ) ) ; for ( MasterWorkerInfo worker : mWorkers ) { // worker net address is unmodifiable after initialization , no locking is needed workerAddresses . add ( worker . getWorkerAddress ( ) ) ; } return workerAddresses ; }
response: public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } <START> Set<WorkerNetAddress> workerAddresses = new HashSet<>(mWorkers.size()); <END> for (MasterWorkerInfo worker : mWorkers) { // worker net address is unmodifiable after initialization, no locking is needed workerAddresses.add(worker.getWorkerAddress()); } return workerAddresses; }

sample: 89
buggy_code: public void setUp() { params.put("CallSid", "CA1234567890ABCDE"); params.put("Caller", "+14158675309"); params.put("Digits", "1234"); params.put("From", "+14158675309"); params.put("To", "+18005551212"); <START> signature = "RSOYDt4T1cUTdK1PDd93/VVr8B8="; <END> }
code_review: move this to where `signature` is declared, since it never changes?
target code: public void setUp ( ) { params . put ( "Digits" , "1234" ) ; params . put ( "CallSid" , "CA1234567890ABCDE" ) ; params . put ( "To" , " + 18005551212" ) ; params . put ( "Caller" , " + 14158675309" ) ; params . put ( "From" , " + 14158675309" ) ; }
response: public void setUp() { params.put("CallSid", "CA1234567890ABCDE"); params.put("Caller", "+14158675309"); params.put("Digits", "1234"); params.put("From", "+14158675309"); params.put("To", "+18005551212"); }

sample: 90
buggy_code: <START> public String getAttributeValue(@Nullable String name) { <END> return name; }
code_review: public @Nullable String...
target code: public @Nullable String getAttributeValue ( @Nullable String name ) { return name ; }
response: <START> public @Nullable String getAttributeValue(@Nullable String name) { <END> return name; }

sample: 91
buggy_code: public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { for (Object cookie : cookiesToClear) { Cookie realCookie = null; <START> if (cookie instanceof String) { <END> realCookie = new Cookie((String) cookie, null); String cookiePath = request.getContextPath() + "/"; realCookie.setPath(cookiePath); realCookie.setMaxAge(0); }else if (cookie instanceof Cookie){ realCookie = (Cookie) cookie; } response.addCookie(realCookie); } }
code_review: This logic will obviously need updated once we change `this.cookiesToClear`.
target code: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { cookiesToClear . forEach ( f - > response . addCookie ( f . apply ( request ) ) ) ; }
response: public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { for (Object cookie : cookiesToClear) { Cookie realCookie = null; <START> if (cookie instanceof String) { <END> realCookie = new Cookie((String) cookie, null); String cookiePath = request.getContextPath() + "/"; realCookie.setPath(cookiePath); realCookie.setMaxAge(0); }else if (cookie instanceof Cookie){ realCookie = (Cookie) cookie; } response.addCookie(realCookie); } }

sample: 92
buggy_code: <START> private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass) throws InvalidWebSocketException <END> { return MethodHandles.publicLookup().in(endpointClass); }
code_review: Can remove the throws `InvalidWebSocketException` now.
target code: private MethodHandles . Lookup getMethodHandleLookup ( Class < ? > endpointClass ) { return MethodHandles . publicLookup ( ) . in ( endpointClass ) ; }
response: <START> private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass) <END> { return MethodHandles.publicLookup().in(endpointClass); }

sample: 93
buggy_code: public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (maxConnections > 0) { if (numConnections.incrementAndGet() > maxConnections) { ctx.getChannel().close(); <START> numConnections.decrementAndGet(); <END> log.info("Accepted connection above limit ({}). Dropping.", maxConnections); } } super.channelOpen(ctx, e); }
code_review: won't this be a double-decrement?
target code: public void channelOpen ( ChannelHandlerContext ctx , ChannelStateEvent e ) throws Exception { if ( maxConnections > 0 ) { if ( numConnections . incrementAndGet ( ) > maxConnections ) { ctx . getChannel ( ) . close ( ) ; // numConnections will be decremented in channelClosed log . info ( "Accepted connection above limit ( { } ) . Dropping . " , maxConnections ) ; } } super . channelOpen ( ctx , e ) ; }
response: public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (maxConnections > 0) { if (numConnections.incrementAndGet() > maxConnections) { ctx.getChannel().close(); <START> numConnections.decrementAndGet(); <END> log.info("Accepted connection above limit ({}). Dropping.", maxConnections); } } super.channelOpen(ctx, e); }

sample: 94
buggy_code: public Builder from(int ... nums) { <START> this.matchers.add((from, to, msg) -> Arrays.binarySearch(nums, from) >= 0); <END> return this; }
code_review: this assumes the input is sorted, but the test case is what calls this; its very possible that the test defined them in non-sorted order
target code: public Builder from ( int . . . nums ) { from = nums ; return this ; }
response: public Builder from(int ... nums) { <START> this.matchers.add((from, to, msg) -> Arrays.binarySearch(nums, from) >= 0); <END> return this; }

sample: 95
buggy_code: public B channel(Class<? extends C> channelClass) { ObjectUtil.checkNotNull(channelClass, "channelClass"); <START> return channelFactory(new ReflectiveChannelFactory<C>(channelClass)); <END> }
code_review: @qeesung: nit you can merge the above 2 lines as `checkNotNull` returns `channelClass`.
target code: public B channel ( Class < ? extends C > channelClass ) { return channelFactory ( new ReflectiveChannelFactory < C > ( ObjectUtil . checkNotNull ( channelClass , "channelClass" ) ) ) ; }
response: public B channel(Class<? extends C> channelClass) { <START> return channelFactory(new ReflectiveChannelFactory<C>(ObjectUtil.checkNotNull(channelClass, "channelClass"))); <END> }

sample: 96
buggy_code: public void getActiveConditions_shouldGetActiveConditions() { List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2)); Condition firstActiveCondition = activeConditions.get(0); Condition secondActiveCondition = activeConditions.get(1); <START> String firstUUID = "2cc6880e-2c46-11e4-9138-a6c5e4d20fb7"; <END> String secondUUID = "2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"; Assert.assertTrue(activeConditions.size() == 2); Assert.assertEquals(firstUUID,firstActiveCondition.getUuid()); Assert.assertEquals(secondUUID, secondActiveCondition.getUuid()); }
code_review: For variables which you are using in one place, remove them and just use the actual value in that one place.
target code: public void getActiveConditions_shouldGetActiveConditions ( ) { List < Condition > activeConditions = conditionService . getActiveConditions ( patientService . getPatient ( 2 ) ) ; Assert . assertTrue ( activeConditions . size ( ) == 2 ) ; Assert . assertEquals ( "2cc6880e - 2c46 - 11e4 - 9138 - a6c5e4d20fb7" , activeConditions . get ( 0 ) . getUuid ( ) ) ; Assert . assertEquals ( "2cc6880e - 2c46 - 15e4 - 9038 - a6c5e4d22fb7" , activeConditions . get ( 1 ) . getUuid ( ) ) ; }
response: public void getActiveConditions_shouldGetActiveConditions() { List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2)); Condition firstActiveCondition = activeConditions.get(0); Condition secondActiveCondition = activeConditions.get(1); <START> String firstUUID = "2cc6880e-2c46-11e4-9138-a6c5e4d20fb7"; <END> String secondUUID = "2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"; Assert.assertTrue(activeConditions.size() == 2); Assert.assertEquals("2cc6880e-2c46-11e4-9138-a6c5e4d20fb7",firstActiveCondition.getUuid()); Assert.assertEquals("2cc6880e-2c46-15e4-9038-a6c5e4d22fb7", secondActiveCondition.getUuid()); }

sample: 97
buggy_code: public synchronized Inode<?> getInodeOrNull() { if (!fullPathExists()) { return null; } <START> List<Inode<?>> inodeList = Lists.newArrayList(mLockList.getInodes()); <END> return inodeList.get(inodeList.size() - 1); }
code_review: why is there a `newArrayList`?
target code: public synchronized Inode < ? > getInodeOrNull ( ) { if ( ! fullPathExists ( ) ) { return null ; } List < Inode < ? > > inodeList = mLockList . getInodes ( ) ; return inodeList . get ( inodeList . size ( ) - 1 ) ; }
response: public synchronized Inode<?> getInodeOrNull() { if (!fullPathExists()) { return null; } <START> List<Inode<?>> inodeList = mLockList.getInodes(); <END> return inodeList.get(inodeList.size() - 1); }

sample: 98
buggy_code: private static <T> Set<T> findDuplicates(Collection<T> list) { Set<T> duplicates = new HashSet<>(); Set<T> uniques = new HashSet<>(); <START> for(T t : list) { <END> if(!uniques.add(t)) { duplicates.add(t); } } return duplicates; }
code_review: why not `list.stream().forEach`?
target code: private static < T > Set < T > findDuplicates ( Collection < T > list ) { Set < T > duplicates = new HashSet < > ( ) ; Set < T > uniques = new HashSet < > ( ) ; list . stream ( ) . forEach ( t - > { if ( ! uniques . add ( t ) ) { duplicates . add ( t ) ; } } ) ; return duplicates ; }
response: private static <T> Set<T> findDuplicates(Collection<T> list) { Set<T> duplicates = new HashSet<>(); Set<T> uniques = new HashSet<>(); <START> list.stream().forEach(t -> { <END> if(!uniques.add(t)) { duplicates.add(t); } }); return duplicates; }

sample: 99
buggy_code: public boolean next() throws IOException { for (;;) { LogQueueEntry t = queue.poll(); if (t == null) { return false; } refName = t.lc.getRefName(); updateIndex = t.lc.getUpdateIndex(); entry = t.lc.getReflogEntry(); boolean include = includeDeletes || entry != null; skipShadowed(refName, updateIndex); add(t); <START> if (include) { return true; } return true; <END> } }
code_review: This isn't right.
target code: public boolean next ( ) throws IOException { for ( ; ; ) { LogQueueEntry t = queue . poll ( ) ; if ( t == null ) { return false ; } refName = t . lc . getRefName ( ) ; updateIndex = t . lc . getUpdateIndex ( ) ; entry = t . lc . getReflogEntry ( ) ; boolean include = includeDeletes || entry != null ; skipShadowed ( refName , updateIndex ) ; add ( t ) ; if ( include ) { return true ; } } }
response: public boolean next() throws IOException { for (;;) { LogQueueEntry t = queue.poll(); if (t == null) { return false; } refName = t.lc.getRefName(); updateIndex = t.lc.getUpdateIndex(); entry = t.lc.getReflogEntry(); boolean include = includeDeletes || entry != null; skipShadowed(refName, updateIndex); add(t); <START> if (include) { return true; } <END> } }

sample: 100
buggy_code: void remove(MessageGroup group) { Object correlationKey = group.getGroupId(); <START> if (this.groupIds.contains(correlationKey)) { <END> this.messageStore.removeMessageGroup(correlationKey); this.groupIds.remove(correlationKey); } }
code_review: That's not logic for this method. If we are here, we have to be already sure that it is our own group. The real problem is definitely in the `ForceReleaseMessageGroupProcessor` implementation. We have to check for its presence there. All other logic should not be affected. Please, make this `remove()` method `protected`.
target code: protected void remove ( MessageGroup group ) { Object correlationKey = group . getGroupId ( ) ; this . messageStore . removeMessageGroup ( correlationKey ) ; this . groupIds . remove ( group . getGroupId ( ) ) ; }
response: void remove(MessageGroup group) { Object correlationKey = group.getGroupId(); <START> this.messageStore.removeMessageGroup(correlationKey); this.groupIds.remove(correlationKey); <END> }

sample: 101
buggy_code: public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException { <START> if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) { <END> // Generally this logic should only be triggered once during first call. log.warn("Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API", cachedGroupMetadata.groupId(), consumerGroupId); cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId, JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty()); } sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false); }
code_review: Hmm, this feels like premature optimization. The offsets map is more likely to be a problem. Also, I'm not sure we should restrict the usage. It is possible today to send offsets for multiple groups. Is there a good reason to restrict this even if it doesn't make sense in streams?
target code: public void sendOffsetsToTransaction ( Map < TopicPartition , OffsetAndMetadata > offsets , String consumerGroupId ) throws ProducerFencedException { sendOffsetsToTransaction ( offsets , new ConsumerGroupMetadata ( consumerGroupId ) ) ; }
response: public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException { <START> if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) { <END> // Generally this logic should only be triggered once during first call. log.warn("Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API", cachedGroupMetadata.groupId(), consumerGroupId); cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId, JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty()); } sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false); }

sample: 102
buggy_code: public boolean cancel(final Exception rootReason) { if (transitionCancel(rootReason)) { final Exception reason = new CancellationException(rootReason); try { traceFailure(reason); } catch (Throwable ex) { <START> LOGGER.warn("Exception thrown in logging trace for failure!", ex); <END> } getSettableDelegate().fail(reason); return true; } return false; }
code_review: The issue we found was when the original `reason` could not be logged due to an error in its `toString`. Do we have any concern that logging the _new_ error might have the same issue? Would it be better to have two stages to this? 1. Catch the logging error, then try to log that error. 2. Catch _that_ error if it happens, and log a generic, static message.
target code: public boolean cancel ( final Exception rootReason ) { if ( transitionCancel ( rootReason ) ) { final Exception reason = new CancellationException ( rootReason ) ; try { traceFailure ( reason ) ; } catch ( Throwable ex ) { LOGGER . warn ( "Exception thrown in logging trace for failure ! " , ex ) ; } finally { // guard any exception that may throw from catch block getSettableDelegate ( ) . fail ( reason ) ; } return true ; } return false ; }
response: public boolean cancel(final Exception rootReason) { if (transitionCancel(rootReason)) { final Exception reason = new CancellationException(rootReason); try { traceFailure(reason); } catch (Throwable ex) { <START> LOGGER.warn("Exception thrown in logging trace for failure!", new Exception(ex)); <END> } getSettableDelegate().fail(reason); return true; } return false; }

sample: 103
buggy_code: <START> int allVersionsCombined() <END> { return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION; }
code_review: Can be private
target code: private int allVersionsCombined ( ) { return formatIdentifier > > > SHIFT_FORMAT_IDENTIFIER | formatVersion > > > SHIFT_FORMAT_VERSION ; }
response: <START> private int allVersionsCombined() <END> { return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION; }

sample: 104
buggy_code: <START> protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException { <END> writer.writeStartElement(Element.SIMPLE_CONNECTION); writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl()); writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass()); writeOptional(writer, Attribute.USERNAME, configuration.username()); writeOptional(writer, Attribute.PASSWORD, configuration.password()); writer.writeEndElement(); }
code_review: the connection configuration is never serialized.
target code: private void writeJDBCStoreConnection ( XMLExtendedStreamWriter writer , SimpleConnectionFactoryConfiguration configuration ) throws XMLStreamException { writer . writeStartElement ( Element . SIMPLE_CONNECTION ) ; writeOptional ( writer , Attribute . CONNECTION_URL , configuration . connectionUrl ( ) ) ; writeOptional ( writer , Attribute . DRIVER_CLASS , configuration . driverClass ( ) ) ; writeOptional ( writer , Attribute . USERNAME , configuration . username ( ) ) ; writeOptional ( writer , Attribute . PASSWORD , configuration . password ( ) ) ; writer . writeEndElement ( ) ; }
response: <START> protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException { <END> writer.writeStartElement(Element.SIMPLE_CONNECTION); writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl()); writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass()); writeOptional(writer, Attribute.USERNAME, configuration.username()); writeOptional(writer, Attribute.PASSWORD, configuration.password()); writer.writeEndElement(); }

sample: 105
buggy_code: <START> static ByteBuf copyData(ByteBufList list) { <END> ByteBuf buf = Unpooled.buffer(list.readableBytes()); for (int i = 0; i < list.size(); i++) { buf.writeBytes(list.getBuffer(i).slice()); } return buf; }
code_review: "public" or "private" ?
target code: private static ByteBuf copyData ( ByteBufList list ) { ByteBuf buf = Unpooled . buffer ( list . readableBytes ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { buf . writeBytes ( list . getBuffer ( i ) . slice ( ) ) ; } return buf ; }
response: <START> private static ByteBuf copyData(ByteBufList list) { <END> ByteBuf buf = Unpooled.buffer(list.readableBytes()); for (int i = 0; i < list.size(); i++) { buf.writeBytes(list.getBuffer(i).slice()); } return buf; }

sample: 106
buggy_code: private String getXMI_ID(final EObject eobject) { if (eobject.eResource() instanceof XMIResource) { return ((XMIResource) eobject.eResource()).getID(eobject); } <START> ; <END> return null; }
code_review: Useless
target code: private String getXMI_ID ( final EObject eobject ) { if ( eobject . eResource ( ) instanceof XMIResource ) { return ( ( XMIResource ) eobject . eResource ( ) ) . getID ( eobject ) ; } return null ; }
response: private String getXMI_ID(final EObject eobject) { if (eobject.eResource() instanceof XMIResource) { return ((XMIResource) eobject.eResource()).getID(eobject); } <START> return null; <END> }

sample: 107
buggy_code: <START> @Override public float getPressure () { <END> return 0; }
code_review: Can you format these overrides?
target code: public float getPressure ( ) { return 0 ; }
response: @Override public float getPressure () { return 0; }

sample: 108
buggy_code: private boolean checkForJournalFlush() { // System.err.printf("checkForJournalFlush: queue size=%d; journal size = %d\n", queue.size(), journal.size()) ; // System.err.printf("checkForJournalFlush: QueueBatchSize=%d; MaxQueueThreshold=%d; JournalThresholdSize=%d\n", // QueueBatchSize, MaxQueueThreshold, JournalThresholdSize) ; <START> if ( QueueBatchSize == 0 ) <END> return true ; if ( queue.size() >= QueueBatchSize ) // Based on number of queued commits // The MaxQueueThreshold is handled in processDelayedReplayQueue. return true ; boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ; if ( journalSizeFlush ) // JENA-1222 // Based on Journal file growing large in terms of bytes return true ; // No test for excessive queue length (MaxQueueThreshold). // That happens in notifyCommit (writer exit). return false ; }
code_review: I'm probably missing something, but it seems like this is part of the next case (isn't `queue.size() >= 0` an invariant?). Is this called out just to emphasize that setting `0` => "no queuing"?
target code: private boolean checkForJournalFlush ( ) { if ( queue . size ( ) >= QueueBatchSize ) return true ; boolean journalSizeFlush = ( JournalThresholdSize > 0 && journal . size ( ) > JournalThresholdSize ) ; if ( journalSizeFlush ) // JENA - 1222 // Based on Journal file growing large in terms of bytes return true ; // No test here for excessive queue length ( MaxQueueThreshold ) . return false ; }
response: private boolean checkForJournalFlush() { // System.err.printf("checkForJournalFlush: queue size=%d; journal size = %d\n", queue.size(), journal.size()) ; // System.err.printf("checkForJournalFlush: QueueBatchSize=%d; MaxQueueThreshold=%d; JournalThresholdSize=%d\n", // QueueBatchSize, MaxQueueThreshold, JournalThresholdSize) ; <START> if ( QueueBatchSize == 0 ) <END> return true ; if ( queue.size() >= QueueBatchSize ) // Based on number of queued commits // The MaxQueueThreshold is handled in processDelayedReplayQueue. return true ; boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ; if ( journalSizeFlush ) // JENA-1222 // Based on Journal file growing large in terms of bytes return true ; // No test for excessive queue length (MaxQueueThreshold). // That happens in notifyCommit (writer exit). return false ; }

sample: 109
buggy_code: private ProjectState newProjectState(ProjectConfig local) { <START> PrologEnvironment.Factory envFactory = null; GitRepositoryManager gitMgr = null; ProjectControl.AssistedFactory projectControlFactory = null; RulesCache rulesCache = null; SitePaths sitePaths = null; List<CommentLinkInfo> commentLinks = null; all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local)); <END> return all.get(local.getProject().getNameKey()); }
code_review: Use add(ProjectConfig) method here instead of repeating the same code?
target code: private ProjectState newProjectState ( ProjectConfig local ) { add ( local ) ; return all . get ( local . getProject ( ) . getNameKey ( ) ) ; }
response: private ProjectState newProjectState(ProjectConfig local) { <START> PrologEnvironment.Factory envFactory = null; GitRepositoryManager gitMgr = null; ProjectControl.AssistedFactory projectControlFactory = null; RulesCache rulesCache = null; SitePaths sitePaths = null; List<CommentLinkInfo> commentLinks = null; all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local)); <END> return all.get(local.getProject().getNameKey()); }

sample: 110
buggy_code: public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId <START> + "AND p.status_id != " + Persona.PersonaStatus.DELETED.getStatusId(); <END> CentralRepository cr = CentralRepository.getInstance(); if (cr != null) { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId; PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback(); cr.executeSelectSQL(queryClause, queryCallback); return queryCallback.getPersonaAccountsList(); } return new ArrayList<>(); }
code_review: There's a re-declaration error here, that got fixed on the parent branch. That needs to get merged in here.
target code: public static Collection < PersonaAccount > getPersonaAccountsForAccount ( long accountId ) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts . account_id = " + accountId + "AND p . status_id != " + Persona . PersonaStatus . DELETED . getStatusId ( ) ; CentralRepository cr = CentralRepository . getInstance ( ) ; if ( cr != null ) { PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback ( ) ; cr . executeSelectSQL ( queryClause , queryCallback ) ; return queryCallback . getPersonaAccountsList ( ) ; } return new ArrayList < > ( ) ; }
response: public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId <START> + "AND p.status_id != " + Persona.PersonaStatus.DELETED.getStatusId(); <END> CentralRepository cr = CentralRepository.getInstance(); if (cr != null) { PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback(); cr.executeSelectSQL(queryClause, queryCallback); return queryCallback.getPersonaAccountsList(); } return new ArrayList<>(); }

sample: 111
buggy_code: public boolean hasMultipleValues(final String dimension) { if (isVirtualColumn(dimension)) { return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues(); } final Column column = index.getColumn(dimension); <START> if (column == null || !columnSupportsFiltering(column)) { <END> return false; } else { return column.getCapabilities().hasMultipleValues(); } }
code_review: The same question, how "column supports filtering" relates to "has multiple values"?
target code: public boolean hasMultipleValues ( final String dimension ) { if ( isVirtualColumn ( dimension ) ) { return virtualColumns . getVirtualColumn ( dimension ) . capabilities ( dimension ) . hasMultipleValues ( ) ; } final Column column = index . getColumn ( dimension ) ; return column != null && column . getCapabilities ( ) . hasMultipleValues ( ) ; }
response: public boolean hasMultipleValues(final String dimension) { if (isVirtualColumn(dimension)) { return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues(); } final Column column = index.getColumn(dimension); <START> if (column == null || !columnSupportsFiltering(column)) { <END> return false; } else { return column.getCapabilities().hasMultipleValues(); } }

sample: 112
buggy_code: public void resumeNode(String id) { <START> waitServerUntilAvailable.apply(getNode(id)); <END> api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE)); }
code_review: This won't work? You wait until the node is powered on when you want to resume it. This will take forever.
target code: public void resumeNode ( String id ) { api . serverApi ( ) . updateStatus ( id , Server . UpdateStatus . create ( Types . ServerAction . POWER_ON , Types . ServerActionMethod . HARDWARE ) ) ; }
response: public void resumeNode(String id) { <START> waitServerUntilAvailable.apply(getNode(id)); api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE)); <END> }

sample: 113
buggy_code: public IStyledLabelProvider[] getLabelProviders() { <START> if (fLabelProviders == null) { <END> fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders(); } return fLabelProviders; }
code_review: either make this a get method that returns the result, or have it be a "load" method. Having it do both is unexpected (same for above method)
target code: public IStyledLabelProvider [ ] getLabelProviders ( ) { return fLabelProviders ; }
response: public IStyledLabelProvider[] getLabelProviders() { <START> if (fLabelProviders == null) { <END> fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders(); } return fLabelProviders; }

sample: 114
buggy_code: public void registerOperations(ManagementResourceRegistration resourceRegistration) { if (showResources) { resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler()); } else { resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE); <START> resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE); <END> } }
code_review: Why are these registered at all? What invokes them?
target code: public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { super . registerOperations ( resourceRegistration ) ; resourceRegistration . registerOperationHandler ( ShowJaxrsResourcesHandler . DEFINITION , new ShowJaxrsResourcesHandler ( ) ) ; }
response: public void registerOperations(ManagementResourceRegistration resourceRegistration) { if (showResources) { resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler()); } else { resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE); <START> resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE); <END> } }

sample: 115
buggy_code: public int hashCode() { <START> int result = processId.hashCode(); <END> result = 31 * result + taskId.hashCode(); result = 31 * result + taskName.hashCode(); result = 31 * result + formName.hashCode(); return result; }
code_review: And one for luck ;-)
target code: public int hashCode ( ) { int result = processId . hashCode ( ) ; result = ~~result ; result = 31 * result + taskId . hashCode ( ) ; result = ~~result ; result = 31 * result + taskName . hashCode ( ) ; result = ~~result ; result = 31 * result + formName . hashCode ( ) ; result = ~~result ; return result ; }
response: public int hashCode() { <START> int result = processId.hashCode(); result = 31 * result + taskId.hashCode(); <END> result = 31 * result + taskName.hashCode(); result = 31 * result + formName.hashCode(); return result; }

sample: 116
buggy_code: <START> public synchronized void stop(final String reason) <END> { new Thread( "Shutdown Thread" ) { @Override public void run() { independentThreadStop( reason, true ); } }.start(); }
code_review: Can probably remove synchronized now?
target code: public void stop ( final String reason ) { new Thread ( "Shutdown Thread" ) { @Override public void run ( ) { independentThreadStop ( reason , true ) ; } } . start ( ) ; }
response: <START> public void stop(final String reason) <END> { new Thread( "Shutdown Thread" ) { @Override public void run() { independentThreadStop( reason, true ); } }.start(); }

sample: 117
buggy_code: public boolean equals(Object o) { if (!(o instanceof Map.Entry)) <START> return <END> false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; return ((key == null ? e.getKey() == null : key.equals(e.getKey())) && (value == null ? e.getValue() == null : value.equals(e.getValue()))); }
code_review: braces
target code: public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return ( ( key == null ? e . getKey ( ) == null : key . equals ( e . getKey ( ) ) ) && ( value == null ? e . getValue ( ) == null : value . equals ( e . getValue ( ) ) ) ) ; }
response: public boolean equals(Object o) { if (!(o instanceof Map.Entry)) { <START> return <END> false; } Map.Entry<?,?> e = (Map.Entry<?,?>)o; return ((key == null ? e.getKey() == null : key.equals(e.getKey())) && (value == null ? e.getValue() == null : value.equals(e.getValue()))); }

sample: 118
buggy_code: <START> public PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException { <END> super(driver, properties, Dialect.POSTGRESQL); }
code_review: protected ?
target code: protected PostgreSqlEngine ( final PdbProperties properties , final String driver ) throws DatabaseEngineException { super ( driver , properties , Dialect . POSTGRESQL ) ; }
response: <START> protected PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException { <END> super(driver, properties, Dialect.POSTGRESQL); }

sample: 119
buggy_code: <START> public void dispose() { <END> clearCachedSwingEditor(); }
code_review: make dispose synchronized, then we could remove the volatile keyword in the class member.
target code: public synchronized void dispose ( ) { clearCachedSwingEditor ( ) ; }
response: <START> public synchronized void dispose() { <END> clearCachedSwingEditor(); }

sample: 120
buggy_code: public void run() { if(thread == null || !Thread.currentThread().equals(thread)) { <START> thread = new Thread(this); <END> thread.start(); } else { try { if (logger.isInfoEnabled()) logger.info("Start reconnecting " + provider); provider.register( getUIService().getDefaultSecurityAuthority(provider)); } catch (OperationFailedException ex) { logger.error("cannot re-register provider will keep going", ex); } } }
code_review: I'm thinking that new thread is not needed for the reconnect task. This thread should be dead already by the time a new reconnect is needed and I see `Timer` instance serving the purpose of this thread. What do you think?
target code: public void run ( ) { try { if ( logger . isInfoEnabled ( ) ) logger . info ( "Start reconnecting " + provider ) ; provider . register ( getUIService ( ) . getDefaultSecurityAuthority ( provider ) ) ; } catch ( OperationFailedException ex ) { logger . error ( "cannot re - register provider will keep going" , ex ) ; } }
response: public void run() { if(thread == null || !Thread.currentThread().equals(thread)) { <START> thread = new Thread(this); <END> thread.start(); } else { try { if (logger.isInfoEnabled()) logger.info("Start reconnecting " + provider); provider.register( getUIService().getDefaultSecurityAuthority(provider)); } catch (OperationFailedException ex) { logger.error("cannot re-register provider will keep going", ex); } } }

sample: 121
buggy_code: public void checkProperties(Properties properties) { <START> properties.setProperty("log4j.shutdownCallbackRegistry", "io.druid.common.config.Log4jShutdown"); <END> properties.setProperty("log4j.shutdownHookEnabled", "true"); }
code_review: Couldn't this actually depend on the class and generate the name from that?
target code: public void checkProperties ( Properties properties ) { if ( ! properties . contains ( "log4j . shutdownCallbackRegistry" ) ) { properties . setProperty ( "log4j . shutdownCallbackRegistry" , "io . druid . common . config . Log4jShutdown" ) ; } if ( ! properties . contains ( "log4j . shutdownHookEnabled" ) ) { properties . setProperty ( "log4j . shutdownHookEnabled" , "true" ) ; } }
response: public void checkProperties(Properties properties) { <START> properties.setProperty("log4j.shutdownCallbackRegistry", "io.druid.common.config.Log4jShutdown"); <END> properties.setProperty("log4j.shutdownHookEnabled", "true"); }

sample: 122
buggy_code: public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class); assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, ""); <END> // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }
code_review: ```suggestion assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE); ```
target code: public void testUnmarshallTopLevelEmptyEventProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_START_EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartTimerEvent emptyTop = getStartNodeById ( diagram , EMPTY_TOP_LEVEL_EVENT_ID , StartTimerEvent . class ) ; assertGeneralSet ( emptyTop . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertTimerEventEmpty ( emptyTop . getExecutionSet ( ) , NON_INTERRUPTING , EMPTY_VALUE ) ; // Know issue . Should be uncommented after https :/ / issues . jboss . org / browse / JBPM - 7038 will be fixed // assertDataIOSet ( emptySubprocess . getDataIOSet ( ) , EMPTY_VALUE ) ; }
response: public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class); assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE); <END> // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }

sample: 123
buggy_code: private EmbeddedExpirableMetadata( long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) { super(version); this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan); <START> this.maxIdle = maxIdleUnit.toMillis(maxIdle); <END> }
code_review: We should handle maxIdle as well
target code: private EmbeddedExpirableMetadata ( long lifespan , TimeUnit lifespanUnit , long maxIdle , TimeUnit maxIdleUnit , EntryVersion version ) { super ( version ) ; this . lifespan = lifespan < 0 ? - 1 : lifespanUnit . toMillis ( lifespan ) ; this . maxIdle = maxIdle < 0 ? - 1 : maxIdleUnit . toMillis ( maxIdle ) ; }
response: private EmbeddedExpirableMetadata( long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) { super(version); this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan); <START> this.maxIdle = maxIdle < 0 ? maxIdle : maxIdleUnit.toMillis(maxIdle); <END> }

sample: 124
buggy_code: protected void setMatcherString(String pattern) { if (pattern.length() == 0) { searchPattern = null; } else { SearchPattern patternMatcher = new SearchPattern(); if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) { <START> pattern = "*" + pattern; //$NON-NLS-1$ <END> } patternMatcher.setPattern(pattern); searchPattern = patternMatcher; } }
code_review: @Lars Do you think that for consistency (and maybe another slight performance enhancement) this line should be changed as well?
target code: protected void setMatcherString ( String pattern ) { if ( pattern . length ( ) == 0 ) { searchPattern = null ; } else { SearchPattern patternMatcher = new SearchPattern ( ) ; if ( pattern . indexOf ( ' * ' ) != 0 && pattern . indexOf ( ' ? ' ) != 0 && pattern . indexOf ( ' . ' ) != 0 ) { pattern = ' * ' + pattern ; } patternMatcher . setPattern ( pattern ) ; searchPattern = patternMatcher ; } }
response: protected void setMatcherString(String pattern) { if (pattern.length() == 0) { searchPattern = null; } else { SearchPattern patternMatcher = new SearchPattern(); if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) { <START> pattern = "*" + pattern; //$NON-NLS-1$ <END> } patternMatcher.setPattern(pattern); searchPattern = patternMatcher; } }

sample: 125
buggy_code: public DefaultEditorSession(final ManagedSession session, final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager, final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager, final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager, final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) { this.session = session; <START> this.commandRegistry = clientCommandRegistry.setSession(session); <END> this.sessionCommandManager = sessionCommandManager; this.requestCommandManager = requestCommandManager; this.canvasCommandManager = canvasCommandManager; }
code_review: yeah let's remove this :)
target code: public DefaultEditorSession ( final ManagedSession session , final CanvasCommandManager < AbstractCanvasHandler > canvasCommandManager , final @Session SessionCommandManager < AbstractCanvasHandler > sessionCommandManager , final @Request SessionCommandManager < AbstractCanvasHandler > requestCommandManager , final ClientCommandRegistry < org . kie . workbench . common . stunner . core . command . Command < AbstractCanvasHandler , CanvasViolation > > clientCommandRegistry ) { this . session = session ; this . commandRegistry = clientCommandRegistry ; this . sessionCommandManager = sessionCommandManager ; this . requestCommandManager = requestCommandManager ; this . canvasCommandManager = canvasCommandManager ; }
response: public DefaultEditorSession(final ManagedSession session, final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager, final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager, final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager, final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) { this.session = session; <START> this.commandRegistry = clientCommandRegistry.setSession(session); <END> this.sessionCommandManager = sessionCommandManager; this.requestCommandManager = requestCommandManager; this.canvasCommandManager = canvasCommandManager; }

sample: 126
buggy_code: private String transformToHeaderValue(Directive... directives) { <START> final StringBuilder sb = new StringBuilder(); <END> for (int i = 0; i < directives.length - 1; i++) { sb.append(directives[i].headerValue).append(", "); } sb.append(directives[directives.length - 1].headerValue); return sb.toString(); }
code_review: For consistency across the project, please remove the `final` keyword here.
target code: private String transformToHeaderValue ( Directive . . . directives ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < directives . length - 1 ; i ++ ) { sb . append ( directives [ i ] . headerValue ) . append ( " , " ) ; } sb . append ( directives [ directives . length - 1 ] . headerValue ) ; return sb . toString ( ) ; }
response: private String transformToHeaderValue(Directive... directives) { <START> StringBuilder sb = new StringBuilder(); <END> for (int i = 0; i < directives.length - 1; i++) { sb.append(directives[i].headerValue).append(", "); } sb.append(directives[directives.length - 1].headerValue); return sb.toString(); }

sample: 127
buggy_code: private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) { for (CloudProvisioningListener cl : CloudProvisioningListener.all()) { try { cl.onFailure(plannedNode, cause); } catch (Throwable e) { LOGGER.log(Level.SEVERE, "Unexpected uncaught exception encountered while " + "processing onFailure() listener call in " + cl + " for agent " + plannedNode.displayName, e); <START> if (e instanceof Error) { <END> throw e; } } } }
code_review:  De-facto we process errors in the logging handler. E.g. logging constructs the string, and it may cause OutOfMemoryError, which suppresses the original one. I'd rather vote that Errors are being rethrown without any processing
target code: private static void fireOnFailure ( final NodeProvisioner . PlannedNode plannedNode , final Throwable cause ) { for ( CloudProvisioningListener cl : CloudProvisioningListener . all ( ) ) { try { cl . onFailure ( plannedNode , cause ) ; } catch ( Error e ) { throw e ; } catch ( Throwable e ) { LOGGER . log ( Level . SEVERE , "Unexpected uncaught exception encountered while " + "processing onFailure ( ) listener call in " + cl + " for agent " + plannedNode . displayName , e ) ; } } }
response: private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) { for (CloudProvisioningListener cl : CloudProvisioningListener.all()) { try { cl.onFailure(plannedNode, cause); } catch (Throwable e) { LOGGER.log(Level.SEVERE, "Unexpected uncaught exception encountered while " + "processing onFailure() listener call in " + cl + " for agent " + plannedNode.displayName, e); <START> if (e instanceof Error) { throw e; } <END> } } }

sample: 128
buggy_code: public synchronized boolean isLastMQNotifLongAgo() { long delay = 18 * 3600; // 24h - 3h = 18h long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay; if (threshold < Calendar.getInstance().getTimeInMillis()) { Logger.d(TAG, "{} - Last MQ notif was yesterday", getCurrentModeName()); return true; } else { <START> Logger.d(TAG, "{} - Last MQ notif was recent, do not notify", getCurrentModeName()); <END> return false; } }
code_review: These two logs could be `Logger.v()`. That's all, good to go!
target code: public synchronized boolean isLastMQNotifLongAgo ( ) { long delay = 18 * 3600 ; // 24h - 3h = 18h long threshold = sharedPreferences . getLong ( getCurrentModeName ( ) + LAST_MORNING_Q_TIMESTAMP , - delay ) + delay ; if ( threshold < Calendar . getInstance ( ) . getTimeInMillis ( ) ) { Logger . v ( TAG , " { } - Last MQ notif was yesterday" , getCurrentModeName ( ) ) ; return true ; } else { Logger . v ( TAG , " { } - Last MQ notif was recent , do not notify" , getCurrentModeName ( ) ) ; return false ; } }
response: public synchronized boolean isLastMQNotifLongAgo() { long delay = 18 * 3600; // 24h - 3h = 18h long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay; if (threshold < Calendar.getInstance().getTimeInMillis()) { Logger.d(TAG, "{} - Last MQ notif was yesterday", getCurrentModeName()); return true; } else { <START> Logger.v(TAG, "{} - Last MQ notif was recent, do not notify", getCurrentModeName()); <END> return false; } }

sample: 129
buggy_code: public CrewMember apply(org.atlasapi.media.entity.CrewMember input) { if (input instanceof org.atlasapi.media.entity.Actor) { return translateLegacyActor((org.atlasapi.media.entity.Actor) input); <START> } else if(Objects.nonNull(input)) { <END> return translateLegacyCrewMember(input); } else { return null; } }
code_review: Ditto `input != null`
target code: public CrewMember apply ( org . atlasapi . media . entity . CrewMember input ) { // we carry IDs through from Owl to Deer , reject anything without one if ( null == input . getId ( ) ) { return null ; } if ( input instanceof org . atlasapi . media . entity . Actor ) { return translateLegacyActor ( ( org . atlasapi . media . entity . Actor ) input ) ; } else if ( null != input ) { return translateLegacyCrewMember ( input ) ; } else { return null ; } }
response: public CrewMember apply(org.atlasapi.media.entity.CrewMember input) { if (input instanceof org.atlasapi.media.entity.Actor) { return translateLegacyActor((org.atlasapi.media.entity.Actor) input); <START> } else if(input != null) { <END> return translateLegacyCrewMember(input); } else { return null; } }

sample: 130
buggy_code: public void testSocket() throws Exception { Socket s = new Socket(); s.connect(server.getLocalAddress()); s.close(); assertEquals(Collections.EMPTY_MAP, <START> tagger.getLiveDescriptors()); <END> }
code_review: Did you want to assert something before close in all these cases? i.e. it's not empty.
target code: public void testSocket ( ) throws Exception { Socket s = new Socket ( ) ; s . connect ( server . getLocalAddress ( ) ) ; assertEquals ( 1 , tagger . getLiveDescriptors ( ) . size ( ) ) ; s . close ( ) ; assertEquals ( Collections . EMPTY_MAP , tagger . getLiveDescriptors ( ) ) ; }
response: public void testSocket() throws Exception { Socket s = new Socket(); s.connect(server.getLocalAddress()); assertEquals(Collections.EMPTY_MAP, <START> tagger.getLiveDescriptors()); <END> s.close(); }

sample: 131
buggy_code: public ValuesMatcher( Map<String, Integer> outputSymbolAliases, Optional<Integer> expectedOutputSymbolCount, Optional<List<List<Expression>>> expectedRows) { <START> this.outputSymbolAliases = ImmutableMap.copyOf(requireNonNull(outputSymbolAliases, "outputSymbolAliases is null")); <END> this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, "expectedOutputSymbolCount is null"); this.expectedRows = requireNonNull(expectedRows, "expectedRows is null"); }
code_review: `requireNonNull` is not needed given `copyOf` checks for nullability.
target code: public ValuesMatcher ( Map < String , Integer > outputSymbolAliases , Optional < Integer > expectedOutputSymbolCount , Optional < List < List < Expression > > > expectedRows ) { this . outputSymbolAliases = ImmutableMap . copyOf ( outputSymbolAliases ) ; this . expectedOutputSymbolCount = requireNonNull ( expectedOutputSymbolCount , "expectedOutputSymbolCount is null" ) ; this . expectedRows = requireNonNull ( expectedRows , "expectedRows is null" ) ; }
response: public ValuesMatcher( Map<String, Integer> outputSymbolAliases, Optional<Integer> expectedOutputSymbolCount, Optional<List<List<Expression>>> expectedRows) { <START> this.outputSymbolAliases = ImmutableMap.copyOf(outputSymbolAliases); <END> this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, "expectedOutputSymbolCount is null"); this.expectedRows = requireNonNull(expectedRows, "expectedRows is null"); }

sample: 132
buggy_code: protected Button getButton(int id) { <START> return buttons.get(new Integer(id)); <END> }
code_review: Can just pass id and let Java autoboxing take care of it.
target code: protected Button getButton ( int id ) { return buttons . get ( id ) ; }
response: protected Button getButton(int id) { <START> return buttons.get(id); <END> }

sample: 133
buggy_code: public void setInitializationData(IConfigurationElement config, String propertyName, Object data) { if (data instanceof <START> Hashtable) { <END> Hashtable<?, ?> table = (Hashtable<?, ?>) data; color = (String) table.get("color"); //$NON-NLS-1$ } }
code_review: Better: Map
target code: public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) { if ( data instanceof Hashtable < ? , ? > ) { Hashtable < ? , ? > map = ( Hashtable < ? , ? > ) data ; color = ( String ) map . get ( "color" ) ; // $NON - NLS - 1$ } }
response: public void setInitializationData(IConfigurationElement config, String propertyName, Object data) { if (data instanceof <START> Map) { <END> Map<?, ?> table = (Map<?, ?>) data; color = (String) table.get("color"); //$NON-NLS-1$ } }

sample: 134
buggy_code: public void addRequestCleanupHandler(HttpServletRequest request) { RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() { @Override public void cleanup(HttpServletRequest req) { try { close(); } catch (OperationException cause) { <START> throw new NuxeoException(cause); <END> } } }); }
code_review: `cause` > `e` please
target code: public void addRequestCleanupHandler ( HttpServletRequest request ) { RequestContext . getActiveContext ( request ) . addRequestCleanupHandler ( new RequestCleanupHandler ( ) { @Override public void cleanup ( HttpServletRequest req ) { try { close ( ) ; } catch ( OperationException e ) { throw new NuxeoException ( e ) ; } } } ) ; }
response: public void addRequestCleanupHandler(HttpServletRequest request) { RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() { @Override public void cleanup(HttpServletRequest req) { try { close(); } catch (OperationException e) { <START> throw new NuxeoException(e); <END> } } }); }

sample: 135
buggy_code: public void visitStatementList(PyStatementListTree pyStatementListTree) { <START> if (isStmtListIncrementsNestingLevel(pyStatementListTree) && !pyStatementListTree.parent().is(Kind.FILE_INPUT)) { <END> nestingLevelStack.peek().increment(); super.visitStatementList(pyStatementListTree); nestingLevelStack.peek().decrement(); } else { super.visitStatementList(pyStatementListTree); } }
code_review: Why not move the logic about `Kind.FILE_INPUT` inside `isStmtListIncrementsNestingLevel`?
target code: public void visitStatementList ( PyStatementListTree pyStatementListTree ) { if ( isStmtListIncrementsNestingLevel ( pyStatementListTree ) ) { nestingLevelStack . peek ( ) . increment ( ) ; super . visitStatementList ( pyStatementListTree ) ; nestingLevelStack . peek ( ) . decrement ( ) ; } else { super . visitStatementList ( pyStatementListTree ) ; } }
response: public void visitStatementList(PyStatementListTree pyStatementListTree) { <START> if (isStmtListIncrementsNestingLevel(pyStatementListTree)) { <END> nestingLevelStack.peek().increment(); super.visitStatementList(pyStatementListTree); nestingLevelStack.peek().decrement(); } else { super.visitStatementList(pyStatementListTree); } }

sample: 136
buggy_code: private static void checkLxmlParseCall(SubscriptionContext ctx) { CallExpression callExpression = (CallExpression) ctx.syntaxNode(); if (checkCallExpressionFqn(callExpression, LXML_PARSE)) { CallExpression parserCall = getParserCall( getArgValueAsCallExpression( TreeUtils.nthArgumentOrKeyword(1, "parser", callExpression.arguments()))); if (parserCall != null && isUnsafeParserUsage(parserCall)) { <START> ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, MESSAGE); <END> } } }
code_review: no need to add the same message to the secondary location
target code: private static void checkLxmlParseCall ( SubscriptionContext ctx ) { CallExpression callExpression = ( CallExpression ) ctx . syntaxNode ( ) ; if ( checkCallExpressionFqn ( callExpression , LXML_PARSE ) ) { CallExpression parserCall = getParserCall ( getArgValueAsCallExpression ( TreeUtils . nthArgumentOrKeyword ( 1 , "parser" , callExpression . arguments ( ) ) ) ) ; if ( parserCall != null && isUnsafeParserUsage ( parserCall ) ) { ctx . addIssue ( parserCall , MESSAGE ) . secondary ( callExpression , null ) ; } } }
response: private static void checkLxmlParseCall(SubscriptionContext ctx) { CallExpression callExpression = (CallExpression) ctx.syntaxNode(); if (checkCallExpressionFqn(callExpression, LXML_PARSE)) { CallExpression parserCall = getParserCall( getArgValueAsCallExpression( TreeUtils.nthArgumentOrKeyword(1, "parser", callExpression.arguments()))); if (parserCall != null && isUnsafeParserUsage(parserCall)) { <START> ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, null); <END> } } }

sample: 137
buggy_code: public int getVisibility(IBinding member) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST); return members.getAccessibility(member); } catch (CoreException e) { CCorePlugin.log(e); <START> throw new IllegalArgumentException(member.getName() + " is not a member of " + getName()); //$NON-NLS-1$ <END> } }
code_review: The same error is reported twice.
target code: public int getVisibility ( IBinding member ) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock ( getLinkage ( ) , record + MEMBERLIST ) ; return members . getVisibility ( member ) ; } catch ( CoreException e ) { CCorePlugin . log ( e ) ; throw new IllegalArgumentException ( member . getName ( ) + " is not a member of " + getName ( ) ) ; // $NON - NLS - 1$ } }
response: public int getVisibility(IBinding member) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST); return members.getAccessibility(member); } catch (CoreException e) { CCorePlugin.log(e); <START> throw new IllegalArgumentException(member.getName() + " is not a member of " + getName()); //$NON-NLS-1$ <END> } }

sample: 138
buggy_code: public Map<String,Object> getDynamicTemplateData() { if(dynamicTemplateData == null) <START> return Collections.<String,Object>emptyMap(); <END> return dynamicTemplateData; }
code_review: Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement. Alternatively, a more succinct way of writing this method would be: ``` return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData; ```
target code: public Map < String , Object > getDynamicTemplateData ( ) { return dynamicTemplateData == null ? Collections . < String , Object > emptyMap ( ) : dynamicTemplateData ; }
response: public Map<String,Object> getDynamicTemplateData() { if(dynamicTemplateData == null) { <START> return Collections.<String,Object>emptyMap(); <END> } return dynamicTemplateData; }

sample: 139
buggy_code: <START> public String getVersion() { <END> return version; }
code_review: I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
target code: String getVersion ( ) { return version ; }
response: <START> public String getVersion() { <END> return version; }

sample: 140
buggy_code: public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException { Utils.checkPerunSession(sess); // Authorization if(!AuthzResolver.isAuthorized(sess, Role.PERUNADMIN) && <START> !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) { <END> throw new PrivilegeException(sess, "getUsers"); } return getUsersManagerBl().getUsers(sess); }
code_review: You can drop PERUNADMIN check here. And also in all other such methods in this file please.
target code: public List < User > getUsers ( PerunSession sess ) throws InternalErrorException , PrivilegeException { Utils . checkPerunSession ( sess ) ; // Authorization if ( ! AuthzResolver . isAuthorized ( sess , Role . PERUNOBSERVER ) ) { throw new PrivilegeException ( sess , "getUsers" ) ; } return getUsersManagerBl ( ) . getUsers ( sess ) ; }
response: public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException { Utils.checkPerunSession(sess); // Authorization if(<START> !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) { <END> throw new PrivilegeException(sess, "getUsers"); } return getUsersManagerBl().getUsers(sess); }

sample: 141
buggy_code: protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); <START> if (cluster.isSetRequiredSwitchType()) { <END> SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } }
code_review: Negation missing? if (!cluster.isSetRequiredSwitchType()) {
target code: protected void setDefaultSwitchTypeIfNeeded ( ) { Cluster cluster = getCluster ( ) ; if ( ! cluster . isSetRequiredSwitchType ( ) ) { SwitchType defaultSwitchType = DefaultSwitchType . getDefaultSwitchType ( cluster . getCompatibilityVersion ( ) ) ; cluster . setRequiredSwitchTypeForCluster ( defaultSwitchType ) ; } }
response: protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); <START> if (!cluster.isSetRequiredSwitchType()) { <END> SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } }

sample: 142
buggy_code: public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI) <START> throws IOException <END> { throw new UnsupportedOperationException("GetBlockLocations is not supported."); }
code_review: Removed.
target code: public List < BlockLocationInfo > getBlockLocations ( AlluxioURI alluxioURI ) { throw new UnsupportedOperationException ( "GetBlockLocations is not supported . " ) ; }
response: public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI) { throw new UnsupportedOperationException("GetBlockLocations is not supported."); }

sample: 143
buggy_code: public CustomTxtParserWizard() { super(); <START> setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle); <END> }
code_review: can this be in the second ctor and call this(null) here?
target code: public CustomTxtParserWizard ( ) { this ( null ) ; }
response: public CustomTxtParserWizard() { super(); <START> setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle); <END> }

sample: 144
buggy_code: <START> protected Provider<AdditionalProperties> createProvider(String name) { <END> Provider<AdditionalProperties> p = mock(Provider.class); when(p.getName()).thenReturn(name); return p; }
code_review: Don't see how this change is necessary
target code: private Provider < AdditionalProperties > createProvider ( String name ) { Provider < AdditionalProperties > p = mock ( Provider . class ) ; when ( p . getName ( ) ) . thenReturn ( name ) ; return p ; }
response: <START> protected Provider<AdditionalProperties> createProvider(String name) { <END> Provider<AdditionalProperties> p = mock(Provider.class); when(p.getName()).thenReturn(name); return p; }

sample: 145
buggy_code: public static int mapApiToArtVersion(int api) { if (api < 19) { return NO_VERSION; } switch (api) { case 19: case 20: return 7; case 21: return 39; case 22: return 45; case 23: return 64; case 24: case 25: return 79; case 26: return 124; case 27: return 131; case 28: // 144 is the current version in the master branch of AOSP as of 2018-05-22 return 144; } <START> return 143; <END> }
code_review: You can change the 28 case to a default case, and remove this.
target code: public static int mapApiToArtVersion ( int api ) { if ( api < 19 ) { return NO_VERSION ; } switch ( api ) { case 19 : case 20 : return 7 ; case 21 : return 39 ; case 22 : return 45 ; case 23 : return 64 ; case 24 : case 25 : return 79 ; case 26 : return 124 ; case 27 : return 131 ; default : // 144 is the current version in the master branch of AOSP as of 2018 - 05 - 22 return 144 ; } }
response: public static int mapApiToArtVersion(int api) { if (api < 19) { return NO_VERSION; } switch (api) { case 19: case 20: return 7; case 21: return 39; case 22: return 45; case 23: return 64; case 24: case 25: return 79; case 26: return 124; case 27: return 131; default: // 144 is the current version in the master branch of AOSP as of 2018-05-22 return 144; } <START> return 143; <END> }

sample: 146
buggy_code: public void onAppendColumnEvent() { AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP); scenarioSimulationEventHandler.onEvent(event); verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class)); <START> verify(scenarioGridPanelMock).setFocus(true); <END> }
code_review: @jomarko If it is possible to move all those "context.getScenarioGridPanel().setFocus(true);" inside commonExecution, then move this "verify(scenarioGridPanelMock).setFocus(true);" inside "commonExecution" Test
target code: public void onAppendColumnEvent ( ) { AppendColumnEvent event = new AppendColumnEvent ( COLUMN_GROUP ) ; scenarioSimulationEventHandler . onEvent ( event ) ; verify ( scenarioSimulationEventHandler ) . commonExecution ( eq ( scenarioSimulationContextLocal ) , isA ( AppendColumnCommand . class ) , eq ( true ) ) ; }
response: public void onAppendColumnEvent() { AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP); scenarioSimulationEventHandler.onEvent(event); verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class)); }

sample: 147
buggy_code: public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception { byte[] bytes = serialize( instance ); T result = ( T )deserialize( bytes ); <START> Object adapter = result.getDisplay().getAdapter( IDisplayAdapter.class ); <END> IDisplayAdapter displayAdapter = ( IDisplayAdapter )adapter; displayAdapter.attachThread(); return result; }
code_review: Since getAdapter() has a generic interface, there is no need to type cast anymore.
target code: public static < T > T serializeAndDeserialize ( T instance ) throws Exception { byte [ ] bytes = serialize ( instance ) ; return ( T ) deserialize ( bytes ) ; }
response: public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception { byte[] bytes = serialize( instance ); T result = ( T )deserialize( bytes ); <START> IDisplayAdapter displayAdapter = result.getDisplay().getAdapter( IDisplayAdapter.class ); <END> displayAdapter.attachThread(); return result; }

sample: 148
buggy_code: <START> public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) { <END> for (PreReceiveHook hook : hooks) { hook.onPreReceive(rp, commands); } }
code_review: maybe line wrap?
target code: public void onPreReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( int i = 0 ; i < count ; i ++ ) hooks [ i ] . onPreReceive ( rp , commands ) ; }
response: <START> public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) { <END> for (PreReceiveHook hook : hooks) { hook.onPreReceive(rp, commands); } }

sample: 149
buggy_code: public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) { if (annotation == null) { throw new NullPointerException("Cannot add a null annotation"); } annotations.add(annotation); <START> annotations.addAll(Arrays.asList(additionalAnnotations)); <END> return this; }
code_review: This only checks the first parameter for `null`. Could you update the version that takes in a `List` to check the entries for `null`s and update this line to call that version?
target code: public DescriptionBuilder withAdditionalAnnotations ( Annotation annotation , Annotation . . . additionalAnnotations ) { List < Annotation > annotations = new ArrayList < Annotation > ( ) ; annotations . add ( annotation ) ; annotations . addAll ( Arrays . asList ( additionalAnnotations ) ) ; return withAdditionalAnnotations ( annotations ) ; }
response: public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) { if (annotation == null) { throw new NullPointerException("Cannot add a null annotation"); } annotations.add(annotation); <START> withAdditionalAnnotations(Arrays.asList(additionalAnnotations)); <END> return this; }

sample: 150
buggy_code: public void onAttach(final Activity activity) { super.onAttach(activity); try { mListener = (Listener) activity; <START> } catch (final ClassCastException e) { <END> Lg.e(activity.getClass().getName(), " should implement ", Listener.class.getName()); } }
code_review: instanceof?
target code: public void onAttach ( final Activity activity ) { super . onAttach ( activity ) ; if ( activity instanceof Listener ) { mListener = ( Listener ) activity ; } else { Lg . e ( activity . getClass ( ) . getName ( ) , " should implement " , Listener . class . getName ( ) ) ; } }
response: public void onAttach(final Activity activity) { super.onAttach(activity); try { mListener = (Listener) activity; <START> } catch (final ClassCastException e) { <END> Lg.e(activity.getClass().getName(), " should implement ", Listener.class.getName()); } }

sample: 151
buggy_code: private void preloadDataSet(){ preloadedDataSet = load(iter.next()); totalOutcomes = preloadedDataSet.getLabels().size(1); inputColumns = preloadedDataSet.getFeatureMatrix().size(1); <START> batch = preloadedDataSet.numExamples(); <END> }
code_review: Need to be careful here. We can't always assume classification problems. Maybe use -1 (last dimension) instead?
target code: private void preloadDataSet ( ) { preloadedDataSet = load ( iter . next ( ) ) ; totalOutcomes = preloadedDataSet . getLabels ( ) . size ( 1 ) ; inputColumns = preloadedDataSet . getFeatureMatrix ( ) . size ( 1 ) ; }
response: private void preloadDataSet(){ preloadedDataSet = load(iter.next()); totalOutcomes = preloadedDataSet.getLabels().size(1); inputColumns = preloadedDataSet.getFeatureMatrix().size(1); <START> batch = preloadedDataSet.numExamples(); <END> }

sample: 152
buggy_code: public void startup(Application application, ComponentStartupStatus ss) { FileOps.ensureDir(deltaClientZone); FileOps.clearAll(deltaClientZone); zone = Zone.connect(deltaClientZone); deltaLink = DeltaLinkHTTP.connect(deltaServerURL); deltaClient = DeltaClient.create(zone, deltaLink); jmsMessagingClient = application.getJMSMessagingClient(); <START> log.info(String.format("DeltaClient connected to DeltaServer at %s with zone %s", deltaServerURL, deltaClientZone)); <END> }
code_review: `log.info()` to `ss.info()`.
target code: public void startup ( Application application , ComponentStartupStatus ss ) { FileOps . ensureDir ( deltaClientZone ) ; FileOps . clearAll ( deltaClientZone ) ; Zone zone = Zone . connect ( deltaClientZone ) ; deltaLink = DeltaLinkHTTP . connect ( deltaServerURL ) ; deltaClient = DeltaClient . create ( zone , deltaLink ) ; jmsMessagingClient = application . getJMSMessagingClient ( ) ; ss . info ( String . format ( "DeltaClient connected to DeltaServer at % s with zone % s" , deltaServerURL , deltaClientZone ) ) ; }
response: public void startup(Application application, ComponentStartupStatus ss) { FileOps.ensureDir(deltaClientZone); FileOps.clearAll(deltaClientZone); zone = Zone.connect(deltaClientZone); deltaLink = DeltaLinkHTTP.connect(deltaServerURL); deltaClient = DeltaClient.create(zone, deltaLink); jmsMessagingClient = application.getJMSMessagingClient(); <START> ss.info(String.format("DeltaClient connected to DeltaServer at %s with zone %s", deltaServerURL, deltaClientZone)); <END> }

sample: 153
buggy_code: protected void onInit() { super.onInit(); if (this.connectionFactory == null) { <START> this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort()); <END> this.connectionFactory.setDeserializer(new ByteArrayLfSerializer()); this.connectionFactory.setBeanFactory(getBeanFactory()); if (this.applicationEventPublisher != null) { this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher); } this.connectionFactory.afterPropertiesSet(); } this.connectionFactory.registerListener(this); }
code_review: I think we don't need this change. We have similar structure in the `UdpSyslogReceivingChannelAdapter` below but you don't override the `onInit()` logic there.
target code: protected void onInit ( ) { super . onInit ( ) ; if ( this . connectionFactory == null ) { this . connectionFactory = new TcpNioServerConnectionFactory ( getPort ( ) ) ; this . connectionFactory . setDeserializer ( new ByteArrayLfSerializer ( ) ) ; this . connectionFactory . setBeanFactory ( getBeanFactory ( ) ) ; if ( this . applicationEventPublisher != null ) { this . connectionFactory . setApplicationEventPublisher ( this . applicationEventPublisher ) ; } this . connectionFactory . afterPropertiesSet ( ) ; } this . connectionFactory . registerListener ( this ) ; }
response: protected void onInit() { super.onInit(); if (this.connectionFactory == null) { <START> this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort()); <END> this.connectionFactory.setDeserializer(new ByteArrayLfSerializer()); this.connectionFactory.setBeanFactory(getBeanFactory()); if (this.applicationEventPublisher != null) { this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher); } this.connectionFactory.afterPropertiesSet(); } this.connectionFactory.registerListener(this); }

sample: 154
buggy_code: <START> public static Pair<Integer, Integer> getPrecisionAndScale(String type) { <END> String param = type.substring(8, type.length() - 1); String[] params = param.split(","); return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim())); }
code_review: are there some unit tests for this? Will this handle extraneous whitespaces well?
target code: public static Pair < Integer , Integer > getPrecisionAndScale ( String type ) { type = type . trim ( ) ; String param = type . substring ( 8 , type . length ( ) - 1 ) ; String [ ] params = param . split ( " , " ) ; return new Pair < > ( Integer . parseInt ( params [ 0 ] . trim ( ) ) , Integer . parseInt ( params [ 1 ] . trim ( ) ) ) ; }
response: <START> public static Pair<Integer, Integer> getPrecisionAndScale(String type) { <END> String param = type.substring(8, type.length() - 1); String[] params = param.split(","); return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim())); }

sample: 155
buggy_code: <START> static String constructSegmentPath(String baseKey, String storageDir) <END> { return JOINER.join( baseKey.isEmpty() ? null : baseKey, storageDir ) + "/index.zip"; }
code_review: we don't know if these were used in extensions, can the things that were public remain so?
target code: public static String constructSegmentPath ( String baseKey , String storageDir ) { return JOINER . join ( baseKey . isEmpty ( ) ? null : baseKey , storageDir ) + " / index . zip" ; }
response: <START> static String constructSegmentPath(String baseKey, String storageDir) <END> { return JOINER.join( baseKey.isEmpty() ? null : baseKey, storageDir ) + "/index.zip"; }

sample: 156
buggy_code: public MappingIterator(Collection<S> source, Function<S, D> transformation) { this.sourceIt = source.iterator(); this.transformation = transformation; <START> readNext(); <END> }
code_review: I find it strange that the constructor already does some work. Might catch someone by surprise, especially if he wants to concatenate several iterators. I'd like this better if only hasNext() or next() actually advanced. It's more predictable. Maybe similar to the logic in CachingKeyPairProvider$CancellingKeyPairIterator . That one is similar to MappingIterator<Path, KeyPair>.
target code: public MappingIterator ( Collection < S > source , Function < S , D > transformation ) { this . sourceIt = source . iterator ( ) ; this . transformation = transformation ; }
response: public MappingIterator(Collection<S> source, Function<S, D> transformation) { this.sourceIt = source.iterator(); this.transformation = transformation; }

sample: 157
buggy_code: public boolean removeAll(Collection<?> c) { boolean changed = false; for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) { <START> if (map.remove(x.getFilename(), x)) { <END> changed = true; } } if (changed) { updatedMap(); } return changed; }
code_review: remove(a,b) is going to use equals which is not right for XWikiAttachment. You should use remove(a) != b instead.
target code: public boolean removeAll ( Collection < ? > c ) { boolean changed = false ; for ( XWikiAttachment x : ( Collection < ? extends XWikiAttachment > ) c ) { if ( map . get ( x . getFilename ( ) ) == x ) { map . remove ( x . getFilename ( ) ) ; changed = true ; } } if ( changed ) { updatedMap ( ) ; } return changed ; }
response: public boolean removeAll(Collection<?> c) { boolean changed = false; for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) { <START> if (map.remove(x.getFilename()) != x) { <END> changed = true; } } if (changed) { updatedMap(); } return changed; }

sample: 158
buggy_code: public void run(String... strings) throws Exception { <START> System.out.println(">>> Starting Audit App... "); <END> }
code_review: @erdemedeiros let's remove all the system outs
target code: public void run ( String . . . strings ) throws Exception { }
response: public void run(String... strings) throws Exception { <START> log.info(">>> Starting Audit App... "); <END> }

sample: 159
buggy_code: public CollectEnvCommand(FileSystemContext fsContext) { super(fsContext); <START> mCommands = new HashMap<>(); mCommandsAlt = new HashMap<>(); <END> registerCommands(); }
code_review: This is already initialized by super class.
target code: public CollectEnvCommand ( FileSystemContext fsContext ) { super ( fsContext ) ; registerCommands ( ) ; }
response: public CollectEnvCommand(FileSystemContext fsContext) { super(fsContext); <START> mCommandsAlt = new HashMap<>(); <END> registerCommands(); }

sample: 160
buggy_code: protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException("BlobStorageService cannot be null"); <START> } else { <END> this.blobStorageService = blobStorageService; logger.trace("BlobStorage service set to {}", blobStorageService.getClass()); } }
code_review: The "else" seems unnecessary
target code: protected void setBlobStorageService ( BlobStorageService blobStorageService ) { if ( blobStorageService == null ) { throw new IllegalArgumentException ( "BlobStorageService cannot be null" ) ; } this . blobStorageService = blobStorageService ; logger . trace ( "BlobStorage service set to { } " , blobStorageService . getClass ( ) ) ; }
response: protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException("BlobStorageService cannot be null"); <START> } <END> this.blobStorageService = blobStorageService; logger.trace("BlobStorage service set to {}", blobStorageService.getClass()); }

sample: 161
buggy_code: public void dispose() { app.getChildren().remove(windowModel); coolBarManager.dispose(); menuManager.dispose(); statusLineManager.dispose(); <START> windowModel.setToBeRendered(false); <END> windowModel.getContext().deactivate(); windowModel.getContext().dispose(); ((Shell) windowModel.getWidget()).dispose(); }
code_review: I don't think this hurts but line 96 already sets this window.tbr to false and I have not seen that this property has changed.
target code: public void dispose ( ) { app . getChildren ( ) . remove ( windowModel ) ; coolBarManager . dispose ( ) ; menuManager . dispose ( ) ; statusLineManager . dispose ( ) ; windowModel . getContext ( ) . deactivate ( ) ; windowModel . getContext ( ) . dispose ( ) ; ( ( Shell ) windowModel . getWidget ( ) ) . dispose ( ) ; }
response: public void dispose() { app.getChildren().remove(windowModel); coolBarManager.dispose(); menuManager.dispose(); statusLineManager.dispose(); <START> windowModel.getContext().deactivate(); <END> windowModel.getContext().dispose(); ((Shell) windowModel.getWidget()).dispose(); }

sample: 162
buggy_code: public void setUp() { n = new CacheManagerNotifierImpl(); cl = new CacheManagerListener(); <START> TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor())); <END> n.start(); n.addListener(cl); }
code_review: The executor shouldn't be needed here either
target code: public void setUp ( ) { n = new CacheManagerNotifierImpl ( ) ; cl = new CacheManagerListener ( ) ; n . start ( ) ; n . addListener ( cl ) ; }
response: public void setUp() { n = new CacheManagerNotifierImpl(); cl = new CacheManagerListener(); <START> TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor())); <END> n.start(); n.addListener(cl); }

sample: 163
buggy_code: public char getLabel() { <START> char rv; <END> switch (getType()) { case INPUT_VAL: rv = buttonData.inputVal; break; case AUTO_CHAR: rv = buttonData.autoChar; break; case CUSTOM: rv = buttonData.customChar; break; default: rv='*'; // Should never happen. } return rv; }
code_review: Should be `final char rv;`.
target code: public char getLabel ( ) { final char rv ; switch ( getType ( ) ) { case INPUT_VAL : rv = buttonData . inputVal ; break ; case AUTO_CHAR : rv = buttonData . autoChar ; break ; case CUSTOM : rv = buttonData . customChar ; break ; default : rv = ' * ' ; // Should never happen . } return rv ; }
response: public char getLabel() { <START> final char rv; <END> switch (getType()) { case INPUT_VAL: rv = buttonData.inputVal; break; case AUTO_CHAR: rv = buttonData.autoChar; break; case CUSTOM: rv = buttonData.customChar; break; default: rv='*'; // Should never happen. } return rv; }

sample: 164
buggy_code: public ReleasableBytesReference retainedSlice(int from, int length) { BytesReference slice = delegate.slice(from, length); <START> refCounted.incRef(); <END> return new ReleasableBytesReference(slice, refCounted); }
code_review: I would prefer to move this call to the private `ReleasableBytesReference` constructor.
target code: public ReleasableBytesReference retainedSlice ( int from , int length ) { return new ReleasableBytesReference ( delegate . slice ( from , length ) , refCounted ) ; }
response: public ReleasableBytesReference retainedSlice(int from, int length) { BytesReference slice = delegate.slice(from, length); return new ReleasableBytesReference(slice, refCounted); }

sample: 165
buggy_code: public static <T> Iterable<T> latest(final Observable<? extends T> source) { return new Iterable<T>() { @Override public Iterator<T> iterator() { LatestObserverIterator<T> lio = new LatestObserverIterator<T>(); <START> lio.subscription = source.materialize().subscribe(lio); <END> return lio; } }; }
code_review: This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value `lio` essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call `this.unsubscribe()` on L101.
target code: public static < T > Iterable < T > latest ( final Observable < ? extends T > source ) { return new Iterable < T > ( ) { @Override public Iterator < T > iterator ( ) { LatestObserverIterator < T > lio = new LatestObserverIterator < T > ( ) ; source . materialize ( ) . subscribe ( lio ) ; return lio ; } } ; }
response: public static <T> Iterable<T> latest(final Observable<? extends T> source) { return new Iterable<T>() { @Override public Iterator<T> iterator() { LatestObserverIterator<T> lio = new LatestObserverIterator<T>(); <START> source.materialize().subscribe(lio); <END> return lio; } }; }

sample: 166
buggy_code: public static MessageType fromId(String id) { for(MessageType current : values()) { if(current.getId().equals(id)) { return current; } } <START> return UNKNOWN; <END> }
code_review: Discussion: does it make sense to return an enum entry here that I guess only exists for this method? Other alternatives could be to return `null` here, or an Optional
target code: public static Optional < MessageType > fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return Optional . of ( current ) ; } } return Optional . empty ( ) ; }
response: public static MessageType fromId(String id) { for(MessageType current : values()) { if(current.getId().equals(id)) { return current; } } <START> return null; <END> }

sample: 167
buggy_code: private boolean isHostNetworkUnreacable(VDS vds) { VdsDynamic vdsDynamic = vds.getDynamicData(); return ((vdsDynamic.getStatus() == VDSStatus.Down) || (vdsDynamic.getStatus() == VDSStatus.Reboot) || (vdsDynamic.getStatus() == VDSStatus.NonOperational <START> && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE)); <END> }
code_review: Please remove unnecessary brackets: return vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE); Even remaining brackets are not necessary, but they makes code more readable
target code: private boolean isHostNetworkUnreacable ( VDS vds ) { VdsDynamic vdsDynamic = vds . getDynamicData ( ) ; return ( vdsDynamic . getStatus ( ) == VDSStatus . Down || vdsDynamic . getStatus ( ) == VDSStatus . Reboot || ( vdsDynamic . getStatus ( ) == VDSStatus . NonOperational && vdsDynamic . getNonOperationalReason ( ) == NonOperationalReason . NETWORK_UNREACHABLE ) ) ; }
response: private boolean isHostNetworkUnreacable(VDS vds) { VdsDynamic vdsDynamic = vds.getDynamicData(); return (vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational <START> && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE)); <END> }

sample: 168
buggy_code: <START> ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) { <END> this.scriptMessageProcessor = scriptMessageProcessor; }
code_review: Having the Java Config style, it'd better to make this class `public`.
target code: public ScriptExecutingMessageSource ( AbstractScriptExecutingMessageProcessor < ? > scriptMessageProcessor ) { this . scriptMessageProcessor = scriptMessageProcessor ; }
response: <START> public ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) { <END> this.scriptMessageProcessor = scriptMessageProcessor; }

sample: 169
buggy_code: public void typeInSearchField(String content, int length) { waitForElementVisibleByElement(searchInput); <START> searchInput.sendKeys(content.substring(0, length)); <END> PageObjectLogging.log( "typeInSearchField", "String >>" + content.substring(0, length) + "<< was typed in string field", true ); }
code_review: How come there needs to be a substring for this?
target code: public void typeInSearchField ( String content , int length ) { waitForElementVisibleByElement ( searchInput ) ; searchInput . sendKeys ( content . substring ( 0 , 3 ) ) ; PageObjectLogging . log ( "typeInSearchField" , "String > > " + content . substring ( 0 , length ) + " < < was typed in string field" , true ) ; }
response: public void typeInSearchField(String content, int length) { waitForElementVisibleByElement(searchInput); <START> searchInput.sendKeys(content); <END> PageObjectLogging.log( "typeInSearchField", "String >>" + content.substring(0, length) + "<< was typed in string field", true ); }

sample: 170
buggy_code: public Iterable<E> read(Configuration configuration) throws IOException { // TODO: what to do with Configuration? create new view? DatasetReader<E> reader = view.newReader(); <START> return reader; // TODO: who calls close? <END> }
code_review: Inline.
target code: public Iterable < E > read ( Configuration configuration ) throws IOException { // TODO : what to do with Configuration ? create new view ? return view . newReader ( ) ; // TODO : who calls close ? }
response: public Iterable<E> read(Configuration configuration) throws IOException { // TODO: what to do with Configuration? create new view? <START> return view.newReader(); // TODO: who calls close? <END> }

sample: 171
buggy_code: public void setRefreshInterval(final long refreshInterval) { <START> REFRESH_INTERVAL_IN_SECONDS = refreshInterval; <END> }
code_review: if it is not constant, please convert to lower case?
target code: public void setRefreshInterval ( final long refreshInterval ) { this . refreshInterval = refreshInterval ; }
response: public void setRefreshInterval(final long refreshInterval) { <START> refreshIntervalInSeconds = refreshInterval; <END> }

sample: 172
buggy_code: public void onNewImageFromCamera() { <START> if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) { <END> navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA); } else { interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null); } }
code_review: These copy-paste sections are starting to clutter up the presenter. Please try to extract a common denominator (e.g. a function) to reduce repeating code snippets.
target code: public void onNewImageFromCamera ( ) { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; }
response: public void onNewImageFromCamera() { <START> if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) { <END> navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA); } else { interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null); } }

sample: 173
buggy_code: public void testEquals() throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, "UTF8", <START> 10, true, false, true); <END> FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, "UTF8", 10, true, false, true); assertEquals(conf1, conf2); FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, "UTF8", 10, false, false, true); assertFalse(conf1.equals(conf3)); }
code_review: Please make sure there are overloaded constructors available for the old constructor signature. Then you also wont have to change this existing test.
target code: public void testEquals ( ) throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true ) ; FixedWidthConfiguration conf2 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true ) ; assertEquals ( conf1 , conf2 ) ; FixedWidthConfiguration conf3 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , false ) ; assertFalse ( conf1 . equals ( conf3 ) ) ; }
response: public void testEquals() throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, "UTF8", <START> 10, true, false, true); <END> FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, "UTF8", 10, true, false, true); assertEquals(conf1, conf2); FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, "UTF8", 10, false, false, true); assertFalse(conf1.equals(conf3)); }

sample: 174
buggy_code: public void showLinkPreview(PageTitle title, int entrySource) { final String linkPreviewFragmentTag = "link_preview_dialog"; if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) { <START> linkPreview = LinkPreviewDialog.newInstance(title, entrySource); <END> linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag); } }
code_review: You actually don't need a private variable for storing the link preview. If you look at the line directly above, the findFragmentByTag() function finds the dialog by its tag name (also specified above). You can cast the return value of this function into a LinkPreviewDialog, and call dismiss() on it.
target code: public void showLinkPreview ( PageTitle title , int entrySource ) { final String linkPreviewFragmentTag = "link_preview_dialog" ; if ( getSupportFragmentManager ( ) . findFragmentByTag ( linkPreviewFragmentTag ) == null ) { LinkPreviewDialog linkPreview = LinkPreviewDialog . newInstance ( title , entrySource ) ; linkPreview . show ( getSupportFragmentManager ( ) , linkPreviewFragmentTag ) ; } }
response: public void showLinkPreview(PageTitle title, int entrySource) { final String linkPreviewFragmentTag = "link_preview_dialog"; if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) { <START> LinkPreviewDialog.newInstance(title, entrySource).show(getSupportFragmentManager(), linkPreviewFragmentTag); <END> } }

sample: 175
buggy_code: public void clear() { <START> if (loader instanceof CacheStore) <END> try { ((CacheStore) loader).clear(); } catch (CacheLoaderException e) { throw newCacheLoaderException(e); } }
code_review: IMO, if you use `if (...) { ... }`, it makes the code easy to read. I meant the `{` and `}` are missing :) edit: the same for the following `if`s
target code: public void clear ( ) { if ( loader instanceof CacheStore ) { try { ( ( CacheStore ) loader ) . clear ( ) ; } catch ( CacheLoaderException e ) { throw newCacheLoaderException ( e ) ; } } }
response: public void clear() { <START> if (loader instanceof CacheStore) { <END> try { ((CacheStore) loader).clear(); } catch (CacheLoaderException e) { throw newCacheLoaderException(e); } } }

sample: 176
buggy_code: public ApplicabilityIds getApplicabilityIds() { // TBD - Replace with call to IApplicabilityService calls once implemented <START> ApplicabilityIds ids = new ApplicabilityIds(); <END> // ids.getApplicabilityIds().add(new ApplicabilityId(345L, "ARC-210")); // ids.getApplicabilityIds().add(new ApplicabilityId(366L, "COMM")); // ids.getApplicabilityIds().add(new ApplicabilityId(376L, "ASM")); // ids.getApplicabilityIds().add(new ApplicabilityId(368L, "UTF")); // ids.getApplicabilityIds().add(new ApplicabilityId(466L, "MDR")); return ids; }
code_review: This file needs some work to ensure it works with client.
target code: public ApplicabilityIds getApplicabilityIds ( ) { return null ; }
response: public ApplicabilityIds getApplicabilityIds() { // TBD - Replace with call to IApplicabilityService calls once implemented <START> ApplicabilityIds ids = new ApplicabilityIds(); <END> // ids.getApplicabilityIds().add(new ApplicabilityId(345L, "ARC-210")); // ids.getApplicabilityIds().add(new ApplicabilityId(366L, "COMM")); // ids.getApplicabilityIds().add(new ApplicabilityId(376L, "ASM")); // ids.getApplicabilityIds().add(new ApplicabilityId(368L, "UTF")); // ids.getApplicabilityIds().add(new ApplicabilityId(466L, "MDR")); return ids; } // Review: This file needs some work to ensure it works with client.

sample: 177
buggy_code: <START> MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) { <END> if (!negotiated.matchesAll()) return negotiated; MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType(); if (storageMediaType == null) return negotiated; if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN; if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON; return negotiated; }
code_review: private?
target code: private MediaType tryNarrowMediaType ( MediaType negotiated , AdvancedCache < ? , ? > cache ) { if ( ! negotiated . matchesAll ( ) ) return negotiated ; MediaType storageMediaType = cache . getValueDataConversion ( ) . getStorageMediaType ( ) ; if ( storageMediaType == null ) return negotiated ; if ( storageMediaType . equals ( MediaType . APPLICATION_OBJECT ) ) return TEXT_PLAIN ; if ( storageMediaType . match ( MediaType . APPLICATION_PROTOSTREAM ) ) return APPLICATION_JSON ; return negotiated ; }
response: <START> private MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) { <END> if (!negotiated.matchesAll()) return negotiated; MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType(); if (storageMediaType == null) return negotiated; if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN; if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON; return negotiated; }

sample: 178
buggy_code: protected void addJAROption(Composite comp) { fJarButton = new Button(comp, SWT.CHECK); fJarButton.setText(getJarButtonText()); <START> fJarButton.addSelectionListener(widgetSelectedAdapter(e -> { <END> })); }
code_review: This does not do anything. Can be removed
target code: protected void addJAROption ( Composite comp ) { fJarButton = new Button ( comp , SWT . CHECK ) ; fJarButton . setText ( getJarButtonText ( ) ) ; }
response: protected void addJAROption(Composite comp) { fJarButton = new Button(comp, SWT.CHECK); fJarButton.setText(getJarButtonText()); <START> fJarButton.addSelectionListener(widgetSelectedAdapter(e -> { })); <END> }

sample: 179
buggy_code: public String getTurnDescription( Translation tr ) { <START> if (rawName || !name.isEmpty()) <END> return getName(); return tr.tr("finish"); }
code_review: The additional check is not used in other instructions, is it needed?
target code: public String getTurnDescription ( Translation tr ) { if ( rawName ) return getName ( ) ; return tr . tr ( "finish" ) ; }
response: public String getTurnDescription( Translation tr ) { <START> if (rawName || !name.isEmpty()) <END> return getName(); return tr.tr("finish"); }

sample: 180
buggy_code: private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions(); presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton()); try { createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true); } catch (Exception e) { <START> throw e; <END> } }
code_review: Catch?
target code: private void fetchPresenterWidgetTemplate ( PresenterOptions presenterOptions ) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions ( ) ; presenterWidgetOptions . setSingleton ( presenterConfigModel . isUseSingleton ( ) ) ; createdPresenterWidgetTemplates = CreatePresenterWidget . run ( presenterOptions , presenterWidgetOptions , true ) ; }
response: private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions(); presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton()); try { createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true); } catch (Exception e) { <START> throw e; <END> } }

sample: 181
buggy_code: public String toString() { StringWriter writer = new StringWriter(); try { new ObjectMapper().writeValue(writer, graph); } catch (Exception e) { log.debug ("Error while constructing new ObjectMapper",e); <START> } <END> return writer.toString(); }
code_review: Make this as a log.error statement. And needs to have space after the ","
target code: public String toString ( ) { StringWriter writer = new StringWriter ( ) ; try { new ObjectMapper ( ) . writeValue ( writer , graph ) ; } catch ( Exception e ) { log . error ( "Error while constructing new ObjectMapper" , e ) ; } return writer . toString ( ) ; }
response: public String toString() { StringWriter writer = new StringWriter(); try { new ObjectMapper().writeValue(writer, graph); } catch (Exception e) { log.error("Error while constructing new ObjectMapper", e); <START> } <END> return writer.toString(); }

sample: 182
buggy_code: public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) { //TODO: check non-null this.topic = topic; this.connector = task.connector(); this.task = task.task(); <START> this.discoverTimestamp = discoverTimestamp; <END> }
code_review: How about replacing these four lines with: ``` this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp); ``` and then removing the TODO line?
target code: public TopicStatus ( String topic , ConnectorTaskId task , long discoverTimestamp ) { this ( topic , task . connector ( ) , task . task ( ) , discoverTimestamp ) ; }
response: public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) { this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp); }

sample: 183
buggy_code: private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length) { switch (type) { case POINT: return readPoint(input); case MULTI_POINT: case LINE_STRING: case MULTI_LINE_STRING: case POLYGON: case MULTI_POLYGON: return readSimpleGeometry(input, inputSlice, type, length); case GEOMETRY_COLLECTION: return readGeometryCollection(input, inputSlice); case ENVELOPE: <START> return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null); <END> default: throw new IllegalArgumentException("Unexpected type: " + type); } }
code_review: Just add an envelope section to `createFromEsriGeometry` method in this file
target code: private static OGCGeometry readGeometry ( BasicSliceInput input , Slice inputSlice , GeometryType type , int length ) { switch ( type ) { case POINT : return readPoint ( input ) ; case MULTI_POINT : case LINE_STRING : case MULTI_LINE_STRING : case POLYGON : case MULTI_POLYGON : return readSimpleGeometry ( input , inputSlice , type , length ) ; case GEOMETRY_COLLECTION : return readGeometryCollection ( input , inputSlice ) ; case ENVELOPE : return createFromEsriGeometry ( readEnvelope ( input ) , false ) ; default : throw new IllegalArgumentException ( "Unexpected type : " + type ) ; } }
response: private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length) { switch (type) { case POINT: return readPoint(input); case MULTI_POINT: case LINE_STRING: case MULTI_LINE_STRING: case POLYGON: case MULTI_POLYGON: return readSimpleGeometry(input, inputSlice, type, length); case GEOMETRY_COLLECTION: return readGeometryCollection(input, inputSlice); case ENVELOPE: <START> return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null); <END> default: throw new IllegalArgumentException("Unexpected type: " + type); } }

sample: 184
buggy_code: public void close() { <START> sketch = null; <END> }
code_review: Could set `null` to the `values` field too
target code: public void close ( ) { sketch = null ; values = null ; }
response: public void close() { <START> sketch = null; values = null; <END> }

sample: 185
buggy_code: public boolean shouldSpill() { // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV) long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch; long reserveForOutgoing = batchMemoryManager.getOutputBatchSize(); <START> long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing; <END> boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow; if ( needsSpill ) { logger.debug("should spill now - batch size {}, mem avail {}, reserved for outgoing {}", batchSize, memoryAvailableNow, reserveForOutgoing); } return needsSpill; // go spill if too little memory is available }
code_review: We still need to account for the probe batch size here when we are processing a spilled partition. If we try to account for it in he PostBuildCalculator it will already be too late, because we will have already prefetched the probe side batch.
target code: public boolean shouldSpill ( ) { // Expected new batch size like the current , plus the Hash Values vector ( 4 bytes per HV ) long batchSize = ( batchMemoryManager . getRecordBatchSizer ( RIGHT_INDEX ) . getRowAllocWidth ( ) + 4 ) * recordsPerBatch ; long reserveForOutgoing = batchMemoryManager . getOutputBatchSize ( ) ; long memoryAvailableNow = allocator . getLimit ( ) - allocator . getAllocatedMemory ( ) ; boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow - reserveForOutgoing ; if ( needsSpill ) { logger . debug ( "should spill now - batch size { } , mem avail { } , reserved for outgoing { } " , batchSize , memoryAvailableNow , reserveForOutgoing ) ; } return needsSpill ; // go spill if too little memory is available }
response: public boolean shouldSpill() { // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV) long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch; long reserveForOutgoing = batchMemoryManager.getOutputBatchSize(); <START> long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing - batchMemoryManager.getRecordBatchSizer(LEFT_INDEX).getRowAllocWidth() * recordsPerBatch; <END> boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow; if ( needsSpill ) { logger.debug("should spill now - batch size {}, mem avail {}, reserved for outgoing {}", batchSize, memoryAvailableNow, reserveForOutgoing); } return needsSpill; // go spill if too little memory is available }

sample: 186
buggy_code: public void close() { try { Await.result(beam.close()); } catch (Exception e) { final String errorMsg = "Error while closing Druid beam client"; LOG.error(errorMsg, e); <START> throw new RuntimeException(errorMsg); <END> } }
code_review: same as above. we shouldn't be throwing run-time exceptions when close is called.
target code: public void close ( ) { try { Await . result ( beam . close ( ) ) ; } catch ( Exception e ) { LOG . error ( "Error while closing Druid beam client" , e ) ; } }
response: public void close() { try { Await.result(beam.close()); } catch (Exception e) { final String errorMsg = "Error while closing Druid beam client"; LOG.error(errorMsg, e); <START> throw new RuntimeException(errorMsg); <END> } }

sample: 187
buggy_code: private boolean isPlatformKeybindingBug517068Fixed() { Bundle bundle = Platform.getBundle("org.eclipse.e4.ui.bindings"); //$NON-NLS-1$ Version currentVersion = bundle.getVersion(); <START> Version fixVersion = new Version(0, 12, 100); <END> return currentVersion.compareTo(fixVersion) >= 0; }
code_review: Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
target code: private boolean isPlatformKeybindingBug517068Fixed ( ) { Bundle bundle = Platform . getBundle ( "org . eclipse . e4 . ui . bindings" ) ; // $NON - NLS - 1$ Version currentVersion = bundle . getVersion ( ) ; Version fixVersion = new Version ( 0 , 12 , 1 ) ; return currentVersion . compareTo ( fixVersion ) >= 0 ; }
response: private boolean isPlatformKeybindingBug517068Fixed() { Bundle bundle = Platform.getBundle("org.eclipse.e4.ui.bindings"); //$NON-NLS-1$ Version currentVersion = bundle.getVersion(); <START> Version fixVersion = new Version(0, 12, 1); <END> return currentVersion.compareTo(fixVersion) >= 0; }

sample: 188
buggy_code: public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 ) { <START> if ( StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) <END> && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ) ) { return true; } return false; }
code_review: Why not just: return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) && StringUtils.equals( p1.getPrefix(), p2.getPrefix() );
target code: public static boolean isPluginPrefixAndArtifactIdEquals ( Plugin p1 , Plugin p2 ) { return StringUtils . equals ( p1 . getArtifactId ( ) , p2 . getArtifactId ( ) ) && StringUtils . equals ( p1 . getPrefix ( ) , p2 . getPrefix ( ) ) ; }
response: public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 ) { <START> return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) <END> && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ); }

sample: 189
buggy_code: public <VT> MessageOut<T> withParameter(ParameterType type, VT value) { <START> List<Object> newParameters = new ArrayList<>(parameters.size() + 3); <END> newParameters.addAll(parameters); newParameters.add(type); newParameters.add(value); return new MessageOut<T>(verb, payload, serializer, newParameters); }
code_review: I think tuple size used to be 3. I'll fix it.
target code: public < VT > MessageOut < T > withParameter ( ParameterType type , VT value ) { List < Object > newParameters = new ArrayList < > ( parameters . size ( ) + 2 ) ; newParameters . addAll ( parameters ) ; newParameters . add ( type ) ; newParameters . add ( value ) ; return new MessageOut < T > ( verb , payload , serializer , newParameters ) ; }
response: public <VT> MessageOut<T> withParameter(ParameterType type, VT value) { <START> List<Object> newParameters = new ArrayList<>(parameters.size() + 2); <END> newParameters.addAll(parameters); newParameters.add(type); newParameters.add(value); return new MessageOut<T>(verb, payload, serializer, newParameters); }

sample: 190
buggy_code: private boolean validateTimeRange() { boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty(); return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) <= 0; <START> } <END>
code_review: should this be < 0? do we want to import a 0 nanosecond range?
target code: private boolean validateTimeRange ( ) { boolean isEmpty = fStartTimeRangeText . getText ( ) . isEmpty ( ) || fEndTimeRangeText . getText ( ) . isEmpty ( ) ; return ! isEmpty && parseTimeRange ( ) && fStartTimestamp . compareTo ( fEndTimestamp ) < 0 ; }
response: private boolean validateTimeRange() { boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty(); return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) < 0; <START> } <END>

sample: 191
buggy_code: public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) { String filenamePath = ""; StringBuilder filenameBuilder = new StringBuilder(); filenameBuilder.append(fieldbookProperties.getUploadDirectory()); filenameBuilder.append(File.separator); filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename)); <START> filenamePath = filenameBuilder.toString(); <END> return filenamePath; }
code_review: Move filenamePath declaration to this line and make it final
target code: public static String getFileNamePath ( final String filename , final FieldbookProperties fieldbookProperties ) { final StringBuilder filenameBuilder = new StringBuilder ( ) ; filenameBuilder . append ( fieldbookProperties . getUploadDirectory ( ) ) ; filenameBuilder . append ( File . separator ) ; filenameBuilder . append ( SettingsUtil . cleanSheetAndFileName ( filename ) ) ; final String filenamePath = filenameBuilder . toString ( ) ; return filenamePath ; }
response: public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) { StringBuilder filenameBuilder = new StringBuilder(); filenameBuilder.append(fieldbookProperties.getUploadDirectory()); filenameBuilder.append(File.separator); filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename)); <START> final String filenamePath = filenameBuilder.toString(); <END> return filenamePath; }

sample: 192
buggy_code: protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) { executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() { @SuppressWarnings("synthetic-access") @Override public StoragePoolIsoMap runInTransaction() { <START> CompensationContext context = getCompensationContext(); <END> context.snapshotEntityStatus(map, map.getstatus()); map.setstatus(status); getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus()); getCompensationContext().stateChanged(); return null; } }); }
code_review: this line can be removed
target code: protected void changeStorageDomainStatusInTransaction ( final StoragePoolIsoMap map , final StorageDomainStatus status ) { executeInNewTransaction ( new TransactionMethod < StoragePoolIsoMap > ( ) { @Override public StoragePoolIsoMap runInTransaction ( ) { CompensationContext context = getCompensationContext ( ) ; context . snapshotEntityStatus ( map , map . getstatus ( ) ) ; updateStatus ( map , status ) ; getCompensationContext ( ) . stateChanged ( ) ; return null ; } } ) ; }
response: protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) { executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() { @SuppressWarnings("synthetic-access") @Override public StoragePoolIsoMap runInTransaction() { <START> CompensationContext context = getCompensationContext(); <END> context.snapshotEntityStatus(map, map.getstatus()); map.setstatus(status); getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus()); getCompensationContext().stateChanged(); return null; } }); }

sample: 193
buggy_code: public void visitMemberSelectExpression(MemberSelectExpressionTree tree) { if (tree.expression().is(Tree.Kind.IDENTIFIER)) { IdentifierTree identifier = (IdentifierTree) tree.expression(); <START> final Symbol owner = identifier.symbol().owner(); <END> if (owner != null && owner.isMethodSymbol()) { // No need to investigate selection on local symbols return; } } if (tree.expression().symbolType().isSubtypeOf("java.lang.Class")) { // No need to investigate selection on a Class object return; } super.visitMemberSelectExpression(tree); }
code_review: remove `final` modifier.
target code: public void visitMemberSelectExpression ( MemberSelectExpressionTree tree ) { if ( tree . expression ( ) . is ( Tree . Kind . IDENTIFIER ) ) { IdentifierTree identifier = ( IdentifierTree ) tree . expression ( ) ; Symbol owner = identifier . symbol ( ) . owner ( ) ; if ( owner != null && owner . isMethodSymbol ( ) ) { // No need to investigate selection on local symbols return ; } } if ( tree . expression ( ) . symbolType ( ) . isSubtypeOf ( "java . lang . Class" ) ) { // No need to investigate selection on a Class object return ; } super . visitMemberSelectExpression ( tree ) ; }
response: public void visitMemberSelectExpression(MemberSelectExpressionTree tree) { if (tree.expression().is(Tree.Kind.IDENTIFIER)) { IdentifierTree identifier = (IdentifierTree) tree.expression(); <START> Symbol owner = identifier.symbol().owner(); <END> if (owner != null && owner.isMethodSymbol()) { // No need to investigate selection on local symbols return; } } if (tree.expression().symbolType().isSubtypeOf("java.lang.Class")) { // No need to investigate selection on a Class object return; } super.visitMemberSelectExpression(tree); }

sample: 194
buggy_code: public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED); checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED); <START> if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { <END> BiFunctionExecutingEntryProcessor<K, V> ep = new BiFunctionExecutingEntryProcessor<>(remappingFunction); return executeOnKeyInternal(key, ep); } else { return computeIfPresentLocally(key, remappingFunction); } }
code_review: Hi, @mmedenjak is right we need a fallback mechanism when server is not available. Having a fallback mechanism have greater scope. Lets make the `computeIfPresentLocally` only implementation for now for the client. The optimisation for the client can be addressed later.
target code: public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) { checkNotNull ( key , NULL_KEY_IS_NOT_ALLOWED ) ; checkNotNull ( key , NULL_BIFUNCTION_IS_NOT_ALLOWED ) ; return computeIfPresentLocally ( key , remappingFunction ) ; }
response: public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED); checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED); <START> return computeIfPresentLocally(key, remappingFunction); <END> }

sample: 195
buggy_code: public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) { Tuple tuple = task.getTuple(stream, values); List<Integer> tasks = task.getOutgoingTasks(stream, values); <START> if (tasks.size() == 0) { <END> return; } for (Integer t : tasks) { transfer.transfer(t, tuple); } }
code_review: we don't need this check right. For loop won't enter if tasks are empty. We should avoid having multiple returns.
target code: public void sendUnanchored ( Task task , String stream , List < Object > values , ExecutorTransfer transfer ) { Tuple tuple = task . getTuple ( stream , values ) ; List < Integer > tasks = task . getOutgoingTasks ( stream , values ) ; for ( Integer t : tasks ) { transfer . transfer ( t , tuple ) ; } }
response: public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) { Tuple tuple = task.getTuple(stream, values); List<Integer> tasks = task.getOutgoingTasks(stream, values); for (Integer t : tasks) { transfer.transfer(t, tuple); } }

sample: 196
buggy_code: AffinityResourceDefinition(PathElement path) { <START> super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new ReloadRequiredAddStepHandler(), new ReloadRequiredRemoveStepHandler()); <END> }
code_review: Unless I'm mistaken, you don't need to reload the whole server, just restart the services of the parent resource. You can leverage RestartParentResourceRegistration for this.
target code: AffinityResourceDefinition ( PathElement path ) { super ( path , UndertowExtension . getResolver ( Constants . HANDLER , Constants . AFFINITY , path . getValue ( ) ) ) ; }
response: AffinityResourceDefinition(PathElement path) { <START> super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new RestartParentResourceAddHandler(Constants.HANDLER), new RestartParentResourceRemoveHandler(Constants.HANDLER)); <END> }

sample: 197
buggy_code: @Override public E poll() { lock.lock(); try { if (queue.isEmpty()) { return null; } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> return null; <END> } finally { lock.unlock(); } }
code_review: throws
target code: @Override public E poll ( ) { lock . lock ( ) ; try { if ( queue . isEmpty ( ) ) { return null ; } E peek = queue . peek ( ) ; queue . remove ( ) ; return peek ; } catch ( IOException e ) { throw QueueFile . < Error > getSneakyThrowable ( e ) ; } finally { lock . unlock ( ) ; } }
response: @Override public E poll() { lock.lock(); try { if (queue.isEmpty()) { return null; } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> throw new RuntimeException(e); <END> } finally { lock.unlock(); } }

sample: 198
buggy_code: public void testTimeout() throws SystemException, RemoteException { <START> log.info("Method stateful #testTimeout called"); <END> Transaction txn; txn = tm.getTransaction(); TxTestUtil.enlistTestXAResource(txn); TxTestUtil.enlistTestXAResource(txn); try { TxTestUtil.waitForTimeout(tm); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RemoteException("Interupted during waiting for transaction timeout", ie); } }
code_review: log.tracef
target code: public void testTimeout ( ) throws SystemException , RemoteException { log . trace ( "Method stateful #testTimeout called" ) ; Transaction txn ; txn = tm . getTransaction ( ) ; TxTestUtil . enlistTestXAResource ( txn ) ; TxTestUtil . enlistTestXAResource ( txn ) ; try { TxTestUtil . waitForTimeout ( tm ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RemoteException ( "Interupted during waiting for transaction timeout" , ie ) ; } }
response: public void testTimeout() throws SystemException, RemoteException { <START> log.tracef("Method stateful #testTimeout called"); <END> Transaction txn; txn = tm.getTransaction(); TxTestUtil.enlistTestXAResource(txn); TxTestUtil.enlistTestXAResource(txn); try { TxTestUtil.waitForTimeout(tm); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RemoteException("Interupted during waiting for transaction timeout", ie); } }

sample: 199
buggy_code: <START> public UnstagedComparator(boolean sortAlphabetically) { <END> this.alphabeticallySort = sortAlphabetically; }
code_review: doesn't need to be public
target code: private UnstagedComparator ( boolean sortAlphabetically ) { this . alphabeticallySort = sortAlphabetically ; }
response: <START> UnstagedComparator(boolean sortAlphabetically) { <END> this.alphabeticallySort = sortAlphabetically; }

sample: 200
buggy_code: public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) { StorageType storageType = diskImage.getStorageTypes().get(0); String diskType = getDiskType(vm, diskImage, device); boolean isNativeIO = !"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion())); // marked as transient disk (file type) and uses cache when snapshotId is not null if <START> (device.getSnapshotId() != null) { <END> isNativeIO = false; } return isNativeIO; }
code_review: So why not just add it to the boolean expression in line #1377?
target code: public boolean shouldUseNativeIO ( VM vm , DiskImage diskImage , VmDevice device ) { StorageType storageType = diskImage . getStorageTypes ( ) . get ( 0 ) ; String diskType = getDiskType ( vm , diskImage , device ) ; return ( ! "file" . equals ( diskType ) || ( storageType == StorageType . GLUSTERFS && FeatureSupported . useNativeIOForGluster ( vm . getCompatibilityVersion ( ) ) ) ) && device . getSnapshotId ( ) == null ; // marked as transient disk ( file type ) and uses cache when snapshotId is not null // so native io should not be used }
response: public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) { StorageType storageType = diskImage.getStorageTypes().get(0); String diskType = getDiskType(vm, diskImage, device); boolean isNativeIO = !"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion())); // marked as transient disk (file type) and uses cache when snapshotId is not null if <START> (device.getSnapshotId() != null) { <END> isNativeIO = false; } return isNativeIO; }

sample: 201
buggy_code: public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException { if (!isAnonymous()) { return execute(request, true, monitor); } <START> return execute(request, false, monitor); <END> }
code_review: Lines 316-319 can be rewritten as return execute(request, !isAnonymous(), monitor);
target code: public < T > T execute ( Request < T > request , IProgressMonitor monitor ) throws IOException , GerritException { return execute ( request , ! isAnonymous ( ) , monitor ) ; }
response: public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException { if (!isAnonymous()) { return execute(request, true, monitor); } return execute(request, !isAnonymous(), monitor); }

sample: 202
buggy_code: public HighlightingInlineHyperlink(final String text, final String token, final String toHighlight) { super(text, token); <START> highlight(text, toHighlight); <END> }
code_review: Maybe highlight should be called from setText instead? That way, if the text is changed after construction it will get highlighted too.
target code: public HighlightingInlineHyperlink ( final String text , final String token , final String toHighlight ) { super ( text , token ) ; this . toHighlight = toHighlight ; highlight ( text , toHighlight ) ; }
response: public HighlightingInlineHyperlink(final String text, final String token, final String toHighlight) { super(text, token); highlight(text, toHighlight); }

sample: 203
buggy_code: <START> String serializeInstallCmd(Collection<String> packages) { <END> if (packages.isEmpty()) { return ""; } else { return CommandInfo.CMD_INSTALL + " " + String.join(" ", packages); } }
code_review: Not sure if this is guideline, I would prefer to use `protected` visibility rather than package protected one.
target code: protected String serializeInstallCmd ( Collection < String > packages ) { if ( packages . isEmpty ( ) ) { return "" ; } else { return CommandInfo . CMD_INSTALL + " " + String . join ( " " , packages ) ; } }
response: <START> protected String serializeInstallCmd(Collection<String> packages) { <END> if (packages.isEmpty()) { return ""; } else { return CommandInfo.CMD_INSTALL + " " + String.join(" ", packages); } }

sample: 204
buggy_code: private List roundtrip(List vals, Map conf) { List ret = null; try { ret = deserialize(serialize(vals, conf), conf); <START> } catch (IOException e) { <END> LOG.error("Exception when serialize/deserialize ", e); } return ret; }
code_review: I would prefer to have the IOException thrown by roundtrip. Catching it will still cause the test to fail, but it will be harder to debug.
target code: private List roundtrip ( List vals , Map conf ) throws IOException { return deserialize ( serialize ( vals , conf ) , conf ) ; }
response: private List roundtrip(List vals, Map conf) throws IOException { List ret = null; try { ret = deserialize(serialize(vals, conf), conf); <START> } catch (IOException e) { <END> LOG.error("Exception when serialize/deserialize ", e); } return ret; }

sample: 205
buggy_code: public GlobalDirectoryResourceDefinition() { super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY)) <START> .setAddRestartLevel(OperationEntry.Flag.RE<START>_JVM) <END> .setRemoveRestartLevel(OperationEntry.Flag.RE<START>_JVM) .setAddHandler(GlobalDirectoryResourceDefinition.ADD) .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE) .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY) ); }
code_review: Why RESTART_JVM? AFAICT if I add this after boot the service is installed immediately. You'd have to redeploy any app for it to use the module, but that doesn't even require a reload much less a process restart.
target code: public GlobalDirectoryResourceDefinition ( ) { super ( new SimpleResourceDefinition . Parameters ( PathElement . pathElement ( EESubsystemModel . GLOBAL_DIRECTORY ) , EeExtension . getResourceDescriptionResolver ( EESubsystemModel . GLOBAL_DIRECTORY ) ) . setAddHandler ( GlobalDirectoryResourceDefinition . ADD ) . setRemoveHandler ( GlobalDirectoryResourceDefinition . REMOVE ) . setCapabilities ( EE_GLOBAL_DIRECTORY_CAPABILITY ) ) ; }
response: public GlobalDirectoryResourceDefinition() { super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY)) <START> .setAddRestartLevel(OperationEntry.Flag.RESTART_JVM) <END> .setRemoveRestartLevel(OperationEntry.Flag.RESTART_JVM) .setAddHandler(GlobalDirectoryResourceDefinition.ADD) .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE) .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY) ); }

sample: 206
buggy_code: public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); <START> this.fChartViewer <END> = chartViewer; }
code_review: You can remove the this
target code: public LockRangeDialog ( Shell parentShell , TmfXYChartViewer chartViewer ) { super ( parentShell ) ; fChartViewer = chartViewer ; }
response: public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); <START> fChartViewer <END> = chartViewer; }

sample: 207
buggy_code: public String toStringShort() { <START> return MoreObjects.toStringHelper("") <END> .add("ClientType", getStringFromOptional(mClientType)) .add("ClientHostname", mLocalHostName) .add("ServerAddress", mServerAddress) .add("ChannelId", mChannelId) .omitNullValues() .toString(); }
code_review: I am confused when this is supposed to be "" or `this`?
target code: public String toStringShort ( ) { return MoreObjects . toStringHelper ( this ) . add ( "ClientType" , getStringFromOptional ( mClientType ) ) . add ( "ClientHostname" , mLocalHostName ) . add ( "ServerAddress" , mServerAddress ) . add ( "ChannelId" , mChannelId ) . omitNullValues ( ) . toString ( ) ; }
response: public String toStringShort() { <START> return MoreObjects.toStringHelper(this) <END> .add("ClientType", getStringFromOptional(mClientType)) .add("ClientHostname", mLocalHostName) .add("ServerAddress", mServerAddress) .add("ChannelId", mChannelId) .omitNullValues() .toString(); }

sample: 208
buggy_code: public CompilationUnit() { <START> this(null, false, null, new NodeList<>(), new NodeList<>(), null); <END> }
code_review: for the boolean parameter could be useful to use enums, so that it is more clear what it means
target code: public CompilationUnit ( ) { this ( null , null , new NodeList < > ( ) , new NodeList < > ( ) , null ) ; }
response: public CompilationUnit() { <START> this(null, false, null, new NodeList<>(), new NodeList<>(), null); <END> }

sample: 209
buggy_code: public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); <START> description = (String) command.getParam(PARAM_DESC); <END> }
code_review: cast is not needed.
target code: public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; description = command . getParam ( PARAM_DESC ) ; }
response: public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); <START> description = command.getParam(PARAM_DESC); <END> }

sample: 210
buggy_code: protected void executeQueryCommand() { <START> Provider provider = getDbFacade().getProviderDao().get(getParameters().getId()); <END> NetworkProviderProxy client = getProviderProxyFactory().create(provider); getQueryReturnValue().setReturnValue(client.getAll()); }
code_review: shouldn't provider be validated for existence prior to accessing it?
target code: protected void executeQueryCommand ( ) { Provider < ? > provider = getDbFacade ( ) . getProviderDao ( ) . get ( getParameters ( ) . getId ( ) ) ; NetworkProviderProxy client = getProviderProxyFactory ( ) . create ( provider ) ; getQueryReturnValue ( ) . setReturnValue ( client . getAll ( ) ) ; }
response: protected void executeQueryCommand() { <START> Provider provider = getDbFacade().getProviderDao().get(getParameters().getId()); if (provider == null) { throw new VdcBLLException(VdcBllErrors.PROVIDER_NOT_FOUND); } <END> NetworkProviderProxy client = getProviderProxyFactory().create(provider); getQueryReturnValue().setReturnValue(client.getAll()); }

sample: 211
buggy_code: public void testCrashlyticsUninitializedOnAnonymousReportDisabled() { Context context = InstrumentationRegistry.getTargetContext(); SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit(); editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false); <START> editor.clear(); <END> editor.commit(); CrashReporter crashReporter = new CrashReporter(context); assertFalse(crashReporter.initialize()); }
code_review: In some tests you're using `editor.clear()`, in some you don't. I guess it's better to use it in all tests. Assume that the tests are executed in a random order and should also start in a clean state. So using a [@Before method (setUp)](http://junit.sourceforge.net/javadoc/org/junit/Before.html) to clear the `SharedPreferences` seems like a good idea. Maybe create a static util method so others can benefit from it as well.
target code: public void testCrashlyticsUninitializedOnAnonymousReportDisabled ( ) { editor . putBoolean ( SettingsActivity . SETTINGS_CRASH_REPORTS , false ) ; editor . commit ( ) ; assertFalse ( CrashReporter . initialize ( context ) ) ; }
response: public void testCrashlyticsUninitializedOnAnonymousReportDisabled() { Context context = InstrumentationRegistry.getTargetContext(); SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit(); editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false); editor.commit(); CrashReporter crashReporter = new CrashReporter(context); assertFalse(crashReporter.initialize()); }

sample: 212
buggy_code: <START> protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { <END> if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages())) { return false; } else { return true; } }
code_review: it can be simplified to a single return statement protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages()); }
target code: protected boolean uniqueInterfaceName ( List < VmNetworkInterface > interfaces ) { return VmHandler . IsNotDuplicateInterfaceName ( interfaces , getInterfaceName ( ) , getReturnValue ( ) . getCanDoActionMessages ( ) ) ; }
response: protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages()); }

sample: 213
buggy_code: private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException { log.info("Start Discovery Service."); CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>(); this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath()); // Start LogReplicationDiscovery Service, responsible for // acquiring lock, retrieving Site Manager Info and processing this info // so this node is initialized as Source (sender) or Sink (receiver) replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext, <START> clusterManagerAdapter, discoveryServiceCallback);; <END> return discoveryServiceCallback; }
code_review: typo --> ;;
target code: private CompletableFuture < CorfuInterClusterReplicationServerNode > startDiscoveryService ( ServerContext serverContext ) { log . info ( "Start Discovery Service . " ) ; CompletableFuture < CorfuInterClusterReplicationServerNode > discoveryServiceCallback = new CompletableFuture < > ( ) ; this . clusterManagerAdapter = buildClusterManagerAdapter ( serverContext . getPluginConfigFilePath ( ) ) ; // Start LogReplicationDiscovery Service , responsible for // acquiring lock , retrieving Site Manager Info and processing this info // so this node is initialized as Source ( sender ) or Sink ( receiver ) replicationDiscoveryService = new CorfuReplicationDiscoveryService ( serverContext , clusterManagerAdapter , discoveryServiceCallback ) ; replicationDiscoveryService . start ( ) ; return discoveryServiceCallback ; }
response: private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException { log.info("Start Discovery Service."); CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>(); this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath()); // Start LogReplicationDiscovery Service, responsible for // acquiring lock, retrieving Site Manager Info and processing this info // so this node is initialized as Source (sender) or Sink (receiver) replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext, <START> clusterManagerAdapter, discoveryServiceCallback); <END> return discoveryServiceCallback; }

sample: 214
buggy_code: public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception { long prevChunk = mallocChunks(4); long middleChunk = mallocChunks(4); long nextChunk = mallocChunks(2); free(middleChunk); // This should be taken from the end of "middleChunk", since that's closer to the smaller neighbor long smallChunk1 = mallocChunks(1); // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks(1); <START> assertTrue("The small chunks should have been allocated from the end of the free block", smallChunk1 > smallChunk2); assertTrue("The small chunks should have been allocated from space before 'nextChunk'", smallChunk1 < nextChunk); assertTrue("The small chunks should have been allocated from space after 'prevChunk'", smallChunk2 > prevChunk); <END> }
code_review: I would change the order to: assertTrue(prevChunk < smallChunk2); assertTrue(smallChunk2 < smallChunk1); assertTrue(smallChunk1 < nextChunk);
target code: public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock ( ) throws Exception { long prevChunk = mallocChunks ( 4 ) ; long middleChunk = mallocChunks ( 4 ) ; long nextChunk = mallocChunks ( 2 ) ; free ( middleChunk ) ; // This should be taken from the end of "middleChunk" , since that's closer to the smaller neighbor long smallChunk1 = mallocChunks ( 1 ) ; // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks ( 1 ) ; assertTrue ( "The small chunks should have been allocated from space after 'prevChunk'" , prevChunk < smallChunk2 ) ; assertTrue ( "The small chunks should have been allocated from the end of the free block" , smallChunk2 < smallChunk1 ) ; assertTrue ( "The small chunks should have been allocated from space before 'nextChunk'" , smallChunk1 < nextChunk ) ; }
response: public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception { long prevChunk = mallocChunks(4); long middleChunk = mallocChunks(4); long nextChunk = mallocChunks(2); free(middleChunk); // This should be taken from the end of "middleChunk", since that's closer to the smaller neighbor long smallChunk1 = mallocChunks(1); // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks(1); <START> assertTrue("The small chunks should have been allocated from the end of the free block", smallChunk1 > smallChunk2); assertTrue("The small chunks should have been allocated from space before 'nextChunk'", smallChunk1 < nextChunk); assertTrue("The small chunks should have been allocated from space after 'prevChunk'", smallChunk2 > prevChunk); <END> }

sample: 215
buggy_code: public void shouldSetTempImagesPathAsCompleteDirectory() { URI path = URI.create("/pages/newImagesTemp/"); ConfigCore.setImagesPath(URI.create("/pages/newImagesTemp/")); <START> System.out.println(ConfigCore.getTempImagesPathAsCompleteDirectory()); <END> assertEquals("Temp images path was set incorrectly!", path, URI.create("/pages/newImagesTemp/")); }
code_review: Why did you add this `System.out.println()` call? Maybe a logger is a better solution.
target code: public void shouldSetTempImagesPathAsCompleteDirectory ( ) { URI path = URI . create ( " / pages / newImagesTemp / " ) ; ConfigCore . setImagesPath ( URI . create ( " / pages / newImagesTemp / " ) ) ; assertEquals ( "Temp images path was set incorrectly ! " , path , URI . create ( " / pages / newImagesTemp / " ) ) ; }
response: public void shouldSetTempImagesPathAsCompleteDirectory() { URI path = URI.create("/pages/newImagesTemp/"); ConfigCore.setImagesPath(URI.create("/pages/newImagesTemp/")); <START> ConfigCore.getTempImagesPathAsCompleteDirectory(); <END> assertEquals("Temp images path was set incorrectly!", path, URI.create("/pages/newImagesTemp/")); }

sample: 216
buggy_code: public MetadataHashAggPOP(@JsonProperty("child") PhysicalOperator child, @JsonProperty("context") MetadataAggregateContext context, @JsonProperty("phase") OperatorPhase phase) { super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F); <START> this.context = context; <END> this.phase = phase; Preconditions.checkArgument(context.createNewAggregations(), "Hash aggregate for metadata collecting should be used only for creating new aggregations."); }
code_review: Please move this check before assigning the variables.
target code: public MetadataHashAggPOP ( @JsonProperty ( "child" ) PhysicalOperator child , @JsonProperty ( "context" ) MetadataAggregateContext context , @JsonProperty ( "phase" ) OperatorPhase phase ) { super ( child , phase , context . groupByExpressions ( ) , Collections . emptyList ( ) , 1 . 0F ) ; Preconditions . checkArgument ( context . createNewAggregations ( ) , "Hash aggregate for metadata collecting should be used only for creating new aggregations . " ) ; this . context = context ; this . phase = phase ; }
response: public MetadataHashAggPOP(@JsonProperty("child") PhysicalOperator child, @JsonProperty("context") MetadataAggregateContext context, @JsonProperty("phase") OperatorPhase phase) { super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F); Preconditions.checkArgument(context.createNewAggregations(), "Hash aggregate for metadata collecting should be used only for creating new aggregations."); <START> this.context = context; <END> this.phase = phase; }

sample: 217
buggy_code: private void saveProcess(Process process) { try { serviceManager.getProcessService().save(process); } catch (DataException e) { <START> Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, "Error while saving process: " + process.getTitle(), e); <END> logger.error(KITODO_SCRIPT_FIELD + "Error while saving process: " + process.getTitle(), e); } }
code_review: Please first log the error and then inform the user.
target code: private void saveProcess ( Process process ) { try { serviceManager . getProcessService ( ) . save ( process ) ; } catch ( DataException e ) { logger . error ( KITODO_SCRIPT_FIELD + "Error while saving process : " + process . getTitle ( ) , e ) ; Helper . setFehlerMeldung ( KITODO_SCRIPT_FIELD , "Error while saving process : " + process . getTitle ( ) , e ) ; } }
response: private void saveProcess(Process process) { try { serviceManager.getProcessService().save(process); } catch (DataException e) { <START> logger.error(KITODO_SCRIPT_FIELD + "Error while saving process: " + process.getTitle(), e); Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, "Error while saving process: " + process.getTitle(), e); <END> } }

sample: 218
buggy_code: <START> private String toHexString(QuantileDigest qdigest) <END> { return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll("\\s+", " "); }
code_review: private static
target code: private static String toHexString ( QuantileDigest qdigest ) { return new SqlVarbinary ( qdigest . serialize ( ) . getBytes ( ) ) . toString ( ) . replaceAll ( "\\s + " , " " ) ; }
response: <START> private static String toHexString(QuantileDigest qdigest) <END> { return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll("\\s+", " "); }

sample: 219
buggy_code: <START> public String getHeader(){ <END> return selectedPageHeader.getText(); }
code_review: this should be private method
target code: private String getHeader ( ) { return selectedPageHeader . getText ( ) ; }
response: <START> private String getHeader(){ <END> return selectedPageHeader.getText(); }

sample: 220
buggy_code: public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) { String userModelAttrName = getUserModelAttribute(); String attributeValue = getAttributeValue(); Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase()); if (userModelProperty != null) { <START> checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user); <END> setPropertyOnUserModel(userModelProperty, user, attributeValue); } else { user.setAttribute(userModelAttrName, Arrays.asList(attributeValue)); } }
code_review: Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute.
target code: public void onImportUserFromLDAP ( LDAPObject ldapUser , UserModel user , RealmModel realm , boolean isCreate ) { String userModelAttrName = getUserModelAttribute ( ) ; String attributeValue = getAttributeValue ( ) ; Property < Object > userModelProperty = userModelProperties . get ( userModelAttrName . toLowerCase ( ) ) ; if ( userModelProperty != null ) { setPropertyOnUserModel ( userModelProperty , user , attributeValue ) ; } else { user . setAttribute ( userModelAttrName , Arrays . asList ( attributeValue ) ) ; } }
response: public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) { String userModelAttrName = getUserModelAttribute(); String attributeValue = getAttributeValue(); Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase()); if (userModelProperty != null) { setPropertyOnUserModel(userModelProperty, user, attributeValue); } else { user.setAttribute(userModelAttrName, Arrays.asList(attributeValue)); } }

sample: 221
buggy_code: <START> public Boolean delete( ProjectName projectName ) <END> { return callWithContext( () -> { final Boolean result = doDelete( projectName ); LOG.info( "Project deleted: " + projectName ); return result; } ); }
code_review: boolean instead of Boolean
target code: public boolean delete ( ProjectName projectName ) { return callWithContext ( ( ) - > { final boolean result = doDelete ( projectName ) ; LOG . info ( "Project deleted : " + projectName ) ; return result ; } ) ; }
response: <START> public boolean delete( ProjectName projectName ) <END> { return callWithContext( () -> { final boolean result = doDelete( projectName ); LOG.info( "Project deleted: " + projectName ); return result; } ); }

sample: 222
buggy_code: public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort) throws IOException, <START> InterruptedException, KeeperException.NoNodeException { <END> final int port = getPort(hostPort); LOG.info("<START>ING server instance 127.0.0.1:{}", port); ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000); factory.startup(zks); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure())); }
code_review: this isn't needed anymore right?
target code: public static void startServerInstance ( File dataDir , ServerCnxnFactory factory , String hostPort ) throws IOException , InterruptedException { final int port = getPort ( hostPort ) ; LOG . info ( "STARTING server instance 127 . 0 . 0 . 1 : { } " , port ) ; ZooKeeperServer zks = new ZooKeeperServer ( dataDir , dataDir , 3000 ) ; factory . startup ( zks ) ; Assert . assertTrue ( "waiting for server up" , ClientBase . waitForServerUp ( "127 . 0 . 0 . 1 : " + port , CONNECTION_TIMEOUT , factory . isSecure ( ) ) ) ; }
response: public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort) throws IOException, <START> InterruptedException, KeeperException.NoNodeException { <END> final int port = getPort(hostPort); LOG.info("<START>ING server instance 127.0.0.1:{}", port); ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000); factory.startup(zks); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure())); }

sample: 223
buggy_code: public void shouldShowAllMusicsAsHTTP() { MockHttpResult mockHttpResult = new MockHttpResult(); controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics); when(dao.listAll()).thenReturn(Arrays.asList(music)); controller.showAllMusicsAsHTTP(); assertEquals("<p class=\"content\">"+ Arrays.asList(music).toString()+"</p>", mockHttpResult.getBody()); <START> } <END>
code_review: If you want, you can change to use hamcrest here too. The method `Matchers.is` compare if two objects are equals.
target code: public void shouldShowAllMusicsAsHTTP ( ) { MockHttpResult mockHttpResult = new MockHttpResult ( ) ; controller = new MusicController ( dao , userInfo , mockHttpResult , validator , musics ) ; when ( dao . listAll ( ) ) . thenReturn ( Arrays . asList ( music ) ) ; controller . showAllMusicsAsHTTP ( ) ; assertThat ( mockHttpResult . getBody ( ) , is ( " < p class = \"content\" > " + Arrays . asList ( music ) . toString ( ) + " </ p > " ) ) ; }
response: public void shouldShowAllMusicsAsHTTP() { MockHttpResult mockHttpResult = new MockHttpResult(); controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics); when(dao.listAll()).thenReturn(Arrays.asList(music)); controller.showAllMusicsAsHTTP(); assertThat(mockHttpResult.getBody(), is("<p class=\"content\">"+ Arrays.asList(music).toString()+"</p>")); <START> } <END>

sample: 224
buggy_code: public AttributeValueSearch(IAttributeType attributeType, String attributeValue) { this.attributeType = attributeType; this.attributeValue = attributeValue; <START> Conditions.checkNotNull(attributeType, "attributeType"); Conditions.checkNotNullOrEmpty(attributeValue, "attributeValue"); <END> }
code_review: wouldn't you want the conditions check prior to assignments?
target code: public AttributeValueSearch ( IAttributeType attributeType , String attributeValue ) { Conditions . checkNotNull ( attributeType , "attributeType" ) ; Conditions . checkNotNullOrEmpty ( attributeValue , "attributeValue" ) ; this . attributeType = attributeType ; this . attributeValue = attributeValue ; }
response: public AttributeValueSearch(IAttributeType attributeType, String attributeValue) { <START> Conditions.checkNotNull(attributeType, "attributeType"); Conditions.checkNotNullOrEmpty(attributeValue, "attributeValue"); <END> this.attributeType = attributeType; this.attributeValue = attributeValue; }

sample: 225
buggy_code: public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) { super(source); <START> this.idleTime = Duration.ofMillis(idleTime); <END> this.listenerId = id; this.queueNames = Arrays.asList(queueNames); }
code_review: What made you to wrap, when you still use a simple long afterwards?
target code: public ListenerContainerIdleEvent ( Object source , long idleTime , @Nullable String id , String . . . queueNames ) { super ( source ) ; this . idleTime = idleTime ; this . listenerId = id ; this . queueNames = Arrays . asList ( queueNames ) ; }
response: public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) { super(source); this.idleTime = Duration.ofMillis(idleTime); this.listenerId = id; this.queueNames = Arrays.asList(queueNames); }

sample: 226
buggy_code: public static XARecoveryModule getRegisteredXARecoveryModule () { if (registeredXARecoveryModule == null) { RecoveryManager recMan = RecoveryManager.manager(); Vector recoveryModules = recMan.getModules(); if (recoveryModules != null) { Enumeration modules = recoveryModules.elements(); while (modules.hasMoreElements()) { RecoveryModule m = (RecoveryModule) modules.nextElement(); if (m instanceof XARecoveryModule) { <START> registeredXARecoveryModule = (XARecoveryModule) m; <END> } } } } return registeredXARecoveryModule; }
code_review: you should break out of the loop early after finding the target module
target code: public static XARecoveryModule getRegisteredXARecoveryModule ( ) { if ( registeredXARecoveryModule == null ) { RecoveryManager recMan = RecoveryManager . manager ( ) ; Vector recoveryModules = recMan . getModules ( ) ; if ( recoveryModules != null ) { Enumeration modules = recoveryModules . elements ( ) ; while ( modules . hasMoreElements ( ) ) { RecoveryModule m = ( RecoveryModule ) modules . nextElement ( ) ; if ( m instanceof XARecoveryModule ) { registeredXARecoveryModule = ( XARecoveryModule ) m ; break ; } } } } return registeredXARecoveryModule ; }
response: public static XARecoveryModule getRegisteredXARecoveryModule () { if (registeredXARecoveryModule == null) { RecoveryManager recMan = RecoveryManager.manager(); Vector recoveryModules = recMan.getModules(); if (recoveryModules != null) { Enumeration modules = recoveryModules.elements(); while (modules.hasMoreElements()) { RecoveryModule m = (RecoveryModule) modules.nextElement(); if (m instanceof XARecoveryModule) { <START> registeredXARecoveryModule = (XARecoveryModule) m; break; <END> } } } } return registeredXARecoveryModule; }

sample: 227
buggy_code: public String getUrl() { <START> return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent); <END> }
code_review: possible NPE
target code: public String getUrl ( ) { return url ; }
response: public String getUrl() { <START> return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent); }

sample: 228
buggy_code: public void testBoundarySignalProcessInstance() throws Exception { Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS); assertNotNull(processInstanceId); assertTrue(processInstanceId.longValue() > 0); try { <START> checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId); <END> } catch (Exception e){ processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); e.printStackTrace(); fail(e.getMessage()); } }
code_review: Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
target code: public void testBoundarySignalProcessInstance ( ) throws Exception { Long processInstanceId = processClient . startProcess ( CONTAINER_ID , PROCESS_ID_BOUNDARY_SIGNAL_PROCESS ) ; assertNotNull ( processInstanceId ) ; assertTrue ( processInstanceId . longValue ( ) > 0 ) ; try { checkAvailableBoundarySignals ( CONTAINER_ID , processInstanceId ) ; } finally { processClient . abortProcessInstance ( CONTAINER_ID , processInstanceId ) ; } }
response: public void testBoundarySignalProcessInstance() throws Exception { Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS); assertNotNull(processInstanceId); assertTrue(processInstanceId.longValue() > 0); try { <START> checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId); <END> } finally { processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); } }

sample: 229
buggy_code: private void validateAppConfig(String fileName) throws Exception { String appsDir = getAppsDirectory(); if (appsDir.equalsIgnoreCase("apps") && !isAppConfiguredInSourceServerXml(fileName)) { // add application configuration applicationXml.createWebApplicationElement(fileName); } <START> else if (appsDir.equalsIgnoreCase("dropins") && isAnyAppConfiguredInSourceServerXml()) <END> throw new MojoExecutionException(messages.getString("error.install.app.dropins.directory")); }
code_review: why not calling isAppConfiguredInSourceServerXml(fileName) to make sure the app installed to the dropins location is not configured?
target code: private void validateAppConfig ( String fileName ) throws Exception { String appsDir = getAppsDirectory ( ) ; if ( appsDir . equalsIgnoreCase ( "apps" ) && ! isAppConfiguredInSourceServerXml ( fileName ) ) { // add application configuration applicationXml . createWebApplicationElement ( fileName ) ; } else if ( appsDir . equalsIgnoreCase ( "dropins" ) && isAppConfiguredInSourceServerXml ( fileName ) ) throw new MojoExecutionException ( messages . getString ( "error . install . app . dropins . directory" ) ) ; }
response: private void validateAppConfig(String fileName) throws Exception { String appsDir = getAppsDirectory(); if (appsDir.equalsIgnoreCase("apps") && !isAppConfiguredInSourceServerXml(fileName)) { // add application configuration applicationXml.createWebApplicationElement(fileName); } <START> else if (appsDir.equalsIgnoreCase("dropins") && isAppConfiguredInSourceServerXml(fileName)) <END> throw new MojoExecutionException(messages.getString("error.install.app.dropins.directory")); }

sample: 230
buggy_code: <START> static RequestContextDataHolder getRequestContext(Context ctx) { <END> return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null); }
code_review: Please add `private` modifier
target code: private static RequestContextDataHolder getRequestContext ( Context ctx ) { return ctx . getOrDefault ( REQUEST_CONTEXT_DATA_HOLDER , null ) ; }
response: <START> private static RequestContextDataHolder getRequestContext(Context ctx) { <END> return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null); }

sample: 231
buggy_code: public long getNumberOfImagesInStorageDomain(Guid storageDomainId) { <START> MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId); <END> return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), params); }
code_review: I'd inline this to conform with the rest of the class.
target code: public long getNumberOfImagesInStorageDomain ( Guid storageDomainId ) { return getCallsHandler ( ) . executeRead ( "GetNumberOfImagesInStorageDomain" , getLongMapper ( ) , getCustomMapSqlParameterSource ( ) . addValue ( "storage_domain_id" , storageDomainId ) ) ; }
response: public long getNumberOfImagesInStorageDomain(Guid storageDomainId) { <START> return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId)); <END> }

sample: 232
buggy_code: public TestObjectAsync() { try { <START> Thread.sleep(100); <END> Thread.sleep(100); counter = 1; } catch (InterruptedException ie) { throw new RuntimeException(ie); } }
code_review: Is it really necessary to wait 100 milliseconds? Why not `Thread.sleep(1)`. Why not `Thread.yield()`?
target code: public TestObjectAsync ( ) { try { Thread . sleep ( 1 ) ; Thread . sleep ( 1 ) ; counter = 1 ; } catch ( InterruptedException ie ) { throw new RuntimeException ( ie ) ; } }
response: public TestObjectAsync() { try { <START> Thread.sleep(1); <END> Thread.sleep(100); counter = 1; } catch (InterruptedException ie) { throw new RuntimeException(ie); } }

sample: 233
buggy_code: private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) { Field field = getField(beanClass, beanProp.getName()); return field != null ? field.getAnnotationsByType(Optional.class).length > 0 <START> || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 <END> : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0; }
code_review: Maybe `beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0` should be checked before calling getField ? Method getField modifies field via reflection and optionally recursively calls itself, so it could be costly.
target code: private static boolean isOptionalProperty ( Class beanClass , PropertyDescriptor beanProp ) { if ( beanProp . getReadMethod ( ) . getAnnotationsByType ( Optional . class ) . length > 0 ) { return true ; } Field field = getField ( beanClass , beanProp . getName ( ) ) ; return field != null && field . getAnnotationsByType ( Optional . class ) . length > 0 ; }
response: private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) { Field field = getField(beanClass, beanProp.getName()); return field != null ? field.getAnnotationsByType(Optional.class).length > 0 <START> || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 <END> : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0; }

sample: 234
buggy_code: public int getImageselector () { return imageSelectorIndex; <START> } <END>
code_review: Why is this method required? Didn't see it used anywhere in the code
target code: int getImageselector ( ) { return imageSelectorIndex ; }
response: public int getImageselector () { return imageSelectorIndex; }

sample: 235
buggy_code: public InputStream getInputStream(FileHeader entry) throws IOException { if (entry == null) { return null; } InputStream inputStream = getEntryData(entry).getInputStream(); if (entry.getMethod() == ZipEntry.DEFLATED) { <START> inputStream = new ZipInflaterInputStream(inputStream, new Inflater(true), <END> (int) entry.getSize()); } return inputStream; }
code_review: I don't think we want to pass in an `Inflater` and than have `ZipInflaterInputStream` call `end()` on it.
target code: public InputStream getInputStream ( FileHeader entry ) throws IOException { if ( entry == null ) { return null ; } InputStream inputStream = getEntryData ( entry ) . getInputStream ( ) ; if ( entry . getMethod ( ) == ZipEntry . DEFLATED ) { inputStream = new ZipInflaterInputStream ( inputStream , ( int ) entry . getSize ( ) ) ; } return inputStream ; }
response: public InputStream getInputStream(FileHeader entry) throws IOException { if (entry == null) { return null; } InputStream inputStream = getEntryData(entry).getInputStream(); if (entry.getMethod() == ZipEntry.DEFLATED) { <START> inputStream = new ZipInflaterInputStream(inputStream, (int) entry.getSize()); <END> } return inputStream; }

sample: 236
buggy_code: private org.eclipse.swt.graphics.Image createImage() { org.eclipse.swt.graphics.Image newImage; RenderedImage image = renderManager.getImage(); <START> this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform(); <END> if (image != null) newImage = AWTSWTImageUtils.createSWTImage(image, false); else { newImage = new Image(getDisplay(), getWidth(), getHeight()); } return newImage; }
code_review: Can you explain the idea behind storing transformation here and not anywhere else (at the very beginning of repaint())? Is it worth to keep this information and to compare it within getDoubleBufferGraphics() rather using the up-to-date viewportModel Transformation. is it because of a non-atomar opration betwenn getImage() and getDoubleBufferGraphics() calls?
target code: private org . eclipse . swt . graphics . Image createImage ( ) { org . eclipse . swt . graphics . Image newImage ; RenderedImage image = renderManager . getImage ( ) ; if ( image != null ) newImage = AWTSWTImageUtils . createSWTImage ( image , false ) ; else { newImage = new Image ( getDisplay ( ) , getWidth ( ) , getHeight ( ) ) ; } return newImage ; }
response: private org.eclipse.swt.graphics.Image createImage() { org.eclipse.swt.graphics.Image newImage; RenderedImage image = renderManager.getImage(); <START> this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform(); <END> if (image != null) newImage = AWTSWTImageUtils.createSWTImage(image, false); else { newImage = new Image(getDisplay(), getWidth(), getHeight()); } return newImage; }

sample: 237
buggy_code: public VirtualMachine getCurrentMachineBuild(ITmfEvent event) { VirtualMachine machine = innerGetCurrentMachine(event); if (machine == null) { synchronized (fStateSystem) { String hostId = event.getTrace().getHostId(); <START> machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName()); <END> fKnownMachines.put(hostId, machine); } } return machine; }
code_review: this is nullable
target code: public VirtualMachine getCurrentMachineBuild ( ITmfEvent event ) { VirtualMachine machine = innerGetCurrentMachine ( event ) ; if ( machine == null ) { synchronized ( fStateSystem ) { String hostId = event . getTrace ( ) . getHostId ( ) ; machine = createMachine ( fStateSystem , event . getTimestamp ( ) . toNanos ( ) , hostId , String . valueOf ( event . getTrace ( ) . getName ( ) ) ) ; fKnownMachines . put ( hostId , machine ) ; } } return machine ; }
response: public VirtualMachine getCurrentMachineBuild(ITmfEvent event) { VirtualMachine machine = innerGetCurrentMachine(event); if (machine == null) { synchronized (fStateSystem) { String hostId = event.getTrace().getHostId(); <START> machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName()); <END> fKnownMachines.put(hostId, machine); } } return machine; }

sample: 238
buggy_code: public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && isDeterministic(expression) && !mayReturnNullOnNonNullInput(expression) && <START> !isDynamicFilter(expression)) { <END> ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }
code_review: Why do we need it here?
target code: public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }
response: public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && isDeterministic(expression) && !mayReturnNullOnNonNullInput(expression) && <START> !isDynamicFilter(expression)) { <END> ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }

sample: 239
buggy_code: private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates) throws DbException { for (int agg = 0; agg < aggregators.length; ++agg) { if (!(aggregators[agg] .getClass() .getName() <START> .equals(StatefulUserDefinedAggregator.class.getName()))) { <END> aggregators[agg].addRow(tb, row, curAggStates[agg]); } } }
code_review: instanceof
target code: private void updateGroup ( final TupleBatch tb , final int row , final Object [ ] curAggStates ) throws DbException { for ( int agg = 0 ; agg < aggregators . length ; ++ agg ) { if ( ! ( aggregators [ agg ] instanceof StatefulUserDefinedAggregator ) ) { aggregators [ agg ] . addRow ( tb , row , curAggStates [ agg ] ) ; } } }
response: private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates) throws DbException { for (int agg = 0; agg < aggregators.length; ++agg) { if (!(aggregators[agg] <START> instanceof StatefulUserDefinedAggregator)) { <END> aggregators[agg].addRow(tb, row, curAggStates[agg]); } } }

sample: 240
buggy_code: protected void update(float delta) { int lengthInterpretation; try { <START> lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite); <END> } catch (InterpretationException interpretationException) { lengthInterpretation = 0; Log.d(getClass().getSimpleName(), "Formula interpretation for this specific Brick failed.", interpretationException); } this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation)); }
code_review: Please apply same changes as requested in first review here.
target code: protected void update ( float delta ) { int lengthInterpretation = 0 ; try { if ( length != null ) { lengthInterpretation = length . interpretInteger ( sprite ) ; } } catch ( InterpretationException interpretationException ) { lengthInterpretation = 0 ; Log . d ( getClass ( ) . getSimpleName ( ) , "Formula interpretation for this specific Brick failed . " , interpretationException ) ; } this . sprite . runningStitch . activateStitching ( sprite , new SimpleRunningStitch ( sprite , lengthInterpretation ) ) ; }
response: protected void update(float delta) { int lengthInterpretation; try { <START> lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite); <END> } catch (InterpretationException interpretationException) { lengthInterpretation = 0; Log.d(getClass().getSimpleName(), "Formula interpretation for this specific Brick failed.", interpretationException); } this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation)); }

sample: 241
buggy_code: protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) { long sum = 0; for (String weaselParameterToSum : weaselParametersToSum) { final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters)); if (timing == null) { <START> discardSpan(span); <END> return; } else { sum += timing; } } span.setTag(TIMING_RESOURCE, sum); }
code_review: remove line
target code: protected void processSpanImpl ( Span span , Map < String , String [ ] > servletRequestParameters ) { long sum = 0 ; for ( String weaselParameterToSum : weaselParametersToSum ) { final Long timing = parsedLongOrNull ( getParameterValueOrNull ( weaselParameterToSum , servletRequestParameters ) ) ; if ( timing == null ) { return ; } else { sum += timing ; } } span . setTag ( TIMING_RESOURCE , sum ) ; }
response: protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) { long sum = 0; for (String weaselParameterToSum : weaselParametersToSum) { final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters)); if (timing == null) { <START> discardSpan(span); return; <END> } else { sum += timing; } } span.setTag(TIMING_RESOURCE, sum); }

sample: 242
buggy_code: private void close(Path path) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent(); try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced)) { <START> s.filter(p -> !Files.isDirectory(p)).map(ThrowingFunction.unchecked(p -> p)) <END> .forEach(ThrowingConsumer.unchecked(Files::delete)); } }
code_review: `.map(ThrowingFunction.unchecked(p -> p))` unnecessary
target code: private void close ( Path path ) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path . getParent ( ) ; try ( Stream < Path > s = Files . list ( directoryWhereGeneratedArtifactsWasPlaced ) ) { s . filter ( p - > ! Files . isDirectory ( p ) ) . forEach ( ThrowingConsumer . unchecked ( Files : : delete ) ) ; } }
response: private void close(Path path) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent(); try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced)) { <START> s.filter(p -> !Files.isDirectory(p)) <END> .forEach(ThrowingConsumer.unchecked(Files::delete)); } }

sample: 243
buggy_code: public void hashcodeVerifyEqualsContract() { <START> EqualsVerifier.forClass(MessageReference.class).suppress(Warning.NONFINAL_FIELDS).verify(); <END> }
code_review: As a general rule: If you're unsure whether or not to suppress a warning, don't! You discovered the principal problem of mutable objects. The easy fix is to use [immutable objects](http://en.wikipedia.org/wiki/Immutable_object) whenever possible. `MessageReference` looks like it could be easily made immutable. So you should definitely do that instead of suppressing the warning.
target code: public void hashcodeVerifyEqualsContract ( ) { EqualsVerifier . forClass ( MessageReference . class ) . verify ( ) ; }
response: public void hashcodeVerifyEqualsContract() { <START> EqualsVerifier.forClass(MessageReference.class).verify(); <END> }

sample: 244
buggy_code: public HttpRequest setUri(String uri) { ObjectUtil.checkNotNull(uri, "uri"); <START> this.uri = uri; <END> return this; }
code_review: nit: you can merge both lines above as `checkNotNull` will return the given argument
target code: public HttpRequest setUri ( String uri ) { this . uri = ObjectUtil . checkNotNull ( uri , "uri" ) ; return this ; }
response: public HttpRequest setUri(String uri) { <START> this.uri = ObjectUtil.checkNotNull(uri, "uri"); <END> return this; }

sample: 245
buggy_code: <START> protected ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { <END> this.creds = creds; }
code_review: Make all Guice constructors package private by removing the method modifier. Just: ``` java @Inject ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { ```
target code: ServiceKeyAuthentication ( @Provider Supplier < Credentials > creds ) { this . creds = creds ; }
response: <START> @Inject ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { <END> this.creds = creds; }

sample: 246
buggy_code: protected int countChildrenOf(IResource checkResource) throws CoreException { if (checkResource.getType() == IResource.FILE) { return 1; } int count = 0; if (checkResource.isAccessible()) { for (IResource <START> resource : <END> ((IContainer) checkResource).members()) { count += countChildrenOf(resource); } } return count; }
code_review: rename 'child'
target code: protected int countChildrenOf ( IResource checkResource ) throws CoreException { if ( checkResource . getType ( ) == IResource . FILE ) { return 1 ; } int count = 0 ; if ( checkResource . isAccessible ( ) ) { for ( IResource child : ( ( IContainer ) checkResource ) . members ( ) ) { count += countChildrenOf ( child ) ; } } return count ; }
response: protected int countChildrenOf(IResource checkResource) throws CoreException { if (checkResource.getType() == IResource.FILE) { return 1; } int count = 0; if (checkResource.isAccessible()) { for (IResource <START> child : <END> ((IContainer) checkResource).members()) { count += countChildrenOf(child); } } return count; }

sample: 247
buggy_code: public String getAppFolderToMonitor() { <START> if (folder == null) { <END> File f = new File("Applications"); folder = f.getAbsolutePath(); } return folder; }
code_review: If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The `startMonitor` method below also checks for the return value of this method being `null`. I guess `null` would then also be the default.
target code: public String getAppFolderToMonitor ( ) { return folder ; }
response: public String getAppFolderToMonitor() { <START> if (folder == null) { <END> File f = new File("Applications"); folder = f.getAbsolutePath(); } return folder; }

sample: 248
buggy_code: private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts) { long input = inputAddress; Arrays.fill(counts, 0); <START> if (inputSize != 0) { <END> for (int i = 0; i < inputSize; i++) { int symbol = UNSAFE.getByte(inputBase, input) & 0xFF; input++; counts[symbol]++; } } }
code_review: I don't think you need this
target code: private static void count ( Object inputBase , long inputAddress , int inputSize , int [ ] counts ) { long input = inputAddress ; Arrays . fill ( counts , 0 ) ; for ( int i = 0 ; i < inputSize ; i ++ ) { int symbol = UNSAFE . getByte ( inputBase , input ) & 0xFF ; input ++ ; counts [ symbol ] ++ ; } }
response: private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts) { long input = inputAddress; Arrays.fill(counts, 0); <START> if (inputSize != 0) { for (int i = 0; i < inputSize; i++) { int symbol = UNSAFE.getByte(inputBase, input) & 0xFF; input++; counts[symbol]++; } <END> } }

sample: 249
buggy_code: public void submit(List<LuceneWork> workList, IndexingMonitor monitor) { Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor ); transferQueue.add( changeset ); wakeUpConsumer(); boolean interrupted = false; while ( ! changeset.isProcessed() ) { LockSupport.park(); if ( Thread.interrupted() ) { <START> interrupted = true; <END> } } if ( interrupted ) { Thread.currentThread().interrupt(); } }
code_review: If it's interrupted you might want to return too, rather than getting stuck in another park.
target code: public void submit ( List < LuceneWork > workList , IndexingMonitor monitor ) { Changeset changeset = new Changeset ( workList , Thread . currentThread ( ) , monitor ) ; transferQueue . add ( changeset ) ; wakeUpConsumer ( ) ; boolean interrupted = false ; while ( ! changeset . isProcessed ( ) && ! interrupted ) { LockSupport . park ( ) ; if ( Thread . interrupted ( ) ) { interrupted = true ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } }
response: public void submit(List<LuceneWork> workList, IndexingMonitor monitor) { Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor ); transferQueue.add( changeset ); wakeUpConsumer(); boolean interrupted = false; while ( ! changeset.isProcessed() ) { LockSupport.park(); if ( Thread.interrupted() ) { <START> interrupted = true; return; <END> } } if ( interrupted ) { Thread.currentThread().interrupt(); } }

sample: 250
buggy_code: public void setHttpService(HttpService httpService) { <START> logger.info("setHttpService called"); <END> this.httpService = httpService; }
code_review: could we directly reduce this to debug level?
target code: public void setHttpService ( HttpService httpService ) { logger . debug ( "setHttpService called" ) ; this . httpService = httpService ; }
response: public void setHttpService(HttpService httpService) { <START> logger.debug("setHttpService called"); <END> this.httpService = httpService; }

sample: 251
buggy_code: public boolean isInternal() { return getParentNode() .filter(parent -> parent instanceof Name) .map(parent -> (Name) parent) .flatMap(Name::getQualifier) <START> .map(parentNameQualifier -> parentNameQualifier == this) <END> .orElse(false); }
code_review: Oh, yes, `Name` can only be qualified by another `Name`. I think it's a safe assumption to make :-)
target code: public boolean isInternal ( ) { return getParentNode ( ) . filter ( parent - > parent instanceof Name ) . isPresent ( ) ; }
response: public boolean isInternal() { return getParentNode() .filter(parent -> parent instanceof Name) .map(parent -> (Name) parent) .flatMap(Name::getQualifier) <START> .map(parentNameQualifier -> parentNameQualifier == this) <END> .orElse(false); }

sample: 252
buggy_code: private void logStart() { log(3, "Running test " + m_testName + " on " + m_classMap.size() + " " + " classes, " <START> + " included groups:[" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups()) <END> + "] excluded groups:[" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + "]"); if (getVerbose() >= 3) { for (ITestClass tc : m_classMap.values()) { ((TestClass) tc).dump(); } } }
code_review: `valueOf` looks more appropriate (like `String#valueOf`)
target code: private void logStart ( ) { log ( 3 , "Running test " + m_testName + " on " + m_classMap . size ( ) + " " + " classes , " + " included groups : [ " + Strings . valueOf ( m_xmlMethodSelector . getIncludedGroups ( ) ) + " ] excluded groups : [ " + Strings . valueOf ( m_xmlMethodSelector . getExcludedGroups ( ) ) + " ] " ) ; if ( getVerbose ( ) >= 3 ) { for ( ITestClass tc : m_classMap . values ( ) ) { ( ( TestClass ) tc ) . dump ( ) ; } } }
response: private void logStart() { log(3, "Running test " + m_testName + " on " + m_classMap.size() + " " + " classes, " <START> + " included groups:[" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups()) <END> + "] excluded groups:[" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + "]"); if (getVerbose() >= 3) { for (ITestClass tc : m_classMap.values()) { ((TestClass) tc).dump(); } } }

sample: 253
buggy_code: public NutchJob(Configuration conf) throws IOException { <START> super(conf, "NutchJob"); <END> }
code_review: Does this mean that every Job will be named ```"NutchJob"```?
target code: public NutchJob ( Configuration conf ) { super ( conf , NutchJob . class ) ; }
response: public NutchJob(Configuration conf) throws IOException { super(conf, "NutchJob"); }

sample: 254
buggy_code: private void loadMachineUUID() { if <START> (System.getProperty(PROP_UUID) != <END> null) return; String uuid = loadExistingUUID(); if (uuid == null) { uuid = UUID.randomUUID().toString(); saveUUID(uuid); } EnvironmentInfo environment = environmentTracker.getService(); if (environment != null) { environment.setProperty(PROP_UUID, uuid); } else { System.setProperty(PROP_UUID, uuid); } }
code_review: Should use BundleContext.getProperty here, or the EnvonmentInfo service.
target code: private void loadMachineUUID ( ) { EnvironmentInfo environment = environmentTracker . getService ( ) ; if ( environment != null ) { if ( environment . getProperty ( PROP_UUID ) != null ) return ; } String uuid = loadExistingUUID ( ) ; if ( uuid == null ) { uuid = UUID . randomUUID ( ) . toString ( ) ; saveUUID ( uuid ) ; } if ( environment != null ) { environment . setProperty ( PROP_UUID , uuid ) ; } else { System . setProperty ( PROP_UUID , uuid ) ; } }
response: private void loadMachineUUID() { if <START> (System.getProperty(PROP_UUID) != <END> null) return; String uuid = loadExistingUUID(); if (uuid == null) { uuid = UUID.randomUUID().toString(); saveUUID(uuid); } EnvironmentInfo environment = environmentTracker.getService(); if (environment != null) { environment.setProperty(PROP_UUID, uuid); } else { System.setProperty(PROP_UUID, uuid); } }

sample: 255
buggy_code: public synchronized boolean retry(ITestResult result) { if (currentTry < maxreruntimes) { <START> ++currentTry; <END> return true; } return false; }
code_review: Maybe we can use `AtomicInteger` and get rid of `synchronized` keyword ? On a side note, I noticed that you haven't enabled the `parallel` attribute on `@DataProvider` annotation. So you can completely get rid of the need for ensuring Thread safety.
target code: public boolean retry ( ITestResult result ) { if ( currentTry < maxreruntimes ) { ++ currentTry ; return true ; } return false ; }
response: public boolean retry(ITestResult result) { if (currentTry < maxreruntimes) { <START> ++currentTry; <END> return true; } return false; }

sample: 256
buggy_code: public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException { <START> return (Statistics<T>)getStatistics(expr.getInt()); <END> }
code_review: It was much nicer when we did not have to explicitly cast everywhere to `(Statistics<T>)`. Please consider re-working this part your changes.
target code: public Statistics < T > visitIntConstant ( ValueExpressions . IntExpression expr , Void value ) throws RuntimeException { return getStatistics ( expr . getInt ( ) ) ; }
response: public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException { <START> return getStatistics(expr.getInt()); <END> }

sample: 257
buggy_code: public ServiceDate getEnd() { <START> return end == UNBOUNDED_<END> ? null : end; <END> }
code_review: It might even be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging.
target code: public ServiceDate getEnd ( ) { return end ; }
response: public ServiceDate getEnd() { <START> return end == UNBOUNDED_<END> ? UNBOUNDED : end; <END> }

sample: 258
buggy_code: <START> public boolean <END> isLoggedIn() { return token != null && hub != null; }
code_review: no public
target code: public boolean isLoggedIn ( ) { return token != null && user != null ; }
response: <START> boolean <END> isLoggedIn() { return token != null && hub != null; }

sample: 259
buggy_code: <START> public void setBuildStatus(String buildStatus) { <END> StashBuildState overwrittenBuildState = null; try { overwrittenBuildState = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } this.buildStatus = overwrittenBuildState; }
code_review: The complete method could be stripped down to: ``` try { this.buildStatus = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } ```
target code: public void setBuildStatus ( String buildStatus ) { try { this . buildStatus = StashBuildState . valueOf ( buildStatus ) ; } catch ( Exception e ) { // ignore unknown or null values } }
response: public void setBuildStatus(String buildStatus) { try { this.buildStatus = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } }

sample: 260
buggy_code: public void preInit(FMLPreInitializationEvent evt) { RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID); BCSiliconConfig.preInit(); BCSiliconItems.preInit(); BCSiliconBlocks.preInit(); // Reload after all of the definitions have been created. <START> BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME); <END> NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy()); BCSiliconProxy.getProxy().fmlPreInit(); }
code_review: Put this in the config preinit please
target code: public void preInit ( FMLPreInitializationEvent evt ) { RegistryHelper . useOtherModConfigFor ( MODID , BCCore . MODID ) ; BCSiliconConfig . preInit ( ) ; BCSiliconItems . preInit ( ) ; BCSiliconBlocks . preInit ( ) ; NetworkRegistry . INSTANCE . registerGuiHandler ( INSTANCE , BCSiliconProxy . getProxy ( ) ) ; BCSiliconProxy . getProxy ( ) . fmlPreInit ( ) ; }
response: public void preInit(FMLPreInitializationEvent evt) { RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID); BCSiliconConfig.preInit(); BCSiliconItems.preInit(); BCSiliconBlocks.preInit(); // Reload after all of the definitions have been created. <START> BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME); <END> NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy()); BCSiliconProxy.getProxy().fmlPreInit(); }

sample: 261
buggy_code: public Hash(HashType type){ this.type = type; try { digest = type.get(); } finally { <START> type.recycle(digest); <END> } }
code_review: Recycling a digest to which we still have references (namely in the member variable`digest`) is bound to give problems at some point: another thread may obtain it by means of `HashType.get()` while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of `Hash`. Note that the semantics of `finally` don't have anything to do with finalizers!
target code: public Hash ( HashType type ) { this . type = type ; digest = type . get ( ) ; }
response: public Hash(HashType type){ this.type = type; try { digest = type.get(); } finally { <START> type.recycle(digest); <END> } }

sample: 262
buggy_code: private boolean validateExternalVnicProfileMapping() { <START> drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings()); <END> final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping( getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId()); return validate(validationResult); }
code_review: the mapping is still performed before the validation. it should be after it
target code: private boolean validateExternalVnicProfileMapping ( ) { final ValidationResult validationResult = externalVnicProfileMappingValidator . validateExternalVnicProfileMapping ( getParameters ( ) . getExternalVnicProfileMappings ( ) , getParameters ( ) . getClusterId ( ) ) ; return validate ( validationResult ) ; }
response: private boolean validateExternalVnicProfileMapping() { final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping( getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId()); <START> drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings()); <END> return validate(validationResult); }

sample: 263
buggy_code: public void serDeTest() { <START> doSerDeTest(Collections.emptyList()); <END> doSerDeTest(Arrays.asList("a", "b", "/signedId/abcdef")); }
code_review: do we need a `null` case?
target code: public void serDeTest ( ) { doSerDeTest ( null ) ; doSerDeTest ( Collections . emptyList ( ) ) ; doSerDeTest ( Arrays . asList ( "a" , "b" , " / signedId / abcdef" ) ) ; }
response: public void serDeTest() { <START> doSerDeTest(Collections.emptyList()); <END> doSerDeTest(Arrays.asList("a", "b", "/signedId/abcdef")); doSerDeTest(null); }

sample: 264
buggy_code: protected void buildVmVideoCards() { createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl createInfo.add(VdsProperties.num_of_monitors, <START> (new Integer(vm.getnum_of_monitors())).toString()); <END> }
code_review: use String.valueOf(vm.getnum_of_monitors()) instead.
target code: protected void buildVmVideoCards ( ) { createInfo . add ( VdsProperties . display , vm . getdisplay_type ( ) . toString ( ) ) ; // vnc , qxl createInfo . add ( VdsProperties . num_of_monitors , String . valueOf ( vm . getnum_of_monitors ( ) ) ) ; }
response: protected void buildVmVideoCards() { createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl createInfo.add(VdsProperties.num_of_monitors, <START> String.valueOf(vm.getnum_of_monitors())); <END> }

sample: 265
buggy_code: <START> String encode(String segment) { <END> return URL.encodeQueryString(type.replacePathSeparator(segment)); }
code_review: [optional] maybe this method can be static and should be moved to end of the class
target code: private String encode ( String segment ) { return URL . encodeQueryString ( type . replacePathSeparator ( segment ) ) ; }
response: <START> static String encode(String segment) { <END> return URL.encodeQueryString(type.replacePathSeparator(segment)); }

sample: 266
buggy_code: public List<String> getStrongDependencies() { List<String> strongDependencies = new ArrayList<>(); <START> strongDependencies.add(A_U_D_preferredMail); <END> strongDependencies.add(A_U_D_ISMail); strongDependencies.add(A_U_D_publicAliasMails); strongDependencies.add(A_U_D_privateAliasMails); strongDependencies.add(A_U_D_o365EmailAddressesMU); return strongDependencies; }
code_review: This code is duplicate. Moreover, repeated "add" operations are not necessary. You can use something like this: ``` return Arrays.asList( A_U_D_preferredMail, A_U_D_ISMail, A_U_D_publicAliasMails, A_U_D_privateAliasMails, A_U_D_o365EmailAddressesMU); ```
target code: public List < String > getStrongDependencies ( ) { return Arrays . asList ( A_U_D_preferredMail , A_U_D_ISMail , A_U_D_publicAliasMails , A_U_D_privateAliasMails , A_U_D_o365EmailAddressesMU ) ; }
response: public List<String> getStrongDependencies() { return Arrays.asList( A_U_D_preferredMail, A_U_D_ISMail, A_U_D_publicAliasMails, A_U_D_privateAliasMails, A_U_D_o365EmailAddressesMU); }

sample: 267
buggy_code: boolean isCacheable() { <START> return true; <END> }
code_review: `isCacheable` is now `true`? I guess this was supposed to be `false` for generic extractors. Or am I wrong?
target code: boolean isCacheable ( ) { return false ; }
response: boolean isCacheable() { <START> return false; <END> }

sample: 268
buggy_code: <START> protected static KeyManagerFactory buildKeyManagerFactory(File certChainFile, <END> String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf, String keyStore) throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidAlgorithmParameterException, IOException, CertificateException, KeyException, UnrecoverableKeyException { return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm, toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore); }
code_review: It does not make sense to expose a protected method and mark it as @Deprecated from the beginning. Maybe you should remove the annotation and make it package-private ?
target code: static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , String keyAlgorithm , File keyFile , String keyPassword , KeyManagerFactory kmf , String keyStore ) throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , CertificateException , KeyException , UnrecoverableKeyException { return buildKeyManagerFactory ( toX509Certificates ( certChainFile ) , keyAlgorithm , toPrivateKey ( keyFile , keyPassword ) , keyPassword , kmf , keyStore ) ; }
response: <START> static KeyManagerFactory buildKeyManagerFactory(File certChainFile, <END> String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf, String keyStore) throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidAlgorithmParameterException, IOException, CertificateException, KeyException, UnrecoverableKeyException { return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm, toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore); }

sample: 269
buggy_code: public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { // send request channel.connect(); fail("should have thrown!"); } catch (IOException e) { <START> assertTrue(e.getMessage().contains("Connection refused")); <END> } }
code_review: It's probably a bad idea to be checking for exception messages in the first place.
target code: public void testWrongPortConnection ( ) throws Exception { BlockingChannel channel = new SSLBlockingChannel ( hostName , sslPort + 1 , new MetricRegistry ( ) , 10000 , 10000 , 10000 , 2000 , sslSocketFactory , clientSSLConfig ) ; try { // send request channel . connect ( ) ; fail ( "should have thrown ! " ) ; } catch ( IOException e ) { } }
response: public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { // send request channel.connect(); fail("should have thrown!"); } catch (IOException e) { <START> assertTrue(e.getMessage().contains("Connection refused")); <END> } }

sample: 270
buggy_code: public void notifyParameterChanged(String name) { if (!fParameterNames.contains(name)) { throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName())); } <START> synchronized (fParameters) { <END> Object oldValue = fParameters.get(name); Object value = getParameter(name); if ((value != null) && !(value.equals(oldValue))) { parameterChanged(name); } } }
code_review: the .contains() should probably be in the synchronized block too
target code: public void notifyParameterChanged ( String name ) { synchronized ( fParameters ) { if ( ! fParameterNames . contains ( name ) ) { throw new RuntimeException ( String . format ( Messages . TmfAbstractAnalysisModule_InvalidParameter , name , getName ( ) ) ) ; } Object oldValue = fParameters . get ( name ) ; Object value = getParameter ( name ) ; if ( ( value != null ) && ! ( value . equals ( oldValue ) ) ) { parameterChanged ( name ) ; } } }
response: public void notifyParameterChanged(String name) { if (!fParameterNames.contains(name)) { throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName())); } <START> synchronized (fParameters) { if (!fParameterNames.contains(name)) { throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName())); } <END> Object oldValue = fParameters.get(name); Object value = getParameter(name); if ((value != null) && !(value.equals(oldValue))) { parameterChanged(name); } } }

sample: 271
buggy_code: public void testUnrecognizedSpec() { when(authentication.getAttributes().get(any(String.class))).thenReturn("strong_two_factor"); spec.setAuthenticationMethod("weak_two_factor"); <START> assertTrue(this.spec.isSatisfiedBy(this.assertion)); <END> }
code_review: Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue?
target code: public void testUnrecognizedSpec ( ) { when ( authentication . getAttributes ( ) . get ( any ( String . class ) ) ) . thenReturn ( "strong_two_factor" ) ; spec . setAuthenticationMethod ( "weak_two_factor" ) ; spec . isSatisfiedBy ( this . assertion ) ; }
response: public void testUnrecognizedSpec() { when(authentication.getAttributes().get(any(String.class))).thenReturn("strong_two_factor"); spec.setAuthenticationMethod("weak_two_factor"); <START> assertFalse(this.spec.isSatisfiedBy(this.assertion)); <END> }

sample: 272
buggy_code: <START> public static Bundle updateBundleConfig(Connection connection, Bundle bundle) <END> throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"; try (final PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, bundle.config); statement.setLong(2, bundle.bundle); statement.setLong(3, bundle.view); statement.execute(); } return null; }
code_review: Why does this claim to return Bundle? Doesn't really matter though :)
target code: private void updateBundleConfig ( Connection connection , Bundle bundle ) throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config = ? WHERE bundle_id = ? AND view_id = ? " ; try ( final PreparedStatement statement = connection . prepareStatement ( sql ) ) { statement . setString ( 1 , bundle . config ) ; statement . setLong ( 2 , bundle . bundle ) ; statement . setLong ( 3 , bundle . view ) ; statement . execute ( ) ; } }
response: <START> public static void updateBundleConfig(Connection connection, Bundle bundle) <END> throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"; try (final PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, bundle.config); statement.setLong(2, bundle.bundle); statement.setLong(3, bundle.view); statement.execute(); } }

sample: 273
buggy_code: protected int getOverProvisioningFactor() { <START> return Integer.valueOf(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING)); <END> }
code_review: `Integer.parseInt`
target code: protected int getOverProvisioningFactor ( ) { return Integer . parseInt ( Framework . getProperty ( WORKMANAGER_OVERPROVISIONING_PROP , DEFAULT_WORKMANAGER_OVERPROVISIONING ) ) ; }
response: protected int getOverProvisioningFactor() { <START> return Integer.parseInt(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING)); <END> }

sample: 274
buggy_code: protected void onDestroy() { <START> super.onDestroy(); <END> webView.setDownloadListener(null); }
code_review: Please move `super.onDestroy` to the end of the method.
target code: protected void onDestroy ( ) { webView . setDownloadListener ( null ) ; super . onDestroy ( ) ; }
response: protected void onDestroy() { webView.setDownloadListener(null); <START> super.onDestroy(); <END> }

sample: 275
buggy_code: <START> public void closeTest() { <END> // request is keep-alive by default. HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString()); EmbeddedChannel channel = createEmbeddedChannel(); channel.writeInbound(request); // drain the channel of content. while (channel.readOutbound() != null) { ; } assertFalse("Channel should be closed", channel.isOpen()); }
code_review: Which part in this test calls `NettyResponseChannel.close()`?
target code: public void closeTest ( ) { // request is keep - alive by default . HttpRequest request = createRequestWithHeaders ( HttpMethod . GET , TestingUri . Close . toString ( ) ) ; EmbeddedChannel channel = createEmbeddedChannel ( ) ; channel . writeInbound ( request ) ; // drain the channel of content . while ( channel . readOutbound ( ) != null ) { } assertFalse ( "Channel should be closed" , channel . isOpen ( ) ) ; }
response: <START> public void closeTest() { <END> // request is keep-alive by default. HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString()); EmbeddedChannel channel = createEmbeddedChannel(); channel.writeInbound(request); // drain the channel of content. while (channel.readOutbound() != null) { ; } assertFalse("Channel should be closed", channel.isOpen()); }

sample: 276
buggy_code: public String getRuleLogsForVms() { <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("get_rule_logs_for_vms"); final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser(); final String result = cmd.execute(parser); if (result == null) { return parser.getLine(); } return null; }
code_review: Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion.
target code: public String getRuleLogsForVms ( ) { final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "get_rule_logs_for_vms" ) ; final OutputInterpreter . OneLineParser parser = new OutputInterpreter . OneLineParser ( ) ; final String result = cmd . execute ( parser ) ; if ( result == null ) { return parser . getLine ( ) ; } return null ; }
response: public String getRuleLogsForVms() { <START> final Script cmd = new Script(_securityGroupPath, _timeout, s_logger); <END> cmd.add("get_rule_logs_for_vms"); final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser(); final String result = cmd.execute(parser); if (result == null) { return parser.getLine(); } return null; }

sample: 277
buggy_code: private void addReporter(Class<? extends IReporter> r) { <START> m_reporters.put(r, ClassHelper.newInstance(r)); <END> }
code_review: We can avoid the instance creation if the reporter already exist
target code: private void addReporter ( Class < ? extends IReporter > r ) { if ( ! m_reporters . containsKey ( r ) ) { m_reporters . put ( r , ClassHelper . newInstance ( r ) ) ; } }
response: private void addReporter(Class<? extends IReporter> r) { <START> if (!m_reporters.containsKey(r)) { m_reporters.put(r, ClassHelper.newInstance(r)); } <END> }

sample: 278
buggy_code: <START> public final synchronized void addFunctions(List<? extends SqlFunction> functions) <END> { addFunctions(TEMP_DEFAULT_CATALOG, functions); }
code_review: Don't mark methods as `final`.
target code: public void addFunctions ( List < ? extends SqlFunction > functions ) { addFunctions ( TEMP_DEFAULT_CATALOG , functions ) ; }
response: <START> public synchronized void addFunctions(List<? extends SqlFunction> functions) <END> { addFunctions(TEMP_DEFAULT_CATALOG, functions); }

sample: 279
buggy_code: public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) { <START> if (oldInput != newInput) { <END> if (newInput != null) { ImportTraceContentProvider input = (ImportTraceContentProvider) newInput; clearCandidates(); fTraceTypes.putAll(input.fTraceTypes); fTraceFiles.putAll(fTraceFiles); } } }
code_review: You can join the ifs. There's a content assist for that, it's awesome.
target code: public synchronized void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( oldInput != newInput && newInput != null ) { ImportTraceContentProvider input = ( ImportTraceContentProvider ) newInput ; clearCandidates ( ) ; fTraceTypes . putAll ( input . fTraceTypes ) ; fTraceFiles . putAll ( fTraceFiles ) ; } }
response: public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) { <START> if (oldInput != newInput && newInput != null) { <END> ImportTraceContentProvider input = (ImportTraceContentProvider) newInput; clearCandidates(); fTraceTypes.putAll(input.fTraceTypes); fTraceFiles.putAll(fTraceFiles); } }

sample: 280
buggy_code: <START> boolean isPowerManagementLegal() { <END> return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup() .getcompatibility_version().toString()); }
code_review: please set a modifier - protected seem suitable
target code: protected boolean isPowerManagementLegal ( ) { return IsPowerManagementLegal ( getParameters ( ) . getVdsStaticData ( ) , getVdsGroup ( ) . getcompatibility_version ( ) . toString ( ) ) ; }
response: <START> protected boolean isPowerManagementLegal() { <END> return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup() .getcompatibility_version().toString()); }

sample: 281
buggy_code: public void info(String message) { <START> System.out.println(message); <END> info.add(message); }
code_review: Should avoid `System.out` in tests. Instead can you write to log4j
target code: public void info ( String message ) { info . add ( message ) ; }
response: public void info(String message) { <START> log.info(message); <END> info.add(message); }

sample: 282
buggy_code: public static File makeNumericDimFile(File dir, String dimension, ByteOrder order) { <START> return new File(dir, StringUtils.safeFormat("numeric_dim_%s_%s.drd", dimension, order)); <END> }
code_review: Probably should crash if bad format string
target code: public static File makeNumericDimFile ( File dir , String dimension , ByteOrder order ) { return new File ( dir , StringUtils . format ( "numeric_dim_ % s_ % s . drd" , dimension , order ) ) ; }
response: public static File makeNumericDimFile(File dir, String dimension, ByteOrder order) { <START> return new File(dir, StringUtils.format("numeric_dim_%s_%s.drd", dimension, order)); <END> }

sample: 283
buggy_code: private AuditLogableBase createAuditLog(final VmNic iface) { AuditLogableBase logable = new AuditLogableBase(); <START> logable.setVmId(iface.getVmId()); <END> logable.addCustomValue("MACAddr", iface.getMacAddress()); logable.addCustomValue("IfaceName", iface.getName()); return logable; }
code_review: Is there any longer a need for the VM ID ?
target code: private AuditLogableBase createAuditLog ( final VmNic iface ) { AuditLogableBase logable = new AuditLogableBase ( ) ; logable . addCustomValue ( "MACAddr" , iface . getMacAddress ( ) ) ; logable . addCustomValue ( "IfaceName" , iface . getName ( ) ) ; return logable ; }
response: private AuditLogableBase createAuditLog(final VmNic iface) { AuditLogableBase logable = new AuditLogableBase(); <START> logable.setVmId(iface.getVmId()); logable.addCustomValue("MACAddr", iface.getMacAddress()); <END> logable.addCustomValue("IfaceName", iface.getName()); return logable; }

sample: 284
buggy_code: public boolean equals( VirtualValue other ) { <START> if ( other == null || !(other instanceof MapValue) ) <END> { return false; } MapValue that = (MapValue) other; return size() == that.size() && Arrays.equals( keys, that.keys ) && Arrays.equals( values, that.values ); }
code_review: same here, redundant?
target code: public boolean equals ( VirtualValue other ) { if ( other == null || other . getClass ( ) != MapValue . class ) { return false ; } MapValue that = ( MapValue ) other ; return map . equals ( that . map ) ; }
response: public boolean equals( VirtualValue other ) { <START> if ( other == null || !(other instanceof MapValue) ) <END> { return false; } MapValue that = (MapValue) other; return size() == that.size() && Arrays.equals( keys, that.keys ) && Arrays.equals( values, that.values ); }

sample: 285
buggy_code: private void processSingleClusterChanges(ManageNetworkClustersParameters param) { final List<ActionParametersBase> setupNetworksParams = new ArrayList<>( createNetworkClustersToSetupNetworksParametersTransformer().transform( param.getAttachments(), param.getDetachments(), param.getUpdates()) ); HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams); setupNetworksParams.forEach(this::withRootCommandInfo); <START> runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext()); <END> }
code_review: nit: Formatting
target code: private void processSingleClusterChanges ( ManageNetworkClustersParameters param ) { final List < ActionParametersBase > setupNetworksParams = new ArrayList < > ( createNetworkClustersToSetupNetworksParametersTransformer ( ) . transform ( param . getAttachments ( ) , param . getDetachments ( ) , param . getUpdates ( ) ) ) ; HostSetupNetworksParametersBuilder . updateParametersSequencing ( setupNetworksParams ) ; setupNetworksParams . forEach ( this : : withRootCommandInfo ) ; runInternalMultipleActions ( ActionType . PersistentHostSetupNetworks , setupNetworksParams ) ; }
response: private void processSingleClusterChanges(ManageNetworkClustersParameters param) { final List<ActionParametersBase> setupNetworksParams = new ArrayList<>( createNetworkClustersToSetupNetworksParametersTransformer().transform( param.getAttachments(), param.getDetachments(), param.getUpdates()) ); HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams); setupNetworksParams.forEach(this::withRootCommandInfo); <START> runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext()); <END> }

sample: 286
buggy_code: <START> private void setFixedLengthStreamingMode(HttpURLConnection connection, long length) { <END> try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter! HttpURLConnection.class.getMethod("setFixedLengthStreamingMode", long.class).invoke(connection, length); } catch (Exception e) { throw new IllegalArgumentException("Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations." + " Use chunked encoding or multi-part upload, if possible, or use a different http driver." + " For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"); } }
code_review: [minor] Can be static?
target code: private static void setFixedLengthStreamingMode ( HttpURLConnection connection , long length ) { try { // Not caching method as invocation is literally sending > 2GB , which means reflection isn't a limiter ! HttpURLConnection . class . getMethod ( "setFixedLengthStreamingMode" , long . class ) . invoke ( connection , length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Cannot transfer 2 GB or larger chunks due to JDK 1 . 6 limitations . " + " Use chunked encoding or multi - part upload , if possible , or use a different http driver . " + " For more information : http :/ / bugs . sun . com / bugdatabase / view_bug . do ? bug_id = 6755625" ) ; } }
response: <START> private static void setFixedLengthStreamingMode(HttpURLConnection connection, long length) { <END> try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter! HttpURLConnection.class.getMethod("setFixedLengthStreamingMode", long.class).invoke(connection, length); } catch (Exception e) { throw new IllegalArgumentException("Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations." + " Use chunked encoding or multi-part upload, if possible, or use a different http driver." + " For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"); } }

sample: 287
buggy_code: <START> String getErrorMessage(ClientResponse clientResponse) { <END> String response = clientResponse.getEntity(String.class); try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser().readValue(response, ApiError.class); return error.getMessage(); } catch (IOException e) { // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever) int statusCode = clientResponse.getStatus(); ClientResponse.Status status = clientResponse.getClientResponseStatus(); String responseText = clientResponse.getEntity(String.class); return "Server returned "+status+"("+statusCode+"); "+responseText; } }
code_review: Method should probably be protected, given writing this for sub-classing.
target code: protected String getErrorMessage ( ClientResponse clientResponse ) { String response = clientResponse . getEntity ( String . class ) ; try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser ( ) . readValue ( response , ApiError . class ) ; return error . getMessage ( ) ; } catch ( IOException e ) { // If not , inform the user of the underlying response ( e . g . if server threw NPE or whatever ) int statusCode = clientResponse . getStatus ( ) ; ClientResponse . Status status = clientResponse . getClientResponseStatus ( ) ; String responseText = clientResponse . getEntity ( String . class ) ; return "Server returned " + status + " ( " + statusCode + " ) ; " + responseText ; } }
response: <START> protected String getErrorMessage(ClientResponse clientResponse) { <END> String response = clientResponse.getEntity(String.class); try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser().readValue(response, ApiError.class); return error.getMessage(); } catch (IOException e) { // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever) int statusCode = clientResponse.getStatus(); ClientResponse.Status status = clientResponse.getClientResponseStatus(); String responseText = clientResponse.getEntity(String.class); return "Server returned "+status+"("+statusCode+"); "+responseText; } }

sample: 288
buggy_code: public int hashCode() { int bits = 1; bits = 31 * bits + this.type.ordinal(); bits = 31 * bits + getToX(); bits = 31 * bits + getToY(); bits = 31 * bits + getToZ(); bits = 31 * bits + getFromX(); bits = 31 * bits + getFromY(); bits = 31 * bits + getFromZ(); <START> return bits; <END> }
code_review: `b ^ (b >> 31)` is missed here.
target code: public int hashCode ( ) { int bits = 1 ; bits = 31 * bits + this . type . ordinal ( ) ; bits = 31 * bits + getToX ( ) ; bits = 31 * bits + getToY ( ) ; bits = 31 * bits + getToZ ( ) ; bits = 31 * bits + getFromX ( ) ; bits = 31 * bits + getFromY ( ) ; bits = 31 * bits + getFromZ ( ) ; return bits ^ ( bits > > 31 ) ; }
response: public int hashCode() { int bits = 1; bits = 31 * bits + this.type.ordinal(); bits = 31 * bits + getToX(); bits = 31 * bits + getToY(); bits = 31 * bits + getToZ(); bits = 31 * bits + getFromX(); bits = 31 * bits + getFromY(); bits = 31 * bits + getFromZ(); <START> return bits ^ (bits >> 31); <END> }

sample: 289
buggy_code: public static AccountCollection all(Map<String, Object> params) throws AuthenticationException, InvalidRequestException, APIConnectionException, CardException, APIException { <START> return request(RequestMethod.GET, classURL(Account.class), params, AccountCollection.class, (RequestOptions) null); <END> }
code_review: This should call all ``` java return all(params, (RequestOptions) null); ```
target code: public static AccountCollection all ( Map < String , Object > params ) throws AuthenticationException , InvalidRequestException , APIConnectionException , CardException , APIException { return all ( params , ( RequestOptions ) null ) ; }
response: public static AccountCollection all(Map<String, Object> params) throws AuthenticationException, InvalidRequestException, APIConnectionException, CardException, APIException { <START> return all(params, (RequestOptions) null); <END> }

sample: 290
buggy_code: public void onSaveClick() { editView.setSaveState(true); WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient(); <START> client.submitDescription(pageTitle, editView.getDescription(), <END> new WikidataDescriptionEditDataClient.Callback() { @Override public void success() { editView.setSaveState(false); L.i("WD description edit successful"); // TODO: go to success fragment } @Override public void failure(@NonNull Throwable caught) { editView.setSaveState(false); L.e("WD description edit failed: ", caught); // TODO: go to failure fragment } }); }
code_review: Since this is a Fragment with a lifecycle, consider holding a reference to Call<?> and canceling it in onDestroy() if Call<?> is nonnull.
target code: public void onSaveClick ( ) { editView . setSaveState ( true ) ; if ( client == null ) { client = new WikidataDescriptionEditDataClient ( ) ; } client . request ( pageTitle , editView . getDescription ( ) , new WikidataDescriptionEditDataClient . Callback ( ) { @Override public void success ( ) { editView . setSaveState ( false ) ; L . i ( "WD description edit successful" ) ; // TODO : go to success fragment } @Override public void failure ( @NonNull Throwable caught ) { editView . setSaveState ( false ) ; L . e ( "WD description edit failed : " , caught ) ; // TODO : go to failure fragment } } ) ; }
response: public void onSaveClick() { editView.setSaveState(true); WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient(); <START> Call<Void> call = client.submitDescription(pageTitle, editView.getDescription(), <END> new WikidataDescriptionEditDataClient.Callback() { @Override public void success() { editView.setSaveState(false); L.i("WD description edit successful"); // TODO: go to success fragment } @Override public void failure(@NonNull Throwable caught) { editView.setSaveState(false); L.e("WD description edit failed: ", caught); // TODO: go to failure fragment } }); }

sample: 291
buggy_code: protected ResourceSet loadResource(IEditorInput editorInput) { <START> final URI resourceURI = EditUIUtil.getURI(getEditorInput(), null); <END> return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack()); }
code_review: why not use the passed in editorInput
target code: protected ResourceSet loadResource ( IEditorInput editorInput ) { final URI resourceURI = EditUIUtil . getURI ( editorInput , null ) ; return ResourceSetHelpers . loadResourceSetWithProxies ( resourceURI , getCommandStack ( ) ) ; }
response: protected ResourceSet loadResource(IEditorInput editorInput) { <START> final URI resourceURI = EditUIUtil.getURI(editorInput, null); <END> return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack()); }

sample: 292
buggy_code: FileReftableStack.CompactionStats getCompactionStats() <START> throws IOException { <END> return reftableStack.getStats(); }
code_review: declared exception isn't thrown
target code: FileReftableStack . CompactionStats getCompactionStats ( ) { return reftableStack . getStats ( ) ; }
response: FileReftableStack.CompactionStats getCompactionStats() { return reftableStack.getStats(); }

sample: 293
buggy_code: public OnlineBackup incremental( String targetDirectory ) { outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ), <START> getConsistencyCheck( true ), timeoutMillis, defaultConfig() ); <END> return this; }
code_review: This changes default behaviour, right? Should it?
target code: public OnlineBackup incremental ( String targetDirectory ) { outcome = new BackupService ( ) . doIncrementalBackup ( hostNameOrIp , port , new File ( targetDirectory ) , getConsistencyCheck ( false ) , timeoutMillis , defaultConfig ( ) ) ; return this ; }
response: public OnlineBackup incremental( String targetDirectory ) { outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ), <START> getConsistencyCheck( true ), timeoutMillis, defaultConfig() ); <END> return this; }

sample: 294
buggy_code: private boolean isValidConfiguration() { if (isDiscarding() || isCalleeData()) { return isAsync(); } else { return true; <START> } <END> }
code_review: This could just be `return !(isDiscarding() || isCalleeData()) || isAsync();`
target code: private boolean isValidConfiguration ( ) { return ! ( isDiscarding ( ) || isCalleeData ( ) ) || isAsync ( ) ; }
response: private boolean isValidConfiguration() { return !(isDiscarding() || isCalleeData()) || isAsync(); <START> } <END> }

sample: 295
buggy_code: public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException { boolean ret = super.setTrace(trace); if (!ret) { return ret; } ret = fCriticalPathModule.setTrace(trace); <START> fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); <END> return ret; }
code_review: should this be set if ret is false? I don't know.
target code: public boolean setTrace ( @NonNull ITmfTrace trace ) throws TmfAnalysisException { boolean ret = super . setTrace ( trace ) ; if ( ! ret ) { return ret ; } ret = fCriticalPathModule . setTrace ( trace ) ; if ( ret ) { fCriticalPathModule . setParameter ( CriticalPathModule . PARAM_GRAPH , getId ( ) ) ; } return ret ; }
response: public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException { boolean ret = super.setTrace(trace); if (!ret) { return ret; } ret = fCriticalPathModule.setTrace(trace); <START> if (ret) { fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); } <END> return ret; }

sample: 296
buggy_code: public void fillContextMenu(final IMenuManager menu) { super.fillContextMenu(menu); final ISelection selection = getContext().getSelection(); if (selection.isEmpty()) { return; } // Wait the end of the loading of the representations file try { Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor()); } catch (InterruptedException e) { <START> throw new RuntimeException(e); <END> } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown. // Fill the context menu contextMenuFiller.fillContextMenu(menu, selection); }
code_review: Before, with waitOtherJobs, we "Do nothing" in case of InterruptedException. Why do you change that? Have you test the difference?
target code: public void fillContextMenu ( final IMenuManager menu ) { super . fillContextMenu ( menu ) ; final ISelection selection = getContext ( ) . getSelection ( ) ; if ( selection . isEmpty ( ) ) { return ; } // Wait the end of the loading of the representations file try { Job . getJobManager ( ) . join ( AbstractRepresentationsFileJob . FAMILY , new NullProgressMonitor ( ) ) ; } catch ( InterruptedException e ) { // Do nothing } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown . // Fill the context menu contextMenuFiller . fillContextMenu ( menu , selection ) ; }
response: public void fillContextMenu(final IMenuManager menu) { super.fillContextMenu(menu); final ISelection selection = getContext().getSelection(); if (selection.isEmpty()) { return; } // Wait the end of the loading of the representations file try { Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor()); } catch (InterruptedException e) { <START> // Do nothing <END> } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown. // Fill the context menu contextMenuFiller.fillContextMenu(menu, selection); }

sample: 297
buggy_code: public void dispose() { // run super. super.dispose(); // remove ourselves as a selection and registry listener getSite().getPage().removePostSelectionListener(this); RegistryFactory.getRegistry().removeListener(this); SaveablesList saveables = <START> (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); <END> if (saveables != null) { saveables.removeModelLifecycleListener(saveablesTracker); } currentPart = null; currentSelection = null; pinPropertySheetAction = null; }
code_review: Are you sure about that cast operation? You are asking for a service interface and cast it to a concrete implementation without instanceof check. You perform that check in the tracker that is only added to a SaveablesList.
target code: public void dispose ( ) { // run super . super . dispose ( ) ; // remove ourselves as a selection and registry listener getSite ( ) . getPage ( ) . removePostSelectionListener ( this ) ; RegistryFactory . getRegistry ( ) . removeListener ( this ) ; ISaveablesLifecycleListener saveables = getSite ( ) . getService ( ISaveablesLifecycleListener . class ) ; if ( saveables instanceof SaveablesList ) { ( ( SaveablesList ) saveables ) . removeModelLifecycleListener ( saveablesTracker ) ; } currentPart = null ; currentSelection = null ; pinPropertySheetAction = null ; }
response: public void dispose() { // run super. super.dispose(); // remove ourselves as a selection and registry listener getSite().getPage().removePostSelectionListener(this); RegistryFactory.getRegistry().removeListener(this); SaveablesList saveables = <START> (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); <END> if (saveables != null) { saveables.removeModelLifecycleListener(saveablesTracker); } currentPart = null; currentSelection = null; pinPropertySheetAction = null; }

sample: 298
buggy_code: public void setBaseballCard(BaseballCard card) { Locale locale = Locale.getDefault(); brand.setText(card.brand); year.setText(String.format(locale, "%d", card.year)); <START> number.setText(String.format(locale, "%s", card.number)); <END> player.setText(card.playerName); }
code_review: `String.format()` is no longer necessary here.
target code: public void setBaseballCard ( BaseballCard card ) { Locale locale = Locale . getDefault ( ) ; brand . setText ( card . brand ) ; year . setText ( String . format ( locale , " % d" , card . year ) ) ; number . setText ( card . number ) ; player . setText ( card . playerName ) ; }
response: public void setBaseballCard(BaseballCard card) { Locale locale = Locale.getDefault(); brand.setText(card.brand); year.setText(String.format(locale, "%d", card.year)); <START> number.setText(card.number); <END> player.setText(card.playerName); }

sample: 299
buggy_code: <START> private String capitalize(String word) { <END> return Character.toUpperCase(word.charAt(0)) + word.substring(1); }
code_review: Can be static
target code: private static String capitalize ( String word ) { return Character . toUpperCase ( word . charAt ( 0 ) ) + word . substring ( 1 ) ; }
response: <START> private static String capitalize(String word) { <END> return Character.toUpperCase(word.charAt(0)) + word.substring(1); }

sample: 300
buggy_code: <START> private static boolean isStringParameter( <END> @NonNull Expression expression, @NonNull JavaContext context) { if (expression instanceof StringLiteral) { return true; } else { JavaParser.ResolvedNode resolvedNode = context.resolve(expression); if (resolvedNode instanceof JavaParser.ResolvedField) { if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) { return true; } } } return false; }
code_review: instead of this, use (at the callsite where you have the JavaContext) TypeDescriptor type = context.getType(expression); return type != null && type.matchesSignature(JavaContext.TYPE_STRING);
target code: private static boolean isStringParameter ( @NonNull Expression expression , @NonNull JavaContext context ) { if ( expression instanceof StringLiteral ) { return true ; } else { ResolvedNode resolvedNode = context . resolve ( expression ) ; if ( resolvedNode instanceof ResolvedField ) { if ( ( ( ResolvedField ) resolvedNode ) . getValue ( ) instanceof String ) { return true ; } } } return false ; }
response: <START> private static boolean isStringParameter( <END> @NonNull Expression expression, @NonNull JavaContext context) { if (expression instanceof StringLiteral) { return true; } else { JavaParser.ResolvedNode resolvedNode = context.resolve(expression); if (resolvedNode instanceof JavaParser.ResolvedField) { if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) { return true; } } } return false; }

sample: 301
buggy_code: protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) { <START> TopologyDetails td = getNextHighest(); <END> return getScore(availableCpu, availableMemory, availableGenericResources, td); }
code_review: Nit: could we inline this to avoid unnecessary object creation
target code: protected double getScore ( double availableCpu , double availableMemory , Map < String , Double > availableGenericResources ) { return getScore ( availableCpu , availableMemory , availableGenericResources , getNextHighest ( ) ) ; }
response: protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) { <START> TopologyDetails td = getNextHighest(); <END> return getScore(availableCpu, availableMemory, availableGenericResources, td); }

sample: 302
buggy_code: public <T extends Action> List<T> getActions(Class<T> type) { <START> List<T> _actions = Util.filter(getPersistedActions(), type); <END> for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) { _actions.addAll(Util.filter(createFor(taf), type)); } return Collections.unmodifiableList(_actions); }
code_review: I think this should be reverted, so it would still take into account additions from pre-`TransientActionFactory` implementations.
target code: public < T extends Action > List < T > getActions ( Class < T > type ) { List < T > _actions = Util . filter ( getActions ( ) , type ) ; for ( TransientActionFactory < ? > taf : TransientActionFactory . factoriesFor ( getClass ( ) , type ) ) { _actions . addAll ( Util . filter ( createFor ( taf ) , type ) ) ; } return Collections . unmodifiableList ( _actions ) ; }
response: public <T extends Action> List<T> getActions(Class<T> type) { <START> List<T> _actions = Util.filter(getPersistedActions(), type); <END> for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) { _actions.addAll(Util.filter(createFor(taf), type)); } return Collections.unmodifiableList(_actions); }

sample: 303
buggy_code: public void addRepresentation (ImageData srcImageData, int zoom) { if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT); int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom); if (imageSelectorIndex == device.getImageSelector ()) { init(srcImageData); <START> init(); <END> } else { data [imageSelectorIndex] = srcImageData; } }
code_review: ImageData for current image needs to be updated in the array?
target code: public void addRepresentation ( ImageData srcImageData , int zoom ) { if ( srcImageData == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; int imageSelectorIndex = DPIUtil . mapZoomToImageSelectorIndex ( zoom ) ; if ( imageSelectorIndex == getImageSelector ( ) ) { init ( srcImageData ) ; init ( ) ; } data [ imageSelectorIndex ] = srcImageData ; }
response: public void addRepresentation (ImageData srcImageData, int zoom) { if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT); int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom); if (imageSelectorIndex == device.getImageSelector ()) { init(srcImageData); <START> data [imageSelectorIndex] = srcImageData; <END> } else { data [imageSelectorIndex] = srcImageData; } }

sample: 304
buggy_code: private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType); <START> defaultEnvironment.setup(); <END> return defaultEnvironment; }
code_review: you don't need to do that if you're already calling `loadProperties` in the public constructor, right? https://github.com/caelum/vraptor4/pull/973/files#diff-b7b62c45c7478eb642acfb81c12a4227R82
target code: private DefaultEnvironment buildEnvironment ( EnvironmentType environmentType ) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment ( environmentType ) ; return defaultEnvironment ; }
response: private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType); return defaultEnvironment; }

sample: 305
buggy_code: public int hashCode() { <START> return getRepositoryName() != null ? getRepositoryName().hashCode() : <END> System.identityHashCode(this); }
code_review: Style-nit: This is hard to read. Maybe: if (getRepositoryName() != null) return getRepositoryName().hashCode(); return System.identityHashCode(this);
target code: public int hashCode ( ) { if ( getRepositoryName ( ) != null ) return getRepositoryName ( ) . hashCode ( ) ; return System . identityHashCode ( this ) ; }
response: public int hashCode() { <START> if (getRepositoryName() != null) return getRepositoryName().hashCode(); return <END> System.identityHashCode(this); }

sample: 306
buggy_code: public List<String> getExtensions() { <START> return extensions == null ? DEFAULT_EXTS : extensions; <END> }
code_review: Can be removed and return only extensions without assigning logic.
target code: public List < String > getExtensions ( ) { return extensions ; }
response: public List<String> getExtensions() { <START> return extensions; <END> }

sample: 307
buggy_code: public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria(); addRestrictionOnPatient(radiologyOrderCriteria, patient); <START> List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list(); <END> return result == null ? new ArrayList<RadiologyOrder>() : result; }
code_review: use final
target code: public List < RadiologyOrder > getRadiologyOrdersByPatient ( Patient patient ) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria ( ) ; addRestrictionOnPatient ( radiologyOrderCriteria , patient ) ; final List < RadiologyOrder > result = ( List < RadiologyOrder > ) radiologyOrderCriteria . list ( ) ; return result == null ? new ArrayList < RadiologyOrder > ( ) : result ; }
response: public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria(); addRestrictionOnPatient(radiologyOrderCriteria, patient); <START> final List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list(); <END> return result == null ? new ArrayList<RadiologyOrder>() : result; }

sample: 308
buggy_code: public Weld addExtensions(Class<? extends Extension>... extensionClasses) { <START> Object[] constructorParams = new Object[] {}; <END> for (Class<? extends Extension> extensionClass : extensionClasses) { try { Extension extension = SecurityActions.newInstance(extensionClass); addExtension(extension); } catch (Exception ex) { CommonLogger.LOG.unableToInstantiate(extensionClass, constructorParams, ex); } } return this; }
code_review: This variable is useless in most cases. I would rather pass `new Object[] {}` to log method directly.
target code: public Weld addExtensions ( Class < ? extends Extension > . . . extensionClasses ) { for ( Class < ? extends Extension > extensionClass : extensionClasses ) { try { Extension extension = SecurityActions . newInstance ( extensionClass ) ; addExtension ( extension ) ; } catch ( Exception ex ) { CommonLogger . LOG . unableToInstantiate ( extensionClass , new Object [ ] { } , ex ) ; } } return this ; }
response: public Weld addExtensions(Class<? extends Extension>... extensionClasses) { for (Class<? extends Extension> extensionClass : extensionClasses) { try { Extension extension = SecurityActions.newInstance(extensionClass); addExtension(extension); } catch (Exception ex) { CommonLogger.LOG.unableToInstantiate(extensionClass, new Object[] {}, ex); } } return this; }

sample: 309
buggy_code: public RTTestsParser() { super(Messages._Warnings_RTTests_ParserName(), Messages._Warnings_RTTests_LinkName(), Messages._Warnings_RTTests_TrendName(), <START> CYCLICTEST_WARNING_PATTERN, true); <END> }
code_review: If the last parameter is `true` then you need to overwrite `isLineInteresting`.
target code: public RTTestsParser ( ) { super ( Messages . _Warnings_RTTests_ParserName ( ) , Messages . _Warnings_RTTests_LinkName ( ) , Messages . _Warnings_RTTests_TrendName ( ) , CYCLICTEST_WARNING_PATTERN ) ; }
response: public RTTestsParser() { super(Messages._Warnings_RTTests_ParserName(), Messages._Warnings_RTTests_LinkName(), Messages._Warnings_RTTests_TrendName(), <START> CYCLICTEST_WARNING_PATTERN, true); <END> }

sample: 310
buggy_code: private ValidationResult hostExists() { <START> if (getVds() == null) { <END> return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST); } return ValidationResult.VALID; }
code_review: You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
target code: private ValidationResult hostExists ( ) { return getVds ( ) == null ? new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_HOST_NOT_EXIST ) : ValidationResult . VALID ; }
response: private ValidationResult hostExists() { <START> return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID; <END> }

sample: 311
buggy_code: public static ToolTipString fromString(String text) { <START> Objects.requireNonNull(text, "fromString cannot take null"); //$NON-NLS-1$ <END> return new ToolTipString(text, toHtmlString(text)); }
code_review: You can remove all the requireNonNull due to @NNBD. I'm surprised we're allowed to use it, doing an explicit null check would be a compilation error...
target code: public static ToolTipString fromString ( String text ) { return new ToolTipString ( text , toHtmlString ( text ) ) ; }
response: public static ToolTipString fromString(String text) { <START> return new ToolTipString(text, toHtmlString(text)); }

sample: 312
buggy_code: public DataRadioStation getNextById(String id) { <START> if (listStations.size() == 0) <END> return null; for (int i = 0; i < listStations.size() - 1; i++) { if (listStations.get(i).ID.equals(id)) { return listStations.get(i + 1); } } return listStations.get(0); }
code_review: `if (listStations.isEmpty())`
target code: public DataRadioStation getNextById ( String id ) { if ( listStations . isEmpty ( ) ) return null ; for ( int i = 0 ; i < listStations . size ( ) - 1 ; i ++ ) { if ( listStations . get ( i ) . ID . equals ( id ) ) { return listStations . get ( i + 1 ) ; } } return listStations . get ( 0 ) ; }
response: public DataRadioStation getNextById(String id) { <START> if (listStations.isEmpty()) <END> return null; for (int i = 0; i < listStations.size() - 1; i++) { if (listStations.get(i).ID.equals(id)) { return listStations.get(i + 1); } } return listStations.get(0); }

sample: 313
buggy_code: public static void setBiomeArrayMethod(boolean jeidPresent) { try { if (jeidPresent) { biomeArrayMethod = Chunk.class.getMethod("getIntBiomeArray"); } else <START> biomeArrayMethod = Chunk.class.getMethod("getBiomeArray"); <END> } catch (NoSuchMethodException e) { throw new RuntimeException(e); } }
code_review: Please add the `{}` for the one-liner
target code: public static void setBiomeArrayMethod ( boolean jeidPresent ) { try { if ( jeidPresent ) { biomeArrayMethod = Chunk . class . getMethod ( "getIntBiomeArray" ) ; } else { biomeArrayMethod = Chunk . class . getMethod ( "getBiomeArray" ) ; } } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } }
response: public static void setBiomeArrayMethod(boolean jeidPresent) { try { if (jeidPresent) { biomeArrayMethod = Chunk.class.getMethod("getIntBiomeArray"); } else { biomeArrayMethod = Chunk.class.getMethod("getBiomeArray"); } } catch (NoSuchMethodException e) { throw new RuntimeException(e); } }

sample: 314
buggy_code: public String getDescription() { return "Transform files representing a structured table under an Alluxio directory." + "\n\n" + "Files are coalesced and converted to parquet format." + "\n\n" + "Definition is in format like 'write(hive).option(hive.num.files, 100)'," + "currently, the only modification you can do to the example definition is " <START> + "the number of files in the option." <END> }
code_review: I think since this will change in future release, it's better to let it be here so it's easier to update.
target code: public String getDescription ( ) { return "Transform files representing a structured table under an Alluxio directory . " + "\n\n" + "Files are coalesced and converted to parquet format . " + "\n\n" + "Definition is in format like 'write ( hive ) . option ( hive . num . files , 100 ) ' , " + "currently , the only modification you can do to the example definition is " + "the number of files in the option . " ; }
response: public String getDescription() { return "Transform files representing a structured table under an Alluxio directory." + "\n\n" + "Files are coalesced and converted to parquet format." + "\n\n" + "Definition is in format like 'write(hive).option(hive.num.files, 100)'," + "currently, the only modification you can do to the example definition is " + "the number of files in the option." }

sample: 315
buggy_code: <START> public static void validateNonNegative(int[] data, String paramName){ <END> boolean nonnegative = true; for(int value : data){ if(value < 0) { nonnegative = false; } } Preconditions.checkArgument(nonnegative, "Values for %s must be >= 0, got: %s", paramName, data); }
code_review: Handling of nulls? You have some in the later methods, but not here... If null is acceptable, we should return null here. If not, let's either add a lombok ```@NonNull``` or a ```Preconditions.checkNotNull(```. At present, nulls will give a non-useful NPE.
target code: public static void validateNonNegative ( int [ ] data , String paramName ) { if ( data == null ) { return ; } boolean nonnegative = true ; for ( int value : data ) { if ( value < 0 ) { nonnegative = false ; } } Preconditions . checkArgument ( nonnegative , "Values for % s must be >= 0 , got : % s" , paramName , data ) ; }
response: <START> public static void validateNonNegative(int[] data, String paramName){ <END> boolean nonnegative = true; for(int value : data){ if(value < 0) { nonnegative = false; } } Preconditions.checkArgument(nonnegative, "Values for %s must be >= 0, got: %s", paramName, data); }

sample: 316
buggy_code: <START> public SetContentTypeFilter() { <END> try { mimetypeToExtensionMap = new Properties(); mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream( "mimetypeToExtension.txt"))); contentTypeProperties = new Properties(); contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream( "toContentType.properties"))); } catch (IOException e) { log.error("Failed to load mimetype mappings", e); } }
code_review: Looking at this (and i realize this is my own crappy code), its really a configuration error for the files to fail to load, and we really don't want to be eating that and just putting something in the log. Could you either remove the try block and make this constructor throw the IOException, or rethrow an exception with a little extra context? Up to you which you prefer.
target code: public SetContentTypeFilter ( ) throws IOException { mimetypeToExtensionMap = new Properties ( ) ; mimetypeToExtensionMap . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "mimetypeToExtension . txt" ) ) ) ; contentTypeProperties = new Properties ( ) ; contentTypeProperties . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "toContentType . properties" ) ) ) ; }
response: <START> public SetContentTypeFilter() throws IOException { <END> mimetypeToExtensionMap = new Properties(); mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream( "mimetypeToExtension.txt"))); contentTypeProperties = new Properties(); contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream( "toContentType.properties"))); }

sample: 317
buggy_code: private SwiftApi api(String authUrl, Properties overrides) throws IOException { if (overrides == null){ overrides = new Properties(); <START> } <END> overrides.setProperty(CREDENTIAL_TYPE, "tempAuthCredentials"); return ContextBuilder.newBuilder(new SwiftApiMetadata()) .credentials("user", "password") .endpoint(authUrl) .overrides(overrides) .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor()))) .buildApi(SwiftApi.class); }
code_review: Instead of passing null, remove this check and call this method with a new Properties object.
target code: private SwiftApi api ( String authUrl , Properties overrides ) throws IOException { overrides . setProperty ( CREDENTIAL_TYPE , "tempAuthCredentials" ) ; return ContextBuilder . newBuilder ( new SwiftApiMetadata ( ) ) . credentials ( "user" , "password" ) . endpoint ( authUrl ) . overrides ( overrides ) . modules ( ImmutableSet . of ( new ExecutorServiceModule ( sameThreadExecutor ( ) ) ) ) . buildApi ( SwiftApi . class ) ; }
response: private SwiftApi api(String authUrl, Properties overrides) throws IOException { if (overrides == null){ overrides = new Properties(); <START> } <END> overrides.setProperty(CREDENTIAL_TYPE, "tempAuthCredentials"); return ContextBuilder.newBuilder(new SwiftApiMetadata()) .credentials("user", "password") .endpoint(authUrl) .overrides(overrides) .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor()))) .buildApi(SwiftApi.class); }

sample: 318
buggy_code: public void setAcceptableValues(Collection<K> values) { buttons.clear(); panels.clear(); wrapperPanel.clear(); <START> for (final K value : values) { <END> addValue(value); } updateButtons(); }
code_review: add null check
target code: public void setAcceptableValues ( Collection < K > values ) { buttons . clear ( ) ; panels . clear ( ) ; wrapperPanel . clear ( ) ; if ( values != null ) { for ( final K value : values ) { addValue ( value ) ; } } updateButtons ( ) ; }
response: public void setAcceptableValues(Collection<K> values) { buttons.clear(); panels.clear(); wrapperPanel.clear(); <START> if (values != null) { for (final K value : values) { <END> addValue(value); } } updateButtons(); }

sample: 319
buggy_code: public Bucket getOrCreateBucket(String bucketName) { try { Bucket bucket = storage.get(bucketName); if (bucket == null) { log.debug(String.format("Creating a new bucket %s", bucketName)); return storage.create(BucketInfo.of(bucketName)); } return bucket; } catch (StorageException e) { <START> throw new NuxeoException(e); <END> } }
code_review: `StorageException` is a runtime exception, no need to catch and rethrow it (several occurrences).
target code: public Bucket getOrCreateBucket ( String bucketName ) { Bucket bucket = storage . get ( bucketName ) ; if ( bucket == null ) { log . debug ( String . format ( "Creating a new bucket % s" , bucketName ) ) ; return storage . create ( BucketInfo . of ( bucketName ) ) ; } return bucket ; }
response: public Bucket getOrCreateBucket(String bucketName) { Bucket bucket = storage.get(bucketName); if (bucket == null) { log.debug(String.format("Creating a new bucket %s", bucketName)); return storage.create(BucketInfo.of(bucketName)); } return bucket; }

sample: 320
buggy_code: private void onFragmentLoaded() { if (searchAdapter == null) { searchAdapter = new SearchlistAdapter(getActivity(), itemAccess); setListAdapter(searchAdapter); } searchAdapter.notifyDataSetChanged(); setListShown(true); String query = getArguments().getString(ARG_QUERY); <START> setEmptyText(getString(R.string.no_results_for_query) + " \"" + query + "\""); <END> }
code_review: You need to keep in mind that the sentence construction in other languages could be different, so the query string doesn't always show at the end. You should use %1$s in your string on values/strings.xml and pass the query term as an extra argument to getString()
target code: private void onFragmentLoaded ( ) { if ( searchAdapter == null ) { searchAdapter = new SearchlistAdapter ( getActivity ( ) , itemAccess ) ; setListAdapter ( searchAdapter ) ; } searchAdapter . notifyDataSetChanged ( ) ; setListShown ( true ) ; String query = getArguments ( ) . getString ( ARG_QUERY ) ; setEmptyText ( getString ( R . string . no_results_for_query , query ) ) ; }
response: private void onFragmentLoaded() { if (searchAdapter == null) { searchAdapter = new SearchlistAdapter(getActivity(), itemAccess); setListAdapter(searchAdapter); } searchAdapter.notifyDataSetChanged(); setListShown(true); String query = getArguments().getString(ARG_QUERY); <START> setEmptyText(getString(R.string.no_results_for_query, query)); <END> }

sample: 321
buggy_code: private Iterable<Ref> getSortedRefs() throws Exception { List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL); <START> if (all instanceof RefMap <END> || (all instanceof SortedMap && ((SortedMap) all).comparator() == null)) { return all; } return RefComparator.sort(all); }
code_review: Thanks. Marking resolved.
target code: private Iterable < Ref > getSortedRefs ( ) throws Exception { List < Ref > all = db . getRefDatabase ( ) . getRefsByPrefix ( ALL ) ; // TODO ( jrn ) check if we can reintroduce fast - path by e . g . implementing // SortedList return RefComparator . sort ( all ) ; }
response: private Iterable<Ref> getSortedRefs() throws Exception { List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL); <START> if (all instanceof RefMap <END> || (all instanceof SortedMap && ((SortedMap) all).comparator() == null)) { return all; } return RefComparator.sort(all); }

sample: 322
buggy_code: private static void convertAAAProfilesResult(AsyncQuery aQuery) { aQuery.converterCallback = new IAsyncConverter() { @Override public Object Convert(Object source, AsyncQuery _asyncQuery) { List<String> results = new ArrayList<String>(); <START> for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source) <END> : new ArrayList<ProfileEntry>()) { results.add(profileEntry.getProfile()); } return results; } }; }
code_review: I don't understand why you need to create a new ArrayList for a collection that is coming from a query - it is necessarily not being used by anyone else. Also, why cast what's coming from the backend to an ArrayList? This means you're committing to a specific implementation. I think a cast to Collection is more appropriate. If it's important for you to have the end result in specifically an ArrayList (and not any other kind of collection), then I would create a new ArrayList, but still cast the result from the backend to Collection.
target code: private static void convertAAAProfilesResult ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { List < String > results = new ArrayList < String > ( ) ; for ( ProfileEntry profileEntry : source != null ? ( Collection < ProfileEntry > ) source : new ArrayList < ProfileEntry > ( ) ) { results . add ( profileEntry . getProfile ( ) ) ; } return results ; } } ; }
response: private static void convertAAAProfilesResult(AsyncQuery aQuery) { aQuery.converterCallback = new IAsyncConverter() { @Override public Object Convert(Object source, AsyncQuery _asyncQuery) { List<String> results = new ArrayList<String>(); <START> for (ProfileEntry profileEntry : source != null ? (Collection<ProfileEntry>) source : new ArrayList<ProfileEntry>()) { results.add(profileEntry.getProfile()); } return results; } }; }

sample: 323
buggy_code: <START> public FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier, <END> final CellEditorControlsView.Presenter cellEditorControls, final KindPopoverView.Presenter editor, final Optional<String> editorTitle, final FunctionGrid gridWidget) { super(cellEditorControls, editor, editorTitle); this.functionSupplier = functionSupplier; this.gridWidget = gridWidget; }
code_review: Since the `class` has _package_ protected access the constructor can probably have _package_ protection too?
target code: FunctionKindRowColumnHeaderMetaData ( final Supplier < FunctionDefinition > functionSupplier , final CellEditorControlsView . Presenter cellEditorControls , final KindPopoverView . Presenter editor , final Optional < String > editorTitle , final FunctionGrid gridWidget ) { super ( cellEditorControls , editor , editorTitle ) ; this . functionSupplier = functionSupplier ; this . gridWidget = gridWidget ; }
response: <START> FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier, <END> final CellEditorControlsView.Presenter cellEditorControls, final KindPopoverView.Presenter editor, final Optional<String> editorTitle, final FunctionGrid gridWidget) { super(cellEditorControls, editor, editorTitle); this.functionSupplier = functionSupplier; this.gridWidget = gridWidget; }

sample: 324
buggy_code: public List<ProxiedPlayer> matchPlayer(String partialName) { List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>(); for (ProxiedPlayer iPlayer : this.getPlayers()) { String iterPlayerName = iPlayer.getName(); if (partialName.equalsIgnoreCase(iterPlayerName)) { matched.add(iPlayer); break; } <START> if (iterPlayerName.toLowerCase().contains(partialName.toLowerCase())) { <END> matched.add(iPlayer); } } return matched; }
code_review: Wouldn't starts with make more sense?
target code: public List < ProxiedPlayer > matchPlayer ( String partialName ) { List < ProxiedPlayer > matched = new ArrayList < ProxiedPlayer > ( ) ; for ( ProxiedPlayer iPlayer : this . getPlayers ( ) ) { String iterPlayerName = iPlayer . getName ( ) ; if ( partialName . equalsIgnoreCase ( iterPlayerName ) ) { matched . add ( iPlayer ) ; break ; } if ( iterPlayerName . toLowerCase ( ) . startsWith ( partialName . toLowerCase ( ) ) ) { matched . add ( iPlayer ) ; } } return matched ; }
response: public List<ProxiedPlayer> matchPlayer(String partialName) { List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>(); for (ProxiedPlayer iPlayer : this.getPlayers()) { String iterPlayerName = iPlayer.getName(); if (partialName.equalsIgnoreCase(iterPlayerName)) { matched.add(iPlayer); break; } <START> if (iterPlayerName.toLowerCase().startsWith(partialName.toLowerCase())) { <END> matched.add(iPlayer); } } return matched; }

sample: 325
buggy_code: private int zigzagDecode(int input) { <START> return (input >> 1) ^ (-(input & 1)); <END> }
code_review: I notice in the unzigzag method below, you use the unsigned right shift operator (`>>>`), but here you're using the signed one (`>>`). Is that intentional?
target code: private int zigzagDecode ( int input ) { return ( input > > > 1 ) ^ ( - ( input & 1 ) ) ; }
response: private int zigzagDecode(int input) { <START> return (input >>> 1) ^ (-(input & 1)); <END> }

sample: 326
buggy_code: <START> public void testEqualsCondition() { doTest(GoStringIndexIsByteQuickFix.NAME); } <END>
code_review: Please create method`doTest() { doTest(GoStringIndexIsByteQuickFix.NAME); }` and maybe same method `doTestNoFix()`
target code: public void testEqualsCondition ( ) { doTest ( ) ; }
response: <START> public void testEqualsCondition() { doTest(); } <END>

sample: 327
buggy_code: public void testRedrawAfterDispose() { LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn(); CompositeRuler ruler= new CompositeRuler(); ruler.addDecorator(0, lineNumberRulerColumn); SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE); lineNumberRulerColumn.getControl().setSize(10, 10); sourceViewer.getTextWidget().dispose(); try { lineNumberRulerColumn.redraw(); } <START> catch (Exception <END> notExpected) { notExpected.printStackTrace(); fail(); } }
code_review: why do we need try/catch here? It should not fail, and if it fails, junit will take care about the stack etc
target code: public void testRedrawAfterDispose ( ) { LineNumberRulerColumn lineNumberRulerColumn = new LineNumberRulerColumn ( ) ; CompositeRuler ruler = new CompositeRuler ( ) ; ruler . addDecorator ( 0 , lineNumberRulerColumn ) ; SourceViewer sourceViewer = new SourceViewer ( fParent , ruler , SWT . NONE ) ; lineNumberRulerColumn . getControl ( ) . setSize ( 10 , 10 ) ; sourceViewer . getTextWidget ( ) . dispose ( ) ; lineNumberRulerColumn . redraw ( ) ; }
response: public void testRedrawAfterDispose() { LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn(); CompositeRuler ruler= new CompositeRuler(); ruler.addDecorator(0, lineNumberRulerColumn); SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE); lineNumberRulerColumn.getControl().setSize(10, 10); sourceViewer.getTextWidget().dispose(); lineNumberRulerColumn.redraw(); }

sample: 328
buggy_code: public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) { if (!_canBridgeFirewall) { return false; } <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("default_network_rules_systemvm"); cmd.add("--vmname", vmName); cmd.add("--localbrname", _linkLocalBridgeName); final String result = cmd.execute(); if (result != null) { return false; } return true; }
code_review: Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion.
target code: public boolean configureDefaultNetworkRulesForSystemVm ( final Connect conn , final String vmName ) { if ( ! _canBridgeFirewall ) { return false ; } final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "default_network_rules_systemvm" ) ; cmd . add ( " -- vmname" , vmName ) ; cmd . add ( " -- localbrname" , _linkLocalBridgeName ) ; final String result = cmd . execute ( ) ; if ( result != null ) { return false ; } return true ; }
response: public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) { if (!_canBridgeFirewall) { return false; } <START> final Script cmd = new Script(_securityGroupPath, _timeout, s_logger); <END> cmd.add("default_network_rules_systemvm"); cmd.add("--vmname", vmName); cmd.add("--localbrname", _linkLocalBridgeName); final String result = cmd.execute(); if (result != null) { return false; } return true; }

sample: 329
buggy_code: public void testQueryCumulativeTable() { computeActual("SELECT * FROM \"*:*\""); computeActual("SELECT * FROM \"java.util.logging:*\""); <START> assertTrue(computeActual("SELECT * FROM \"java.lang:*\"").getRowCount() > 0); <END> assertTrue(computeActual("SELECT * FROM \"jAVA.LANg:*\"").getRowCount() > 0); }
code_review: shouldn't it be `> 1`
target code: public void testQueryCumulativeTable ( ) { computeActual ( "SELECT * FROM \" * :* \"" ) ; computeActual ( "SELECT * FROM \"java . util . logging :* \"" ) ; assertTrue ( computeActual ( "SELECT * FROM \"java . lang :* \"" ) . getRowCount ( ) > 1 ) ; assertTrue ( computeActual ( "SELECT * FROM \"jAVA . LANg :* \"" ) . getRowCount ( ) > 1 ) ; }
response: public void testQueryCumulativeTable() { computeActual("SELECT * FROM \"*:*\""); computeActual("SELECT * FROM \"java.util.logging:*\""); <START> assertTrue(computeActual("SELECT * FROM \"java.lang:*\"").getRowCount() > 1); <END> assertTrue(computeActual("SELECT * FROM \"jAVA.LANg:*\"").getRowCount() > 1); }

sample: 330
buggy_code: public RequestLogger get() { LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC); <START> log.info(new Exception("Stack trace"), "Creating %s at", logger); <END> return logger; }
code_review: should these be `debug` level?
target code: public RequestLogger get ( ) { LoggingRequestLogger logger = new LoggingRequestLogger ( mapper , setMDC , setContextMDC ) ; log . debug ( new Exception ( "Stack trace" ) , "Creating % s at" , logger ) ; return logger ; }
response: public RequestLogger get() { LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC); <START> log.debug(new Exception("Stack trace"), "Creating %s at", logger); <END> return logger; }

sample: 331
buggy_code: private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) { String accessRecord = leak.toString(); if (StringUtil.isNullOrEmpty(accessRecord)) { // means leak has been closed and there is no accessRecord. return e; } <START> return new TrackedIllegalReferenceCountException(e.getMessage(), accessRecord); <END> }
code_review: shouldn't we wrap the original `e` ?
target code: private IllegalReferenceCountException handleIllegalReferenceCountException ( IllegalReferenceCountException e ) { String accessRecord = leak . toString ( ) ; if ( StringUtil . isNullOrEmpty ( accessRecord ) ) { // means leak has been closed and there is no accessRecord . return e ; } return new TrackedIllegalReferenceCountException ( accessRecord , e ) ; }
response: private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) { String accessRecord = leak.toString(); if (StringUtil.isNullOrEmpty(accessRecord)) { // means leak has been closed and there is no accessRecord. return e; } <START> return new TrackedIllegalReferenceCountException(e, accessRecord); <END> }

sample: 332
buggy_code: public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getAccountPayments(accountId, withPluginInfo, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext)); <END> }
code_review: The new flag `withAttempts` is not passed (used) the `paymentProcessor#getAccountPayments`
target code: public List < Payment > getAccountPayments ( final UUID accountId , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getAccountPayments ( accountId , withPluginInfo , withAttempts , tenantContext , internalCallContextFactory . createInternalTenantContext ( accountId , tenantContext ) ) ; }
response: public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getAccountPayments(accountId, withPluginInfo, withAttempts, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext)); <END> }

sample: 333
buggy_code: public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER); disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString()); retentionManager = Framework.getService(RetentionManager.class); <START> ruleId = (String) command.getParam(PARAM_RULE_ID); <END> }
code_review: No need to cast to `String`, here `getParam` is a generic method `public <T> T getParam(String key)`
target code: public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; Serializable auditParam = command . getParam ( NXAuditEventsService . DISABLE_AUDIT_LOGGER ) ; disableAudit = auditParam != null && Boolean . parseBoolean ( auditParam . toString ( ) ) ; retentionManager = Framework . getService ( RetentionManager . class ) ; ruleId = command . getParam ( PARAM_RULE_ID ) ; }
response: public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER); disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString()); retentionManager = Framework.getService(RetentionManager.class); <START> ruleId = command.getParam(PARAM_RULE_ID); <END> }

sample: 334
buggy_code: public boolean remove(Connection connection) { boolean removed = connectionPool.remove(connection); if (getHttpExchanges().isEmpty()) { tryRemoveIdleDestination(); } else { // We need to execute queued requests // even if this connection was removed. // We may create a connection that is not // needed, but it will eventually idle timeout. if (removed) <START> process(true); <END> } return connectionPool.remove(connection); }
code_review: should this check that the queue is not 0? Why acquire a connection if there are no waiting exchanges?
target code: public boolean remove ( Connection connection ) { boolean removed = connectionPool . remove ( connection ) ; if ( getHttpExchanges ( ) . isEmpty ( ) ) { tryRemoveIdleDestination ( ) ; } else if ( removed ) { // Process queued requests that may be waiting . // We may create a connection that is not // needed , but it will eventually idle timeout . process ( true ) ; } return removed ; }
response: public boolean remove(Connection connection) { boolean removed = connectionPool.remove(connection); if (getHttpExchanges().isEmpty()) { tryRemoveIdleDestination(); } else { // We need to execute queued requests // even if this connection was removed. // We may create a connection that is not // needed, but it will eventually idle timeout. if (removed) <START> process(true); <END> } return removed; }

sample: 335
buggy_code: public boolean getRewriteBatchedStatements() { final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS); <START> return isRewrite == null ? null : Boolean.valueOf(isRewrite); <END> }
code_review: return null ? I think you meant 'false', did not you?
target code: public boolean getRewriteBatchedStatements ( ) { final String isRewrite = super . connectionProperties . getProperty ( REWRITE_BATCHED_STATEMENTS ) ; return isRewrite == null ? false : Boolean . valueOf ( isRewrite ) ; }
response: public boolean getRewriteBatchedStatements() { final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS); <START> return isRewrite == null ? false : Boolean.valueOf(isRewrite); <END> }

sample: 336
buggy_code: public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon)); scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); <START> scheduler.setRemoveOnCancelPolicy(true); <END> return scheduler; }
code_review: I am little wary about this. coz, all our existing schedulers are using this and setting this might cause them to be removed immediately. Even though ideally we want to be in that position, when rolling this out, don't want to have any unexpected behaviors.
target code: public static ScheduledExecutorService newScheduler ( int numThreads , String threadNamePrefix , boolean isDaemon ) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor ( numThreads , new SchedulerThreadFactory ( threadNamePrefix , isDaemon ) ) ; scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; return scheduler ; }
response: public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon)); scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); <START> scheduler.setRemoveOnCancelPolicy(true); return scheduler; <END> }

sample: 337
buggy_code: public boolean setValue(T newValue) { if (!validator.validate(newValue)) { <START> LOGGER.warn("The passed value {} is invalid.", newValue); <END> return false; } PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue); this.value = newValue; dispatchChangedEvent(event); return true; }
code_review: Ah, that's what you meant. =) No, this isn't good: it's too generic, it wouldn't help you debug a failure. The validator itself has to log a warning and then return false, so that the warning can be very specific on what went wrong, i.e. the new value being beyond the maximum value allowed.
target code: public boolean setValue ( T newValue ) { if ( ! validate ( newValue ) ) { return false ; } PropertyChangeEvent event = new PropertyChangeEvent ( this , id . toString ( ) , this . value , newValue ) ; this . value = newValue ; dispatchChangedEvent ( event ) ; return true ; }
response: public boolean setValue(T newValue) { if (!validator.validate(newValue)) { <START> LOGGER.warn("The passed value {} is invalid.", newValue); <END> return false; } PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue); this.value = newValue; dispatchChangedEvent(event); return true; }

sample: 338
buggy_code: public void onMessage(MessageHolderWithTokens message) { try { <START> logger.debug("receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"); <END> dequeueEvent.fire(message); } catch (DispatchInitiationException e) { throw e; } catch (Exception e) { logger.error("NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered", e); } }
code_review: Do we really want to move this from `trace` to `debug`?
target code: public void onMessage ( MessageHolderWithTokens message ) { try { logger . trace ( "receiving tokens from queue , triggering Notification Dispatcher class to pick the right sender" ) ; dequeueEvent . fire ( message ) ; } catch ( DispatchInitiationException e ) { throw e ; } catch ( Exception e ) { logger . error ( "NotificationDispatcher or PushNotificationSender unexpectedly failed , the message won't be redelivered" , e ) ; } }
response: public void onMessage(MessageHolderWithTokens message) { try { <START> logger.trace("receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"); <END> dequeueEvent.fire(message); } catch (DispatchInitiationException e) { throw e; } catch (Exception e) { logger.error("NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered", e); } }

sample: 339
buggy_code: private Collection<Key> getRegisteredKeys() { List<Key> result = new ArrayList<Key>(); <START> for (Iterator<Key> i = cacheMap.keySet().iterator(); i.hasNext();) { result.add(i.next()); } return result; <END> }
code_review: why not: return result.addAll(cacheMap.keySet());
target code: private Collection < Key > getRegisteredKeys ( ) { return new ArrayList < Key > ( cacheMap . keySet ( ) ) ; }
response: private Collection<Key> getRegisteredKeys() { List<Key> result = new ArrayList<Key>(); <START> return result.addAll(cacheMap.keySet()); <END> }

sample: 340
buggy_code: <START> public AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) { <END> name = metricName; type = metricType; value = initialValue; metricManager = manager; }
code_review: I would make this constructor `protected` because you cannot directly instantiate abstract classes. See the answers to http://stackoverflow.com/questions/260666/can-an-abstract-class-have-a-constructor for a discussion.
target code: protected AbstractMetric ( String metricName , String metricType , T initialValue , MetricReportManager manager ) { name = metricName ; type = metricType ; value = initialValue ; metricManager = manager ; }
response: <START> protected AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) { <END> name = metricName; type = metricType; value = initialValue; metricManager = manager; }

sample: 341
buggy_code: public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() { Allergy allergy = allergy(); <START> allergy.hasSameValues(allergy()); <END> }
code_review: Shouldn't this line be something like AssertTrue(allergy.hasSameValues(allergy())); ?
target code: public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues ( ) { Allergy allergy = allergy ( ) ; assertThat ( allergy . hasSameValues ( allergy ( ) ) , is ( true ) ) ; }
response: public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() { Allergy allergy = allergy(); <START> AssertTrue(allergy.hasSameValues(allergy())); <END> }

sample: 342
buggy_code: private static String readMapping() throws IOException, ParseException { JSONParser parser = new JSONParser(); ClassLoader classloader = Thread.currentThread().getContextClassLoader(); <START> InputStream inputStream = classloader.getResourceAsStream("mapping.json"); <END> String mapping = IOUtils.toString(inputStream, "UTF-8"); Object object = parser.parse(mapping); JSONObject jsonObject = (JSONObject) object; return jsonObject.toJSONString(); }
code_review: You are open a stream object without closing it never. Maybe you can use the try-with-resources statement here and avoid / handle the unhandled IOException here.
target code: private static String readMapping ( ) throws ParseException { JSONParser parser = new JSONParser ( ) ; ClassLoader classloader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try ( InputStream inputStream = classloader . getResourceAsStream ( "mapping . json" ) ) { String mapping = IOUtils . toString ( inputStream , "UTF - 8" ) ; Object object = parser . parse ( mapping ) ; JSONObject jsonObject = ( JSONObject ) object ; return jsonObject . toJSONString ( ) ; } catch ( IOException e ) { logger . error ( e ) ; return "" ; } }
response: private static String readMapping() throws IOException, ParseException { JSONParser parser = new JSONParser(); ClassLoader classloader = Thread.currentThread().getContextClassLoader(); <START> InputStream inputStream = classloader.getResourceAsStream("mapping.json"); String mapping = IOUtils.toString(inputStream, "UTF-8"); <END> Object object = parser.parse(mapping); JSONObject jsonObject = (JSONObject) object; return jsonObject.toJSONString(); }

sample: 343
buggy_code: public synchronized void commit() throws CommitException { SyncCommitObserver sco = null; try { sco = new SyncCommitObserver(); commitAsync(sco); sco.waitForCommit(); } finally { updates.clear(); weakNotification = null; <START> observedColumns.clear(); <END> columnsRead.clear(); } }
code_review: @mjwall I found the bug. Its my fault, I suggested clearing `observedColumns` and that is a bad thing to do. `observedColumns` is shared between transactions. It should be an immutable set, I'll open an issue for that.
target code: public synchronized void commit ( ) throws CommitException { SyncCommitObserver sco = null ; try { sco = new SyncCommitObserver ( ) ; commitAsync ( sco ) ; sco . waitForCommit ( ) ; } finally { updates . clear ( ) ; weakNotification = null ; columnsRead . clear ( ) ; } }
response: public synchronized void commit() throws CommitException { SyncCommitObserver sco = null; try { sco = new SyncCommitObserver(); commitAsync(sco); sco.waitForCommit(); } finally { updates.clear(); weakNotification = null; <START> <END> columnsRead.clear(); } }

sample: 344
buggy_code: public static boolean hasPictureId(byte[] buf, int off, int len) { if (!isValid(buf, off)) return false; if ((buf[off] & X_BIT) == 0 || (buf[off+1] & I_BIT) == 0) <START> return false; <END> return true; }
code_review: I would simplify to "return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)"
target code: public static boolean hasPictureId ( byte [ ] buf , int off , int len ) { return isValid ( buf , off , len ) && ( buf [ off ] & X_BIT ) != 0 && ( buf [ off + 1 ] & I_BIT ) != 0 ; }
response: public static boolean hasPictureId(byte[] buf, int off, int len) { if (!isValid(buf, off)) return false; if ((buf[off] & X_BIT) == 0 || (buf[off+1] & I_BIT) == 0) <START> return false; <END> return true; }

sample: 345
buggy_code: public void setEnabled(boolean enabled) { this.active = enabled; <START> System.out.println("active state change: " + active); <END> updateButtonState(); }
code_review: remove the println
target code: public void setEnabled ( boolean enabled ) { this . active = enabled ; updateButtonState ( ) ; }
response: public void setEnabled(boolean enabled) { this.active = enabled; <START> <END> updateButtonState(); }

sample: 346
buggy_code: <START> default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) { <END> throw new UnsupportedOperationException("Method is not implemented"); }
code_review: Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
target code: default void beforeDataProviderExecution ( IDataProviderMethod dataProviderMethod , ITestNGMethod method , ITestContext iTestContext ) { // not implemented }
response: <START> default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) { <END> }

sample: 347
buggy_code: private void handleEndActionJobAndStep() { if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) { <START> if (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep) { <END> startFinalizingStep(); } } }
code_review: the inner 'if' isn't needed - the conditions can be added to the outer 'if'
target code: private void handleEndActionJobAndStep ( ) { if ( ( ! hasTaskHandlers ( ) || getExecutionIndex ( ) == getTaskHandlers ( ) . size ( ) - 1 ) && ( ! parentHasCallback ( ) || getExecutionContext ( ) . getExecutionMethod ( ) == ExecutionMethod . AsStep ) ) { startFinalizingStep ( ) ; } }
response: private void handleEndActionJobAndStep() { if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1 && (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep)) { <START> startFinalizingStep(); <END> } }

sample: 348
buggy_code: private boolean waitForScanState(ScanStates state) { try { <START> while (!getScanState().equals(state)) { <END> scanState.wait(); } return true; } catch (InterruptedException e) { tsLogger.logger.warn("problem waiting for scanLock whilst in state " + state.name(), e); return false; } }
code_review: why did you change the do ... while into a while do loop. The caller already knows the scan state is not equal to state and since this is a private method it is safe to assume that the caller has already checked (under the lock) that he has to wait for a state change.
target code: private boolean waitForScanState ( ScanStates state ) { try { do { scanState . wait ( ) ; } while ( ! getScanState ( ) . equals ( state ) ) ; return true ; } catch ( InterruptedException e ) { tsLogger . logger . warn ( "problem waiting for scanLock whilst in state " + state . name ( ) , e ) ; return false ; } }
response: private boolean waitForScanState(ScanStates state) { try { <START> do { <END> scanState.wait(); } while (!getScanState().equals(state)); return true; } catch (InterruptedException e) { tsLogger.logger.warn("problem waiting for scanLock whilst in state " + state.name(), e); return false; } }

sample: 349
buggy_code: private void maybeScheduleCheckpoint() { switch (state()) { <START> case RESTORING: <END> this.checkpoint = checkpointableOffsets(); break; case RUNNING: if (!eosEnabled) { this.checkpoint = checkpointableOffsets(); } break; case SUSP<END>ED: this.checkpoint = checkpointableOffsets(); break; case CREATED: case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while scheduling checkpoint for active task " + id); default: throw new IllegalStateException("Unknown state " + state() + " while scheduling checkpoint for active task " + id); } }
code_review: Could we merge RESTORING and SUSPENDED?
target code: private void maybeScheduleCheckpoint ( ) { switch ( state ( ) ) { case RESTORING : case SUSPENDED : this . checkpoint = checkpointableOffsets ( ) ; break ; case RUNNING : if ( ! eosEnabled ) { this . checkpoint = checkpointableOffsets ( ) ; } break ; case CREATED : case CLOSED : throw new IllegalStateException ( "Illegal state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; default : throw new IllegalStateException ( "Unknown state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; } }
response: private void maybeScheduleCheckpoint() { switch (state()) { <START> case RESTORING: case SUSPENDED: <END> this.checkpoint = checkpointableOffsets(); break; case RUNNING: if (!eosEnabled) { this.checkpoint = checkpointableOffsets(); } break; case CREATED: case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while scheduling checkpoint for active task " + id); default: throw new IllegalStateException("Unknown state " + state() + " while scheduling checkpoint for active task " + id); } }

sample: 350
buggy_code: protected void executeQueryCommand() { Provider hostProvider = getProvider(); <START> HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider)); <END> getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); }
code_review: Why do you cast to HostProviderProxy?
target code: protected void executeQueryCommand ( ) { Provider hostProvider = getProvider ( ) ; HostProviderProxy proxy = ProviderProxyFactory . getInstance ( ) . create ( hostProvider ) ; getQueryReturnValue ( ) . setReturnValue ( chainToString ( proxy . getCertificateChain ( ) ) ) ; }
response: protected void executeQueryCommand() { Provider hostProvider = getProvider(); <START> ProviderProxy proxy = ProviderProxyFactory.getInstance().create(hostProvider); <END> getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); }

sample: 351
buggy_code: public void t1() { <START> testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName()); <END> }
code_review: We could have leveraged `InvokedMethodListener` for this. See [here](https://github.com/cbeust/testng/blob/master/src/test/java/test/InvokedMethodListener.java)
target code: public void t1 ( ) { }
response: public void t1() { <START> testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName()); <END> }

sample: 352
buggy_code: public void testValidateDataStreamsNoConflicts() { Metadata metadata = createIndices(5, 10, "foo-datastream").metadata; try { <START> validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE)); <END> } catch (Exception e) { fail("did not expect exception when validating a system without indices that would conflict with future backing indices: " + e.getMessage()); } }
code_review: Currently when the test fails with any error then there is no stacktrace to the original failure, which I think makes pinpointing the culprit easier? That being said, this is just preference, so feel free to ignore :)
target code: public void testValidateDataStreamsNoConflicts ( ) { Metadata metadata = createIndices ( 5 , 10 , "foo - datastream" ) . metadata ; // don't expect any exception when validating a system without indices that would conflict with future backing indices validateDataStreams ( metadata . getIndicesLookup ( ) , ( DataStreamMetadata ) metadata . customs ( ) . get ( DataStreamMetadata . TYPE ) ) ; }
response: public void testValidateDataStreamsNoConflicts() { Metadata metadata = createIndices(5, 10, "foo-datastream").metadata; try { <START> validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE)); <END> } catch (Exception e) { fail("did not expect exception when validating a system without indices that would conflict with future backing indices", e); } }

sample: 353
buggy_code: public ShaderProvider getPassShaderProvider (int n) { <START> if (n >= passShaderProviders.length) <END> throw new GdxRuntimeException("ShaderProvider " + n + " doesn't exist in " + getClass().getName()); return passShaderProviders[n]; }
code_review: I dont think that this check is needed here (otherwise it will throw an index out of bounds exception, which says the same). https://github.com/libgdx/libgdx/wiki/Contributing#performance-considerations
target code: public ShaderProvider getPassShaderProvider ( int n ) { return passShaderProviders [ n ] ; }
response: public ShaderProvider getPassShaderProvider (int n) { <START> return passShaderProviders[n]; }

sample: 354
buggy_code: public void onConnectionClosedForUser(QBRTCSession qbrtcSession, Integer integer) { setStatusForOpponent(integer, getString(R.string.closed)); <START> stopTimer(); <END> }
code_review: stopTimer()      ,     
target code: public void onConnectionClosedForUser ( QBRTCSession qbrtcSession , Integer integer ) { setStatusForOpponent ( integer , getString ( R . string . closed ) ) ; }
response: public void onSessionClosed(QBRTCSession session) { <START> stopTimer(); <END> }

sample: 355
buggy_code: public void install(ITextViewer textViewer) { for (IReconciler iReconciler : fReconcilers) { <START> if(iReconciler != null) { <END> iReconciler.install(textViewer); } } }
code_review: It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here.
target code: public void install ( ITextViewer textViewer ) { for ( IReconciler iReconciler : fReconcilers ) { iReconciler . install ( textViewer ) ; } }
response: public void install(ITextViewer textViewer) { for (IReconciler iReconciler : fReconcilers) { <START> if(iReconciler != null) { <END> iReconciler.install(textViewer); } } }

sample: 356
buggy_code: public JettyServer run(WebApplicationContext baseContext, boolean directlyUseAsWebAppRoot, Function<Function<Integer, JettyServer>, JettyServer> serverStarter, boolean exitOnError) { try { configureLogger(); configureSentry(baseContext); JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter, <START> v->v.addLifeCycleListener(new JettyLifeCycleListener(baseContext))); <END> jettyServer.start(); logStartupInfo(baseContext); return jettyServer; } catch (Exception e) { return logErrorAndExit(e, exitOnError); } }
code_review:      -    listener -        webAppInitializer
target code: public JettyServer run ( WebApplicationContext baseContext , boolean directlyUseAsWebAppRoot , Function < Function < Integer , JettyServer > , JettyServer > serverStarter , boolean exitOnError ) { try { configureLogger ( ) ; configureSentry ( baseContext ) ; JettyServer jettyServer = createJettyServer ( baseContext , directlyUseAsWebAppRoot , serverStarter ) ; jettyServer . start ( ) ; logStartupInfo ( baseContext ) ; return jettyServer ; } catch ( Exception e ) { return logErrorAndExit ( e , exitOnError ) ; } }
response: public JettyServer run(WebApplicationContext baseContext, boolean directlyUseAsWebAppRoot, Function<Function<Integer, JettyServer>, JettyServer> serverStarter, boolean exitOnError) { try { configureLogger(); configureSentry(baseContext); JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter, <START> v->v.addLifeCycleListener(new JettyLifeCycleListener(baseContext))); <END> jettyServer.start(); logStartupInfo(baseContext); return jettyServer; } catch (Exception e) { return logErrorAndExit(e, exitOnError); } }

sample: 357
buggy_code: public PlanItem(String id, String definitionRef) { <START> super(); <END> this.id = id; this.definitionRef = definitionRef; }
code_review: AFAIK this is redundant.
target code: public PlanItem ( String id , String definitionRef ) { this . id = id ; this . definitionRef = definitionRef ; }
response: public PlanItem(String id, String definitionRef) { <START> super(); <END> this.id = id; this.definitionRef = definitionRef; }

sample: 358
buggy_code: public int hashCode() { <START> return name.hashCode(); <END> }
code_review: Looking on `QName` class, maybe we should use `return ~~name.hashCode()`.
target code: public int hashCode ( ) { return ~~name . hashCode ( ) ; }
response: public int hashCode() { <START> return ~~name.hashCode(); <END> }

sample: 359
buggy_code: protected boolean copyObject(String src, String dst) { try { <START> LOG.info("Copying {} to {}", src, dst); <END> mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst); return true; } catch (CosClientException e) { LOG.error("Failed to rename file {} to {}", src, dst, e); return false; } }
code_review: `LOG.debug` please to avoid overhead on operations.
target code: protected boolean copyObject ( String src , String dst ) { try { LOG . debug ( "Copying { } to { } " , src , dst ) ; mClient . copyObject ( mBucketNameInternal , src , mBucketNameInternal , dst ) ; return true ; } catch ( CosClientException e ) { LOG . error ( "Failed to rename file { } to { } " , src , dst , e ) ; return false ; } }
response: protected boolean copyObject(String src, String dst) { try { <START> LOG.debug("Copying {} to {}", src, dst); <END> mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst); return true; } catch (CosClientException e) { LOG.error("Failed to rename file {} to {}", src, dst, e); return false; } }

sample: 360
buggy_code: public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, <START> false); <END> }
code_review: Since the logic switch, this should be true (former behavior).
target code: public RepositorySearchDialog ( Collection < String > existingDirs ) { this ( existingDirs , false , true ) ; }
response: public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, <START> true); <END> }

sample: 361
buggy_code: public DelegatingResourceDescription getCreatableProperties() { DelegatingResourceDescription description = super.getCreatableProperties(); <START> description.addProperty("name"); <END> description.addProperty("location"); description.addProperty("description"); return description; }
code_review: Aren't the name and description properties already added by the super class?
target code: public DelegatingResourceDescription getCreatableProperties ( ) { DelegatingResourceDescription description = super . getCreatableProperties ( ) ; description . addProperty ( "location" ) ; return description ; }
response: public DelegatingResourceDescription getCreatableProperties() { DelegatingResourceDescription description = super.getCreatableProperties(); <START> description.addProperty("location"); <END> return description; }

sample: 362
buggy_code: private JsonParser getParser(String data) throws IOException { // If the first character is { or [, assume this is // JSON data and use a JsonParser. Otherwise assume // YAML and use a YAMLParser. <START> Character firstChar = data.charAt(0); <END> if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } }
code_review: Character should be "char" https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#charAt(int) This is returning a char (primitive type) and that is why the "=="test works I think, if it was returning Character (object wrapper for char) we would need to use ".equals"
target code: private JsonParser getParser ( String data ) throws IOException { // If the first character is { or [ , assume this is // JSON data and use a JsonParser . Otherwise assume // YAML and use a YAMLParser . char firstChar = data . charAt ( 0 ) ; if ( firstChar == ' { ' || firstChar == ' [ ' ) { return this . jsonFactory . createParser ( data ) ; } else { return this . yamlFactory . createParser ( data ) ; } }
response: private JsonParser getParser(String data) throws IOException { // If the first character is { or [, assume this is // JSON data and use a JsonParser. Otherwise assume // YAML and use a YAMLParser. <START> char firstChar = data.charAt(0); <END> if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } }

sample: 363
buggy_code: public void testGenerateDroolsTestOption() { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig(); assertThat(config.isGenerateDroolsTestOnError()).isNull(); config.setGenerateDroolsTestOnError(true); <START> assertThat((boolean) config.isGenerateDroolsTestOnError()).isTrue(); <END> config.setGenerateDroolsTestOnError(Boolean.FALSE); assertThat((boolean) config.isGenerateDroolsTestOnError()).isFalse(); config.setGenerateDroolsTestOnError(null); assertThat(config.isGenerateDroolsTestOnError()).isNull(); }
code_review: Redundant cast.
target code: public void testGenerateDroolsTestOption ( ) { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig ( ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; config . setGenerateDroolsTestOnError ( true ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isTrue ( ) ; config . setGenerateDroolsTestOnError ( Boolean . FALSE ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isFalse ( ) ; config . setGenerateDroolsTestOnError ( null ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; }
response: public void testGenerateDroolsTestOption() { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig(); assertThat(config.isGenerateDroolsTestOnError()).isNull(); config.setGenerateDroolsTestOnError(true); <START> assertThat(config.isGenerateDroolsTestOnError()).isTrue(); <END> config.setGenerateDroolsTestOnError(Boolean.FALSE); assertThat(config.isGenerateDroolsTestOnError()).isFalse(); config.setGenerateDroolsTestOnError(null); assertThat(config.isGenerateDroolsTestOnError()).isNull(); }

sample: 364
buggy_code: private RawText getRawText(ObjectId id, Repository repo) throws IOException { <START> if (id.equals(ObjectId.zeroId())) return new RawText(new byte[] {}); <END> return new RawText(repo.openBlob(id).getCachedBytes()); }
code_review: Style-nit: Use curly brackets and wrap the return to next line.
target code: private RawText getRawText ( ObjectId id , Repository repo ) throws IOException { if ( id . equals ( ObjectId . zeroId ( ) ) ) { return new RawText ( new byte [ ] { } ) ; } return new RawText ( repo . openBlob ( id ) . getCachedBytes ( ) ) ; }
response: private RawText getRawText(ObjectId id, Repository repo) throws IOException { <START> if (id.equals(ObjectId.zeroId())) { return new RawText(new byte[] {}); } <END> return new RawText(repo.openBlob(id).getCachedBytes()); }

sample: 365
buggy_code: private static String getUserAgentSuffix() { String suffix = ";" + USER_AGENT_SUFFIX; <START> return suffix; <END> }
code_review: We can make this inline. ```suggestion return ";" + USER_AGENT_SUFFIX; ```
target code: private static String getUserAgentSuffix ( ) { return " ; " + USER_AGENT_SUFFIX ; }
response: private static String getUserAgentSuffix() { <START> return ";" + USER_AGENT_SUFFIX; <END> }

sample: 366
buggy_code: public Builder setDataSize(Estimate dataSize) { <START> this.dataSize = requireNonNull(dataSize, "dataSize can not be null"); <END> return this; }
code_review: you don't validate in other builders method (and you don't have to)
target code: public Builder setDataSize ( Estimate dataSize ) { this . dataSize = dataSize ; return this ; }
response: public Builder setDataSize(Estimate dataSize) { <START> this.dataSize = dataSize; <END> return this; }

sample: 367
buggy_code: public boolean isExpired(Date invocationDate) { if (getExpires() != null) { Date currentInvocationDate = invocationDate == null ? new Date() : invocationDate; <START> return getExpires().before(currentInvocationDate); <END> } return false; }
code_review: Statement can be rewritten inline.
target code: public boolean isExpired ( Date invocationDate ) { if ( getExpires ( ) != null ) { return getExpires ( ) . before ( invocationDate == null ? new Date ( ) : invocationDate ) ; } return false ; }
response: public boolean isExpired(Date invocationDate) { if (getExpires() != null) { <START> return getExpires().before(invocationDate == null ? new Date() : invocationDate); <END> } return false; }

sample: 368
buggy_code: public void stop() { if (isRunning()) { process.destroy(); try { if (stdout !=null) { <START> stdout.close(); <END> } if (stdin !=null) { stdin.close(); } } catch (IOException e) { throw new RuntimeException(e.getMessage(),e); } finally { running.set(false); } } }
code_review: Is this really needed?
target code: public void stop ( ) { if ( isRunning ( ) ) { process . destroy ( ) ; running . set ( false ) ; } }
response: public void stop() { if (isRunning()) { process.destroy(); try { if (stdout !=null) { <START> stdout.close(); <END> } if (stdin !=null) { stdin.close(); } } catch (IOException e) { throw new RuntimeException(e.getMessage(),e); } finally { running.set(false); } } }

sample: 369
buggy_code: public boolean equals(Object object) { <START> if (object == null || object.getClass() != getClass()) { <END> return false; } if (object == this) { return true; } MacroId rhs = (MacroId) object; return new EqualsBuilder() .append(getId(), rhs.getId()) .append(getSyntax(), rhs.getSyntax()) .isEquals(); }
code_review: Actually since MacroId is not really supposed to be extended you could replace this with a `if (!(object instanceof MacroId))`. Can't be null if it's an instance of MacroId. Also I would put it after the `if (object == this)` test instead of before.
target code: public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof MacroId ) ) { return false ; } MacroId rhs = ( MacroId ) object ; return new EqualsBuilder ( ) . append ( getId ( ) , rhs . getId ( ) ) . append ( getSyntax ( ) , rhs . getSyntax ( ) ) . isEquals ( ) ; }
response: public boolean equals(Object object) { <START> if (object == this) { return true; } if (object == null || object.getClass() != getClass()) { <END> return false; } MacroId rhs = (MacroId) object; return new EqualsBuilder() .append(getId(), rhs.getId()) .append(getSyntax(), rhs.getSyntax()) .isEquals(); }

sample: 370
buggy_code: <START> Map<String, Object> getExtraInformation() { <END> return extraInformation; }
code_review: this is public API, we can't lower the visibility without deprecating first
target code: public Map < String , Object > getExtraInformation ( ) { return extraInformation ; }
response: <START> public Map<String, Object> getExtraInformation() { <END> return extraInformation; }

sample: 371
buggy_code: public int hashCode() { <START> return Objects.hash(pointer, ownerName, owner, readers, writers); <END> }
code_review: neat.
target code: public int hashCode ( ) { return Objects . hash ( pointer , ownerName ) ; }
response: public int hashCode() { <START> return Objects.hash(pointer, ownerName, owner, readers, writers); <END> }

sample: 372
buggy_code: private String getFriendsPath( SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) { // https://youtrack.jetbrains.com/issue/KT-29933 ImmutableSortedSet<String> absoluteFriendPaths = ImmutableSortedSet.copyOf( friendPathsSourcePaths .stream() .map(path -> sourcePathResolver.getAbsolutePath(path).toString()) .collect(Collectors.toSet())); return "-Xfriend-paths=" <START> + absoluteFriendPaths.stream().reduce("", (path1, path2) -> path1 + "," + path2); <END> }
code_review: What about the same when the list is empty, it still adds `-Xfriend-paths=` option?
target code: private String getFriendsPath ( SourcePathResolver sourcePathResolver , ImmutableList < SourcePath > friendPathsSourcePaths ) { if ( friendPathsSourcePaths . isEmpty ( ) ) { return "" ; } // https :/ / youtrack . jetbrains . com / issue / KT - 29933 ImmutableSortedSet < String > absoluteFriendPaths = ImmutableSortedSet . copyOf ( friendPathsSourcePaths . stream ( ) . map ( path - > sourcePathResolver . getAbsolutePath ( path ) . toString ( ) ) . collect ( Collectors . toSet ( ) ) ) ; return " - Xfriend - paths = " + absoluteFriendPaths . stream ( ) . reduce ( "" , ( path1 , path2 ) - > path1 + " , " + path2 ) ; }
response: private String getFriendsPath( SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) { // https://youtrack.jetbrains.com/issue/KT-29933 ImmutableSortedSet<String> absoluteFriendPaths = ImmutableSortedSet.copyOf( friendPathsSourcePaths .stream() .map(path -> sourcePathResolver.getAbsolutePath(path).toString()) .collect(Collectors.toSet())); return absoluteFriendPaths.isEmpty() ? "" : "-Xfriend-paths=" <START> + absoluteFriendPaths.stream().reduce("", (path1, path2) -> path1 + "," + path2); <END> }

sample: 373
buggy_code: public Target(String targetUriAsString) { <START> super(); <END> Assert.hasText(targetUriAsString, "The provided targetUriAsString must neither be null nor empty."); this.targetUri = URI.create(targetUriAsString); }
code_review: Do we need super(), if the class is not inheriting from a super class?
target code: public Target ( String targetUriAsString ) { Assert . hasText ( targetUriAsString , "The provided targetUriAsString must neither be null nor empty . " ) ; this . targetUri = URI . create ( targetUriAsString ) ; }
response: public Target(String targetUriAsString) { <START> Assert.hasText(targetUriAsString, "The provided targetUriAsString must neither be null nor empty."); this.targetUri = URI.create(targetUriAsString); <END> }

sample: 374
buggy_code: public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) { super(definition); final String propertyName = definition.getTestValue(); String regexExpression = PropertiesManager.getProperty (propertyName, ""); if (StringUtils.isBlank(regexExpression)) { logger.error("Unable to find property name {} in portal.properties or has empty value." + " PAGS PropertyInvertedRegexTester will always return true for attribute {}", propertyName, definition.getAttributeName()); } setPattern(regexExpression); <START> } <END>
code_review: Minor, but rather than duplicating lines 44 - 51, perhaps put them in a private method invoked by both constructors, or have this constructor invoke the other.
target code: public PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition ) { super ( definition ) ; setPattern ( definition . getAttributeName ( ) , definition . getTestValue ( ) ) ; }
response: public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) { super(definition); final String propertyName = definition.getTestValue(); String regexExpression = PropertiesManager.getProperty (propertyName, ""); if (StringUtils.isBlank(regexExpression)) { logger.error("Unable to find property name {} in portal.properties or has empty value." + " PAGS PropertyInvertedRegexTester will always return true for attribute {}", propertyName, definition.getAttributeName()); } setPattern(regexExpression); <START> } <END>

sample: 375
buggy_code: public final boolean doesProvideNewPage() { if (provision == null) { <START> throw new IllegalStateException("Page instance not yet resolved"); <END> } return getProvision().doesProvideNewPage(); }
code_review: Looking bad indeed, I fixed later during my work on the branch: https://github.com/apache/wicket/pull/210/commits/b64f2b4b2cb50a594cabb50a0c1eeca43485f6b9#diff-36b11db0d92a540368a080c520de953aL177 The three states looks overcomplicated. There's no place in Wicket core needing to test such flag for the value "OLD".
target code: public final boolean doesProvideNewPage ( ) { return getProvision ( ) . doesProvideNewPage ( ) ; }
response: public final boolean doesProvideNewPage() { if (provision == null) { <START> throw new IllegalStateException("Page instance not yet resolved"); <END> } return getProvision().doesProvideNewPage(); }

sample: 376
buggy_code: private Handler getHandler() { <START> if (mHandler == null) { <END> // Use current main looper mHandler = new Handler(mContext.getMainLooper()); } return mHandler; }
code_review: This doesn't look thread-safe.
target code: private synchronized Handler getHandler ( ) { if ( mHandler == null ) { // Use current main looper mHandler = new Handler ( mContext . getMainLooper ( ) ) ; } return mHandler ; }
response: private Handler getHandler() { <START> if (mHandler == null) { <END> // Use current main looper mHandler = new Handler(mContext.getMainLooper()); } return mHandler; }

sample: 377
buggy_code: @SuppressWarnings("UnusedDeclaration") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); <START> setLoggingEnabled(debugging); <END> }
code_review: Let's remove this behavior. `setDebugging` will only affect the indicators.
target code: @SuppressWarnings ( "UnusedDeclaration" ) @Deprecated public void setDebugging ( boolean debugging ) { setIndicatorsEnabled ( debugging ) ; }
response: @SuppressWarnings("UnusedDeclaration") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); }

sample: 378
buggy_code: public List<ServerTemplate> load() { synchronized (store) { return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList()); <START> } <END> }
code_review: I guess we no longer need `store` to be of `ConcurrentHashMap` implementation if we are fully locking it.
target code: public List < ServerTemplate > load ( ) { synchronized ( store ) { return store . values ( ) . stream ( ) . map ( this : : cloneServerTemplate ) . collect ( Collectors . toList ( ) ) ; } }
response: public List<ServerTemplate> load() { synchronized (store) { return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList()); } }

sample: 379
buggy_code: public String getLearnerMaster() { QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster(); InetSocketAddress address = learnerMaster.addr.getReachableOrOne(); <START> if (learnerMaster == null || address == null) { <END> return "Unknown"; } return address.getAddress().getHostAddress() + ":" + address.getPort(); }
code_review: if `learnerMaster` is `null` here then you'll get a NPE on the `learnerMaster.addr.getReachableOrOne()` above.
target code: public String getLearnerMaster ( ) { QuorumPeer . QuorumServer learnerMaster = observer . getCurrentLearnerMaster ( ) ; if ( learnerMaster == null || learnerMaster . addr . isEmpty ( ) ) { return "Unknown" ; } InetSocketAddress address = learnerMaster . addr . getReachableOrOne ( ) ; return address . getAddress ( ) . getHostAddress ( ) + " : " + address . getPort ( ) ; }
response: public String getLearnerMaster() { QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster(); InetSocketAddress address = learnerMaster.addr.getReachableOrOne(); <START> if (address == null) { <END> return "Unknown"; } return address.getAddress().getHostAddress() + ":" + address.getPort(); }

sample: 380
buggy_code: default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) { ArgumentUtil.requireNotNull(func, "function"); final Task<Task<R>> nested = map("map: " + desc, func); nested.getShallowTraceBuilder().setSystemHidden(true); <START> nested.getShallowTraceBuilder().setTaskType("nestedTask"); <END> return flatten(desc, nested); }
code_review: I think we should drop redundant "Task" suffix from the task types e.g.: "nestedTask" -> "nested" "withSideEffectTask" -> "withSideEffect" "timeoutTask" -> "timeout" "withTimeoutTask" -> "withTimeout"
target code: default < R > Task < R > flatMap ( final String desc , final Function1 < ? super T , Task < R > > func ) { ArgumentUtil . requireNotNull ( func , "function" ) ; final Task < Task < R > > nested = map ( "map : " + desc , func ) ; nested . getShallowTraceBuilder ( ) . setSystemHidden ( true ) ; return flatten ( desc , nested ) ; }
response: default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) { ArgumentUtil.requireNotNull(func, "function"); final Task<Task<R>> nested = map("map: " + desc, func); nested.getShallowTraceBuilder().setSystemHidden(true); <START> nested.getShallowTraceBuilder().setTaskType("nested"); <END> return flatten(desc, nested); }

sample: 381
buggy_code: protected List<String> findStringsInFileCommon(String regexp, boolean stopOnFirst, int searchLimit, File fileToSearch) <START> throws Exception { <END> return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO); }
code_review: As stated above, I don't see the need for this method to throw an exception.
target code: protected List < String > findStringsInFileCommon ( String regexp , boolean stopOnFirst , int searchLimit , File fileToSearch ) { return findStringsInFileCommon ( regexp , stopOnFirst , searchLimit , fileToSearch , Project . MSG_INFO ) ; }
response: protected List<String> findStringsInFileCommon(String regexp, boolean stopOnFirst, int searchLimit, File fileToSearch) <START> { <END> return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO); }

sample: 382
buggy_code: public void notifyAboutStartProcess(String id) { Long processInstanceId = Long.parseLong(id); newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId, deploymentId, processInstanceId, processDefId, processName, <START> 1)); <END> final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue()); notificationEvent.fire(new NotificationEvent(message, NotificationEvent.NotificationType.SUCCESS)); close(); }
code_review: can you pass null in here for the status, I recently refactored similar code, and status should not be part of the event.
target code: public void notifyAboutStartProcess ( String id ) { Long processInstanceId = Long . parseLong ( id ) ; newProcessInstanceEvent . fire ( new NewProcessInstanceEvent ( serverTemplateId , deploymentId , processInstanceId , processDefId , processName , null ) ) ; final String message = Constants . INSTANCE . ProcessStarted ( processInstanceId . longValue ( ) ) ; notificationEvent . fire ( new NotificationEvent ( message , NotificationEvent . NotificationType . SUCCESS ) ) ; close ( ) ; }
response: public void notifyAboutStartProcess(String id) { Long processInstanceId = Long.parseLong(id); newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId, deploymentId, processInstanceId, processDefId, processName, <START> null)); <END> final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue()); notificationEvent.fire(new NotificationEvent(message, NotificationEvent.NotificationType.SUCCESS)); close(); }

sample: 383
buggy_code: protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); <START> if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) { <END> maybeMove(oldChildReference, newChildReference); } } }); }
code_review: I don't understand what this check is doing here. maybeMove is already taking check of checking rights.
target code: protected void process ( final SpaceReference source , final SpaceReference destination ) { visitDocuments ( source , new Visitor < DocumentReference > ( ) { @Override public void visit ( DocumentReference oldChildReference ) { DocumentReference newChildReference = oldChildReference . replaceParent ( source , destination ) ; maybeMove ( oldChildReference , newChildReference ) ; } } ) ; }
response: protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); <START> maybeMove(oldChildReference, newChildReference); <END> } }); }

sample: 384
buggy_code: <START> public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException { <END> log.info("Process event {}", event.getType()); switch (event.type) { case DISCOVER_INIT_TOPOLOGY: startDiscovery(); break; case ACQUIRE_LOCK: processLockAcquire(); break; case RELEASE_LOCK: processLockRelease(); break; case DISCOVERED_TOPOLOGY: processTopologyChangeNotification(event); break; case UPGRADE: processUpgrade(event); break; default: log.error("Invalid event type {}", event.type); } }
code_review: same, we can delete LogReplicationDiscoveryServiceException.java file now.
target code: public void processEvent ( DiscoveryServiceEvent event ) { log . info ( "Process event { } " , event . getType ( ) ) ; switch ( event . getType ( ) ) { case DISCOVER_INIT_TOPOLOGY : startDiscovery ( ) ; break ; case ACQUIRE_LOCK : processLockAcquire ( ) ; break ; case RELEASE_LOCK : processLockRelease ( ) ; break ; case DISCOVERED_TOPOLOGY : processTopologyChangeNotification ( event ) ; break ; case UPGRADE : processUpgrade ( event ) ; break ; default : log . error ( "Invalid event type { } " , event . getType ( ) ) ; } }
response: <START> public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException { <END> log.info("Process event {}", event.getType()); switch (event.type) { case DISCOVER_INIT_TOPOLOGY: startDiscovery(); break; case ACQUIRE_LOCK: processLockAcquire(); break; case RELEASE_LOCK: processLockRelease(); break; case DISCOVERED_TOPOLOGY: processTopologyChangeNotification(event); break; case UPGRADE: processUpgrade(event); break; default: log.error("Invalid event type {}", event.type); } }

sample: 385
buggy_code: public void deleteError(final ProgramError error) { synchronized (errors) { errors.remove(error); <START> eventBus.publish(new ProgramErrorDeletedEvent(error)); <END> } }
code_review: Don't really like firing events when holding locks on things... If anything that receives a ProgramErrorDeletedEvent tries to access the ErrorManager (which is not altogether unreasonable!) you'll end up with a nasty deadlock. Could we just make errors a ConcurrentSkipListSet and drop all the synchronization?
target code: public void deleteError ( final ProgramError error ) { errors . remove ( error ) ; eventBus . publish ( new ProgramErrorDeletedEvent ( error ) ) ; }
response: public void deleteError(final ProgramError error) { synchronized (errors) { errors.remove(error); } <START> eventBus.publish(new ProgramErrorDeletedEvent(error)); <END> }

sample: 386
buggy_code: public LamiTableContentProvider() { fCurrentEntries = <START> checkNotNull(Collections.emptyList()); <END> }
code_review: Can remove checkNotNull, we have external @NonNull annotation on Collections.emptyList().
target code: public LamiTableContentProvider ( ) { fCurrentEntries = Collections . emptyList ( ) ; }
response: public LamiTableContentProvider() { fCurrentEntries = <START> Collections.emptyList(); <END> }

sample: 387
buggy_code: public ArticlePageObject clickGetInfoLink() { switchToIFrame(); waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); switchOutOfIFrame(); <START> return new ArticlePageObject(driver); <END> }
code_review: in case of switching, in my opinion it's better to us etry/finnally like that: ``` switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); } ``` it's clearer in reading
target code: public ArticlePageObject clickGetInfoLink ( ) { switchToIFrame ( ) ; try { waitForElementByElement ( getInfoLink ) ; // Opens new tab to Template namespace getInfoLink . click ( ) ; return new ArticlePageObject ( driver ) ; } finally { switchOutOfIFrame ( ) ; } }
response: public ArticlePageObject clickGetInfoLink() { switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); } }

sample: 388
buggy_code: @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setAdviceChain(new CacheInterceptor()); assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain()) .hasSize(2) <START> .matches(adviceArray -> asList(adviceArray).get(0) instanceof TracingRabbitListenerAdvice); <END> }
code_review: would this work? (also removing the import) ```suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice); ```
target code: @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent ( ) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory ( ) ; factory . setAdviceChain ( new CacheInterceptor ( ) ) ; // the order of advices is important for the downstream interceptor to see the tracing context assertThat ( rabbitTracing . decorateSimpleRabbitListenerContainerFactory ( factory ) . getAdviceChain ( ) ) . hasSize ( 2 ) . matches ( adviceArray - > adviceArray [ 0 ] instanceof TracingRabbitListenerAdvice ) ; }
response: @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setAdviceChain(new CacheInterceptor()); assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain()) .hasSize(2) <START> .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice); <END> }

sample: 389
buggy_code: private static List<IResource> getReadonlyFiles(IResource[] resources) { <START> List<IResource> readOnlyFiles= new ArrayList<IResource>(); <END> for (int i= 0; i < resources.length; i++) { IResource resource= resources[i]; ResourceAttributes resourceAttributes= resource.getResourceAttributes(); if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly()) readOnlyFiles.add(resource); } return readOnlyFiles; }
code_review: Use ArrayList<>
target code: private static List < IResource > getReadonlyFiles ( IResource [ ] resources ) { List < IResource > readOnlyFiles = new ArrayList < > ( ) ; for ( IResource resource : resources ) { ResourceAttributes resourceAttributes = resource . getResourceAttributes ( ) ; if ( resource . getType ( ) == IResource . FILE && resourceAttributes != null && resourceAttributes . isReadOnly ( ) ) readOnlyFiles . add ( resource ) ; } return readOnlyFiles ; }
response: private static List<IResource> getReadonlyFiles(IResource[] resources) { <START> List<IResource> readOnlyFiles= new ArrayList<>(); <END> for (int i= 0; i < resources.length; i++) { IResource resource= resources[i]; ResourceAttributes resourceAttributes= resource.getResourceAttributes(); if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly()) readOnlyFiles.add(resource); } return readOnlyFiles; }

sample: 390
buggy_code: void clean(K key) { List<V> data = getDataMap().get(key); if (data != null) { <START> data.clear(); <END> } getDataMap().remove(key); }
code_review: I think this is not necessary as the GC will remove it as soon as there is no more reference on the Object
target code: void clean ( K key ) { getDataMap ( ) . remove ( key ) ; }
response: void clean(K key) { List<V> data = getDataMap().get(key); if (data != null) { <START> data.clear(); <END> } }

sample: 391
buggy_code: public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) { if (!isMemory(memoryDevice)) { <START> throw new RuntimeException("Memory device expected but device " + memoryDevice + " obtained."); <END> } return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent(); }
code_review: IllegalArgumentException sounds better here.
target code: public static boolean isMemoryDeviceHotUnpluggable ( VmDevice memoryDevice ) { if ( ! isMemory ( memoryDevice ) ) { throw new IllegalArgumentException ( "Memory device expected but device " + memoryDevice + " obtained . " ) ; } return getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_SIZE ) . isPresent ( ) && getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_NODE ) . isPresent ( ) ; }
response: public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) { if (!isMemory(memoryDevice)) { <START> throw new IllegalArgumentException("Memory device expected but device " + memoryDevice + " obtained."); <END> } return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent(); }

sample: 392
buggy_code: public boolean connectorExists(String id) { try { List<ConnectorConfiguration> list = configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id)); if (list.isEmpty()) { return false; } return true; } catch (PersistenceException e) { <START> throw new RuntimeException(e); <END> } }
code_review: Would be nice if you add here an exception text. Something like "unable to load the list of connector configurations"
target code: public Boolean connectorExists ( String id ) { try { List < ConnectorConfiguration > list = configPersistence . load ( ImmutableMap . of ( Constants . CONNECTOR_PERSISTENT_ID , id ) ) ; return ! list . isEmpty ( ) ; } catch ( PersistenceException e ) { throw new RuntimeException ( e ) ; } }
response: public boolean connectorExists(String id) { try { List<ConnectorConfiguration> list = configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id)); if (list.isEmpty()) { return false; } return true; } catch (PersistenceException e) { <START> throw new RuntimeException("unable to load the list of connector configurations", e); <END> } }

sample: 393
buggy_code: public void testUpdateStmtBuilder() { printStatement("update foo set \"column['looks_like_nested']\"=1"); printStatement("update foo set foo.a='b'"); printStatement("update bar.foo set bar.foo.t=3"); printStatement("update foo set col['x'] = 3"); printStatement("update foo set col['x'] = 3 where foo['x'] = 2"); printStatement("update schemah.foo set foo.a='b', foo.b=foo.a"); printStatement("update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"); printStatement("update foo set foo='a' returning id"); printStatement("update foo set foo='a' where x=false returning id"); printStatement("update foo set foo='a' returning id AS foo"); printStatement("update foo set foo='a' returning id + 1 AS foo, id -1 as bar"); <START> } <END>
code_review: can we maybe have separate test cases for the returning clause?
target code: public void testUpdateStmtBuilder ( ) { printStatement ( "update foo set \"column [ 'looks_like_nested' ] \" = 1" ) ; printStatement ( "update foo set foo . a = 'b'" ) ; printStatement ( "update bar . foo set bar . foo . t = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3 where foo [ 'x' ] = 2" ) ; printStatement ( "update schemah . foo set foo . a = 'b' , foo . b = foo . a" ) ; printStatement ( "update schemah . foo set foo . a = abs ( - 6 . 3334 ) , x = true where x = false" ) ; }
response: public void testUpdateStmtBuilder() { printStatement("update foo set \"column['looks_like_nested']\"=1"); printStatement("update foo set foo.a='b'"); printStatement("update bar.foo set bar.foo.t=3"); printStatement("update foo set col['x'] = 3"); printStatement("update foo set col['x'] = 3 where foo['x'] = 2"); printStatement("update schemah.foo set foo.a='b', foo.b=foo.a"); printStatement("update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"); <START> printStatement("update foo set foo='a' returning id"); printStatement("update foo set foo='a' where x=false returning id"); printStatement("update foo set foo='a' returning id AS foo"); printStatement("update foo set foo='a' returning id + 1 AS foo, id -1 as bar"); <END> }

sample: 394
buggy_code: public void setSetPath(String path) { <START> setPath.set(requireNonNull(path, "path is null")); <END> }
code_review: nit: I know that in other parts of this class we put the requireNonNull calls inside another method call, but let's not do it here for the sake of slightly better readability: ``` requireNonNull(path, "path is null"); setPath.set(path); ```
target code: public void setSetPath ( String path ) { requireNonNull ( path , "path is null" ) ; setPath . set ( path ) ; }
response: public void setSetPath(String path) { <START> requireNonNull(path, "path is null"); setPath.set(path); <END> }

sample: 395
buggy_code: public EnvVars getEnvironment() throws IOException, InterruptedException { if (cachedEnvironment != null) { <START> return cachedEnvironment; <END> } cachedEnvironment = EnvVars.getRemote(getChannel()); return cachedEnvironment; }
code_review: Something like this: ``` public EnvVars getEnvironment() throws IOException, InterruptedException { EnvVars cachedEnvironment = this.cachedEnvironment; if (cachedEnvironment != null) { return cachedEnvironment; cachedEnvironment = EnvVars.getRemote(getChannel()); // all non-null values should be equivalent so in a race it doesn't matter who wins this.cachedEnvironment = cachedEnvironment; return cachedEnvironment; } ```
target code: public EnvVars getEnvironment ( ) throws IOException , InterruptedException { EnvVars cachedEnvironment = this . cachedEnvironment ; if ( cachedEnvironment != null ) { return cachedEnvironment ; } cachedEnvironment = EnvVars . getRemote ( getChannel ( ) ) ; this . cachedEnvironment = cachedEnvironment ; return cachedEnvironment ; }
response: public EnvVars getEnvironment() throws IOException, InterruptedException { EnvVars cachedEnvironment = this.cachedEnvironment; if (cachedEnvironment != null) { <START> return cachedEnvironment; <END> } cachedEnvironment = EnvVars.getRemote(getChannel()); // all non-null values should be equivalent so in a race it doesn't matter who wins this.cachedEnvironment = cachedEnvironment; return cachedEnvironment; }

sample: 396
buggy_code: public int getMaxCapacity() { <START> readLock.lock(); <END> try { return maxCapacity; } finally { readLock.unlock(); } }
code_review: why should add lock here?
target code: public int getMaxCapacity ( ) { return maxCapacity ; }
response: public int getMaxCapacity() { <START> readLock.lock(); <END> try { return maxCapacity; } finally { readLock.unlock(); } }

sample: 397
buggy_code: public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() { List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> }
code_review: Can you use isEmpty()?
target code: public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser ( ) { List < VDS > result = dao . getAllForVdsGroup ( existingVds . getvds_group_id ( ) , UNPRIVILEGED_USER_ID , true ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; }
response: public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() { List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.isEmpty()); <END> }

sample: 398
buggy_code: private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) { ComboPooledDataSource ds = new ComboPooledDataSource(false); ds.setDataSourceName(name); ds.setIdentityToken(name); new BeanMap(ds).putAll(properties); C3P0Registry.reregister(ds); try { checkDataSource(ds, name); } catch (SQLException e) { <START> throw new RuntimeException("Failed check data source", e); <END> } return ds; }
code_review:        exception, n "Failed to check data source " + e.toString(), e).
target code: private static DataSource createC3P0DataSource ( String name , Map < Object , Object > properties ) { ComboPooledDataSource ds = new ComboPooledDataSource ( false ) ; ds . setDataSourceName ( name ) ; ds . setIdentityToken ( name ) ; new BeanMap ( ds ) . putAll ( properties ) ; C3P0Registry . reregister ( ds ) ; checkDataSource ( ds , name ) ; return ds ; }
response: private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) { ComboPooledDataSource ds = new ComboPooledDataSource(false); ds.setDataSourceName(name); ds.setIdentityToken(name); new BeanMap(ds).putAll(properties); C3P0Registry.reregister(ds); try { checkDataSource(ds, name); } catch (SQLException e) { <START> throw new RuntimeException("Failed to check data source " + e.toString(), e); <END> } return ds; }

sample: 399
buggy_code: protected Control createPageControls(Composite parent) { setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer); <START> Label label = new Label(parent, SWT.CENTER); <END> label.setText( NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName())); return parent; }
code_review: no need to center it, just give it SWT.NONE
target code: protected Control createPageControls ( Composite parent ) { setTitle ( Messages . RemoveReviewerDialog_Remove_Reviewer ) ; Label label = new Label ( parent , SWT . NONE ) ; label . setText ( NLS . bind ( Messages . RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove , userToRemove . getDisplayName ( ) ) ) ; return parent ; }
response: protected Control createPageControls(Composite parent) { setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer); <START> Label label = new Label(parent, SWT.NONE); <END> label.setText( NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName())); return parent; }

sample: 400
buggy_code: public List<PermissionSubject> getPermissionCheckSubjects() { List<PermissionSubject> list = new ArrayList<PermissionSubject>(); Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue(); list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup())); QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId()); return list; <START> } <END>
code_review: I think you need to call super otherwise you loose the permissions that you need to check by default.
target code: public List < PermissionSubject > getPermissionCheckSubjects ( ) { List < PermissionSubject > list = new ArrayList < PermissionSubject > ( ) ; Guid storagePoolId = getVdsGroup ( ) == null || getVdsGroup ( ) . getstorage_pool_id ( ) == null ? null : getVdsGroup ( ) . getstorage_pool_id ( ) . getValue ( ) ; list . add ( new PermissionSubject ( storagePoolId , VdcObjectType . StoragePool , getActionType ( ) . getActionGroup ( ) ) ) ; list = QuotaHelper . addQuotaPermissionSubject ( list , getStoragePool ( ) , getQuotaId ( ) ) ; return list ; }
response: public List<PermissionSubject> getPermissionCheckSubjects() { List<PermissionSubject> list = super.getPermissionCheckSubjects(); Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue(); list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup())); QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId()); return list; <START> } <END>

sample: 401
buggy_code: public void onInit( String clientName, Map<String,Object> credentials ) throws IOException { <START> packer.packStructHeader( 1, INIT.signature() ); <END> packer.pack( clientName ); packer.pack( ValueUtils.asMapValue( credentials ) ); onMessageComplete.onMessageComplete(); }
code_review: This is actually wrong but it is an error that has propagated to all drivers. The init struct has size 2 and not size 1. We are saved by ignoring the struct size when we read the init message.
target code: public void onInit ( String clientName , Map < String , Object > credentials ) throws IOException { packer . packStructHeader ( 2 , INIT . signature ( ) ) ; packer . pack ( clientName ) ; packer . pack ( ValueUtils . asMapValue ( credentials ) ) ; onMessageComplete . onMessageComplete ( ) ; }
response: public void onInit( String clientName, Map<String,Object> credentials ) throws IOException { <START> packer.packStructHeader( 2, INIT.signature() ); <END> packer.pack( clientName ); packer.pack( ValueUtils.asMapValue( credentials ) ); onMessageComplete.onMessageComplete(); }

sample: 402
buggy_code: <START> public SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension, <END> NovaSecurityGroupExtension novaSecurityGroupExtension) { this.neutronSecurityGroupExtension = neutronSecurityGroupExtension; this.novaSecurityGroupExtension = novaSecurityGroupExtension; }
code_review: Remove the public modifier
target code: SecurityGroupExtensionProvider ( NeutronSecurityGroupExtension neutronSecurityGroupExtension , NovaSecurityGroupExtension novaSecurityGroupExtension ) { this . neutronSecurityGroupExtension = neutronSecurityGroupExtension ; this . novaSecurityGroupExtension = novaSecurityGroupExtension ; }
response: <START> SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension, <END> NovaSecurityGroupExtension novaSecurityGroupExtension) { this.neutronSecurityGroupExtension = neutronSecurityGroupExtension; this.novaSecurityGroupExtension = novaSecurityGroupExtension; }

sample: 403
buggy_code: private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionNotEqualNullWithOr(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionComparedWithFunction(expression, kind); <START> if (comparedExpression == null) { <END> return null; } } } return comparedExpression; }
code_review: @vilchik-elena Do we need this block?
target code: private static ExpressionTree getComparedWithNullExpression ( ExpressionTree expression , Tree . Kind kind ) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd ( expression , kind ) ; if ( comparedExpression == null ) { comparedExpression = getExpressionNotEqualNullWithOr ( expression , kind ) ; if ( comparedExpression == null ) { comparedExpression = getExpressionComparedWithFunction ( expression , kind ) ; } } return comparedExpression ; }
response: private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionNotEqualNullWithOr(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionComparedWithFunction(expression, kind); <START> return comparedExpression; <END> } } return comparedExpression; }

sample: 404
buggy_code: private void scheduleRefresh(Duration delay) { // already stopped? avoids rejection exception if (executor.isShutdown()) { return; } <START> executor.schedule((Runnable) this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS); <END> }
code_review: Is the `(Runnable)` needed?
target code: private void scheduleRefresh ( Duration delay ) { // already stopped ? avoids rejection exception if ( executor . isShutdown ( ) ) { return ; } executor . schedule ( this : : refresh , delay . toMillis ( ) , TimeUnit . MILLISECONDS ) ; }
response: private void scheduleRefresh(Duration delay) { // already stopped? avoids rejection exception if (executor.isShutdown()) { return; } <START> executor.schedule(this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS); <END> }

sample: 405
buggy_code: public static void main(String[] args) { <START> LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of("reorder_joins", "false")); <END> new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out)); }
code_review: Technically, you should `queryRunner.close()` (or t-w-r). This would ensure proper cleanup of any temp files (or whatevers) it might have created
target code: public static void main ( String [ ] args ) { LocalQueryRunner queryRunner = createLocalQueryRunner ( ImmutableMap . of ( "reorder_joins" , "false" ) ) ; new SqlConsecutiveJoinBenchmark ( queryRunner ) . runBenchmark ( new SimpleLineBenchmarkResultWriter ( System . out ) ) ; queryRunner . close ( ) ; }
response: public static void main(String[] args) { <START> LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of("reorder_joins", "false")); <END> new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out)); queryRunner.close(); }

sample: 406
buggy_code: <START> public void beforeStartingVertx(VertxOptions options) { <END> }
code_review: Shouldn't they be protected not public?
target code: protected void beforeStartingVertx ( VertxOptions options ) { }
response: <START> protected void beforeStartingVertx(VertxOptions options) { <END> }

sample: 407
buggy_code: public Builder body(String json) { checkNotNull(json, "body required"); checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES), <START> "json size must be <= %s bytes", getInteger(MESSAGE_BODY_MAX_IN_BYTES)); <END> this.body = new JsonBall(json).toString(); return self(); }
code_review: Ah, so I guess that lack of a Guice context here (and above) is the reason for the system properties? How do we solve that elsewhere in jclouds? Would we inject some kind of factory object via Guice?
target code: public Builder body ( String json ) { checkNotNull ( json , "body required" ) ; this . body = new JsonBall ( json ) . toString ( ) ; return self ( ) ; }
response: public Builder body(String json) { checkNotNull(json, "body required"); checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES), <START> "json size must be <= %s bytes", getInteger(MESSAGE_BODY_MAX_IN_BYTES)); <END> this.body = new JsonBall(json).toString(); return self(); }

sample: 408
buggy_code: private String getTokenFromHeader(HttpServletRequest request) { String token = null; String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION); if (headerValue != null && headerValue.startsWith(BEARER)) { token = <START> headerValue.substring("Bearer".length()).trim(); <END> } return token; }
code_review: s/"Bearer"/BEARER
target code: private String getTokenFromHeader ( HttpServletRequest request ) { String token = null ; String headerValue = request . getHeader ( SsoConstants . HEADER_AUTHORIZATION ) ; if ( headerValue != null && headerValue . startsWith ( BEARER ) ) { token = headerValue . substring ( BEARER . length ( ) ) . trim ( ) ; } return token ; }
response: private String getTokenFromHeader(HttpServletRequest request) { String token = null; String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION); if (headerValue != null && headerValue.startsWith(BEARER)) { token = <START> headerValue.substring(BEARER.length()).trim(); <END> } return token; }

sample: 409
buggy_code: <START> public static CDIProvider getCDIProvider() { <END> if (configuredProvider != null) { return configuredProvider; } else { // Discover providers and cache if (discoveredProviders == null) { synchronized (lock) { if (discoveredProviders == null) { findAllProviders(); } } } configuredProvider = discoveredProviders.stream() .filter(c -> c.getCDI() != null) .findAny().orElseThrow(() -> new IllegalStateException("Unable to access CDI")); return configuredProvider; } }
code_review: This method should not be public or what's the point?
target code: private static CDIProvider getCDIProvider ( ) { if ( configuredProvider != null ) { return configuredProvider ; } else { // Discover providers and cache if ( discoveredProviders == null ) { synchronized ( lock ) { if ( discoveredProviders == null ) { findAllProviders ( ) ; } } } configuredProvider = discoveredProviders . stream ( ) . filter ( c - > c . getCDI ( ) != null ) . findAny ( ) . orElseThrow ( ( ) - > new IllegalStateException ( "Unable to access CDI" ) ) ; return configuredProvider ; } }
response: <START> private static CDIProvider getCDIProvider() { <END> if (configuredProvider != null) { return configuredProvider; } else { // Discover providers and cache if (discoveredProviders == null) { synchronized (lock) { if (discoveredProviders == null) { findAllProviders(); } } } configuredProvider = discoveredProviders.stream() .filter(c -> c.getCDI() != null) .findAny().orElseThrow(() -> new IllegalStateException("Unable to access CDI")); return configuredProvider; } }

sample: 410
buggy_code: <START> public void testIsDrawable_Stage() throws Exception { <END> testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true); }
code_review: The Exception is never thrown.
target code: public void testIsDrawable_Stage ( ) { testIsDrawable ( CaseManagementDiagram . class , AdHocSubprocess . class , true ) ; }
response: <START> public void testIsDrawable_Stage() { <END> testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true); }

sample: 411
buggy_code: public static boolean customImageExists(String storage, String key) { final AzureBlobClient azureBlob = ContextBuilder.newBuilder("azureblob") .credentials(storage, key) .buildApi(AzureBlobClient.class); try { return azureBlob.containerExists("system"); } catch (Exception e) { e.printStackTrace(); return false; <START> } <END> finally { Closeables2.closeQuietly(azureBlob); } }
code_review: The container exists method should already return false [if the container exists call returns a 404](https://github.com/jclouds/jclouds/blob/master/providers/azureblob/src/main/java/org/jclouds/azureblob/AzureBlobClient.java#L156). Worth removing the catch, as it might be caused by other errors that should be taken into acount?
target code: public static boolean customImageExists ( String storage , String key ) { final AzureBlobClient azureBlob = ContextBuilder . newBuilder ( "azureblob" ) . credentials ( storage , key ) . buildApi ( AzureBlobClient . class ) ; try { return azureBlob . containerExists ( "system" ) ; } finally { Closeables2 . closeQuietly ( azureBlob ) ; } }
response: public static boolean customImageExists(String storage, String key) { final AzureBlobClient azureBlob = ContextBuilder.newBuilder("azureblob") .credentials(storage, key) .buildApi(AzureBlobClient.class); try { return azureBlob.containerExists("system"); } finally { Closeables2.closeQuietly(azureBlob); } }

sample: 412
buggy_code: public void enter() { mUseEap = (IkeSessionOptions.IKE_AUTH_METHOD_EAP == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod); <START> super.enter(); <END> }
code_review: Nit: By convention, this is almost always the first thing called, unless there's a explicit reason why it needs to happen after (which is usually a code smell)
target code: public void enter ( ) { super . enter ( ) ; mUseEap = ( IkeSessionOptions . IKE_AUTH_METHOD_EAP == mIkeSessionOptions . getLocalAuthConfig ( ) . mAuthMethod ) ; }
response: public void enter() { <START> mUseEap = (IkeSessionOptions.IKE_AUTH_METHOD_EAP == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod); <END> super.enter(); }

sample: 413
buggy_code: public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && DeterminismEvaluator.isDeterministic(expression) && <START> !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) && <END> !isDynamicFilter(expression)) { ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }
code_review: you can static import these functions.
target code: public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) && ! isDynamicFilter ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }
response: public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && DeterminismEvaluator.isDeterministic(expression) && <START> !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) && <END> !isDynamicFilter(expression)) { ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }

sample: 414
buggy_code: public void startMasters() throws Exception { mMaster = LocalAlluxioMaster.create(mWorkDirectory, true); mMaster.start(); <START> CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); <END> }
code_review: why is this needed?
target code: public void startMasters ( ) throws Exception { mMaster = LocalAlluxioMaster . create ( mWorkDirectory , true ) ; mMaster . start ( ) ; }
response: public void startMasters() throws Exception { mMaster = LocalAlluxioMaster.create(mWorkDirectory, true); mMaster.start(); <START> CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); <END> } <START> CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); <END>

sample: 415
buggy_code: public Proxy getProxy() { <START> if (mProxyHost == null) return null; <END> Proxy.Type type = null; switch (mProxyType) { case TYPE_HTTP: type = Proxy.Type.HTTP; break; case TYPE_SOCKS: type = Proxy.Type.SOCKS; break; } return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort)); }
code_review: mind the code style
target code: public Proxy getProxy ( ) { if ( mProxyHost == null ) { return null ; } return new Proxy ( mProxyType , new InetSocketAddress ( mProxyHost , mProxyPort ) ) ; }
response: public Proxy getProxy() { <START> if (mProxyHost == null) return null; <END> Proxy.Type type = null; switch (mProxyType) { case TYPE_HTTP: type = Proxy.Type.HTTP; break; case TYPE_SOCKS: type = Proxy.Type.SOCKS; break; } return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort)); }

sample: 416
buggy_code: public HttpRequest setMethod(HttpMethod method) { ObjectUtil.checkNotNull(method, "method"); <START> this.method = method; <END> return this; }
code_review: nit: you can merge both lines above as `checkNotNull` will return the given argument
target code: public HttpRequest setMethod ( HttpMethod method ) { this . method = ObjectUtil . checkNotNull ( method , "method" ) ; return this ; }
response: public HttpRequest setMethod(HttpMethod method) { <START> this.method = ObjectUtil.checkNotNull(method, "method"); <END> return this; }

sample: 417
buggy_code: public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) { if (!FeatureSupported.deviceCustomProperties(version)) { return Collections.emptySet(); } <START> Set<VmDeviceGeneralType> types; <END> EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version); if (map.isEmpty()) { // no device type has any properities types = Collections.emptySet(); } else { // prevent client to modify types = Collections.unmodifiableSet(map.keySet()); } return types; }
code_review: a matter of taste - types can be avoided for the sake of return statements from the if-else block.
target code: public Set < VmDeviceGeneralType > getDeviceTypesWithProperties ( Version version ) { if ( ! FeatureSupported . deviceCustomProperties ( version ) ) { return Collections . emptySet ( ) ; } EnumMap < VmDeviceGeneralType , Map < String , Pattern > > map = deviceProperties . get ( version ) ; if ( map . isEmpty ( ) ) { // no device type has any properties return Collections . emptySet ( ) ; } else { // prevent client to modify return Collections . unmodifiableSet ( map . keySet ( ) ) ; } }
response: public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) { if (!FeatureSupported.deviceCustomProperties(version)) { return Collections.emptySet(); } <START> Set<VmDeviceGeneralType> types; <END> EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version); if (map.isEmpty()) { // no device type has any properities return Collections.emptySet(); } else { // prevent client to modify return Collections.unmodifiableSet(map.keySet()); } }

sample: 418
buggy_code: public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException { super(reference, bot); GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() { @Override public GraphicalViewer run() { final IEditorPart editor = partReference.getEditor(true); <START> return editor.getAdapter(GraphicalViewer.class); <END> } }); ReflectionHelper.setFieldValueWithoutException(this, "viewer", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass()); }
code_review: generic has come with mars. Consequently that code won't compile against previous platform
target code: public SWTBotSiriusDiagramEditor ( final IEditorReference reference , final SWTWorkbenchBot bot ) throws WidgetNotFoundException { super ( reference , bot ) ; GraphicalViewer graphicalViewer = UIThreadRunnable . syncExec ( new Result < GraphicalViewer > ( ) { @Override public GraphicalViewer run ( ) { final IEditorPart editor = partReference . getEditor ( true ) ; return ( GraphicalViewer ) editor . getAdapter ( GraphicalViewer . class ) ; } } ) ; ReflectionHelper . setFieldValueWithoutException ( this , "viewer" , new SWTBotSiriusGefViewer ( graphicalViewer ) , this . getClass ( ) . getSuperclass ( ) ) ; }
response: public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException { super(reference, bot); GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() { @Override public GraphicalViewer run() { final IEditorPart editor = partReference.getEditor(true); <START> return editor.getAdapter(GraphicalViewer.class); <END> } }); ReflectionHelper.setFieldValueWithoutException(this, "viewer", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass()); }

sample: 419
buggy_code: public CreateAllSnapshotsFromVmParameters() { needsLocking = true; <START> snapshotType = SnapshotType.REGULAR; <END> saveMemory = true; diskIdsToIgnoreInChecks = Collections.emptySet(); }
code_review: I'd prefer that we handled it (the snapshot type) in a separate change.
target code: public CreateAllSnapshotsFromVmParameters ( ) { needsLocking = true ; saveMemory = true ; diskIdsToIgnoreInChecks = Collections . emptySet ( ) ; }
response: public CreateAllSnapshotsFromVmParameters() { needsLocking = true; snapshotType = SnapshotType.REGULAR; <START> saveMemory = true; <END> diskIdsToIgnoreInChecks = Collections.emptySet(); }

sample: 420
buggy_code: public SchedulerTask<?> createTaskInstance( String taskType ) throws IllegalArgumentException <START> { <END> try { return lookupTask( taskType ); } catch ( ComponentLookupException e ) { this.logger.debug( "Failed to load Schedule Task: " + taskType, e ); throw new IllegalArgumentException( "Could not create task of type" + taskType, e ); } }
code_review: afacit vvv is all noise
target code: public SchedulerTask < ? > createTaskInstance ( String taskType ) throws IllegalArgumentException { try { return lookupTask ( taskType ) ; } catch ( ComponentLookupException e ) { throw new IllegalArgumentException ( "Could not create task of type" + taskType , e ) ; } }
response: public SchedulerTask<?> createTaskInstance( String taskType ) throws IllegalArgumentException <START> { <END> try { return lookupTask( taskType ); } catch ( ComponentLookupException e ) { this.logger.debug( "Failed to load Schedule Task: " + taskType, e ); throw new IllegalArgumentException( "Could not create task of type" + taskType, e ); } }

sample: 421
buggy_code: public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) { super(adapterFactory); <START> labelProviderService = new LabelProviderServiceImpl(); <END> try { labelProviderService.startService(); } catch (ServiceException ex) { Activator.getDefault().getLog().log( new Status(IStatus.WARNING, Activator.PLUGIN_ID, "Unable to start Papyrus Label Provider Service", ex)); //$NON-NLS-1$ } }
code_review: It worries me a bit to imagine that _each_ decorator will start its own service (whatever that means, I'm not familiar with papyrus services) Can you check whether this is a common way of using services? Would it be possible to share a common instance somehow between decorators?
target code: public PapyrusStereotypedElementItemProviderDecorator ( ComposeableAdapterFactory adapterFactory ) { super ( adapterFactory ) ; }
response: public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) { super(adapterFactory); <START> labelProviderService = new LabelProviderServiceImpl(); <END> try { labelProviderService.startService(); } catch (ServiceException ex) { Activator.getDefault().getLog().log( new Status(IStatus.WARNING, Activator.PLUGIN_ID, "Unable to start Papyrus Label Provider Service", ex)); //$NON-NLS-1$ } }

sample: 422
buggy_code: <START> default SourceMap sourceMap() { <END> return null; }
code_review: Why not rely on `Optional`, rather than introducing another method which could lead to NPEs?
target code: default Optional < SourceMap > sourceMap ( ) { return Optional . empty ( ) ; }
response: <START> default Optional<SourceMap> sourceMap() { <END> return Optional.empty(); }

sample: 423
buggy_code: public static void setupDefaultTestCluster() throws Exception { config = DrillConfig.create(cloneDefaultTestConfigProperties()); classpathScan = ClassPathScanner.fromPrescan(config); openClient(); // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test("ALTER SESSION SET `exec.errors.verbose` = true"); <START> emptyDirCreating(); <END> }
code_review: Why do we create empty directory for all tests that extend this class? I guess need to create it only for those tests that need it.
target code: public static void setupDefaultTestCluster ( ) throws Exception { config = DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) ; classpathScan = ClassPathScanner . fromPrescan ( config ) ; openClient ( ) ; // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test ( "ALTER SESSION SET `exec . errors . verbose` = true" ) ; }
response: public static void setupDefaultTestCluster() throws Exception { config = DrillConfig.create(cloneDefaultTestConfigProperties()); classpathScan = ClassPathScanner.fromPrescan(config); openClient(); // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test("ALTER SESSION SET `exec.errors.verbose` = true"); }

sample: 424
buggy_code: private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier, final String errorMessage) { try { theTypeSupplier.get(); <START> throw new RuntimeException(errorMessage); <END> } catch (MirroredTypeException mte) { return mte.getTypeMirror().toString(); } }
code_review: As I am looking at the code, this is not necessary wrong, but maybe it would be better to throw new RuntimeException() in the end of the method. It's up to you what do you prefer.
target code: private static String parseAnnotationFieldTypeName ( final Supplier < Class < ? > > theTypeSupplier , final String errorMessage ) { try { theTypeSupplier . get ( ) ; } catch ( MirroredTypeException mte ) { return mte . getTypeMirror ( ) . toString ( ) ; } // Failed to parse the field type name throw new RuntimeException ( errorMessage ) ; }
response: private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier, final String errorMessage) { try { theTypeSupplier.get(); } catch (MirroredTypeException mte) { return mte.getTypeMirror().toString(); } <START> throw new RuntimeException(errorMessage); <END> }

sample: 425
buggy_code: default StreamPriority getStreamPriority() { <START> return StreamPriority.DEFAULT; <END> }
code_review: return `null` instead when there is no priority
target code: default StreamPriority getStreamPriority ( ) { return null ; }
response: default StreamPriority getStreamPriority() { <START> return null; <END> }

sample: 426
buggy_code: protected void configure() { bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton(); <START> bind(Bootstrap.class); <END> }
code_review: ?? Pourquoi cette ligne. Bootstrap est dj une classe concrte...
target code: protected void configure ( ) { bind ( EventDao . class ) . to ( EventDaoInMemory . class ) . asEagerSingleton ( ) ; }
response: protected void configure() { bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton(); <START> bind(Bootstrap.class); <END> }

sample: 427
buggy_code: public static void onAdvancementEvent(AdvancementEvent event) { <START> if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat()) <END> { logger.info("{} got the {} advancement", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText()); } }
code_review: Second `ENABLED` check is not necessary if you have the first one.
target code: public static void onAdvancementEvent ( AdvancementEvent event ) { if ( event . getAdvancement ( ) . getDisplay ( ) != null && event . getAdvancement ( ) . getDisplay ( ) . shouldAnnounceToChat ( ) ) { logger . info ( " { } got the { } advancement" , event . getEntityPlayer ( ) . getDisplayNameString ( ) , event . getAdvancement ( ) . getDisplayText ( ) . getUnformattedText ( ) ) ; } }
response: public static void onAdvancementEvent(AdvancementEvent event) { <START> if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat()) <END> { logger.info("{} got the {} advancement", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText()); } }

sample: 428
buggy_code: public ExampleEndpointsProvider() { // Put custom code here to get endpoints // In our case they will be hardcoded try { JHttpEndpoint httpEndpoint = new JHttpEndpoint(new URI("https://jagger.griddynamics.net:443")); <START> endpoints.add(httpEndpoint); <END> } catch (URISyntaxException e) { throw new IllegalStateException(e); } }
code_review: let's use URI.create and avoid try/catch
target code: public ExampleEndpointsProvider ( ) { // Put custom code here to get endpoints // In our case they will be hardcoded JHttpEndpoint httpEndpoint = new JHttpEndpoint ( URI . create ( "https :/ / jagger . griddynamics . net : 443" ) ) ; endpoints . add ( httpEndpoint ) ; }
response: public ExampleEndpointsProvider() { // Put custom code here to get endpoints // In our case they will be hardcoded JHttpEndpoint httpEndpoint = new JHttpEndpoint(URI.create("https://jagger.griddynamics.net:443")); <START> endpoints.add(httpEndpoint); <END> }

sample: 429
buggy_code: public SlackUserProperty() { <START> this.userId = null; <END> this.disableNotifications = false; }
code_review: do we need any content in this constructor at all?
target code: public SlackUserProperty ( ) { }
response: public SlackUserProperty() { <START> this.userId = null; this.disableNotifications = false; <END> }

sample: 430
buggy_code: public void onStreamCreate(IMediaStream stream) { <START> if (!stream.isTranscodeResult()) { <END> PacketListener listener = new PacketListener(); WMSProperties props = stream.getProperties(); synchronized (props) { props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener); } stream.addLivePacketListener(listener); } }
code_review: do return
target code: public void onStreamCreate ( IMediaStream stream ) { if ( stream . isTranscodeResult ( ) ) { return ; } PacketListener listener = new PacketListener ( ) ; WMSProperties props = stream . getProperties ( ) ; synchronized ( props ) { props . setProperty ( STREAM_ACTION_LISTENER_PROPERTY , listener ) ; } stream . addLivePacketListener ( listener ) ; }
response: public void onStreamCreate(IMediaStream stream) { <START> if (!stream.isTranscodeResult()) { <END> PacketListener listener = new PacketListener(); WMSProperties props = stream.getProperties(); synchronized (props) { props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener); } stream.addLivePacketListener(listener); return; } }

sample: 431
buggy_code: public long getEstimatedSizeInBytes() { <START> int result = INSTANCE_SIZE; <END> result += sizeOf(levelOffsets); result += tree.sizeOf(); for (T item : items) { result += item.getEstimatedSizeInBytes(); } return result; }
code_review: result -> size
target code: public long getEstimatedSizeInBytes ( ) { long result = INSTANCE_SIZE + sizeOf ( levelOffsets ) + tree . sizeOf ( ) ; for ( T item : items ) { result += item . getEstimatedSizeInBytes ( ) ; } return result ; }
response: public long getEstimatedSizeInBytes() { <START> int size = INSTANCE_SIZE; <END> size += sizeOf(levelOffsets); size += tree.sizeOf(); for (T item : items) { size += item.getEstimatedSizeInBytes(); } return size; }

sample: 432
buggy_code: public boolean respondsTo(RunEvent event) { Run r = event.getEventObject(); <START> if (event.getEventType().equals(MisoEventType.RUN_FAILED) && r.getHealth().equals(HealthType.Failed)) { <END> log.info("Run " + r.getAlias() + ": " + event.getEventMessage()); return true; } return false; }
code_review: `==` instead of `.equals` (in both instances) would make this null-safe
target code: public boolean respondsTo ( RunEvent event ) { Run r = event . getEventObject ( ) ; if ( event . getEventType ( ) == MisoEventType . RUN_FAILED && r . getHealth ( ) == HealthType . Failed ) { log . info ( "Run " + r . getAlias ( ) + " : " + event . getEventMessage ( ) ) ; return true ; } return false ; }
response: public boolean respondsTo(RunEvent event) { Run r = event.getEventObject(); <START> if (event.getEventType() == MisoEventType.RUN_FAILED && r.getHealth() == HealthType.Failed) { <END> log.info("Run " + r.getAlias() + ": " + event.getEventMessage()); return true; } return false; }

sample: 433
buggy_code: public boolean isEnabled() { <START> final boolean res = super.isEnabled() || isDirty(); <END> return res; }
code_review: en profiter pour enlever cette variable intermdiaire?
target code: public boolean isEnabled ( ) { return super . isEnabled ( ) || isDirty ( ) ; }
response: public boolean isEnabled() { <START> return super.isEnabled() || isDirty(); <END> }

sample: 434
buggy_code: private void updateSslVerifyUser(boolean value) { StoredConfig userConfig = GlobalConfigCache.getInstance() .getUserConfig(); try { <START> userConfig.load(); <END> updateSslVerify(userConfig, value); } catch (IOException | ConfigInvalidException e) { // Log it, but otherwise ignore here. LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid, userConfig, e)); } }
code_review: If I understand this change correctly, this shouldn't be needed anymore?
target code: private void updateSslVerifyUser ( boolean value ) { StoredConfig userConfig = null ; try { userConfig = GlobalConfigCache . getInstance ( ) . getUserConfig ( ) ; updateSslVerify ( userConfig , value ) ; } catch ( IOException | ConfigInvalidException e ) { // Log it , but otherwise ignore here . LOG . error ( MessageFormat . format ( JGitText . get ( ) . userConfigFileInvalid , userConfig , e ) ) ; } }
response: private void updateSslVerifyUser(boolean value) { StoredConfig userConfig = GlobalConfigCache.getInstance() .getUserConfig(); try { <START> userConfig.load(); <END> updateSslVerify(userConfig, value); } catch (IOException | ConfigInvalidException e) { // Log it, but otherwise ignore here. LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid, userConfig, e)); } }

sample: 435
buggy_code: <START> private boolean isUserBrickAdapter(BaseAdapter baseAdapter) { <END> return baseAdapter instanceof UserBrickAdapter; }
code_review: this method could be static i guess? more relevant: is this method necessary? i only see one usage
target code: private static boolean isUserBrickAdapter ( BaseAdapter baseAdapter ) { return baseAdapter instanceof UserBrickAdapter ; }
response: <START> private static boolean isUserBrickAdapter(BaseAdapter baseAdapter) { <END> return baseAdapter instanceof UserBrickAdapter; }

sample: 436
buggy_code: private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) { FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager() .findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG)); <START> formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId); <END> return formulaEditorFragment; }
code_review: Please check if the fragment exists. It could lead to a null-pointer exception.
target code: private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor ( CategoryListItem categoryListItem ) { FormulaEditorFragment formulaEditorFragment = null ; if ( getFragmentManager ( ) != null ) { formulaEditorFragment = ( ( FormulaEditorFragment ) getFragmentManager ( ) . findFragmentByTag ( FormulaEditorFragment . FORMULA_EDITOR_FRAGMENT_TAG ) ) ; if ( formulaEditorFragment != null ) { formulaEditorFragment . addResourceToActiveFormula ( categoryListItem . nameResId ) ; } } return formulaEditorFragment ; }
response: private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) { FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager() .findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG)); if (formulaEditorFragment != null) { <START> formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId); <END> } return formulaEditorFragment; }

sample: 437
buggy_code: public final ReviewCategoryStrategy reviewCategoryStrategy() { String s = reviewCategeoryStrategyRaw(); return s != null ? ReviewCategoryStrategy.valueOf(s) : <START> null; <END> }
code_review: Shouldn't this return ReviewCategoryStrategy.NONE? Otherwise why do we have ReviewCategoryStrategy.NONE if null means NONE too?
target code: public final ReviewCategoryStrategy reviewCategoryStrategy ( ) { String s = reviewCategeoryStrategyRaw ( ) ; return s != null ? ReviewCategoryStrategy . valueOf ( s ) : ReviewCategoryStrategy . NONE ; }
response: public final ReviewCategoryStrategy reviewCategoryStrategy() { String s = reviewCategeoryStrategyRaw(); return s != null ? ReviewCategoryStrategy.valueOf(s) : <START> ReviewCategoryStrategy.NONE; <END> }

sample: 438
buggy_code: public Iterable<ConnectorFactory> getConnectorFactories() { <START> return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.of(metastore))); <END> }
code_review: `metastore` is nullable here
target code: public Iterable < ConnectorFactory > getConnectorFactories ( ) { return ImmutableList . of ( new HiveConnectorFactory ( name , getClassLoader ( ) , metastore ) ) ; }
response: public Iterable<ConnectorFactory> getConnectorFactories() { <START> return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.fromNullable(metastore))); <END> }

sample: 439
buggy_code: public void testDBConnectionTimeMetrics() { <START> metrics.setDBConnectionTime(14); <END> assertEquals(14, testUtil.getGaugeValue("dbConnectionTime")); }
code_review: Did you apply saveaction?
target code: public void testDBConnectionTimeMetrics ( ) { this . metrics . setDBConnectionTime ( 14 ) ; assertEquals ( 14 , this . testUtil . getGaugeValue ( "dbConnectionTime" ) ) ; }
response: public void testDBConnectionTimeMetrics() { <START> metrics.setDBConnectionTime(14); <END> assertEquals(14, testUtil.getGaugeValue("dbConnectionTime")); }

sample: 440
buggy_code: protected void createCacheManagers() throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true); <START> builder.clustering().stateTransfer().chunkSize(200).sync().replTimeout(45, TimeUnit.SECONDS); <END> createClusteredCaches(4, cacheName(), builder); }
code_review: I think I like 20 better, to exercise the key migration code more.
target code: protected void createCacheManagers ( ) throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig ( getCacheMode ( ) , true ) ; builder . clustering ( ) . stateTransfer ( ) . sync ( ) . replTimeout ( 45 , TimeUnit . SECONDS ) ; createClusteredCaches ( 4 , cacheName ( ) , builder ) ; }
response: protected void createCacheManagers() throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true); <START> builder.clustering().stateTransfer().chunkSize(20).sync().replTimeout(45, TimeUnit.SECONDS); <END> createClusteredCaches(4, cacheName(), builder); }

sample: 441
buggy_code: private String getByAccountName(CodeReviewCommit codeReviewCommit) { Account account = getAccount(codeReviewCommit); if (account != null && account.getFullName() != null) { return " by " + <START> account.getUserName(); <END> } return ""; }
code_review: getFullName()
target code: private String getByAccountName ( CodeReviewCommit codeReviewCommit ) { Account account = getAccount ( codeReviewCommit ) ; if ( account != null && account . getFullName ( ) != null ) { return " by " + account . getFullName ( ) ; } return "" ; }
response: private String getByAccountName(CodeReviewCommit codeReviewCommit) { Account account = getAccount(codeReviewCommit); if (account != null && account.getFullName() != null) { return " by " + <START> account.getFullName(); <END> } return ""; }

sample: 442
buggy_code: public void findByUndefinedSchema() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> getClient().perform(get("/api/core/metadatafields/search/bySchema") .param("schema", "undefined")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath("$.page.size", is(20))) .andExpect(jsonPath("$.page.totalElements", is(0))); }
code_review: I believe the Auth system should remain on in this method.
target code: public void findByUndefinedSchema ( ) throws Exception { getClient ( ) . perform ( get ( " / api / core / metadatafields / search / bySchema" ) . param ( "schema" , "undefined" ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( content ( ) . contentType ( contentType ) ) . andExpect ( jsonPath ( "$ . page . size" , is ( 20 ) ) ) . andExpect ( jsonPath ( "$ . page . totalElements" , is ( 0 ) ) ) ; }
response: public void findByUndefinedSchema() throws Exception { getClient().perform(get("/api/core/metadatafields/search/bySchema") .param("schema", "undefined")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath("$.page.size", is(20))) .andExpect(jsonPath("$.page.totalElements", is(0))); }

sample: 443
buggy_code: <START> private void addAll(QuantileDigest digest, long... values) <END> { requireNonNull(values, "values is null"); for (long value : values) { digest.add(value); } }
code_review: private static
target code: private static void addAll ( QuantileDigest digest , long . . . values ) { requireNonNull ( values , "values is null" ) ; for ( long value : values ) { digest . add ( value ) ; } }
response: <START> private static void addAll(QuantileDigest digest, long... values) <END> { requireNonNull(values, "values is null"); for (long value : values) { digest.add(value); } }

sample: 444
buggy_code: protected Object encodeCommand(Command command) { initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD); switch (command.getType()) { case Command.TYPE_CUSTOM: return formatCommand(command, "{%s}", Command.KEY_DATA); case Command.TYPE_POSITION_SINGLE: return formatCommand(command, "AVREQ,{%s},1", Command.KEY_DEVICE_PASSWORD); case Command.TYPE_REBOOT_DEVICE: return formatCommand(command, "AVRESET,{%s},{%s}", Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD); default: break; } <START> return null; <END> }
code_review: Move this to default.
target code: protected Object encodeCommand ( Command command ) { initDevicePassword ( command , LaipacProtocolDecoder . DEFAULT_DEVICE_PASSWORD ) ; switch ( command . getType ( ) ) { case Command . TYPE_CUSTOM : return formatCommand ( command , " { % s } " , Command . KEY_DATA ) ; case Command . TYPE_POSITION_SINGLE : return formatCommand ( command , "AVREQ , { % s } , 1" , Command . KEY_DEVICE_PASSWORD ) ; case Command . TYPE_REBOOT_DEVICE : return formatCommand ( command , "AVRESET , { % s } , { % s } " , Command . KEY_UNIQUE_ID , Command . KEY_DEVICE_PASSWORD ) ; default : return null ; } }
response: protected Object encodeCommand(Command command) { initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD); switch (command.getType()) { case Command.TYPE_CUSTOM: return formatCommand(command, "{%s}", Command.KEY_DATA); case Command.TYPE_POSITION_SINGLE: return formatCommand(command, "AVREQ,{%s},1", Command.KEY_DEVICE_PASSWORD); case Command.TYPE_REBOOT_DEVICE: return formatCommand(command, "AVRESET,{%s},{%s}", Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD); default: break; } <START> return null; <END> } <START>

sample: 445
buggy_code: public void close() throws IOException { <START> if (selectObjectContentResult != null) { <END> selectObjectContentResult.close(); selectObjectContentResult = null; selectObjectRequest = null; } }
code_review: We shouldn't need to check or clear any fields here, as `SelectObjectContentResult` is a `Closeable` which guarantees that `close()` is idempotent: > If the stream is already closed then invoking this method has no effect.
target code: public void close ( ) throws IOException { selectObjectContentResult . close ( ) ; }
response: public void close() throws IOException { <START> if (selectObjectContentResult != null) { <END> selectObjectContentResult.close(); } }

sample: 446
buggy_code: @Override public boolean isDisposed() { <START> return inner == null; <END> }
code_review: `get()`. (Btw since `inner` is plain, this check may end up hoisted and you'd never see it turning null).
target code: @Override public boolean isDisposed ( ) { return get ( ) ; }
response: @Override public boolean isDisposed() { <START> return get() == null; <END> }

sample: 447
buggy_code: public void close() throws IOException { if (s3Object != null) { <START> s3Object.close(); <END> } }
code_review: I think that we need `super.close()` here.
target code: public void close ( ) throws IOException { super . close ( ) ; if ( s3Object != null ) { s3Object . close ( ) ; } }
response: public void close() throws IOException { if (s3Object != null) { <START> super.close(); <END> } }

sample: 448
buggy_code: public void loadChunk(int x, int z) { <START> w.loadChunk(z, z); <END> }
code_review: (z, z) certainly doesn't look right.
target code: public void loadChunk ( int x , int z ) { w . loadChunk ( x , z ) ; }
response: public void loadChunk(int x, int z) { <START> w.loadChunk(x, z); <END> }

sample: 449
buggy_code: <START> public GeneratorUtil(TypeOracle typeOracle, <END> Logger logger, GeneratorContext generatorContext) { this.typeOracle = typeOracle; this.logger = logger; this.generatorContext = generatorContext; }
code_review: rm public
target code: GeneratorUtil ( TypeOracle typeOracle , Logger logger , GeneratorContext generatorContext ) { this . typeOracle = typeOracle ; this . logger = logger ; this . generatorContext = generatorContext ; }
response: <START> GeneratorUtil(TypeOracle typeOracle, <END> Logger logger, GeneratorContext generatorContext) { this.typeOracle = typeOracle; this.logger = logger; this.generatorContext = generatorContext; }

sample: 450
buggy_code: protected boolean failPassthroughVnicHotPlug() { if <START> (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) <END> { addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED); return true; } return false; }
code_review: replace equals with == for enums.
target code: protected boolean failPassthroughVnicHotPlug ( ) { if ( VmInterfaceType . pciPassthrough == VmInterfaceType . forValue ( getParameters ( ) . getNic ( ) . getType ( ) ) ) { addCanDoActionMessage ( EngineMessage . HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED ) ; return true ; } return false ; }
response: protected boolean failPassthroughVnicHotPlug() { if <START> (VmInterfaceType.pciPassthrough == VmInterfaceType.forValue(getParameters().getNic().getType())) <END> { addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED); return true; } return false; }

sample: 451
buggy_code: <START> public List<Map> getStageReachedCounts(Context context) throws SQLException { <END> return workspaceItemDAO.getStageReachedCounts(context); }
code_review: It would be great if this map could use generics so we know what it contains.
target code: public List < Map . Entry < Integer , Long > > getStageReachedCounts ( Context context ) throws SQLException { return workspaceItemDAO . getStageReachedCounts ( context ) ; }
response: <START> public List<Map<String, Integer>> getStageReachedCounts(Context context) throws SQLException { <END> return workspaceItemDAO.getStageReachedCounts(context); }

sample: 452
buggy_code: Evaluator( final ObjectMapper mapper, final AsyncTaskExecutor asyncTaskExecutor, <START> final long timeoutLength) { <END> this.mapper = mapper; this.asyncTaskExecutor = asyncTaskExecutor; this.timeoutLength = timeoutLength; }
code_review: usually this `) {` is on the next line
target code: protected Evaluator ( final ObjectMapper mapper , final AsyncTaskExecutor asyncTaskExecutor , final long timeoutLength ) { this . mapper = mapper ; this . asyncTaskExecutor = asyncTaskExecutor ; this . timeoutLength = timeoutLength ; }
response: Evaluator( final ObjectMapper mapper, final AsyncTaskExecutor asyncTaskExecutor, <START> final long timeoutLength <END> ) { this.mapper = mapper; this.asyncTaskExecutor = asyncTaskExecutor; this.timeoutLength = timeoutLength; }

sample: 453
buggy_code: public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient) <START> throws IOException { <END> // TODO(lu) should avoid throw exception in Java constructor to avoid half-baked class instances mMasterAddress = masterAddress; mMasterClient = masterClient; mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS); mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs; }
code_review: do we still need to throw exception here? if not, you can remove the next TODO
target code: public MetaMasterSync ( Address masterAddress , MetaMasterMasterClient masterClient ) { mMasterAddress = masterAddress ; mMasterClient = masterClient ; mHeartbeatTimeoutMs = ( int ) Configuration . getMs ( PropertyKey . MASTER_HEARTBEAT_TIMEOUT_MS ) ; mLastSuccessfulHeartbeatMs = System . currentTimeMillis ( ) - mHeartbeatTimeoutMs ; }
response: public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient) <START> throws IOException { <END> // TODO(lu) should avoid throw exception in Java constructor to avoid half-baked class instances mMasterAddress = masterAddress; mMasterClient = masterClient; mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS); mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs; } // Review: do we still need to throw exception here? if not, you can remove the next TODO

sample: 454
buggy_code: public void sendLayerDeleted(String layerName) { <START> listeners.stream().forEachOrdered(listener->{ <END> listener.layerDeleted(layerName); }); }
code_review: Seems me a ```` listeners.forEach(listener -> layerDeleted(layerName)); ```` would have been at the same time more compact, readable, and faster (streams are very slow)
target code: public void sendLayerDeleted ( String layerName ) { listeners . forEach ( listener - > { listener . layerDeleted ( layerName ) ; } ) ; }
response: public void sendLayerDeleted(String layerName) { <START> listeners.forEach(listener -> layerDeleted(layerName)); <END> }

sample: 455
buggy_code: public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) { <START> List<SqlIdentifier> columnList = new ArrayList<>(); <END> columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO)); columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO)); return columnList; }
code_review: Please immutable collection.
target code: public List < SqlIdentifier > getProjectionFields ( MetadataType metadataLevel , OptionManager options ) { return Arrays . asList ( new SqlIdentifier ( options . getString ( ExecConstants . IMPLICIT_FQN_COLUMN_LABEL ) , SqlParserPos . ZERO ) , new SqlIdentifier ( options . getString ( ExecConstants . IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL ) , SqlParserPos . ZERO ) ) ; }
response: public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) { <START> List<SqlIdentifier> columnList = new ArrayList<>(); <END> columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO)); columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO)); return Collections.unmodifiableList(columnList); }

sample: 456
buggy_code: protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) { <START> super((Snapshot)tx, encoder, tl); <END> this.tx = tx; this.encoder = encoder; this.tl = tl; }
code_review: can TypedSnapshotBase constructor take SnapshotBase instead of Snapshot?
target code: protected TypedTransaction ( Transaction tx , Encoder encoder , TypeLayer tl ) { super ( tx , encoder , tl ) ; this . tx = tx ; this . encoder = encoder ; this . tl = tl ; }
response: protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) { <START> super(tx, encoder, tl); <END> this.tx = tx; this.encoder = encoder; this.tl = tl; }

sample: 457
buggy_code: public int hashCode() { int result = name != null ? name.hashCode() : 0; <START> result = 31 * result + (permissions != null ? permissions.hashCode() : 0); <END> result = 31 * result + mask; return result; }
code_review: `permissions` can't be `null`, otherwise the constructor would throw a NPE.
target code: public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + permissions . hashCode ( ) ; result = 31 * result + mask ; return result ; }
response: public int hashCode() { int result = name != null ? name.hashCode() : 0; <START> result = 31 * result + permissions.hashCode(); <END> result = 31 * result + mask; return result; }

sample: 458
buggy_code: public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = <START> EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); <END> }
code_review: this.contributor
target code: public EEFTabbedPropertySheetPage ( Object contributor , String contributorId ) { if ( contributor instanceof IEEFTabbedPropertySheetPageContributor ) { this . contributor = ( IEEFTabbedPropertySheetPageContributor ) contributor ; } else { this . contributor = new ContributorWrapper ( contributor , contributorId ) ; } this . registry = EEFTabbedPropertyRegistry . getDefault ( this . contributor ) ; }
response: public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = <START> EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); <END> }

sample: 459
buggy_code: public List<String> getSuggestions(String input) { <START> return WorldEdit.getInstance().getPlatformManager() <END> .queryCapability(Capability.GAME_HOOKS).getWorlds().stream() .map(World::getId) .filter(world -> world.startsWith(input)) .collect(Collectors.toList()); }
code_review: You should probably extract the world-stream extraction to its own method.
target code: public List < String > getSuggestions ( String input ) { return getWorlds ( ) . map ( World : : getId ) . filter ( world - > world . startsWith ( input ) ) . collect ( Collectors . toList ( ) ) ; }
response: public List<String> getSuggestions(String input) { <START> return getWorlds().stream() <END> .map(World::getId) .filter(world -> world.startsWith(input)) .collect(Collectors.toList()); }

sample: 460
buggy_code: <START> protected void executeCommand() { <END> //disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage(); if(isStorageDisconnectSucceeded) { String connectionId = getConnection().getid(); if(StringUtils.isNotEmpty(connectionId)) { //remove the connection record from db getDbFacade().getStorageServerConnectionDao().remove(connectionId); setSucceeded(true); } } }
code_review: I don't understand something - now we will perform the this command for one host and then the connection will be removed from db, how we will perform the disconnect for other hosts? the load of connection will return null..no? you should take care of that i guess.
target code: protected void executeCommand ( ) { // disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage ( ) ; if ( isStorageDisconnectSucceeded ) { String connectionId = getConnection ( ) . getid ( ) ; if ( StringUtils . isNotEmpty ( connectionId ) ) { // remove the connection record from db getDbFacade ( ) . getStorageServerConnectionDao ( ) . remove ( connectionId ) ; } setSucceeded ( true ) ; } }
response: protected void executeCommand() { //disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage(); if(isStorageDisconnectSucceeded) { String connectionId = getConnection().getid(); if(StringUtils.isNotEmpty(connectionId)) { //remove the connection record from db getDbFacade().getStorageServerConnectionDao().remove(connectionId); setSucceeded(true); } } }

sample: 461
buggy_code: public void testNotEliminateSorts() { @Language("SQL") String sql = "SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"; PlanMatchPattern pattern = anyTree( sort( <START> window(windowMatcherBuilder -> windowMatcherBuilder <END> .specification(windowSpec) .addFunction(functionCall("row_number", Optional.empty(), ImmutableList.of())), anyTree(LINEITEM_TABLESCAN_Q)))); assertUnitPlan(sql, pattern); }
code_review: curious: why remove `anyTree`?
target code: public void testNotEliminateSorts ( ) { @Language ( "SQL" ) String sql = "SELECT quantity , row_number ( ) OVER ( ORDER BY quantity ) FROM lineitem ORDER BY tax" ; PlanMatchPattern pattern = anyTree ( sort ( anyTree ( window ( windowMatcherBuilder - > windowMatcherBuilder . specification ( windowSpec ) . addFunction ( functionCall ( "row_number" , Optional . empty ( ) , ImmutableList . of ( ) ) ) , anyTree ( LINEITEM_TABLESCAN_Q ) ) ) ) ) ; assertUnitPlan ( sql , pattern ) ; }
response: public void testNotEliminateSorts() { @Language("SQL") String sql = "SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"; PlanMatchPattern pattern = anyTree( sort( <START> window(windowMatcherBuilder -> windowMatcherBuilder <END> .specification(windowSpec) .addFunction(functionCall("row_number", Optional.empty(), ImmutableList.of())), LINEITEM_TABLESCAN_Q))); assertUnitPlan(sql, pattern); }

sample: 462
buggy_code: public Program getAssociatedProgram(Artifact artifact) { String extension = getAssociatedExtension(artifact); Program program = <START> ProgramFinder.findProgram(extension.toLowerCase()); <END> if (program == null) { throw new OseeArgumentException("No program associated with the extension [%s] found on your local machine.", extension); } return program; }
code_review: Perform this operation in the custom ProgramFinder.findProgram() method instead.
target code: public Program getAssociatedProgram ( Artifact artifact ) { String extension = getAssociatedExtension ( artifact ) ; Program program = ProgramFinder . findProgram ( extension ) ; if ( program == null ) { throw new OseeArgumentException ( "No program associated with the extension [ % s ] found on your local machine . " , extension ) ; } return program ; }
response: public Program getAssociatedProgram(Artifact artifact) { String extension = getAssociatedExtension(artifact); Program program = <START> ProgramFinder.findProgram(extension); <END> if (program == null) { throw new OseeArgumentException("No program associated with the extension [%s] found on your local machine.", extension); } return program; }

sample: 463
buggy_code: public final Iterable<N> toDepthFirstIterable() { <START> return () -> AbstractTree.this.depthFirstIterator(); <END> }
code_review: Please replace all the occurrences of `AbstractTree.this`. Indeed, the code style we are using does not recommend to add `this` as a prefix of a function call when the function is in the current object.
target code: public final Iterable < N > toDepthFirstIterable ( ) { return ( ) - > this . depthFirstIterator ( ) ; }
response: public final Iterable<N> toDepthFirstIterable() { <START> return () -> depthFirstIterator(); <END> }

sample: 464
buggy_code: void put(final K key, final V value) { clusterRegistry.put(scope, key, value); <START> System.out.println("putting key "+key+" ffrom thread "+Thread.currentThread().getName()); <END> localCacheInsert(key, value); }
code_review: This is definitely a leftover that must be removed.
target code: void put ( final K key , final V value ) { clusterRegistry . put ( scope , key , value ) ; localCacheInsert ( key , value ) ; }
response: void put(final K key, final V value) { clusterRegistry.put(scope, key, value); <START> System.out.println("putting key "+key+" from thread "+Thread.currentThread().getName()); <END> localCacheInsert(key, value); }

sample: 465
buggy_code: <START> public static String getWarningMessages(String filename){ <END> String warningMessage = ""; if (getErrorMessage(filename).length() == 0 && filename.length() > 0) { if (!filename.matches("[A-Za-z][A-Za-z0-9_]*")) { // check to make sure if filename has no spaces String errorMessage = MESSAGES.whitespaceProjectNameError(); filename = filename.replaceAll("( )+", " ").replace(" ","_"); warningMessage = errorMessage + ". \n '" + filename + "' will be used if continued."; } } return warningMessage; }
code_review: Missed a space here between the `)` and `{`
target code: public static String getWarningMessages ( String filename ) { String warningMessage = "" ; if ( getErrorMessage ( filename ) . length ( ) == 0 && filename . trim ( ) . length ( ) > 0 ) { if ( ! filename . matches ( " [ A - Za - z ] [ A - Za - z0 - 9_ ] * " ) ) { // check to make sure if filename has no spaces String errorMessage = MESSAGES . whitespaceProjectNameError ( ) ; filename = filename . trim ( ) . replaceAll ( " ( ) + " , " " ) . replace ( " " , "_" ) ; warningMessage = errorMessage + " . \n '" + filename + "' will be used if continued . " ; } } return warningMessage ; }
response: <START> public static String getWarningMessages(String filename) { <END> String warningMessage = ""; if (getErrorMessage(filename).length() == 0 && filename.length() > 0) { if (!filename.matches("[A-Za-z][A-Za-z0-9_]*")) { // check to make sure if filename has no spaces String errorMessage = MESSAGES.whitespaceProjectNameError(); filename = filename.replaceAll("( )+", " ").replace(" ","_"); warningMessage = errorMessage + ". \n '" + filename + "' will be used if continued."; } } return warningMessage; }

sample: 466
buggy_code: public @NonNull TraceSessionComponent[] getSessions() { List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class); if (compenents.size() > 0) { TraceSessionGroup group = (TraceSessionGroup)compenents.get(0); List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class); return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]); } return new <START> @NonNull TraceSessionComponent[0]; <END> }
code_review: this doesn't seem to change anything for me?
target code: public @NonNull TraceSessionComponent [ ] getSessions ( ) { List < ITraceControlComponent > compenents = getChildren ( TraceSessionGroup . class ) ; if ( compenents . size ( ) > 0 ) { TraceSessionGroup group = ( TraceSessionGroup ) compenents . get ( 0 ) ; List < ITraceControlComponent > sessions = group . getChildren ( TraceSessionComponent . class ) ; return sessions . toArray ( new @NonNull TraceSessionComponent [ sessions . size ( ) ] ) ; } return new TraceSessionComponent [ 0 ] ; }
response: public @NonNull TraceSessionComponent[] getSessions() { List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class); if (compenents.size() > 0) { TraceSessionGroup group = (TraceSessionGroup)compenents.get(0); List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class); return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]); } return new <START> @NonNull TraceSessionComponent[0]; <END> }

sample: 467
buggy_code: private static void cacheColors(Display display) { BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB(); FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB(); Color hyperlinkText= JFaceColors.getHyperlinkText(display); <START> Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display); <END> if (hyperlinkText != null) { LINK_COLOR_RGB= hyperlinkText.getRGB(); } if (activeHyperlinkText != null) { ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB(); } }
code_review: Minor: Move declaration before the if block where it is used?
target code: private static void cacheColors ( Display display ) { BG_COLOR_RGB = JFaceColors . getInformationViewerBackgroundColor ( display ) . getRGB ( ) ; FG_COLOR_RGB = JFaceColors . getInformationViewerForegroundColor ( display ) . getRGB ( ) ; Color hyperlinkText = JFaceColors . getHyperlinkText ( display ) ; if ( hyperlinkText != null ) { LINK_COLOR_RGB = hyperlinkText . getRGB ( ) ; } Color activeHyperlinkText = JFaceColors . getActiveHyperlinkText ( display ) ; if ( activeHyperlinkText != null ) { ACTIVE_LINK_COLOR_RGB = activeHyperlinkText . getRGB ( ) ; } }
response: private static void cacheColors(Display display) { BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB(); FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB(); Color hyperlinkText= JFaceColors.getHyperlinkText(display); <START> Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display); if (activeHyperlinkText != null) { ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB(); } <END> if (hyperlinkText != null) { LINK_COLOR_RGB= hyperlinkText.getRGB(); } }

sample: 468
buggy_code: private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) { if (f instanceof IRadioButton) { <START> return (IRadioButton<T>) f; //TODO: mnick <END> } else if (f instanceof ICompositeField) { for (IFormField sub : ((ICompositeField) f).getFields()) { IRadioButton<T> b = findFirstButtonInFieldTree(sub); if (b != null) { return b; } } } return null; }
code_review: you can use TypeCastUtility.getGenericsParameterClass(getClass(), IHolder.class); to check the type parameter
target code: private IRadioButton < T > findFirstButtonInFieldTree ( IFormField f ) { if ( f instanceof IRadioButton ) { return ( IRadioButton ) f ; } else if ( f instanceof ICompositeField ) { for ( IFormField sub : ( ( ICompositeField ) f ) . getFields ( ) ) { IRadioButton < T > b = findFirstButtonInFieldTree ( sub ) ; if ( b != null ) { return b ; } } } return null ; }
response: private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) { if (f instanceof IRadioButton) { <START> return (IRadioButton<T>) f; //TODO: mnick <END> } else if (f instanceof ICompositeField) { for (IFormField sub : ((ICompositeField) f).getFields()) { IRadioButton<T> b = findFirstButtonInFieldTree(sub); if (b != null) { return b; } } } return null; }

sample: 469
buggy_code: public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception { final String expected = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!DOCTYPE suppressions PUBLIC\n" <START> + " \"-//Puppy Crawl//DTD Suppressions Xpath Experimental 1.2//EN\"\n" <END> + " \"http://checkstyle.sourceforge.net/dtds/" + "suppressions_1_2_xpath_experimental.dtd\">\n" + "<suppressions>\n" + "</suppressions>\n"; exit.checkAssertionAfterwards(() -> { assertEquals("Unexpected output log", expected, systemOut.getLog()); assertEquals("Unexpected system error log", "", systemErr.getLog()); }); Main.main("-c", getPath("InputMainConfig-empty.xml"), "--generate-xpath-suppression", getPath("InputMainComplexityOverflow.java")); }
code_review: fix name
target code: public void testGenerateXpathSuppressionOptionEmptyConfig ( ) throws Exception { final String expected = "" ; exit . checkAssertionAfterwards ( ( ) - > { assertEquals ( "Unexpected output log" , expected , systemOut . getLog ( ) ) ; assertEquals ( "Unexpected system error log" , "" , systemErr . getLog ( ) ) ; } ) ; Main . main ( " - c" , getPath ( "InputMainConfig - empty . xml" ) , " -- generate - xpath - suppression" , getPath ( "InputMainComplexityOverflow . java" ) ) ; }
response: public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception { final String expected = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!DOCTYPE suppressions PUBLIC\n" <START> + " \"-//Puppy Crawl//DTD Suppressions Xpath Experimental 1.2//EN\"\n" <END> + " \"http://checkstyle.sourceforge.net/dtds/" + "suppressions_1_2_xpath_experimental.dtd\">\n" + "<suppressions>\n" + "</suppressions>\n"; exit.checkAssertionAfterwards(() -> { assertEquals("Unexpected output log", expected, systemOut.getLog()); assertEquals("Unexpected system error log", "", systemErr.getLog()); }); Main.main("-c", getPath("InputMainConfig-empty.xml"), "--generate-xpath-suppression", getPath("InputMainComplexityOverflow.java")); }

sample: 470
buggy_code: public String getPackageName() { if (clazz.getPackage() != null) { return clazz.getPackage().getName(); } <START> return null; <END> }
code_review: Can this method return null? Or should it return empty string?
target code: public String getPackageName ( ) { if ( clazz . getPackage ( ) != null ) { return clazz . getPackage ( ) . getName ( ) ; } return "" ; }
response: public String getPackageName() { if (clazz.getPackage() != null) { return clazz.getPackage().getName(); } <START> return ""; <END> }

sample: 471
buggy_code: public void testIsStringLiteral() { Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1); ASTLiteral literal = literals.iterator().next(); assertTrue(literal.isStringLiteral()); <START> assertEquals("String", literal.getTypeImage()); <END> }
code_review: This could also be `java.lang.String`.
target code: public void testIsStringLiteral ( ) { Set < ASTLiteral > literals = getNodes ( ASTLiteral . class , TEST1 ) ; assertTrue ( ( literals . iterator ( ) . next ( ) ) . isStringLiteral ( ) ) ; }
response: public void testIsStringLiteral() { Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1); ASTLiteral literal = literals.iterator().next(); assertTrue(literal.isStringLiteral()); <START> assertEquals("java.lang.String", literal.getTypeImage()); <END> }

sample: 472
buggy_code: public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys) { ImmutableMap.Builder builder = ImmutableMap.builder(); for (K key : keys <START> ) { <END> V value = getIfPresent(key); if (value != null) { builder.put(key, value); } } return builder.build(); }
code_review: formatting weird
target code: public Map < K , V > getAllPresent ( final Iterable < K > keys ) { ImmutableMap . Builder builder = ImmutableMap . builder ( ) ; for ( K key : keys ) { V value = getIfPresent ( key ) ; if ( value != null ) { builder . put ( key , value ) ; } } return builder . build ( ) ; }
response: public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys) { ImmutableMap.Builder builder = ImmutableMap.builder(); for (K key : keys <START> ) { <END> V value = getIfPresent(key); if (value != null) { builder.put(key, value); } } return builder.build(); }

sample: 473
buggy_code: <START> public void configure(ServerHttpSecurity http) { <END> ReactiveAuthenticationManager authenticationManager = getAuthenticationManager(); X509PrincipalExtractor principalExtractor = getPrincipalExtractor(); AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager); filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor)); http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION); }
code_review: Please make this protected to avoid exposing methods that consumers of the API do not care about.
target code: protected void configure ( ServerHttpSecurity http ) { ReactiveAuthenticationManager authenticationManager = getAuthenticationManager ( ) ; X509PrincipalExtractor principalExtractor = getPrincipalExtractor ( ) ; AuthenticationWebFilter filter = new AuthenticationWebFilter ( authenticationManager ) ; filter . setServerAuthenticationConverter ( new ServerX509AuthenticationConverter ( principalExtractor ) ) ; http . addFilterAt ( filter , SecurityWebFiltersOrder . AUTHENTICATION ) ; }
response: <START> protected void configure(ServerHttpSecurity http) { <END> ReactiveAuthenticationManager authenticationManager = getAuthenticationManager(); X509PrincipalExtractor principalExtractor = getPrincipalExtractor(); AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager); filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor)); http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION); }

sample: 474
buggy_code: public void action(AuthenticationFlowContext context) { if (DisplayUtils.isConsole(context)) { <START> ConsoleOTPFormAuthenticator.SINGLETON.action(context); <END> return; } validateOTP(context); }
code_review: Would it not be better to obtain this from the session? With this approach it's not pluggable.
target code: public void action ( AuthenticationFlowContext context ) { validateOTP ( context ) ; }
response: public void action(AuthenticationFlowContext context) { if (DisplayUtils.isConsole(context)) { <START> ConsoleOTPFormAuthenticator.SINGLETON.action(context); <END> return; } validateOTP(context); }

sample: 475
buggy_code: private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber, Repository which, Collection<IFile> resources) { for (GitSynchronizeData gsd : gsds) { if (which.equals(gsd.getRepository())) { <START> if (!resources.isEmpty()) <END> refreshResources(subscriber, resources); else refreshRepository(subscriber); } } }
code_review: A null check is needed also. An NPE will be thrown if reopening a very large project. java.lang.NullPointerException at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.handleResourceChange(GitSubscriberMergeContext.java:141) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.access$1(GitSubscriberMergeContext.java:137) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext$2.indexDiffChanged(GitSubscriberMergeContext.java:69) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.notifyListeners(IndexDiffCache.java:94) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.access$0(IndexDiffCache.java:86) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache$1.indexDiffChanged(IndexDiffCache.java:81) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.notifyListeners(IndexDiffCacheEntry.java:313) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.access$6(IndexDiffCacheEntry.java:306) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry$3.run(IndexDiffCacheEntry.java:171) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
target code: private void handleResourceChange ( GitResourceVariantTreeSubscriber subscriber , Repository which , Collection < IFile > resources ) { for ( GitSynchronizeData gsd : gsds ) { if ( which . equals ( gsd . getRepository ( ) ) && resources != null && ! resources . isEmpty ( ) ) refreshResources ( subscriber , resources ) ; } }
response: private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber, Repository which, Collection<IFile> resources) { for (GitSynchronizeData gsd : gsds) { if (which.equals(gsd.getRepository())) { <START> if (resources != null && !resources.isEmpty()) <END> refreshResources(subscriber, resources); else refreshRepository(subscriber); } } }

sample: 476
buggy_code: public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root, Sort rootSort) { <START> Set<Path> ret=new HashSet<Path>(); <END> if(rootSort!=null) { SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot()); for(SortFieldInfo fi:sfi) ret.add(fi.getName()); } return ret; }
code_review: Don't necessarily need the type info in the right hand assignment anymore. Only mention it because you use both ways throughout.
target code: public static Set < Path > getIncludedFieldsOfRootEntityForSort ( CompositeMetadata root , Sort rootSort ) { Set < Path > ret = new HashSet < > ( ) ; if ( rootSort != null ) { SortFieldInfo [ ] sfi = SortFieldInfo . buildSortFields ( rootSort , root . getFieldTreeRoot ( ) ) ; for ( SortFieldInfo fi : sfi ) ret . add ( fi . getName ( ) ) ; } return ret ; }
response: public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root, Sort rootSort) { <START> Set<Path> ret=new HashSet<>(); <END> if(rootSort!=null) { SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot()); for(SortFieldInfo fi:sfi) ret.add(fi.getName()); } return ret; }

sample: 477
buggy_code: public LocalCluster(String jarFileName, int siteCount, int hostCount, int kfactor, int clusterId, BackendTarget target, FailureState failureState, boolean debug, boolean isRejoinTest, Map<String, String> env) { // NOTE: isRejoinTest is unused <START> this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); <END> }
code_review: Why remove unused at only one level below if its not used at all remove all together.
target code: public LocalCluster ( String jarFileName , int siteCount , int hostCount , int kfactor , int clusterId , BackendTarget target , FailureState failureState , boolean debug , boolean isRejoinTest , Map < String , String > env ) { this ( null , null , jarFileName , siteCount , hostCount , kfactor , clusterId , target , failureState , debug , isRejoinTest , env ) ; }
response: public LocalCluster(String jarFileName, int siteCount, int hostCount, int kfactor, int clusterId, BackendTarget target, FailureState failureState, boolean debug, boolean isRejoinTest, Map<String, String> env) { // NOTE: isRejoinTest is unused <START> this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); <END> } // NOTE: isRejoinTest is unused <START> this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); <END>

sample: 478
buggy_code: public void execute(String userName) { FollowModeManager currentFollowModeManager = followModeManager; User userToFollow = findUser(userName); if (currentFollowModeManager == null) { return; } <START> User currentlyFollowedUser = followModeManager.getFollowedUser(); <END> if ((currentlyFollowedUser != null && !currentlyFollowedUser.equals(userToFollow)) || (currentlyFollowedUser == null && userToFollow != null)) { currentFollowModeManager.follow(userToFollow); } actionPerformed(); }
code_review: I would prefer to move this logic into the `FollowModeManager`
target code: public void execute ( String userName ) { FollowModeManager currentFollowModeManager = followModeManager ; User userToFollow = findUser ( userName ) ; if ( currentFollowModeManager == null ) { return ; } currentFollowModeManager . follow ( userToFollow ) ; actionPerformed ( ) ; }
response: public void execute(String userName) { FollowModeManager currentFollowModeManager = followModeManager; User userToFollow = findUser(userName); if (currentFollowModeManager == null) { return; } <START> currentFollowModeManager.follow(userToFollow); <END> actionPerformed(); }

sample: 479
buggy_code: @Override public Appendable write(Appendable appendable, Context context) throws IOException { <START> String sep = ""; <END> for (TypeName className : typeNames) { appendable.append(sep); className.write(appendable, context); sep = " & "; } return appendable; }
code_review: nit: `sep` > `separator` ?
target code: @Override public Appendable write ( Appendable appendable , Context context ) throws IOException { Iterator < TypeName > iterator = typeNames . iterator ( ) ; if ( iterator . hasNext ( ) ) { iterator . next ( ) . write ( appendable , context ) ; while ( iterator . hasNext ( ) ) { appendable . append ( " & " ) ; iterator . next ( ) . write ( appendable , context ) ; } } return appendable ; }
response: @Override public Appendable write(Appendable appendable, Context context) throws IOException { <START> String separator = ""; <END> for (TypeName className : typeNames) { appendable.append(separator); className.write(appendable, context); separator = " & "; } return appendable; }

sample: 480
buggy_code: public void flush() throws IOException { <START> entryLogManager.flushCurrentLogs(); <END> entryLogManager.flushRotatedLogs(); }
code_review: for single-log manager, it is better to flush `rotated logs` before flushing `current logs`, because the way how it rotates files and do the checkpoint. I would prefer keeping existing logic unchanged to reduce the risks. besides that, why not provide `flush` method in EntryLogManager? so different entry log manager implementation can implement its own flushing logic rather than exposing this knowledge to EntryLogger. If you provide `flush` method, it is possible that you don't need to expose `flushCurrentLogs` and `flushRotatedLogs`.
target code: public void flush ( ) throws IOException { entryLogManager . flush ( ) ; }
response: public void flush() throws IOException { <START> entryLogManager.flushRotatedLogs(); <END> entryLogManager.flushCurrentLogs(); }

sample: 481
buggy_code: public void disableWireframe() { boolean refreshTaskList = false; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling(); <START> if (!getDesiredStateChanges().contains(faceCullingStateChange)) { <END> addDesiredStateChange(faceCullingStateChange); refreshTaskList = true; } if (getDesiredStateChanges().contains(wireframeStateChange)) { removeDesiredStateChange(wireframeStateChange); refreshTaskList = true; } if (refreshTaskList) { worldRenderer.requestTaskListRefresh(); } }
code_review: Also notice OpaqueObjectsNode.java needs the same treatment.
target code: public void disableWireframe ( ) { if ( getDesiredStateChanges ( ) . contains ( wireframeStateChange ) ) { addDesiredStateChange ( faceCullingStateChange ) ; removeDesiredStateChange ( wireframeStateChange ) ; worldRenderer . requestTaskListRefresh ( ) ; } }
response: public void disableWireframe() { boolean refreshTaskList = false; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling(); <START> if (!getDesiredStateChanges().contains(faceCullingStateChange)) { <END> addDesiredStateChange(faceCullingStateChange); refreshTaskList = true; } if (getDesiredStateChanges().contains(wireframeStateChange)) { removeDesiredStateChange(wireframeStateChange); refreshTaskList = true; } if (refreshTaskList) { worldRenderer.requestTaskListRefresh(); } }

sample: 482
buggy_code: public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) { List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId()); connections.clear(); connections.addAll(res); <START> return true; <END> }
code_review: What's the point of this return value if it's always true?
target code: public void prepareConnectHostToStoragePoolServers ( ConnectHostToStoragePoolServersParameters parameters , List < StorageServerConnections > connections ) { List < StorageServerConnections > res = updateIfaces ( connections , parameters . getVds ( ) . getId ( ) ) ; connections . clear ( ) ; connections . addAll ( res ) ; }
response: public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) { List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId()); connections.clear(); connections.addAll(res); <START> return true; <END> }

sample: 483
buggy_code: public HibernateErrorReportingServiceDao() { <START> this.errorOccurrenceConverter = new ErrorOccurrenceConverter(); <END> }
code_review: I am not sure that converter should be part of DAO. Given we still using save on single entity I would suggest i would move that code to Service layer.
target code: public HibernateErrorReportingServiceDao ( ) { }
response: public HibernateErrorReportingServiceDao() { <START> this.errorOccurrenceConverter = new ErrorOccurrenceConverter(); <END> }

sample: 484
buggy_code: public JettyConfig getJettyConfig() { <START> if(jettyConfig != null) <END> { return jettyConfig; } else { return new DefaultJettyConfig(); } }
code_review: Would much rather use the ternary operator here. Or even Optional, since we're on Java8 now. ``` Optional.ofNullable(jettyConfig).orElse(() -> new DefaultJettyConfig()); ```
target code: public JettyConfig getJettyConfig ( ) { return jettyConfig != null ? jettyConfig : new DefaultJettyConfig ( ) ; }
response: public JettyConfig getJettyConfig() { <START> return Optional.ofNullable(jettyConfig).orElse(() -> new DefaultJettyConfig()); <END> }

sample: 485
buggy_code: public void setNumThreads(final Integer numThreads) { <START> m_threads = ConfigUtils.assertNotNull(numThreads, "threads"); <END> }
code_review: Why do we not allow this field to be null?
target code: public void setNumThreads ( final Integer numThreads ) { m_threads = numThreads ; }
response: public void setNumThreads(final Integer numThreads) { <START> m_threads = numThreads; <END> }

sample: 486
buggy_code: <START> public String getModeName() { <END> String header = getHeader(); return header.substring(0, header.indexOf('"') - 1); }
code_review: change to private
target code: private String getModeName ( ) { String header = getHeader ( ) ; return header . substring ( 0 , header . indexOf ( '"' ) - 1 ) ; }
response: <START> private String getModeName() { <END> String header = getHeader(); return header.substring(0, header.indexOf('"') - 1); }

sample: 487
buggy_code: private List<RequestInfo> pollForRequests() { // these are ids that were successfully put for an operation that eventually failed idsToDelete.clear(); <START> putManager.getIdsToDelete(idsToDelete); <END> // this is a best effort to delete ids for cleanup purposes (these may fail and we will // not do anything about it at this time). for (String blobId : idsToDelete) { // possibly add a batch api going forward. deleteManager .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null); } List<RequestInfo> requests = new ArrayList<RequestInfo>(); putManager.poll(requests); getManager.poll(requests); deleteManager.poll(requests); return requests; }
code_review: If you make the getIdsToDelete() to return a list of blob Ids, we can avoid idsToDelete.clear(). We can just call idsToDelete = putManager.getIdsToDelete() everytime.
target code: private List < RequestInfo > pollForRequests ( ) { // these are ids that were successfully put for an operation that eventually failed idsToDelete . clear ( ) ; putManager . getIdsToDelete ( idsToDelete ) ; // this is a best effort to delete ids for cleanup purposes ( these may fail and we will // not do anything about it at this time ) . for ( String blobId : idsToDelete ) { // possibly add a batch api going forward . deleteManager . submitDeleteBlobOperation ( blobId , new FutureResult < Void > ( ) , null ) ; } List < RequestInfo > requests = new ArrayList < RequestInfo > ( ) ; putManager . poll ( requests ) ; getManager . poll ( requests ) ; deleteManager . poll ( requests ) ; return requests ; }
response: private List<RequestInfo> pollForRequests() { // these are ids that were successfully put for an operation that eventually failed idsToDelete.clear(); <START> idsToDelete = putManager.getIdsToDelete(); <END> // this is a best effort to delete ids for cleanup purposes (these may fail and we will // not do anything about it at this time). for (String blobId : idsToDelete) { // possibly add a batch api going forward. deleteManager .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null); } List<RequestInfo> requests = new ArrayList<RequestInfo>(); putManager.poll(requests); getManager.poll(requests); deleteManager.poll(requests); return requests; }

sample: 488
buggy_code: public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager) { Type type = boundVariables.getTypeVariable("E"); MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation( <START> functionManager.resolveOperator(operatorType, TypeSignatureProvider.fromTypes(ImmutableList.of(type, type)))).getMethodHandle(); <END> return generateAggregation(type, compareMethodHandle); }
code_review: Static import `fromTypes`.
target code: public InternalAggregationFunction specialize ( BoundVariables boundVariables , int arity , TypeManager typeManager , FunctionManager functionManager ) { Type type = boundVariables . getTypeVariable ( "E" ) ; MethodHandle compareMethodHandle = functionManager . getScalarFunctionImplementation ( functionManager . resolveOperator ( operatorType , fromTypes ( ImmutableList . of ( type , type ) ) ) ) . getMethodHandle ( ) ; return generateAggregation ( type , compareMethodHandle ) ; }
response: public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager) { Type type = boundVariables.getTypeVariable("E"); MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation( <START> functionManager.resolveOperator(operatorType, fromTypes(ImmutableList.of(type, type)))).getMethodHandle(); <END> return generateAggregation(type, compareMethodHandle); }

sample: 489
buggy_code: public AccountInfo getAccountInfo() throws IOException { CoingiBalances coingiBalances; try { coingiBalances = getCoingiBalance(); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); <START> } <END>
code_review: it would be easier to read if would surround the entire method with this type of try / catch like: ``` @Override public AccountInfo getAccountInfo() throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance(); return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } } ``` please apply this hint to all the methods that have this type of try catch
target code: public AccountInfo getAccountInfo ( ) throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance ( ) ; return CoingiAdapters . adaptAccountInfo ( coingiBalances , exchange . getExchangeSpecification ( ) . getUserName ( ) ) ; } catch ( CoingiException e ) { throw CoingiErrorAdapter . adapt ( e ) ; } }
response: public AccountInfo getAccountInfo() throws IOException { <START> try { CoingiBalances coingiBalances = getCoingiBalance(); return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } <END> }

sample: 490
buggy_code: public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context) { <START> IdentityHashMap<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> node.getSources().forEach(source -> ret.putAll(source.accept(this, context))); return ret; }
code_review: `Map<TableScanNode, Void> result = new IdentityHashMap<>();`
target code: public Map < TableScanNode , Void > visitPlan ( PlanNode node , Void context ) { Map < TableScanNode , Void > ret = new IdentityHashMap < > ( ) ; node . getSources ( ) . forEach ( source - > ret . putAll ( source . accept ( this , context ) ) ) ; return ret ; }
response: public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context) { <START> Map<TableScanNode, Void> result = new IdentityHashMap<>(); <END> node.getSources().forEach(source -> result.putAll(source.accept(this, context))); return result; }

sample: 491
buggy_code: protected RevCommit findHead(Repository repo) { try (RevWalk walk = new RevWalk(repo)) { try { ObjectId head = repo.resolve(HEAD); return walk.parseCommit(head); <START> } catch (RevisionSyntaxException e) { <END> throw new RuntimeException(e); } catch (AmbiguousObjectException e) { throw new RuntimeException(e); } catch (IncorrectObjectTypeException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } }
code_review: you handle all these exceptions in the same way so you can use multi-catch: } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) {
target code: protected RevCommit findHead ( Repository repo ) { try ( RevWalk walk = new RevWalk ( repo ) ) { try { ObjectId head = repo . resolve ( HEAD ) ; return walk . parseCommit ( head ) ; } catch ( RevisionSyntaxException | IOException e ) { throw new RuntimeException ( e ) ; } } }
response: protected RevCommit findHead(Repository repo) { try (RevWalk walk = new RevWalk(repo)) { try { ObjectId head = repo.resolve(HEAD); return walk.parseCommit(head); <START> } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) { <END> throw new RuntimeException(e); } } }

sample: 492
buggy_code: public void process(EquivalentContentUpdatedMessage message) throws RecoverableException { Id contentId = message.getContentRef().getId(); <START> log.debug("Processing message on id {}, took PT{}S, message: {}", <END> contentId, getTimeToProcessInSeconds(message)); Timer.Context time = timer.time(); try { Content content = getContent(contentId); neo4JContentStore.writeContent(content); time.stop(); } catch (Exception e) { failureMeter.mark(); throw Throwables.propagate(e); } }
code_review: You're not passing in the message even though you have a marker there. Think that might throw weird RTEs.
target code: public void process ( EquivalentContentUpdatedMessage message ) throws RecoverableException { Id contentId = message . getContentRef ( ) . getId ( ) ; log . debug ( "Processing message on id { } , took PT { } S , message : { } " , contentId , getTimeToProcessInSeconds ( message ) , message ) ; Timer . Context time = timer . time ( ) ; try { Content content = getContent ( contentId ) ; neo4JContentStore . writeContent ( content ) ; time . stop ( ) ; } catch ( Exception e ) { failureMeter . mark ( ) ; throw Throwables . propagate ( e ) ; } }
response: public void process(EquivalentContentUpdatedMessage message) throws RecoverableException { Id contentId = message.getContentRef().getId(); <START> log.debug("Processing message on id {}, took PT{}S, message: {}", contentId, getTimeToProcessInSeconds(message), message); <END> Timer.Context time = timer.time(); try { Content content = getContent(contentId); neo4JContentStore.writeContent(content); time.stop(); } catch (Exception e) { failureMeter.mark(); throw Throwables.propagate(e); } }

sample: 493
buggy_code: public String apply(String dimValue) { <START> if (dimValue == null) return null; <END> Matcher matcher = pattern.matcher(dimValue); return matcher.find() ? dimValue : null; }
code_review: Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though.
target code: public String apply ( String dimValue ) { dimValue = ( dimValue == null ) ? "" : dimValue ; Matcher matcher = pattern . matcher ( dimValue ) ; return matcher . find ( ) ? dimValue : null ; }
response: public String apply(String dimValue) { <START> if (dimValue == null) return ""; <END> Matcher matcher = pattern.matcher(dimValue); return matcher.find() ? dimValue : null; }

sample: 494
buggy_code: private void writeSubscribeCommands( String repoName, List<SubscribeCommand> commands) throws IOException { write("repository " + repoName); for (SubscribeCommand cmd : commands) { switch (cmd.getCommand()) { case SUBSCRIBE: write("want " + cmd.getSpec()); break; case UNSUBSCRIBE: write("stop " + cmd.getSpec()); break; <START> } <END> } }
code_review: default: throw new IllegalArgumentException...
target code: private void writeSubscribeCommands ( String repoName , List < SubscribeCommand > commands ) throws IOException { write ( "repository " + repoName ) ; for ( SubscribeCommand cmd : commands ) { switch ( cmd . getCommand ( ) ) { case SUBSCRIBE : write ( "want " + cmd . getSpec ( ) ) ; break ; case UNSUBSCRIBE : write ( "stop " + cmd . getSpec ( ) ) ; break ; default : throw new IllegalArgumentException ( ) ; } } }
response: private void writeSubscribeCommands( String repoName, List<SubscribeCommand> commands) throws IOException { write("repository " + repoName); for (SubscribeCommand cmd : commands) { switch (cmd.getCommand()) { case SUBSCRIBE: write("want " + cmd.getSpec()); break; case UNSUBSCRIBE: write("stop " + cmd.getSpec()); break; default: throw new IllegalArgumentException("Unknown command: " + cmd.getCommand()); } } }

sample: 495
buggy_code: private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) { Set<GlusterServerInfo> fetchedServers = null; <START> while (fetchedServers == null && existingServers.size() > 0) { <END> fetchedServers = fetchServers(upServer); if (fetchedServers == null) { logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED); // Couldn't fetch servers from the up server. Mark it as non-operational setNonOperational(upServer); existingServers.remove(upServer); upServer = getNewUpServer(existingServers, upServer); } } return fetchedServers; }
code_review: consider !existingServes.isEmpty()
target code: private Set < GlusterServerInfo > fetchServers ( VDS upServer , List < VDS > existingServers ) { Set < GlusterServerInfo > fetchedServers = null ; while ( fetchedServers == null && ! existingServers . isEmpty ( ) ) { fetchedServers = fetchServers ( upServer ) ; if ( fetchedServers == null ) { logServerMessage ( upServer , AuditLogType . GLUSTER_SERVERS_LIST_FAILED ) ; // Couldn't fetch servers from the up server . Mark it as non - operational setNonOperational ( upServer ) ; existingServers . remove ( upServer ) ; upServer = getNewUpServer ( existingServers , upServer ) ; } } return fetchedServers ; }
response: private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) { Set<GlusterServerInfo> fetchedServers = null; <START> while (fetchedServers == null && !existingServers.isEmpty()) { <END> fetchedServers = fetchServers(upServer); if (fetchedServers == null) { logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED); // Couldn't fetch servers from the up server. Mark it as non-operational setNonOperational(upServer); existingServers.remove(upServer); upServer = getNewUpServer(existingServers, upServer); } } return fetchedServers; }

sample: 496
buggy_code: public static String sanitizeSecondCachedKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId()); }
code_review: ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck)
target code: public static String sanitizeSecondCachedKey ( final Contentlet vanityUrl ) throws DotDataException , DotSecurityException { Host host = hostAPI . find ( vanityUrl . getStringProperty ( VanityUrlContentType . SITE_FIELD_VAR ) , APILocator . systemUser ( ) , false ) ; return sanitizeSecondCacheKey ( host . getIdentifier ( ) , vanityUrl . getLanguageId ( ) ) ; }
response: public static String sanitizeSecondCachedKey(final Contentlet vanityUrl) <START> throws DotDataException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId()); }

sample: 497
buggy_code: void remove(I key) { Integer prev = this.identityMap.remove(key); <START> if (prev != null) this.objectList.set(prev, null); <END> }
code_review: please keep the body of an `if` on its own line
target code: void remove ( I key ) { Integer prev = this . identityMap . remove ( key ) ; if ( prev != null ) { this . objectList . set ( prev , null ) ; } }
response: void remove(I key) { Integer prev = this.identityMap.remove(key); <START> if (prev != null) { this.objectList.set(prev, null); } <END> }

sample: 498
buggy_code: public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof TaskPropertyType)) { return false; } TaskPropertyType that = (TaskPropertyType) o; <START> if (!name.equals(that.name)) { <END> return false; } return true; }
code_review: This is always FALSE. since name is `static final`
target code: public boolean equals ( Object o ) { return this == o || o instanceof TaskPropertyType ; }
response: public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof TaskPropertyType)) { return false; } TaskPropertyType that = (TaskPropertyType) o; <START> if (!name.equals(that.name)) { return false; } <END> return true; }

sample: 499
buggy_code: <START> protected long obtainEntityId() { <END> return nextEntityId++; }
code_review: This could be `private` right?
target code: private long obtainEntityId ( ) { return nextEntityId ++ ; }
response: <START> private long obtainEntityId() { <END> return nextEntityId++; }

sample: 500
buggy_code: public void markInCatalog() { <START> exportLog.info("ExportDataSource for table " + m_tableName + " partition " + m_partitionId + " marked as in catalog."); <END> m_isInCatalog = true; }
code_review: I'm not sure that this INFO message is helpful to users.
target code: public void markInCatalog ( ) { m_isInCatalog = true ; }
response: public void markInCatalog() { <START> m_isInCatalog = true; <END> }

sample: 501
buggy_code: private static boolean canConvert(ParameterDefinition def, ParameterValue v) { return def instanceof SimpleParameterDefinition && !(def instanceof StringParameterDefinition) && v instanceof StringParameterValue; <START> } <END>
code_review: This results conversion will be applyed also to subclass of `StringParameterValue`. It would be better applied to exact `StringParameterValue`.
target code: private static boolean canConvert ( ParameterDefinition def , ParameterValue v ) { return def instanceof SimpleParameterDefinition && ! ( def instanceof StringParameterDefinition ) && v . getClass ( ) . equals ( StringParameterValue . class ) ; }
response: private static boolean canConvert(ParameterDefinition def, ParameterValue v) { return def instanceof SimpleParameterDefinition && !(def instanceof StringParameterDefinition) && v instanceof StringParameterValue; }

sample: 502
buggy_code: public void setUp() { <START> deviceHandler = new EventHandlerTest(); <END> passingHandler = new FilterHandler(); filtingHandler = new FilterHandler(); filtingHandler.setFilterInvalid(true); filtingHandler.setFilterZero(true); filtingHandler.setFilterDuplicate(true); filtingHandler.setFilterFuture(true); filtingHandler.setFilterApproximate(true); filtingHandler.setFilterStatic(true); filtingHandler.setFilterDistance(10); filtingHandler.setFilterLimit(10); }
code_review: Why are you using `EventHandlerTest` here? It has nothing to do with filtering.
target code: public void setUp ( ) { passingHandler = new FilterHandler ( ) ; filtingHandler = new FilterHandler ( ) ; filtingHandler . setFilterInvalid ( true ) ; filtingHandler . setFilterZero ( true ) ; filtingHandler . setFilterDuplicate ( true ) ; filtingHandler . setFilterFuture ( true ) ; filtingHandler . setFilterApproximate ( true ) ; filtingHandler . setFilterStatic ( true ) ; filtingHandler . setFilterDistance ( 10 ) ; filtingHandler . setFilterLimit ( 10 ) ; }
response: public void setUp() { <START> deviceHandler = new EventHandler(); <END> passingHandler = new FilterHandler(); filtingHandler = new FilterHandler(); filtingHandler.setFilterInvalid(true); filtingHandler.setFilterZero(true); filtingHandler.setFilterDuplicate(true); filtingHandler.setFilterFuture(true); filtingHandler.setFilterApproximate(true); filtingHandler.setFilterStatic(true); filtingHandler.setFilterDistance(10); filtingHandler.setFilterLimit(10); }

sample: 503
buggy_code: public void download(String url, String downloadPath) { InputStream in = null; try { in = new URL(url).openStream(); FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in)); System.out.println(IOUtils.toString(in)); } catch (IOException e) { <START> log.error(e); <END> } finally { IOUtils.closeQuietly(in); } }
code_review: The connector setup should fail when an exception occurs.
target code: public boolean download ( String url , String downloadPath ) { InputStream in = null ; try { in = new URL ( url ) . openStream ( ) ; FileUtils . writeByteArrayToFile ( new File ( downloadPath ) , IOUtils . toByteArray ( in ) ) ; return true ; } catch ( IOException e ) { log . error ( e ) ; return false ; } finally { IOUtils . closeQuietly ( in ) ; } }
response: public void download(String url, String downloadPath) { InputStream in = null; try { in = new URL(url).openStream(); FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in)); System.out.println(IOUtils.toString(in)); } catch (IOException e) { <START> throw new RuntimeException(e); <END> } finally { IOUtils.closeQuietly(in); } }

sample: 504
buggy_code: private boolean getOldChildStale(IObservable child) { Boolean oldChildValue = staleMap.get(child); boolean oldChildStale = <START> oldChildValue == null ? false : oldChildValue .booleanValue(); <END> return oldChildStale; }
code_review: Simpler: oldChildValue != && oldChildValue.booleanValue()
target code: private boolean getOldChildStale ( IObservable child ) { Boolean oldChildValue = staleMap . get ( child ) ; boolean oldChildStale = oldChildValue != null && oldChildValue ; return oldChildStale ; }
response: private boolean getOldChildStale(IObservable child) { Boolean oldChildValue = staleMap.get(child); boolean oldChildStale = <START> oldChildValue != null && oldChildValue.booleanValue(); <END> return oldChildStale; }

sample: 505
buggy_code: public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) { if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return; if (editor.getSettings().isVariableInplaceRenameEnabled()) { final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor); <START> if (templateState != null && !templateState.isFinished()) return; <END> } performAction(new GoIntroduceOperation(project, editor, file)); }
code_review: Add tooltip
target code: public void invoke ( @NotNull final Project project , final Editor editor , PsiFile file , DataContext dataContext ) { if ( ! CommonRefactoringUtil . checkReadOnlyStatus ( file ) ) return ; performAction ( new GoIntroduceOperation ( project , editor , file ) ) ; }
response: public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) { if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return; if (editor.getSettings().isVariableInplaceRenameEnabled()) { final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor); <START> if (templateState != null && !templateState.isFinished()) return; <END> } performAction(new GoIntroduceOperation(project, editor, file)); }

sample: 506
buggy_code: <START> private List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) { <END> List<String> isoFileList = new ArrayList<String>(); File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info)); for (File file : filterOvirtFiles) { isoFileList.add(file.getName()); } return isoFileList; }
code_review: but you removed the static from there as well.
target code: private static List < String > getListOfIsoFiles ( File directory , OVirtNodeInfo info ) { List < String > isoFileList = new ArrayList < String > ( ) ; File [ ] filterOvirtFiles = filterOvirtFiles ( directory , getIsoPattern ( info ) ) ; for ( File file : filterOvirtFiles ) { isoFileList . add ( file . getName ( ) ) ; } return isoFileList ; }
response: <START> private static List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) { <END> List<String> isoFileList = new ArrayList<String>(); File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info)); for (File file : filterOvirtFiles) { isoFileList.add(file.getName()); } return isoFileList; }

sample: 507
buggy_code: EWAHCompressedBitmap getBitmap() { // Fast path to immediately return the expanded result. Object r = bitmapContainer; if (r instanceof EWAHCompressedBitmap) return (EWAHCompressedBitmap) r; // Expand the bitmap and cache the result. XorCompressedBitmap xb = (XorCompressedBitmap) r; EWAHCompressedBitmap out = xb.bitmap; <START> while (true) { <END> r = xb.xorBitmap.bitmapContainer; if (r instanceof EWAHCompressedBitmap) { bitmapContainer = out = out.xor((EWAHCompressedBitmap) r); return out; } xb = (XorCompressedBitmap) r; out = out.xor(xb.bitmap); } }
code_review: nit: jgit spells this for (;;)
target code: EWAHCompressedBitmap getBitmap ( ) { // Fast path to immediately return the expanded result . Object r = bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) return ( EWAHCompressedBitmap ) r ; // Expand the bitmap and cache the result . XorCompressedBitmap xb = ( XorCompressedBitmap ) r ; EWAHCompressedBitmap out = xb . bitmap ; for ( ; ; ) { r = xb . xorBitmap . bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) { out = out . xor ( ( EWAHCompressedBitmap ) r ) ; bitmapContainer = out ; return out ; } xb = ( XorCompressedBitmap ) r ; out = out . xor ( xb . bitmap ) ; } }
response: EWAHCompressedBitmap getBitmap() { // Fast path to immediately return the expanded result. Object r = bitmapContainer; if (r instanceof EWAHCompressedBitmap) return (EWAHCompressedBitmap) r; // Expand the bitmap and cache the result. XorCompressedBitmap xb = (XorCompressedBitmap) r; EWAHCompressedBitmap out = xb.bitmap; <START> for (;;) { <END> r = xb.xorBitmap.bitmapContainer; if (r instanceof EWAHCompressedBitmap) { bitmapContainer = out = out.xor((EWAHCompressedBitmap) r); return out; } xb = (XorCompressedBitmap) r; out = out.xor(xb.bitmap); } }

sample: 508
buggy_code: public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store, CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) { Assert.notNull(processor); Assert.notNull(store); setMessageStore(store); this.outputProcessor = processor; this.correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy; this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy; <START> super.messagingTemplate.setSendTimeout(DEFAULT_S<END>_TIMEOUT); <END> sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy; }
code_review: ??? `this.` of course. That's why I said to revert those all changes for the `messagingTemplate` and PR is becoming clear
target code: public AbstractCorrelatingMessageHandler ( MessageGroupProcessor processor , MessageGroupStore store , CorrelationStrategy correlationStrategy , ReleaseStrategy releaseStrategy ) { Assert . notNull ( processor ) ; Assert . notNull ( store ) ; setMessageStore ( store ) ; this . outputProcessor = processor ; this . correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy ( IntegrationMessageHeaderAccessor . CORRELATION_ID ) : correlationStrategy ; this . releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy ( ) : releaseStrategy ; this . messagingTemplate . setSendTimeout ( DEFAULT_SEND_TIMEOUT ) ; sequenceAware = this . releaseStrategy instanceof SequenceSizeReleaseStrategy ; }
response: public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store, CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) { Assert.notNull(processor); Assert.notNull(store); setMessageStore(store); this.outputProcessor = processor; this.correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy; this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy; <START> this.messagingTemplate.setSendTimeout(DEFAULT_S<END>_TIMEOUT); <END> sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy; }

sample: 509
buggy_code: public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) { <START> return groupToBootScript.apply(group, null); <END> }
code_review: Hmmm this is wrong now? There should be two methods, one passing null and the other one passing the nodeName.
target code: public Statement createBootstrapScriptForGroup ( String group , @Nullable String nodeName ) { return groupToBootScript . apply ( group , nodeName ) ; }
response: public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) { <START> return groupToBootScript.apply(group, nodeName); <END> }

sample: 510
buggy_code: public boolean create(Personname personnameRecord) { LOG.trace("PersonnameDAO.create() - Begin"); <START> boolean result = true; <END> if (personnameRecord != null) { result = super.create(personnameRecord); } LOG.trace("PersonnameDAO.create() - End"); return result; }
code_review: No need for result variable
target code: public boolean create ( Personname personnameRecord ) { LOG . trace ( "PersonnameDAO . create ( ) - Begin" ) ; return personnameRecord != null ? super . create ( personnameRecord ) : true ; }
response: public boolean create(Personname personnameRecord) { LOG.trace("PersonnameDAO.create() - Begin"); <START> boolean result = true; <END> if (personnameRecord != null) { super.create(personnameRecord); } LOG.trace("PersonnameDAO.create() - End"); return result; }

sample: 511
buggy_code: public void handleInvocation(EJBClientInvocationContext context) throws Exception { <START> log.info("In the client interceptor handleInvocation : " + this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); <END> context.getContextData().put("ClientInterceptorInvoked", this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); // Must make this call context.sendRequest(); }
code_review: Please only log at debug or trace
target code: public void handleInvocation ( EJBClientInvocationContext context ) throws Exception { log . debug ( "In the client interceptor handleInvocation : " + this . getClass ( ) . getName ( ) + " " + context . getViewClass ( ) + " " + context . getLocator ( ) ) ; // Must make this call context . sendRequest ( ) ; }
response: public void handleInvocation(EJBClientInvocationContext context) throws Exception { <START> log.debug("In the client interceptor handleInvocation : " + this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); <END> context.getContextData().put("ClientInterceptorInvoked", this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); // Must make this call context.sendRequest(); }

sample: 512
buggy_code: public void edit(final NewExternalSubnetModel subnet) { driver.edit(subnet); <START> if (subnet.getNetwork().getEntity() != null){ <END> networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName()); } }
code_review: If I'm not mistaken, it shouldn't be possible for subnet.getNetwork() to be null, so you can drop the check.
target code: public void edit ( final NewExternalSubnetModel subnet ) { driver . edit ( subnet ) ; networkEditor . asValueBox ( ) . setValue ( subnet . getNetwork ( ) . getEntity ( ) . getName ( ) ) ; }
response: public void edit(final NewExternalSubnetModel subnet) { driver.edit(subnet); <START> networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName()); <END> }

sample: 513
buggy_code: protected AddVmFromTemplateCommand<AddVmParameters> createCommand() { initVM(); AddVmParameters <START> param = <END> new AddVmParameters(vm); return new AddVmFromTemplateCommand<>(param, null); }
code_review: this is probably simple enough to be inlined...
target code: protected AddVmFromTemplateCommand < AddVmParameters > createCommand ( ) { initVM ( ) ; return new AddVmFromTemplateCommand < > ( new AddVmParameters ( vm ) , null ) ; }
response: protected AddVmFromTemplateCommand<AddVmParameters> createCommand() { initVM(); AddVmParameters <START> param = <END> new AddVmParameters(vm); return new AddVmFromTemplateCommand<>(param, null); }

sample: 514
buggy_code: public void testGetNameFromPath() { <START> String path1 = "/group1"; <END> String path2 = "/group1/group2/group3"; String emptyPath = ""; String nullPath = null; String rootPath = "/"; assertEquals(HDF5Utils.getNameFromPath(path1), "group1"); assertEquals(HDF5Utils.getNameFromPath(path2), "group3"); assertEquals(HDF5Utils.getNameFromPath(emptyPath), ""); assertNull(HDF5Utils.getNameFromPath(nullPath)); assertEquals(HDF5Utils.getNameFromPath(rootPath), ""); }
code_review: Please split this test into several, testing each case separately.
target code: public void testGetNameFromPath ( ) { String path1 = " / group1" ; assertEquals ( HDF5Utils . getNameFromPath ( path1 ) , "group1" ) ; }
response: public void testGetNameFromPath() { String path1 = "/group1"; String path2 = "/group1/group2/group3"; String emptyPath = ""; String nullPath = null; String rootPath = "/"; assertEquals(HDF5Utils.getNameFromPath(path1), "group1"); assertEquals(HDF5Utils.getNameFromPath(path2), "group3"); assertEquals(HDF5Utils.getNameFromPath(emptyPath), ""); assertNull(HDF5Utils.getNameFromPath(nullPath)); assertEquals(HDF5Utils.getNameFromPath(rootPath), ""); }

sample: 515
buggy_code: <START> @Override public <END> GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() { JsonRpcRequest request = new RequestBuilder("GlusterHost.logicalVolumeList").build(); Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey(); return new GlusterLocalLogicalVolumeListReturn(response); }
code_review: Coding conventions: Let's have the @Override on its own line please
target code: public GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList ( ) { JsonRpcRequest request = new RequestBuilder ( "GlusterHost . logicalVolumeList" ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) . withIgnoreResponseKey ( ) ; return new GlusterLocalLogicalVolumeListReturn ( response ) ; }
response: <START> @Override public <END> GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() { JsonRpcRequest request = new RequestBuilder("GlusterHost.logicalVolumeList").build(); Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey(); return new GlusterLocalLogicalVolumeListReturn(response); }

sample: 516
buggy_code: <START> public String toString() { <END> return "TypedByteArray[length=" + length() + "]"; }
code_review: needs `@Override`
target code: @Override public String toString ( ) { return "TypedByteArray [ length = " + length ( ) + " ] " ; }
response: <START> @Override public String toString() { <END> return "TypedByteArray[length=" + length() + "]"; }

sample: 517
buggy_code: public void onEntityDestroyed(EntityRef entity) { <START> if (!entity.isPersistent()) { <END> return; // ignore } entityDeltas.remove(entity.getId()); destroyedEntities.add(entity.getId()); }
code_review: Not an issue, but could be rewritten as ``` java if (entity.isPersistent()) { // do stuff } ``` to avoid multiple points of return from the method (and save a line of code).
target code: public void onEntityDestroyed ( EntityRef entity ) { if ( entity . isPersistent ( ) ) { entityDeltas . remove ( entity . getId ( ) ) ; destroyedEntities . add ( entity . getId ( ) ) ; } }
response: public void onEntityDestroyed(EntityRef entity) { <START> if (entity.isPersistent()) { <END> entityDeltas.remove(entity.getId()); destroyedEntities.add(entity.getId()); } }

sample: 518
buggy_code: private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) { Optional<OrganizationalUnit> targetOU = organizationalUnits.stream() .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst(); <START> if ( targetOU.isPresent() ) { <END> return targetOU.get(); } return null; }
code_review: Isn't this use of `Optional` and returning `null` contradictory? Surely checking `isPresent(..)` in `getDefaultOrganizationalUnit(..)` would be better?
target code: private Optional < OrganizationalUnit > getOU ( String ouIdentifier , Collection < OrganizationalUnit > organizationalUnits ) { Optional < OrganizationalUnit > targetOU = organizationalUnits . stream ( ) . filter ( p - > p . getIdentifier ( ) . equalsIgnoreCase ( ouIdentifier ) ) . findFirst ( ) ; return targetOU ; }
response: private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) { Optional<OrganizationalUnit> targetOU = organizationalUnits.stream() .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst(); <START> if ( targetOU.isPresent() ) { <END> return targetOU.get(); } return null; }

sample: 519
buggy_code: public void testPutAsync() throws Exception { // put Future<String> f = c.putAsync("k", "v"); testFuture(f, null); testK("v"); f = c.putAsync("k", "v2"); testFuture(f, "v"); <START> assertEquals("v2", c.get("k")); <END> }
code_review: to keep code consistency, you may use `testK("v2");`
target code: public void testPutAsync ( ) throws Exception { // put Future < String > f = c . putAsync ( "k" , "v" ) ; testFuture ( f , null ) ; testK ( "v" ) ; f = c . putAsync ( "k" , "v2" ) ; testFuture ( f , "v" ) ; testK ( "v2" ) ; }
response: public void testPutAsync() throws Exception { // put Future<String> f = c.putAsync("k", "v"); testFuture(f, null); testK("v"); f = c.putAsync("k", "v2"); testFuture(f, "v"); <START> testK("v2"); <END> }

sample: 520
buggy_code: public boolean isReady(TaskActionClient taskActionClient) throws Exception { <START> return false; <END> }
code_review: should this return true instead ?
target code: public boolean isReady ( TaskActionClient taskActionClient ) throws Exception { return true ; }
response: public boolean isReady(TaskActionClient taskActionClient) throws Exception { <START> return true; <END> }

sample: 521
buggy_code: <START> static Map<String, EntryValue> convertBeanToEntryMap(Object bean) { <END> Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean); return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer()); }
code_review: why not public
target code: public static Map < String , EntryValue > convertBeanToEntryMap ( Object bean ) { Map < String , Object > buildAttributeValueMap = BeanUtilsExtended . buildObjectAttributeMap ( bean ) ; return Maps . transformEntries ( buildAttributeValueMap , new ObjectToEntryValueTransformer ( ) ) ; }
response: <START> public static Map<String, EntryValue> convertBeanToEntryMap(Object bean) { <END> Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean); return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer()); }

sample: 522
buggy_code: public RequestHeader(Struct struct, short headerVersion) { this.data = new RequestHeaderData(struct, headerVersion); <START> this.headerVersion = headerVersion; <END> }
code_review: nit: replace with `this(new RequestHeaderData(struct, headerVersion), headerVersion)`. Consolidates c'tor logic to one place.
target code: public RequestHeader ( Struct struct , short headerVersion ) { this ( new RequestHeaderData ( struct , headerVersion ) , headerVersion ) ; }
response: public RequestHeader(Struct struct, short headerVersion) { this(new RequestHeaderData(struct, headerVersion), headerVersion); }

sample: 523
buggy_code: public void accountSession(String username, String password) throws TmdbInvalidParametersException { <START> if (username == null || password==null) <END> throw new TmdbInvalidParametersException(401,"Username and Password may not be null"); this.username = username; this.password = password; hasAccountSession = true; }
code_review: Please add braces to conditionals (like `if { }`).
target code: public void accountSession ( String username , String password ) throws TmdbInvalidParametersException { if ( username == null || password == null ) { throw new TmdbInvalidParametersException ( 401 , "Username and Password may not be null" ) ; } this . username = username ; this . password = password ; hasAccountSession = true ; }
response: public void accountSession(String username, String password) throws TmdbInvalidParametersException { <START> if (username == null || password==null) { <END> throw new TmdbInvalidParametersException(401,"Username and Password may not be null"); } this.username = username; this.password = password; hasAccountSession = true; }

sample: 524
buggy_code: public void setProjectName(String projectName) { fProjectName = projectName; // If remote directory field is empty if(fLocationText.getText().equals(EMPTY_STRING)) { fRemoteDirSelected = false; } // If remote directory was not selected yet <START> if (fRemoteDirSelected == false) { <END> fLocationText.setText(getDefaultPathDisplayString()); } }
code_review: Use if (!fRemoteDirSelected) {
target code: public void setProjectName ( String projectName ) { fProjectName = projectName ; // If remote directory field is empty if ( fLocationText . getText ( ) . equals ( EMPTY_STRING ) ) { fRemoteDirSelected = false ; } // If remote directory was not selected yet if ( ! fRemoteDirSelected ) { fLocationText . setText ( getDefaultPathDisplayString ( ) ) ; } }
response: public void setProjectName(String projectName) { fProjectName = projectName; // If remote directory field is empty if(fLocationText.getText().equals(EMPTY_STRING)) { fRemoteDirSelected = false; } // If remote directory was not selected yet <START> if (!fRemoteDirSelected) { <END> fLocationText.setText(getDefaultPathDisplayString()); } }

sample: 525
buggy_code: public void testAddChildCycle3() { assertNotNull(fFixture); assertNotNull(f42Fixture); assertNotNull(fHiFixture); ((CalledFunction) f42Fixture).addChild(fHiFixture); <START> assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren()); <END> }
code_review: unreachable. Maybe you should remove.
target code: public void testAddChildCycle3 ( ) { assertNotNull ( fFixture ) ; assertNotNull ( f42Fixture ) ; assertNotNull ( fHiFixture ) ; ( ( CalledFunction ) f42Fixture ) . addChild ( fHiFixture ) ; }
response: public void testAddChildCycle3() { assertNotNull(fFixture); assertNotNull(f42Fixture); assertNotNull(fHiFixture); ((CalledFunction) f42Fixture).addChild(fHiFixture); <START> assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren()); <END> }

sample: 526
buggy_code: private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) { <START> if (fieldName.length() > 2 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) { <END> return fieldName.charAt(0); } else { return Character.toUpperCase(fieldName.charAt(0)); } }
code_review: I think the condition needs top start as `fieldName.length() > 1` instead of `fieldName.length() > 2 `. I think the generated code getters/setters has same rules for fields **aField** and **aF**. Or am I wrong?
target code: private char formatFieldFirstCharacterToFitDroolsCoreStandards ( final String fieldName ) { if ( fieldName . length ( ) > 1 && Character . isLowerCase ( fieldName . charAt ( 0 ) ) && Character . isUpperCase ( fieldName . charAt ( 1 ) ) ) { return fieldName . charAt ( 0 ) ; } else { return Character . toUpperCase ( fieldName . charAt ( 0 ) ) ; } }
response: private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) { <START> if (fieldName.length() > 1 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) { <END> return fieldName.charAt(0); } else { return Character.toUpperCase(fieldName.charAt(0)); } }

sample: 527
buggy_code: public void start() { <START> logger.debug("start()"); <END> for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) { cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType)); } }
code_review: Are these logging statements really needed?
target code: public void start ( ) { logger . trace ( "start ( ) " ) ; for ( final Class < ? > stepDefinitionType : cachedStepsInstances . keySet ( ) ) { cachedStepsInstances . put ( stepDefinitionType , createStepsInstance ( stepDefinitionType ) ) ; } }
response: public void start() { <START> logger.debug("start()"); <END> for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) { cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType)); } }

sample: 528
buggy_code: private WorkingSetDescriptor getSelectedWorkingSet() { IStructuredSelection selection = typesListViewer.getStructuredSelection(); WorkingSetDescriptor descriptor = null; if (!selection.isEmpty()) { descriptor = (WorkingSetDescriptor) <START> selection.getFirstElement(); <END> } return descriptor; }
code_review: I don't have the code now but if the contract od sselection is to return null on getFirstElement() if sselection is empty, the code can be changed to simply return the first element, without the if.
target code: private WorkingSetDescriptor getSelectedWorkingSet ( ) { return ( WorkingSetDescriptor ) typesListViewer . getStructuredSelection ( ) . getFirstElement ( ) ; }
response: private WorkingSetDescriptor getSelectedWorkingSet() { IStructuredSelection selection = typesListViewer.getStructuredSelection(); WorkingSetDescriptor descriptor = null; if (!selection.isEmpty()) { descriptor = (WorkingSetDescriptor) <START> selection.getFirstElement(); <END> } return descriptor; }

sample: 529
buggy_code: public void evaluate() throws Throwable { <START> if (null != previous) { <END> previous.evaluate(); } for (FrameworkMethod before : befores) { before.invokeExplosively(target); } next.evaluate(); }
code_review: Is it reasonable for the caller to pass in a null value for previous into the constructor? If not, then the constructor should throw a `NullPointerException` if it is null.
target code: public void evaluate ( ) throws Throwable { for ( FrameworkMethod before : befores ) { before . invokeExplosively ( target ) ; } next . evaluate ( ) ; }
response: public void evaluate() throws Throwable { <START> if (null != previous) { previous.evaluate(); } <END> for (FrameworkMethod before : befores) { before.invokeExplosively(target); } next.evaluate(); }

sample: 530
buggy_code: public Response add(OpenStackVolumeProvider provider) { validateParameters(provider, "name"); StoragePool storagePool = provider.isSetDataCenter() ? <START> getStoragePool(provider.getDataCenter()) : new StoragePool(); <END> provider.setDataCenter(DataCenterMapper.map(storagePool, null)); return performCreate( VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class) ); }
code_review: It is a bit weird to create here an empty "StoragePool" to indicate that there is no storage pool to use. Can't we just pass "null" to the backend in that case?
target code: public Response add ( OpenStackVolumeProvider provider ) { validateParameters ( provider , "name" ) ; if ( provider . isSetDataCenter ( ) ) { StoragePool storagePool = getStoragePool ( provider . getDataCenter ( ) ) ; provider . setDataCenter ( DataCenterMapper . map ( storagePool , null ) ) ; } return performCreate ( VdcActionType . AddProvider , new ProviderParameters ( map ( provider ) ) , new QueryIdResolver < Guid > ( VdcQueryType . GetProviderById , IdQueryParameters . class ) ) ; }
response: public Response add(OpenStackVolumeProvider provider) { validateParameters(provider, "name"); StoragePool storagePool = provider.isSetDataCenter() ? getStoragePool(provider.getDataCenter()) : null; provider.setDataCenter(DataCenterMapper.map(storagePool, null)); return performCreate( VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class) ); }

sample: 531
buggy_code: <START> protected void doStoreUsers() <END> { try { usersFileManager.store(new UsersDto(new HashSet<>(userMap.values()))); } catch (IOException e) { throw new UndeclaredThrowableException(e); } }
code_review: private
target code: private void doStoreUsers ( ) { try { usersFileManager . store ( new UsersDto ( new HashSet < > ( userMap . values ( ) ) ) ) ; } catch ( IOException e ) { throw new UndeclaredThrowableException ( e ) ; } }
response: <START> private void doStoreUsers() <END> { try { usersFileManager.store(new UsersDto(new HashSet<>(userMap.values()))); } catch (IOException e) { throw new UndeclaredThrowableException(e); } }

sample: 532
buggy_code: <START> public void tearDown() throws IOException, SQLException { <END> try { globalScheduler.shutdown(); } catch (Exception e) { } cleanup(); tearDownOnce(); }
code_review: Why is this needed now?
target code: public void tearDown ( ) { try { globalScheduler . shutdown ( ) ; } catch ( Exception e ) { } cleanup ( ) ; tearDownOnce ( ) ; }
response: <START> public void tearDown() throws IOException, SQLException { <END> try { globalScheduler.shutdown(); } catch (Exception e) { } cleanup(); tearDownOnce(); }

sample: 533
buggy_code: private CloudMachineNamer getCloudMachineNamer(ConfigBag config) { String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS); if (namerClass != null) { try { return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass) .getDeclaredConstructor(ConfigBag.class).newInstance(config); } catch (Exception e) { throw Exceptions.propagate(e); } } else { <START> return new JcloudsMachineNamer(getAllConfigBag()); <END> } }
code_review: This shouldn't call `getAllConfigBag()`. It should use the `config` passed in, otherwise we lose the local values passed in to the obtain() method. Do you agree?
target code: private CloudMachineNamer getCloudMachineNamer ( ConfigBag config ) { String namerClass = config . get ( LocationConfigKeys . CLOUD_MACHINE_NAMER_CLASS ) ; if ( namerClass != null ) { try { return ( CloudMachineNamer ) getManagementContext ( ) . getCatalog ( ) . getRootClassLoader ( ) . loadClass ( namerClass ) . getDeclaredConstructor ( ConfigBag . class ) . newInstance ( config ) ; } catch ( Exception e ) { throw Exceptions . propagate ( e ) ; } } else { return new JcloudsMachineNamer ( config ) ; } }
response: private CloudMachineNamer getCloudMachineNamer(ConfigBag config) { String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS); if (namerClass != null) { try { return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass) .getDeclaredConstructor(ConfigBag.class).newInstance(config); } catch (Exception e) { throw Exceptions.propagate(e); } } else { <START> return new JcloudsMachineNamer(config); <END> } }

sample: 534
buggy_code: <START> public IllustratedSelectItem(Object value, String label, String image) { <END> super(value, label); this.image = image; }
code_review: Missing JavaDoc.
target code: IllustratedSelectItem ( Object value , String label , String image ) { super ( value , label ) ; this . image = image ; }
response: public IllustratedSelectItem(Object value, String label, String image) { super(value, label); this.image = image; }

sample: 535
buggy_code: private boolean layerGroupContainmentCheckRequired() { // first, is it WMS? Request request = Dispatcher.REQUEST.get(); if(request == null) { return false; } // layer groups are used only in WMS final String service = request.getService(); boolean isMapService = "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); if(!isMapService) { return false; } <START> return true; <END> }
code_review: The last six lines can be squashed into: return "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service);
target code: private boolean layerGroupContainmentCheckRequired ( ) { // first , is it WMS ? Request request = Dispatcher . REQUEST . get ( ) ; if ( request == null ) { return false ; } // layer groups are used only in WMS final String service = request . getService ( ) ; return "WMS" . equalsIgnoreCase ( service ) || "gwc" . equalsIgnoreCase ( service ) ; }
response: private boolean layerGroupContainmentCheckRequired() { // first, is it WMS? Request request = Dispatcher.REQUEST.get(); if(request == null) { return false; } // layer groups are used only in WMS final String service = request.getService(); <START> return "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); <END> }

sample: 536
buggy_code: public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) { <START> initialize(absoluteUri, contextPath, InitData.canBeCached(absoluteUri) ? initData : null); <END> }
code_review: I would do this instead: ``initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null);`` IOW, no point in spending time on checking if the cache can be used if there's no ``initData`` provided.
target code: public ResteasyUriInfo ( final String absoluteUri , final String contextPath , final InitData initData ) { initialize ( absoluteUri , contextPath , initData != null && InitData . canBeCached ( absoluteUri ) ? initData : null ) ; }
response: public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) { <START> initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null); <END> }

sample: 537
buggy_code: private void buildUnaryExpression(UnaryExpressionTree tree) { <START> if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) { <END> build(tree.expression()); currentBlock.elements.add(tree); } else { currentBlock.elements.add(tree); build(tree.expression()); } }
code_review: @benzonico The fact that postfix operators return value before modification shouldn't change order in CFG, because loading of value should anyway happen before operation, i.e. order should be the same.
target code: private void buildUnaryExpression ( UnaryExpressionTree tree ) { currentBlock . elements . add ( tree ) ; build ( tree . expression ( ) ) ; }
response: private void buildUnaryExpression(UnaryExpressionTree tree) { <START> if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) { <END> build(tree.expression()); currentBlock.elements.add(tree); } else { currentBlock.elements.add(tree); } }

sample: 538
buggy_code: <START> public Class getRealClass() { <END> return testNGMethod.getRealClass(); }
code_review: Class<?>
target code: public Class < ? > getRealClass ( ) { return testNGMethod . getRealClass ( ) ; }
response: <START> public Class<?> getRealClass() { <END> return testNGMethod.getRealClass(); }

sample: 539
buggy_code: private KeyStore getSecretsStore() { final File secretStoreFile = createStoreIfNeeded(); try { final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE); <START> try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) { <END> keyStore.load(inputStream, loadStorePassword()); } return keyStore; } catch (Exception e) { Logger.warn(this.getClass(), "unable to load secrets store " + SECRETS_STORE_FILE + ": " + e); throw new DotRuntimeException(e); } }
code_review: Good it is the way
target code: private KeyStore getSecretsStore ( ) { final File secretStoreFile = createStoreIfNeeded ( ) ; try { final KeyStore keyStore = KeyStore . getInstance ( SECRETS_STORE_KEYSTORE_TYPE ) ; try ( InputStream inputStream = Files . newInputStream ( secretStoreFile . toPath ( ) ) ) { keyStore . load ( inputStream , loadStorePassword ( ) ) ; } return keyStore ; } catch ( Exception e ) { Logger . error ( this . getClass ( ) , "unable to load secrets store " + SECRETS_STORE_FILE + " : " + e ) ; throw new DotRuntimeException ( e ) ; } }
response: private KeyStore getSecretsStore() { final File secretStoreFile = createStoreIfNeeded(); try { final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE); <START> try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) { keyStore.load(inputStream, loadStorePassword()); } <END> return keyStore; } catch (Exception e) { Logger.warn(this.getClass(), "unable to load secrets store " + SECRETS_STORE_FILE + ": " + e); throw new DotRuntimeException(e); } }

sample: 540
buggy_code: public AnonymousSpec anonymous(){ if (this.anonymous == null) { this.anonymous = new AnonymousSpec(); } <START> return this.anonymous.authorities("ROLE_USER"); <END> }
code_review: This should be ROLE_ANONYMOUS. However given the defaults in AnonymousSpec you should just delete it
target code: public AnonymousSpec anonymous ( ) { if ( this . anonymous == null ) { this . anonymous = new AnonymousSpec ( ) ; } return this . anonymous ; }
response: public AnonymousSpec anonymous(){ if (this.anonymous == null) { this.anonymous = new AnonymousSpec(); } <START> return this.anonymous; <END> }

sample: 541
buggy_code: public int getNumWaiters() { <START> return this.connectionPool.getNumActive(); <END> }
code_review: ```suggestion return this.connectionPool.getNumWaiters(); ```
target code: public int getNumWaiters ( ) { return this . connectionPool . getNumWaiters ( ) ; }
response: public int getNumWaiters() { <START> return this.connectionPool.getNumWaiters(); <END> }

sample: 542
buggy_code: private void store() throws IOException { byte[] serialized = state.toCbor().serialize(); System.out.println("Writing "+ serialized.length +" bytes to "+ statePath); Files.write( statePath, serialized, <START> StandardOpenOption.CREATE); <END> }
code_review: can we do this atomically?
target code: private synchronized void store ( ) throws IOException { byte [ ] serialized = state . toCbor ( ) . serialize ( ) ; System . out . println ( "Writing " + serialized . length + " bytes to " + statePath ) ; Files . write ( statePath , serialized , StandardOpenOption . CREATE ) ; }
response: private void store() throws IOException { byte[] serialized = state.toCbor().serialize(); System.out.println("Writing "+ serialized.length +" bytes to "+ statePath); Files.write( statePath, serialized, <START> StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING); <END> }

sample: 543
buggy_code: private static void initFacets(@CheckForNull Fingerprint fingerprint){ if (fingerprint==null) return; <START> for (FingerprintFacet facet : fingerprint.facets) <END> facet._setOwner(fingerprint); }
code_review: Please add curlies here
target code: private static void initFacets ( @CheckForNull Fingerprint fingerprint ) { if ( fingerprint == null ) { return ; } for ( FingerprintFacet facet : fingerprint . facets ) { facet . _setOwner ( fingerprint ) ; } }
response: private static void initFacets(@CheckForNull Fingerprint fingerprint){ if (fingerprint==null) return; <START> for (FingerprintFacet facet : fingerprint.facets) { <END> facet._setOwner(fingerprint); } }

sample: 544
buggy_code: public Map<FactoryContainer, Attributes> getEnabledContainers() { Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(); synchronized(_path) { for <START> (Entry<FactoryContainer, <END> Attributes> entry : getReversed(_path.entrySet())) { Attributes attr = entry.getValue(); if (attr.isEnabled()) { Attributes attrClone = new Attributes(attr); map.put(entry.getKey(), attrClone); } } } return map; }
code_review: For clarity it's preferable: Map.Entry
target code: public Map < FactoryContainer , Attributes > getEnabledContainers ( ) { Map < FactoryContainer , Attributes > map = new LinkedHashMap < > ( ) ; synchronized ( _path ) { for ( Map . Entry < FactoryContainer , Attributes > entry : getReversed ( _path . entrySet ( ) ) ) { Attributes attr = entry . getValue ( ) ; if ( attr . isEnabled ( ) ) { Attributes attrClone = new Attributes ( attr ) ; map . put ( entry . getKey ( ) , attrClone ) ; } } } return map ; }
response: public Map<FactoryContainer, Attributes> getEnabledContainers() { Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(); synchronized(_path) { for <START> (Map.Entry<FactoryContainer, <END> Attributes> entry : getReversed(_path.entrySet())) { Attributes attr = entry.getValue(); if (attr.isEnabled()) { Attributes attrClone = new Attributes(attr); map.put(entry.getKey(), attrClone); } } } return map; }

sample: 545
buggy_code: private FileListCacheValue getFileList() { <START> readLock.lock(); <END> try { FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey); if (fileList == null) { fileList = new FileListCacheValue(); FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList); if (prev != null) { fileList = prev; } } if (trace) log.trace("Refreshed file listing view"); return fileList; } finally { readLock.unlock(); } }
code_review: I'm concerned about this lock.. it doesn't seem necessary as each operation invoking this private method is guarded already, and whenever a thread needs to acquire two locks I have an alarm bell ringing in my head.
target code: private FileListCacheValue getFileList ( ) { FileListCacheValue fileList = ( FileListCacheValue ) cache . get ( fileListCacheKey ) ; if ( fileList == null ) { fileList = new FileListCacheValue ( ) ; FileListCacheValue prev = ( FileListCacheValue ) cache . putIfAbsent ( fileListCacheKey , fileList ) ; if ( prev != null ) { fileList = prev ; } } if ( trace ) log . trace ( "Refreshed file listing view" ) ; return fileList ; }
response: private FileListCacheValue getFileList() { <START> FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey); if (fileList == null) { fileList = new FileListCacheValue(); FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList); if (prev != null) { fileList = prev; } } if (trace) log.trace("Refreshed file listing view"); return fileList; <END> }

sample: 546
buggy_code: public long size() { build(); <START> return body.length() + partBoundary.length + partHeader.length; <END> }
code_review: What happens when one of these `TypedOutput` instances return `-1` because they don't know their length?
target code: public long size ( ) { build ( ) ; if ( body . length ( ) > - 1 ) { return body . length ( ) + partBoundary . length + partHeader . length ; } else { return - 1 ; } }
response: public long size() { build(); <START> return body.length() + partBoundary.length + partHeader.length; <END> }

sample: 547
buggy_code: public boolean canStreamToNextPipe() { <START> return super.canStreamToNextPipe() && !isCollectResults(); // when collectResults is false, streaming is not necessary or useful <END> }
code_review: Performance gezien is het natuurlijk handiger eerst een boolean check te hebben en dan extra logica..
target code: public boolean canStreamToNextPipe ( ) { return ! isCollectResults ( ) && super . canStreamToNextPipe ( ) ; // when collectResults is false , streaming is not necessary or useful }
response: public boolean canStreamToNextPipe() { <START> return !isCollectResults() && super.canStreamToNextPipe(); // when collectResults is false, streaming is not necessary or useful <END> }

sample: 548
buggy_code: public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) { String idRefString = idRef.name(); FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString); if (foundViewHolder == null) { foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass); <START> foundHolders.put(idRefString, foundViewHolder); <END> } return foundViewHolder; }
code_review: Where do you handle this now?
target code: public FoundViewHolder getFoundViewHolder ( JFieldRef idRef , AbstractJClass viewClass ) { return getFoundViewHolder ( idRef , viewClass , null ) ; }
response: public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) { String idRefString = idRef.name(); FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString); if (foundViewHolder == null) { foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass); <START> foundHolders.put(idRefString, foundViewHolder); <END> } return foundViewHolder; }

sample: 549
buggy_code: public void tearDown() { try { queryRunner.close(); } <START> finally { <END> queryRunner = null; } }
code_review: `finally` is not really needed. If `close` throws the test will fail anyway and we won't care whether `queryRunner` is `null` or not.
target code: public void tearDown ( ) { queryRunner . close ( ) ; }
response: public void tearDown() { try { queryRunner.close(); } <START> finally { queryRunner = null; } }

sample: 550
buggy_code: private CommitConfig(Config rc) { commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION, null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE); String i18nCommitEncoding = rc.getString( ConfigConstants.CONFIG_SECTION_I18N, null, ConfigConstants.CONFIG_KEY_COMMIT_ENCODING); if (i18nCommitEncoding != null) { <START> commitMessageEncoding = Charset.forName(i18nCommitEncoding); <END> } }
code_review: What if this throws an exception? Should probably be mapped to a ConfigInvalidException, and the caller should report the error.
target code: private CommitConfig ( Config rc ) { commitTemplatePath = rc . getString ( ConfigConstants . CONFIG_COMMIT_SECTION , null , ConfigConstants . CONFIG_KEY_COMMIT_TEMPLATE ) ; i18nCommitEncoding = rc . getString ( ConfigConstants . CONFIG_SECTION_I18N , null , ConfigConstants . CONFIG_KEY_COMMIT_ENCODING ) ; }
response: private CommitConfig(Config rc) { commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION, null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE); String i18nCommitEncoding = rc.getString( ConfigConstants.CONFIG_SECTION_I18N, null, ConfigConstants.CONFIG_KEY_COMMIT_ENCODING); if (i18nCommitEncoding != null) { <START> commitMessageEncoding = Charset.forName(i18nCommitEncoding); <END> } }

sample: 551
buggy_code: public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) throws MalformedInputException { <START> try { <END> Inflater inflater = new Inflater(true); inflater.setInput(input, inputOffset, inputLength); int resultLength = inflater.inflate(output, outputOffset, maxOutputLength); inflater.end(); return resultLength; } catch (DataFormatException e) { throw Throwables.propagate(e); } }
code_review: What's broken (add some details in the commit message)? This is not very obvious.
target code: public int decompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset , int maxOutputLength ) throws MalformedInputException { try { Inflater inflater = new Inflater ( true ) ; inflater . setInput ( input , inputOffset , inputLength ) ; int resultLength = inflater . inflate ( output , outputOffset , maxOutputLength ) ; inflater . end ( ) ; return resultLength ; } catch ( DataFormatException e ) { throw new RuntimeException ( e ) ; } }
response: public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) throws MalformedInputException { <START> try { <END> Inflater inflater = new Inflater(true); inflater.setInput(input, inputOffset, inputLength); int resultLength = inflater.inflate(output, outputOffset, maxOutputLength); inflater.end(); return resultLength; } catch (DataFormatException e) { throw Throwables.propagate(e); } }

sample: 552
buggy_code: <START> public List<OutputLine> getLog() { <END> return this.log; }
code_review: we should return an ImmutableList if we don't intend for users of this method to edit the list.
target code: public List < OutputLine > getLog ( ) { return new ArrayList < > ( this . log ) ; }
response: <START> public ImmutableList<OutputLine> getLog() { <END> return this.log; }

sample: 553
buggy_code: protected void doInit() { super.doInit(); if (!this.evaluationContextSet) { this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory()); } <START> Assert.state(this.closeStreamAfterSend ? this.isSingleUse : true, <END> "Single use connection needed with closeStreamAfterSend"); }
code_review: `!this.closeStreamAfterSend || this.isSingleUse` ?
target code: protected void doInit ( ) { super . doInit ( ) ; if ( ! this . evaluationContextSet ) { this . evaluationContext = ExpressionUtils . createStandardEvaluationContext ( getBeanFactory ( ) ) ; } Assert . state ( ! this . closeStreamAfterSend || this . isSingleUse , "Single use connection needed with closeStreamAfterSend" ) ; }
response: protected void doInit() { super.doInit(); if (!this.evaluationContextSet) { this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory()); } <START> Assert.state(!this.closeStreamAfterSend || this.isSingleUse, <END> "Single use connection needed with closeStreamAfterSend"); }

sample: 554
buggy_code: public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) { super(xStream); this.extensionRegisters = new ArrayList<DMNExtensionRegister>(); if(extensionRegisters != null && extensionRegisters.size() > 0) <START> this.extensionRegisters.addAll(extensionRegisters); <END> }
code_review: I'm reworking this code in the context of the class, also to avoid potential NPE if the extensionRegisters field might have not been initialized, from the no-args constructor.
target code: public ExtensionElementsConverter ( XStream xStream , List < DMNExtensionRegister > extensionRegisters ) { super ( xStream ) ; if ( ! extensionRegisters . isEmpty ( ) ) { this . extensionRegisters . addAll ( extensionRegisters ) ; } }
response: public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) { super(xStream); if(extensionRegisters != null && extensionRegisters.size() > 0) <START> this.extensionRegisters.addAll(extensionRegisters); <END> }

sample: 555
buggy_code: public void executeBatch(OperationsQueue operationsQueue) { <START> log.tracef( "Executing batch" ); <END> try { if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class ) || GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) { super.executeBatch( operationsQueue ); } } catch ( TupleAlreadyExistsException taee ) { // TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this // information via the original exception; It'd require a fair bit of changes to obtain the entity name here // (we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here) throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee ); } }
code_review: Maybe we should move that inside the `if` body, since we won't always execute the batch... ?
target code: public void executeBatch ( OperationsQueue operationsQueue ) { try { if ( GridDialects . hasFacet ( getGridDialect ( ) , BatchableGridDialect . class ) || GridDialects . hasFacet ( getGridDialect ( ) , GroupingByEntityDialect . class ) ) { log . tracef ( "Executing batch" ) ; super . executeBatch ( operationsQueue ) ; } } catch ( TupleAlreadyExistsException taee ) { // TODO : Ideally , we should log the entity name + id here ; For now we trust the datastore to provide this // information via the original exception ; It'd require a fair bit of changes to obtain the entity name here // ( we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here ) throw log . mustNotInsertSameEntityTwice ( taee . getMessage ( ) , taee ) ; } }
response: public void executeBatch(OperationsQueue operationsQueue) { try { if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class ) || GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) { <START> log.tracef( "Executing batch" ); <END> super.executeBatch( operationsQueue ); } } catch ( TupleAlreadyExistsException taee ) { // TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this // information via the original exception; It'd require a fair bit of changes to obtain the entity name here // (we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here) throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee ); } }

sample: 556
buggy_code: public int hashCode() { <START> return (((startCommit.hashCode() * 31) + numbers.length) * 31) <END> + getNumber(); }
code_review: nit-pick: startCommit.hashCode can just be xored/added in since it is well distributed
target code: public int hashCode ( ) { return ( ( startCommit . hashCode ( ) + numbers . length ) * 31 ) + getNumber ( ) ; }
response: public int hashCode() { <START> return (((startCommit.hashCode() ^ numbers.length) * 31) <END> + getNumber(); }

sample: 557
buggy_code: <START> private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException { <END> AuthenticationSettings.INSTANCE.setUseBroker(true); }
code_review: can this function now throw NoSuchAlgorithmException
target code: private void prepareAuthForBrokerCall ( ) { AuthenticationSettings . INSTANCE . setUseBroker ( true ) ; }
response: <START> private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException { <END> AuthenticationSettings.INSTANCE.setUseBroker(true); }

sample: 558
buggy_code: public boolean isWrapperFor(Class<?> iface) { if (gridCoverage instanceof Wrapper) return ((Wrapper) gridCoverage).isWrapperFor(iface); <START> else if (iface.isInstance(gridCoverage)) return true; <END> else return false; }
code_review: I woudl remove this else, if the gridCoverage is a wrapper and says "false" but iface is "GridCoverage2D" you want to fall back on the isInstance check anyways.
target code: public boolean isWrapperFor ( Class < ? > iface ) { if ( gridCoverage instanceof Wrapper ) { return ( ( Wrapper ) gridCoverage ) . isWrapperFor ( iface ) ; } return iface . isInstance ( gridCoverage ) ; }
response: public boolean isWrapperFor(Class<?> iface) { if (gridCoverage instanceof Wrapper) return ((Wrapper) gridCoverage).isWrapperFor(iface); <START> if (iface.isInstance(gridCoverage)) return true; <END> else return false; }

sample: 559
buggy_code: DataSegment uploadDataSegment( DataSegment segment, final int binaryVersion, final long size, final File compressedSegmentData, final String azurePath ) throws StorageException, IOException, URISyntaxException { azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath); final DataSegment outSegment = segment .withSize(size) .withLoadSpec(this.makeLoadSpec(new URI(azurePath))) .withBinaryVersion(binaryVersion); <START> log.info("Deleting file [%s]", compressedSegmentData); <END> compressedSegmentData.delete(); return outSegment; }
code_review: Would you change the log level to debug? it doesn't look worth to be the info level.
target code: DataSegment uploadDataSegment ( DataSegment segment , final int binaryVersion , final long size , final File compressedSegmentData , final String azurePath ) throws StorageException , IOException , URISyntaxException { azureStorage . uploadBlob ( compressedSegmentData , config . getContainer ( ) , azurePath ) ; final DataSegment outSegment = segment . withSize ( size ) . withLoadSpec ( this . makeLoadSpec ( new URI ( azurePath ) ) ) . withBinaryVersion ( binaryVersion ) ; log . debug ( "Deleting file [ % s ] " , compressedSegmentData ) ; compressedSegmentData . delete ( ) ; return outSegment ; }
response: DataSegment uploadDataSegment( DataSegment segment, final int binaryVersion, final long size, final File compressedSegmentData, final String azurePath ) throws StorageException, IOException, URISyntaxException { azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath); final DataSegment outSegment = segment .withSize(size) .withLoadSpec(this.makeLoadSpec(new URI(azurePath))) .withBinaryVersion(binaryVersion); <START> log.debug("Deleting file [%s]", compressedSegmentData); <END> compressedSegmentData.delete(); return outSegment; }

sample: 560
buggy_code: public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter, TransactionalEditingDomain editingDomain) { <START> super(description, variableManager, <END> interpreter, editingDomain); this.description = description; }
code_review: not done
target code: public EEFButtonLifecycleManager ( EEFButtonDescription description , IVariableManager variableManager , IInterpreter interpreter , TransactionalEditingDomain editingDomain ) { super ( variableManager , interpreter , editingDomain ) ; this . description = description ; }
response: public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter, TransactionalEditingDomain editingDomain) { <START> super(description, variableManager, interpreter, editingDomain); <END> this.description = description; }

sample: 561
buggy_code: private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) { return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) && <START> (!formatString.contains("{}") && formatString.contains("%")); <END> }
code_review: useless parenthesis
target code: private static boolean isProbablyLog4jFormatterLogger ( MethodInvocationTree mit , String formatString ) { return mit . symbol ( ) . owner ( ) . type ( ) . is ( ORG_APACHE_LOGGING_LOG4J_LOGGER ) && ! formatString . contains ( " { } " ) && formatString . contains ( " % " ) ; }
response: private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) { return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) && <START> !formatString.contains("{}") && formatString.contains("%"); <END> }

sample: 562
buggy_code: void setMarker(TextMarker marker, int length) { this.marker = marker; numSkipLines = length; if (checkAndUpdateArrows()) { upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND)); } <START> skipNum.setText(PatchUtil.C.patchSkipRegion(Integer <END> .toString(length))); }
code_review: PatchUtil.M
target code: void setMarker ( TextMarker marker , int length ) { this . marker = marker ; numSkipLines = length ; if ( checkAndUpdateArrows ( ) ) { upArrow . setHTML ( PatchUtil . M . expandBefore ( NUM_ROWS_TO_EXPAND ) ) ; downArrow . setHTML ( PatchUtil . M . expandAfter ( NUM_ROWS_TO_EXPAND ) ) ; } skipNum . setText ( PatchUtil . M . patchSkipRegion ( Integer . toString ( length ) ) ) ; }
response: void setMarker(TextMarker marker, int length) { this.marker = marker; numSkipLines = length; if (checkAndUpdateArrows()) { upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND)); } <START> skipNum.setText(PatchUtil.M.patchSkipRegion(Integer <END> .toString(length))); }

sample: 563
buggy_code: public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) { this.publisher = publisher; this.run = build; this.workspace = build.getWorkspace(); this.launcher = launcher; <START> this.listener = listener; <END> }
code_review: Wouldn't be better to directly call the new constructor? Just for easier maintenance in the future.
target code: public ExtendedEmailPublisherContext ( ExtendedEmailPublisher publisher , AbstractBuild < ? , ? > build , Launcher launcher , BuildListener listener ) { this ( publisher , build , build . getWorkspace ( ) , launcher , listener ) ; }
response: public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) { this.publisher = publisher; this.run = build; this.workspace = build.getWorkspace(); this.launcher = launcher; <START> this.listener = listener; <END> }

sample: 564
buggy_code: public void testWrongFormatNumber() throws Exception { NumberCellEditor editor; editor = new NumberCellEditor(shell, Integer.class); //empty string editor.setValue(" "); editor.getValue(); assertNull(editor.getValue() ); //not parsable number editor.setValue("aa"); <START> editor.getValue(); <END> assertNull(editor.getValue() ); }
code_review: this might be obsolete if `isValueValid`is implemented...
target code: public void testWrongFormatNumber ( ) throws Exception { NumberCellEditor editor ; editor = new NumberCellEditor ( shell , Integer . class ) ; // empty string editor . getValue ( ) ; assertNull ( editor . getValue ( ) ) ; // not parsable number editor . setValue ( "aa" ) ; editor . getValue ( ) ; assertNull ( editor . getValue ( ) ) ; }
response: public void testWrongFormatNumber() throws Exception { NumberCellEditor editor; editor = new NumberCellEditor(shell, Integer.class); //empty string editor.setValue(" "); editor.getValue(); assertNull(editor.getValue() ); //not parsable number editor.setValue("aa"); <START> editor.getValue(); <END> assertNull(editor.getValue() ); }

sample: 565
buggy_code: public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) { if (hasAvatarProvider(newPlugin)) { avatarSupport = true; <START> } else { if (avatarSupport <END> && hasAvatarProvider(oldPlugin)) { avatarSupport = false; } } }
code_review: else if on one line.
target code: public void onReloadPlugin ( Plugin oldPlugin , Plugin newPlugin ) { update ( ) ; }
response: public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) { if (hasAvatarProvider(newPlugin)) { avatarSupport = true; <START> } else if (avatarSupport <END> && hasAvatarProvider(oldPlugin)) { avatarSupport = false; } } }

sample: 566
buggy_code: <START> public Class getRealClass() { <END> return clazz; }
code_review: `Class<?>`
target code: public Class < ? > getRealClass ( ) { return clazz ; }
response: <START> public Class<?> getRealClass() { <END> return clazz; }

sample: 567
buggy_code: private String read(String resourcePath) throws IOException { InputStream is = getClass().getResourceAsStream(resourcePath); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }
code_review: I suppose close() is already done in Util.read(..)
target code: private String read ( String resourcePath ) throws IOException { InputStream is = getClass ( ) . getResourceAsStream ( resourcePath ) ; return Util . read ( is ) ; }
response: private String read(String resourcePath) throws IOException { InputStream is = getClass().getResourceAsStream(resourcePath); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }

sample: 568
buggy_code: public static String getModelFileWithGAV(ReleaseId releaseId) { <START> ReleaseIdImpl releaseIdImpl = (ReleaseIdImpl) releaseId; <END> return Paths.get(MODEL_FILE_DIRECTORY, releaseIdImpl.getGroupId(), releaseIdImpl.getArtifactId(), releaseIdImpl.getVersion(), MODEL_FILE_NAME).toString(); }
code_review: I don't see why I need this cast. The group and artifact IDs are accessible even at interface level. Also the version is accessible, but I don't think you should add it here: this is for multimodule project compilaton and afaik you cannot have different modules with same GA and different version in the same project.
target code: public static String getModelFileWithGAV ( ReleaseId releaseId ) { return Paths . get ( MODEL_FILE_DIRECTORY , releaseId . getGroupId ( ) , releaseId . getArtifactId ( ) , MODEL_FILE_NAME ) . toString ( ) ; }
response: public static String getModelFileWithGAV(ReleaseId releaseId) { <START> return Paths.get(MODEL_FILE_DIRECTORY, releaseId.getGroupId(), releaseId.getArtifactId(), MODEL_FILE_NAME).toString(); <END> }

sample: 569
buggy_code: void removeConnection(String connectionId) { <START> if (availableConnections.remove(connectionId)) { <END> availableCount--; } poolCount--; }
code_review: This operation can be O(n), though the size of the list may be small. Making sense to use a set instead?
target code: void removeConnection ( String connectionId ) { availableConnections . remove ( connectionId ) ; poolCount -- ; }
response: void removeConnection(String connectionId) { <START> if (availableConnections.remove(connectionId)) { <END> availableCount--; } poolCount--; }

sample: 570
buggy_code: private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); if <START> (!desiredColumns.isEmpty()) <END> { for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; }
code_review: return before instantiating the map?
target code: private Map < Long , ISegmentAspect > getAspectsFromColumnsId ( List < Long > desiredColumns ) { if ( ! desiredColumns . isEmpty ( ) ) { Map < Long , ISegmentAspect > aspects = new LinkedHashMap < > ( ) ; for ( Long columnsId : desiredColumns ) { ISegmentAspect segmentAspect = fAspectMap . get ( columnsId ) ; if ( segmentAspect != null ) { aspects . put ( columnsId , segmentAspect ) ; } } return aspects ; } return fAspectMap ; }
response: private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { if <START> (!desiredColumns.isEmpty()) <END> { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; }

sample: 571
buggy_code: static boolean isValidMining(ICodeMining mining) { <START> return Objects.nonNull(mining) && mining.getLabel() != null && !mining.getLabel().isEmpty(); <END> }
code_review: Why Objects.nonNull instead of != null?
target code: static boolean isValidMining ( ICodeMining mining ) { return mining != null && mining . getLabel ( ) != null && ! mining . getLabel ( ) . isEmpty ( ) ; }
response: static boolean isValidMining(ICodeMining mining) { <START> return mining != null && mining.getLabel() != null && !mining.getLabel().isEmpty(); <END> }

sample: 572
buggy_code: public void addInput(Page page) { verify(probe == null); probe = page; probePosition = 0; joinAddresses = null; <START> joinAddressIndex = 0; <END> }
code_review: `-1` would be more correct. AFAIC you can skip this.
target code: public void addInput ( Page page ) { verify ( probe == null ) ; probe = page ; probePosition = 0 ; joinAddresses = null ; }
response: public void addInput(Page page) { verify(probe == null); probe = page; probePosition = 0; joinAddresses = null; <START> joinAddressIndex = -1; <END> }

sample: 573
buggy_code: public DescriptorImpl() { super(ThrottleJobProperty.class); synchronized(propertiesByCategoryLock) { load(); // Explictly drop queue items loaded from 1.8.1 version if (!propertiesByCategory.isEmpty()) { propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>(); save(); // Save the configuration to remove obsolete data } <START> } <END> }
code_review: Simpler to just rename the field. Then XStream will discard the old data automatically.
target code: public DescriptorImpl ( ) { super ( ThrottleJobProperty . class ) ; synchronized ( propertiesByCategoryLock ) { load ( ) ; // Explictly handle the persisted data from the version 1 . 8 . 1 if ( propertiesByCategory == null ) { propertiesByCategory = new HashMap < String , Map < ThrottleJobProperty , Void > > ( ) ; } if ( ! propertiesByCategory . isEmpty ( ) ) { propertiesByCategory . clear ( ) ; save ( ) ; // Save the configuration to remove obsolete data } } }
response: public DescriptorImpl() { super(ThrottleJobProperty.class); synchronized(propertiesByCategoryLock) { load(); // Explictly drop queue items loaded from 1.8.1 version if (!propertiesByCategory.isEmpty()) { propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>(); save(); // Save the configuration to remove obsolete data } <START> } <END> }

sample: 574
buggy_code: public String toString() { // Since the static data arrives from external source it's not guarenteed not to be null so a null check is // mandatory in order to avoid NPE when invoking toString by the logger String domainName = staticData.getName() == null ? "null" : staticData.getName(); <START> String domainId = staticData.getId() == null ? "null" : staticData.getId().toString(); <END> return "StorageDomain[" + domainName + ", " + domainId + "]"; }
code_review: you don't need this. the "+" operator does this for you.
target code: public String toString ( ) { // Since the static data arrives from external source it's not guarenteed not to be null so a null check is // mandatory in order to avoid NPE when invoking toString by the logger String domainName = staticData == null ? "null" : staticData . getName ( ) ; Guid domainId = staticData == null ? null : staticData . getId ( ) ; return "StorageDomain [ " + domainName + " , " + domainId + " ] " ; }
response: public String toString() { // Since the static data arrives from external source it's not guarenteed not to be null so a null check is // mandatory in order to avoid NPE when invoking toString by the logger String domainName = staticData.getName() == null ? "null" : staticData.getName(); <START> String domainId = staticData.getId() == null ? "null" : staticData.getId().toString(); <END> return "StorageDomain[" + domainName + ", " + domainId + "]"; }

sample: 575
buggy_code: Predicate<Entry<Key,Value>> getScanPredicate() { final Range range = getRange(); <START> return input -> { if (range != null && !range.contains(input.getKey())) return false; return true; }; <END> }
code_review: Can this be simplified to: ```java return input -> range == null || range.contains(input.getKey()); ```
target code: Predicate < Entry < Key , Value > > getScanPredicate ( ) { final Range range = getRange ( ) ; return input - > range == null || range . contains ( input . getKey ( ) ) ; }
response: Predicate<Entry<Key,Value>> getScanPredicate() { final Range range = getRange(); <START> return input -> range == null || range.contains(input.getKey()); <END> }

sample: 576
buggy_code: public AlluxioHiveMetastore(TableMasterClient client) { <START> requireNonNull(client, "client is null"); <END> this.client = client; }
code_review: nit ```java this.client = requireNonNull(client, "client is null");
target code: public AlluxioHiveMetastore ( TableMasterClient client ) { this . client = requireNonNull ( client , "client is null" ) ; }
response: public AlluxioHiveMetastore(TableMasterClient client) { <START> this.client = requireNonNull(client, "client is null"); <END> }

sample: 577
buggy_code: private void addWorkPackageCriteria() { if (isWorkPackageSpecified()) { ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId); if (isColorTeamMatch(workPackArt)) { <START> if (workPackArt.isValid()) <END> { queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString()); } } } }
code_review: Should this be above "isColorTeamMatch"? For example, on line #755.
target code: private void addWorkPackageCriteria ( ) { if ( isWorkPackageSpecified ( ) ) { ArtifactId workPackArt = atsApi . getQueryService ( ) . getArtifactOrSentinel ( workPackageId ) ; if ( workPackArt . isValid ( ) ) { if ( isColorTeamMatch ( workPackArt ) ) { queryAnd ( AtsAttributeTypes . WorkPackageReference , workPackArt . getIdString ( ) ) ; } } } }
response: private void addWorkPackageCriteria() { if (isWorkPackageSpecified()) { ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId); <START> if (isColorTeamMatch(workPackArt)) <END> { if (workPackArt.isValid()) { queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString()); } } } }

sample: 578
buggy_code: private void sendToSocket(Socket socket, String cmdString) throws IOException { // remove spaces at beginning and end and replace double spaces in // string with single space byte[] sendBytes = ("A" + cmdString.trim().replaceAll("\\s+", " ") + "\n").getBytes(); <START> socket.getInputStream().skip(tcpSocket.getInputStream().available()); <END> socket.getOutputStream().write(sendBytes); socket.getOutputStream().flush(); AstericsErrorHandling.instance.reportInfo(this, "IRTrans sent data: " + cmdString); }
code_review: you directly use the member variable tcpSocket, but shouldnt it be the parameter socket?
target code: private void sendToSocket ( Socket socket , String cmdString ) throws IOException { // remove spaces at beginning and end and replace double spaces in // string with single space byte [ ] sendBytes = ( "A" + cmdString . trim ( ) . replaceAll ( "\\s + " , " " ) + "\n" ) . getBytes ( ) ; socket . getInputStream ( ) . skip ( socket . getInputStream ( ) . available ( ) ) ; socket . getOutputStream ( ) . write ( sendBytes ) ; socket . getOutputStream ( ) . flush ( ) ; AstericsErrorHandling . instance . reportInfo ( this , "IRTrans sent data : " + cmdString ) ; }
response: private void sendToSocket(Socket socket, String cmdString) throws IOException { // remove spaces at beginning and end and replace double spaces in // string with single space byte[] sendBytes = ("A" + cmdString.trim().replaceAll("\\s+", " ") + "\n").getBytes(); <START> socket.getInputStream().skip(socket.getInputStream().available()); <END> socket.getOutputStream().write(sendBytes); socket.getOutputStream().flush(); AstericsErrorHandling.instance.reportInfo(this, "IRTrans sent data: " + cmdString); }

sample: 579
buggy_code: public int hashCode() { <START> return getClass().hashCode(); <END> }
code_review: can you explain why this is necessary?
target code: public int hashCode ( ) { return 1 ; }
response: public int hashCode() { <START> return getClass().hashCode(); <END> }

sample: 580
buggy_code: private void reset() { <START> setId( next = NO_ID ); <END> }
code_review: i do not think we need to save this line better make it more readable
target code: private void reset ( ) { next = NO_ID ; setId ( NO_ID ) ; }
response: private void reset() { <START> setId( NO_ID ); <END> }

sample: 581
buggy_code: public String getActualDowntime() { <START> return (actualDowntime == null) ? "(N/A)" : actualDowntime.toString() + "ms"; <END> }
code_review: so now you can drop the "toString()"
target code: public String getActualDowntime ( ) { return ( actualDowntime == null ) ? " ( N / A ) " : actualDowntime + "ms" ; }
response: public String getActualDowntime() { <START> return (actualDowntime == null) ? "(N/A)" : actualDowntime + "ms"; <END> }

sample: 582
buggy_code: String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params, final String argument) { if (argument.contains("/")) { <START> <END> }else{ return (params.live) ? "/live/" + argument + "." + EXTENSION : "/working/" + argument + "." + EXTENSION; } }
code_review: @wezell , missing return statement... This is breaking when compiling the code
target code: String resolveTemplatePath ( final Context context , final Writer writer , final RenderParams params , final String argument ) { return ( params . live ) ? " / live / " + argument + " . " + EXTENSION : " / working / " + argument + " . " + EXTENSION ; }
response: String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params, final String argument) { if (argument.contains("/")) { <START> return argument; <END> }else{ return (params.live) ? "/live/" + argument + "." + EXTENSION : "/working/" + argument + "." + EXTENSION; } }

sample: 583
buggy_code: public DispoConfig findDispoConfig(DispoProgram program) { <START> ArtifactReadable config = <END> getQuery().fromBranch(program.getUuid()).andNameEquals("Program Config").getResults().getOneOrNull(); if (config == null) { DispoUtil.getDefaultConfig(); } return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config)); }
code_review: andNameEquals is un-needed and probably undesired incase name ever changes
target code: public DispoConfig findDispoConfig ( DispoProgram program ) { ArtifactReadable config = getQuery ( ) . fromBranch ( program . getUuid ( ) ) . andNameEquals ( "Program Config" ) . getResults ( ) . getOneOrNull ( ) ; if ( config == null ) { return DispoUtil . getDefaultConfig ( ) ; } return DispoUtil . configArtToConfigData ( new DispoConfigArtifact ( config ) ) ; }
response: public DispoConfig findDispoConfig(DispoProgram program) { <START> ArtifactReadable config = <END> getQuery().fromBranch(program.getUuid()).getResults().getOneOrNull(); if (config == null) { DispoUtil.getDefaultConfig(); } return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config)); }

sample: 584
buggy_code: public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { // Indexing on signatures optimises this type of request for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { <START> if (operations.get(entry.getKey()).contains(name)) { <END> return true; } } } return false; }
code_review: This is wrong, should be `entry.getValue()`
target code: public boolean hasMatchingOpSig ( String name , JavaOperationSigMask mask ) { // Indexing on signatures optimises this type of request for ( Entry < JavaOperationSignature , Set < String > > entry : operations . entrySet ( ) ) { if ( mask . covers ( entry . getKey ( ) ) ) { if ( entry . getValue ( ) . contains ( name ) ) { return true ; } } } return false ; }
response: public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { // Indexing on signatures optimises this type of request for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { <START> if (entry.getValue().contains(name)) { <END> return true; } } } return false; }

sample: 585
buggy_code: <START> IonSqlQueryBuilder(TypeManager typeManager) <END> { this.typeManager = requireNonNull(typeManager, "typeManager is null"); }
code_review: Make these methods public since they are part of the public API of the class. If we want to restrict access to the class, we would make the class itself package private.
target code: public IonSqlQueryBuilder ( TypeManager typeManager ) { this . typeManager = requireNonNull ( typeManager , "typeManager is null" ) ; }
response: <START> public IonSqlQueryBuilder(TypeManager typeManager) <END> { this.typeManager = requireNonNull(typeManager, "typeManager is null"); }

sample: 586
buggy_code: protected OperationController getOperationController() { <START> return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size())); <END> }
code_review: Should we abstract this. I mean the way we choose the operation controller. What in case in future, we wish to choose the one which is less loaded compared to others?
target code: private OperationController getOperationController ( ) { return ocList . get ( ThreadLocalRandom . current ( ) . nextInt ( ocList . size ( ) ) ) ; }
response: protected OperationController getOperationController() { <START> return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size())); <END> }

sample: 587
buggy_code: public List<JDK> getJDKs() { <START> if(jdks==null) <END> jdks = new ArrayList<JDK>(); return jdks; }
code_review: So I believe the only way this could be null is if a configuration was saved without the <jdks> entry and then reloaded. I don't see how that could happen - but there may be some old version of Jenkins that could have done it. Would probably make sense to modify a `readResolve()` to set it to an empty list and remove this check and the theoretical possibility?
target code: public List < JDK > getJDKs ( ) { return jdks ; }
response: public List<JDK> getJDKs() { <START> if(jdks==null) <END> jdks = new ArrayList<JDK>(); return jdks; }

sample: 588
buggy_code: public boolean addAll(int index, Collection<? extends T> c) { Collection<T> uniqueValuesToAdd = getUniqueValues(c); if (uniqueValuesToAdd.isEmpty()) { return false; } try { return super.addAll(index, uniqueValuesToAdd); } catch (IndexOutOfBoundsException ioobException) { comparingSet.removeAll(uniqueValuesToAdd); <START> throw new IndexOutOfBoundsException(); <END> } }
code_review: same as above: please pass on the original exception so that we retain the stacktrace and message.
target code: public boolean addAll ( int index , Collection < ? extends T > c ) { Collection < T > uniqueValuesToAdd = getUniqueValues ( c ) ; if ( uniqueValuesToAdd . isEmpty ( ) ) { return false ; } try { return super . addAll ( index , uniqueValuesToAdd ) ; } catch ( IndexOutOfBoundsException ioobException ) { comparingSet . removeAll ( uniqueValuesToAdd ) ; throw ioobException ; } }
response: public boolean addAll(int index, Collection<? extends T> c) { Collection<T> uniqueValuesToAdd = getUniqueValues(c); if (uniqueValuesToAdd.isEmpty()) { return false; } try { return super.addAll(index, uniqueValuesToAdd); } catch (IndexOutOfBoundsException ioobException) { comparingSet.removeAll(uniqueValuesToAdd); <START> throw ioobException; <END> } }

sample: 589
buggy_code: public Context getContext() { if (sdkName == null) { sdkName = this.getClass().getPackage().getName(); } return new Context("Sdk-Name", sdkName) <START> .addData("Sdk-Version", SDK_VERSION); <END> }
code_review: why sdk version hardcoded?
target code: public Context getContext ( ) { return new Context ( "Sdk - Name" , sdkName ) . addData ( "Sdk - Version" , SDK_VERSION ) ; }
response: public Context getContext() { if (sdkName == null) { sdkName = this.getClass().getPackage().getName(); } return new Context("Sdk-Name", sdkName) <START> .addData("Sdk-Version", SDK_VERSION); <END> }

sample: 590
buggy_code: <START> public void setSelectedDevices(List<StorageDevice> selectedDevices) { <END> getStorageDevices().setSelectedItems(selectedDevices); }
code_review: Can this be protected. I assume only the ListModel is using it
target code: protected void setSelectedDevices ( List < StorageDevice > selectedDevices ) { getStorageDevices ( ) . setSelectedItems ( selectedDevices ) ; }
response: <START> protected void setSelectedDevices(List<StorageDevice> selectedDevices) { <END> getStorageDevices().setSelectedItems(selectedDevices); }

sample: 591
buggy_code: private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) { Snapshot snapshot = timer.getSnapshot(); JsonObject json = new JsonObject(); // Meter populateMetered(json, timer, rateUnit); // Snapshot double factor = 1.0 / durationUnit.toNanos(1); populateSnapshot(json, snapshot, factor); // Duration rate <START> String duration = durationUnit.toString().toLowerCase(Locale.US); <END> json.putString("durationRate", duration); return json; }
code_review: Why US?
target code: private JsonObject toJson ( Timer timer , TimeUnit rateUnit , TimeUnit durationUnit ) { Snapshot snapshot = timer . getSnapshot ( ) ; JsonObject json = new JsonObject ( ) ; // Meter populateMetered ( json , timer , rateUnit ) ; // Snapshot double factor = 1 . 0 / durationUnit . toNanos ( 1 ) ; populateSnapshot ( json , snapshot , factor ) ; // Duration rate String duration = durationUnit . toString ( ) . toLowerCase ( ) ; json . putString ( "durationRate" , duration ) ; return json ; }
response: private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) { Snapshot snapshot = timer.getSnapshot(); JsonObject json = new JsonObject(); // Meter populateMetered(json, timer, rateUnit); // Snapshot double factor = 1.0 / durationUnit.toNanos(1); populateSnapshot(json, snapshot, factor); // Duration rate <START> String duration = durationUnit.toString().toLowerCase(Locale.ENGLISH); <END> json.putString("durationRate", duration); return json; }

sample: 592
buggy_code: protected void delete(LogEntry delegate, String reason, RequestContext context) throws ResourceDoesNotSupportOperationException { <START> throw new UnsupportedOperationException("delete not supported"); <END> }
code_review: Should be ResourceDoesNotSupportOperationException
target code: protected void delete ( LogEntry delegate , String reason , RequestContext context ) throws ResourceDoesNotSupportOperationException { throw new ResourceDoesNotSupportOperationException ( ) ; }
response: protected void delete(LogEntry delegate, String reason, RequestContext context) throws ResourceDoesNotSupportOperationException { <START> throw new ResourceDoesNotSupportOperationException("delete not supported"); <END> }

sample: 593
buggy_code: <START> protected void setConsumerBatchEnabled(boolean consumerBatchEnabled) { <END> this.consumerBatchEnabled = consumerBatchEnabled; }
code_review: Why is this `protected` ? Are you going to detect this option internally by the `@RabbitListener(Handler)` method signature?
target code: public void setConsumerBatchEnabled ( boolean consumerBatchEnabled ) { this . consumerBatchEnabled = consumerBatchEnabled ; }
response: <START> void setConsumerBatchEnabled(boolean consumerBatchEnabled) { <END> this.consumerBatchEnabled = consumerBatchEnabled; }

sample: 594
buggy_code: public int getLevel() { <START> return data.optInt("toclevel"); <END> }
code_review: old code seems to indicate this should be "level" not "toclevel"? Could be causing failure of getLevel() calls being compared in SectionsFetchTask.processResult?
target code: public int getLevel ( ) { return data . optInt ( "toclevel" , 1 ) ; }
response: public int getLevel() { <START> return data.optInt("level"); <END> }

sample: 595
buggy_code: private void setPagesRecycler(OnThisDayCard card) { if (card.pages() != null) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) <START> this.getContext()); <END> recyclerAdapter.setCallback(new ItemCallback()); pagesRecycler.setAdapter(recyclerAdapter); } else { pagesRecycler.setVisibility(GONE); } }
code_review: use getContext() instead of this.getContext() ?
target code: private void setPagesRecycler ( OnThisDayCard card ) { if ( card . pages ( ) != null ) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter ( card . pages ( ) , card . wiki ( ) , true , ( Activity ) getContext ( ) ) ; recyclerAdapter . setCallback ( new ItemCallback ( ) ) ; pagesRecycler . setAdapter ( recyclerAdapter ) ; } else { pagesRecycler . setVisibility ( GONE ) ; } }
response: private void setPagesRecycler(OnThisDayCard card) { if (card.pages() != null) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) <START> getContext()); <END> recyclerAdapter.setCallback(new ItemCallback()); pagesRecycler.setAdapter(recyclerAdapter); } else { pagesRecycler.setVisibility(GONE); } }

sample: 596
buggy_code: public String getExtendedLabelForVSM(String providedShapeURI) { for (IConfigurationElement configurationElement : extensions) { String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier(); if (identifier != null && identifier.equals(providedShapeURI)) { return <START> configurationElement.getAttribute(LABEL_ATTRIBUTE) + " - " + configurationElement.getNamespaceIdentifier(); //$NON-NLS-1$ <END> } } return "Unknown URI"; //$NON-NLS-1$ }
code_review: Add a getExtendedLabelsForVSM(IConfigurationElement) method to avoid duplication
target code: public String getExtendedLabelForVSM ( String providedShapeURI ) { for ( IConfigurationElement configurationElement : extensions ) { String identifier = ( ( ExtensionHandle ) configurationElement . getParent ( ) ) . getSimpleIdentifier ( ) ; if ( identifier != null && identifier . equals ( providedShapeURI ) ) { return getExtendedLabelForVSM ( configurationElement ) ; } } return "Unknown URI" ; // $NON - NLS - 1$ }
response: public String getExtendedLabelForVSM(String providedShapeURI) { for (IConfigurationElement configurationElement : extensions) { String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier(); if (identifier != null && identifier.equals(providedShapeURI)) { return <START> getExtendedLabelsForVSM(configurationElement); <END> } } return "Unknown URI"; //$NON-NLS-1$ }

sample: 597
buggy_code: public void stopServer() { if (server instanceof GrizzlyServer) { <START> ((GrizzlyServer) server).setCleanIdleConnections(); <END> } server.stop(); }
code_review: I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter.
target code: public void stopServer ( ) { if ( server instanceof GrizzlyServer ) { ( ( GrizzlyServer ) server ) . setCleanIdleConnections ( true ) ; } server . stop ( ) ; }
response: public void stopServer() { if (server instanceof GrizzlyServer) { <START> ((GrizzlyServer) server).setCleanIdleConnections(true); <END> } server.stop(); }

sample: 598
buggy_code: protected Supplier<Operation> createOperationSupplier() { <START> return () -> new DistributedObjectDestroyOperation(parameters.serviceName, parameters.name); <END> }
code_review: We can make `DestroyProxyMessageTask` implement the Supplier, so that this method will no create a lamda but return `this` instead.
target code: protected Supplier < Operation > createOperationSupplier ( ) { return this ; }
response: protected Supplier<Operation> createOperationSupplier() { <START> return this; <END> }

sample: 599
buggy_code: public <C extends CtTypedElement> C setType(CtTypeReference<T> type) { if (type != null) { type.setParent(this); } // even if the setter delegates to getExecutable, it makes sense to create an event <START> getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType()); <END> if (getExecutable() != null) { getExecutable().setType(type); } return (C) this; }
code_review: So model change listener will be called twice for single modification? I do not like it. @monperrus Could you explain why it is good?
target code: public < C extends CtTypedElement > C setType ( CtTypeReference < T > type ) { if ( type != null ) { type . setParent ( this ) ; } if ( getExecutable ( ) != null ) { getExecutable ( ) . setType ( type ) ; } return ( C ) this ; }
response: public <C extends CtTypedElement> C setType(CtTypeReference<T> type) { if (type != null) { type.setParent(this); } // even if the setter delegates to getExecutable, it makes sense to create an event <START> getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType()); <END> if (getExecutable() != null) { getExecutable().setType(type); } return (C) this; }

sample: 600
buggy_code: public static AuthenticationProfileRepository getInstance() { return instance; <START> } <END>
code_review: I do not understand the above two... but for ut it will be hell.
target code: public static AuthenticationProfileRepository getInstance ( ) { if ( instance == null ) { synchronized ( AuthenticationProfileRepository . class ) { if ( instance == null ) { instance = new AuthenticationProfileRepository ( ) ; } } } return instance ; }
response: public static AuthenticationProfileRepository getInstance() { return instance; }

sample: 601
buggy_code: public HttpRequest filterKey(HttpRequest request) throws HttpException { request = replaceDateHeader(request); String signature = calculateSignature(createStringToSign(request)); <START> request = replaceAuthorizationHeader(request, signature); <END> return request; }
code_review: ```suggestion ```
target code: public HttpRequest filterKey ( HttpRequest request ) throws HttpException { request = replaceDateHeader ( request ) ; String signature = calculateSignature ( createStringToSign ( request ) ) ; return replaceAuthorizationHeader ( request , signature ) ; }
response: public HttpRequest filterKey(HttpRequest request) throws HttpException { request = replaceDateHeader(request); String signature = calculateSignature(createStringToSign(request)); <START> request = replaceAuthorizationHeader(request, signature); <END> return request; }

sample: 602
buggy_code: public ScreenshotSize get() { <START> if (config.getScreenshotSize() == ScreenshotSize.DOUBLE_SIZE) { <END> return ScreenshotSize.DOUBLE_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.NORMAL_SIZE) { return ScreenshotSize.NORMAL_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.HALF_SIZE) { return ScreenshotSize.HALF_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.QUARTER_SIZE) { return ScreenshotSize.QUARTER_SIZE; } else { return ScreenshotSize.NORMAL_SIZE; } }
code_review: Again, should just return the value if not null.
target code: public ScreenshotSize get ( ) { if ( config . getScreenshotSize ( ) != null ) { return config . getScreenshotSize ( ) ; } else { return ScreenshotSize . NORMAL_SIZE ; } }
response: public ScreenshotSize get() { <START> if (config.getScreenshotSize() == ScreenshotSize.DOUBLE_SIZE) { <END> return ScreenshotSize.DOUBLE_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.NORMAL_SIZE) { return ScreenshotSize.NORMAL_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.HALF_SIZE) { return ScreenshotSize.HALF_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.QUARTER_SIZE) { return ScreenshotSize.QUARTER_SIZE; } else { return ScreenshotSize.NORMAL_SIZE; } }

sample: 603
buggy_code: <START> public String canonicalID() { <END> return canonical; }
code_review: Why make this non-final? Given how important this method is for its serialization/internal representation, it's pretty important that it not be overridden.
target code: public final String canonicalID ( ) { return canonical ; }
response: <START> public final String canonicalID() { <END> return canonical; }

sample: 604
buggy_code: protected void close() { try { <START> m_sout.flush(); <END> m_sout.close(); } catch (IOException ex) { } }
code_review: close does an implicit flush
target code: protected void close ( ) { try { m_sout . close ( ) ; } catch ( IOException ex ) { } }
response: protected void close() { try { <START> m_sout.close(); <END> } catch (IOException ex) { } }

sample: 605
buggy_code: protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) { long last = tracker.readLastCommittedOffset(); <START> return (last > 0) && (last >= offset); <END> }
code_review: No need for parentheses.
target code: protected boolean isProcessed ( ChronicleLogOffsetTracker tracker , long offset ) { long last = tracker . readLastCommittedOffset ( ) ; return last > 0 && last >= offset ; }
response: protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) { long last = tracker.readLastCommittedOffset(); <START> return last > 0 && last >= offset; <END> }

sample: 606
buggy_code: public EList<Diff> getDifferences() { <START> return new BasicEList<Diff>(this.diffs); <END> }
code_review: Please don't create a new list on every call of getDifferences(), but create the list once, e.g., on the first call, and then return the same instance. You might want to use an UnmodifiableEList instead, to fail early, if someone tries to modify it.
target code: public EList < Diff > getDifferences ( ) { return this . diffs ; }
response: public EList<Diff> getDifferences() { <START> return this.diffs; <END> }

sample: 607
buggy_code: <START> public IOWorkers.Selector getWorkerSelector() { <END> return workerSelector; }
code_review: @clevertension Why do we need to expose `IOWorkers.Selector`? Looks completely unnecessary to me.
target code: IOWorkers . Selector getWorkerSelector ( ) { return workerSelector ; }
response: public IOWorkers.Selector getWorkerSelector() { return workerSelector; }

sample: 608
buggy_code: public Iterable<Tree> children() { List<Tree> result = new ArrayList<>(); if(openParenToken != null) { result.add(openParenToken); } <START> for (Tree tree : super.children()) { <END> result.add(tree); } if(closeParenToken != null) { result.add(closeParenToken); } return result; }
code_review: `super.children().forEach(res::add);` ?
target code: public Iterable < Tree > children ( ) { List < Tree > result = new ArrayList < > ( ) ; if ( openParenToken != null ) { result . add ( openParenToken ) ; } super . children ( ) . forEach ( result : : add ) ; if ( closeParenToken != null ) { result . add ( closeParenToken ) ; } return result ; }
response: public Iterable<Tree> children() { List<Tree> result = new ArrayList<>(); if(openParenToken != null) { result.add(openParenToken); } <START> super.children().forEach(res::add); <END> if(closeParenToken != null) { result.add(closeParenToken); } return result; }

sample: 609
buggy_code: public void setName(String name) { Objects.requireNonNull(name); <START> this.name = name; <END> }
code_review: `requireNonNull` could be on same line than affectation.
target code: public void setName ( String name ) { this . name = requireNonNull ( name ) ; }
response: public void setName(String name) { <START> this.name = Objects.requireNonNull(name); <END> }

sample: 610
buggy_code: public Query existsQuery(QueryShardContext context) { if (hasDocValues()) { return new DocValuesFieldExistsQuery(name()); <START> } else if (omitNorms()) { <END> return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())); } else { return new NormsFieldExistsQuery(name()); } }
code_review: I believe it should be `omitNorms() || indexOptions() != IndexOptions.NONE`
target code: public Query existsQuery ( QueryShardContext context ) { if ( hasDocValues ( ) ) { return new DocValuesFieldExistsQuery ( name ( ) ) ; } else { return new TermQuery ( new Term ( FieldNamesFieldMapper . NAME , name ( ) ) ) ; } }
response: public Query existsQuery(QueryShardContext context) { if (hasDocValues()) { return new DocValuesFieldExistsQuery(name()); <START> } else if (omitNorms() || indexOptions() != IndexOptions.NONE) { <END> return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())); } else { return new NormsFieldExistsQuery(name()); } }

sample: 611
buggy_code: <START> private void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) { <END> if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) { yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, "yield")); } }
code_review: This method should be static
target code: private static void handleYieldExpression ( SubscriptionContext ctx , PyYieldExpressionTree yieldExpr ) { if ( yieldExpr . fromKeyword ( ) == null && yieldExpr . expressions ( ) . size ( ) == 1 ) { yieldExpr . expressions ( ) . forEach ( e - > checkExpr ( e , ctx , "yield" ) ) ; } }
response: <START> private static void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) { <END> if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) { yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, "yield")); } }

sample: 612
buggy_code: <START> private void importLdif(InMemoryDirectoryServer directoryServer) throws LDAPException { <END> if (StringUtils.hasText(this.ldif)) { try { Resource resource = locateResource(); try (InputStream inputStream = resource.getInputStream()) { directoryServer.importFromLDIF(false, new LDIFReader(inputStream)); } } catch (Exception ex) { throw new IllegalStateException("Unable to load LDIF " + this.ldif, ex); } } }
code_review: We do not need to declare that this throws an `LDAPException`.
target code: private void importLdif ( InMemoryDirectoryServer directoryServer ) { if ( StringUtils . hasText ( this . ldif ) ) { try { Resource resource = locateResource ( ) ; try ( InputStream inputStream = resource . getInputStream ( ) ) { directoryServer . importFromLDIF ( false , new LDIFReader ( inputStream ) ) ; } } catch ( Exception ex ) { throw new IllegalStateException ( "Unable to load LDIF " + this . ldif , ex ) ; } } }
response: <START> private void importLdif(InMemoryDirectoryServer directoryServer) { <END> if (StringUtils.hasText(this.ldif)) { try { Resource resource = locateResource(); try (InputStream inputStream = resource.getInputStream()) { directoryServer.importFromLDIF(false, new LDIFReader(inputStream)); } } catch (Exception ex) { throw new IllegalStateException("Unable to load LDIF " + this.ldif, ex); } } }

sample: 613
buggy_code: <START> public XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) { <END> this.table = table; this.ctTableColumn = ctTableColumn; }
code_review: I would insist in having all methods that use a `CT*` parameter to be annotated as `@Internal` when they are not private.
target code: protected XSSFTableColumn ( XSSFTable table , CTTableColumn ctTableColumn ) { this . table = table ; this . ctTableColumn = ctTableColumn ; }
response: <START> public XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) { <END> this.table = table; this.ctTableColumn = ctTableColumn; }

sample: 614
buggy_code: private boolean isDateSelectable(Date date) { <START> if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) return false; <END> return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date); }
code_review: We'd use `{` and `}` here or just fold the conditional into a single `return` statement.
target code: private boolean isDateSelectable ( Date date ) { if ( isCheckDayInSelectableCals && ! containsDate ( selectableCals , date ) ) { return false ; } return dateConfiguredListener == null || dateConfiguredListener . isDateSelectable ( date ) ; }
response: private boolean isDateSelectable(Date date) { <START> if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) { return false; } <END> return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date); }

sample: 615
buggy_code: <START> public void updatePathGroup(List<Variable> <END> variables, IPath node, IPath selection) { final int segmentsSelection = selection.segmentCount(); for (final Variable variable : variables) if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) { final IPath oldPath = variable.getPath(); final int count = selection.segmentCount(); variable.setPath(buildPath(oldPath, node, count)); } }
code_review: make static
target code: public static void updatePathGroup ( List < Variable > variables , IPath node , IPath selection ) { final int segmentsSelection = selection . segmentCount ( ) ; for ( final Variable variable : variables ) if ( variable . getPath ( ) . uptoSegment ( segmentsSelection ) . equals ( selection . makeAbsolute ( ) ) ) { final IPath oldPath = variable . getPath ( ) ; final int count = selection . segmentCount ( ) ; variable . setPath ( buildPath ( oldPath , node , count ) ) ; } }
response: <START> public static void updatePathGroup(List<Variable> <END> variables, IPath node, IPath selection) { final int segmentsSelection = selection.segmentCount(); for (final Variable variable : variables) if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) { final IPath oldPath = variable.getPath(); final int count = selection.segmentCount(); variable.setPath(buildPath(oldPath, node, count)); } }

sample: 616
buggy_code: private FactorComparator(String factorName, int weight, Comparator<T> comparator){ this.factorName = factorName; this.weight = weight; this.comparator = comparator; <START> logger.info("comparator created for " + this.factorName); <END> }
code_review: is this necessary?
target code: private FactorComparator ( String factorName , int weight , Comparator < T > comparator ) { this . factorName = factorName ; this . weight = weight ; this . comparator = comparator ; }
response: private FactorComparator(String factorName, int weight, Comparator<T> comparator){ this.factorName = factorName; this.weight = weight; this.comparator = comparator; <START> logger.info("comparator created for " + this.factorName); <END> } <START> logger.info("comparator created for " + this.factorName); <END>

sample: 617
buggy_code: <START> public PatternMatcher(TermContext context) { <END> this.termContext = context; multiSubstitutions = new ArrayList<java.util.Collection<Map<Variable, Term>>>(); }
code_review: why was this done?
target code: private PatternMatcher ( TermContext context ) { this . termContext = context ; multiSubstitutions = new ArrayList < Collection < Map < Variable , Term > > > ( ) ; }
response: <START> public PatternMatcher(TermContext context) { <END> this.termContext = context; multiSubstitutions = new ArrayList<java.util.Collection<Map<Variable, Term>>>();

sample: 618
buggy_code: public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode()); <START> result = prime * result + ((getBranchId().isInvalid()) ? 0 : getBranchId().hashCode()); <END> return result; }
code_review: result = prime * result + getBranchId().hashCode(); can use BranchId's hashCode method directly since branchId is not allowed to be null and it will work whether the id is valid or not
target code: public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( getArtUuid ( ) == null ) ? 0 : getArtUuid ( ) . hashCode ( ) ) ; result = prime * result + getBranchId ( ) . hashCode ( ) ; return result ; }
response: public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode()); <START> result = prime * result + getBranchId().hashCode(); <END> return result; }

sample: 619
buggy_code: <START> protected void <END> setUpGetUnregisteredVmTemplateExpectations(boolean notFound) { setUpEntityQueryExpectations( QueryType.GetUnregisteredVmTemplate, GetUnregisteredEntityQueryParameters.class, new String[] { "StorageDomainId", "EntityId" }, new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID }, notFound ? null : getEntity(1)); }
code_review: Can be private
target code: private void setUpGetUnregisteredVmTemplateExpectations ( boolean notFound ) { setUpEntityQueryExpectations ( QueryType . GetUnregisteredVmTemplate , GetUnregisteredEntityQueryParameters . class , new String [ ] { "StorageDomainId" , "EntityId" } , new Object [ ] { STORAGE_DOMAIN_ID , TEMPLATE_ID } , notFound ? null : getEntity ( 1 ) ) ; }
response: <START> private void <END> setUpGetUnregisteredVmTemplateExpectations(boolean notFound) { setUpEntityQueryExpectations( QueryType.GetUnregisteredVmTemplate, GetUnregisteredEntityQueryParameters.class, new String[] { "StorageDomainId", "EntityId" }, new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID }, notFound ? null : getEntity(1)); }

sample: 620
buggy_code: <START> public boolean isDomainXmlEnabledForVds(Guid vdsId) { <END> return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion()); }
code_review: The whole purpose of FullListAdapter is to abstract the implementation details of querying the device list from the caller - so how about moving the changes that are done in VmDevicesMonitoring to FullListVDSCommand ?
target code: private boolean isDomainXmlEnabledForVds ( Guid vdsId ) { return FeatureSupported . isDomainXMLSupported ( getVdsManager ( vdsId ) . getCompatibilityVersion ( ) ) ; }
response: <START> public boolean isDomainXmlEnabledForVds(Guid vdsId) { <END> return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion()); }

sample: 621
buggy_code: public void mousePressed(MouseEvent e) { <START> if (e.isPopupTrigger()) <END> doPop(e); }
code_review: Please add {} also for `if` blocks with only one statement.
target code: public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { doPop ( e ) ; } }
response: public void mousePressed(MouseEvent e) { <START> if (e.isPopupTrigger()) { <END> doPop(e); } }

sample: 622
buggy_code: public boolean isSuggestionListDisplayed() { try { <START> waitForElementByElement(searchSuggestions.get(0)); <END> return searchSuggestions.get(0).isDisplayed(); } catch (NoSuchElementException|IndexOutOfBoundsException e) {} return false; }
code_review: Use .getSize to see if element is on page
target code: public boolean isSuggestionListDisplayed ( ) { try { if ( searchSuggestions . size ( ) > 0 ) { waitForElementByElement ( searchSuggestions . get ( 0 ) ) ; return searchSuggestions . get ( 0 ) . isDisplayed ( ) ; } } catch ( NoSuchElementException e ) { } return false ; }
response: public boolean isSuggestionListDisplayed() { try { <START> waitForElementByElement(searchSuggestions.get(0)); <END> return searchSuggestions.get(0).getSize().getHeight() > 0; } catch (NoSuchElementException|IndexOutOfBoundsException e) {} return false; }

sample: 623
buggy_code: public ConnectionId(final String host, final int port, final String connectionId) { Objects.requireNonNull(host); if (port <= 0) { <START> throw new IllegalArgumentException(String.format("Port must be greater than 0")); <END> } this.host = host; this.port = port; this.connectionId = connectionId; }
code_review: no need to use String.format as there is no parameter. Either provide directly throw new IllegalArgumentException("Port must be greater than 0"); or maybe improve message with somethign like: throw new IllegalArgumentException(String.format("Port must be greater than 0 (provided {0})", port));
target code: public ConnectionId ( final String host , final int port , final String connectionId ) { Objects . requireNonNull ( host ) ; if ( port <= 0 ) { throw new IllegalArgumentException ( "Port must be greater than 0" ) ; } this . host = host ; this . port = port ; this . connectionId = connectionId ; }
response: public ConnectionId(final String host, final int port, final String connectionId) { Objects.requireNonNull(host); if (port <= 0) { <START> throw new IllegalArgumentException("Port must be greater than 0"); <END> } this.host = host; this.port = port; this.connectionId = connectionId; }

sample: 624
buggy_code: public RecursiveLoggerContextInstantiationException(String message) { <START> super(I18nMessageFactory.createStaticMessage(message)); <END> }
code_review: use static import.
target code: public RecursiveLoggerContextInstantiationException ( String message ) { super ( createStaticMessage ( message ) ) ; }
response: public RecursiveLoggerContextInstantiationException(String message) { <START> super(createStaticMessage(message)); <END> }

sample: 625
buggy_code: <START> public Map<String, MetricPlotDTOs> createTaskPlots() { <END> sessionId = getSessionIdProvider().getSessionId(); // check new model List<MetricPointEntity> metricDetails = getHibernateTemplate().find( "select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?", sessionId); if (metricDetails == null || metricDetails.isEmpty()) { return oldWay(); } else { return newWay(metricDetails); } }
code_review: why is it public?
target code: private Map < String , MetricPlotDTOs > createTaskPlots ( ) { // check new model List < MetricPointEntity > metricDetails = getHibernateTemplate ( ) . find ( "select m from MetricPointEntity m where m . metricDescription . taskData . sessionId = ? " , sessionId ) ; if ( metricDetails == null || metricDetails . isEmpty ( ) ) { return oldWay ( ) ; } else { return newWay ( metricDetails ) ; } }
response: <START> public Map<String, MetricPlotDTOs> createTaskPlots() { <END> sessionId = getSessionIdProvider().getSessionId(); // check new model List<MetricPointEntity> metricDetails = getHibernateTemplate().find( "select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?", sessionId); if (metricDetails == null || metricDetails.isEmpty()) { return oldWay(); } else { return newWay(metricDetails); } }

sample: 626
buggy_code: public void testDeadlock() throws Exception { doTest(1000 * 30); // 30 secs almost always locks boolean <START> interrupted = <END> Thread.interrupted(); if (interrupted) { fail("Thread was interrupted at end of test"); } }
code_review: Why not inline this variable?
target code: public void testDeadlock ( ) throws Exception { doTest ( 1000 * 30 ) ; // 30 secs almost always locks if ( Thread . interrupted ( ) ) { fail ( "Thread was interrupted at end of test" ) ; } }
response: public void testDeadlock() throws Exception { doTest(1000 * 30); // 30 secs almost always locks boolean <START> interrupted = <END> Thread.interrupted(); if (Thread.interrupted()) { fail("Thread was interrupted at end of test"); } }

sample: 627
buggy_code: public static QueryGranularity fromString(String str) { String name = str.toUpperCase(); if(name.equals("ALL")) { return QueryGranularity.ALL; } else if(name.equals("NONE")) { return QueryGranularity.NONE; } else if(CAL<END>RIC_GRANULARITIES.containsKey(name)) { <START> return new PeriodGranularity(CAL<END>RIC_GRANULARITIES.get(name), null, null); <END> } return new DurationGranularity(convertValue(str), 0); }
code_review: instead of creating a new object every time, it might make more sense to store constants for each predefined granularity string
target code: public static QueryGranularity fromString ( String str ) { String name = str . toUpperCase ( ) ; if ( name . equals ( "ALL" ) ) { return QueryGranularity . ALL ; } else if ( name . equals ( "NONE" ) ) { return QueryGranularity . NONE ; } else if ( CALENDRIC_GRANULARITIES . containsKey ( name ) ) { return CALENDRIC_GRANULARITIES . get ( name ) ; } return new DurationGranularity ( convertValue ( str ) , 0 ) ; }
response: public static QueryGranularity fromString(String str) { String name = str.toUpperCase(); if(name.equals("ALL")) { return QueryGranularity.ALL; } else if(name.equals("NONE")) { return QueryGranularity.NONE; } else if(CAL<END>RIC_GRANULARITIES.containsKey(name)) { <START> return CAL<END>RIC_GRANULARITIES.get(name); <END> } return new DurationGranularity(convertValue(str), 0); }

sample: 628
buggy_code: public Object[] getElements(Object element) { <START> if (element instanceof Object[]) { <END> return (Object[]) element; } if (element instanceof Collection) { return ((Collection) element).toArray(); } return new Object[0]; }
code_review: style nit: we don't use braces around single line blocks
target code: public Object [ ] getElements ( Object element ) { if ( element instanceof Object [ ] ) return ( Object [ ] ) element ; if ( element instanceof Collection ) return ( ( Collection ) element ) . toArray ( ) ; return new Object [ 0 ] ; }
response: public Object[] getElements(Object element) { <START> if (element instanceof Object[]) <END> return (Object[]) element; if (element instanceof Collection) return ((Collection) element).toArray(); return new Object[0]; }

sample: 629
buggy_code: public void setUp() throws Exception { super.setUp(); <START> if (SystemUtils.IS_OS_LINUX) { <END> try { eventLoopGroup = new EpollEventLoopGroup(); } catch (Throwable t) { LOG.warn("Could not use Netty Epoll event loop {}", t.getMessage()); eventLoopGroup = new NioEventLoopGroup(); } } else { eventLoopGroup = new NioEventLoopGroup(); } executor = OrderedSafeExecutor.newBuilder() .name("BKClientOrderedSafeExecutor") .numThreads(2) .build(); }
code_review: maybe we should create a common utility function to build EventLoopGroups and do not duplicate this kind of code
target code: public void setUp ( ) throws Exception { super . setUp ( ) ; eventLoopGroup = new NioEventLoopGroup ( ) ; executor = OrderedSafeExecutor . newBuilder ( ) . name ( "BKClientOrderedSafeExecutor" ) . numThreads ( 2 ) . build ( ) ; }
response: public void setUp() throws Exception { super.setUp(); <START> if (SystemUtils.IS_OS_LINUX) { <END> try { eventLoopGroup = new EpollEventLoopGroup(); } catch (Throwable t) { LOG.warn("Could not use Netty Epoll event loop {}", t.getMessage()); eventLoopGroup = new NioEventLoopGroup(); } } else { eventLoopGroup = new NioEventLoopGroup(); } executor = OrderedSafeExecutor.newBuilder() .name("BKClientOrderedSafeExecutor") .numThreads(2) .build(); }

sample: 630
buggy_code: private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength) { try { long readStart = System.nanoTime(); inputStream.readFully(position, buffer, bufferOffset, bufferLength); stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart); } catch (PrestoException e) { // just in case there is a Presto wrapper or hook throw e; } catch (Exception e) { <START> throw new PrestoException(HIVE_FILESYSTEM_ERROR, format("Error reading from %s at position %s", id.toString(), position), e); <END> } }
code_review: Don't need the `toString` call.
target code: private void readInternal ( long position , byte [ ] buffer , int bufferOffset , int bufferLength ) { try { long readStart = System . nanoTime ( ) ; inputStream . readFully ( position , buffer , bufferOffset , bufferLength ) ; stats . readDataBytesPerSecond ( bufferLength , System . nanoTime ( ) - readStart ) ; } catch ( PrestoException e ) { // just in case there is a Presto wrapper or hook throw e ; } catch ( Exception e ) { throw new PrestoException ( HIVE_FILESYSTEM_ERROR , format ( "Error reading from % s at position % s" , id , position ) , e ) ; } }
response: private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength) { try { long readStart = System.nanoTime(); inputStream.readFully(position, buffer, bufferOffset, bufferLength); stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart); } catch (PrestoException e) { // just in case there is a Presto wrapper or hook throw e; } catch (Exception e) { <START> throw new PrestoException(HIVE_FILESYSTEM_ERROR, format("Error reading from %s at position %s", id, position), e); <END> } }

sample: 631
buggy_code: public void invalidPropertiesFormat() { VmDevice device = new VmDevice(); device.setType(VmDeviceGeneralType.DISK); device.setCustomProperties("bootable"); DevicePropertiesUtils utils = mockDevicePropertiesUtils(); List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device); assertFalse(errors.isEmpty()); <START> assertTrue(errors.get(0).getReason() == ValidationFailureReason.SYNTAX_ERROR); <END> }
code_review: Don't you prefer to use assertEquals?
target code: public void invalidPropertiesFormat ( ) { VmDevice device = new VmDevice ( ) ; device . setType ( VmDeviceGeneralType . DISK ) ; device . setCustomProperties ( "bootable" ) ; DevicePropertiesUtils utils = mockDevicePropertiesUtils ( ) ; List < ValidationError > errors = utils . validateDeviceProperties ( Version . v3_3 , device ) ; assertFalse ( errors . isEmpty ( ) ) ; assertEquals ( ValidationFailureReason . SYNTAX_ERROR , errors . get ( 0 ) . getReason ( ) ) ; }
response: public void invalidPropertiesFormat() { VmDevice device = new VmDevice(); device.setType(VmDeviceGeneralType.DISK); device.setCustomProperties("bootable"); DevicePropertiesUtils utils = mockDevicePropertiesUtils(); List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device); assertFalse(errors.isEmpty()); <START> assertEquals(errors.get(0).getReason(), ValidationFailureReason.SYNTAX_ERROR); <END> }

sample: 632
buggy_code: private boolean isMandatory(MethodExpression expression) { <START> return expression.getMethod().getWords().get(0).equals(MANDATORY) ? true : false; <END> }
code_review: If this is the use of the "MANDATORY" constant then you may want to define it as a "Name" instead of "String": privates static final Name MANDATORY = NameParser.parseUsingCase("Mandatory"); Then you can compare it easily: return expression.getMethod().equals(MANDATORY);
target code: private boolean isMandatory ( MethodExpression expression ) { return expression . getMethod ( ) . equals ( MANDATORY ) ? true : false ; }
response: private boolean isMandatory(MethodExpression expression) { <START> return expression.getMethod().equals(MANDATORY); <END> }

sample: 633
buggy_code: <START> private DeltaVisit next() { <END> // If our parent has no more children, discard it. if (parent != null && parent.nextChild == null) { parent.data = null; parent = parent.parent; } if (nextChild != null) return new DeltaVisit(this); // If we have no child ourselves, our parent must (if it exists), // due to the discard rule above. With no parent, we are done. if (parent != null) return new DeltaVisit(parent); return null; }
code_review: Good change making this an instance member, thanks.
target code: DeltaVisit next ( ) { // If our parent has no more children , discard it . if ( parent != null && parent . nextChild == null ) { parent . data = null ; parent = parent . parent ; } if ( nextChild != null ) return new DeltaVisit ( this ) ; // If we have no child ourselves , our parent must ( if it exists ) , // due to the discard rule above . With no parent , we are done . if ( parent != null ) return new DeltaVisit ( parent ) ; return null ; }
response: <START> private DeltaVisit next() { <END> // If our parent has no more children, discard it. if (parent != null && parent.nextChild == null) { parent.data = null; parent = parent.parent; } if (nextChild != null) return new DeltaVisit(this); // If we have no child ourselves, our parent must (if it exists), // due to the discard rule above. With no parent, we are done. if (parent != null) return new DeltaVisit(parent); return null; }

sample: 634
buggy_code: boolean delayNextTimeToRun(Date timeToRunTheVm) { this.timeToRunTheVm = timeToRunTheVm; <START> return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_<START>_VM; <END> }
code_review: we can do something like: numOfSkips = ++numOfSkips % MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM; return numOfSkips == 0; and remove clearSkipCounter, no? if this was already properly verified, we can merge this and think about the change above on master-only
target code: boolean delayNextTimeToRun ( Date timeToRunTheVm ) { this . timeToRunTheVm = timeToRunTheVm ; numOfSkips = ++ numOfSkips % MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM ; return numOfSkips != 0 ; }
response: boolean delayNextTimeToRun(Date timeToRunTheVm) { this.timeToRunTheVm = timeToRunTheVm; <START> return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM; <END> }

sample: 635
buggy_code: protected boolean isTransientException(Throwable e) { if(e instanceof SQLException) { final String sqlState = ((SQLException) e).getSQLState(); // retry on connection errors and insufficient resources // (see http://www.postgresql.org/docs/current/static/errcodes-appendix.html) <START> return sqlState.startsWith("08") || sqlState.startsWith("53"); <END> } return false; }
code_review: Of the "53" class of errors, I think only "53300" might be transient, no?
target code: protected boolean isTransientException ( Throwable e ) { if ( e instanceof SQLException ) { final String sqlState = ( ( SQLException ) e ) . getSQLState ( ) ; // limited to errors that are likely to be resolved within a few retries // retry on connection errors and insufficient resources // see http :/ / www . postgresql . org / docs / current / static / errcodes - appendix . html for details return sqlState != null && ( sqlState . startsWith ( "08" ) || sqlState . startsWith ( "53" ) ) ; } return false ; }
response: protected boolean isTransientException(Throwable e) { if(e instanceof SQLException) { final String sqlState = ((SQLException) e).getSQLState(); // retry on connection errors and insufficient resources // (see http://www.postgresql.org/docs/current/static/errcodes-appendix.html) <START> return sqlState.startsWith("08") || sqlState.startsWith("53300"); <END> } return false; }

sample: 636
buggy_code: public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) { // send(op, myMsgs, otherMsgs); JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor); // add(op, myMsgs) to outgoing; <START> if (!(op instanceof TimestampOperation)) { <END> this.ackJupiterActivityList.add( new OperationWrapper(op, this.vectorTime.getLocalOperationCount())); } // myMsgs = myMsgs + 1; this.vectorTime = this.vectorTime.incrementLocalOperationCount(); return jupiterActivity; }
code_review: So you pointed me to this line and what is the problem here ? The problem is that discardAcknowledgedOperations is never called. This was never done in this method anyway.
target code: public JupiterActivity generateJupiterActivity ( Operation op , User source , SPath editor ) { // send ( op , myMsgs , otherMsgs ) ; JupiterActivity jupiterActivity = new JupiterActivity ( this . vectorTime , op , source , editor ) ; // add ( op , myMsgs ) to outgoing ; this . ackJupiterActivityList . add ( new OperationWrapper ( op , this . vectorTime . getLocalOperationCount ( ) ) ) ; // myMsgs = myMsgs + 1 ; this . vectorTime = this . vectorTime . incrementLocalOperationCount ( ) ; return jupiterActivity ; }
response: public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) { // send(op, myMsgs, otherMsgs); JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor); // add(op, myMsgs) to outgoing; <START> if (!(op instanceof TimestampOperation)) { <END> this.ackJupiterActivityList.add( new OperationWrapper(op, this.vectorTime.getLocalOperationCount())); } // myMsgs = myMsgs + 1; this.vectorTime = this.vectorTime.incrementLocalOperationCount(); this.discardAcknowledgedOperations(); return jupiterActivity; }

sample: 637
buggy_code: public void testAssignExecutorInvalidExecutor() throws Exception { final ExecutableFlow flow = TestUtils.createExecutableFlow("exectest1", "exec1"); this.executionFlowDao.uploadExecutableFlow(flow); assertThatThrownBy( <START> () -> this.assignExecutor.assignExecutor(flow.getExecutionId(), 1)) <END> .isInstanceOf(ExecutorManagerException.class) .hasMessageContaining("non-existent executor"); }
code_review: Should it be assignExecutor(1, flow.getExecutionId())? Also how do you know 1 is a non-existent executor?
target code: public void testAssignExecutorInvalidExecutor ( ) throws Exception { final ExecutableFlow flow = TestUtils . createExecutableFlow ( "exectest1" , "exec1" ) ; this . executionFlowDao . uploadExecutableFlow ( flow ) ; // Since we haven't inserted any executors , 1 should be non - existent executor id . assertThatThrownBy ( ( ) - > this . assignExecutor . assignExecutor ( 1 , flow . getExecutionId ( ) ) ) . isInstanceOf ( ExecutorManagerException . class ) . hasMessageContaining ( "non - existent executor" ) ; }
response: public void testAssignExecutorInvalidExecutor() throws Exception { final ExecutableFlow flow = TestUtils.createExecutableFlow("exectest1", "exec1"); this.executionFlowDao.uploadExecutableFlow(flow); assertThatThrownBy( <START> () -> this.assignExecutor.assignExecutor(1, flow.getExecutionId())) <END> .isInstanceOf(ExecutorManagerException.class) .hasMessageContaining("non-existent executor"); }

sample: 638
buggy_code: private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions() <START> throws Exception <END> { ConnectorSession connectorSession = new TestingConnectorSession( new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties()); return new BackgroundHiveSplitLoader( SIMPLE_TABLE, createPartitionMetadataWithOfflinePartitions(), TupleDomain.all(), createBucketSplitInfo(Optional.empty(), ImmutableList.of()), connectorSession, new TestingHdfsEnvironment(), new NamenodeStats(), new TestingDirectoryLister(TEST_FILES), directExecutor(), 2, false); }
code_review: no `Exception` is thrown here
target code: private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions ( ) { ConnectorSession connectorSession = new TestingConnectorSession ( new HiveSessionProperties ( new HiveClientConfig ( ) . setMaxSplitSize ( new DataSize ( 1 . 0 , GIGABYTE ) ) ) . getSessionProperties ( ) ) ; return new BackgroundHiveSplitLoader ( SIMPLE_TABLE , createPartitionMetadataWithOfflinePartitions ( ) , TupleDomain . all ( ) , createBucketSplitInfo ( Optional . empty ( ) , ImmutableList . of ( ) ) , connectorSession , new TestingHdfsEnvironment ( ) , new NamenodeStats ( ) , new TestingDirectoryLister ( TEST_FILES ) , directExecutor ( ) , 2 , false ) ; }
response: private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions() { ConnectorSession connectorSession = new TestingConnectorSession( new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties()); return new BackgroundHiveSplitLoader( SIMPLE_TABLE, createPartitionMetadataWithOfflinePartitions(), TupleDomain.all(), createBucketSplitInfo(Optional.empty(), ImmutableList.of()), connectorSession, new TestingHdfsEnvironment(), new NamenodeStats(), new TestingDirectoryLister(TEST_FILES), directExecutor(), 2, false); }

sample: 639
buggy_code: public String toString() { <START> return methodPrefix.toString(); <END> }
code_review: 'methodPrefix.toString()' is redundant
target code: public String toString ( ) { return methodPrefix ; }
response: public String toString() { <START> return methodPrefix; <END> }

sample: 640
buggy_code: private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) { android.view.textclassifier.TextClassificationManager <START> textClassificationManager = <END> (android.view.textclassifier.TextClassificationManager) mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE); android.view.textclassifier.TextClassifier platformTextClassifier = textClassifier == null ? null : new PlatformTextClassifier(mContext, textClassifier); textClassificationManager.setTextClassifier(platformTextClassifier); }
code_review: TCM is an optional Android system service. Check for null.
target code: private void setPlatformTextClassifier ( @Nullable TextClassifier textClassifier ) { android . view . textclassifier . TextClassificationManager textClassificationManager = ( android . view . textclassifier . TextClassificationManager ) mContext . getSystemService ( Context . TEXT_CLASSIFICATION_SERVICE ) ; if ( textClassificationManager == null ) { return ; } android . view . textclassifier . TextClassifier platformTextClassifier = textClassifier == null ? null : new PlatformTextClassifier ( mContext , textClassifier ) ; textClassificationManager . setTextClassifier ( platformTextClassifier ) ; }
response: private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) { android.view.textclassifier.TextClassificationManager <START> textClassificationManager = <END> (android.view.textclassifier.TextClassificationManager) mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE); if (textClassificationManager != null) { android.view.textclassifier.TextClassifier platformTextClassifier = textClassifier == null ? null : new PlatformTextClassifier(mContext, textClassifier); textClassificationManager.setTextClassifier(platformTextClassifier); } }

sample: 641
buggy_code: Object loadServiceCapabilities(String serviceUrl) throws IOException { HttpGet request = new HttpGet(serviceUrl); request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES)); CloseableHttpResponse httpResponse = execute(request, serviceUrl, "retrieve help"); validateResponse(httpResponse, serviceUrl); HttpEntity httpEntity = httpResponse.getEntity(); ContentType contentType = ContentType.getOrDefault(httpEntity); <START> if ("text/plain".equals(contentType.getMimeType())) { <END> return getContent(httpEntity); } return parseJsonMetadata(httpEntity); }
code_review: mime type is mandatory
target code: Object loadServiceCapabilities ( String serviceUrl ) throws IOException { HttpGet request = new HttpGet ( serviceUrl ) ; request . setHeader ( new BasicHeader ( HttpHeaders . ACCEPT , ACCEPT_SERVICE_CAPABILITIES ) ) ; CloseableHttpResponse httpResponse = execute ( request , serviceUrl , "retrieve help" ) ; validateResponse ( httpResponse , serviceUrl ) ; HttpEntity httpEntity = httpResponse . getEntity ( ) ; ContentType contentType = ContentType . getOrDefault ( httpEntity ) ; if ( contentType . getMimeType ( ) . equals ( "text / plain" ) ) { return getContent ( httpEntity ) ; } return parseJsonMetadata ( httpEntity ) ; }
response: Object loadServiceCapabilities(String serviceUrl) throws IOException { HttpGet request = new HttpGet(serviceUrl); request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES)); CloseableHttpResponse httpResponse = execute(request, serviceUrl, "retrieve help"); validateResponse(httpResponse, serviceUrl); HttpEntity httpEntity = httpResponse.getEntity(); ContentType contentType = ContentType.getOrDefault(httpEntity); <START> if ("text/plain".equals(contentType.getMimeType())) { <END> return getContent(httpEntity); } return parseJsonMetadata(httpEntity); }

sample: 642
buggy_code: protected void doStop() { log.info("Stopping Netty server"); boss.shutdownGracefully(); if(!datagram) { <START> wrkr.shutdownGracefully(); <END> } try { sock.channel().closeFuture().sync(); } catch (InterruptedException e) { log.warn("Netty server stop interrupted"); Thread.currentThread().interrupt(); } log.info("Netty server stopped"); notifyStopped(); }
code_review: I think it is the boss who should be shut down if (!datagram)
target code: protected void doStop ( ) { log . info ( "Stopping Netty server" ) ; wrkr . shutdownGracefully ( ) ; if ( ! datagram ) { boss . shutdownGracefully ( ) ; } try { sock . channel ( ) . closeFuture ( ) . sync ( ) ; } catch ( InterruptedException e ) { log . warn ( "Netty server stop interrupted" ) ; Thread . currentThread ( ) . interrupt ( ) ; } log . info ( "Netty server stopped" ) ; notifyStopped ( ) ; }
response: protected void doStop() { log.info("Stopping Netty server"); if(!datagram) { <START> boss.shutdownGracefully(); <END> } wrkr.shutdownGracefully(); try { sock.channel().closeFuture().sync(); } catch (InterruptedException e) { log.warn("Netty server stop interrupted"); Thread.currentThread().interrupt(); } log.info("Netty server stopped"); notifyStopped(); }

sample: 643
buggy_code: public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { <START> LayoutInflater inflater = LayoutInflater.from(parent.getContext()); <END> return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false)); }
code_review: Maybe pass the layout inflater as a param to the adapter.
target code: public ChannelViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { return new ChannelViewHolder ( ( ChannelView ) inflater . inflate ( R . layout . channel_item_layout , parent , false ) ) ; }
response: public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false)); }

sample: 644
buggy_code: public void onSelectionChanged(int selectedItemCnt) { int numberMergeSelections = adapter.numberMergeSelections; if (adapter.isMergeSelection && selectedItemCnt >= numberMergeSelections) { <START> ToastUtil.showError(getContext(), "We can only merge " + numberMergeSelections + " projects"); <END> } updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection)); actionMode.setTitle(getResources() .getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt)); }
code_review: is there a reason that this is displayed everytime? since this is shown when the second project is selected, it will always be there.
target code: public void onSelectionChanged ( int selectedItemCnt ) { updateSelectionToggle ( actionMode . getMenu ( ) . findItem ( R . id . toggle_selection ) ) ; actionMode . setTitle ( getResources ( ) . getQuantityString ( getActionModeTitleId ( actionModeType ) , selectedItemCnt , selectedItemCnt ) ) ; }
response: public void onSelectionChanged(int selectedItemCnt) { int numberMergeSelections = adapter.numberMergeSelections; if (adapter.isMergeSelection && selectedItemCnt >= numberMergeSelections) { <START> ToastUtil.showError(getContext(), "We can only merge " + numberMergeSelections + " projects"); <END> } updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection)); actionMode.setTitle(getResources() .getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt)); }

sample: 645
buggy_code: private boolean shouldBeDistributed(PlanNode planNode) { return planNode instanceof AggregationNode || planNode instanceof JoinNode || <START> (planNode instanceof TopNNode && ((TopNNode) planNode).getStep().equals(TopNNode.Step.PARTIAL)); <END> }
code_review: The method will grow (i once already wanted to add something here), so what about putting this in a more lengthy but more readable way? (Note, I also changed TopNNode's condition) ``` if (planNode instanceof JoinNode) { return true; } if (planNode instanceof AggregationNode) { return true; // here you could differentiate between partial/... } if (planNode instanceof TopNNode) { return ((TopNNode) planNode).getStep() != TopNNode.Step.FINAL; } return false; ```
target code: private boolean shouldBeDistributed ( PlanNode planNode ) { if ( planNode instanceof JoinNode ) { return true ; } if ( planNode instanceof AggregationNode ) { // TODO : differentiate aggregation with empty grouping set return true ; } if ( planNode instanceof TopNNode ) { return ( ( TopNNode ) planNode ) . getStep ( ) == TopNNode . Step . PARTIAL ; } return false ; }
response: private boolean shouldBeDistributed(PlanNode planNode) { return planNode instanceof AggregationNode || planNode instanceof JoinNode || <START> (planNode instanceof TopNNode && ((TopNNode) planNode).getStep() != TopNNode.Step.FINAL); <END> }

sample: 646
buggy_code: public void testConcurrency() { final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId); marshal("application/xml", serverTemplate); Thread disconnect = new Thread(() -> disconnect()); disconnect.start(); String response = marshal("application/xml", serverTemplate); <START> LOGGER.info(response); <END> }
code_review: ```suggestion assertNotNull(response); ```
target code: public void testConcurrency ( ) { final ServerTemplate serverTemplate = templateStorage . load ( serverTemplateId ) ; marshal ( "application / xml" , serverTemplate ) ; Thread disconnect = new Thread ( ( ) - > disconnect ( ) ) ; disconnect . start ( ) ; String response = marshal ( "application / xml" , serverTemplate ) ; assertNotNull ( response ) ; }
response: public void testConcurrency() { final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId); marshal("application/xml", serverTemplate); Thread disconnect = new Thread(() -> disconnect()); disconnect.start(); String response = marshal("application/xml", serverTemplate); <START> assertNotNull(response); <END> }

sample: 647
buggy_code: protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) { <START> builder.append(String.format(Locale.ENGLISH, "%d", node.getValue())); <END> return null; }
code_review: ```suggestion builder.append(Integer.toString(node.getValue())); ``` Cheaper than going through `String.format`
target code: protected Void visitIntegerLiteral ( IntegerLiteral node , Integer indent ) { builder . append ( node . getValue ( ) ) ; return null ; }
response: protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) { <START> builder.append(Integer.toString(node.getValue())); <END> return null; }

sample: 648
buggy_code: <START> private List<GerritQueryResult> executeQueryRest(String query) throws GerritException { <END> List<GerritQueryResult> results = null; results = client.executeQueryRest(new NullProgressMonitor(), query); return results; }
code_review: This is essentially one line of code, I'd prefer to inline this.
target code: private List < GerritQueryResult > executeQueryRest ( String query ) throws GerritException { return client . executeQueryRest ( new NullProgressMonitor ( ) , query ) ; }
response: <START> private List<GerritQueryResult> executeQueryRest(String query) throws GerritException { <END> return client.executeQueryRest(new NullProgressMonitor(), query); }

sample: 649
buggy_code: public QueryWrapper(@JsonProperty("query") String query, @JsonProperty("queryType") String queryType) { <START> this(query, queryType, ""); <END> }
code_review: to avoid redundant pattern check : ```suggestion this(query, queryType, null); ```
target code: public QueryWrapper ( @JsonProperty ( "query" ) String query , @JsonProperty ( "queryType" ) String queryType ) { this ( query , queryType , null ) ; }
response: public QueryWrapper(@JsonProperty("query") String query, @JsonProperty("queryType") String queryType) { <START> this(query, queryType, null); <END> }

sample: 650
buggy_code: private List<CoordinatorDuty> makeCompactSegmentsDuty() { <START> List<CoordinatorDuty> duties = new ArrayList<>(); duties.add(compactSegments); return ImmutableList.copyOf(duties); <END> }
code_review: Why not `return ImmutableList.of(compactSegments);` instead?
target code: private List < CoordinatorDuty > makeCompactSegmentsDuty ( ) { return ImmutableList . of ( compactSegments ) ; }
response: private List<CoordinatorDuty> makeCompactSegmentsDuty() { <START> return ImmutableList.of(compactSegments); <END> }

sample: 651
buggy_code: public CreateServerOptions networks(String... networks) { <START> return networks(ImmutableSet.copyOf(checkNotNull(networks, "network should not be empty"))); <END> }
code_review: The "standard" jclouds pattern would be `checkNotNull(networks, "networks")`, but in this case it's not doing the expected thing since a varargs argument cannot be `null`, it will be an empty array instead. If we want to enforce this check, it probably should be: ``` checkArgument(networks.length > 0, "networks should not be empty"); return networks(ImmutableSet.copyOf(networks)); ``` but since `networks(Iterable<String> networks)` already checks I don't think we need the check here.
target code: public CreateServerOptions networks ( String . . . networks ) { return networks ( ImmutableSet . copyOf ( networks ) ) ; }
response: public CreateServerOptions networks(String... networks) { <START> return networks(ImmutableSet.copyOf(networks)); <END> }

sample: 652
buggy_code: private static AbbreviatedObjectId id(DiffEntry de) { <START> return (de.changeType == ChangeType.DELETE ? de.oldId : de.newId); <END> }
code_review: Style-nit: We don't put () around ?: in a return.
target code: private static AbbreviatedObjectId id ( DiffEntry de ) { return de . changeType == ChangeType . DELETE ? de . oldId : de . newId ; }
response: private static AbbreviatedObjectId id(DiffEntry de) { <START> return de.changeType == ChangeType.DELETE ? de.oldId : de.newId; <END> }

sample: 653
buggy_code: protected VariableReferenceExpression getVariableReference(RowExpression expression) { if (expression instanceof VariableReferenceExpression) { return ((VariableReferenceExpression) expression); } else { <START> throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), "Expected a variable reference but got " + expression); <END> } }
code_review: private
target code: protected VariableReferenceExpression getVariableReference ( RowExpression expression ) { if ( expression instanceof VariableReferenceExpression ) { return ( ( VariableReferenceExpression ) expression ) ; } throw new PinotException ( PINOT_UNSUPPORTED_EXPRESSION , Optional . empty ( ) , "Expected a variable reference but got " + expression ) ; }
response: private VariableReferenceExpression getVariableReference(RowExpression expression) { if (expression instanceof VariableReferenceExpression) { return ((VariableReferenceExpression) expression); } else { <START> throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), "Expected a variable reference but got " + expression); <END> } }

sample: 654
buggy_code: public boolean isLocalOnly() { <START> switch (this) { <END> case LOCAL: return true; default: return false; } }
code_review: it could be simpler `return this == LOCAL`
target code: public boolean isLocalOnly ( ) { return this == LOCAL ; }
response: public boolean isLocalOnly() { <START> return this == LOCAL; <END> }

sample: 655
buggy_code: protected void findUsers(String searchString, AsyncQuery query) { Frontend.getInstance() .runQuery(VdcQueryType.Search, <START> new DirectorySearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), query); //$NON-NLS-1$ //$NON-NLS-2$ <END> }
code_review: Done
target code: protected void findUsers ( String searchString , AsyncQuery query ) { Frontend . getInstance ( ) . runQuery ( VdcQueryType . Search , new DirectorySearchParameters ( "ADUSER@" + ( ( ProfileEntry ) getProfile ( ) . getSelectedItem ( ) ) . getAuthz ( ) + " : " + searchString , SearchType . DirectoryUser , getNamespace ( ) . getSelectedItem ( ) ) , query ) ; // $NON - NLS - 1$ // $NON - NLS - 2$ }
response: protected void findUsers(String searchString, AsyncQuery query) { Frontend.getInstance() .runQuery(VdcQueryType.Search, <START> new DirectorySearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), query); //$NON-NLS-1$ //$NON-NLS-2$ <END> }

sample: 656
buggy_code: public String getImageUrl(String id) { return getProvider().getUrl() + API_VERSION + "/images/" + id + <START> "/file"; <END> }
code_review: if it's v2 older hosts won't work since they use HEAD, no?
target code: public String getImageUrl ( String id ) { return getProvider ( ) . getUrl ( ) + API_VERSION + " / images / " + id ; }
response: public String getImageUrl(String id) { return getProvider().getUrl() + API_VERSION + "/images/" + id + <START> "/file" <END>; }

sample: 657
buggy_code: public User(@NonNull String username, @NonNull String password) { this(username, password, <START> new HashMap<String, Integer>(), null); <END> }
code_review: I recommend using Collections.emptyMap() instead
target code: public User ( @NonNull String username , @NonNull String password ) { this ( username , password , null , null ) ; }
response: public User(@NonNull String username, @NonNull String password) { this(username, password, <START> Collections.emptyMap(), null); <END> }

sample: 658
buggy_code: public final String consoleClientResourcesUrl() { String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL); boolean isAbsolute = url.contains("://"); return isAbsolute ? url : Window.Location.getProtocol() + "//" + Window.Location.getHost() + //$NON-NLS-1$ <START> "/" + BaseContextPathData.getInstance().getRelativePath() + url; //$NON-NLS-1$ <END> }
code_review: no... this can be relative as well... see: frontend/webadmin/modules/uicommonweb/src/main/java/org/ovirt/engine/ui/uicommonweb/ReportInit.java
target code: public final String consoleClientResourcesUrl ( ) { String url = getString ( DynamicMessageKey . CONSOLE_CLIENT_RESOURCES_URL ) ; boolean isAbsolute = url . contains ( " :/ / " ) ; return isAbsolute ? url : " / " + BaseContextPathData . getInstance ( ) . getRelativePath ( ) + url ; // $NON - NLS - 1$ }
response: public final String consoleClientResourcesUrl() { String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL); boolean isAbsolute = url.contains("://"); return isAbsolute ? url : Window.Location.getProtocol() + "//" + Window.Location.getHost() + //$NON-NLS-1$ <START> "/" + BaseContextPathData.getInstance().getRelativePath() + url; //$NON-NLS-1$ <END> }

sample: 659
buggy_code: private boolean isFileEntryPackageable(ZipEntry entry) { <START> String entryName = entry.getName(); <END> return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entryName); }
code_review: don't need this. Just refer to entry.getName() in both places
target code: private boolean isFileEntryPackageable ( ZipEntry entry ) { return ApkBuilder . checkFileForPackaging ( entry . getName ( ) ) && isValidMetaInfEntry ( entry . getName ( ) ) ; }
response: private boolean isFileEntryPackageable(ZipEntry entry) { return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entry.getName()); }

sample: 660
buggy_code: public void testList() { List<VirtualMachine> list = api().list(); <START> for (VirtualMachine machine : list) { <END> assertTrue(!machine.name().isEmpty()); } }
code_review: I'd just assert that it contains the created VM.
target code: public void testList ( ) { List < VirtualMachine > list = api ( ) . list ( ) ; VirtualMachine vm = api ( ) . get ( getName ( ) ) ; assertTrue ( list . contains ( vm ) ) ; }
response: public void testList() { List<VirtualMachine> list = api().list(); <START> for (VirtualMachine machine : list) { <END> assertTrue(!machine.name().isEmpty()); } }

sample: 661
buggy_code: <START> void addLayer(String id, StyleLayer layer) { <END> layersById.put(id, layer); }
code_review: package-private?
target code: public void addLayer ( String id , StyleLayer layer ) { layersById . put ( id , layer ) ; }
response: <START> void addLayer(String id, StyleLayer layer) { <END> layersById.put(id, layer); }

sample: 662
buggy_code: public void setSelection(ITimeGraphEntry trace) { /* if there is a pending selection, ignore this one */ synchronized (fListenerNotifierLock) { <START> if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) { <END> return; } } fSelectedEntry = trace; fTimeGraphCtrl.selectItem(trace, false); adjustVerticalScrollBar(); }
code_review: idem
target code: public void setSelection ( ITimeGraphEntry trace ) { /* if there is a pending selection , ignore this one */ if ( fListenerNotifier != null && fListenerNotifier . hasSelectionChanged ( ) ) { return ; } fSelectedEntry = trace ; fTimeGraphCtrl . selectItem ( trace , false ) ; adjustVerticalScrollBar ( ) ; }
response: public void setSelection(ITimeGraphEntry trace) { /* if there is a pending selection, ignore this one */ synchronized (fListenerNotifierLock) { <START> if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) { <END> return; } } fSelectedEntry = trace; fTimeGraphCtrl.selectItem(trace, false); adjustVerticalScrollBar(); }

sample: 663
buggy_code: private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) { try { <START> return SecurityActions.getConstructor(ClassFile.class, String.class, int.class, String.class, ClassLoader.class, Arrays2.EMPTY_STRING_ARRAY.getClass()) <END> .newInstance(name, accessFlags, superclass, classLoader, interfaces); } catch (Exception e) { throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause()); } }
code_review: Why not use the constructor right away, i.e. without reflection?
target code: private ClassFile newClassFile ( String name , int accessFlags , String superclass , String . . . interfaces ) { try { return new ClassFile ( name , accessFlags , superclass , classLoader , interfaces ) ; } catch ( Exception e ) { throw BeanLogger . LOG . unableToCreateClassFile ( name , e . getCause ( ) ) ; } }
response: private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) { try { <START> return new ClassFile(name, accessFlags, superclass, classLoader, interfaces); <END> } catch (Exception e) { throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause()); } }

sample: 664
buggy_code: public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) { <START> final VirtualClassLoader localClassLoader = ((VirtualClassLoader) getLocalClassLoader(type, id)); <END> return localClassLoader.addListener(classLoaderListener); }
code_review: We can change the return type of getLocalClassLoader only in the implementation to avoid the cast.
target code: public boolean addListener ( String type , long id , ClassLoaderListener classLoaderListener ) { final VirtualClassLoader localClassLoader = getLocalClassLoader ( type , id ) ; return localClassLoader . addListener ( classLoaderListener ) ; }
response: public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) { <START> final VirtualClassLoader localClassLoader = getLocalClassLoader(type, id); <END> return localClassLoader.addListener(classLoaderListener); }

sample: 665
buggy_code: public static final void setPreferenceNodeId (String id) { if (fgPreferenceNodeId == null) { <START> fgPreferenceNodeId = <END> id; } }
code_review: JDT uses compact assignement, e.g. i= 3;
target code: public static final boolean setPreferenceNodeId ( String id ) { if ( fgPreferenceNodeId == null || id == null ) { fgPreferenceNodeId = id ; return true ; } return false ; }
response: public static final void setPreferenceNodeId (String id) { if (fgPreferenceNodeId == null) { <START> fgPreferenceNodeId = id; <END> } }

sample: 666
buggy_code: private void init() { // get the localhost. try { hostname = InetAddress.getLocalHost().getHostName(); <START> hostname = "localhost"; <END> } catch (UnknownHostException e) { logger.warn("Error getting the value of localhost. " + "Proceeding with 'localhost'.", e); } }
code_review: Please remove this. This is probably due to an incorrect /etc/hosts file in your test environment
target code: private void init ( ) { // get the localhost . try { hostname = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { logger . warn ( "Error getting the value of localhost . " + "Proceeding with 'localhost' . " , e ) ; } }
response: private void init() { // get the localhost. try { hostname = InetAddress.getLocalHost().getHostName(); <START> hostname = "localhost"; <END> } catch (UnknownHostException e) { logger.warn("Error getting the value of localhost. " + "Proceeding with 'localhost'.", e); } }

sample: 667
buggy_code: <START> protected OSImageToImage(JustProvider provider) { <END> this.provider = provider; }
code_review: Make it package private by removing the `protected` modifier.
target code: OSImageToImage ( JustProvider provider ) { this . provider = provider ; }
response: <START> OSImageToImage(JustProvider provider) { <END> this.provider = provider; }

sample: 668
buggy_code: private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) { <START> Optional<Cookie> cookie = <END> Arrays.stream(httpClient.getState().getCookies()) .filter(c -> cookieName.equals(c.getName())) .findFirst(); return cookie; }
code_review: return immediately, no need to store it in a local var
target code: private Optional < Cookie > findCookieWithName ( String cookieName , HttpClient httpClient ) { return Arrays . stream ( httpClient . getState ( ) . getCookies ( ) ) . filter ( c - > cookieName . equals ( c . getName ( ) ) ) . findFirst ( ) ; }
response: private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) { <START> return <END> Arrays.stream(httpClient.getState().getCookies()) .filter(c -> cookieName.equals(c.getName())) .findFirst(); }

sample: 669
buggy_code: public void destroy() { // clients must be destroyed before the pools or // you will create a several second busy wait loop for (JettyHttpClient client : clients) { client.close(); } if (pool != null) { pool.close(); pool = null; <START> if(injector.getExistingBinding(Key.get(MBeanExporter.class)) != null) { <END> injector.getInstance(MBeanExporter.class) .unexport(generatedNameOf(QueuedThreadPoolMBean.class) + "_" + name); } } destroyed.set(true); }
code_review: This class is effectively a provider. Instead of doing the export directly, we should bind the JMX export when we bind IO pool and let the export happen the normal way.
target code: public void destroy ( ) { // clients must be destroyed before the pools or // you will create a several second busy wait loop for ( JettyHttpClient client : clients ) { client . close ( ) ; } if ( pool != null ) { pool . close ( ) ; pool = null ; } destroyed . set ( true ) ; }
response: public void destroy() { // clients must be destroyed before the pools or // you will create a several second busy wait loop for (JettyHttpClient client : clients) { client.close(); } if (pool != null) { pool.close(); pool = null; } destroyed.set(true); }

sample: 670
buggy_code: private Set<String> expandRegionalChannelUris(String channelUri) { Set<String> expandedUris = null; if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC1_TXLOG_CHANNEL_URIS; } if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC2_TXLOG_CHANNEL_URIS; } <START> return expandedUris == null ? null : Sets.difference(expandedUris, ImmutableSet.of(channelUri)); <END> }
code_review: you could do the difference and return in inside the if, and save 2 checks.
target code: private Set < String > expandRegionalChannelUris ( String channelUri ) { if ( BBC1_TXLOG_CHANNEL_URIS . contains ( channelUri ) ) { return Sets . difference ( BBC1_TXLOG_CHANNEL_URIS , ImmutableSet . of ( channelUri ) ) ; } else if ( BBC2_TXLOG_CHANNEL_URIS . contains ( channelUri ) ) { return Sets . difference ( BBC2_TXLOG_CHANNEL_URIS , ImmutableSet . of ( channelUri ) ) ; } return null ; }
response: private Set<String> expandRegionalChannelUris(String channelUri) { Set<String> expandedUris = null; if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC1_TXLOG_CHANNEL_URIS; } if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC2_TXLOG_CHANNEL_URIS; } <START> return expandedUris == null ? null : Sets.difference(expandedUris, ImmutableSet.of(channelUri)); <END> }

sample: 671
buggy_code: public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception { String sql = "SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM " + "dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)" + " AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"; testBuilder() .optionSettingQueriesForTestQuery("alter session set `%s` = true", <START> PlannerSettings.STREAMAGG.getOptionName()) <END> .sqlQuery(sql) .unOrdered() .baselineColumns("maxprice") .baselineValues(367190) .baselineValues(316347) .baselineValues(146610) .baselineValues(306996) .baselineValues(235695) .baselineValues(177819) .build().run(); }
code_review: Should "planner.enable_hashagg" be set to **false** ? "planner.enable_streamagg" defaults to **true** anyway.
target code: public void testMultipleBatchesLateral_WithStreamingAgg ( ) throws Exception { String sql = "SELECT t2 . maxprice FROM ( SELECT customer . c_orders AS c_orders FROM " + "dfs . `lateraljoin / multipleFiles / ` customer ) t1 , LATERAL ( SELECT CAST ( MAX ( t . ord . o_totalprice ) " + " AS int ) AS maxprice FROM UNNEST ( t1 . c_orders ) t ( ord ) GROUP BY t . ord . o_orderstatus ) t2" ; testBuilder ( ) . sqlQuery ( sql ) . unOrdered ( ) . baselineColumns ( "maxprice" ) . baselineValues ( 367190 ) . baselineValues ( 316347 ) . baselineValues ( 146610 ) . baselineValues ( 306996 ) . baselineValues ( 235695 ) . baselineValues ( 177819 ) . build ( ) . run ( ) ; }
response: public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception { String sql = "SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM " + "dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)" + " AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"; testBuilder() .optionSettingQueriesForTestQuery("alter session set `%s` = true", PlannerSettings.STREAMAGG.getOptionName()) .sqlQuery(sql) .unOrdered() .baselineColumns("maxprice") .baselineValues(367190) .baselineValues(316347) .baselineValues(146610) .baselineValues(306996) .baselineValues(235695) .baselineValues(177819) .build().run(); }

sample: 672
buggy_code: public boolean isType(String value) { GlusterStatus volStatus = <START> GlusterStatus.valueOf(value); <END> for (GlusterStatus status : values) { if (status.equals(volStatus)) { return true; } } return false; }
code_review: This might throw IllegalArgumentException in case `value` doesn't match any enum constant. It's much easier to compare `value` to name() of enum constants: for (GlusterStatus status : values) { if (status.name().equals(value)) { return true; } } return false;
target code: public boolean isType ( String value ) { for ( GlusterStatus status : values ) { if ( status . name ( ) . equals ( value ) ) { return true ; } } return false ; }
response: public boolean isType(String value) { for (GlusterStatus status : values) { if (status.name().equals(value)) { return true; } } return false; }

sample: 673
buggy_code: public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); <START> ctx.channel().close(); <END> }
code_review: `ctx.close()`
target code: public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { cause . printStackTrace ( ) ; ctx . close ( ) ; }
response: public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); <START> ctx.close(); <END> }

sample: 674
buggy_code: <START> public CloseNoOpServerProtocolHandler(String websocketPath) { <END> super(websocketPath, null, false); }
code_review: remove public
target code: CloseNoOpServerProtocolHandler ( String websocketPath ) { super ( websocketPath , null , false ) ; }
response: <START> CloseNoOpServerProtocolHandler(String websocketPath) { <END> super(websocketPath, null, false); }

sample: 675
buggy_code: public MessageView(Context context, AttributeSet attrs) { super(context, attrs); <START> setOrientation(VERTICAL); <END> }
code_review: Since you are forcing the orientation, it might be a good idea to use the `super.setOrientation()` instead, override the `setOrientation()` method and only print a log or throw an exception if someone tries to mess with it
target code: public MessageView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; super . setOrientation ( VERTICAL ) ; }
response: public MessageView(Context context, AttributeSet attrs) { super(context, attrs); <START> super.setOrientation(VERTICAL); <END> }

sample: 676
buggy_code: public Canvas addShapeIntoView(final Shape shape) { if (shape.getUUID() == null) { shape.setUUID(UUID.uuid()); } <START> shape.getShapeView().setUUID(shape.getUUID()); <END> getView().add(shape.getShapeView()); return this; }
code_review: Shouldn't it be a part of `shape#setUUID` method?
target code: public Canvas addShapeIntoView ( final Shape shape ) { if ( shape . getUUID ( ) == null ) { shape . setUUID ( UUID . uuid ( ) ) ; } getView ( ) . add ( shape . getShapeView ( ) ) ; return this ; }
response: public Canvas addShapeIntoView(final Shape shape) { if (shape.getUUID() == null) { shape.setUUID(UUID.uuid()); } getView().add(shape.getShapeView()); return this; }

sample: 677
buggy_code: public boolean getRequiredParamBoolean(final String key) throws ActionParamsException { <START> final String errMsg = "Required parameter '" + key + "' missing!"; <END> final String val = getRequiredParam(key, errMsg); try { return Boolean.parseBoolean(val); } catch (Exception e) { throw new ActionParamsException(errMsg); } }
code_review: You don't need to give this string (even as other similar do) since it's the default message for getRequiredParam(key).
target code: public boolean getRequiredParamBoolean ( final String key ) throws ActionParamsException { final String val = getRequiredParam ( key ) ; try { return Boolean . parseBoolean ( val ) ; } catch ( Exception e ) { throw new ActionParamsException ( e . getMessage ( ) ) ; } }
response: public boolean getRequiredParamBoolean(final String key) throws ActionParamsException { <START> final String errMsg = "Required parameter '" + key + "' missing!"; <END> final String val = getRequiredParam(key); try { return Boolean.parseBoolean(val); } catch (Exception e) { throw new ActionParamsException(errMsg); } }

sample: 678
buggy_code: public void onPingFromClient(PingFromClientEvent event, EntityRef entity){ <START> if (networkSystem.getMode().isServer()) { <END> Instant end = Instant.now(); endMap.put(entity, end); updatePing(entity); } }
code_review: In the `@ReceiveEvent` annotation and in the `@RegisterSystem` annotation you can specify if a event handler / all event handlers of that class are for a server or client. So you don't need to check the mode of networkSystem.
target code: public void onPingFromClient ( PingFromClientEvent event , EntityRef entity ) { Instant end = Instant . now ( ) ; endMap . put ( entity , end ) ; updatePing ( entity ) ; }
response: public void onPingFromClient(PingFromClientEvent event, EntityRef entity){ Instant end = Instant.now(); endMap.put(entity, end); updatePing(entity); }

sample: 679
buggy_code: public boolean areEqual(MapObject o1, MapObject o2) { if (o1 == null ^ o2 == null) { return false; <START> } else if (o1 == o2) { <END> return true; } else { return o1.id.equals(o2.id); } }
code_review: This block is useless.
target code: public boolean areEqual ( MapObject o1 , MapObject o2 ) { if ( o1 == null ) { return o2 == null ; } else { return o1 . id . equals ( o2 . id ) ; } }
response: public boolean areEqual(MapObject o1, MapObject o2) { if (o1 == null ^ o2 == null) { return false; } else if (o1 == o2) { return true; } else { return o1.id.equals(o2.id); } }

sample: 680
buggy_code: public RedisMetadataStore(RedisConnectionFactory connectionFactory) { Assert.notNull(connectionFactory, "'connectionFactory' must not be null."); this.redisTemplate = new StringRedisTemplate(connectionFactory); <START> this.redisTemplate.afterPropertiesSet(); <END> }
code_review: `StringRedisTemplate` constructor takes care of it.
target code: public RedisMetadataStore ( RedisConnectionFactory connectionFactory ) { Assert . notNull ( connectionFactory , "'connectionFactory' must not be null . " ) ; this . redisTemplate = new StringRedisTemplate ( connectionFactory ) ; }
response: public RedisMetadataStore(RedisConnectionFactory connectionFactory) { Assert.notNull(connectionFactory, "'connectionFactory' must not be null."); this.redisTemplate = new StringRedisTemplate(connectionFactory); <START> this.redisTemplate.afterPropertiesSet(); <END> }

sample: 681
buggy_code: public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId, long txnId, boolean isReadOnly, int hash, boolean isRollback, boolean requiresAck, boolean isRestart, boolean isForReplay) { super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay); m_hash = hash; setBit(ISROLLBACK, isRollback); setBit(REQUIRESACK, requiresAck); setBit(ISRE<START>, isRestart); <START> m_toLeader = false; <END> m_ackRequestedFromSender = true; }
code_review: Can you use the inherited "m_isLeaderToReplica" instead of adding a new "m_toLeader"? The message is either from leader to replica or from MPI to leader?
target code: public CompleteTransactionMessage ( long initiatorHSId , long coordinatorHSId , long txnId , boolean isReadOnly , int hash , boolean isRollback , boolean requiresAck , boolean isRestart , boolean isForReplay ) { super ( initiatorHSId , coordinatorHSId , txnId , 0 , isReadOnly , isForReplay ) ; m_hash = hash ; setBit ( ISROLLBACK , isRollback ) ; setBit ( REQUIRESACK , requiresAck ) ; setBit ( ISRESTART , isRestart ) ; }
response: public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId, long txnId, boolean isReadOnly, int hash, boolean isRollback, boolean requiresAck, boolean isRestart, boolean isForReplay) { super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay); m_hash = hash; setBit(ISROLLBACK, isRollback); setBit(REQUIRESACK, requiresAck); setBit(ISRE<START>, isRestart); <START> m_isLeaderToReplica = false; <END> m_ackRequestedFromSender = true; }

sample: 682
buggy_code: private CuEinvoiceDao getCuEinvoiceDao() { <START> if (ObjectUtils.isNull(null)) { <END> cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class); } return cuEinvoiceDao; }
code_review: This will always return true, did you want cuEinvoiceDao instead of null here
target code: private CuEinvoiceDao getCuEinvoiceDao ( ) { if ( ObjectUtils . isNull ( cuEinvoiceDao ) ) { cuEinvoiceDao = SpringContext . getBean ( CuEinvoiceDaoOjb . class ) ; } return cuEinvoiceDao ; }
response: private CuEinvoiceDao getCuEinvoiceDao() { <START> if (ObjectUtils.isNull(cuEinvoiceDao)) { <END> cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class); } return cuEinvoiceDao; }

sample: 683
buggy_code: <START> public static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) { <END> SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl(Collections.singletonList(expression), Collections.emptyList()); return newEchoTagStatement(expressionList, eosToken); }
code_review: Can we make this method private?
target code: private static EchoTagStatementTree newEchoTagStatement ( ExpressionTree expression , InternalSyntaxToken eosToken ) { SeparatedList < ExpressionTree > expressionList = new SeparatedListImpl < > ( Collections . singletonList ( expression ) , Collections . emptyList ( ) ) ; return newEchoTagStatement ( expressionList , eosToken ) ; }
response: <START> private static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) { <END> SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl(Collections.singletonList(expression), Collections.emptyList()); return newEchoTagStatement(expressionList, eosToken); }

sample: 684
buggy_code: private static TextSummarizer getLocalSummarizer() throws IOException { Collection<? extends TextSummarizer> summarizers = Lookup.getDefault().lookupAll(TextSummarizer.class ); if (!summarizers.isEmpty()) { summarizerToUse = summarizers.iterator().next(); return summarizerToUse; } <START> throw new IOException("No summarizers found"); <END> }
code_review: Perhaps it would be better to return null instead of throwing an exception? Nothing has really gone wrong. And then you wouldn't need that empty catch block.
target code: private static TextSummarizer getLocalSummarizer ( ) { Collection < ? extends TextSummarizer > summarizers = Lookup . getDefault ( ) . lookupAll ( TextSummarizer . class ) ; if ( ! summarizers . isEmpty ( ) ) { summarizerToUse = summarizers . iterator ( ) . next ( ) ; return summarizerToUse ; } return null ; }
response: private static TextSummarizer getLocalSummarizer() throws IOException { Collection<? extends TextSummarizer> summarizers = Lookup.getDefault().lookupAll(TextSummarizer.class ); if (!summarizers.isEmpty()) { summarizerToUse = summarizers.iterator().next(); return summarizerToUse; } <START> return null; <END> }

sample: 685
buggy_code: public void verifyNoVideo() { if(checkIfElementOnPage(mediaNode)) <START> throw new AssertionError("Media Node is still on the page"); <END> else PageObjectLogging.log("verifyNoVideo", "Verified no video is on page", true, driver); }
code_review: could you please put it in brackets to make it easier to read?
target code: public void verifyNoVideo ( ) { if ( checkIfElementOnPage ( mediaNode ) ) { throw new AssertionError ( "Media Node is still on the page" ) ; } else { PageObjectLogging . log ( "verifyNoVideo" , "Verified no video is on page" , true , driver ) ; } }
response: public void verifyNoVideo() { if(checkIfElementOnPage(mediaNode)) { <START> throw new AssertionError("Media Node is still on the page"); <END> } else PageObjectLogging.log("verifyNoVideo", "Verified no video is on page", true, driver); }

sample: 686
buggy_code: private void startOrStopGeoDataListener() { if (requireGeodata) { <START> geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA); <END> } else { geoDataSubscription.unsubscribe(); } }
code_review: Is it save to assign a new subscription here without unsubscribing a potentially existing previous subscription? Or to ask different: Can you guarantee this is not called two times in a row in the activity lifecycle with requireGeodata==true?
target code: private void startOrStopGeoDataListener ( ) { geoDataSubscription . unsubscribe ( ) ; if ( requireGeodata ) { geoDataSubscription = locationUpdater . start ( GeoDirHandler . UPDATE_GEODATA ) ; } }
response: private void startOrStopGeoDataListener() { if (requireGeodata) { <START> geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA); <END> } else { if (geoDataSubscription != null) { geoDataSubscription.unsubscribe(); } } }

sample: 687
buggy_code: ZipFormatter( <START> Formatters formatters, <END> FormatterUtil formatterUtil, HtmlBuilder html) { this.formatters = formatters; this.util = formatterUtil; this.html = html; }
code_review: not needed.
target code: ZipFormatter ( Formatters formatters , FormatterUtil formatterUtil , HtmlBuilder html ) { this . util = formatterUtil ; this . html = html ; }
response: ZipFormatter( Formatters formatters, FormatterUtil formatterUtil, HtmlBuilder html) { this.formatters = formatters; this.util = formatterUtil; this.html = html; }

sample: 688
buggy_code: private boolean clusterHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); return cluster != null && cluster.getArchitecture() != null <START> && ArchitectureType.ppc.getFamily() == cluster.getArchitecture().getFamily(); <END> }
code_review: I think I saw multiple ppc types in the enum: ppc, ppc64, ppcle, ppc64le
target code: private boolean clusterHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; return cluster != null && cluster . getArchitecture ( ) != null && ArchitectureType . ppc == cluster . getArchitecture ( ) . getFamily ( ) ; }
response: private boolean clusterHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); return cluster != null && cluster.getArchitecture() != null <START> && ArchitectureType.ppc.getFamily() == cluster.getArchitecture().getFamily() || ArchitectureType.ppc64.getFamily() == cluster.getArchitecture().getFamily() || ArchitectureType.ppcle.getFamily() == cluster.getArchitecture().getFamily() || ArchitectureType.ppc64le.getFamily() == cluster.getArchitecture().getFamily(); <END> }

sample: 689
buggy_code: <START> protected void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException { <END> if (metaData.isIndexingDisabled()) return; boolean indexExists = indexExists(getIndexName(false, indexExt), conn); if (!indexExists) { String ddl = String.format("CREATE INDEX %s ON %s (%s)", getIndexName(true, indexExt), getTableName(), columnName); if (log.isTraceEnabled()) { log.tracef("Adding index with following DDL: '%s'.", ddl); } executeUpdateSql(conn, ddl); } }
code_review: We can make this private
target code: private void createIndex ( Connection conn , String indexExt , String columnName ) throws PersistenceException { if ( metaData . isIndexingDisabled ( ) ) return ; boolean indexExists = indexExists ( getIndexName ( false , indexExt ) , conn ) ; if ( ! indexExists ) { String ddl = String . format ( "CREATE INDEX % s ON % s ( % s ) " , getIndexName ( true , indexExt ) , getTableName ( ) , columnName ) ; if ( log . isTraceEnabled ( ) ) { log . tracef ( "Adding index with following DDL : ' % s' . " , ddl ) ; } executeUpdateSql ( conn , ddl ) ; } }
response: <START> private void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException { <END> if (metaData.isIndexingDisabled()) return; boolean indexExists = indexExists(getIndexName(false, indexExt), conn); if (!indexExists) { String ddl = String.format("CREATE INDEX %s ON %s (%s)", getIndexName(true, indexExt), getTableName(), columnName); if (log.isTraceEnabled()) { log.tracef("Adding index with following DDL: '%s'.", ddl); } executeUpdateSql(conn, ddl); } }

sample: 690
buggy_code: public Object getValue() { <START> if (value == null) { <END> return null; } else { return value; } }
code_review: This should be simplified to just: >return value;
target code: public Object getValue ( ) { return value ; }
response: public Object getValue() { <START> return value; <END> }

sample: 691
buggy_code: private boolean needProjectionNode (AbstractPlanNode root) { <START> if ( false == root.planNodeClassNeedsProjectionNode()) { <END> return false; } // If there is a complexGroupby at his point, it means that // display columns contain all the order by columns and // does not require another projection node on top of sort node. // If there is a complex aggregation case, the projection plan node is already added // right above the group by plan node. In future, we may inline that projection node. if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) { return false; } if (root instanceof AbstractReceivePlanNode && m_parsedSelect.hasPartitionColumnInGroupby()) { // Top aggregate has been removed, its schema is exactly the same to // its local aggregate node. return false; } return true; }
code_review: `false ==` is a peculiar way to express `!`. BTW, `peculiar` is a polite way to say `wrong`.
target code: private boolean needProjectionNode ( AbstractPlanNode root ) { if ( ! root . planNodeClassNeedsProjectionNode ( ) ) { return false ; } // If there is a complexGroupby at his point , it means that // display columns contain all the order by columns and // does not require another projection node on top of sort node . // If there is a complex aggregation case , the projection plan node is already added // right above the group by plan node . In future , we may inline that projection node . if ( m_parsedSelect . hasComplexGroupby ( ) || m_parsedSelect . hasComplexAgg ( ) ) { return false ; } if ( root instanceof AbstractReceivePlanNode && m_parsedSelect . hasPartitionColumnInGroupby ( ) ) { // Top aggregate has been removed , its schema is exactly the same to // its local aggregate node . return false ; } return true ; }
response: private boolean needProjectionNode (AbstractPlanNode root) { <START> if ( !root.planNodeClassNeedsProjectionNode()) { <END> return false; } // If there is a complexGroupby at his point, it means that // display columns contain all the order by columns and // does not require another projection node on top of sort node. // If there is a complex aggregation case, the projection plan node is already added // right above the group by plan node. In future, we may inline that projection node. if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) { return false; } if (root instanceof AbstractReceivePlanNode && m_parsedSelect.hasPartitionColumnInGroupby()) { // Top aggregate has been removed, its schema is exactly the same to // its local aggregate node. return false; } return true; }

sample: 692
buggy_code: public void isExecutable_HeaderCellSelected() { when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList()); <START> when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Lists.create(selectedCell, selectedCell2)); <END> assertTrue(handler.isExecutable(scenarioGridMock)); }
code_review: just one cell please
target code: public void isExecutable_HeaderCellSelected ( ) { when ( scenarioGridModelMock . getSelectedCells ( ) ) . thenReturn ( Collections . emptyList ( ) ) ; when ( scenarioGridModelMock . getSelectedHeaderCells ( ) ) . thenReturn ( Arrays . asList ( selectedCell , selectedCell2 ) ) ; assertTrue ( handler . isExecutable ( scenarioGridMock ) ) ; }
response: public void isExecutable_HeaderCellSelected() { when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList()); <START> when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Lists.create(selectedCell)); <END> assertTrue(handler.isExecutable(scenarioGridMock)); }

sample: 693
buggy_code: public boolean equals(Object object) { if (object == this) { return true; } if (!(object instanceof XarSecurityRule)) { return false; } XarSecurityRule rhs = (XarSecurityRule) object; return new EqualsBuilder() .append(this.right, rhs.right) .append(this.simple, rhs.simple) <START> .append(this.securityTool, rhs.securityTool) <END> .isEquals(); }
code_review: This is not really relevant IMO. It's not data of that rules, just an internal helper. In practice this is always going to be true anyway since it's a singleton component.
target code: public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof XarSecurityRule ) ) { return false ; } XarSecurityRule rhs = ( XarSecurityRule ) object ; return new EqualsBuilder ( ) . append ( this . right , rhs . right ) . append ( this . simple , rhs . simple ) . isEquals ( ) ; }
response: public boolean equals(Object object) { if (object == this) { return true; } if (!(object instanceof XarSecurityRule)) { return false; } XarSecurityRule rhs = (XarSecurityRule) object; return new EqualsBuilder() .append(this.right, rhs.right) .append(this.simple, rhs.simple) .isEquals(); }

sample: 694
buggy_code: public static boolean containsSearchAnnotations(XClass mappedClass) { <START> List<XClass> hierarchy = ReflectionHelper.createXClassHierarchy( mappedClass ); <END> for ( XClass clazz : hierarchy ) { if ( containsLocalSearchAnnotation( clazz ) ) { return true; } } return false; }
code_review: Any reason why you added `ReflectionHelper.`? Might as well remove it so that we see it's a method of this very class?
target code: public static boolean containsSearchAnnotations ( XClass mappedClass ) { List < XClass > hierarchy = createXClassHierarchy ( mappedClass ) ; for ( XClass clazz : hierarchy ) { if ( containsLocalSearchAnnotation ( clazz ) ) { return true ; } } return false ; }
response: public static boolean containsSearchAnnotations(XClass mappedClass) { <START> List<XClass> hierarchy = createXClassHierarchy( mappedClass ); <END> for ( XClass clazz : hierarchy ) { if ( containsLocalSearchAnnotation( clazz ) ) { return true; } } return false; }

sample: 695
buggy_code: private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) { int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload); assert newUsedCapacity >= 0; <START> return newUsedCapacity <= currentCapacity ? currentCapacity : newUsedCapacity; <END> }
code_review: `Math.max(newUsedCapacity, currentCapacity)` would be a little bit clearer here.
target code: private static int computeNewVectorCapacity ( int usedCapacity , int newPayload , int currentCapacity ) { int newUsedCapacity = BaseAllocator . nextPowerOfTwo ( usedCapacity + newPayload ) ; assert newUsedCapacity >= 0 ; return Math . max ( currentCapacity , newUsedCapacity ) ; }
response: private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) { int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload); assert newUsedCapacity >= 0; <START> return Math.max(newUsedCapacity, currentCapacity); <END> }

sample: 696
buggy_code: private static void cleanShutdown() { log.info("CleanShutdown: Starting Cleanup."); shutdownServer = true; try { CorfuServerNode current = activeServer; if (current != null) { activeServer.close(); } } catch (Throwable th) { log.error("cleanShutdown: failed during shutdown", th); } // Flush the async appender before exiting to prevent the loss of logs <START> LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); <END> loggerContext.stop(); }
code_review: This doesn't help at all, I suspect it can even cause loss of the logs. Logback already have solved the problem, and we have it enabled https://github.com/CorfuDB/CorfuDB/blob/30c8d154f59dfe22d4cc16b94ab9e2c51851c2e5/infrastructure/src/main/resources/logback.prod.xml#L5
target code: private static void cleanShutdown ( ) { log . info ( "CleanShutdown : Starting Cleanup . " ) ; shutdownServer = true ; try { CorfuServerNode current = activeServer ; if ( current != null ) { current . close ( ) ; } } catch ( Throwable th ) { log . error ( "cleanShutdown : failed during shutdown" , th ) ; } // Flush the async appender before exiting to prevent the loss of logs LoggerContext loggerContext = ( LoggerContext ) LoggerFactory . getILoggerFactory ( ) ; loggerContext . stop ( ) ; }
response: private static void cleanShutdown() { log.info("CleanShutdown: Starting Cleanup."); shutdownServer = true; try { CorfuServerNode current = activeServer; if (current != null) { activeServer.close(); } } catch (Throwable th) { log.error("cleanShutdown: failed during shutdown", th); } }

sample: 697
buggy_code: public void preInit(FMLPreInitializationEvent event) { <START> Log.setModLog(event.getModLog()); <END> configDir = new File(event.getModConfigurationDirectory(), "antiqueatlas"); configDir.mkdir(); extTileIdMap = ExtTileIdMap.instance(); extTileConfig = new ExtTileConfig(new File(configDir, "tileids.json")); extTileConfig.load(extTileIdMap); // Assign default values AFTER the config file loads, so that the old saved values are kept: registerVanillaCustomTiles(); checkSaveConfig(); }
code_review: As I said in the last PR (https://github.com/AntiqueAtlasTeam/AntiqueAtlas/pull/205) that did something like this, this should use `LogManager.getLogger(...)`. Honestly, `Log#modLog` should just be changed to ```java private static final Logger LOGGER = LogManager.getLogger(AntiqueAtlasMod.ID); ```
target code: public void preInit ( FMLPreInitializationEvent event ) { configDir = new File ( event . getModConfigurationDirectory ( ) , "antiqueatlas" ) ; configDir . mkdir ( ) ; extTileIdMap = ExtTileIdMap . instance ( ) ; extTileConfig = new ExtTileConfig ( new File ( configDir , "tileids . json" ) ) ; extTileConfig . load ( extTileIdMap ) ; // Assign default values AFTER the config file loads , so that the old saved values are kept : registerVanillaCustomTiles ( ) ; checkSaveConfig ( ) ; }
response: public void preInit(FMLPreInitializationEvent event) { <START> Log.setModLog(LogManager.getLogger(ID)); <END> configDir = new File(event.getModConfigurationDirectory(), "antiqueatlas"); configDir.mkdir(); extTileIdMap = ExtTileIdMap.instance(); extTileConfig = new ExtTileConfig(new File(configDir, "tileids.json")); extTileConfig.load(extTileIdMap); // Assign default values AFTER the config file loads, so that the old saved values are kept: registerVanillaCustomTiles(); checkSaveConfig(); }

sample: 698
buggy_code: public void close() { try { if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) { LOGGER.warn("Finalize on readRaw() returned false for " + this); } <START> if (this.client.isConnected()) <END> this.client.logout(); this.client.disconnect(); } catch (Exception e) { LOGGER.warn("failed to disconnect FTPClient", e); } }
code_review: Checkstyle violation: ``` [ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-integration/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpSession.java:157: 'if' construct must use '{}'s. [NeedBraces] ``` You can verify yourself locally using `gradlew clean :spring-integration-ftp:check`
target code: public void close ( ) { try { if ( this . readingRaw . get ( ) && ! finalizeRaw ( ) && LOGGER . isWarnEnabled ( ) ) { LOGGER . warn ( "Finalize on readRaw ( ) returned false for " + this ) ; } if ( this . client . isConnected ( ) ) { this . client . logout ( ) ; } this . client . disconnect ( ) ; } catch ( Exception e ) { LOGGER . warn ( "failed to disconnect FTPClient" , e ) ; } }
response: public void close() { try { if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) { LOGGER.warn("Finalize on readRaw() returned false for " + this); } <START> if (this.client.isConnected()) { <END> this.client.logout(); this.client.disconnect(); } } catch (Exception e) { LOGGER.warn("failed to disconnect FTPClient", e); } }

sample: 699
buggy_code: protected FileType doGetType() throws Exception { <START> return (this.stat == null) ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER; <END> }
code_review: No extra (clutter) please.
target code: protected FileType doGetType ( ) throws Exception { return this . stat == null ? FileType . IMAGINARY : FileType . FILE_OR_FOLDER ; }
response: protected FileType doGetType() throws Exception { <START> return (this.stat == null) ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER; <END> }

sample: 700
buggy_code: public EquivalentHashMap( int initialCapacity, float loadFactor, Equivalence<K> keyEq, Equivalence<V> valueEq) { int capacity = 1; while (capacity < initialCapacity) capacity <<= 1; this.loadFactor = loadFactor; <START> threshold = (int)(capacity * DEFAULT_LOAD_FACTOR); <END> table = new Node[capacity]; this.keyEq = keyEq; this.valueEq = valueEq; }
code_review: `capacity * loadFactor` maybe?
target code: public EquivalentHashMap ( int initialCapacity , float loadFactor , Equivalence < K > keyEq , Equivalence < V > valueEq ) { int capacity = 1 ; while ( capacity < initialCapacity ) capacity < <= 1 ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; table = new Node [ capacity ] ; this . keyEq = keyEq ; this . valueEq = valueEq ; }
response: public EquivalentHashMap( int initialCapacity, float loadFactor, Equivalence<K> keyEq, Equivalence<V> valueEq) { int capacity = 1; while (capacity < initialCapacity) capacity <<= 1; this.loadFactor = loadFactor; <START> threshold = (int)(capacity * loadFactor); <END> table = new Node[capacity]; this.keyEq = keyEq; this.valueEq = valueEq; }

sample: 701
buggy_code: <START> private void mockSSHClient() { <END> try { doNothing().when(sshclient).connect(); doNothing().when(sshclient).authenticate(); } catch(Exception e) {} }
code_review: just throw the exception upwards..
target code: private void mockSSHClient ( ) { try { doNothing ( ) . when ( sshclient ) . connect ( ) ; doNothing ( ) . when ( sshclient ) . authenticate ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
response: <START> private void mockSSHClient() throws Exception { <END> doNothing().when(sshclient).connect(); doNothing().when(sshclient).authenticate(); }

sample: 702
buggy_code: public static String sanitizeKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeKey(host.getIdentifier(), fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)), vanityUrl.getLanguageId()); }
code_review: ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck)
target code: public static String sanitizeKey ( final Contentlet vanityUrl ) throws DotDataException , DotSecurityException { Host host = hostAPI . find ( vanityUrl . getStringProperty ( VanityUrlContentType . SITE_FIELD_VAR ) , APILocator . systemUser ( ) , false ) ; return sanitizeKey ( host . getIdentifier ( ) , fixURI ( vanityUrl . getStringProperty ( VanityUrlContentType . URI_FIELD_VAR ) ) , vanityUrl . getLanguageId ( ) ) ; }
response: public static String sanitizeKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeKey(host.getIdentifier(), fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)), vanityUrl.getLanguageId()); }

sample: 703
buggy_code: protected void dataTemplateToJsonGenerator(Object data, DataSchema schema, JsonGenerator generator, boolean order) throws IOException { if (order) { JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator); Data.traverse(data, callback); } else { <START> objectToJsonGenerator(data, generator, false); <END> } }
code_review: You can revert this change now.
target code: protected void dataTemplateToJsonGenerator ( Object data , DataSchema schema , JsonGenerator generator , boolean order ) throws IOException { if ( order ) { JacksonTraverseCallback callback = new SchemaOrderTraverseCallback ( schema , generator ) ; Data . traverse ( data , callback ) ; } else { objectToJsonGenerator ( data , generator ) ; } }
response: protected void dataTemplateToJsonGenerator(Object data, DataSchema schema, JsonGenerator generator, boolean order) throws IOException { if (order) { JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator); Data.traverse(data, callback); } else { <START> objectToJsonGenerator(data, generator, false); <END> } }

sample: 704
buggy_code: <START> public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException { <END> ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this); response.setResponseName(getCommandName()); setResponseObject(response); }
code_review: these exceptions are unacceptable (intended pun miserably failed) we are listing clusters, no resource-, allocation-, or any change related exception should ever occur. at most a entity not found kind of thing.
target code: public void execute ( ) throws ServerApiException , ConcurrentOperationException { ListResponse < KubernetesSupportedVersionResponse > response = kubernetesVersionService . listKubernetesSupportedVersions ( this ) ; response . setResponseName ( getCommandName ( ) ) ; setResponseObject ( response ) ; }
response: <START> public void execute() throws ServerApiException { <END> ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this); response.setResponseName(getCommandName()); setResponseObject(response); }

sample: 705
buggy_code: public void loggedInUserPropertyFalseTest() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> configurationService.setProperty("webui.user.assumelogin", false); context.restoreAuthSystemState(); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get("/api/authn/status") .header("X-On-Behalf-Of", eperson.getID())) .andExpect(status().isBadRequest()); context.turnOffAuthorisationSystem(); configurationService.setProperty("webui.user.assumelogin", true); context.restoreAuthSystemState(); }
code_review: the turnOff is not really needed
target code: public void loggedInUserPropertyFalseTest ( ) throws Exception { configurationService . setProperty ( "webui . user . assumelogin" , false ) ; String token = getAuthToken ( admin . getEmail ( ) , password ) ; getClient ( token ) . perform ( get ( " / api / authn / status" ) . header ( "X - On - Behalf - Of" , eperson . getID ( ) ) ) . andExpect ( status ( ) . isBadRequest ( ) ) ; }
response: public void loggedInUserPropertyFalseTest() throws Exception { <START> configurationService.setProperty("webui.user.assumelogin", false); <END> context.restoreAuthSystemState(); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get("/api/authn/status") .header("X-On-Behalf-Of", eperson.getID())) .andExpect(status().isBadRequest()); context.turnOffAuthorisationSystem(); configurationService.setProperty("webui.user.assumelogin", true); context.restoreAuthSystemState(); }

sample: 706
buggy_code: protected void addExtraHeaders(Builder webResource) { if (additionalHeaders != null) { <START> for (String key : additionalHeaders.keySet()) { <END> webResource.header(key, additionalHeaders.get(key)); } } }
code_review: Could use an entrySet.
target code: protected void addExtraHeaders ( Builder webResource ) { if ( additionalHeaders != null ) { for ( Map . Entry < String , List < Object > > entry : additionalHeaders . entrySet ( ) ) { webResource . header ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }
response: protected void addExtraHeaders(Builder webResource) { if (additionalHeaders != null) { <START> for (Map.Entry<String, String> entry : additionalHeaders.entrySet()) { <END> webResource.header(entry.getKey(), entry.getValue()); } } }

sample: 707
buggy_code: private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) { <START> boolean newFragment = false; if (newList.size() > currentList.size()) { newFragment = true; } return newFragment; <END> }
code_review: I think return (newList.size() > currentList.size()) is sufficient
target code: private boolean hasNewFragment ( EList < InteractionFragment > currentList , List < InteractionFragment > newList ) { return ( newList . size ( ) > currentList . size ( ) ) ; }
response: private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) { <START> return (newList.size() > currentList.size()); <END> }

sample: 708
buggy_code: void closeResultSets() throws SQLException { closeResultSets(activeResultSets); <START> <END> if (generatedKeysResultSet != null && !generatedKeysResultSet.isClosed()) { generatedKeysResultSet.internalClose(); } generatedKeysResultSet = null; }
code_review: This is unnecessary as generatedKeysResultSet is added to activeResultSets when created
target code: void closeResultSets ( ) throws SQLException { closeResultSets ( activeResultSets ) ; generatedKeysResultSet = null ; }
response: void closeResultSets() throws SQLException { closeResultSets(activeResultSets); <START> <END> generatedKeysResultSet = null; }

sample: 709
buggy_code: public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader, ResourceLoader resourceLoader) { if (ClassUtils.isPresent("org.apache.jasper.compiler.JspConfig", classLoader)) { try { String resourceName = getResourceName(view, environment); if (resourceLoader.getResource(resourceName).exists()) { return true; } <START> return new File("src/main/webapp", resourceName).exists(); <END> } catch (AccessControlException ex) { return false; } } return false; }
code_review: The scope of this `try` block is broader than necessary. It only needs to contain this line.
target code: public boolean isTemplateAvailable ( String view , Environment environment , ClassLoader classLoader , ResourceLoader resourceLoader ) { if ( ClassUtils . isPresent ( "org . apache . jasper . compiler . JspConfig" , classLoader ) ) { String resourceName = getResourceName ( view , environment ) ; if ( resourceLoader . getResource ( resourceName ) . exists ( ) ) { return true ; } try { return new File ( "src / main / webapp" , resourceName ) . exists ( ) ; } catch ( AccessControlException ex ) { } } return false ; }
response: public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader, ResourceLoader resourceLoader) { if (ClassUtils.isPresent("org.apache.jasper.compiler.JspConfig", classLoader)) { try { String resourceName = getResourceName(view, environment); if (resourceLoader.getResource(resourceName).exists()) { return true; } <START> return new File("src/main/webapp", resourceName).exists(); <END> } catch (AccessControlException ex) { return false; } } return false; }

sample: 710
buggy_code: <START> public Object visit(final AntlrBaseNode node) { <END> return node.accept(this); }
code_review: Why does this return Object instead of T ?
target code: public T visit ( final AntlrBaseNode node ) { return node . accept ( this ) ; }
response: <START> public T visit(final AntlrBaseNode node) { <END> return node.accept(this); }

sample: 711
buggy_code: public static void addDiskToVm(BaseDisk disk, Guid vmId) { DbFacade.getInstance().getBaseDiskDao().save(disk); VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceType.DISK, VmDeviceType.DISK, null, true, false, <START> ""); <END> }
code_review: please remove alias setting (should be encapsulated in addManagedDevice
target code: public static void addDiskToVm ( BaseDisk disk , Guid vmId ) { DbFacade . getInstance ( ) . getBaseDiskDao ( ) . save ( disk ) ; VmDeviceUtils . addManagedDevice ( new VmDeviceId ( disk . getId ( ) , vmId ) , VmDeviceType . DISK , VmDeviceType . DISK , null , true , false ) ; }
response: public static void addDiskToVm(BaseDisk disk, Guid vmId) { DbFacade.getInstance().getBaseDiskDao().save(disk); VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceType.DISK, VmDeviceType.DISK, null, true, false, <START> "" <END> ); }

sample: 712
buggy_code: private static Throwable getConfigFailureException(ITestContext context) { Throwable t = null; for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) { ITestNGMethod m = method.getTestMethod(); if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) { <START> t = method.getTestResult().getThrowable(); <END> break; } } return t; }
code_review: return here
target code: private static Throwable getConfigFailureException ( ITestContext context ) { for ( IInvokedMethod method : context . getSuite ( ) . getAllInvokedMethods ( ) ) { ITestNGMethod m = method . getTestMethod ( ) ; if ( m . isBeforeSuiteConfiguration ( ) && ( ! method . getTestResult ( ) . isSuccess ( ) ) ) { return method . getTestResult ( ) . getThrowable ( ) ; } } return null ; }
response: private static Throwable getConfigFailureException(ITestContext context) { Throwable t = null; for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) { ITestNGMethod m = method.getTestMethod(); if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) { <START> return method.getTestResult().getThrowable(); <END> } } return t; }

sample: 713
buggy_code: protected String toString(Operator operator) { <START> if (Operator.<START>SWITH.equals(operator)) return LIKE; <END> return operator.toString(); }
code_review: I recommend adding `{}` here
target code: protected String toString ( Operator operator ) { if ( Operator . STARTSWITH . equals ( operator ) ) { return LIKE ; } return operator . toString ( ) ; }
response: protected String toString(Operator operator) { <START> if (Operator.<START>SWITH.equals(operator)) { return LIKE; } <END> return operator.toString(); }

sample: 714
buggy_code: <START> static UberDocument toUberDocument(final Object object) { <END> if (object == null) { return null; } if (object instanceof UberDocument) { return (UberDocument) object; } if (object instanceof Iterable) { } else if (object instanceof Map) { } throw new IllegalArgumentException("Don't know how to handle type : " + object.getClass()); }
code_review: This looks like a leftover and it hasn't any usage. Can we remove it?
target code: static UberDocument toUberDocument ( final Object object ) { if ( object == null ) { return null ; } if ( object instanceof UberDocument ) { return ( UberDocument ) object ; } throw new IllegalArgumentException ( "Don't know how to handle type : " + object . getClass ( ) ) ; }
response: <START> static UberDocument toUberDocument(final Object object) { <END> if (object == null) { return null; } if (object instanceof UberDocument) { return (UberDocument) object; } if (object instanceof Iterable) { } else if (object instanceof Map) { } throw new IllegalArgumentException("Don't know how to handle type : " + object.getClass()); } <TEST> UberDocument.toUberDocument(null); </TEST>

sample: 715
buggy_code: <START> public ArgumentSplitter(String arguments) { <END> this.arguments = arguments; }
code_review: There is no point exposing this constructor if there is not even a single public method. All methods are private (except for the static, which does not require a constructor to be used)
target code: private ArgumentSplitter ( String arguments ) { this . arguments = arguments ; }
response: <START> private ArgumentSplitter(String arguments) { <END> this.arguments = arguments; }

sample: 716
buggy_code: public LgoProducts getProducts() { LgoProducts products = null; try { products = this.proxy.getProducts( exchange.getNonceFactory().createValue(), exchange.getSignatureService()); <START> } catch (HttpStatusIOException e) { <END> LgoErrorAdapter.adapt(e); } return products; }
code_review: please improve error handling in accordance to: https://github.com/knowm/XChange/wiki/New-Implementation-Best-Practices#step-7 you should introduce and LgoException that implements HttpStatusExceptionSupport try catch adapt should be done in methods that implement generic interfaces, *Raw methods should throw our the LgoException
target code: public LgoProducts getProducts ( ) throws IOException { return this . proxy . getProducts ( exchange . getNonceFactory ( ) . createValue ( ) , exchange . getSignatureService ( ) ) ; }
response: public LgoProducts getProducts() { LgoProducts products = null; try { products = this.proxy.getProducts( exchange.getNonceFactory().createValue(), exchange.getSignatureService()); <START> } catch (HttpStatusIOException e) { <END> LgoErrorAdapter.adapt(e); } return products; }

sample: 717
buggy_code: protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) { try { Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink); note.setAttachment(attachment); } catch (IOException e) { LOG.error("addAttachmentToNote, unable to create attachment: " + e.getMessage()); String message = MessageFormat.format( configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), <START> KFSConstants.BLANK_SPACE + backupLink.getLinkUrl()); <END> throw new ValidationException(message); } }
code_review: Do you still need to prepend the blank space, now that you're using MessageFormat.format()? If not, then you should be able to simplify this a little further.
target code: protected void addAttachmentToNote ( T document , AccountingXmlDocumentBackupLink backupLink , Note note ) { try { Attachment attachment = accountingXmlDocumentDownloadAttachmentService . createAttachmentFromBackupLink ( document , backupLink ) ; note . setAttachment ( attachment ) ; } catch ( IOException e ) { LOG . error ( "addAttachmentToNote , unable to create attachment : " + e . getMessage ( ) ) ; String message = MessageFormat . format ( configurationService . getPropertyValueAsString ( CuFPKeyConstants . ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD ) , backupLink . getLinkUrl ( ) ) ; throw new ValidationException ( message ) ; } }
response: protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) { try { Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink); note.setAttachment(attachment); } catch (IOException e) { LOG.error("addAttachmentToNote, unable to create attachment: " + e.getMessage()); String message = MessageFormat.format( configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), <START> backupLink.getLinkUrl()); <END> throw new ValidationException(message); } }

sample: 718
buggy_code: public Void getResult() { <START> throw new UnsupportedOperationException(getClass().getName()); <END> }
code_review: This is effectively final class, so just `throw new UnsupportedOperationException()`
target code: public Void getResult ( ) { throw new UnsupportedOperationException ( ) ; }
response: public Void getResult() { <START> throw new UnsupportedOperationException(); <END> }

sample: 719
buggy_code: public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties) { PreferredProperties translatedPreferred = preferredProperties.translate(variable -> { <START> checkArgument(variable instanceof VariableReferenceExpression, "Expect VariableReferenceExpression"); <END> return node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty(); }); return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred)); }
code_review: Please add the actual type, just in case it ever fails
target code: public PlanWithProperties visitUnnest ( UnnestNode node , PreferredProperties preferredProperties ) { PreferredProperties translatedPreferred = preferredProperties . translate ( variable - > node . getReplicateVariables ( ) . contains ( variable ) ? Optional . of ( variable ) : Optional . empty ( ) ) ; return rebaseAndDeriveProperties ( node , planChild ( node , translatedPreferred ) ) ; }
response: public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties) { PreferredProperties translatedPreferred = preferredProperties.translate(variable -> { <START> checkArgument(variable instanceof VariableReferenceExpression, "Expect VariableReferenceExpression"); <END> return node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty(); }); return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred)); }

sample: 720
buggy_code: public ValidationResult isAnyDomainInProcess() { List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId()); for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) { if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) { return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2, <START> String.format("$status %1$s", StorageDomainStatus.Locked)); <END> } } return ValidationResult.VALID; }
code_review: please put the correct status.
target code: public ValidationResult isAnyDomainInProcess ( ) { List < StoragePoolIsoMap > poolIsoMaps = getStoragePoolIsoMapDao ( ) . getAllForStoragePool ( storagePool . getId ( ) ) ; for ( StoragePoolIsoMap domainIsoMap : poolIsoMaps ) { if ( domainIsoMap . getStatus ( ) != null && domainIsoMap . getStatus ( ) . isStorageDomainInProcess ( ) ) { return new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2 , String . format ( "$status % 1$s" , domainIsoMap . getStatus ( ) ) ) ; } } return ValidationResult . VALID ; }
response: public ValidationResult isAnyDomainInProcess() { List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId()); for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) { if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) { return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2, <START> String.format("$status %1$s", domainIsoMap.getStatus())); <END> } } return ValidationResult.VALID; }

sample: 721
buggy_code: <START> private boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName) <END> { if (castToExpression(rowExpression) instanceof FunctionCall) { return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName); } return false; }
code_review: static
target code: private static boolean isFunctionNameMatch ( RowExpression rowExpression , String expectedName ) { if ( castToExpression ( rowExpression ) instanceof FunctionCall ) { return ( ( FunctionCall ) castToExpression ( rowExpression ) ) . getName ( ) . toString ( ) . equalsIgnoreCase ( expectedName ) ; } return false ; }
response: <START> private static boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName) <END> { if (castToExpression(rowExpression) instanceof FunctionCall) { return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName); } return false; }

sample: 722
buggy_code: public boolean hasError() { <START> return result != null && result.getType() != null && CommandResult.Type.ERROR.equals(result.getType()); <END> }
code_review: We can slightly simplify: ```java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType()); ```
target code: public boolean hasError ( ) { return result != null && CommandResult . Type . ERROR . equals ( result . getType ( ) ) ; }
response: public boolean hasError() { <START> return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType()); <END> }

sample: 723
buggy_code: private void setupVdsNetworkInterfaceDao() { when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock); List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface); when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn( <START> expectedVdsNetworkInterface); <END> }
code_review: Why did you have to change the order of the lines here?...
target code: private void setupVdsNetworkInterfaceDao ( ) { List < VdsNetworkInterface > expectedVdsNetworkInterface = Collections . singletonList ( vdsNetworkInterface ) ; when ( vdsNetworkInterfaceDaoMock . getVdsInterfacesByNetworkId ( networkId ) ) . thenReturn ( expectedVdsNetworkInterface ) ; when ( getDbFacadeMockInstance ( ) . getInterfaceDao ( ) ) . thenReturn ( vdsNetworkInterfaceDaoMock ) ; }
response: private void setupVdsNetworkInterfaceDao() { when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock); List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface); when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn( <START> expectedVdsNetworkInterface); <END> }

sample: 724
buggy_code: <START> public void setProject(IProject project) { <END> this.project=project; }
code_review: Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
target code: protected void setProject ( IProject project ) { this . project = project ; }
response: <START> void setProject(IProject project) { <END> this.project=project; }

sample: 725
buggy_code: public List<String> values(String name) { <START> return headers == null ? null : headers.get("Request-Id"); <END> }
code_review: I think this should be `headers.get(name)`.
target code: public List < String > values ( String name ) { return headers == null ? null : headers . get ( name ) ; }
response: public List<String> values(String name) { <START> return headers == null ? null : headers.get(name); <END> }

sample: 726
buggy_code: <START> @Override protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) { <END> Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability(); return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED); }
code_review: dude
target code: protected Pair < Recipients , Boolean > doInBackground ( Recipients . . . recipients ) { Capability textCapability = DirectoryHelper . getUserCapabilities ( context , recipients [ 0 ] ) . getTextCapability ( ) ; return new Pair < > ( recipients [ 0 ] , textCapability == Capability . SUPPORTED ) ; }
response: <START> @Override protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) { <END> Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability(); return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED); }

sample: 727
buggy_code: public void cleanup() { <START> myIdeFrame = <END> null; myNavigationHelper.cleanup(); myNavigationHelper = null; myStateComponent = null; myTaskContext = null; }
code_review: Generally speaking, there's no need to null out the fields of an object if no one is going to hold the reference to the object afterwards. The GC is going to do its job, you don't need to help. :)
target code: public void cleanup ( ) { myNavigationHelper . cleanup ( ) ; }
response: public void cleanup() { <START> myIdeFrame = <END> null; myNavigationHelper.cleanup(); myNavigationHelper = null; }

sample: 728
buggy_code: <START> public static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) { <END> DateTime beginValidTime = beginValidTimeArg; final DateTime now = new DateTime(); if (beginValidTime == null || beginValidTime.isAfter(now)) { beginValidTime = now; } // If provided time is after the given issue instant, // modify it to include the issue instant if (beginValidTime.isAfter(issueInstant)) { if (issueInstant.isAfter(now)) { beginValidTime = now; } } else { beginValidTime = issueInstant; } return beginValidTime; }
code_review: Why is this public?
target code: private static DateTime setBeginValidTime ( DateTime beginValidTimeArg , DateTime issueInstant ) { DateTime beginValidTime = beginValidTimeArg ; final DateTime now = new DateTime ( ) ; if ( beginValidTime == null || beginValidTime . isAfter ( now ) ) { beginValidTime = now ; } // If provided time is after the given issue instant , // modify it to include the issue instant if ( beginValidTime . isAfter ( issueInstant ) ) { if ( issueInstant . isAfter ( now ) ) { beginValidTime = now ; } } else { beginValidTime = issueInstant ; } return beginValidTime ; }
response: <START> public static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) { <END> DateTime beginValidTime = beginValidTimeArg; final DateTime now = new DateTime(); if (beginValidTime == null || beginValidTime.isAfter(now)) { beginValidTime = now; } // If provided time is after the given issue instant, // modify it to include the issue instant if (beginValidTime.isAfter(issueInstant)) { if (issueInstant.isAfter(now)) { beginValidTime = now; } } else { beginValidTime = issueInstant; } return beginValidTime; }

sample: 729
buggy_code: private void <START> setupRestrictedNotification() <END> { final Resources res = getResources(mContext, mActiveDataSubId); final String title = res.getString(R.string.disable_tether_notification_title); final String message = res.getString(R.string.disable_tether_notification_message); showNotification(R.drawable.stat_sys_tether_general, title, message, ""); }
code_review: We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it.
target code: void setupRestrictedNotification ( ) { final Resources res = getResources ( mContext , mActiveDataSubId ) ; final String title = res . getString ( R . string . disable_tether_notification_title ) ; final String message = res . getString ( R . string . disable_tether_notification_message ) ; showNotification ( R . drawable . stat_sys_tether_general , title , message , "" ) ; }
response: private void <START> setupRestrictedNotification() <END> { final Resources res = getResources(mContext, mActiveDataSubId); final String title = res.getString(R.string.disable_tether_notification_title); final String message = res.getString(R.string.disable_tether_notification_message); showNotification(R.drawable.stat_sys_tether_general, title, message, ""); }

sample: 730
buggy_code: <START> private File getFeatureTypeDir( <END> File featureTypesBaseDir, String namespacePrefix, String typeName) { return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName)); }
code_review: Any specific reason to make this method no ``static`` anymore ?
target code: protected File getFeatureTypeDir ( File featureTypesBaseDir , String namespacePrefix , String typeName ) { return new File ( featureTypesBaseDir , getDataStoreName ( namespacePrefix , typeName ) ) ; }
response: <START> private static File getFeatureTypeDir( <END> File featureTypesBaseDir, String namespacePrefix, String typeName) { return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName)); }

sample: 731
buggy_code: public static void setupSystemProperties() { <START> int freePort = TestUtilGit.findFreePort(); <END> System.setProperty("org.uberfire.nio.git.daemon.port", String.valueOf(freePort)); logger.info("Git port used:{}", freePort); //These are not needed for the tests System.setProperty("org.uberfire.nio.git.daemon.enabled", "false"); System.setProperty("org.uberfire.nio.git.ssh.enabled", "false"); System.setProperty("org.uberfire.sys.repo.monitor.disabled", "true"); }
code_review: Just a note about consistency: does it make any sense to find free port and set system property if you're setting `org.uberfire.nio.git.daemon.enabled=false` on the lines below that?
target code: public static void setupSystemProperties ( ) { // These are not needed for the tests System . setProperty ( "org . uberfire . nio . git . daemon . enabled" , "false" ) ; System . setProperty ( "org . uberfire . nio . git . ssh . enabled" , "false" ) ; System . setProperty ( "org . uberfire . sys . repo . monitor . disabled" , "true" ) ; }
response: public static void setupSystemProperties() { <START> int freePort = TestUtilGit.findFreePort(); System.setProperty("org.uberfire.nio.git.daemon.port", String.valueOf(freePort)); logger.info("Git port used:{}", freePort); <END> //These are not needed for the tests System.setProperty("org.uberfire.nio.git.daemon.enabled", "false"); System.setProperty("org.uberfire.nio.git.ssh.enabled", "false"); System.setProperty("org.uberfire.sys.repo.monitor.disabled", "true"); }

sample: 732
buggy_code: public void setPreferredAgencies(String s) { if (s != null && !s.equals("")) <START> preferredAgencies = Sets.newHashSet(s.split(",")); <END> }
code_review: "This method is not actually very useful and will likely be deprecated in the future."
target code: public void setPreferredAgencies ( String s ) { if ( ! s . isEmpty ( ) ) { preferredAgencies = new HashSet < > ( ) ; Collections . addAll ( preferredAgencies , s . split ( " , " ) ) ; } }
response: public void setPreferredAgencies(String s) { if (s != null && !s.equals("")) <START> preferredAgencies = Sets.newHashSet(s.split(",")); <END> }

sample: 733
buggy_code: synchronized void updateSubscribedTopics(final Set<String> topics, final String logPrefix) { <START> log.debug("{}found {} topics possibly matching subscription", logPrefix, topics.size()); <END> subscriptionUpdates.clear(); subscriptionUpdates.addAll(topics); log.debug("{}updating builder with {} topic(s) with possible matching regex subscription(s)", logPrefix, subscriptionUpdates.size()); setRegexMatchedTopicsToSourceNodes(); setRegexMatchedTopicToStateStore(); }
code_review: Thanks for the PR! I just noticed these two log messages are completely redundant; can we remove one of them, or combine into a single log?
target code: synchronized void updateSubscribedTopics ( final Set < String > topics , final String logPrefix ) { log . debug ( " { } found { } topics possibly matching subscription" , logPrefix , topics . size ( ) ) ; subscriptionUpdates . clear ( ) ; subscriptionUpdates . addAll ( topics ) ; setRegexMatchedTopicsToSourceNodes ( ) ; setRegexMatchedTopicToStateStore ( ) ; }
response: synchronized void updateSubscribedTopics(final Set<String> topics, final String logPrefix) { <START> log.debug("{}found {} topics possibly matching subscription", logPrefix, topics.size()); <END> subscriptionUpdates.clear(); subscriptionUpdates.addAll(topics); log.debug("{}updating builder with {} topic(s) with possible matching regex subscription(s)", logPrefix, subscriptionUpdates.size()); setRegexMatchedTopicsToSourceNodes(); setRegexMatchedTopicToStateStore(); }

sample: 734
buggy_code: public void releaseCursor(Cursor cursor) { try { cursor.release(); if (cursors.remove(cursor)) { <START> if (provider.isClosed() && cursors.isEmpty()) { <END> releaseResources(); } } } catch (Exception e) { LOGGER.warn("Exception was found trying to release cursor resources. Execution will continue", e); } finally { statistics.decrementOpenCursors(); } }
code_review: why not put this with an `&&` in the previous `if`?
target code: public void releaseCursor ( Cursor cursor ) { try { cursor . release ( ) ; if ( cursors . remove ( cursor ) && provider . isClosed ( ) && cursors . isEmpty ( ) ) { releaseResources ( ) ; } } catch ( Exception e ) { LOGGER . warn ( "Exception was found trying to release cursor resources . Execution will continue" , e ) ; } finally { statistics . decrementOpenCursors ( ) ; } }
response: public void releaseCursor(Cursor cursor) { try { cursor.release(); if (cursors.remove(cursor)) { <START> if (provider.isClosed()) { <END> releaseResources(); } } } catch (Exception e) { LOGGER.warn("Exception was found trying to release cursor resources. Execution will continue", e); } finally { statistics.decrementOpenCursors(); } }

sample: 735
buggy_code: protected void doStop() { <START> autoEncryptionSupport.close(); <END> super.doStop(); LDAPCache.clear(); }
code_review: Check for null missing?
target code: protected void doStop ( ) { if ( autoEncryptionSupport != null ) { autoEncryptionSupport . close ( ) ; } super . doStop ( ) ; LDAPCache . clear ( ) ; }
response: protected void doStop() { <START> autoEncryptionSupport.close(); <END> super.doStop(); LDAPCache.clear(); }

sample: 736
buggy_code: <START> private Now(A a) { <END> this.a = a; }
code_review: make the constructor package private instead of private to avoid going through a generated synthetic constructor.
target code: Now ( A a ) { this . a = a ; }
response: <START> Now(A a) { <END> this.a = a; }

sample: 737
buggy_code: private String getWorkspaceRelativePath(String sourcePath) { if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains("{")) { return sourcePath; } IPath absolutePath = new Path(sourcePath); IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath); if (container != null) { <START> return container.getFullPath().toPortableString(); <END> } return null; }
code_review: I am not sure that toPortableString() is preferred here to just toString(). IPath.toString() makes only separator '/' for all platforms and it is what we need. Docs say that if toPortableString() is used it has to be matched with fromPortableString() when converting back to Path. toPortableString() doubles all ':' after the one that belongs to the device part (for Windows). For example "c:\one\two:x" will be transformed into "c://one/two::x". If segments have no ':' symbols, then there is no difference from toString(). However if a segment has ':' symbol, fromPortableString() is necessary to restore the original path, even for Linux.
target code: private String getWorkspaceRelativePath ( String sourcePath ) { if ( org . apache . commons . lang . StringUtils . isBlank ( sourcePath ) || sourcePath . contains ( " { " ) ) { return sourcePath ; } IPath absolutePath = new Path ( sourcePath ) ; IContainer container = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getContainerForLocation ( absolutePath ) ; if ( container != null ) { return container . getFullPath ( ) . toString ( ) ; } return null ; }
response: private String getWorkspaceRelativePath(String sourcePath) { if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains("{")) { return sourcePath; } IPath absolutePath = new Path(sourcePath); IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath); if (container != null) { <START> return container.getFullPath().toString(); <END> } return null; }

sample: 738
buggy_code: private void buildErrataDetailPanel() { errataDetailPanel.clear(); errataDetailFormPanel = new GeneralFormPanel(); errataTitle = new Span(); errataTitle.setStyleName(style.errataTitleLabel()); FlowPanel errataTitlePanel = new FlowPanel(); errataTitlePanel.setStyleName(style.errataTitlePanel()); errataTitlePanel.add(errataTitle); errataDetailPanel.add(errataTitlePanel); <START> errataDetailPanel.setStyleName("testtest"); //$NON-NLS-1$ <END> errataDetailPanel.add(errataDetailFormPanel); }
code_review: style name wrong? should use the style.something()?
target code: private void buildErrataDetailPanel ( ) { errataDetailPanel . clear ( ) ; errataDetailFormPanel = new GeneralFormPanel ( ) ; errataTitle = new Span ( ) ; errataTitle . setStyleName ( style . errataTitleLabel ( ) ) ; FlowPanel errataTitlePanel = new FlowPanel ( ) ; errataTitlePanel . setStyleName ( style . errataTitlePanel ( ) ) ; errataTitlePanel . add ( errataTitle ) ; errataDetailPanel . add ( errataTitlePanel ) ; errataDetailPanel . add ( errataDetailFormPanel ) ; }
response: private void buildErrataDetailPanel() { errataDetailPanel.clear(); errataDetailFormPanel = new GeneralFormPanel(); errataTitle = new Span(); errataTitle.setStyleName(style.errataTitleLabel()); FlowPanel errataTitlePanel = new FlowPanel(); errataTitlePanel.setStyleName(style.errataTitlePanel()); errataTitlePanel.add(errataTitle); errataDetailPanel.add(errataTitlePanel); <START> errataDetailPanel.setStyleName(style.errataDetailPanel()); //$NON-NLS-1$ <END> errataDetailPanel.add(errataDetailFormPanel); }

sample: 739
buggy_code: public List<String> getMoreStable(String branch) { int i = order.indexOf(fullName(branch)); if (0 <= i) { <START> return order.subList(i + 1, order.size()); <END> } else { return Collections.emptyList(); } }
code_review: This subList should not be mutable to the caller.
target code: public List < String > getMoreStable ( String branch ) { int i = order . indexOf ( fullName ( branch ) ) ; if ( 0 <= i ) { return order . subList ( i + 1 , order . size ( ) ) ; } else { return ImmutableList . of ( ) ; } }
response: public List<String> getMoreStable(String branch) { int i = order.indexOf(fullName(branch)); if (0 <= i) { <START> return Collections.unmodifiableList(order.subList(i + 1, order.size())); <END> } else { return Collections.emptyList(); } }

sample: 740
buggy_code: public void notifyListeners(int eventType, Event event) { if <START> (this.dropdownTableViewer != <END> null && !this.dropdownTable.isDisposed()) this.dropdownTable.notifyListeners(eventType, event); }
code_review: why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
target code: public void notifyListeners ( int eventType , Event event ) { if ( this . dropdownTable != null && ! this . dropdownTable . isDisposed ( ) ) this . dropdownTable . notifyListeners ( eventType , event ) ; }
response: public void notifyListeners(int eventType, Event event) { if <START> (this.dropdownTable != <END> null && !this.dropdownTable.isDisposed()) this.dropdownTable.notifyListeners(eventType, event); }

sample: 741
buggy_code: public static void setup() throws Exception { <START> assumeTrue("Skipping tests since Hive supports only JDK 8.", HiveTestUtilities.supportedJavaVersion()); <END> startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName()); prepHiveConfAndData(); setSqlStdBasedAuthorizationInHiveConf(); startHiveMetaStore(); startDrillCluster(true); addHiveStoragePlugin(getHivePluginConfig()); addMiniDfsBasedStorage(new HashMap<>()); generateTestData(); }
code_review: Can't we move check to `BaseTestHiveImpersonation` and extend from some common Hive test class?
target code: public static void setup ( ) throws Exception { startMiniDfsCluster ( TestSqlStdBasedAuthorization . class . getSimpleName ( ) ) ; prepHiveConfAndData ( ) ; setSqlStdBasedAuthorizationInHiveConf ( ) ; startHiveMetaStore ( ) ; startDrillCluster ( true ) ; addHiveStoragePlugin ( getHivePluginConfig ( ) ) ; addMiniDfsBasedStorage ( new HashMap < > ( ) ) ; generateTestData ( ) ; }
response: public static void setup() throws Exception { <START> assumeTrue("Skipping tests since Hive supports only JDK 8.", HiveTestUtilities.supportedJavaVersion()); <END> startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName()); prepHiveConfAndData(); setSqlStdBasedAuthorizationInHiveConf(); startHiveMetaStore(); startDrillCluster(true); addHiveStoragePlugin(getHivePluginConfig()); addMiniDfsBasedStorage(new HashMap<>()); generateTestData(); }

sample: 742
buggy_code: public OrderType retireOrderType(OrderType orderType, String reason) { orderType.setRetired(true); <START> orderType.setRetireReason(reason); <END> return dao.saveOrderType(orderType); }
code_review: these fields are already set by AOP in RetireSaveHandler and this needs to delegate to saveOrderType instead of calling the DAO just in case there is extra logic in the save method we don't want to by pass
target code: public OrderType retireOrderType ( OrderType orderType , String reason ) { orderType . setRetired ( true ) ; orderType . setRetireReason ( reason ) ; return saveOrderType ( orderType ) ; }
response: public OrderType retireOrderType(OrderType orderType, String reason) { orderType.setRetired(true); <START> orderType.setRetireReason(reason); <END> return saveOrderType(orderType); }

sample: 743
buggy_code: private void updateFiltersCheckState() { Object[] children = filterContentProvider .getElements(getContentService()); ICommonFilterDescriptor filterDescriptor; INavigatorFilterService filterService = getContentService() .getFilterService(); for (Object <START> element : <END> children) { filterDescriptor = (ICommonFilterDescriptor) element; if(filterService.isActive(filterDescriptor.getId())) { getTableViewer().setChecked(element, true); getCheckedItems().add(element); } else { getTableViewer().setChecked(element, false); } } }
code_review: rename 'child'?
target code: private void updateFiltersCheckState ( ) { ICommonFilterDescriptor filterDescriptor ; INavigatorFilterService filterService = getContentService ( ) . getFilterService ( ) ; for ( Object child : filterContentProvider . getElements ( getContentService ( ) ) ) { filterDescriptor = ( ICommonFilterDescriptor ) child ; if ( filterService . isActive ( filterDescriptor . getId ( ) ) ) { getTableViewer ( ) . setChecked ( child , true ) ; getCheckedItems ( ) . add ( child ) ; } else { getTableViewer ( ) . setChecked ( child , false ) ; } } }
response: private void updateFiltersCheckState() { Object[] children = filterContentProvider .getElements(getContentService()); ICommonFilterDescriptor filterDescriptor; INavigatorFilterService filterService = getContentService() .getFilterService(); for (Object <START> child : <END> children) { filterDescriptor = (ICommonFilterDescriptor) child; if(filterService.isActive(filterDescriptor.getId())) { getTableViewer().setChecked(child, true); getCheckedItems().add(child); } else { getTableViewer().setChecked(child, false); } } }

sample: 744
buggy_code: public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) { // Would prefer to accept zoom levels here (less concepts in our API) // If we accept zoom levels we may be able to reduce, and return a list of FeatureTypeStyles // (with the understanding that the list may be empty if the MBLayer does not contribute any content // at a specific zoom level range) <START> FeatureTypeStyle style = transform(styleContext); <END> for (Rule rule : style.rules()) { if (minScaleDenominator != null) { rule.setMinScaleDenominator(minScaleDenominator); } if (maxScaleDenominator != null) { rule.setMaxScaleDenominator(maxScaleDenominator); } } return style; }
code_review: This may return null if layer visibility = false
target code: public FeatureTypeStyle transform ( MBStyle styleContext , Double minScaleDenominator , Double maxScaleDenominator ) { // Would prefer to accept zoom levels here ( less concepts in our API ) // If we accept zoom levels we may be able to reduce , and return a list of FeatureTypeStyles // ( with the understanding that the list may be empty if the MBLayer does not contribute any content // at a specific zoom level range ) FeatureTypeStyle style = transform ( styleContext ) ; if ( style == null ) { return null ; } for ( Rule rule : style . rules ( ) ) { if ( minScaleDenominator != null ) { rule . setMinScaleDenominator ( minScaleDenominator ) ; } if ( maxScaleDenominator != null ) { rule . setMaxScaleDenominator ( maxScaleDenominator ) ; } } return style ; }
response: public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) { // Would prefer to accept zoom levels here (less concepts in our API) // If we accept zoom levels we may be able to reduce, and return a list of FeatureTypeStyles // (with the understanding that the list may be empty if the MBLayer does not contribute any content // at a specific zoom level range) <START> FeatureTypeStyle style = transform(styleContext); <END> for (Rule rule : style.rules()) { if (minScaleDenominator != null) { rule.setMinScaleDenominator(minScaleDenominator); } if (maxScaleDenominator != null) { rule.setMaxScaleDenominator(maxScaleDenominator); } } return style; } Review: This may return null if layer visibility = false

sample: 745
buggy_code: public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets, Collection<RevCommit> starters) throws MissingObjectException, IncorrectObjectTypeException, IOException { walk.reset(); <START> walk.setRetainBody(false); <END> if (topoSort) { walk.sort(RevSort.TOPO); } for (RevCommit target: targets) { walk.markStart(target); } for (RevCommit starter : starters) { walk.markUninteresting(starter); } return Optional.ofNullable(walk.next()); }
code_review: The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it.
target code: public Optional < RevCommit > areAllReachable ( Collection < RevCommit > targets , Collection < RevCommit > starters ) throws MissingObjectException , IncorrectObjectTypeException , IOException { walk . reset ( ) ; if ( topoSort ) { walk . sort ( RevSort . TOPO ) ; } for ( RevCommit target : targets ) { walk . markStart ( target ) ; } for ( RevCommit starter : starters ) { walk . markUninteresting ( starter ) ; } return Optional . ofNullable ( walk . next ( ) ) ; }
response: public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets, Collection<RevCommit> starters) throws MissingObjectException, IncorrectObjectTypeException, IOException { walk.reset(); if (topoSort) { walk.sort(RevSort.TOPO); } for (RevCommit target: targets) { walk.markStart(target); } for (RevCommit starter : starters) { walk.markUninteresting(starter); } <START> walk.setRetainBody(false); <END> return Optional.ofNullable(walk.next()); }

sample: 746
buggy_code: <START> public Optional<SessionStore<J2EContext>> buildFromTrackableSession(final J2EContext context, final Object trackableSession) { <END> return trackableSession == null ? Optional.empty() : Optional.of(new J2EProvidedSessionStore((HttpSession) trackableSession)); }
code_review: shouldn't trackableSession be an Optional? Either they are both or none are for me actually, I don't think we really need to introduce Optional here, it is the caller that should be careful of not calling this with a null value!
target code: public Optional < SessionStore < J2EContext > > buildFromTrackableSession ( final J2EContext context , final Object trackableSession ) { return trackableSession != null ? Optional . of ( new J2EProvidedSessionStore ( ( HttpSession ) trackableSession ) ) : Optional . empty ( ) ; }
response: <START> public SessionStore<J2EContext> buildFromTrackableSession(final J2EContext context, final Object trackableSession) { <END> return new J2EProvidedSessionStore((HttpSession) trackableSession); }

sample: 747
buggy_code: public Response awaitResponse() throws Exception { <START> return Objects.requireNonNull(remoteFuture).get(); <END> }
code_review: I don't see any advantage of using `requireNonNull()`
target code: public Response awaitResponse ( ) throws Exception { return remoteFuture . get ( ) ; }
response: public Response awaitResponse() throws Exception { <START> return remoteFuture.get(); <END> }

sample: 748
buggy_code: static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) { <START> if (!methodNode.name.equals("<init>")) { <END> return false; } final Type[] argumentTypes = Type.getMethodType(methodNode.desc) .getArgumentTypes(); if (argumentTypes.length < 2) { return false; } return "kotlin.jvm.internal.DefaultConstructorMarker" .equals(argumentTypes[argumentTypes.length - 1].getClassName()); }
code_review: "<init>".equals() is null safe and consistent to the last check in this method.
target code: static boolean isDefaultArgumentsConstructor ( final MethodNode methodNode ) { if ( ! " < init > " . equals ( methodNode . name ) ) { return false ; } final Type [ ] argumentTypes = Type . getMethodType ( methodNode . desc ) . getArgumentTypes ( ) ; if ( argumentTypes . length < 2 ) { return false ; } return "kotlin . jvm . internal . DefaultConstructorMarker" . equals ( argumentTypes [ argumentTypes . length - 1 ] . getClassName ( ) ) ; }
response: static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) { <START> if (!"<init>".equals(methodNode.name)) { <END> return false; } final Type[] argumentTypes = Type.getMethodType(methodNode.desc) .getArgumentTypes(); if (argumentTypes.length < 2) { return false; } return "kotlin.jvm.internal.DefaultConstructorMarker" .equals(argumentTypes[argumentTypes.length - 1].getClassName()); }

sample: 749
buggy_code: public void increment(long amount) { long now = clock.now() / 1000L; <START> if (now != currentSecond.get()) { <END> currentCount.set(0); } long count = currentCount.addAndGet(amount); updatePeak(count); }
code_review: Where is currentSecond being updated?
target code: public void increment ( long amount ) { long now = clock . now ( ) / 1000L ; if ( now != currentSecond . get ( ) ) { currentCount . set ( 0 ) ; currentSecond . set ( now ) ; } long count = currentCount . addAndGet ( amount ) ; updatePeak ( count ) ; }
response: public void increment(long amount) { long now = clock.now() / 1000L; <START> if (now != currentSecond.get()) { currentSecond.set(now); currentCount.set(0); } <END> long count = currentCount.addAndGet(amount); updatePeak(count); }

sample: 750
buggy_code: public static void assertValidSubmodulePath(String path) throws SubmoduleValidationException { if (path.startsWith("-")) { //$NON-NLS-1$ throw new SubmoduleValidationException( MessageFormat.format( JGitText.get().submodulePathInvalid, path), <START> ObjectChecker.ErrorType.GITMODULES_PATH); <END> } }
code_review: Ack
target code: public static void assertValidSubmodulePath ( String path ) throws SubmoduleValidationException { if ( path . startsWith ( " - " ) ) { // $NON - NLS - 1$ throw new SubmoduleValidationException ( MessageFormat . format ( JGitText . get ( ) . submodulePathInvalid , path ) , GITMODULES_PATH ) ; } }
response: public static void assertValidSubmodulePath(String path) throws SubmoduleValidationException { if (path.startsWith("-")) { //$NON-NLS-1$ throw new SubmoduleValidationException( MessageFormat.format( JGitText.get().submodulePathInvalid, path), <START> ObjectChecker.ErrorType.GITMODULES_PATH); <END> }

sample: 751
buggy_code: public String getMessage() { <START> String ret = super.getMessage(); <END> if (pql.isPresent()) { ret += " with pql \"" + pql.get() + "\""; } return ret; }
code_review: `ret` -> `message`
target code: public String getMessage ( ) { String message = super . getMessage ( ) ; if ( pql . isPresent ( ) ) { message += " with pql \"" + pql . get ( ) + "\"" ; } return message ; }
response: public String getMessage() { <START> String message = super.getMessage(); <END> if (pql.isPresent()) { message += " with pql \"" + pql.get() + "\""; } return message; }

sample: 752
buggy_code: protected AbstractGraphDecorator(Graph g) { if (g == null) { <START> throw new NullPointerException("g may not be null."); <END> } this.inner = g; }
code_review: Minor suggestion to change this exception to: ``` throw new IllegalArgumentException("g may not be null."); ```
target code: protected AbstractGraphDecorator ( Graph g ) { if ( g == null ) { throw new IllegalArgumentException ( "g may not be null . " ) ; } this . inner = g ; }
response: protected AbstractGraphDecorator(Graph g) { if (g == null) { <START> throw new IllegalArgumentException("g may not be null."); <END> } this.inner = g; }

sample: 753
buggy_code: public boolean isDTS() { <START> return getCodecA() != null && (getCodecA().startsWith("dts") || "dca".equals(getCodecA()) || "dca (dts)".equals(getCodecA())); <END> }
code_review: `return getCodecA() != null && ("dts".contains(getCodecA()) || "dca".contains(getCodecA()));`
target code: public boolean isDTS ( ) { return getCodecA ( ) != null && ( getCodecA ( ) . contains ( "dts" ) || getCodecA ( ) . contains ( "dca" ) ) ; }
response: public boolean isDTS() { <START> return getCodecA() != null && ("dts".contains(getCodecA()) || "dca".contains(getCodecA())); <END> }

sample: 754
buggy_code: <START> public CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { <END> return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader)); }
code_review: This one shouldn't be public.
target code: CacheCollection < V > values ( EnumSet < Flag > explicitFlags , ClassLoader explicitClassLoader ) { return new ValueCacheCollection < > ( this , cacheEntrySet ( explicitFlags , explicitClassLoader ) ) ; }
response: <START> CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { <END> return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader)); }

sample: 755
buggy_code: public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) { if (percent < 0f) { percent = 0f; } else if (percent > 200f) { percent = 200f; } brightness = percent / 100f; <START> changeShader = true; <END> refreshTextures(); }
code_review: Please, change as discussed.
target code: public synchronized void setBrightnessInUserInterfaceDimensionUnit ( float percent ) { if ( percent < 0f ) { percent = 0f ; } else if ( percent > 200f ) { percent = 200f ; } brightness = percent / 100f ; refreshTextures ( true ) ; }
response: public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) { if (percent < 0f) { percent = 0f; } else if (percent > 200f) { percent = 200f; } brightness = percent / 100f; changeShader = true; refreshTextures(); }

sample: 756
buggy_code: <START> public Handles setForceEndTransactions(boolean forceEndTransactions) { <END> this.forceEndTransactions = forceEndTransactions; return this; }
code_review: This is a backwards incompatible change and cannot be merged.
target code: public void setForceEndTransactions ( boolean forceEndTransactions ) { this . forceEndTransactions = forceEndTransactions ; }
response: <START> public Handles setForceEndTransactions(boolean forceEndTransactions) { <END> this.forceEndTransactions = forceEndTransactions; return this; } <START> public Handles setForceEndTransactions(boolean forceEndTransactions) { <END> this.forceEndTransactions = forceEndTransactions; return this; }

sample: 757
buggy_code: protected Cause createUpstreamCause(Run<?, ?> build) { if(Jenkins.getInstance().getPlugin("promoted-builds") != null) { // Test only when promoted-builds is installed. if(build instanceof Promotion) { Promotion promotion = (Promotion)build; // This cannot be done for PromotionCause#PromotionCause is in a package scope. // return new PromotionCause(build, promotion.getTarget()); return new UpstreamCause((Run<?,?>)promotion.getTarget()); } } <START> return new UpstreamCause((Run) build); <END> }
code_review: You should remove obsolete class casts
target code: protected Cause createUpstreamCause ( Run < ? , ? > build ) { if ( Jenkins . getInstance ( ) . getPlugin ( "promoted - builds" ) != null ) { // Test only when promoted - builds is installed . if ( build instanceof Promotion ) { Promotion promotion = ( Promotion ) build ; // This cannot be done for PromotionCause#PromotionCause is in a package scope . // return new PromotionCause ( build , promotion . getTarget ( ) ) ; return new UpstreamCause ( ( Run < ? , ? > ) promotion . getTarget ( ) ) ; } } return new UpstreamCause ( build ) ; }
response: protected Cause createUpstreamCause(Run<?, ?> build) { if(Jenkins.getInstance().getPlugin("promoted-builds") != null) { // Test only when promoted-builds is installed. if(build instanceof Promotion) { Promotion promotion = (Promotion)build; // This cannot be done for PromotionCause#PromotionCause is in a package scope. // return new PromotionCause(build, promotion.getTarget()); return new UpstreamCause(promotion.getTarget()); } } <START> return new UpstreamCause(build); <END> }

sample: 758
buggy_code: public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) { if (d1 == null) { return d2 == null; } else if (d2 == null) { return false; } <START> return (d1 instanceof Timestamp || d2 instanceof Timestamp) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2); <END> }
code_review: Wouldn't it actually be better to check if instance of Date and then delegate to compare(Date, Date)?
target code: public static < Arg1 , Arg2 extends Arg1 > boolean nullSafeEquals ( Arg1 d1 , Arg2 d2 ) { if ( d1 == null ) { return d2 == null ; } else if ( d2 == null ) { return false ; } return ( d1 instanceof Date && d2 instanceof Date ) ? compare ( ( Date ) d1 , ( Date ) d2 ) == 0 : d1 . equals ( d2 ) ; }
response: public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) { if (d1 == null) { return d2 == null; } else if (d2 == null) { return false; } <START> return (d1 instanceof Date || d2 instanceof Date) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2); <END> }

sample: 759
buggy_code: public boolean equals( Object obj ) { if ( this == obj ) { return true; } if ( obj == null ) { return false; } if ( getClass() != obj.getClass() ) { return false; } final HeapObject other = (HeapObject) obj; if ( node == null ) { return other.node == null; } <START> else return node.equals(other.node); <END> }
code_review: You don't need the `else` clause because the `if` clause does a `return`.
target code: public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final HeapObject other = ( HeapObject ) obj ; if ( node == null ) { return other . node == null ; } return node . equals ( other . node ) ; }
response: public boolean equals( Object obj ) { if ( this == obj ) { return true; } if ( obj == null ) { return false; } if ( getClass() != obj.getClass() ) { return false; } final HeapObject other = (HeapObject) obj; if ( node == null ) { return other.node == null; } <START> return node.equals(other.node); <END> }

sample: 760
buggy_code: public void testSignalIntermediateThrow() throws Exception { KieBase kbase = createKnowledgeBase("BPMN2-IntermediateThrowEventSignal.bpmn2"); ksession = createKnowledgeSession(kbase); Map<String, Object> params = new HashMap<String, Object>(); params.put("x", "MyValue"); ProcessInstance processInstance = ksession.startProcess( "SignalIntermediateEvent", params); <START> Assertions.assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED); <END> }
code_review: I think in this class it is possible.
target code: public void testSignalIntermediateThrow ( ) throws Exception { KieBase kbase = createKnowledgeBase ( "BPMN2 - IntermediateThrowEventSignal . bpmn2" ) ; ksession = createKnowledgeSession ( kbase ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( "x" , "MyValue" ) ; ProcessInstance processInstance = ksession . startProcess ( "SignalIntermediateEvent" , params ) ; assertThat ( processInstance . getState ( ) ) . isEqualTo ( ProcessInstance . STATE_COMPLETED ) ; }
response: public void testSignalIntermediateThrow() throws Exception { KieBase kbase = createKnowledgeBase("BPMN2-IntermediateThrowEventSignal.bpmn2"); ksession = createKnowledgeSession(kbase); Map<String, Object> params = new HashMap<String, Object>(); params.put("x", "MyValue"); ProcessInstance processInstance = ksession.startProcess( "SignalIntermediateEvent", params); <START> Assertions.assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED); <END> }

sample: 761
buggy_code: public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash) { this.maxSize = maxSize; this.hllBuckets = hllBuckets; this.minhash = requireNonNull(minhash, "minhash is null"); hllsTotalEstimatedInMemorySize = 0; hllsTotalEstimatedSerializedSize = 0; <START> for (HyperLogLog hll : minhash.values()) { <END> increaseTotalHllSize(hll); } }
code_review: nit: how about `minhash.values().stream().forEach(this:: increaseTotalHllSize)`?
target code: public KHyperLogLog ( int maxSize , int hllBuckets , Long2ObjectSortedMap < HyperLogLog > minhash ) { this . maxSize = maxSize ; this . hllBuckets = hllBuckets ; this . minhash = requireNonNull ( minhash , "minhash is null" ) ; minhash . values ( ) . forEach ( this : : increaseTotalHllSize ) ; }
response: public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash) { this.maxSize = maxSize; this.hllBuckets = hllBuckets; this.minhash = requireNonNull(minhash, "minhash is null"); hllsTotalEstimatedInMemorySize = 0; hllsTotalEstimatedSerializedSize = 0; <START> minhash.values().stream().forEach(this:: increaseTotalHllSize); <END> }

sample: 762
buggy_code: public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException { <START> final Project.NameKey projectKey = projectCache.get(change.getProject()).getProject().getNameKey(); <END> try { return projectControl.controlFor(projectKey, user).controlFor(change); } catch (NoSuchProjectException e) { throw new NoSuchChangeException(change.getId(), e); } }
code_review: This is dumb. Add a Project.Id form to ProjectControl.GenericFactory and ProjectControl.Factory. That way we only have to perform 1 cache lookup, not 2.
target code: public ChangeControl controlFor ( Change change , CurrentUser user ) throws NoSuchChangeException { try { return projectControl . controlFor ( change . getProject ( ) , user ) . controlFor ( change ) ; } catch ( NoSuchProjectException e ) { throw new NoSuchChangeException ( change . getId ( ) , e ) ; } }
response: public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException { <START> final Project.NameKey projectKey = projectCache.get(change.getProject()).getProject().getNameKey(); <END> try { return projectControl.controlFor(projectKey, user).controlFor(change); } catch (NoSuchProjectException e) { throw new NoSuchChangeException(change.getId(), e); } }

sample: 763
buggy_code: public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (ShareFragmentListener) activity; } catch (ClassCastException e) { <START> throw new ClassCastException(activity.toString() <END> + " must implement OnShareFragmentInteractionListener"); } }
code_review: Should throw ```IllegalStateException``` , or similar.
target code: public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; try { mListener = ( ShareFragmentListener ) activity ; } catch ( IllegalStateException e ) { throw new IllegalStateException ( activity . toString ( ) + " must implement OnShareFragmentInteractionListener" ) ; } }
response: public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (ShareFragmentListener) activity; } catch (ClassCastException e) { <START> throw new IllegalStateException(activity.toString() <END> + " must implement OnShareFragmentInteractionListener"); } }

sample: 764
buggy_code: <START> public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) { <END> if (variables == null || variables.isEmpty()) { return; } Task task = event.getTask(); List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT); AuditTaskImpl auditTaskImpl = createAuditTask(task, event.getEventDate()); sendMessage(new AuditTaskData(auditTaskImpl, null, taskVariables, null), 2); }
code_review: I wonder why we don't emit an event in this case. Another thing is that I think in this case (using JMS) we will update autitTaskImpl in the database, but we currently don't update it in case we use normal JPA LifeCycleListener for tasks. Isn't this a little bit inconsistent? https://github.com/kiegroup/jbpm/blob/25fabbca948df52f69475ca54a8cf85fe09e4074/jbpm-human-task/jbpm-human-task-audit/src/main/java/org/jbpm/services/task/audit/JPATaskLifeCycleEventListener.java#L743-L753 Here we just index and persist variables.
target code: public void afterTaskInputVariableChangedEvent ( TaskEvent event , Map < String , Object > variables ) { if ( variables == null || variables . isEmpty ( ) ) { return ; } Task task = event . getTask ( ) ; List < TaskVariableImpl > taskVariables = indexVariables ( task , variables , VariableType . INPUT ) ; sendMessage ( new AuditTaskData ( null , null , taskVariables , null ) , 2 ) ; }
response: <START> public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) { <END> if (variables == null || variables.isEmpty()) { return; } Task task = event.getTask(); List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT); AuditTaskImpl auditTaskImpl = createAuditTask(task, event.getEventDate()); sendMessage(new AuditTaskData(auditTaskImpl, null, taskVariables, null), 2); }

sample: 765
buggy_code: public RubyGemParser(IFile file) throws IOException, CoreException { mSetupDefinitions = new HashMap<String, ArrayList<Object>>(); mSetupDependencies = new HashMap<String, ArrayList<Object>>(); <START> if (file.getContents().available() <= 0) <END> return; this.file = file; gemVariable = ""; parse(); }
code_review: Remember to put {} around if/else/while/for etc.
target code: public RubyGemParser ( IFile file ) throws IOException , CoreException { mSetupDefinitions = new HashMap < String , ArrayList < String > > ( ) ; mSetupDependencies = new HashMap < String , ArrayList < String > > ( ) ; if ( file . getContents ( ) . available ( ) <= 0 ) { return ; } this . file = file ; gemVariable = "" ; parse ( ) ; }
response: public RubyGemParser(IFile file) throws IOException, CoreException { mSetupDefinitions = new HashMap<String, ArrayList<Object>>(); mSetupDependencies = new HashMap<String, ArrayList<Object>>(); <START> if (file.getContents().available() <= 0) { <END> return; } this.file = file; gemVariable = ""; parse(); }

sample: 766
buggy_code: public boolean canHandle(Message<?> message) { <START> return super.canHandle(message) && deadlineNameMatch((DeadlineMessage) message); <END> }
code_review: I would turn this `&&` around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.
target code: public boolean canHandle ( Message < ? > message ) { return message instanceof DeadlineMessage && deadlineNameMatch ( ( DeadlineMessage ) message ) && super . canHandle ( message ) ; }
response: public boolean canHandle(Message<?> message) { <START> return deadlineNameMatch((DeadlineMessage) message) && super.canHandle(message); <END> }

sample: 767
buggy_code: private void checkImportedSymbol(Symbol symbol) { for (IdentifierTree usageIdentifier : symbol.usages()) { Tree parent = usageIdentifier.parent(); <START> if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) { <END> reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } } }
code_review: This approach won't work if all the classes of a project are in a single root package: ``` package org; import org.B; class A { org.B b; // should be noncompliant } ``` ``` package org; class B { ... } ``` You probably should rather rely on the type of the symbol associated to the identifier of the parent member select, if the parent is a member select. ``` if (parent.is(Kind.MEMBER_SELECT)) { ExpressionTree expression = ((MemberSelectExpressionTree) parent).expression(); if (expression.is(Kind.MEMBER_SELECT) && !((MemberSelectExpressionTree) expression).identifier().symbol().isTypeSymbol()) { return; } reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } ```
target code: private void checkImportedSymbol ( Symbol symbol ) { for ( IdentifierTree usageIdentifier : symbol . usages ( ) ) { Tree parent = usageIdentifier . parent ( ) ; if ( parent . is ( Kind . MEMBER_SELECT ) && ( ( MemberSelectExpressionTree ) parent ) . expression ( ) . is ( Kind . MEMBER_SELECT ) ) { reportIssue ( parent , String . format ( MESSAGE , symbol . name ( ) ) ) ; } } }
response: private void checkImportedSymbol(Symbol symbol) { for (IdentifierTree usageIdentifier : symbol.usages()) { Tree parent = usageIdentifier.parent(); <START> if (parent.is(Kind.MEMBER_SELECT)) { ExpressionTree expression = ((MemberSelectExpressionTree) parent).expression(); if (expression.is(Kind.MEMBER_SELECT) && !((MemberSelectExpressionTree) expression).identifier().symbol().isTypeSymbol()) { return; } reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } <END> } }

sample: 768
buggy_code: public void jmsPort_shouldBeExportedWithCorrectId() throws Exception { <START> if (!featuresService.isInstalled(featuresService.getFeature("openengsb-ports-ws"))) { <END> featuresService.installFeature("openengsb-ports-jms"); } OutgoingPort serviceWithId = OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, "jms-json", 60000); assertNotNull(serviceWithId); }
code_review: maybe, if @ Before doesn't work, create a method setUp for this? since the same code lines are in the beginning of each test of this class
target code: public void jmsPort_shouldBeExportedWithCorrectId ( ) throws Exception { OutgoingPort serviceWithId = OpenEngSBCoreServices . getServiceUtilsService ( ) . getServiceWithId ( OutgoingPort . class , "jms - json" , 60000 ) ; assertNotNull ( serviceWithId ) ; }
response: public void jmsPort_shouldBeExportedWithCorrectId() throws Exception { <START> if (!featuresService.isInstalled(featuresService.getFeature("openengsb-ports-jms"))) { <END> featuresService.installFeature("openengsb-ports-jms"); } OutgoingPort serviceWithId = OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, "jms-json", 60000); assertNotNull(serviceWithId); }

sample: 769
buggy_code: private EventHandler createContextEventHandler() { if (contextEventHandler == null) { contextEventHandler = <START> new EventHandler() { <END> @Override public void handleEvent(Event event) { handleContextSet(event); } }; } return contextEventHandler; }
code_review: we have lambdas for this now.
target code: private EventHandler createContextEventHandler ( ) { if ( contextEventHandler == null ) { contextEventHandler = event - > handleContextSet ( event ) ; } return contextEventHandler ; }
response: private EventHandler createContextEventHandler() { if (contextEventHandler == null) { contextEventHandler = <START> event -> handleContextSet(event) <END>; } return contextEventHandler; }

sample: 770
buggy_code: public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) { <START> super(dex, in); this.dex = dex; <END> }
code_review: Make the "super" dex field protected and remove this one? Or a protected getDexBuffer() method?
target code: public AnnotationValueReader ( @Nonnull DexBuffer dex , @Nonnull ByteInput in ) { super ( dex , in ) ; }
response: public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) { <START> super(dex, in); <END> }

sample: 771
buggy_code: protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) { BlobHolder bh = new SimpleBlobHolder(blob); <START> bh = convertToMimeType(destinationMimeType, bh, new HashMap<String, Serializable>()); <END> if (bh == null) { return null; } Blob result = bh.getBlob(); return result; }
code_review: You can pass `null` instead of `new HashMap<String, Serializable>()`.
target code: protected Blob convertBlobToMimeType ( Blob blob , String destinationMimeType ) { BlobHolder bh = new SimpleBlobHolder ( blob ) ; bh = convertToMimeType ( destinationMimeType , bh , null ) ; return bh == null ? null : bh . getBlob ( ) ; }
response: protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) { BlobHolder bh = new SimpleBlobHolder(blob); <START> bh = convertToMimeType(destinationMimeType, bh, null); <END> if (bh == null) { return null; } Blob result = bh.getBlob(); return result; }

sample: 772
buggy_code: private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() { // Lets not modify the existing collection. Hence creating a new hashset. Set<SupportedAdditionalClusterFeature> featuresSupported = <START> new HashSet<SupportedAdditionalClusterFeature>(getVdsGroup().getAddtionalFeaturesSupported()); <END> featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId())); return featuresSupported; }
code_review: i don't think redeclaring the type on the right side is needed.
target code: private Set < SupportedAdditionalClusterFeature > getAdditionalClusterFeaturesAdded ( ) { // Lets not modify the existing collection . Hence creating a new hashset . Set < SupportedAdditionalClusterFeature > featuresSupported = new HashSet < > ( getVdsGroup ( ) . getAddtionalFeaturesSupported ( ) ) ; featuresSupported . removeAll ( clusterFeatureDao . getSupportedFeaturesByClusterId ( getVdsGroup ( ) . getId ( ) ) ) ; return featuresSupported ; }
response: private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() { // Lets not modify the existing collection. Hence creating a new hashset. Set<SupportedAdditionalClusterFeature> featuresSupported = <START> new HashSet(getVdsGroup().getAddtionalFeaturesSupported()); <END> featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId())); return featuresSupported; }

sample: 773
buggy_code: static void runScript(String filename, Connection cx) throws SQLException { try { SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx); } catch (IOException e) { <START> <END> } }
code_review: Eeek, eatin away exceptions?
target code: static void runScript ( String filename , Connection cx ) throws SQLException { try { SqlUtil . runScript ( new GeoPackage ( ) . getClass ( ) . getResourceAsStream ( filename ) , cx ) ; } catch ( IOException e ) { throw new SQLException ( e ) ; } }
response: static void runScript(String filename, Connection cx) throws SQLException { try { SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx); } catch (IOException e) { throw new RuntimeException(e); } }

sample: 774
buggy_code: public void recycleAttributes(long ts) { <START> fPoolAttributes.entrySet().stream().forEach(e <END> -> { NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts); }); }
code_review: why stream? entrySet is iterable.
target code: public void recycleAttributes ( long ts ) { fPoolAttributes . entrySet ( ) . forEach ( e - > { NonNullUtils . checkNotNull ( e . getKey ( ) ) . recycle ( e . getValue ( ) , ts ) ; } ) ; }
response: public void recycleAttributes(long ts) { <START> for (Entry<AttributePool, List<Attribute>> e : fPoolAttributes.entrySet()) { NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts); } <END> }

sample: 775
buggy_code: public boolean hasNext() { // If we do not have the next element pipelined, go ahead and fetch it. <START> if (next == null) { <END> // If the iterator is valid, this means that the next entry exists. checkInvariants(); if (iterator.isValid()) { // Go ahead and cache that entry. next = new AbstractMap.SimpleEntry( serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime), serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime)); // Advance the underlying iterator. iterator.next(); } else { // If there is no more elements to consume, we should release the resources. iterator.close(); } } return next != null; }
code_review: please invert `if` condition
target code: public boolean hasNext ( ) { // If we have the next element pipelined , go ahead and return true . if ( next != null ) { return true ; } // If the iterator is valid , this means that the next entry exists . checkInvariants ( ) ; if ( iterator . isValid ( ) ) { // Go ahead and cache that entry . next = new AbstractMap . SimpleEntry ( serializer . deserialize ( Unpooled . wrappedBuffer ( iterator . key ( ) ) , corfuRuntime ) , serializer . deserialize ( Unpooled . wrappedBuffer ( iterator . value ( ) ) , corfuRuntime ) ) ; // Advance the underlying iterator . iterator . next ( ) ; } else { // If there is no more elements to consume , we should release the resources . iterator . close ( ) ; } return next != null ; }
response: public boolean hasNext() { // If we do not have the next element pipelined, go ahead and fetch it. <START> if (next != null) { <END> // If the iterator is valid, this means that the next entry exists. checkInvariants(); if (iterator.isValid()) { // Go ahead and cache that entry. next = new AbstractMap.SimpleEntry( serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime), serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime)); // Advance the underlying iterator. iterator.next(); } else { // If there is no more elements to consume, we should release the resources. iterator.close(); } } return next != null; }

sample: 776
buggy_code: public int run() throws IOException { int b; if (in != null) { <START> while ((b = in.read()) != -1) out.write(b); <END> in.close(); } out.close(); return -1; }
code_review: Missing braces
target code: public int run ( ) throws IOException { int b ; if ( in != null ) { while ( ( b = in . read ( ) ) != - 1 ) { out . write ( b ) ; } in . close ( ) ; } out . close ( ) ; return - 1 ; }
response: public int run() throws IOException { int b; if (in != null) { <START> while ((b = in.read()) != -1) { out.write(b); } <END> in.close(); } out.close(); return -1; }

sample: 777
buggy_code: public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException { return (List<Cohort>) sessionFactory.getCurrentSession().createCriteria(Cohort.class) <START> .add(Restrictions.eq("voided", false)) <END> .createAlias("members", "m") .createAlias("m.patientId", "p") .add(Restrictions.eq("p.patientId", patientId)) .list(); }
code_review: Do you have a voided field in this cohort_member table? In theory members don't get removed from the set. You might need to update Cohort.removeMember() to set stop date instead of removing. Which means that getCohortsContainingPatientId() should return cohorts that contain the patient as of the current date i.e members that have no stop date or those where the startDate is before current date and end date is after current date
target code: public List < Cohort > getCohortsContainingPatientId ( Integer patientId ) throws DAOException { return getCohortsContainingPatientId ( patientId , false ) ; }
response: public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException { return (List<Cohort>) sessionFactory.getCurrentSession().createCriteria(Cohort.class) .createAlias("members", "m") .createAlias("m.patientId", "p") .add(Restrictions.eq("p.patientId", patientId)) .list(); }

sample: 778
buggy_code: protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException { try { if (dataSink != null) { tupleWriter.open(dataSink.getOutputStream()); } <START> tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames()); <END> } catch (IOException e) { throw new DbException(e); } }
code_review: How can this succeed if `tupleWriter.open()` isn't called (when `dataSink` is `null`)?
target code: protected void init ( final ImmutableMap < String , Object > execEnvVars ) throws DbException { try { tupleWriter . open ( dataSink . getOutputStream ( ) ) ; tupleWriter . writeColumnHeaders ( getChild ( ) . getSchema ( ) . getColumnNames ( ) ) ; } catch ( IOException e ) { throw new DbException ( e ) ; } }
response: protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException { try { if (dataSink != null) { tupleWriter.open(dataSink.getOutputStream()); } <START> tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames()); <END> } catch (IOException e) { throw new DbException(e); } }

sample: 779
buggy_code: public long getSizeInBytes() { long sizeInBytes = 0; <START> int partitionCount = partitionFunction.getPartitionCount(); <END> for (int i = 0; i < partitionCount; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; }
code_review: use partitionData.length for consistency with getRetainedSizeInBytes ``` public long getSizeInBytes() { long sizeInBytes = 0; for (int i = 0; i < partitionData.length; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; } ```
target code: public long getSizeInBytes ( ) { long sizeInBytes = 0 ; for ( int i = 0 ; i < partitionData . length ; i ++ ) { sizeInBytes += partitionData [ i ] . getSizeInBytes ( ) ; } return sizeInBytes ; }
response: public long getSizeInBytes() { long sizeInBytes = 0; for (int i = 0; i < partitionData.length; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; }

sample: 780
buggy_code: public FixedRealVarImpl(String name, double value, Model model) { <START> super(name, model); this.lb = value; this.ub = value; <END> }
code_review: Replace by `this(name, value, value, model);`
target code: public FixedRealVarImpl ( String name , double value , Model model ) { this ( name , value , value , model ) ; }
response: public FixedRealVarImpl(String name, double value, Model model) { <START> this(name, value, value, model); <END> }

sample: 781
buggy_code: public void isGreaterThan() { assertTrue(V3_0.isGreaterThan(of(2, 0))); assertFalse(V3_0.isGreaterThan(of(3, 0))); assertFalse(V3_0.isGreaterThan(of(4, 0))); assertTrue(V3_0.isGreaterThan(NEGATIVE_VERSION_1)); <START> assertTrue(NEGATIVE_VERSION_1.isGreaterThan(NEGATIVE_VERSION_2)); <END> }
code_review: I'd expect this to be the other way around, when version is a WAN version. I'm thinking about subclassing `Version`. That way we can create `ClusterVersion` and `WanVersion` that can - compare/sort the versions properly, - validate that once we set a cluster version, it can't be replaced by a WAN version (checking the sign bit) and vice-versa. WDYT?
target code: public void isGreaterThan ( ) throws Exception { assertTrue ( V3_0 . isGreaterThan ( of ( 2 , 0 ) ) ) ; assertFalse ( V3_0 . isGreaterThan ( of ( 3 , 0 ) ) ) ; assertFalse ( V3_0 . isGreaterThan ( of ( 4 , 0 ) ) ) ; }
response: public void isGreaterThan() { assertTrue(V3_0.isGreaterThan(of(2, 0))); assertFalse(V3_0.isGreaterThan(of(3, 0))); assertFalse(V3_0.isGreaterThan(of(4, 0))); assertTrue(V3_0.isGreaterThan(NEGATIVE_VERSION_1)); assertTrue(NEGATIVE_VERSION_1.isGreaterThan(NEGATIVE_VERSION_2)); <START> assertFalse(NEGATIVE_VERSION_2.isGreaterThan(NEGATIVE_VERSION_1)); <END> }

sample: 782
buggy_code: private String extractDefinitionLine(String typeDeclaration) { String typeLine = ""; String[] lines = typeDeclaration.split("\n"); for (String line : lines) { typeLine = typeLine + "\n" + line; if (line.contains("{")) { break; } } return typeLine; <START> } <END>
code_review: I think that it is ok, although I am not sure how I feel about including the "\n".
target code: private String extractDefinitionLine ( String typeDeclaration ) { String typeLine = "" ; String [ ] lines = typeDeclaration . split ( "\n" ) ; for ( String line : lines ) { typeLine = line ; if ( line . contains ( " { " ) ) { break ; } } return typeLine ; }
response: private String extractDefinitionLine(String typeDeclaration) { String typeLine = ""; String[] lines = typeDeclaration.split("\n"); for (String line : lines) { typeLine = typeLine + "\n" + line; if (line.contains("{")) { break; } } return typeLine; }

sample: 783
buggy_code: public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) { super(material, renderIndex, slot); setHasSubtypes(true); <START> this.maxStackSize = 64; <END> this.maskType = maskType; ItemRegistry.maskMap.put(maskType, this); }
code_review: stackable armo(u)r?
target code: public ItemAshenMask ( ArmorMaterial material , int renderIndex , EntityEquipmentSlot slot , AshenMasks maskType ) { super ( material , renderIndex , slot ) ; this . maskType = maskType ; ItemRegistry . maskMap . put ( maskType , this ) ; }
response: public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) { super(material, renderIndex, slot); setHasSubtypes(true); <START> this.maxStackSize = 1; <END> this.maskType = maskType; ItemRegistry.maskMap.put(maskType, this); }

sample: 784
buggy_code: private void onSuccess() { <START> if (errorCount.getAndSet(0) >= config.storeIOErrorCountToTriggerShutdown) { <END> logger.info("Resetting the error count of BlobStore {} because restart or one operation succeeded", storeId); } }
code_review: I don't understand the `if` here. If the errorCount() was higher or equal to `config.storeIOErrorCountToTriggerShutdown`, won't the store be shutting/shut down?
target code: private void onSuccess ( ) { errorCount . getAndSet ( 0 ) ; }
response: private void onSuccess() { <START> if (errorCount.getAndSet(0) >= config.storeIOErrorCountToTriggerShutdown) { logger.info("Resetting the error count of BlobStore {} because restart or one operation succeeded", storeId); } <END> }

sample: 785
buggy_code: private ApplicationReportModel createAppDependencyGraphReport(GraphContext context) { <START> ApplicationReportService applicationReportService = new ApplicationReportService(context); <END> ApplicationReportModel report = applicationReportService.create(); report.setReportPriority(104); report.setReportIconClass("glyphicon glyphicon-tree-deciduous"); report.setTemplatePath(TEMPLATE); report.setTemplateType(TemplateType.FREEMARKER); report.setDisplayInApplicationReportIndex(Boolean.TRUE); report.setDescription(REPORT_DESCRIPTION); return report; }
code_review: Perhaps the '104' could be a constant?
target code: private ApplicationReportModel createAppDependencyGraphReport ( GraphContext context ) { ApplicationReportService applicationReportService = new ApplicationReportService ( context ) ; ApplicationReportModel report = applicationReportService . create ( ) ; report . setReportPriority ( 104 ) ; report . setReportIconClass ( "glyphicon glyphicon - tree - deciduous" ) ; report . setTemplatePath ( TEMPLATE ) ; report . setTemplateType ( TemplateType . FREEMARKER ) ; report . setDisplayInApplicationReportIndex ( Boolean . TRUE ) ; return report ; }
response: private ApplicationReportModel createAppDependencyGraphReport(GraphContext context) { <START> ApplicationReportService applicationReportService = new ApplicationReportService(context); <END> ApplicationReportModel report = applicationReportService.create(); report.setReportPriority(104); report.setReportIconClass("glyphicon glyphicon-tree-deciduous"); report.setTemplatePath(TEMPLATE); report.setTemplateType(TemplateType.FREEMARKER); report.setDisplayInApplicationReportIndex(Boolean.TRUE); report.setDescription(REPORT_DESCRIPTION); return report; }

sample: 786
buggy_code: private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException { if (client == null) { LOG.info("Connecting to the ElasticSearch cluster: " + configuration.getClusterName()); if (configuration.getHostAddressesList() != null && !configuration.getHostAddressesList().isEmpty()) { client = createClient(); } else { <START> LOG.info("Incorrect ip address and port parameters settings for ElasticSearch cluster"); <END> } } }
code_review: Should this not be WARN or some exception thrown? Instead of logging that the ip is incorrect. And maybe this validation should be done in the doStart method so its validated earlier
target code: private void startClient ( ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException , UnknownHostException { if ( client == null ) { LOG . info ( "Connecting to the ElasticSearch cluster : " + configuration . getClusterName ( ) ) ; if ( configuration . getHostAddressesList ( ) != null && ! configuration . getHostAddressesList ( ) . isEmpty ( ) ) { client = createClient ( ) ; } else { LOG . warn ( "Incorrect ip address and port parameters settings for ElasticSearch cluster" ) ; } } }
response: private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException { if (client == null) { LOG.info("Connecting to the ElasticSearch cluster: " + configuration.getClusterName()); if (configuration.getHostAddressesList() != null && !configuration.getHostAddressesList().isEmpty()) { client = createClient(); } else { <START> LOG.warn("Incorrect ip address and port parameters settings for ElasticSearch cluster"); <END> } } }

sample: 787
buggy_code: protected String getRemoveQosMessage(int size) { <START> return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(); <END> }
code_review: shouldn't the message get the 'size'?
target code: protected String getRemoveQosMessage ( int size ) { return ConstantsManager . getInstance ( ) . getMessages ( ) . removeStorageQoSMessage ( size ) ; }
response: protected String getRemoveQosMessage(int size) { <START> return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(size); <END> }

sample: 788
buggy_code: public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) { Map<Guid, List<DiskImage>> retVal = new HashMap<>(); <START> images.stream().forEach(image <END> -> MultiValueMapUtils.addToMap(image.getId(), image, retVal)); retVal.values().forEach(ImagesHandler::sortImageList); return retVal; }
code_review: Just use images.forEach
target code: public static Map < Guid , List < DiskImage > > getImagesLeaf ( List < DiskImage > images ) { Map < Guid , List < DiskImage > > retVal = new HashMap < > ( ) ; images . forEach ( image - > MultiValueMapUtils . addToMap ( image . getId ( ) , image , retVal ) ) ; retVal . values ( ) . forEach ( ImagesHandler : : sortImageList ) ; return retVal ; }
response: public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) { Map<Guid, List<DiskImage>> retVal = new HashMap<>(); <START> images.forEach(image <END> -> MultiValueMapUtils.addToMap(image.getId(), image, retVal)); retVal.values().forEach(ImagesHandler::sortImageList); return retVal; }

sample: 789
buggy_code: protected boolean moveToState(STATE to) { if (state.get() == to) { <START> return false; <END> } return moveToState(state.get(), to); }
code_review: What is the contract for the return of this method? If we are already at the state that we are trying to move to, it could be said that the moveToState is successful (i.e. true).
target code: protected void moveToState ( STATE to ) { if ( state . get ( ) != to ) { moveToState ( state . get ( ) , to ) ; } }
response: protected boolean moveToState(STATE to) { if (state.get() == to) { <START> return true; <END> } return moveToState(state.get(), to); }

sample: 790
buggy_code: public void writeTo(Resource file) throws JDOMException, IOException { OutputStream out = path.out(); try { IOUtils.write(body, out); } finally { out.close(); <START> } <END> }
code_review: @NielsCharlier try-with-resources?
target code: public void writeTo ( Resource file ) throws JDOMException , IOException { try ( OutputStream out = path . out ( ) ) { IOUtils . write ( body , out ) ; } }
response: public void writeTo(Resource file) throws JDOMException, IOException { try (OutputStream out = path.out()) { IOUtils.write(body, out); } <START> } <END> }

sample: 791
buggy_code: <START> public ApplicationFetchException(String apiKey, ErrorCode errorCode) { <END> super(); this.apiKey = apiKey; this.errorCode = errorCode; }
code_review: The class is abstract. Constructor should be `protected`
target code: protected ApplicationFetchException ( String apiKey , ErrorCode errorCode ) { super ( ) ; this . apiKey = apiKey ; this . errorCode = errorCode ; }
response: <START> protected ApplicationFetchException(String apiKey, ErrorCode errorCode) { <END> super(); this.apiKey = apiKey; this.errorCode = errorCode; }

sample: 792
buggy_code: private void addResource(final BackendResource resource) { resource.setMessageBundle(messageBundle); resource.setBackend(backend); resource.setSessionHelper(sessionHelper); if (resource instanceof AbstractBackendResource) { ((AbstractBackendResource) resource).setMappingLocator(mappingLocator); } else if (resource instanceof CapabilitiesResource) { ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator); } <START> resource.setValidatorLocator(validatorLocator); <END> singletons.add(resource); }
code_review: using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it, you need to inject it in runtime to every resource.
target code: private void addResource ( final BackendResource resource ) { resource . setMessageBundle ( messageBundle ) ; resource . setBackend ( backend ) ; resource . setSessionHelper ( sessionHelper ) ; if ( resource instanceof AbstractBackendResource ) { ( ( AbstractBackendResource ) resource ) . setMappingLocator ( mappingLocator ) ; } else if ( resource instanceof CapabilitiesResource ) { ( ( BackendCapabilitiesResource ) resource ) . setMappingLocator ( mappingLocator ) ; } singletons . add ( resource ) ; }
response: private void addResource(final BackendResource resource) { resource.setMessageBundle(messageBundle); resource.setBackend(backend); resource.setSessionHelper(sessionHelper); if (resource instanceof AbstractBackendResource) { ((AbstractBackendResource) resource).setMappingLocator(mappingLocator); } else if (resource instanceof CapabilitiesResource) { ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator); } <START> if (resource instanceof AbstractBackendResource) { ((AbstractBackendResource) resource).setValidatorLocator(validatorLocator); } <END> singletons.add(resource); }

sample: 793
buggy_code: public boolean isEmpty() { <START> synchronized (listeners) <END> { return listeners.size() == 0; } }
code_review: listeners is atomic
target code: public boolean isEmpty ( ) { return listeners . isEmpty ( ) ; }
response: public boolean isEmpty() { <START> return listeners.size() == 0; <END> }

sample: 794
buggy_code: void setEnd(int end) { this.end = end; <START> if (this.end > this.maxSeen) <END> { this.maxSeen = this.end; } }
code_review: Here we need to take sequence number wrap around into account. Alternatively, what we could do is unconditionally set the `maxSeen`, and prevent the `maxSeen` from being set if the `end` has been set. However, I don't like adding this kind of logic in the setters. Maybe it'd be better to have a getMaxOrEnd() method.
target code: void setEnd ( int end ) { this . end = end ; }
response: void setEnd(int end) { this.end = end; <START> if (this.end > this.maxSeen || this.end < this.maxSeen - MAX_SEQUENCE_NUMBER / 2) <END> { this.maxSeen = this.end; } }

sample: 795
buggy_code: public void dispose() { //Remove all messages from the queue <START> this.mHandler.removeCallbacksAndMessages(null); <END> this.mHandler = null; this.mPhone = null; }
code_review: > Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
target code: public void dispose ( ) { }
response: public void dispose() { //Remove all messages from the queue <START> this.mHandler.removeCallbacksAndMessages(null); <END> this.mHandler = null; this.mPhone = null; }

sample: 796
buggy_code: public boolean indexShareable() { TypedProperties properties = properties(); boolean hasRamDirectoryProvider = false; boolean hasOtherDirectoryProvider = false; for (Object objKey : properties.keySet()) { String key = (String) objKey; if (key.endsWith(DIRECTORY_PROVIDER_KEY)) { if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) { hasRamDirectoryProvider = true; } else { <START> hasOtherDirectoryProvider = true; <END> } } } boolean ramOnly = hasRamDirectoryProvider && !hasOtherDirectoryProvider; return !ramOnly; }
code_review: a couple of questions: - can't you return true here? - is it possible to configure multiple directory providers?
target code: public boolean indexShareable ( ) { TypedProperties properties = properties ( ) ; boolean hasRamDirectoryProvider = false ; for ( Object objKey : properties . keySet ( ) ) { String key = ( String ) objKey ; if ( key . endsWith ( DIRECTORY_PROVIDER_KEY ) ) { if ( properties . get ( key ) . equals ( RAM_DIRECTORY_PROVIDER ) ) { hasRamDirectoryProvider = true ; } else { return true ; } } } return ! hasRamDirectoryProvider ; }
response: public boolean indexShareable() { TypedProperties properties = properties(); boolean hasRamDirectoryProvider = false; boolean hasOtherDirectoryProvider = false; for (Object objKey : properties.keySet()) { String key = (String) objKey; if (key.endsWith(DIRECTORY_PROVIDER_KEY)) { if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) { hasRamDirectoryProvider = true; } else { <START> return true; <END> } } } boolean ramOnly = hasRamDirectoryProvider && !hasOtherDirectoryProvider; return !ramOnly; }

sample: 797
buggy_code: public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata ) throws TransferException { final Transfer item = getCacheReference( resource ); if ( !resource.allowsDeletion() ) { throw new TransferException( "Deletion not allowed for: {}", resource ); <START> } <END> return doDelete( item, eventMetadata ); }
code_review: move this to the first line of this method for optimization.
target code: public boolean delete ( final ConcreteResource resource , final EventMetadata eventMetadata ) throws TransferException { if ( ! resource . allowsDeletion ( ) ) { throw new TransferException ( "Deletion not allowed for : { } " , resource ) ; } final Transfer item = getCacheReference ( resource ) ; return doDelete ( item , eventMetadata ) ; }
response: public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata ) throws TransferException { final Transfer item = getCacheReference( resource ); if ( !resource.allowsDeletion() ) { <START> throw new TransferException( "Deletion not allowed for: {}", resource ); <END> } return doDelete( item, eventMetadata ); }

sample: 798
buggy_code: public String getActualCpuTopology() { <START> if (actualCpuTopology < 0) { <END> return ConstantsManager.getInstance().getConstants().notAvailableLabel(); } else { return String.valueOf(actualCpuTopology); } }
code_review: when will it be < 0? isnt it better to use Integer that can be null? (like other fields in vm dynamic)
target code: public String getActualCpuTopology ( ) { if ( actualCpuTopology > 0 ) { return String . valueOf ( actualCpuTopology ) ; } else { return ConstantsManager . getInstance ( ) . getConstants ( ) . notAvailableLabel ( ) ; } }
response: public String getActualCpuTopology() { <START> if (actualCpuTopology == null) { <END> return ConstantsManager.getInstance().getConstants().notAvailableLabel(); } else { return String.valueOf(actualCpuTopology); } }

sample: 799
buggy_code: public void onPageScrolled(int i, float v, int i2) { if (pager.getCurrentItem() != 0) { speakerbox.stop(); } if (pager.getCurrentItem() == pagerPositionWhenPaused) { resume.setVisibility(View.GONE); <START> getView().findViewById(R.id.routes).setBackgroundColor(act.getBaseContext() <END> .getResources().getColor(R.color.transparent_white)); } }
code_review: Oh I see now it does get slightly darker when you manually page. It was so subtle I didn't see it at first.
target code: public void onPageScrolled ( int i , float v , int i2 ) { if ( pager . getCurrentItem ( ) != 0 ) { speakerbox . stop ( ) ; } if ( pager . getCurrentItem ( ) == pagerPositionWhenPaused ) { resume . setVisibility ( View . GONE ) ; } }
response: public void onPageScrolled(int i, float v, int i2) { if (pager.getCurrentItem() != 0) { speakerbox.stop(); } if (pager.getCurrentItem() == pagerPositionWhenPaused) { resume.setVisibility(View.GONE); <START> getView().findViewById(R.id.routes).setBackgroundColor(act.getBaseContext().getResources().getColor(R.color.transparent_white)); <END> } }

sample: 800
buggy_code: public void benchWavTrack() throws Exception { WavTrack wavTrack = new WavTrack(url); boolean isEOMReached = false; while (!isEOMReached) { Frame process = wavTrack.process(0); isEOMReached = process.isEOM(); } <START> wavTrack.close(); <END> }
code_review: If an exception can be thrown, then wrap wavTrack.close() in a try-finally block, to guarantee resources are properly closed.
target code: public void benchWavTrack ( ) throws Exception { try { wavTrack = new WavTrack ( url ) ; boolean isEOMReached = false ; while ( ! isEOMReached ) { Frame process = wavTrack . process ( 0 ) ; isEOMReached = process . isEOM ( ) ; } } finally { wavTrack . close ( ) ; } }
response: public void benchWavTrack() throws Exception { WavTrack wavTrack = new WavTrack(url); boolean isEOMReached = false; while (!isEOMReached) { Frame process = wavTrack.process(0); isEOMReached = process.isEOM(); } <START> try { wavTrack.close(); } finally { wavTrack.close(); } <END> }

sample: 801
buggy_code: private static void setupLogger(Map<String, Object> args) throws IOException{ String logfile = (String)args.get("log-file"); Logger logger = Logger.getLogger(""); logger.setLevel((Level)args.get("log-level")); logger.addHandler(new ConsoleHandler()); if(logfile != null) { FileHandler fh = new FileHandler(logfile); fh.setFormatter(new SimpleFormatter()); logger.addHandler(fh); <START> } <END> }
code_review: aren't these already set by logging.properties?
target code: private void setupLogger ( Map < String , Object > args ) throws IOException { Logger logger = Logger . getLogger ( "" ) ; logger . setLevel ( ( Level ) args . get ( "log - level" ) ) ; String logfile = ( String ) args . get ( "log - file" ) ; if ( logfile != null ) { FileHandler fh = new FileHandler ( logfile ) ; fh . setFormatter ( new SimpleFormatter ( ) ) ; logger . addHandler ( fh ) ; } }
response: private static void setupLogger(Map<String, Object> args) throws IOException{ String logfile = (String)args.get("log-file"); Logger logger = Logger.getLogger(""); logger.setLevel((Level)args.get("log-level")); logger.addHandler(new ConsoleHandler()); if(logfile != null) { FileHandler fh = new FileHandler(logfile); fh.setFormatter(new SimpleFormatter()); logger.addHandler(fh); } }

sample: 802
buggy_code: public XWikiAttachment set(XWikiAttachment attachment) { XWikiAttachment put = map.put(attachment.getFilename(), attachment); <START> if (put == null || !put.equals(attachment)) { <END> added(attachment); updatedMap(); } return put; }
code_review: I would use == instead of equals. XWikiAttachment don't implement equals and even if they were is might be super slow (they would have to compare sometime big files contents). Then no need for `put == null` anymore since the input cannot be null.
target code: public XWikiAttachment set ( XWikiAttachment attachment ) { XWikiAttachment put = map . put ( attachment . getFilename ( ) , attachment ) ; if ( put != attachment ) { added ( attachment ) ; updatedMap ( ) ; } return put ; }
response: public XWikiAttachment set(XWikiAttachment attachment) { XWikiAttachment put = map.put(attachment.getFilename(), attachment); <START> if (put != attachment) { <END> added(attachment); updatedMap(); } return put; }

sample: 803
buggy_code: <START> public boolean equals(Object obj) { <END> if (obj instanceof MethodKey) { MethodKey toCompare = (MethodKey) obj; return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes); } return false; }
code_review: final, here and elsewhere
target code: public final boolean equals ( Object obj ) { if ( obj instanceof MethodKey ) { MethodKey toCompare = ( MethodKey ) obj ; return toCompare . name . equals ( name ) && toCompare . parameterTypes . equals ( parameterTypes ) ; } return false ; }
response: <START> public boolean equals(Object obj) { <END> if (obj instanceof MethodKey) { final MethodKey toCompare = (MethodKey) obj; return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes); } return false; }

sample: 804
buggy_code: MongoDBTracing(Builder builder) { tracing = builder.tracing; maxAbbreviatedCommandLength = builder.maxAbbreviatedCommandLength; <START> commandsWithCollectionName = Collections.unmodifiableSet(builder.commandsWithCollectionName); <END> }
code_review: Copy into a new set too, the user will still be able to modify the set through the builder.
target code: MongoDBTracing ( Builder builder ) { tracing = builder . tracing ; }
response: MongoDBTracing(Builder builder) { tracing = builder.tracing; maxAbbreviatedCommandLength = builder.maxAbbreviatedCommandLength; <START> commandsWithCollectionName = Collections.unmodifiableSet(new HashSet<>(builder.commandsWithCollectionName)); <END> }

sample: 805
buggy_code: public void disconnect() { <START> Object lock = partitions != null ? partitions : new Object(); <END> synchronized (lock) { document = null; partitions = null; try { inputStream.close(); } catch (IOException e) { } } }
code_review: this makes no sense. synchronizing on a new object is meaningless. I do not know why partitions must be null, if we want synchronize on this object, we should make it final and never null, instead simply clear() them on dispose
target code: public void disconnect ( ) { Object lock = partitions != null ? partitions : new Object ( ) ; synchronized ( lock ) { document = null ; partitions . clear ( ) ; try { inputStream . close ( ) ; } catch ( IOException e ) { } } }
response: public void disconnect() { <START> Object lock = partitions != null ? partitions : new Object(); <END> synchronized (lock) { document = null; partitions = null; try { inputStream.close(); } catch (IOException e) { } } }

sample: 806
buggy_code: private void printInfo(String sizeMessage, String inAlluxioMessage, String inMemMessage, String path) { <START> System.out.println(inMemMessage.equals("") <END> ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path) : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path)); }
code_review: can use `inMemMessage.isEmpty()`
target code: private void printInfo ( String sizeMessage , String inAlluxioMessage , String inMemMessage , String path ) { System . out . println ( inMemMessage . isEmpty ( ) ? String . format ( SHORT_INFO_FORMAT , sizeMessage , inAlluxioMessage , path ) : String . format ( LONG_INFO_FORMAT , sizeMessage , inAlluxioMessage , inMemMessage , path ) ) ; }
response: private void printInfo(String sizeMessage, String inAlluxioMessage, String inMemMessage, String path) { <START> System.out.println(inMemMessage.isEmpty() <END> ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path) : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path)); }

sample: 807
buggy_code: public void tearDown() { // Destroy JMX beans created during testing. <START> MetricsService metricsService = new MetricsService(nodeEngineMock, () -> metricsRegistry); <END> metricsService.init(nodeEngineMock, new Properties()); metricsService.shutdown(true); JmxLeakHelper.checkJmxBeans(); // Stop executor service. if (executionService != null) { executionService.shutdown(); } }
code_review: I think alternatively we can move out the construction of the service from the test cases into a factory method that sets a shutdown function object field that we can call in the tearDown. This may prevent some other unwanted potential side-effects. With this approach we construct two services, but shutdown only one. For example, the service submits a scheduled task. I think it is fine for now, but it would be safer with the function proposed.
target code: public void tearDown ( ) { // Destroy JMX beans created during testing . if ( metricsService != null ) { metricsService . shutdown ( true ) ; metricsService = null ; } JmxLeakHelper . checkJmxBeans ( ) ; // Stop executor service . if ( executionService != null ) { executionService . shutdown ( ) ; } }
response: public void tearDown() { // Destroy JMX beans created during testing. <START> MetricsService metricsService = new MetricsService(nodeEngineMock, () -> metricsRegistry); <END> metricsService.init(nodeEngineMock, new Properties()); metricsService.shutdown(true); JmxLeakHelper.checkJmxBeans(); // Stop executor service. if (executionService != null) { executionService.shutdown(); } }

sample: 808
buggy_code: public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) { WebElement element = getWebElement(slotName); <START> boolean isMobile = src.toUpperCase().equals("MOBILE"); <END> Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile)); PageObjectLogging.log("verifyAdImage", "Ad looks good", true, driver); return this; }
code_review: swap the left and right for the equals to avoid NullPointerException also, use equalsIgnoreCase instead ``` "MOBILE".equalsIgnoreCase(src); ```
target code: public AdsBaseObject verifyAdImage ( String slotName , String src , String imageUrl ) { WebElement element = getWebElement ( slotName ) ; boolean isMobile = "MOBILE" . equalsIgnoreCase ( src ) ; Assertion . assertTrue ( new AdsComparison ( ) . compareImageWithScreenshot ( imageUrl , element , driver , isMobile ) ) ; PageObjectLogging . log ( "verifyAdImage" , "Ad looks good" , true , driver ) ; return this ; }
response: public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) { WebElement element = getWebElement(slotName); <START> boolean isMobile = "MOBILE".equalsIgnoreCase(src); <END> Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile)); PageObjectLogging.log("verifyAdImage", "Ad looks good", true, driver); return this; }

sample: 809
buggy_code: <START> public Set<String> getUnmatchedLabels() { <END> return Collections.unmodifiableSet(unmatchedLabels); }
code_review: Missing synchronization?
target code: public synchronized Set < String > getUnmatchedLabels ( ) { return Collections . unmodifiableSet ( unmatchedLabels ) ; }
response: <START> public Set<String> getUnmatchedLabels() { synchronized (unmatchedLabels) { <END> return Collections.unmodifiableSet(unmatchedLabels); } }

sample: 810
buggy_code: public void scanForRepoChanges() throws IOException { refs.refresh(); <START> getAllRefs(); // This will look for changes to refs <END> if (!isBare()) getIndex(); // This will detect changes in the index }
code_review: This shouldn't be necessary anymore. RefDirectory.refresh() should trigger an event listener if one or more refs was detected to be modified, which means we can drop the getAllRefs() call here.
target code: public void scanForRepoChanges ( ) throws IOException { getAllRefs ( ) ; // This will look for changes to refs if ( ! isBare ( ) ) getIndex ( ) ; // This will detect changes in the index }
response: public void scanForRepoChanges() throws IOException { refs.refresh(); <START> if (!isBare()) getIndex(); // This will detect changes in the index <END> }

sample: 811
buggy_code: public List<Server> getReachableServers() { <START> return getServerList(true); <END> }
code_review: In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.
target code: public List < Server > getReachableServers ( ) { return null ; }
response: public List<Server> getReachableServers() { <START> return getServerList(true); <END> }

sample: 812
buggy_code: protected Guid getStoragePoolId() { <START> return getDbFacade().getStoragePoolDao().getAllForStorageDomain(getStorageDomainId()).get(0).getId(); <END> }
code_review: Might throw an IndexOutOfBound if no the storage domain is not attached to any storage pool
target code: protected Guid getStoragePoolId ( ) { return getParameters ( ) . getStoragePoolId ( ) ; }
response: protected Guid getStoragePoolId() { <START> return getDbFacade().getStoragePoolDao().getAllForStorageDomain(getStorageDomainId()).get(0).getId(); <END> }

sample: 813
buggy_code: <START> private Integer prerequirementImgResource(String group) { <END> if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) { return R.drawable.rank_prerequirement; } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) { return R.drawable.group_prerequirement; } else { return R.drawable.empty; } }
code_review: Why returning Integer instead of plain int?
target code: private int prerequirementImgResource ( String group ) { if ( group . equalsIgnoreCase ( AssignmentPrerequirement . RANK . toString ( ) ) ) { return R . drawable . rank_prerequirement ; } else if ( group . equalsIgnoreCase ( AssignmentPrerequirement . MISSION . toString ( ) ) ) { return R . drawable . group_prerequirement ; } else { return R . drawable . empty ; } }
response: <START> private int prerequirementImgResource(String group) { <END> if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) { return R.drawable.rank_prerequirement; } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) { return R.drawable.group_prerequirement; } else { return R.drawable.empty; } }

sample: 814
buggy_code: public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException { checkBounds(pImageIndex); // TODO: Better implementation, include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB <START> return Collections.singletonList(getRawImageType(pImageIndex)).iterator(); <END> }
code_review: The TODO above the changed line indicates the reason for using a multi value list here... But of course, we could change this until we actually return multiple values.
target code: public Iterator < ImageTypeSpecifier > getImageTypes ( int pImageIndex ) throws IOException { checkBounds ( pImageIndex ) ; // TODO : Better implementation , include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB return Arrays . asList ( getRawImageType ( pImageIndex ) ) . iterator ( ) ; }
response: public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException { checkBounds(pImageIndex); // TODO: Better implementation, include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB <START> return Arrays.asList(getRawImageType(pImageIndex)).iterator(); <END> }

sample: 815
buggy_code: <START> public void resetPositions(int positionCount) <END> { positions = ensureCapacity(positions, positionCount); this.positionCount = 0; }
code_review: For better readability i would sort the methods in the way they are used `resetPositions` -> `addPosition` -> `appendData` -> `flush`. Please also order the private methods accordingly: Method that uses a private method - > private method
target code: private void resetPositions ( int positionCount ) { positions = ensureCapacity ( positions , positionCount ) ; this . positionCount = 0 ; }
response: <START> public void resetPositions(int positionCount) <END> { positions = ensureCapacity(positions, positionCount); this.positionCount = 0; }

sample: 816
buggy_code: public static SelectorHandler getHandler(final String selectorStr) { if (!selectorStr.isEmpty()) <START> for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet()) <END> if (selectorStr.startsWith(handler.getKey())) return handler.getValue(); return vanillaHandler; }
code_review: Why `selectorStr.substring(0, 1)`
target code: public static SelectorHandler getHandler ( final String selectorStr ) { if ( ! selectorStr . isEmpty ( ) ) { for ( final Entry < String , SelectorHandler > handler : selectorHandlers . subMap ( selectorStr , true , selectorStr . substring ( 0 , 1 ) , true ) . entrySet ( ) ) { if ( selectorStr . startsWith ( handler . getKey ( ) ) ) { return handler . getValue ( ) ; } } } return vanillaHandler ; }
response: public static SelectorHandler getHandler(final String selectorStr) { if (!selectorStr.isEmpty()) <START> for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet()) <END> if (selectorStr.startsWith(handler.getKey())) return handler.getValue(); return vanillaHandler; }

sample: 817
buggy_code: public synchronized void close() { if (closed) { return; } closed = true; <START> if (parentMemoryContext != null) { <END> parentMemoryContext.updateBytes(-usedBytes); } usedBytes = 0; }
code_review: This `if` is redundant. Question for you, @nezihyigitbasi: Do you see IntelliJ "warning"s for this? If not, you should turn those on.
target code: public synchronized void close ( ) { if ( closed ) { return ; } closed = true ; parentMemoryContext . updateBytes ( - usedBytes ) ; usedBytes = 0 ; }
response: public synchronized void close() { if (closed) { return; } closed = true; <START> if (parentMemoryContext != null) { parentMemoryContext.updateBytes(-usedBytes); } <END> usedBytes = 0; }

sample: 818
buggy_code: <START> public Map<K, V> getEntries() { <END> return (Map<K, V>) entries; }
code_review: Change seems unneeded. And actually the unchecked can be removed as well.
target code: public Map < ? extends K , ? extends V > getEntries ( ) { return entries ; }
response: <START> public Map<K, V> getEntries() { <END> return entries; }

sample: 819
buggy_code: public void testDefaultConfig() throws Exception { Files.write(springTestFile.toPath(), "modification".getBytes(), StandardOpenOption.SYNC); // Adding few millis to avoid fleaky tests // The file hasher could sometimes evaluate these two changes as duplicate, as the second modification of file could be done before hashing is done Thread.sleep(50); Files.write(springTestFile.toPath(), "modification 2".getBytes(), StandardOpenOption.SYNC); MockEndpoint mock = getMockEndpoint("mock:springTest"); <START> mock.setExpectedCount(1); // The same with testCustomHasher, that second MODIFY event is discarded <END> mock.setResultWaitTime(1000); mock.assertIsSatisfied(); }
code_review: Why are you changing expectation, when no related production code changed? There should be really two events (`modification` and `modification 2`) Please note that this test is platform dependent. We are targetting to Linux and CI reports no issues or flakes with this test. Which OS are you running tests? Last CI build is here: https://builds.apache.org/view/C/view/Apache%20Camel/job/Camel/job/master/1533/consoleFull
target code: public void testDefaultConfig ( ) throws Exception { Files . write ( springTestFile . toPath ( ) , "modification" . getBytes ( ) , StandardOpenOption . SYNC ) ; // Adding few millis to avoid fleaky tests // The file hasher could sometimes evaluate these two changes as duplicate , as the second modification of file could be done before hashing is done Thread . sleep ( 50 ) ; Files . write ( springTestFile . toPath ( ) , "modification 2" . getBytes ( ) , StandardOpenOption . SYNC ) ; MockEndpoint mock = getMockEndpoint ( "mock : springTest" ) ; mock . setExpectedCount ( 2 ) ; // two MODIFY events mock . setResultWaitTime ( 1000 ) ; mock . assertIsSatisfied ( ) ; }
response: public void testDefaultConfig() throws Exception { Files.write(springTestFile.toPath(), "modification".getBytes(), StandardOpenOption.SYNC); // Adding few millis to avoid fleaky tests // The file hasher could sometimes evaluate these two changes as duplicate, as the second modification of file could be done before hashing is done Thread.sleep(50); Files.write(springTestFile.toPath(), "modification 2".getBytes(), StandardOpenOption.SYNC); MockEndpoint mock = getMockEndpoint("mock:springTest"); mock.setExpectedCount(1); // The same with testCustomHasher, that second MODIFY event is discarded mock.setResultWaitTime(1000); mock.assertIsSatisfied(); }

sample: 820
buggy_code: private boolean startsOrEndsWithWhitespace(String value) { boolean startsOrEndsWithWhitespace = false; <START> if (value != null && StringUtils.isNotBlank(value)) { <END> int lastIndex = value.length() - 1; if (Character.isSpaceChar(value.charAt(0))) { startsOrEndsWithWhitespace = true; } else if (Character.isSpaceChar(value.charAt(lastIndex))) { startsOrEndsWithWhitespace = true; } } else { startsOrEndsWithWhitespace = false; } return startsOrEndsWithWhitespace; }
code_review: Isn't isNotBlank already checking for null?
target code: private boolean startsOrEndsWithWhitespace ( String value ) { return ( StringUtils . isNotBlank ( value ) && ( Character . isSpaceChar ( value . charAt ( 0 ) ) || Character . isSpaceChar ( value . charAt ( value . length ( ) - 1 ) ) ) ) ; }
response: private boolean startsOrEndsWithWhitespace(String value) { boolean startsOrEndsWithWhitespace = false; <START> if (StringUtils.isNotBlank(value)) { <END> int lastIndex = value.length() - 1; if (Character.isSpaceChar(value.charAt(0))) { startsOrEndsWithWhitespace = true; } else if (Character.isSpaceChar(value.charAt(lastIndex))) { startsOrEndsWithWhitespace = true; } } else { startsOrEndsWithWhitespace = false; } return startsOrEndsWithWhitespace; }

sample: 821
buggy_code: private void updateData(OCShare share) { // Update DB with the response share.setPath(mPath); <START> if (mPath.endsWith(FileUtils.PATH_SEPARATOR)) { <END> share.setIsFolder(true); } else { share.setIsFolder(false); } share.setPermissions(READ_ONLY); getStorageManager().saveShare(share); // Update OCFile with data from share: ShareByLink and publicLink OCFile file = getStorageManager().getFileByPath(mPath); if (file!=null) { file.setShareWithSharee(true); // TODO - this should be done by the FileContentProvider, as part of getStorageManager().saveShare(share) getStorageManager().saveFile(file); } }
code_review: This Block can be shortened to `share.setIsFolder(mPath.endsWith(FileUtils.PATH_SEPARATOR))`
target code: private void updateData ( OCShare share ) { // Update DB with the response share . setPath ( mPath ) ; share . setIsFolder ( mPath . endsWith ( FileUtils . PATH_SEPARATOR ) ) ; share . setPermissions ( READ_ONLY ) ; getStorageManager ( ) . saveShare ( share ) ; // Update OCFile with data from share : ShareByLink and publicLink OCFile file = getStorageManager ( ) . getFileByPath ( mPath ) ; if ( file != null ) { file . setShareWithSharee ( true ) ; // TODO - this should be done by the FileContentProvider , as part of getStorageManager ( ) . saveShare ( share ) getStorageManager ( ) . saveFile ( file ) ; } }
response: private void updateData(OCShare share) { // Update DB with the response share.setPath(mPath); share.setIsFolder(mPath.endsWith(FileUtils.PATH_SEPARATOR)); share.setPermissions(READ_ONLY); getStorageManager().saveShare(share); // Update OCFile with data from share: ShareByLink and publicLink OCFile file = getStorageManager().getFileByPath(mPath); if (file!=null) { file.setShareWithSharee(true); // TODO - this should be done by the FileContentProvider, as part of getStorageManager().saveShare(share) getStorageManager().saveFile(file); } }

sample: 822
buggy_code: protected void startMasters(boolean isLeader) { try { connectToUFS(); mRegistry.start(isLeader); } catch (IOException e) { <START> LOG.error("Failed to start master.", e); <END> throw Throwables.propagate(e); } }
code_review: does the propagated exception not get logged? This looks like it would result in logging the same thing twice
target code: protected void startMasters ( boolean isLeader ) { try { connectToUFS ( ) ; mRegistry . start ( isLeader ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
response: protected void startMasters(boolean isLeader) { try { connectToUFS(); mRegistry.start(isLeader); } catch (IOException e) { <START> LOG.error("Failed to start master.", e); <END> throw Throwables.propagate(e); } }

sample: 823
buggy_code: <START> public BugzillaRestRepositoryConnectorUi() { <END> connector = BugzillaRestConnector.getDefault() == null ? new BugzillaRestConnector() : BugzillaRestConnector.getDefault(); }
code_review: The default constructor should assign "null" to connector.
target code: public BugzillaRestRepositoryConnectorUi ( ) { this . connector = BugzillaRestConnector . getDefault ( ) == null ? new BugzillaRestConnector ( ) : BugzillaRestConnector . getDefault ( ) ; }
response: <START> public BugzillaRestRepositoryConnectorUi() { <END> connector = null; }

sample: 824
buggy_code: public static ListStatusPOptions getListStatusOptions() { <START> FileSystemMasterCommonPOptions commonOptions = <END> getCommonOptions().toBuilder().setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL)) .setTtlAction(GrpcUtils.toProto( Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class))) .build(); return ListStatusPOptions.newBuilder().setCommonOptions(commonOptions) .setLoadMetadataType(GrpcUtils.toProto(Configuration .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class))) .build(); }
code_review: helper for setting common options?
target code: public static ListStatusPOptions getListStatusOptions ( ) { return ListStatusPOptions . newBuilder ( ) . setCommonOptions ( getCommonOptions ( ) . toBuilder ( ) . setTtl ( Configuration . getMs ( PropertyKey . USER_FILE_LOAD_TTL ) ) . setTtlAction ( GrpcUtils . toProto ( Configuration . getEnum ( PropertyKey . USER_FILE_LOAD_TTL_ACTION , TtlAction . class ) ) ) ) . setLoadMetadataType ( GrpcUtils . toProto ( Configuration . getEnum ( PropertyKey . USER_FILE_METADATA_LOAD_TYPE , LoadMetadataType . class ) ) ) . build ( ) ; }
response: public static ListStatusPOptions getListStatusOptions() { <START> FileSystemMasterCommonPOptions commonOptions = <END> getCommonOptions().toBuilder().setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL)) .setTtlAction(GrpcUtils.toProto( Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class))) .build(); return ListStatusPOptions.newBuilder().setCommonOptions(commonOptions) .setLoadMetadataType(GrpcUtils.toProto(Configuration .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class))) .build(); }

sample: 825
buggy_code: Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) { requireNonNull(nodeProcessor, "The nodeProcessor parameter can't be null."); this.nodeProcessor = nodeProcessor; requireNonNull(name, "The name of the node can't be null"); this.name = name; <START> requireNonNull(name, "The dag of the node can't be null"); <END> this.dag = dag; }
code_review: small typo - I think `name` is supposed to be `dag`, right?
target code: Node ( final String name , final NodeProcessor nodeProcessor , final Dag dag ) { requireNonNull ( nodeProcessor , "The nodeProcessor parameter can't be null . " ) ; this . nodeProcessor = nodeProcessor ; requireNonNull ( name , "The name of the node can't be null" ) ; this . name = name ; requireNonNull ( dag , "The dag of the node can't be null" ) ; this . dag = dag ; }
response: Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) { requireNonNull(nodeProcessor, "The nodeProcessor parameter can't be null."); this.nodeProcessor = nodeProcessor; requireNonNull(name, "The name of the node can't be null"); this.name = name; <START> requireNonNull(dag, "The dag of the node can't be null"); <END> this.dag = dag; }

sample: 826
buggy_code: public String getTooltip(MergeMode mode) { String tooltip; switch (mode) { case LEFT_TO_RIGHT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.right.tooltip"); //$NON-NLS-1$ break; case RIGHT_TO_LEFT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.left.tooltip"); //$NON-NLS-1$ break; case ACCEPT: tooltip = EMFCompareDiagramEditMessages.getString("accept.change.tooltip"); //$NON-NLS-1$ break; case REJECT: tooltip = EMFCompareDiagramEditMessages.getString("reject.change.tooltip"); //$NON-NLS-1$ break; default: <START> throw new IllegalStateException(); <END> } return tooltip; }
code_review: Here it's not the state of this class that's invalid, it's the given parameter. The relevant exception in such a case is IllegalArgumentException
target code: public String getTooltip ( MergeMode mode ) throws IllegalArgumentException { String tooltip ; switch ( mode ) { case LEFT_TO_RIGHT : tooltip = EMFCompareDiagramEditMessages . getString ( "merged . to . right . tooltip" ) ; // $NON - NLS - 1$ break ; case RIGHT_TO_LEFT : tooltip = EMFCompareDiagramEditMessages . getString ( "merged . to . left . tooltip" ) ; // $NON - NLS - 1$ break ; case ACCEPT : tooltip = EMFCompareDiagramEditMessages . getString ( "accept . change . tooltip" ) ; // $NON - NLS - 1$ break ; case REJECT : tooltip = EMFCompareDiagramEditMessages . getString ( "reject . change . tooltip" ) ; // $NON - NLS - 1$ break ; default : throw new IllegalArgumentException ( ) ; } return tooltip ; }
response: public String getTooltip(MergeMode mode) { String tooltip; switch (mode) { case LEFT_TO_RIGHT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.right.tooltip"); //$NON-NLS-1$ break; case RIGHT_TO_LEFT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.left.tooltip"); //$NON-NLS-1$ break; case ACCEPT: tooltip = EMFCompareDiagramEditMessages.getString("accept.change.tooltip"); //$NON-NLS-1$ break; case REJECT: tooltip = EMFCompareDiagramEditMessages.getString("reject.change.tooltip"); //$NON-NLS-1$ break; default: <START> throw new IllegalArgumentException(); <END> } return tooltip; }

sample: 827
buggy_code: <START> public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) { <END> this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null; this.upstreamFilterStrategy = upstreamFilterStrategy; this.allowUpstreamDependencies = allowUpstreamDependencies ? Boolean.TRUE : null; }
code_review: Please add an overloaded constructor to keep comparibility (like `TriggerredBuildSelector(boolean)`).
target code: public TriggeredBuildSelector ( boolean fallbackToLastSuccessful , UpstreamFilterStrategy upstreamFilterStrategy , boolean allowUpstreamDependencies ) { this . fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean . TRUE : null ; this . upstreamFilterStrategy = upstreamFilterStrategy ; this . allowUpstreamDependencies = allowUpstreamDependencies ; }
response: <START> public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) { <END> this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null; this.upstreamFilterStrategy = upstreamFilterStrategy; this.allowUpstreamDependencies = allowUpstreamDependencies ? Boolean.TRUE : null; } public TriggeredBuildSelector(boolean fallbackToLastSuccessful) { this(fallbackToLastSuccessful, UpstreamFilterStrategy.UseAll, false); }

sample: 828
buggy_code: public static Result deleteUser(Long userId) { if (User.findByLoginId(session().get("loginId")).isSiteManager()){ <START> if (!Project.isOnlyManager(userId)) { <END> User.find.byId(userId).delete(); } else { flash(Constants.WARNING, "site.userList.deleteAlert"); } } else { flash(Constants.WARNING, "auth.unauthorized.waringMessage"); } return redirect(routes.SiteApp.userList(0, null)); }
code_review:    if (not a) { ... } not not a { ... }    if   .
target code: public static Result deleteUser ( Long userId ) { if ( User . findByLoginId ( session ( ) . get ( "loginId" ) ) . isSiteManager ( ) ) { if ( Project . isOnlyManager ( userId ) ) { flash ( Constants . WARNING , "site . userList . deleteAlert" ) ; } else { User . find . byId ( userId ) . delete ( ) ; } } else { flash ( Constants . WARNING , "auth . unauthorized . waringMessage" ) ; } return redirect ( routes . SiteApp . userList ( 0 , null ) ) ; }
response: public static Result deleteUser(Long userId) { if (User.findByLoginId(session().get("loginId")).isSiteManager()){ <START> if (Project.isOnlyManager(userId)) { <END> flash(Constants.WARNING, "site.userList.deleteAlert"); } else { User.find.byId(userId).delete(); } } else { flash(Constants.WARNING, "auth.unauthorized.waringMessage"); } return redirect(routes.SiteApp.userList(0, null)); }

sample: 829
buggy_code: public Attachment(@NonNull Uri uri, @NonNull String contentType, long date, @Nullable String fileName) { <START> if (date < 0) { <END> throw new AssertionError("uri, content type, and date must all be specified"); } this.uri = uri; this.fileName = fileName; this.contentType = contentType; this.date = date; }
code_review: I know these are annotated nonnull, but since this is an assertion let's leave it in
target code: public Attachment ( @NonNull Uri uri , @NonNull String contentType , long date , @Nullable String fileName ) { if ( uri == null || contentType == null || date < 0 ) { throw new AssertionError ( "uri , content type , and date must all be specified" ) ; } this . uri = uri ; this . fileName = fileName ; this . contentType = contentType ; this . date = date ; }
response: public Attachment(@NonNull Uri uri, @NonNull String contentType, long date, @Nullable String fileName) { <START> if (date < 0) { <END> throw new AssertionError("uri, content type, and date must all be specified"); } this.uri = uri; this.fileName = fileName; this.contentType = contentType; this.date = date; }

sample: 830
buggy_code: private List<VoldemortService> createServices() { List<VoldemortService> services = new ArrayList<VoldemortService>(); CoordinatorProxyService coordinator = new CoordinatorProxyService(config, storeClientConfigs); <START> services.add(coordinator); <END> if(config.isAdminServiceEnabled()) { services.add(new CoordinatorAdminService(config, storeClientConfigs)); } return ImmutableList.copyOf(services); }
code_review: Just this will work too : services.add(new CoordinatorProxyService(config, storeClientConfigs)); You can save a line by not declaring a coordinator object.
target code: private List < VoldemortService > createServices ( ) { List < VoldemortService > services = new ArrayList < VoldemortService > ( ) ; services . add ( new CoordinatorProxyService ( config , storeClientConfigs ) ) ; if ( config . isAdminServiceEnabled ( ) ) { services . add ( new CoordinatorAdminService ( config , storeClientConfigs ) ) ; } return ImmutableList . copyOf ( services ) ; }
response: private List<VoldemortService> createServices() { List<VoldemortService> services = new ArrayList<VoldemortService>(); <START> services.add(new CoordinatorProxyService(config, storeClientConfigs)); <END> if(config.isAdminServiceEnabled()) { services.add(new CoordinatorAdminService(config, storeClientConfigs)); } return ImmutableList.copyOf(services); }

sample: 831
buggy_code: public void afterBegin() throws EJBException, RemoteException { <START> log.info("afterBegin called"); <END> checker.setSynchronizedBegin(); }
code_review: log.trace
target code: public void afterBegin ( ) throws EJBException , RemoteException { log . trace ( "afterBegin called" ) ; checker . setSynchronizedBegin ( ) ; }
response: public void afterBegin() throws EJBException, RemoteException { <START> log.trace("afterBegin called"); <END> checker.setSynchronizedBegin(); }

sample: 832
buggy_code: private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending) { for (Integer value : pagingSpec.getPagingIdentifiers().values()) { <START> if (descending ^ value < 0) { <END> return false; } } return pagingSpec.getThreshold() >= 0; }
code_review: This is a part of the java spec I'm not as familiar with. Is this doing `((descending ? 1 : 0) ^ value) < 0` or `descending ^ (value < 0)`?
target code: private boolean checkPagingSpec ( PagingSpec pagingSpec , boolean descending ) { for ( Integer value : pagingSpec . getPagingIdentifiers ( ) . values ( ) ) { if ( descending ^ ( value < 0 ) ) { return false ; } } return pagingSpec . getThreshold ( ) >= 0 ; }
response: private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending) { for (Integer value : pagingSpec.getPagingIdentifiers().values()) { <START> if (descending ^ (value < 0)) { <END> return false; } } return pagingSpec.getThreshold() >= 0; }

sample: 833
buggy_code: private void init(Jdbi db) { <START> db.registerArrayType(SqlArrayTypeFactory.of(UserId.class, "int", UserId::getId)); <END> db.registerColumnMapper(new UserIdColumnMapper()); }
code_review: Can we unroll this to use the new `Configurable` method instead?
target code: private void init ( Jdbi db ) { db . registerArrayType ( UserId . class , "int" , UserId : : getId ) ; db . registerColumnMapper ( new UserIdColumnMapper ( ) ) ; }
response: private void init(Jdbi db) { <START> db.registerArrayType(SqlArrayTypeFactory.of(UserId.class, "int", UserId::getId)); <END> db.registerColumnMapper(new UserIdColumnMapper()); }

sample: 834
buggy_code: protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) { VdsStatic server = getVdsStaticDao().get(brick.getServerId()); <START> if ((server == null || !server.getvds_group_id().equals(getVdsGroupId())) && addCanDoActionMessage) { <END> addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID); return false; } brick.setServerName(server.gethost_name()); return true; }
code_review: shouldn't it return false even if addCanDoActionMessage=false? from the name of the parameter it sounds like only the message is not needed but still give the correct return value
target code: protected boolean updateBrickServerName ( GlusterBrickEntity brick , boolean addCanDoActionMessage ) { VdsStatic server = getVdsStaticDao ( ) . get ( brick . getServerId ( ) ) ; if ( ( server == null || ! server . getvds_group_id ( ) . equals ( getVdsGroupId ( ) ) ) ) { if ( addCanDoActionMessage ) { addCanDoActionMessage ( VdcBllMessages . ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID ) ; } return false ; } brick . setServerName ( server . gethost_name ( ) ) ; return true ; }
response: protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) { VdsStatic server = getVdsStaticDao().get(brick.getServerId()); <START> if (server == null || !server.getvds_group_id().equals(getVdsGroupId())) { <END> if (addCanDoActionMessage) { addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID); } return false; } brick.setServerName(server.gethost_name()); return true; }

sample: 835
buggy_code: <START> public static <END> @NonNull String getSpanName(String attributeName) { return attributeName.substring(0, attributeName.lastIndexOf('/')); }
code_review: private
target code: private static @NonNull String getSpanName ( String attributeName ) { return attributeName . substring ( 0 , attributeName . lastIndexOf ( ' / ' ) ) ; }
response: <START> private static <END> @NonNull String getSpanName(String attributeName) { return attributeName.substring(0, attributeName.lastIndexOf('/')); }

sample: 836
buggy_code: private static boolean containsAll(String text, final Collection<String> items) { final String _text = text.toLowerCase(); return items.stream() <START> .allMatch((String it) -> { <END> return _text.contains(it); }); }
code_review: Why do you need to type parameter ?
target code: private static boolean containsAll ( String text , final Collection < String > items ) { final String _text = text . toLowerCase ( ) ; return items . stream ( ) . allMatch ( it - > { return _text . contains ( it ) ; } ) ; }
response: private static boolean containsAll(String text, final Collection<String> items) { final String _text = text.toLowerCase(); return items.stream() <START> .allMatch(it -> { <END> return _text.contains(it); }); }

sample: 837
buggy_code: private void recursiveDelete(Path file) throws IOException { Files.walkFileTree(file, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException { if (e == null) { Files.delete(dir); return FileVisitResult.CONTINUE; <START> } else { throw e; } <END> } }); }
code_review: This doesn't really need to be in an else clause. It might be more readable to invert the logic of this block, i.e.: if (e != null) { throw e; } Files.delete(dir); return FileVisitResult.CONTINUE;
target code: private void recursiveDelete ( Path file ) throws IOException { Files . walkFileTree ( file , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @Override public FileVisitResult postVisitDirectory ( Path dir , IOException e ) throws IOException { if ( e != null ) { throw e ; } Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ) ; }
response: private void recursiveDelete(Path file) throws IOException { Files.walkFileTree(file, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException { if (e == null) { Files.delete(dir); return FileVisitResult.CONTINUE; } else { throw e; } } }); }

sample: 838
buggy_code: public Optional<Object> nextMarker() { if (totalCount < pageSize) return Optional.absent(); <START> if (pageNumber < (totalCount / pageSize)) { <END> return Optional.of(toPaginationOptions(pageNumber + 1)); } return Optional.absent(); }
code_review: Does the `pageNumber` start at 1 or 0? If it starts at one, this conditional could be wrong: pageNumber=1, totalCount=7,pageSize=5 would return false, but there is still a next page.
target code: public Optional < Object > nextMarker ( ) { if ( totalCount < pageSize ) return Optional . absent ( ) ; if ( ( float ) pageNumber < ( ( float ) totalCount / ( float ) pageSize ) ) { return Optional . of ( toPaginationOptions ( pageNumber + 1 ) ) ; } return Optional . absent ( ) ; }
response: public Optional<Object> nextMarker() { if (totalCount < pageSize) return Optional.absent(); <START> if (pageNumber <= (totalCount / pageSize)) { <END> return Optional.of(toPaginationOptions(pageNumber + 1)); } return Optional.absent(); }

sample: 839
buggy_code: public void testInvalidUser(AuthenticationFlowContext context, UserModel user) { <START> if (user == null || user.getServiceAccountClientLink() != null) { <END> dummyHash(context); context.getEvent().error(Errors.USER_NOT_FOUND); Response challengeResponse = challenge(context, getDefaultChallengeMessage(context)); context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse); } }
code_review: Is it really necessary to add this check here? Doesn't the AuthenticationProcessor prevent the login request from reaching this point?
target code: public void testInvalidUser ( AuthenticationFlowContext context , UserModel user ) { if ( user == null ) { dummyHash ( context ) ; context . getEvent ( ) . error ( Errors . USER_NOT_FOUND ) ; Response challengeResponse = challenge ( context , getDefaultChallengeMessage ( context ) ) ; context . failureChallenge ( AuthenticationFlowError . INVALID_USER , challengeResponse ) ; } }
response: public void testInvalidUser(AuthenticationFlowContext context, UserModel user) { <START> if (user == null) { <END> dummyHash(context); context.getEvent().error(Errors.USER_NOT_FOUND); Response challengeResponse = challenge(context, getDefaultChallengeMessage(context)); context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse); } }

sample: 840
buggy_code: public boolean validateChecksum() { if (StringUtils.isNotBlank(checksum)) { try { return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath)); } catch (IOException e) { <START> throw new CloudRuntimeException("could not check sum for file: " + downloadedFilePath); <END> } catch (NoSuchAlgorithmException e) { throw new CloudRuntimeException("Unknown checksum algorithm: " + checksum, e); } } return true; }
code_review: missing second argument to view the actual exception message/stack trace: `file: " + downloadedFilePath, e)`
target code: public boolean validateChecksum ( ) { if ( StringUtils . isNotBlank ( checksum ) ) { try { return DigestHelper . check ( checksum , new FileInputStream ( downloadedFilePath ) ) ; } catch ( IOException e ) { throw new CloudRuntimeException ( "could not check sum for file : " + downloadedFilePath , e ) ; } catch ( NoSuchAlgorithmException e ) { throw new CloudRuntimeException ( "Unknown checksum algorithm : " + checksum , e ) ; } } return true ; }
response: public boolean validateChecksum() { if (StringUtils.isNotBlank(checksum)) { try { return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath)); } catch (IOException e) { <START> throw new CloudRuntimeException("could not check sum for file: " + downloadedFilePath, e); <END> } catch (NoSuchAlgorithmException e) { throw new CloudRuntimeException("Unknown checksum algorithm: " + checksum, e); } } return true; }

sample: 841
buggy_code: public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) { this.address = address; if (registrations == null || registrations.isEmpty()) { this.registrations = Collections.emptyList(); } else { <START> this.registrations = Collections.unmodifiableList(registrations); <END> } }
code_review: can we avoid using `unmodifiableList` and have the cluster manager trust the list will be not modified ?
target code: public RegistrationUpdateEvent ( String address , List < RegistrationInfo > registrations ) { this . address = address ; this . registrations = registrations == null ? Collections . emptyList ( ) : registrations ; }
response: public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) { this.address = address; if (registrations == null || registrations.isEmpty()) { this.registrations = Collections.emptyList(); } else { <START> this.registrations = registrations; <END> } }

sample: 842
buggy_code: public InvocationContext createInvocationContext(boolean isWrite, int keyCount) { if (keyCount == 1) { <START> SingleKeyNonTxInvocationContext result = <END> new SingleKeyNonTxInvocationContext(true, keyEq); return result; } else if (keyCount > 0) { NonTxInvocationContext ctx = new NonTxInvocationContext(keyCount, true, keyEq); return ctx; } return createInvocationContext(null); }
code_review: I would remove the variables and do `return new SingleKeyNonTxInvocationContext(true, keyEq);` the same thing can be applied to other methods
target code: public InvocationContext createInvocationContext ( boolean isWrite , int keyCount ) { if ( keyCount == 1 ) { return new SingleKeyNonTxInvocationContext ( true , keyEq ) ; } else if ( keyCount > 0 ) { return new NonTxInvocationContext ( keyCount , true , keyEq ) ; } return createInvocationContext ( null ) ; }
response: public InvocationContext createInvocationContext(boolean isWrite, int keyCount) { if (keyCount == 1) { <START> return <END> new SingleKeyNonTxInvocationContext(true, keyEq); } else if (keyCount > 0) { NonTxInvocationContext ctx = new NonTxInvocationContext(keyCount, true, keyEq); return ctx; } return createInvocationContext(null); }

sample: 843
buggy_code: private boolean isRealWorklog(final EveritWorklog worklog) { boolean isRealWorklog = true; if (issuesRegex != null) { <START> for (final Pattern issuePattern : issuesRegex) { <END> final boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches(); // if match not count in summary if (issueMatches) { isRealWorklog = false; break; } } } return isRealWorklog; }
code_review: Remove all of the unnecessary final modifier from the local variables from all of the modified classes.
target code: private boolean isRealWorklog ( final EveritWorklog worklog ) { boolean isRealWorklog = true ; if ( issuesRegex != null ) { for ( Pattern issuePattern : issuesRegex ) { boolean issueMatches = issuePattern . matcher ( worklog . getIssue ( ) ) . matches ( ) ; // if match not count in summary if ( issueMatches ) { isRealWorklog = false ; break ; } } } return isRealWorklog ; }
response: private boolean isRealWorklog(final EveritWorklog worklog) { boolean isRealWorklog = true; if (issuesRegex != null) { <START> for (Pattern issuePattern : issuesRegex) { <END> boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches(); // if match not count in summary if (issueMatches) { isRealWorklog = false; break; } } } return isRealWorklog; }

sample: 844
buggy_code: public void removed(IExtension[] extensions) { for (IExtension extension : extensions) { CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension); if (layoutAlgorithmProvider != null) { List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms(); for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) { layoutProviderRegistry.remove(customLayoutAlgorithm.getId()); } } <START> extensionToLayoutAlgorithmProvider.put(extension, <END> null); } }
code_review: remove instead?
target code: public void removed ( IExtension [ ] extensions ) { for ( IExtension extension : extensions ) { CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider . get ( extension ) ; if ( layoutAlgorithmProvider != null ) { List < CustomLayoutAlgorithm > customLayoutAlgorithms = layoutAlgorithmProvider . getCustomLayoutAlgorithms ( ) ; for ( CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms ) { layoutProviderRegistry . remove ( customLayoutAlgorithm . getId ( ) ) ; } } extensionToLayoutAlgorithmProvider . remove ( extension ) ; } }
response: public void removed(IExtension[] extensions) { for (IExtension extension : extensions) { CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension); if (layoutAlgorithmProvider != null) { List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms(); for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) { layoutProviderRegistry.remove(customLayoutAlgorithm.getId()); } } <START> extensionToLayoutAlgorithmProvider.remove(extension); <END> } }

sample: 845
buggy_code: public void increment( int typeId ) { if ( typeId >= counts.length ) { <START> counts = Arrays.copyOf( counts, max( counts.length * 2, typeId ) ); <END> } counts[typeId]++; if ( typeId > highestTypeId ) { highestTypeId = typeId; } }
code_review: This needs to be `typeId + 1`, since the parameter here is the _length_, while `typeId` is elsewhere used as an _index_.
target code: public void increment ( int typeId ) { if ( typeId >= counts . length ) { counts = Arrays . copyOf ( counts , max ( counts . length * 2 , typeId + 1 ) ) ; } counts [ typeId ] ++ ; if ( typeId > highestTypeId ) { highestTypeId = typeId ; } }
response: public void increment( int typeId ) { if ( typeId >= counts.length ) { <START> counts = Arrays.copyOf( counts, max( counts.length * 2, typeId + 1 ) ); <END> } counts[typeId]++; if ( typeId > highestTypeId ) { highestTypeId = typeId; } }

sample: 846
buggy_code: private static void delete(List<ReceiveCommand> cmds, List<ReceiveCommand> createCmds) { for (ReceiveCommand c : createCmds) { ObjectId id = c.getNewId(); String <START> n = <END> c.getRefName(); cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), n)); } }
code_review: s/n/name/ n is always an index
target code: private static void delete ( List < ReceiveCommand > cmds , List < ReceiveCommand > createCmds ) { for ( ReceiveCommand cmd : createCmds ) { ObjectId id = cmd . getNewId ( ) ; String name = cmd . getRefName ( ) ; cmds . add ( new ReceiveCommand ( id , ObjectId . zeroId ( ) , name ) ) ; } }
response: private static void delete(List<ReceiveCommand> cmds, List<ReceiveCommand> createCmds) { for (ReceiveCommand c : createCmds) { ObjectId id = c.getNewId(); String <START> name = <END> c.getRefName(); cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), name)); } }

sample: 847
buggy_code: public RefreshLocalVisitor(IProgressMonitor monitor) { this.monitor = <START> SubMonitor.convert(monitor, <END> TOTAL_WORK); workspace = (Workspace) ResourcesPlugin.getWorkspace(); resourceChanged = false; String msg = Messages.resources_errorMultiRefresh; errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null); }
code_review: Use the one-argument version of convert, since the second argument passed in here is never used.
target code: public RefreshLocalVisitor ( IProgressMonitor monitor ) { this . monitor = SubMonitor . convert ( monitor ) ; workspace = ( Workspace ) ResourcesPlugin . getWorkspace ( ) ; resourceChanged = false ; String msg = Messages . resources_errorMultiRefresh ; errors = new MultiStatus ( ResourcesPlugin . PI_RESOURCES , IResourceStatus . FAILED_READ_LOCAL , msg , null ) ; }
response: public RefreshLocalVisitor(IProgressMonitor monitor) { this.monitor = <START> SubMonitor.convert(monitor); workspace = (Workspace) ResourcesPlugin.getWorkspace(); resourceChanged = false; String msg = Messages.resources_errorMultiRefresh; errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null); }

sample: 848
buggy_code: private ConfigurationImpl() { this.validationBootstrapParameters = new ValidationBootstrapParameters(); this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES ); this.defaultTraversableResolver = new DefaultTraversableResolver(); this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl(); if ( Version.getJavaRelease() >= 8 ) { <START> this.defaultParameterNameProvider = new Java8DefaultParameterNameProvider(); <END> } else { this.defaultParameterNameProvider = new DefaultParameterNameProvider(); } this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator ); }
code_review: Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](http://beanvalidation.org/1.1/spec/#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters) "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
target code: private ConfigurationImpl ( ) { this . validationBootstrapParameters = new ValidationBootstrapParameters ( ) ; this . defaultResourceBundleLocator = new PlatformResourceBundleLocator ( ResourceBundleMessageInterpolator . USER_VALIDATION_MESSAGES ) ; this . defaultTraversableResolver = new DefaultTraversableResolver ( ) ; this . defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl ( ) ; this . defaultParameterNameProvider = new DefaultParameterNameProvider ( ) ; this . defaultMessageInterpolator = new ResourceBundleMessageInterpolator ( defaultResourceBundleLocator ) ; }
response: private ConfigurationImpl() { this.validationBootstrapParameters = new ValidationBootstrapParameters(); this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES ); this.defaultTraversableResolver = new DefaultTraversableResolver(); this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl(); if ( Version.getJavaRelease() >= 8 ) { <START> this.defaultParameterNameProvider = new DefaultParameterNameProvider(); <END> } else { this.defaultParameterNameProvider = new DefaultParameterNameProvider(); } this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator ); }

sample: 849
buggy_code: public void testNull_Event() { XDRResponseEventType eventA = new XDRResponseEventType(); <START> XDREventType eventB = new XDREventType(); <END> eventA = null; eventB = null; assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(eventA)); assertNull(xdrTransformHelper.transformXDRToCheckPolicy(eventB)); }
code_review: Do we need to declare object and then assign to null? Just remove them
target code: public void testNull_Event ( ) { assertNull ( xdrTransformHelper . transformXDRResponseToCheckPolicy ( null ) ) ; assertNull ( xdrTransformHelper . transformXDRToCheckPolicy ( null ) ) ; }
response: public void testNull_Event() { XDRResponseEventType eventA = new XDRResponseEventType(); <START> XDREventType eventB = new XDREventType(); <END> assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(eventA)); assertNull(xdrTransformHelper.transformXDRToCheckPolicy(eventB)); }

sample: 850
buggy_code: public void testJNDIBindingsNoAppName() throws Exception { <START> boolean passed = false; <END> Context ctx = getInitialContext(HOST, PORT); Hello ejb = (Hello) ctx.lookup("ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"); Assert.assertNotNull("Null object returned for local business interface lookup in the ejb namespace", ejb); Assert.assertTrue("Expected JNDI binding message not found", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME, "ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello")); }
code_review: Cruft, It doesn't matter, but this is an unused variable.
target code: public void testJNDIBindingsNoAppName ( ) throws Exception { Context ctx = getInitialContext ( HOST , PORT ) ; Hello ejb = ( Hello ) ctx . lookup ( "ejb :/ ejb - jndi / Hello ! org . jboss . as . test . integration . ejb . jndi . logging . Hello" ) ; Assert . assertNotNull ( "Null object returned for local business interface lookup in the ejb namespace" , ejb ) ; Assert . assertTrue ( "Expected JNDI binding message not found" , LoggingUtil . hasLogMessage ( managementClient , TEST_HANDLER_NAME , "ejb :/ ejb - jndi / Hello ! org . jboss . as . test . integration . ejb . jndi . logging . Hello" ) ) ; }
response: public void testJNDIBindingsNoAppName() throws Exception { <START> Context ctx = getInitialContext(HOST, PORT); Hello ejb = (Hello) ctx.lookup("ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"); Assert.assertNotNull("Null object returned for local business interface lookup in the ejb namespace", ejb); Assert.assertTrue("Expected JNDI binding message not found", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME, "ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello")); }

sample: 851
buggy_code: public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) { this.importedList = importedList; this.doParseDetails = true; this.doParseConditions = true; this.doParseFactors = true; this.doParseVariates = true; this.userDataManager = userDataManager; this.descriptionSheetIndex = 0; <START> ; <END> }
code_review: remove
target code: public CrossesListDescriptionSheetParser ( final T importedList , final UserDataManager userDataManager ) { this . importedList = importedList ; this . doParseDetails = true ; this . doParseConditions = true ; this . doParseFactors = true ; this . doParseVariates = true ; this . userDataManager = userDataManager ; this . descriptionSheetIndex = 0 ; }
response: public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) { this.importedList = importedList; this.doParseDetails = true; this.doParseConditions = true; this.doParseFactors = true; this.doParseVariates = true; this.userDataManager = userDataManager; this.descriptionSheetIndex = 0; <START> ; <END> }

sample: 852
buggy_code: public VolumeClassification getVolumeClassification() { if (volumeClassification == null) { if <START> (active) <END> { return VolumeClassification.Volume; } return VolumeClassification.Snapshot; } return volumeClassification; }
code_review: please change to ternary
target code: public VolumeClassification getVolumeClassification ( ) { if ( volumeClassification == null ) { return ( active ? VolumeClassification . Volume : VolumeClassification . Snapshot ) ; } return volumeClassification ; }
response: public VolumeClassification getVolumeClassification() { if (volumeClassification == null) { return <START> (active) <END> ? VolumeClassification.Volume : VolumeClassification.Snapshot; } return volumeClassification; }

sample: 853
buggy_code: public void registerSonarQubeVersion_publishes_version_on_first_call() { ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings()); try (HazelcastCluster hzCluster = HazelcastCluster.builder(clusterProperties).build()) { hzCluster.registerSonarQubeVersion("1.0.0.0"); HazelcastInstance hzInstance = createHazelcastClient(hzCluster); assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get()) .isNotNull() .isInstanceOf(String.class) <START> .isEqualTo("1.0.0.0"); <END> } }
code_review: no need for isNotNull nor isInstanceOf(String.class). They are both implicit with .isEqualTo("1.0.0.0")
target code: public void registerSonarQubeVersion_publishes_version_on_first_call ( ) { ClusterProperties clusterProperties = new ClusterProperties ( newClusterSettings ( ) ) ; try ( HazelcastCluster hzCluster = HazelcastCluster . create ( clusterProperties ) ) { hzCluster . registerSonarQubeVersion ( "1 . 0 . 0 . 0" ) ; HazelcastInstance hzInstance = createHazelcastClient ( hzCluster ) ; assertThat ( hzInstance . getAtomicReference ( SONARQUBE_VERSION ) . get ( ) ) . isEqualTo ( "1 . 0 . 0 . 0" ) ; } }
response: public void registerSonarQubeVersion_publishes_version_on_first_call() { ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings()); try (HazelcastCluster hzCluster = HazelcastCluster.builder(clusterProperties).build()) { hzCluster.registerSonarQubeVersion("1.0.0.0"); HazelcastInstance hzInstance = createHazelcastClient(hzCluster); assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get()) <START> .isEqualTo("1.0.0.0"); <END> } }

sample: 854
buggy_code: public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) { String[] texts = new <START> String[fColumns.length]; <END> for (int i = 0; i < fColumns.length; i++) { texts[i] = fLabelProvider.getColumnText(entry, i); } return texts; }
code_review: Null pointer...
target code: public String [ ] getColumnTexts ( @NonNull ITimeGraphEntry entry ) { String [ ] texts = null ; if ( fColumns != null ) { texts = new String [ fColumns . length ] ; for ( int i = 0 ; i < fColumns . length ; i ++ ) { texts [ i ] = fLabelProvider . getColumnText ( entry , i ) ; } } else { texts = new String [ 1 ] ; texts [ 0 ] = entry . getName ( ) ; } return texts ; }
response: public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) { String[] texts = new String[fColumns.length]; for (int i = 0; i < fColumns.length; i++) { texts[i] = fLabelProvider.getColumnText(entry, i); } return texts; }

sample: 855
buggy_code: protected Pageview() { <START> } <END>
code_review: private
target code: private Pageview ( ) { }
response: private Pageview() { <START> } <END>

sample: 856
buggy_code: public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration, final List<PasteEObjectConfiguration> existingPasteConfigurations) { super(parentShell); this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration); this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration; this.existingPasteConfigurations = existingPasteConfigurations; <START> setTitle(org.eclipse.papyrus.customization.nattableconfiguration.messages.Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName); <END> }
code_review: import the class Messages ?
target code: public TreeFillingConfigurationDialog ( final Shell parentShell , final TreeFillingConfiguration treefillingConfiguration , final List < ILabelProviderConfiguration > existingLabelProvidersConfiguration , final List < PasteEObjectConfiguration > existingPasteConfigurations ) { super ( parentShell ) ; this . modifiedTreefillingConfiguration = EcoreUtil . copy ( treefillingConfiguration ) ; this . existingLabelProviderConfigurations = existingLabelProvidersConfiguration ; this . existingPasteConfigurations = existingPasteConfigurations ; setTitle ( Messages . TreeFillingConfigurationDialog_treeFillingConfigurationDialogName ) ; }
response: public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration, final List<PasteEObjectConfiguration> existingPasteConfigurations) { super(parentShell); this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration); this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration; this.existingPasteConfigurations = existingPasteConfigurations; <START> setTitle(Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName); <END> }

sample: 857
buggy_code: public void execute(final Talks talks) throws IOException { int idx = this.index(talks); for (final Talk talk : talks.active()) { <START> final int current = idx + 1; <END> talk.modify( new Directives() .xpath("/talk/request") .attr("index", Integer.toString(current)) ); idx = current; } }
code_review: `current` is redundant, just use `idx`
target code: public void execute ( final Talks talks ) throws IOException { int idx = this . index ( talks ) ; for ( final Talk talk : talks . active ( ) ) { idx += 1 ; talk . modify ( new Directives ( ) . xpath ( " / talk / request" ) . attr ( "index" , Integer . toString ( idx ) ) ) ; } }
response: public void execute(final Talks talks) throws IOException { int idx = this.index(talks); for (final Talk talk : talks.active()) { <START> idx++; <END> talk.modify( new Directives() .xpath("/talk/request") .attr("index", Integer.toString(idx)) ); } }

sample: 858
buggy_code: public long getSafePointDrId() { // Acquire lock to avoid seeing bad data while another thread is in truncate() <START> synchronized (m_map) { <END> assert (!m_map.isEmpty()); return end(m_map.asRanges().iterator().next()); } }
code_review: Looks good to me, but worth to protect `getFirstDrId()` and `getLastDrId()` too, they'll throw `NoSuchElementException` also if `m_map` is empty.
target code: public long getSafePointDrId ( ) { assert ( ! m_map . isEmpty ( ) ) ; return end ( m_map . asRanges ( ) . iterator ( ) . next ( ) ) ; }
response: public long getSafePointDrId() { // Acquire lock to avoid seeing bad data while another thread is in truncate() <START> synchronized (m_map) { <END> return end(m_map.asRanges().iterator().next()); } }

sample: 859
buggy_code: public void setUp() throws Exception { createProjectWithNfcAndSetVariable(PROJECT_NAME); numDetectedTags.setValue(0); nfcBrickPosition = 0; setVariableIDPosition = 1; setVariableMessagePosition = 2; baseActivityTestRule.launchActivity(null); <START> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableIDPosition, READ_TAG_ID); <END> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableMessagePosition, READ_TAG_MESSAGE); }
code_review: is this necessary in the set up? wouldnt it be sufficient if this would be done once in the layout test?
target code: public void setUp ( ) throws Exception { createProjectWithNfcAndSetVariable ( ) ; baseActivityTestRule . launchActivity ( null ) ; }
response: public void setUp() throws Exception { createProjectWithNfcAndSetVariable(PROJECT_NAME); numDetectedTags.setValue(0); nfcBrickPosition = 0; setVariableIDPosition = 1; setVariableMessagePosition = 2; baseActivityTestRule.launchActivity(null); <START> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableIDPosition, READ_TAG_ID); checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableMessagePosition, READ_TAG_MESSAGE); <END> }

sample: 860
buggy_code: public ListRequest list() { return new ListRequest() { @Override public List<ProjectInfo> get() throws RestApiException { <START> return ProjectsImpl.this.list(this); <END> } }; }
code_review: I don't think ProjectsImpl.this is necessary, it would only be necessary if the method call were get(this) which conflicts with the method name in the anonymous class.
target code: public ListRequest list ( ) { return new ListRequest ( ) { @Override public List < ProjectInfo > get ( ) throws RestApiException { return list ( this ) ; } } ; }
response: public ListRequest list() { return new ListRequest() { @Override public List<ProjectInfo> get() throws RestApiException { <START> return list(this); <END> } }; }

sample: 861
buggy_code: <START> public void validateEnums(WatchDog entity) { <END> EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true); EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), false); }
code_review: potential NPE, entity can be NULL
target code: public void validateEnums ( WatchDog entity ) { if ( entity != null ) { EnumValidator . validateEnum ( WatchdogAction . class , entity . getAction ( ) , true ) ; EnumValidator . validateEnum ( WatchdogModel . class , entity . getModel ( ) , true ) ; } }
response: <START> public void validateEnums(WatchDog entity) { <END> if (entity != null) { EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true); EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), false); } }

sample: 862
buggy_code: void error(ZuulException e) { RequestContext.getCurrentContext().setThrowable(e); zuulRunner.error(); <START> LOG.error(e.getMessage(), e); <END> }
code_review: My preference would be to remove `e.printStackTrace()` altogether and let the 'error' filters determine if they want to log the error.
target code: void error ( ZuulException e ) { RequestContext . getCurrentContext ( ) . setThrowable ( e ) ; zuulRunner . error ( ) ; }
response: void error(ZuulException e) { RequestContext.getCurrentContext().setThrowable(e); zuulRunner.error(); <START> LOG.error(e.getMessage(), e); <END> }

sample: 863
buggy_code: private List<String> defaultIncludedModuleNamesForUnnamedModule() { if (fJavaElements != null) { List<IPackageFragmentRoot> roots= new ArrayList<>(); for (IJavaElement <START> fJavaElement : <END> fJavaElements) { if (fJavaElement instanceof IPackageFragmentRoot) { roots.add((IPackageFragmentRoot) fJavaElement); } } return JavaCore.defaultRootModules(roots); } return Collections.emptyList(); }
code_review: rename to element
target code: private List < String > defaultIncludedModuleNamesForUnnamedModule ( ) { if ( fJavaElements != null ) { List < IPackageFragmentRoot > roots = new ArrayList < > ( ) ; for ( IJavaElement element : fJavaElements ) { if ( element instanceof IPackageFragmentRoot ) { roots . add ( ( IPackageFragmentRoot ) element ) ; } } return JavaCore . defaultRootModules ( roots ) ; } return Collections . emptyList ( ) ; }
response: private List<String> defaultIncludedModuleNamesForUnnamedModule() { if (fJavaElements != null) { List<IPackageFragmentRoot> roots= new ArrayList<>(); for (IJavaElement <START> element : <END> fJavaElements) { if (element instanceof IPackageFragmentRoot) { roots.add((IPackageFragmentRoot) element); } } return JavaCore.defaultRootModules(roots); } return Collections.emptyList(); }

sample: 864
buggy_code: <START> public ResponseEntity<?> disable(@RequestBody List<Long> printerIds) throws IOException { <END> return setState(printerIds, false); }
code_review: `@ResponseStatus(HttpStatus.NO_RESPONSE)`, void return type Same for `/enable`
target code: public void disable ( @RequestBody List < Long > printerIds ) throws IOException { setState ( printerIds , false ) ; }
response: <START> public void disable(@RequestBody List<Long> printerIds) throws IOException { <END> setState(printerIds, false); }

sample: 865
buggy_code: public double getFilterMinSelectivityEstimateFactor() { <START> return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR.getOptionName()).float_val; <END> }
code_review: Make the option validators above typed: `public static final FloatValidator FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR ...` and change this line to: `return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR);` Same for the other option.
target code: public double getFilterMinSelectivityEstimateFactor ( ) { return options . getOption ( FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR ) ; }
response: public double getFilterMinSelectivityEstimateFactor() { <START> return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR); <END> }

sample: 866
buggy_code: public JavaOutputProcessor(PrettyPrinter printer) { <START> this.printer = printer; <END> this.environment = printer.getEnvironment(); }
code_review: why did you need to copy the env? it is accessible via getFactory().getEnv().
target code: public JavaOutputProcessor ( PrettyPrinter printer ) { this . printer = printer ; }
response: public JavaOutputProcessor(PrettyPrinter printer) { <START> this.printer = printer; <END> }

sample: 867
buggy_code: public BucketFunction getBucketFunction( ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorPartitioningHandle partitioningHandle, List<Type> partitionChannelTypes, int bucketCount) { HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle; BucketFunctionType bucketFunctionType = handle.getBucketFunctionType(); switch (bucketFunctionType) { case HIVE_COMPATIBLE: return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get()); case PRESTO_NATIVE: return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get()); default: <START> throw new IllegalStateException("Unsupported bucket function type " + bucketFunctionType); <END> } }
code_review: nit `IllegalArgumentException`
target code: public BucketFunction getBucketFunction ( ConnectorTransactionHandle transactionHandle , ConnectorSession session , ConnectorPartitioningHandle partitioningHandle , List < Type > partitionChannelTypes , int bucketCount ) { HivePartitioningHandle handle = ( HivePartitioningHandle ) partitioningHandle ; BucketFunctionType bucketFunctionType = handle . getBucketFunctionType ( ) ; switch ( bucketFunctionType ) { case HIVE_COMPATIBLE : return createHiveCompatibleBucketFunction ( bucketCount , handle . getHiveTypes ( ) . get ( ) ) ; case PRESTO_NATIVE : return createPrestoNativeBucketFunction ( bucketCount , handle . getTypes ( ) . get ( ) ) ; default : throw new IllegalArgumentException ( "Unsupported bucket function type " + bucketFunctionType ) ; } }
response: public BucketFunction getBucketFunction( ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorPartitioningHandle partitioningHandle, List<Type> partitionChannelTypes, int bucketCount) { HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle; BucketFunctionType bucketFunctionType = handle.getBucketFunctionType(); switch (bucketFunctionType) { case HIVE_COMPATIBLE: return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get()); case PRESTO_NATIVE: return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get()); default: <START> throw new IllegalArgumentException("Unsupported bucket function type " + bucketFunctionType); <END> } }

sample: 868
buggy_code: public void writePacketData(RailcraftOutputStream data) throws IOException { super.writePacketData(data); <START> tankManager.writePacketData(data); <END> data.writeBoolean(boiler.isBurning()); }
code_review: This is only required in things that render the FluidStack in a TESR.
target code: public void writePacketData ( RailcraftOutputStream data ) throws IOException { super . writePacketData ( data ) ; // tankManager . writePacketData ( data ) ; data . writeBoolean ( boiler . isBurning ( ) ) ; }
response: public void writePacketData(RailcraftOutputStream data) throws IOException { super.writePacketData(data); <START> data.writeFluidStack(tank.getFluid()); <END> data.writeBoolean(boiler.isBurning()); }

sample: 869
buggy_code: protected void setValue(final int rowIndex, final int columnIndex, final Date value) { DTCellValue52 dtCellValue52 = table52.getData() .get(rowIndex) .get(columnIndex); dtCellValue52 .setDateValue(value); try { updateManager.update(table52, getUpdates(rowIndex, columnIndex)); <START> } catch (UpdateException e) { <END> e.printStackTrace(); } }
code_review: This _smells_ bad.. what was your reasoning to catch `UpdateException`?
target code: protected void setValue ( final int rowIndex , final int columnIndex , final Date value ) { DTCellValue52 dtCellValue52 = table52 . getData ( ) . get ( rowIndex ) . get ( columnIndex ) ; dtCellValue52 . setDateValue ( value ) ; updateManager . update ( table52 , getUpdates ( rowIndex , columnIndex ) ) ; }
response: protected void setValue(final int rowIndex, final int columnIndex, final Date value) { DTCellValue52 dtCellValue52 = table52.getData() .get(rowIndex) .get(columnIndex); dtCellValue52 .setDateValue(value); try { updateManager.update(table52, getUpdates(rowIndex, columnIndex)); <START> } catch (UpdateException e) { <END> e.printStackTrace(); } }

sample: 870
buggy_code: private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) { return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent, <START> () -> new TreeMap<>(Comparator.comparing(Event::getExternalId).thenComparing(Event::getWhenOccured)), Collectors.toList())); <END> }
code_review: ```suggestion () -> new TreeMap<>(Comparator.comparing(Event::getWhenOccured).thenComparing(Event::getExternalId)), Collectors.toList())); ```
target code: private TreeMap < Event , List < EntryDTO > > buildEventEntryDTOMap ( List < EntryDTO > entryDTOS ) { return entryDTOS . stream ( ) . collect ( Collectors . groupingBy ( EntryDTO : : getEvent , ( ) - > new TreeMap < > ( Comparator . comparing ( Event : : getWhenOccured ) . thenComparing ( Event : : getExternalId ) ) , Collectors . toList ( ) ) ) ; }
response: private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) { return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent, <START> () -> new TreeMap<>(Comparator.comparing(Event::getWhenOccured).thenComparing(Event::getExternalId)), Collectors.toList())); <END> }

sample: 871
buggy_code: <START> public void verifyTableProperty(String propertyName, int propertyValue) { <END> waitForElementByElement(table); Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue)); PageObjectLogging.log( "verifyTableProperty", "table has correct " + propertyName + " property", true ); }
code_review: 1. set this method to private, 2. create helpers for each property
target code: private void verifyTableProperty ( String propertyName , int propertyValue ) { waitForElementByElement ( table ) ; Assertion . assertEquals ( table . getAttribute ( propertyName ) , Integer . toString ( propertyValue ) ) ; PageObjectLogging . log ( "verifyTableProperty" , "table has correct " + propertyName + " property" , true ) ; }
response: <START> private void verifyTableProperty(String propertyName, int propertyValue) { <END> waitForElementByElement(table); Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue)); PageObjectLogging.log( "verifyTableProperty", "table has correct " + propertyName + " property", true ); }

sample: 872
buggy_code: public ColumnMetadata_v4(String[] name, PrimitiveType.PrimitiveTypeName primitiveType, Object minValue, Object maxValue, Long nulls) { <START> this.name = name; <END> this.minValue = minValue; this.maxValue = maxValue; this.nulls = nulls; this.primitiveType = primitiveType; }
code_review: Please post the examples of content for new metadata cache files to the Jira description
target code: public ColumnMetadata_v4 ( String [ ] name , PrimitiveType . PrimitiveTypeName primitiveType , Object minValue , Object maxValue , Long nulls ) { super ( name , primitiveType , minValue , maxValue , nulls ) ; }
response: public void set(int index, int value) { <START> if (index < 0 || index >= size) { throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size); } <END> array[index] = value; }

sample: 873
buggy_code: <START> @Override public <END> ReflogEntry getReverseEntry(int number) throws IOException { lock.lock(); try { LogCursor cursor = reftable.seekLog(refname); while (true) { if (!cursor.next() || number < 0) { return null; } if (number == 0) { return cursor.getReflogEntry(); } number--; } } finally { lock.unlock(); } }
code_review: The @Override should go on a line on its own, like in getReverseEntries() and the same below.
target code: public ReflogEntry getReverseEntry ( int number ) throws IOException { lock . lock ( ) ; try { LogCursor cursor = reftable . seekLog ( refname ) ; while ( true ) { if ( ! cursor . next ( ) || number < 0 ) { return null ; } if ( number == 0 ) { return cursor . getReflogEntry ( ) ; } number -- ; } } finally { lock . unlock ( ) ; } }
response: <START> @Override public ReflogEntry getReverseEntry(int number) throws IOException { lock.lock(); try { LogCursor cursor = reftable.seekLog(refname); while (true) { if (!cursor.next() || number < 0) { return null; } if (number == 0) { return cursor.getReflogEntry(); } number--; } } finally { lock.unlock(); } } <END>

sample: 874
buggy_code: public void testVersion0_98IsValid() throws Exception{ rootDir = Paths.get(getClass().getClassLoader().getResource("bags/v0_98/bag").toURI()); if (System.getProperty("os.name").contains("Windows")){ <START> Path bagitDir = rootDir.resolve(".bagit"); <END> Files.setAttribute(bagitDir, "dos:hidden", Boolean.TRUE); } Bag bag = reader.read(rootDir); sut.isValid(bag, true); }
code_review: the .bagit folder does not have to be hidden. .bagit is our incubating next version of the bagit spec; it solves a lot of problems from the originial spec.
target code: public void testVersion0_98IsValid ( ) throws Exception { rootDir = Paths . get ( getClass ( ) . getClassLoader ( ) . getResource ( "bags / v0_98 / bag" ) . toURI ( ) ) ; Bag bag = reader . read ( rootDir ) ; sut . isValid ( bag , true ) ; }
response: public void testVersion0_98IsValid() throws Exception{ rootDir = Paths.get(getClass().getClassLoader().getResource("bags/v0_98/bag").toURI()); if (System.getProperty("os.name").contains("Windows")){ Path bagitDir = rootDir.resolve(".bagit"); Files.setAttribute(bagitDir, "dos:hidden", Boolean.TRUE); } Bag bag = reader.read(rootDir); sut.isValid(bag, true); }

sample: 875
buggy_code: public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) { <START> final AbstractStatementVisitor visitor = new PreStatementVisitor(context); <END> syntaxNode.accept(visitor); return visitor.programState; }
code_review: remove `final` modifiers everywhere.
target code: public ProgramState checkPreStatement ( CheckerContext context , Tree syntaxNode ) { AbstractStatementVisitor visitor = new PreStatementVisitor ( context ) ; syntaxNode . accept ( visitor ) ; return visitor . programState ; }
response: public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) { <START> AbstractStatementVisitor visitor = new PreStatementVisitor(context); <END> syntaxNode.accept(visitor); return visitor.programState; }

sample: 876
buggy_code: <START> ParameterMap getQueryParams(MuleEvent event) <END> { return resolveParams(event, HttpParamType.QUERY_PARAM); }
code_review: This breaks compatibility.
target code: public ParameterMap getQueryParams ( MuleEvent event ) { return resolveParams ( event , HttpParamType . QUERY_PARAM ) ; }
response: <START> ParameterMap getQueryParams(MuleEvent event) <END> { return resolveParams(event, HttpParamType.QUERY_PARAM); }

sample: 877
buggy_code: public Mutation(Mutation m) { m.serialize(); this.row = m.row; this.data = m.data; <START> this.size = new MutationSize(m.size.entries, m.size.sizeInBytes); <END> this.values = m.values; this.replicationSources = m.replicationSources; }
code_review: maybe make a copy constructor for this case?
target code: public Mutation ( Mutation m ) { m . serialize ( ) ; this . row = m . row ; this . data = m . data ; this . entries = m . entries ; this . values = m . values ; this . replicationSources = m . replicationSources ; }
response: public Mutation(Mutation m) { m.serialize(); this.row = m.row; this.data = m.data; <START> this.size = new MutationSize(m.size); <END> this.values = m.values; this.replicationSources = m.replicationSources; }

sample: 878
buggy_code: public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) { <START> this(delegate, classLoader, null, null); <END> }
code_review: The last `null` is interpreted as a null `Flag`, not as a null `Flag[]`, and is causing some NPEs in the test suite: http://ci.infinispan.org/viewLog.html?buildId=6702&buildTypeId=bt9
target code: public DecoratedCache ( AdvancedCache < K , V > delegate , ClassLoader classLoader ) { this ( delegate , classLoader , null ) ; }
response: public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) { <START> this(delegate, classLoader, null, (Flag[]) null); <END> }

sample: 879
buggy_code: default Query getRemoveByQuery() { <START> if (isVersionedEntity()) { <END> return getQueryForVersion(); } return getByIdQuery(); }
code_review: Ternary ? true : false. ;)
target code: default Query getRemoveByQuery ( ) { return isVersionedEntity ( ) ? getQueryForVersion ( ) : getByIdQuery ( ) ; }
response: default Query getRemoveByQuery() { <START> return isVersionedEntity() ? getQueryForVersion() : getByIdQuery(); <END> }

sample: 880
buggy_code: <START> public void addError(String errorMessage, Element element) { <END> errors.add(new ProblemImpl(errorMessage, name, element)); }
code_review: There are still a lot of calls to this method, resulting in errors that will not reference any BPMN element. From a quick look, many of those do have an element id that we could reference.
target code: public void addError ( String errorMessage , Element element ) { errors . add ( new ProblemImpl ( errorMessage , element ) ) ; }
response: <START> public void addError(String errorMessage, Element element) { <END> errors.add(new ProblemImpl(errorMessage, name, element)); }

sample: 881
buggy_code: private void validatePage() { String message = null; if (userText.getText().trim().length() == 0) message = Messages.CredentialsWizardPage_ErrorUser; <START> if (message == null && passwordText.getText().trim().length() == 0) <END> message = Messages.CredentialsWizardPage_ErrorPassword; setErrorMessage(message); setPageComplete(message == null); }
code_review: Suggestion: Use an else-if for these two and provide the missing braces. And instead of length() == 0 I'd use isEmpty().
target code: private void validatePage ( ) { String message = null ; if ( userText . getText ( ) . trim ( ) . isEmpty ( ) ) { message = Messages . CredentialsWizardPage_ErrorUser ; } else if ( passwordText . getText ( ) . trim ( ) . isEmpty ( ) ) { message = Messages . CredentialsWizardPage_ErrorPassword ; } setErrorMessage ( message ) ; setPageComplete ( message == null ) ; }
response: private void validatePage() { String message = null; if (userText.getText().trim().isEmpty()) { message = Messages.CredentialsWizardPage_ErrorUser; } <START> else if (message == null && passwordText.getText().trim().isEmpty()) <END> { message = Messages.CredentialsWizardPage_ErrorPassword; } setErrorMessage(message); setPageComplete(message == null); }

sample: 882
buggy_code: public boolean isSupporting(Capabilities capabilities) { return BrowserType.EDGE.equals(capabilities.getBrowserName()) || capabilities.getCapability("chromeOptions") != null || <START> capabilities.getCapability("goog:chromeOptions") != null; <END> }
code_review: You probably don't want to pick this if `browserName` is also `chrome` or `chromium`, right? Otherwise this will match: `{"browserName": "chrome", "goog:chromeOptions": {}}`, which isn't what you want.
target code: public boolean isSupporting ( Capabilities capabilities ) { return BrowserType . EDGE . equals ( capabilities . getBrowserName ( ) ) ; }
response: public boolean isSupporting(Capabilities capabilities) { return BrowserType.EDGE.equals(capabilities.getBrowserName()) || capabilities.getCapability("chromeOptions") != null || <START> BrowserType.CHROME.equals(capabilities.getBrowserName()) || BrowserType.CHROMIUM.equals(capabilities.getBrowserName()) || capabilities.getCapability("goog:chromeOptions") != null; <END> }

sample: 883
buggy_code: public HistoryTreeStub getHistoryTree() { <START> return (HistoryTreeStub) NonNullUtils.checkNotNull(super.getSHT()); <END> }
code_review: getSHT() can never actually be null, we should just annotate it.
target code: public HistoryTreeStub getHistoryTree ( ) { return ( HistoryTreeStub ) super . getSHT ( ) ; }
response: public HistoryTreeStub getHistoryTree() { <START> return (HistoryTreeStub) super.getSHT(); <END> }

sample: 884
buggy_code: public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) { return <START> Lists.newArrayList(Iterables.filter(Iterables.concat(trace.getEventAspects(), <END> EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass()))); }
code_review: why the newArrayList? Iterables.filter already returns an iterable.
target code: public static Iterable < ITmfEventAspect < ? > > getEventAspects ( ITmfTrace trace , Class < ? extends ITmfEventAspect < ? > > aspectClass ) { return Iterables . filter ( Iterables . concat ( trace . getEventAspects ( ) , EXTRA_ASPECTS ) , aspect - > aspectClass . isAssignableFrom ( aspect . getClass ( ) ) ) ; }
response: public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) { return <START> Iterables.filter(Iterables.concat(trace.getEventAspects(), <END> EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass())); }

sample: 885
buggy_code: public PrestoSparkRow get() throws InterruptedException { PrestoSparkRow row; synchronized (monitor) { while (!finished && buffer.isEmpty()) { <START> monitor.wait(); <END> } if (finished) { return null; } row = buffer.poll(); } memoryManager.updateMemoryUsage(-row.getRetainedSize()); return row; }
code_review: So `PrestoSparkRowBuffer#get` is a blocked call. Is there any reason for that -- I am asking this since the general convention in Presto seems to be using `ListenableFuture<PrestoSparkRow>` for such cases?
target code: public PrestoSparkRow get ( ) throws InterruptedException { PrestoSparkRow row = null ; synchronized ( monitor ) { while ( buffer . isEmpty ( ) && ! finished ) { monitor . wait ( ) ; } if ( ! buffer . isEmpty ( ) ) { row = buffer . poll ( ) ; } } if ( row != null ) { memoryManager . updateMemoryUsage ( - row . getRetainedSize ( ) ) ; } return row ; }
response: public PrestoSparkRow get() throws InterruptedException { PrestoSparkRow row; synchronized (monitor) { while (!finished && buffer.isEmpty()) { <START> monitor.wait(); <END> } if (finished) { return null; } row = buffer.poll(); } memoryManager.updateMemoryUsage(-row.getRetainedSize()); return row; }

sample: 886
buggy_code: private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException { ByteBuffer pcapPacketData; pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <START> pcapPacketData.position(PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <END> pcapPacketData.clear(); SeekableByteChannel fFileChannel; try { fFileChannel = getFileChannel(); fFileChannel.read(pcapPacketData); } catch (BadPcapFileException e1) { /* Just ignore */ } pcapPacketData.flip(); return pcapPacketData; }
code_review: This is useless since clear() below resets position to zero?
target code: private ByteBuffer parsePacketIDBAndNRB ( int blockLength ) throws IOException { ByteBuffer pcapPacketData ; pcapPacketData = ByteBuffer . allocate ( blockLength - PcapFileValues . PCAPNG_PACKET_HEADER_SIZE ) ; pcapPacketData . clear ( ) ; SeekableByteChannel fFileChannel ; try { fFileChannel = getFileChannel ( ) ; fFileChannel . read ( pcapPacketData ) ; } catch ( BadPcapFileException e1 ) { /* Just ignore */ } pcapPacketData . flip ( ) ; return pcapPacketData ; }
response: private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException { ByteBuffer pcapPacketData; pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <START> pcapPacketData.position(PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <END> pcapPacketData.clear(); SeekableByteChannel fFileChannel; try { fFileChannel = getFileChannel(); fFileChannel.read(pcapPacketData); } catch (BadPcapFileException e1) { /* Just ignore */ } pcapPacketData.flip(); return pcapPacketData; }

sample: 887
buggy_code: public MiniEditorComponentObject triggerEditCommentArea() { jsActions.scrollToElement(allCommentsArea); WebElement mostRecentComment = articleComments.get(0); PageObjectLogging.log("First check",mostRecentComment.getText(), true); JavascriptExecutor js = (JavascriptExecutor) driver; WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR)); <START> Actions actions = new Actions(driver); <END> actions.moveToElement(editButton).perform(); js.executeScript("arguments[0].querySelector(arguments[1]).click()", mostRecentComment, EDIT_BUTTON_SELECTOR); return new MiniEditorComponentObject(driver); }
code_review: merge into one line
target code: public MiniEditorComponentObject triggerEditCommentArea ( ) { jsActions . scrollToElement ( allCommentsArea ) ; WebElement mostRecentComment = articleComments . get ( 0 ) ; PageObjectLogging . log ( "First check" , mostRecentComment . getText ( ) , true ) ; JavascriptExecutor js = ( JavascriptExecutor ) driver ; WebElement editButton = mostRecentComment . findElement ( By . cssSelector ( EDIT_BUTTON_SELECTOR ) ) ; new Actions ( driver ) . moveToElement ( editButton ) . perform ( ) ; js . executeScript ( "arguments [ 0 ] . querySelector ( arguments [ 1 ] ) . click ( ) " , mostRecentComment , EDIT_BUTTON_SELECTOR ) ; return new MiniEditorComponentObject ( driver ) ; }
response: public MiniEditorComponentObject triggerEditCommentArea() { jsActions.scrollToElement(allCommentsArea); WebElement mostRecentComment = articleComments.get(0); PageObjectLogging.log("First check",mostRecentComment.getText(), true); JavascriptExecutor js = (JavascriptExecutor) driver; WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR)); <START> Actions actions = new Actions(driver); actions.moveToElement(editButton).perform(); <END> js.executeScript("arguments[0].querySelector(arguments[1]).click()", mostRecentComment, EDIT_BUTTON_SELECTOR); return new MiniEditorComponentObject(driver); }

sample: 888
buggy_code: public String getContentAccessModeList() { String[] modeList = contentAccessModeList == null ? new String[0] : contentAccessModeList.split(","); String ammend = ""; <START> if (!ArrayUtils.contains(modeList, ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE)) { <END> ammend = modeList.length > 0 ? "," : ""; ammend += ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE; } return modeList.length > 0 ? this.contentAccessModeList + ammend : ammend; }
code_review: @wottop Would this mean that the "entitlement" mode is always included? Even if a mode list has been set on the owner that did not include it? If so, that does not seem right as it is valid to set the list to not contain entitlements as an option, just that if the list is empty that means it should be set to entitlement.
target code: public String getContentAccessModeList ( ) { return this . contentAccessModeList ; }
response: public String getContentAccessModeList() { String[] modeList = contentAccessModeList == null ? new String[0] : contentAccessModeList.split(","); String ammend = ""; <START> if (!ArrayUtils.contains(modeList, ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE)) { <END> ammend = modeList.length > 0 ? "," : ""; ammend += ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE; } return modeList.length > 0 ? this.contentAccessModeList + ammend : ammend; }

sample: 889
buggy_code: public void setUp() { <START> System.setProperty("user.timezone", "UTC"); <END> TimeZone.setDefault(null); configuration = Configuration.DEFAULT; }
code_review: @timowest weird. I remembered it was failed with testing on querydls-sql module. but it's gone now.
target code: public void setUp ( ) { configuration = Configuration . DEFAULT ; }
response: public void setUp() { <START> System.setProperty("user.timezone", "UTC"); <END> TimeZone.setDefault(null); configuration = Configuration.DEFAULT; }

sample: 890
buggy_code: public void onDestroyView() { mWebViewStateOnDestroyView = new Bundle(); try { storeWebView(mWebViewStateOnDestroyView); <START> mWebViewBridge.destroy(); <END> } catch (Exception exp) { Log.w(TAG, exp.getMessage() + "", exp); } super.onDestroyView(); }
code_review: mWebViewStateOnDestroyView mWebViewBridge.destroy(); mWebViewBridge =null; 
target code: public void onDestroyView ( ) { try { mWebViewBridge . destroy ( ) ; } catch ( Exception exp ) { Log . w ( TAG , exp . getMessage ( ) + "" , exp ) ; } mWebViewBridge = null ; super . onDestroyView ( ) ; }
response: public void onDestroyView() { mWebViewStateOnDestroyView = new Bundle(); try { storeWebView(mWebViewStateOnDestroyView); <START> mWebViewBridge.destroy(); mWebViewBridge =null; <END> } catch (Exception exp) { Log.w(TAG, exp.getMessage() + "", exp); } super.onDestroyView(); }

sample: 891
buggy_code: private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive) { try { hdfsEnvironment.getFileSystem(context, path).delete(path, recursive); } catch (Exception e) { // don't fail if unable to delete path <START> Logger.get(GlueHiveMetastore.class).warn(e, "Failed to delete path: " + path.toString()); <END> } }
code_review: Declare the logger at the top of the class: ```java private static final Logger log = Logger.get(GlueHiveMetastore.class); ``` (you might see the inline `Logger.get()` pattern in some tests, but it's not the normal way)
target code: private static void deleteDir ( HdfsContext context , HdfsEnvironment hdfsEnvironment , Path path , boolean recursive ) { try { hdfsEnvironment . getFileSystem ( context , path ) . delete ( path , recursive ) ; } catch ( Exception e ) { // don't fail if unable to delete path log . warn ( e , "Failed to delete path : " + path . toString ( ) ) ; } }
response: private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive) { try { hdfsEnvironment.getFileSystem(context, path).delete(path, recursive); } catch (Exception e) { // don't fail if unable to delete path <START> log.warn(e, "Failed to delete path: " + path.toString()); <END> } }

sample: 892
buggy_code: <START> private boolean isNakedTD1Key(String s) <END> { return NAKED_TD1_KEY_PATTERN.matcher(s).matches(); }
code_review: `private static`
target code: private static boolean isNakedTD1Key ( String s ) { return NAKED_TD1_KEY_PATTERN . matcher ( s ) . matches ( ) ; }
response: <START> private static boolean isNakedTD1Key(String s) <END> { return NAKED_TD1_KEY_PATTERN.matcher(s).matches(); }

sample: 893
buggy_code: public long skip(long n) throws IOException { if (n <= 0) { return 0; } if (n > MOVEMENT_LIMIT) { mSequentialReadCount = 0; } else { <START> ((Seekable) in).seek(mPos + n); <END> } mPos += n; return n; }
code_review: nit: for readability i prefer a method called `isSequentialReadMode` to determine whether to seek or not
target code: public long skip ( long n ) throws IOException { if ( n <= 0 ) { return 0 ; } if ( n > MOVEMENT_LIMIT ) { mSequentialReadCount = 0 ; } mPos += n ; return n ; }
response: public long skip(long n) throws IOException { if (n <= 0) { return 0; } if (n > MOVEMENT_LIMIT) { mSequentialReadCount = 0; } else { <START> ((Seekable) in).seek(mPos + n); <END> } mPos += n; return n; }

sample: 894
buggy_code: public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { <START> Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); <END> assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE); }
code_review: Missing assertNotNull for executionSet here.
target code: public void testUnmarshallSubprocessLevelEventEmptyProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_START_EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartNoneEvent emptySubprocess = getStartNodeById ( diagram , EMPTY_SUBPROCESS_LEVEL_EVENT_ID , StartNoneEvent . class ) ; assertGeneralSet ( emptySubprocess . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertNotNull ( emptySubprocess . getExecutionSet ( ) ) ; assertStartEventSlaDueDate ( emptySubprocess . getExecutionSet ( ) , EMPTY_VALUE ) ; }
response: public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { <START> Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); <END> assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertNotNull(emptySubprocess.getExecutionSet()); assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE); }

sample: 895
buggy_code: private List<Window> fetchWindowsInQueue() { List<Window> windows = Lists.newArrayList(getWindows()); <START> return ImmutableList.copyOf(Lists.reverse(windows)); <END> }
code_review: Remove the reversal here, and let the JDK 8 implementation return it in reverse, and the JDK 9 implementation *not* reversed.
target code: private List < Window > fetchWindowsInQueue ( ) { return ImmutableList . copyOf ( getWindows ( ) ) ; }
response: private List<Window> fetchWindowsInQueue() { List<Window> windows = Lists.newArrayList(getWindows()); <START> return ImmutableList.copyOf(windows); <END> }

sample: 896
buggy_code: protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException { <START> try { executor.startFB(resource, new FBDeploymentData("", resFB)); //$NON-NLS-1$ //TODO correctly determine prefix } catch (DeploymentException e) { throw e; } <END> }
code_review: what is the point of catching the exception here?
target code: protected void executeCommand ( IDeviceManagementInteractor executor ) throws DeploymentException { executor . startFB ( resource , new FBDeploymentData ( "" , resFB ) ) ; // $NON - NLS - 1$ // TODO correctly determine prefix }
response: protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException { <START> executor.startFB(resource, new FBDeploymentData("", resFB)); //$NON-NLS-1$ //TODO correctly determine prefix <END> }

sample: 897
buggy_code: <START> void setReaderBudget() <END> { reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes); }
code_review: Make this method private.
target code: private void setReaderBudget ( ) { reader . setResultSizeBudget ( ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes ) ; }
response: <START> private void setReaderBudget() <END> { reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes); }

sample: 898
buggy_code: <START> default <T> Flux<SearchHit<T>> find(Query query, Class<T> entityType) { <END> return find(query, entityType, entityType); }
code_review: Same as with the imperative template: Shouldn't we just deprecate these methods and introduce `Flux<SearchHit<T>> search()`?
target code: default < T > Flux < T > find ( Query query , Class < T > entityType ) { return find ( query , entityType , entityType ) ; }
response: <START> default <T> Flux<SearchHit<T>> find(Query query, Class<T> entityType) { <END> return search(query, entityType, entityType); }

sample: 899
buggy_code: public Object execute(ExecutionEvent event) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard( util.getConfiguredRepositories(), <START> false); <END> WizardDialog dialog = new WizardDialog(getShell(event), wizard); if (dialog.open() == Window.OK) { for (String dir : wizard.getDirectories()) { File repositoryDir = FileUtils.canonicalize(new File(dir)); addRepository(repositoryDir); } } return null; }
code_review: True, now.
target code: public Object execute ( ExecutionEvent event ) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard ( util . getConfiguredRepositories ( ) , true ) ; WizardDialog dialog = new WizardDialog ( getShell ( event ) , wizard ) ; if ( dialog . open ( ) == Window . OK ) { for ( String dir : wizard . getDirectories ( ) ) { File repositoryDir = FileUtils . canonicalize ( new File ( dir ) ) ; addRepository ( repositoryDir ) ; } } return null ; }
response: public Object execute(ExecutionEvent event) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard( util.getConfiguredRepositories(), <START> false); <END> WizardDialog dialog = new WizardDialog(getShell(event), wizard); if (dialog.open() == Window.OK) { for (String dir : wizard.getDirectories()) { File repositoryDir = FileUtils.canonicalize(new File(dir)); addRepository(repositoryDir); } } return null; }

sample: 900
buggy_code: public Map<String, String> load() { final Map<String, String> preferences = new HashMap<String, String>(); <START> final String property = System.getProperty( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED ); <END> log.info( "Setting preference '" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + "' to '" + property + "'." ); preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED, property ); return preferences; }
code_review: We normally check if this is `null` and only set if non-null... IDK if your code handles `null` differently?
target code: public Map < String , String > load ( ) { final Map < String , String > preferences = new HashMap < String , String > ( ) ; final String property = getProperty ( ) ; log . info ( "Setting preference '" + GuidedDecisionTableEditorService . DTABLE_VERIFICATION_ENABLED + "' to '" + property + "' . " ) ; preferences . put ( GuidedDecisionTableEditorService . DTABLE_VERIFICATION_ENABLED , property ) ; return preferences ; }
response: public Map<String, String> load() { final Map<String, String> preferences = new HashMap<String, String>(); <START> final String property = System.getProperty( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED ); if ( property != null ) { <END> log.info( "Setting preference '" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + "' to '" + property + "'." ); preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED, property ); } return preferences; }

sample: 901
buggy_code: protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) { if (m_grouping.parallelScheduler != null) { int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism; if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) { <START> taskParallelism = ctx.getDefaultMaxDegreeOfParallelism(); <END> } } return defaultValue; }
code_review: I think you need to return `taskParallelism` here b/c if the value specified as the max degree != `DEFAULT_MAX_DEGREE_OF_PARALLELISM`, then we return `1`, not, say `40`
target code: protected int getParallelHostCount ( UpgradeContext ctx , int defaultValue ) { if ( m_grouping . parallelScheduler != null ) { int taskParallelism = m_grouping . parallelScheduler . maxDegreeOfParallelism ; if ( taskParallelism == ParallelScheduler . DEFAULT_MAX_DEGREE_OF_PARALLELISM ) { taskParallelism = ctx . getDefaultMaxDegreeOfParallelism ( ) ; } return taskParallelism ; } return defaultValue ; }
response: protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) { if (m_grouping.parallelScheduler != null) { int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism; if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) { <START> taskParallelism = ctx.getDefaultMaxDegreeOfParallelism(); <END> } else { return taskParallelism; } } return defaultValue; }

sample: 902
buggy_code: <START> public static boolean stopIfIsPlaying(@Nullable AudioSlide slide) { <END> if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) { playing.get().stop(); return true; } else { return false; } }
code_review: think this has to be synchronized
target code: public synchronized static boolean stopIfIsPlaying ( @Nullable AudioSlide slide ) { if ( playing . isPresent ( ) && playing . get ( ) . getAudioSlide ( ) . equals ( slide ) ) { playing . get ( ) . stop ( ) ; return true ; } else { return false ; } }
response: <START> public static synchronized boolean stopIfIsPlaying(@Nullable AudioSlide slide) { <END> if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) { playing.get().stop(); return true; } else { return false; } }

sample: 903
buggy_code: public List<AggregatorFactory> getRequiredColumns() { return fields.stream() .map( input -> new CardinalityAggregatorFactory( input.getOutputName(), null, Collections.singletonList(input), byRow, round ) <START> ).collect(Collectors.toList()); <END> }
code_review: Line should be breaked after `)`
target code: public List < AggregatorFactory > getRequiredColumns ( ) { return fields . stream ( ) . map ( field - > new CardinalityAggregatorFactory ( field . getOutputName ( ) , null , Collections . singletonList ( field ) , byRow , round ) ) . collect ( Collectors . toList ( ) ) ; }
response: public List<AggregatorFactory> getRequiredColumns() { return fields.stream() .map( input -> new CardinalityAggregatorFactory( input.getOutputName(), null, Collections.singletonList(input), byRow, round ) <START> ) .collect(Collectors.toList()); <END> }

sample: 904
buggy_code: <START> public Optional getRequestAttribute(final String name) { <END> return Optional.ofNullable(this.request.getAttribute(name)); }
code_review: add the type parameter even if it's object
target code: public Optional < Object > getRequestAttribute ( final String name ) { return Optional . ofNullable ( this . request . getAttribute ( name ) ) ; }
response: <START> public Optional<Object> getRequestAttribute(final String name) { <END> return Optional.ofNullable(this.request.getAttribute(name)); }

sample: 905
buggy_code: <START> public static String reflogComments(List<ReflogEntry> entries) { <END> StringBuffer b = new StringBuffer(); for (ReflogEntry e : entries) { b.append(e.getComment()).append(";"); } return b.toString(); }
code_review: this method doesn't need to be public
target code: private static String reflogComments ( List < ReflogEntry > entries ) { StringBuffer b = new StringBuffer ( ) ; for ( ReflogEntry e : entries ) { b . append ( e . getComment ( ) ) . append ( " ; " ) ; } return b . toString ( ) ; }
response: <START> static String reflogComments(List<ReflogEntry> entries) { <END> StringBuffer b = new StringBuffer(); for (ReflogEntry e : entries) { b.append(e.getComment()).append(";"); } return b.toString(); }

sample: 906
buggy_code: private static boolean validateName(String value) throws WSSecurityException { Name name; try { name = new LdapName(value); } catch (Exception e) { LOG.info("Validation of X509 Subject Name failed: {}", e.getLocalizedMessage(), e); throw new WSSecurityException(ErrorCode.FAILURE, "Not a valid X509 Subject Name."); } <START> return name != null; <END> }
code_review: The return value is never used.
target code: private static void validateName ( String value ) throws WSSecurityException { Name name ; try { name = new LdapName ( value ) ; } catch ( Exception e ) { LOG . info ( "Validation of X509 Subject Name failed : { } " , e . getLocalizedMessage ( ) , e ) ; throw new WSSecurityException ( ErrorCode . FAILURE , "Not a valid X509 Subject Name . " ) ; } }
response: private static boolean validateName(String value) throws WSSecurityException { Name name; try { name = new LdapName(value); } catch (Exception e) { LOG.info("Validation of X509 Subject Name failed: {}", e.getLocalizedMessage(), e); throw new WSSecurityException(ErrorCode.FAILURE, "Not a valid X509 Subject Name."); } <START> return true; <END> }

sample: 907
buggy_code: private static SimpleFeatureCollection parseGeoJSON(InputStream in, CoordinateReferenceSystem crs) throws IOException { Map<String, Object> geojson = OM.readValue(in, TYPE_REF); <START> in.close(); <END> SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs); return GeoJSONReader2.toFeatureCollection(geojson, schema); }
code_review: Move close() to a finally-block?
target code: private static SimpleFeatureCollection parseGeoJSON ( InputStream in , CoordinateReferenceSystem crs ) throws IOException { Map < String , Object > geojson = OM . readValue ( in , TYPE_REF ) ; SimpleFeatureType schema = GeoJSONSchemaDetector . getSchema ( geojson , crs ) ; return GeoJSONReader2 . toFeatureCollection ( geojson , schema ) ; }
response: private static SimpleFeatureCollection parseGeoJSON(InputStream in, CoordinateReferenceSystem crs) throws IOException { Map<String, Object> geojson = OM.readValue(in, TYPE_REF); <START> try { SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs); return GeoJSONReader2.toFeatureCollection(geojson, schema); } finally { in.close(); } <END> }

sample: 908
buggy_code: private void refreshHostStorage(Guid hostId) { getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, StorageType.ISCSI, Boolean.FALSE)); <START> } <END>
code_review: Worth checking if we really need this method at all, although probably not in THIS patch. Regardless, why use Boolean.FALSE and not a primitive false?
target code: private void refreshHostStorage ( Guid hostId ) { getBackendCollection ( VdcQueryType . GetDeviceList , new GetDeviceListQueryParameters ( hostId , StorageType . ISCSI , false , null ) ) ; }
response: private void refreshHostStorage(Guid hostId) { getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, StorageType.ISCSI, false)); <START> } <END>

sample: 909
buggy_code: public void openTestShells() { Display.syncExec(() -> { for (int i = 1; i <= TEST_SHELLS_COUNT; i++) { String shellTitle = "shell" + i; ShellTestUtils.createShell(shellTitle); <START> shells.add(new DefaultShell(shellTitle)); <END> } }); }
code_review: do not create new DefaultShell inside syncexec
target code: public void openTestShells ( ) { for ( int i = 1 ; i <= TEST_SHELLS_COUNT ; i ++ ) { String shellTitle = "shell" + i ; Display . syncExec ( ( ) - > { ShellTestUtils . createShell ( shellTitle ) ; } ) ; shells . add ( new DefaultShell ( shellTitle ) ) ; } }
response: public void openTestShells() { Display.syncExec(() -> { for (int i = 1; i <= TEST_SHELLS_COUNT; i++) { String shellTitle = "shell" + i; ShellTestUtils.createShell(shellTitle); <START> shells.add(shellTitle); <END> } }); }

sample: 910
buggy_code: <START> public RangeColumnStatistics( <END> Optional<Object> lowValue, Optional<Object> highValue, Estimate fraction, Estimate dataSize, Estimate distinctValuesCount) { this.lowValue = requireNonNull(lowValue, "lowValue can not be null"); this.highValue = requireNonNull(highValue, "highValue can not be null"); requireNonNull(fraction, "fraction can not be null"); requireNonNull(dataSize, "dataSize can not be null"); requireNonNull(distinctValuesCount, "distinctValuesCount can not be null"); this.statistics = createStatisticsMap(dataSize, fraction, distinctValuesCount); }
code_review: I do not think it should be public. IMO it should only called from `Builder`.
target code: private RangeColumnStatistics ( Optional < Object > lowValue , Optional < Object > highValue , Estimate fraction , Estimate dataSize , Estimate distinctValuesCount ) { this . lowValue = requireNonNull ( lowValue , "lowValue can not be null" ) ; this . highValue = requireNonNull ( highValue , "highValue can not be null" ) ; this . fraction = requireNonNull ( fraction , "fraction can not be null" ) ; this . dataSize = requireNonNull ( dataSize , "dataSize can not be null" ) ; this . distinctValuesCount = requireNonNull ( distinctValuesCount , "distinctValuesCount can not be null" ) ; }
response: <START> RangeColumnStatistics( <END> Optional<Object> lowValue, Optional<Object> highValue, Estimate fraction, Estimate dataSize, Estimate distinctValuesCount) { this.lowValue = requireNonNull(lowValue, "lowValue can not be null"); this.highValue = requireNonNull(highValue, "highValue can not be null"); requireNonNull(fraction, "fraction can not be null"); requireNonNull(dataSize, "dataSize can not be null"); requireNonNull(distinctValuesCount, "distinctValuesCount can not be null"); this.statistics = createStatisticsMap(dataSize, fraction, distinctValuesCount); }

sample: 911
buggy_code: public void close() { log.debug("Closing record collector"); if (eosEnabled) { streamsProducer.abortTransaction(); } <START> streamsProducer.flush(); <END> checkForException(); }
code_review: Sounds reasonable to me
target code: public void close ( ) { log . debug ( "Closing record collector" ) ; if ( eosEnabled ) { streamsProducer . abortTransaction ( ) ; } checkForException ( ) ; }
response: public void close() { log.debug("Closing record collector"); if (eosEnabled) { streamsProducer.abortTransaction(); } <START> streamsProducer.flush(); <END> checkForException(); }

sample: 912
buggy_code: public static FileSystemContext create(ClientContext clientContext) { FileSystemContext ctx = new FileSystemContext(); ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf())); <START> ctx.mUriValidationEnabled = clientContext.getUriValidationEnabled(); <END> return ctx; }
code_review: set this in `initContext` instead?
target code: public static FileSystemContext create ( ClientContext clientContext ) { FileSystemContext ctx = new FileSystemContext ( ) ; ctx . init ( clientContext , MasterInquireClient . Factory . create ( clientContext . getClusterConf ( ) ) ) ; return ctx ; }
response: public static FileSystemContext create(ClientContext clientContext) { FileSystemContext ctx = new FileSystemContext(); ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf())); <START> ctx.mUriValidationEnabled = clientContext.getUriValidationEnabled(); <END> return ctx; }

sample: 913
buggy_code: private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo) { <START> return uriInfo.getBaseUriBuilder().replacePath("/v1/statement").path(queryId.toString()).path(String.valueOf(resultId.incrementAndGet())).replaceQuery("").scheme(scheme).build(); <END> }
code_review: Replace scheme first since it's first in the URL. Let's also wrap this since it's getting long: ```java return uriInfo.getBaseUriBuilder() .scheme(scheme) .replacePath("/v1/statement") .path(queryId.toString()) .path(String.valueOf(resultId.incrementAndGet())) .replaceQuery("") .build();
target code: private synchronized URI createNextResultsUri ( String scheme , UriInfo uriInfo ) { return uriInfo . getBaseUriBuilder ( ) . scheme ( scheme ) . replacePath ( " / v1 / statement" ) . path ( queryId . toString ( ) ) . path ( String . valueOf ( resultId . incrementAndGet ( ) ) ) . replaceQuery ( "" ) . build ( ) ; }
response: private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo) { <START> return uriInfo.getBaseUriBuilder() .scheme(scheme) .replacePath("/v1/statement") .path(queryId.toString()) .path(String.valueOf(resultId.incrementAndGet())) .replaceQuery("") .build(); <END> }

sample: 914
buggy_code: public void commitToFile() throws Exception { // Given afw.write(expectedContent, 0, expectedContent.length()); // When afw.commit(); // Then <START> assertTrue(Files.size(af.toPath()) == expectedContent.length()); <END> }
code_review: ``` java assertEquals(expectedContent.length(), Files.size(af.toPath())); ```
target code: public void commitToFile ( ) throws Exception { // Given afw . write ( expectedContent , 0 , expectedContent . length ( ) ) ; // When afw . commit ( ) ; // Then assertEquals ( expectedContent . length ( ) , Files . size ( af . toPath ( ) ) ) ; }
response: public void commitToFile() throws Exception { // Given afw.write(expectedContent, 0, expectedContent.length()); // When afw.commit(); // Then <START> assertEquals(expectedContent.length(), Files.size(af.toPath())); <END> }

sample: 915
buggy_code: public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) { this.columnWidthConfig.setPercentage(columnPosition, width); if <START> (fireEvent) <END> fireLayerEvent(new ColumnResizeEvent(this, columnPosition)); }
code_review: add { and }
target code: public void setColumnWidthPercentageByPosition ( int columnPosition , int width , boolean fireEvent ) { this . columnWidthConfig . setPercentage ( columnPosition , width ) ; if ( fireEvent ) { fireLayerEvent ( new ColumnResizeEvent ( this , columnPosition ) ) ; } }
response: public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) { this.columnWidthConfig.setPercentage(columnPosition, width); if <START> (fireEvent) { <END> fireLayerEvent(new ColumnResizeEvent(this, columnPosition)); } }

sample: 916
buggy_code: <START> protected void connect() throws IOException <END> { // note that we are not connecting via JMX for testing mbeanServerConn = null; jmxc = null; ssProxy = StorageService.instance; msProxy = MessagingService.instance(); streamProxy = StreamManager.instance; compactionProxy = CompactionManager.instance; fdProxy = (FailureDetectorMBean) FailureDetector.instance; cacheService = CacheService.instance; spProxy = StorageProxy.instance; hhProxy = HintedHandOffManager.instance; gcProxy = new GCInspector(); gossProxy = Gossiper.instance; memProxy = ManagementFactory.getMemoryMXBean(); runtimeProxy = ManagementFactory.getRuntimeMXBean(); }
code_review: Don't think any method is going to throw an `IOException`. We can get rid of this.
target code: protected void connect ( ) { // note that we are not connecting via JMX for testing mbeanServerConn = null ; jmxc = null ; ssProxy = StorageService . instance ; msProxy = MessagingService . instance ( ) ; streamProxy = StreamManager . instance ; compactionProxy = CompactionManager . instance ; fdProxy = ( FailureDetectorMBean ) FailureDetector . instance ; cacheService = CacheService . instance ; spProxy = StorageProxy . instance ; hhProxy = HintedHandOffManager . instance ; gcProxy = new GCInspector ( ) ; gossProxy = Gossiper . instance ; memProxy = ManagementFactory . getMemoryMXBean ( ) ; runtimeProxy = ManagementFactory . getRuntimeMXBean ( ) ; }
response: protected void connect() { // note that we are not connecting via JMX for testing mbeanServerConn = null; jmxc = null; ssProxy = StorageService.instance; msProxy = MessagingService.instance(); streamProxy = StreamManager.instance; compactionProxy = CompactionManager.instance; fdProxy = (FailureDetectorMBean) FailureDetector.instance; cacheService = CacheService.instance; spProxy = StorageProxy.instance; hhProxy = HintedHandOffManager.instance; gcProxy = new GCInspector(); gossProxy = Gossiper.instance; memProxy = ManagementFactory.getMemoryMXBean(); runtimeProxy = ManagementFactory.getRuntimeMXBean(); }

sample: 917
buggy_code: private void sortPositions(int arrayLength, Comparator<Integer> comparator) { List<Integer> list = positions.subList(0, arrayLength); try { list.sort(comparator); } catch (IllegalArgumentException e) { <START> throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Lambda comparator violates the comparator contract"); <END> } }
code_review: To clarify, this does not catch the `PrestoException` thrown from comparatorResult? Do you wan to include the thrown `e` in the new `PrestoException` created here?
target code: private void sortPositions ( int arrayLength , Comparator < Integer > comparator ) { List < Integer > list = positions . subList ( 0 , arrayLength ) ; try { list . sort ( comparator ) ; } catch ( IllegalArgumentException e ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , "Lambda comparator violates the comparator contract" , e ) ; } }
response: private void sortPositions(int arrayLength, Comparator<Integer> comparator) { List<Integer> list = positions.subList(0, arrayLength); try { list.sort(comparator); } catch (IllegalArgumentException e) { <START> throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Lambda comparator violates the comparator contract", e); <END> } }

sample: 918
buggy_code: public void deactivate() { try { httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME); } catch(IllegalArgumentException e) { <START> logger.info("LgTv Servlet '{}' was not registered. Nothing to deactivate.", WEBAPP_ALIAS + SERVLET_NAME); <END> } finally { logger.info("Stopped LgTv Servlet"); } }
code_review: debug
target code: public void deactivate ( ) { try { httpService . unregister ( WEBAPP_ALIAS + SERVLET_NAME ) ; } catch ( IllegalArgumentException e ) { logger . debug ( "LgTv Servlet ' { } ' was not registered . Nothing to deactivate . " , WEBAPP_ALIAS + SERVLET_NAME ) ; } finally { logger . info ( "Stopped LgTv Servlet" ) ; } }
response: public void deactivate() { try { httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME); } catch(IllegalArgumentException e) { <START> logger.debug("LgTv Servlet '{}' was not registered. Nothing to deactivate.", WEBAPP_ALIAS + SERVLET_NAME); <END> } finally { logger.info("Stopped LgTv Servlet"); } }

sample: 919
buggy_code: public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException { long ticketId = 1; ObjectNode json = Json.newObject(); ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME); node.add(ticketId); when(mockedBody.asJson()).thenReturn(json); Result result = ticketsController.free(); assertEquals(Helpers.OK, Helpers.status(result)); <START> verify(mockedTicketsInteractor, times(1)).freeATicket(ticketId); <END> }
code_review: times(1) is by default in verify
target code: public void freeTicketWhenExists ( TicketsInteractor mockedTicketsInteractor ) throws RecordNotFoundException , UpdateTicketStateUnauthorizedException { long ticketId = 1 ; ObjectNode json = Json . newObject ( ) ; ArrayNode node = json . putArray ( ConstantsManager . TICKET_IDS_FIELD_NAME ) ; node . add ( ticketId ) ; when ( mockedBody . asJson ( ) ) . thenReturn ( json ) ; Result result = ticketsController . free ( ) ; assertEquals ( Helpers . OK , Helpers . status ( result ) ) ; verify ( mockedTicketsInteractor ) . freeATicket ( ticketId ) ; }
response: public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException { long ticketId = 1; ObjectNode json = Json.newObject(); ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME); node.add(ticketId); when(mockedBody.asJson()).thenReturn(json); Result result = ticketsController.free(); assertEquals(Helpers.OK, Helpers.status(result)); <START> verify(mockedTicketsInteractor).freeATicket(ticketId); <END> }

sample: 920
buggy_code: private static <E> View<E> load(JobContext jobContext) { Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext); Class<E> type = getType(jobContext); String outputUri = conf.get(KITE_OUTPUT_URI); <START> DefaultConfiguration.set(conf); <END> return Datasets.<E, View<E>>load(outputUri, type); }
code_review: Should this be done in `OutputCommitter#setupTask` instead of here? This method could be called more than once, but we want to ensure we set up the environment config just one time per task. The `setupTask` methods seems like a good place, unless you have a reason to do it here?
target code: private static < E > View < E > load ( JobContext jobContext ) { Configuration conf = Hadoop . JobContext . getConfiguration . invoke ( jobContext ) ; Class < E > type = getType ( jobContext ) ; String outputUri = conf . get ( KITE_OUTPUT_URI ) ; return Datasets . < E , View < E > > load ( outputUri , type ) ; }
response: private static <E> View<E> load(JobContext jobContext) { Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext); Class<E> type = getType(jobContext); String outputUri = conf.get(KITE_OUTPUT_URI); <START> DefaultConfiguration.set(conf); <END> return Datasets.<E, View<E>>load(outputUri, type); }

sample: 921
buggy_code: public boolean validate(Map<String, String> optionsMap) { if (shouldSkip()) { return true; } if (!super.validate(optionsMap)) { return false; } if (!validatePrincipalLogin()) { <START> System.err.format("Principal login test failed.%n"); <END> return false; } return true; }
code_review: if the principal login test will already print the root cause, do we still need to print this here?
target code: public boolean validate ( Map < String , String > optionsMap ) { if ( ! super . validate ( optionsMap ) ) { return false ; } if ( ! validatePrincipalLogin ( ) ) { return false ; } return true ; }
response: public boolean validate(Map<String, String> optionsMap) { if (shouldSkip()) { return true; } if (!super.validate(optionsMap)) { return false; } if (!validatePrincipalLogin()) { return false; } return true; }

sample: 922
buggy_code: <START> public void createEdit() { <END> Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true); buttonBar.pack(); }
code_review: Done
target code: private void createEdit ( ) { Button button = createButton ( buttonparent , buttonEdit_ID , buttonEdit_caption , true ) ; buttonBar . pack ( ) ; }
response: <START> public void createEdit() { <END> Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true); buttonBar.pack(); }

sample: 923
buggy_code: <START> public E read(String line) { <END> try { return builder.makeRecord(parser.parseLine(line), null); } catch (IOException e) { throw new DatasetIOException("Cannot parse line: " + line, e); } }
code_review: This should probably just call `read(String line, E reuse)` and pass in `null` for `reuse` rather than duplicate the method.
target code: public E read ( String line ) { return read ( line , null ) ; }
response: <START> public E read(String line) { <END> return read(line, null); }

sample: 924
buggy_code: public void centerOnCurrentLocation() { followMe = true; <START> if (getMapController().getLocation() != null) { <END> findMe(); } }
code_review: Why would this not be a part of findMe method? instead of the a wrapper? Like here where the call to getLocation happens: https://github.com/mapzen/mapzen-android-demo/blob/peter/noMoToast/src/main/java/com/mapzen/fragment/MapFragment.java#L245
target code: public void centerOnCurrentLocation ( ) { followMe = true ; findMe ( ) ; }
response: public void centerOnCurrentLocation() { followMe = true; <START> findMe(); <END> }

sample: 925
buggy_code: public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider) <START> throws IOException, JsonProcessingException <END> { generator.writeBinary(sketch.toByteArray(true)); }
code_review: JsonProcessingException is not necessary.
target code: public void serialize ( final DoublesSketch sketch , final JsonGenerator generator , final SerializerProvider provider ) throws IOException { generator . writeBinary ( sketch . toByteArray ( true ) ) ; }
response: public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider) <START> throws IOException <END> { generator.writeBinary(sketch.toByteArray(true)); }

sample: 926
buggy_code: public String toString() { StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('['); <START> for (MqttTopicSubscription subscription : topicSubscriptions) { <END> builder.append(subscription).append(", "); } if (!topicSubscriptions.isEmpty()) { builder.setLength(builder.length() - 2); } return builder.append(']').toString(); }
code_review: please keep old "for loop" style to reduce GC.
target code: public String toString ( ) { StringBuilder builder = new StringBuilder ( StringUtil . simpleClassName ( this ) ) . append ( ' [ ' ) ; for ( int i = 0 ; i < topicSubscriptions . size ( ) ; i ++ ) { builder . append ( topicSubscriptions . get ( i ) ) . append ( " , " ) ; } if ( ! topicSubscriptions . isEmpty ( ) ) { builder . setLength ( builder . length ( ) - 2 ) ; } return builder . append ( ' ] ' ) . toString ( ) ; }
response: public String toString() { StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('['); <START> for (int i = 0; i < topicSubscriptions.size(); i++) { <END> builder.append(topicSubscriptions.get(i)).append(", "); } if (!topicSubscriptions.isEmpty()) { builder.setLength(builder.length() - 2); } return builder.append(']').toString(); }

sample: 927
buggy_code: private Field[] getFields(Class<?> currentClass) { final List<Field> fields = new ArrayList<>(); <START> if (currentClass != null) { do { <END> fields.addAll(Arrays.asList(currentClass.getDeclaredFields())); currentClass = currentClass.getSuperclass(); } while (currentClass.getSuperclass() != null); } return fields.toArray(new Field[0]); }
code_review: if you change to while (currentClass != null) {} you can avoid the outer if clause
target code: private Field [ ] getFields ( Class < ? > currentClass ) { final List < Field > fields = new ArrayList < > ( ) ; while ( currentClass != null ) { fields . addAll ( Arrays . asList ( currentClass . getDeclaredFields ( ) ) ) ; currentClass = currentClass . getSuperclass ( ) ; } return fields . toArray ( new Field [ 0 ] ) ; }
response: private Field[] getFields(Class<?> currentClass) { final List<Field> fields = new ArrayList<>(); <START> while (currentClass != null) { <END> fields.addAll(Arrays.asList(currentClass.getDeclaredFields())); currentClass = currentClass.getSuperclass(); } return fields.toArray(new Field[0]); }

sample: 928
buggy_code: public void setDecoderResult(DecoderResult decoderResult) { ObjectUtil.checkNotNull(decoderResult, "decoderResult"); <START> this.decoderResult = decoderResult; <END> }
code_review: nit: you can merge both lines above as `checkNotNull` will return the given argument
target code: public void setDecoderResult ( DecoderResult decoderResult ) { this . decoderResult = ObjectUtil . checkNotNull ( decoderResult , "decoderResult" ) ; }
response: public void setDecoderResult(DecoderResult decoderResult) { <START> this.decoderResult = ObjectUtil.checkNotNull(decoderResult, "decoderResult"); <END> }

sample: 929
buggy_code: protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) { <START> requestData= request; <END> return prepareResponseDocument(context).html(); }
code_review: ```suggestion requestData = request; ```
target code: protected String contentFrom ( FitNesseContext context , Request request , WikiPage requestedPage ) { return prepareResponseDocument ( context ) . html ( request ) ; }
response: protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) { <START> requestData = request; <END> return prepareResponseDocument(context).html(); }

sample: 930
buggy_code: public void start() { for (int i = 0; i < numProcessingQueues; i++) { processingExecutor.scheduleAtFixedRate( new SegmentChangeProcessor(segmentProcessingQueues[i]), 0, <START> config.getCuratorCreateZkNodesRepeatDelay().getMillis(), <END> TimeUnit.MILLISECONDS ); } }
code_review: Just wonder how high requests rate we are discussing, 1mln/s? The Coordinator balancing process will choke to halt from such amount long before the discussed queue will show a mere slight latency. I'm sure a single queue will manage the current request rate of Coordinator, besides threads don't need to call *drainTo()* as they can perfectly consume calling *queue.take()*.
target code: public void start ( ) { }
response: public void start() { for (int i = 0; i < numProcessingQueues; i++) { processingExecutor.scheduleAtFixedRate( new SegmentChangeProcessor(segmentProcessingQueues[i]), 0, <START> config.getCuratorCreateZkNodesRepeatDelay().getMillis(), <END> TimeUnit.MILLISECONDS ); } }

sample: 931
buggy_code: <START> protected void doc(Class c) throws IOException { <END> open("tr class='TableRowColor'"); open("td"); around("span class='modifiers'",getModifiers(c)); close("td"); open("td"); link(c.getType()); tag("br"); around("span class='doc'", getDoc(c)); close("td"); close("tr"); }
code_review: Indentation here looks crazy! I'm thinking this might be some mismatch (between your IDE and github) in the number of spaces a tab is worth.
target code: private void doc ( Class c ) throws IOException { open ( "tr class = 'TableRowColor'" ) ; open ( "td" ) ; around ( "span class = 'modifiers'" , getModifiers ( c ) ) ; close ( "td" ) ; open ( "td" ) ; link ( c . getType ( ) ) ; tag ( "br" ) ; around ( "span class = 'doc'" , getDoc ( c ) ) ; close ( "td" ) ; close ( "tr" ) ; }
response: <START> protected void doc(Class c) throws IOException { <END> open("tr class='TableRowColor'"); open("td"); around("span class='modifiers'",getModifiers(c)); close("td"); open("td"); link(c.getType()); tag("br"); around("span class='doc'", getDoc(c)); close("td"); close("tr"); }

sample: 932
buggy_code: public ArrayList<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i) { if (shapedReverseLookupTable.get(i) != null) return shapedReverseLookupTable.get(i); <START> return new ArrayList<Pair<AbstractIngredient[], Float>>(); <END> }
code_review: internal cache, or just return null from this.
target code: public List < Pair < AbstractIngredient [ ] , Float > > lookupShapedRecipes ( Item i ) { return shapedReverseLookupTable . get ( i ) ; }
response: public ArrayList<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i) { if (shapedReverseLookupTable.get(i) != null) return shapedReverseLookupTable.get(i); <START> return null; <END> }

sample: 933
buggy_code: public boolean exists() { OverriddenBooleanValue overriden = null; if ( decorator != null ) { <START> overriden = decorator.decorateExists( this, new EventMetadata( ) ); <END> } if ( ( overriden != null ) && overriden.overrides() ) { return overriden.getResult(); } else { return provider.exists( resource ); } }
code_review: At some point we will probably need a variant of exists() that accepts an EventMetadata parameter, in case the existence decorator needs to know if a path has special properties within the scope of some package type. Not critical now.
target code: public boolean exists ( ) { return exists ( new EventMetadata ( ) ) ; }
response: public boolean exists() { OverriddenBooleanValue overriden = null; if ( decorator != null ) { <START> overriden = decorator.decorateExists( this ); <END> } if ( ( overriden != null ) && overriden.overrides() ) { return overriden.getResult(); } else { return provider.exists( resource ); } }

sample: 934
buggy_code: public void startIndexPopulation( IndexPopulationJob job ) { populationJobs.add( job ); <START> scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) ); <END> }
code_review: I think there is a race in `IndexingService` between `createIndexes` and `shutdown` where population jobs can be added after `IndexPopulationJobController.stop` is called. Result will be that we can leak population jobs. It might be that this is guarded for higher up in the stack. But I think this should be guarded for explicitly. Either here or in `IndexingService`.
target code: void startIndexPopulation ( IndexPopulationJob job ) { populationJobs . add ( job ) ; scheduler . schedule ( indexPopulation , new IndexPopulationJobWrapper ( job , this ) ) ; }
response: public void startIndexPopulation( IndexPopulationJob job ) { populationJobs.add( job ); <START> if ( !stopped ) { scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) ); } <END> }

sample: 935
buggy_code: public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) { String value = options.get(option); <START> return value == null ? defaultValue : Integer.valueOf(value); <END> }
code_review: `Integer.parseInt`
target code: public static int getOptionAsInteger ( Map < String , String > options , String option , int defaultValue ) { String value = options . get ( option ) ; return value == null ? defaultValue : Integer . parseInt ( value ) ; }
response: public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) { String value = options.get(option); <START> return value == null ? defaultValue : Integer.parseInt(value); <END> }

sample: 936
buggy_code: public void releaseBuffer() { if (serializedCache != null) { serializedCache.release(); <START> if (serializedCache.refCnt() == 0) { <END> serializedCache = null; } } }
code_review: should this be thread safe ?
target code: public synchronized void releaseBuffer ( ) { if ( serializedCache != null ) { serializedCache . release ( ) ; if ( serializedCache . refCnt ( ) == 0 ) { serializedCache = null ; } } }
response: public void releaseBuffer() { if (serializedCache != null) { serializedCache.release(); <START> if (serializedCache.refCnt() == 0) { <END> serializedCache = null; } } }

sample: 937
buggy_code: public Credentials.IdentityProvider getProvider() { String nativeProvider = nativeGetProvider(nativePtr); String id = identityProvider.getId(); // Sanity check - ensure nothing changed in the OS if (nativeProvider.equals(id)) { return identityProvider; } else { <START> throw new AssertionError("The provider from the Object Store differs from the one in Realm."); <END> } }
code_review: Good idea  , but this checking should IMO be moved to `AppCredentials`. The `Os<X>` classes should generally just expose the Os interface and then we do the mapping on the "upper" layer, i.e. `AppCredentials`
target code: public String getProvider ( ) { return nativeGetProvider ( nativePtr ) ; }
response: public Credentials.IdentityProvider getProvider() { String nativeProvider = nativeGetProvider(nativePtr); String id = identityProvider.getId(); // Sanity check - ensure nothing changed in the OS if (nativeProvider.equals(id)) { return identityProvider; } else { <START> throw new AssertionError("The provider from the Object Store differs from the one in Realm."); <END> } }

sample: 938
buggy_code: private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) { if (symbolicValue == null) { return Collections.emptySet(); } <START> HashSet<SymbolicValue> result = new HashSet<>(); <END> result.add(symbolicValue); symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv))); return result; }
code_review: minor: rely on interface rather that full type.
target code: private static Set < SymbolicValue > computedFrom ( @Nullable SymbolicValue symbolicValue ) { if ( symbolicValue == null ) { return Collections . emptySet ( ) ; } Set < SymbolicValue > result = new HashSet < > ( ) ; result . add ( symbolicValue ) ; symbolicValue . computedFrom ( ) . forEach ( sv - > result . addAll ( computedFrom ( sv ) ) ) ; return result ; }
response: private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) { if (symbolicValue == null) { return Collections.emptySet(); } <START> Set<SymbolicValue> result = new HashSet<>(); <END> result.add(symbolicValue); symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv))); return result; }

sample: 939
buggy_code: public ClassLoader getClassLoader() { <START> return this.getClassLoader(); <END> }
code_review: This method recursively calls itself, which will result in stackoverflow. Is that ok?
target code: public ClassLoader getClassLoader ( ) { return this . getClass ( ) . getClassLoader ( ) ; }
response: public ClassLoader getClassLoader() { <START> return this.getClassLoader(); <END> }

sample: 940
buggy_code: public Integer add(Stream<E> entities) { return delegate().add(entities.filter(entity -> { <START> boolean permitted = isOperationPermitted(entity, Action.CREATE); <END> if (permitted) { createAcl(entity); } return permitted; })); }
code_review: Shouldn't this throw an exception instead?
target code: public Integer add ( Stream < E > entities ) { return delegate ( ) . add ( entities . filter ( entity - > { // throws exception if no permission on the containing package isOperationPermitted ( entity , Action . CREATE ) ; createAcl ( entity ) ; return true ; } ) ) ; }
response: public Integer add(Stream<E> entities) { return delegate().add(entities.filter(entity -> { <START> boolean permitted = isOperationPermitted(entity, Action.CREATE); <END> if (permitted) { createAcl(entity); } return permitted; }).collect(Collectors.toList())); }

sample: 941
buggy_code: public void canIgnoreInvocationsWithJunit() throws InterruptedException { // given DelayedExecution delayedExecution = createZeroMillisDelayedExecution(); DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution(); // when delayedExecution.allAsyncCallsStarted(); <START> twentyMillisDelayedExecution.allAsyncCallsStarted(); <END> // then verify(mock, timeout(50)).oneArg('1'); verify(mock, timeout(50)).oneArg('2'); }
code_review: @lukasz-szewc I'd rather propose ``` java delayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('1'); twentyMillisDelayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('2'); ``` I agree with you however the name of this test is wrong...
target code: public void canIgnoreInvocationsWithJunit ( ) throws InterruptedException { // given DelayedExecution delayedExecution = createZeroMillisDelayedExecution ( ) ; DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution ( ) ; // when delayedExecution . allAsyncCallsStarted ( ) ; // then verify ( mock , timeout ( 50 ) ) . oneArg ( '1' ) ; // when twentyMillisDelayedExecution . allAsyncCallsStarted ( ) ; // then verify ( mock , timeout ( 50 ) ) . oneArg ( '2' ) ; }
response: public void canIgnoreInvocationsWithJunit() throws InterruptedException { // given DelayedExecution delayedExecution = createZeroMillisDelayedExecution(); DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution(); // when delayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('1'); twentyMillisDelayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('2'); }

sample: 942
buggy_code: public final boolean isExtendedLifetimeValid() { //extended lifetime is only valid if it contains an access token if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) { return !isTokenExpired(mExtendedExpiresOn); <START> } else { <END> return false; } }
code_review: > else { [](start = 10, length = 6) you don't need this else block.
target code: public final boolean isExtendedLifetimeValid ( ) { // extended lifetime is only valid if it contains an access token if ( mExtendedExpiresOn != null && ! StringExtensions . IsNullOrBlank ( mAccessToken ) ) { return ! isTokenExpired ( mExtendedExpiresOn ) ; } return false ; }
response: public final boolean isExtendedLifetimeValid() { //extended lifetime is only valid if it contains an access token if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) { return !isTokenExpired(mExtendedExpiresOn); } return false; }

sample: 943
buggy_code: public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) { BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument); try { emailService.sendMessage(message, false); } catch (Exception e) { <START> String errorMessage = new String("sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# " + iWantDocument.getDocumentNumber()); <END> LOG.error(errorMessage, e); } }
code_review: Redundant String constructor.
target code: public void sendDocumentFinalizedMessage ( IWantDocument iWantDocument ) { BodyMailMessage message = buildDocumentFinalizedMessage ( iWantDocument ) ; try { emailService . sendMessage ( message , false ) ; } catch ( Exception e ) { LOG . error ( ( "sendDocumentFinalizedMessage , Email could not be sent for IWNT edoc# " + iWantDocument . getDocumentNumber ( ) ) , e ) ; } }
response: public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) { BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument); try { emailService.sendMessage(message, false); } catch (Exception e) { <START> String errorMessage = "sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# " + iWantDocument.getDocumentNumber(); <END> LOG.error(errorMessage, e); } }

sample: 944
buggy_code: <START> public void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) { <END> storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId, infosByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()), buffersByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener)); }
code_review: minor: can be package private
target code: void addStore ( PartitionId partitionId , ReplicationTest . StoreEventListener listener ) { storesByPartition . computeIfAbsent ( partitionId , partitionId1 - > new InMemoryStore ( partitionId , infosByPartition . computeIfAbsent ( partitionId1 , ( Function < PartitionId , List < MessageInfo > > ) partitionId2 - > new ArrayList < > ( ) ) , buffersByPartition . computeIfAbsent ( partitionId1 , ( Function < PartitionId , List < ByteBuffer > > ) partitionId22 - > new ArrayList < > ( ) ) , listener ) ) ; }
response: <START> void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) { <END> storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId, infosByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()), buffersByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener)); }

sample: 945
buggy_code: private static long doubleToSortableLong(double value) { long bits = Double.doubleToLongBits(value); <START> return bits ^ (bits >> 63) & Long.MAX_VALUE; <END> }
code_review: Add clarifying parenthesis. It's easy to forget the precedence rules for `^` and `&` so that will make the code easier to reason about.
target code: private static long doubleToSortableLong ( double value ) { long bits = Double . doubleToLongBits ( value ) ; return bits ^ ( ( bits > > 63 ) & Long . MAX_VALUE ) ; }
response: private static long doubleToSortableLong(double value) { long bits = Double.doubleToLongBits(value); <START> return (bits ^ (bits >> 63)) & Long.MAX_VALUE; <END> }

sample: 946
buggy_code: default int getGroupedJobInitializerCacheSize() { <START> return 10; <END> }
code_review: It's probably a bit low. I doubt GroupedJobInitializer use much memory so we could easily increase it a bit by default (like 100 maybe). Would need to check how many nodes are created after a few jobs are run in XWiki Standard. On extension side there is the root "extension" node and then 1 per namespace (so in practice 1 par wiki). It's potentially a lot more for the refactoring module since you have the root "refactoring" node and then one node for each element of each EntityReference which is manipulated.
target code: default int getGroupedJobInitializerCacheSize ( ) { return 100 ; }
response: default int getGroupedJobInitializerCacheSize() { <START> return 100; <END> }

sample: 947
buggy_code: public DefaultCompactionPolicyTest() throws InterruptedException { Pair<MockBlobStore, StoreConfig> initState = CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE); <START> this.config = initState.getSecond(); <END> this.blobStore = initState.getFirst(); this.mockBlobStoreStats = blobStore.getBlobStoreStats(); this.messageRetentionTimeInMs = config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec; this.compactionPolicy = new DefaultCompactionPolicy(config, time); }
code_review: minor: `this` qualifiers not required.
target code: public DefaultCompactionPolicyTest ( ) throws InterruptedException { Pair < MockBlobStore , StoreConfig > initState = CompactionPolicyTest . initializeBlobStore ( properties , time , - 1 , - 1 , DEFAULT_MAX_BLOB_SIZE ) ; config = initState . getSecond ( ) ; blobStore = initState . getFirst ( ) ; mockBlobStoreStats = blobStore . getBlobStoreStats ( ) ; messageRetentionTimeInMs = config . storeDeletedMessageRetentionDays * Time . HoursPerDay * Time . SecsPerHour * Time . MsPerSec ; compactionPolicy = new DefaultCompactionPolicy ( config , time ) ; }
response: public DefaultCompactionPolicyTest() throws InterruptedException { Pair<MockBlobStore, StoreConfig> initState = CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE); <START> config = initState.getSecond(); <END> blobStore = initState.getFirst(); mockBlobStoreStats = blobStore.getBlobStoreStats(); messageRetentionTimeInMs = config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec; compactionPolicy = new DefaultCompactionPolicy(config, time); }

sample: 948
buggy_code: private boolean containtsOnlyValidXMLChars(String stringToValidate) { <START> String pattern = "[^" <END> + "\u0009\r\n" + "\u0020-\uD7FF" + "\uE000-\uFFFD" + "\ud800\udc00-\udbff\udfff" + "]"; String resultString = stringToValidate.replaceAll(pattern, ""); if (resultString.equals(stringToValidate)) { return true; } return false; }
code_review: Why not simply iterate over the array of chars and not check if `stringToValidate.contains(character)`.
target code: private boolean containtsOnlyValidXMLChars ( String stringToValidate ) { String pattern = " [ ^ " + "\u0009\r\n" + "\u0020 - \uD7FF" + "\uE000 - \uFFFD" + "\ud800\udc00 - \udbff\udfff" + " ] " ; String resultString = stringToValidate . replaceAll ( pattern , "" ) ; return resultString . equals ( stringToValidate ) ; }
response: private boolean containtsOnlyValidXMLChars(String stringToValidate) { <START> String pattern = "[^" <END> + "\u0009\r\n" + "\u0020-\uD7FF" + "\uE000-\uFFFD" + "\ud800\udc00-\udbff\udfff" + "]"; String resultString = stringToValidate.replaceAll(pattern, ""); if (resultString.equals(stringToValidate)) { return true; } return false; }

sample: 949
buggy_code: <START> public CloseableLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database, ManagedDataSource dataSource) throws LiquibaseException, SQLException { <END> super(changeLogFile, resourceAccessor, database); this.dataSource = dataSource; }
code_review: It's a pity we have to change the public API, but I guess it's reasonable in this case. Let's hope not so many folks wrote custom migrations commands.
target code: CloseableLiquibase ( String changeLogFile , ResourceAccessor resourceAccessor , Database database , ManagedDataSource dataSource ) throws LiquibaseException , SQLException { super ( changeLogFile , resourceAccessor , database ) ; this . dataSource = dataSource ; }
response: <START> public CloseableLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database, ManagedDataSource dataSource) throws LiquibaseException, SQLException { <END> super(changeLogFile, resourceAccessor, database); this.dataSource = dataSource; this.database = database; }

sample: 950
buggy_code: public CtfTmfLightweightContext(ArrayList<CtfIterator> iters, ListIterator<CtfIterator> pos) { fIteratorPool = iters; <START> fCurrentIterator = pos; <END> fTrace = iters.get(0).getCtfTmfTrace(); curLocation = new CtfLocation((Long)null); collisions = 0; }
code_review: Might as well remove these fields if they are not used. Perhaps just call the other constructor with: this(iters.get(0).getCtfTmfTrace());
target code: public CtfTmfLightweightContext ( ArrayList < CtfIterator > iters , ListIterator < CtfIterator > pos ) { fTrace = iters . get ( 0 ) . getCtfTmfTrace ( ) ; curLocation = new CtfLocation ( ( Long ) null ) ; }
response: public CtfTmfLightweightContext(ArrayList<CtfIterator> iters, ListIterator<CtfIterator> pos) { fIteratorPool = iters; <START> fCurrentIterator = pos; <END> fTrace = iters.get(0).getCtfTmfTrace(); curLocation = new CtfLocation((Long)null); }

sample: 951
buggy_code: <START> public void testIsAdHocAutostart_true() throws Exception { <END> String id = UUID.randomUUID().toString(); AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess(); adHocSubProcess.setId(id); CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE); tested = new AdHocSubProcessPropertyReader(adHocSubProcess, definitionResolverReal.getDiagram(), definitionResolverReal); assertTrue(tested.isAdHocAutostart()); }
code_review: The Exception is never thrown.
target code: public void testIsAdHocAutostart_true ( ) { String id = UUID . randomUUID ( ) . toString ( ) ; AdHocSubProcess adHocSubProcess = bpmn2 . createAdHocSubProcess ( ) ; adHocSubProcess . setId ( id ) ; CustomElement . autoStart . of ( adHocSubProcess ) . set ( Boolean . TRUE ) ; tested = new AdHocSubProcessPropertyReader ( adHocSubProcess , definitionResolverReal . getDiagram ( ) , definitionResolverReal ) ; assertTrue ( tested . isAdHocAutostart ( ) ) ; }
response: <START> public void testIsAdHocAutostart_true() { <END> String id = UUID.randomUUID().toString(); AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess(); adHocSubProcess.setId(id); CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE); tested = new AdHocSubProcessPropertyReader(adHocSubProcess, definitionResolverReal.getDiagram(), definitionResolverReal); assertTrue(tested.isAdHocAutostart()); }

sample: 952
buggy_code: private BroadcastTrimmer broadcastTrimmer() { return new ScheduleResolverBroadcastTrimmer( <START> null, <END> scheduleResolver, contentResolver, contentWriter ); }
code_review: Remove the parameter completely, the other constructor will initiate the publisher as null.
target code: private BroadcastTrimmer broadcastTrimmer ( ) { return new ScheduleResolverBroadcastTrimmer ( scheduleResolver , contentResolver , contentWriter ) ; }
response: private BroadcastTrimmer broadcastTrimmer() { return new ScheduleResolverBroadcastTrimmer( <START> scheduleResolver, <END> contentResolver, contentWriter ); }

sample: 953
buggy_code: public void disconnect() throws IOException { if (forwarders != null) { for (LocalPortForwarder forwarder : forwarders) { try { forwarder.close(); } catch (IOException e) { log.warn("Error closing forwarder", e); } <START> } <END> } trans.disconnect(); super.disconnect(); }
code_review: clear the forwarders list after the loop?
target code: public void disconnect ( ) throws IOException { for ( LocalPortForwarder forwarder : forwarders ) { try { forwarder . close ( ) ; } catch ( IOException e ) { log . warn ( "Error closing forwarder" , e ) ; } } forwarders . clear ( ) ; trans . disconnect ( ) ; super . disconnect ( ) ; }
response: public void disconnect() throws IOException { if (forwarders != null) { for (LocalPortForwarder forwarder : forwarders) { try { forwarder.close(); } catch (IOException e) { log.warn("Error closing forwarder", e); } } forwarders.clear(); } trans.disconnect(); super.disconnect(); }

sample: 954
buggy_code: public void close() { super.close(); if (mRefCount != null) { <START> mRefCount.decrementAndGet(); <END> } }
code_review: NIT: is there just a plain `decrement()`?
target code: public void close ( ) { super . close ( ) ; mRefCount . decrementAndGet ( ) ; }
response: public void close() { super.close(); if (mRefCount != null) { <START> mRefCount.decrement(); <END> } }

sample: 955
buggy_code: public static String getParameter(String key) { try { return getConfig().getString(key); } catch (NoSuchElementException e) { <START> e.printStackTrace(); <END> throw new NoSuchElementException("No configuration found in " + CONFIG_FILE + " for key " + key + "!"); } }
code_review: Use logger instead of `printStackTrace()` calls.
target code: public static String getParameter ( String key ) { try { return getConfig ( ) . getString ( key ) ; } catch ( NoSuchElementException e ) { throw new NoSuchElementException ( "No configuration found in " + CONFIG_FILE + " for key " + key + " ! " ) ; } }
response: public static String getParameter(String key) { try { return getConfig().getString(key); } catch (NoSuchElementException e) { <START> LOGGER.error("No configuration found in " + CONFIG_FILE + " for key " + key + "!", e); <END> throw new NoSuchElementException("No configuration found in " + CONFIG_FILE + " for key " + key + "!"); } }

sample: 956
buggy_code: public List<Option> getOptions() { <START> return unmodifiableList(options); <END> }
code_review: This class should be immutable anyway so why not wrap the collection in the constructor once rather than every time it is returned to caller?
target code: public List < Option > getOptions ( ) { return options ; }
response: public List<Option> getOptions() { <START> return options; <END> }

sample: 957
buggy_code: public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) { this.input = input; this.initialOffset = initialOffset; <START> } <END>
code_review: Do we need to set the input position to the initial offset?
target code: public DataInputNavigableJsonAdapter ( BufferObjectDataInput input , int initialOffset ) { this . input = input ; this . input . position ( initialOffset ) ; this . initialOffset = initialOffset ; }
response: public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) { this.input = input; this.initialOffset = initialOffset; <START> input.position(initialOffset); <END> }

sample: 958
buggy_code: protected void onMethodInvocationFound(MethodInvocationTree mit) { ExpressionTree argument = mit.arguments().get(1); Type type = argument.symbolType(); <START> if (type.isUnknown()) { <END> return; } if (ExpressionsHelper.isNotSerializable(argument)) { String andParameters = JUtils.isParametrized(type) ? " and its parameters" : ""; reportIssue(argument, "Make \"" + type + "\"" + andParameters + " serializable or don't store it in the session."); } }
code_review: So it means that an argument with unknown type is considered as not serializable? Should we consider making the unknown check inside `isNotSerializable` and provide the same behavior for all rules using it? I'm saying this since the other rule (S2118) using `isNotSerializable` is also reporting an arguable issue with a similar message if we run it against an unknown type. > Make the "!Unknown!" class "Serializable" or don't write it.
target code: protected void onMethodInvocationFound ( MethodInvocationTree mit ) { ExpressionTree argument = mit . arguments ( ) . get ( 1 ) ; Type type = argument . symbolType ( ) ; if ( ExpressionsHelper . isNotSerializable ( argument ) ) { String andParameters = JUtils . isParametrized ( type ) ? " and its parameters" : "" ; reportIssue ( argument , "Make \"" + type . name ( ) + "\"" + andParameters + " serializable or don't store it in the session . " ) ; } }
response: protected void onMethodInvocationFound(MethodInvocationTree mit) { ExpressionTree argument = mit.arguments().get(1); Type type = argument.symbolType(); if (type.isUnknown()) { return; } <START> if (ExpressionsHelper.isNotSerializable(argument)) { <END> String andParameters = JUtils.isParametrized(type) ? " and its parameters" : ""; reportIssue(argument, "Make \"" + type + "\"" + andParameters + " serializable or don't store it in the session."); } }

sample: 959
buggy_code: public Predicate createPredicateAndJoin(String filterString, Root<T> root) { LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString)); LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer)); parser.addErrorListener(new OsiamAntlrErrorListener()); ParseTree tree = parser.parse(); EvalVisitor<T> visitor = new EvalVisitor<>(this, root); <START> return (Predicate) visitor.visit(tree); <END> }
code_review: Is this cast still necessary?
target code: public Predicate createPredicateAndJoin ( String filterString , Root < T > root ) { LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer ( new ANTLRInputStream ( filterString ) ) ; LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser ( new CommonTokenStream ( lexer ) ) ; parser . addErrorListener ( new OsiamAntlrErrorListener ( ) ) ; ParseTree tree = parser . parse ( ) ; EvalVisitor < T > visitor = new EvalVisitor < > ( this , root ) ; return visitor . visit ( tree ) ; }
response: public Predicate createPredicateAndJoin(String filterString, Root<T> root) { LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString)); LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer)); parser.addErrorListener(new OsiamAntlrErrorListener()); ParseTree tree = parser.parse(); EvalVisitor<T> visitor = new EvalVisitor<>(this, root); <START> return visitor.visit(tree); <END> }

sample: 960
buggy_code: <START> public Privilege[] getSupportedPrivileges(String path) throws PathNotFoundException, RepositoryException { <END> return privileges.listOfSupported(); }
code_review: Remove the exceptions, since they're never thrown from the method.
target code: public Privilege [ ] getSupportedPrivileges ( String path ) { return privileges . listOfSupported ( ) ; }
response: <START> public Privilege[] getSupportedPrivileges(String path) { <END> return privileges.listOfSupported(); }

sample: 961
buggy_code: protected AbstractSessionPresenter(final SessionManager sessionManager, final SessionPresenter.View view, final Optional<? extends ToolbarFactory<S>> toolbarFactory, final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory, final NotificationsObserver notificationsObserver) { this.sessionManager = sessionManager; <START> this.toolbarFactory = toolbarFactory.orElse(null); <END> this.paletteFactory = paletteFactory.orElse(null); this.notificationsObserver = notificationsObserver; this.view = view; this.hasToolbar = true; this.hasPalette = true; }
code_review: I'd have thought preserving the use of ```Optional``` in the class's implementation would be nicer than just using ```Optional``` on the constructor and then reverting to ```null``` _inside_ the class.
target code: protected AbstractSessionPresenter ( final SessionManager sessionManager , final SessionPresenter . View view , final Optional < ? extends ToolbarFactory < S > > toolbarFactory , final Optional < PaletteWidgetFactory < DefinitionSetPalette , ? > > paletteFactory , final NotificationsObserver notificationsObserver ) { this . sessionManager = sessionManager ; this . toolbarFactory = ( Optional < ToolbarFactory < S > > ) toolbarFactory ; this . paletteFactory = paletteFactory ; this . notificationsObserver = notificationsObserver ; this . view = view ; this . hasToolbar = true ; this . hasPalette = true ; }
response: protected AbstractSessionPresenter(final SessionManager sessionManager, final SessionPresenter.View view, final Optional<? extends ToolbarFactory<S>> toolbarFactory, final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory, final NotificationsObserver notificationsObserver) { this.sessionManager = sessionManager; <START> this.toolbarFactory = toolbarFactory.orElse(null); <END> this.paletteFactory = paletteFactory.orElse(null); this.notificationsObserver = notificationsObserver; this.view = view; this.hasToolbar = true; this.hasPalette = true; }

sample: 962
buggy_code: <START> public void prepareToNewMarker() { <END> drawerLayout.closeDrawers(); setLongClickListener(true); setToastMarkerInfo(); }
code_review: czy to musi byc publiczne?
target code: private void prepareToNewMarker ( ) { drawerLayout . closeDrawers ( ) ; setLongClickListener ( ) ; setToastMarkerInfo ( ) ; }
response: <START> void prepareToNewMarker() { <END> drawerLayout.closeDrawers(); setLongClickListener(true); setToastMarkerInfo(); }

sample: 963
buggy_code: <START> private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) { <END> if (cacheEntry instanceof MVCCEntry) { MVCCEntry mvccEntry = (MVCCEntry) cacheEntry; updateMetadata(mvccEntry, providedMetadata); return mvccEntry; } return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, true); }
code_review: The skipRead parameter isn't used.
target code: private MVCCEntry wrapMvccEntryForPut ( InvocationContext ctx , Object key , CacheEntry cacheEntry , Metadata providedMetadata , boolean skipRead ) { if ( cacheEntry instanceof MVCCEntry ) { MVCCEntry mvccEntry = ( MVCCEntry ) cacheEntry ; updateMetadata ( mvccEntry , providedMetadata ) ; return mvccEntry ; } return wrapInternalCacheEntryForPut ( ctx , key , ( InternalCacheEntry ) cacheEntry , providedMetadata , skipRead ) ; }
response: <START> private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) { <END> if (cacheEntry instanceof MVCCEntry) { MVCCEntry mvccEntry = (MVCCEntry) cacheEntry; updateMetadata(mvccEntry, providedMetadata); return mvccEntry; } return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, true); }

sample: 964
buggy_code: public SERVICE_FAILURE_ACTIONS getFailureActions() { Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS); SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer); <START> result.read(); <END> return result; }
code_review: You should make the `read()` call part of the `SERVICE_FAILURE_ACTIONS(Pointer)` constructor.
target code: public SERVICE_FAILURE_ACTIONS getFailureActions ( ) { Pointer buffer = queryServiceConfig2 ( Winsvc . SERVICE_CONFIG_FAILURE_ACTIONS ) ; SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS ( buffer ) ; return result ; }
response: public SERVICE_FAILURE_ACTIONS getFailureActions() { Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS); SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer); <START> result.read(); <END> return result; }

sample: 965
buggy_code: void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception { // Questionable: check what is done with this file new File(strPath); // Noncompliant new File(StrParent, StrChild); // Noncompliant {{Make sure this file handling is safe here.}} File parent = new File(uri); // Noncompliant new File(parent, StrChild); // compliant we rely on the fact that parent should be highlighted <START> File.createTempFile(prefix, suffix); // Noncompliant <END> }
code_review: I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
target code: void fun ( String strPath , String StrParent , String StrChild , String prefix , String suffix , java . net . URI uri ) throws Exception { // Questionable : check what is done with this file new File ( strPath ) ; // Noncompliant new File ( StrParent , StrChild ) ; // Noncompliant { { Make sure this file handling is safe here . } } File parent = new File ( uri ) ; // Noncompliant new File ( parent , StrChild ) ; // compliant we rely on the fact that parent should be highlighted File . createTempFile ( prefix , suffix ) ; // Noncompliant File . createTempFile ( prefix , suffix , parent ) ; // compliant }
response: void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception { // Questionable: check what is done with this file new File(strPath); // Noncompliant new File(StrParent, StrChild); // Noncompliant {{Make sure this file handling is safe here.}} File parent = new File(uri); // Noncompliant new File(parent, StrChild); // compliant we rely on the fact that parent should be highlighted <START> File.createTempFile(prefix, suffix, null); // Noncompliant <END> }

sample: 966
buggy_code: public ValidationResult vmNotHavingPciPassthroughDevices() { for (VM vm : vms) { if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) { return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES, <START> String.format("$VmName %s", vm.getName())); <END> } } return ValidationResult.VALID; }
code_review: I see that VmName in not included in the error message.. not sure if the right thing to do is to include it in the message or not to set it here
target code: public ValidationResult vmNotHavingPciPassthroughDevices ( ) { for ( VM vm : vms ) { if ( getHostDeviceManager ( ) . checkVmNeedsPciDevices ( vm . getId ( ) ) ) { return new ValidationResult ( EngineMessage . ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES ) ; } } return ValidationResult . VALID ; }
response: public ValidationResult vmNotHavingPciPassthroughDevices() { for (VM vm : vms) { if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) { return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES, <START> String.format("$VmName %s", vm.getName())); <END> } } return ValidationResult.VALID; }

sample: 967
buggy_code: public void onError(Throwable e) { <START> e.printStackTrace(); <END> try { FileLfsServlet.sendError(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage()); context.complete(); in.close(); } catch (IOException ex) { LOG.log(Level.SEVERE, ex.getMessage(), ex); } }
code_review: did you want to log this exception ?
target code: public void onError ( Throwable e ) { try { FileLfsServlet . sendError ( response , HttpStatus . SC_INTERNAL_SERVER_ERROR , e . getMessage ( ) ) ; context . complete ( ) ; in . close ( ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } }
response: public void onError(Throwable e) { <START> LOG.log(Level.SEVERE, e.getMessage(), e); <END> try { FileLfsServlet.sendError(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage()); context.complete(); in.close(); } catch (IOException ex) { LOG.log(Level.SEVERE, ex.getMessage(), ex); } }

sample: 968
buggy_code: public String pop() { <START> String value = lines.remove(lines.lastKey()); <END> return value; }
code_review: Return could be simplified: `return lines.remove(lines.lastKey());` :)
target code: public String pop ( ) { return lines . remove ( lines . lastKey ( ) ) ; }
response: public String pop() { <START> return lines.remove(lines.lastKey()); <END> }

sample: 969
buggy_code: public void onDestroyView() { mapView.onDestroy(); mapboxMap = null; unbinder.unbind(); unbinder = null; <START> WikipediaApp.getInstance().getRefWatcher().watch(this); <END> super.onDestroyView(); }
code_review: Shouldn't this be in onDestroy?
target code: public void onDestroyView ( ) { mapView . onDestroy ( ) ; mapboxMap = null ; unbinder . unbind ( ) ; unbinder = null ; super . onDestroyView ( ) ; }
response: public void onDestroy() { mapView.onDestroy(); mapboxMap = null; unbinder.unbind(); unbinder = null; <START> WikipediaApp.getInstance().getRefWatcher().watch(this); <END> super.onDestroy(); }

sample: 970
buggy_code: private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) { SampleTissueProcessingDto dto = null; <START> if (from.getClass() == SampleCVSlideImpl.class) { <END> dto = asCVSlideSampleDto((SampleCVSlide) from); } else if (from.getClass() == SampleLCMTubeImpl.class) { dto = asLCMTubeSampleDto((SampleLCMTube) from); } else { dto = new SampleTissueProcessingDto(); } return dto; }
code_review: getClass comparison is required for Dtos because of the way their inheritance works (analyte is also a tissue and an identity for the purpose of including parent data), but instanceof should be used here (and typically for the non-dto models), and check vs. interfaces for flexibility. e.g. we could add another implementation of SampleCVSlide that this method should still work for, or we could subclass SampleCVSlideImpl (however unlikely)
target code: private static SampleTissueProcessingDto asTissueProcessingSampleDto ( SampleTissueProcessing from ) { SampleTissueProcessingDto dto = null ; if ( from instanceof SampleCVSlideImpl ) { dto = asCVSlideSampleDto ( ( SampleCVSlide ) from ) ; } else if ( from . getClass ( ) == SampleLCMTubeImpl . class ) { dto = asLCMTubeSampleDto ( ( SampleLCMTube ) from ) ; } else { dto = new SampleTissueProcessingDto ( ) ; } return dto ; }
response: private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) { SampleTissueProcessingDto dto = null; <START> if (from instanceof SampleCVSlide) { <END> dto = asCVSlideSampleDto((SampleCVSlide) from); } else if (from instanceof SampleLCMTube) { dto = asLCMTubeSampleDto((SampleLCMTube) from); } else { dto = new SampleTissueProcessingDto(); } return dto; }

sample: 971
buggy_code: public void testMakeTimeZone_NoOffsets() throws IOException { <START> <END> int[][] times = {}; int[][] offsets = {}; try { createZoneInfo(times, offsets); fail("Did not detect no transitions"); } catch (IllegalStateException expected) { // Expected this to happen } }
code_review: Unnecessary new line here and below: why leave the first line blank? (unless there's a wrap in the signature, in which case it can help to differentiate between the signature and the body).
target code: public void testMakeTimeZone_NoOffsets ( ) throws Exception { int [ ] [ ] times = { } ; int [ ] [ ] offsets = { } ; try { createZoneInfo ( times , offsets ) ; fail ( "Did not detect no transitions" ) ; } catch ( IllegalStateException expected ) { // Expected this to happen } }
response: public void testMakeTimeZone_NoOffsets() throws IOException { <START> <END> int[][] times = {}; int[][] offsets = {}; try { createZoneInfo(times, offsets); fail("Did not detect no transitions"); } catch (IllegalStateException expected) { // Expected this to happen } }

sample: 972
buggy_code: DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations, GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage, RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) { this.nodeNamingConvention = checkNotNull(namingConvention, "namingConvention").createWithoutPrefix(); this.locations = checkNotNull(locations, "locations"); this.osImageToImage = checkNotNull(osImageToImage, "osImageToImage"); this.roleSizeToHardware = checkNotNull(roleSizeToHardware, "roleSizeToHardware"); <START> this.credentialStore = checkNotNull(credentialStore, "credentialStore cannot be null"); <END> }
code_review: Since the constructor is package private and only the Guice injector will be able to call it, you can remove all the null checks. The injector will already fail if any parameter is missing.
target code: DeploymentToNodeMetadata ( @Memoized Supplier < Set < ? extends Location > > locations , GroupNamingConvention . Factory namingConvention , OSImageToImage osImageToImage , RoleSizeToHardware roleSizeToHardware , Map < String , Credentials > credentialStore ) { this . nodeNamingConvention = namingConvention . createWithoutPrefix ( ) ; this . locations = locations ; this . osImageToImage = osImageToImage ; this . roleSizeToHardware = roleSizeToHardware ; this . credentialStore = credentialStore ; }
response: DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations, GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage, RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) { this.nodeNamingConvention = checkNotNull(namingConvention, "namingConvention").createWithoutPrefix(); this.locations = checkNotNull(locations, "locations"); this.osImageToImage = checkNotNull(osImageToImage, "osImageToImage"); this.roleSizeToHardware = checkNotNull(roleSizeToHardware, "roleSizeToHardware"); <START> this.credentialStore = credentialStore; <END> }

sample: 973
buggy_code: public AsyncContext startAsync() throws IllegalStateException { if (_asyncNotSupportedSource != null) throw new IllegalStateException("!asyncSupported: " + _asyncNotSupportedSource); HttpChannelState state = getHttpChannelState(); if (_async == null) _async = new AsyncContextState(state); <START> AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse(), false); <END> state.startAsync(event); return _async; }
code_review: I wonder if you shouldn't keep the old constructor here, and not use an extra boolean argument.
target code: public AsyncContext startAsync ( ) throws IllegalStateException { if ( _asyncNotSupportedSource != null ) throw new IllegalStateException ( " ! asyncSupported : " + _asyncNotSupportedSource ) ; HttpChannelState state = getHttpChannelState ( ) ; if ( _async == null ) _async = new AsyncContextState ( state ) ; AsyncContextEvent event = new AsyncContextEvent ( _context , _async , state , this , this , getResponse ( ) ) ; state . startAsync ( event ) ; return _async ; }
response: public AsyncContext startAsync() throws IllegalStateException { if (_asyncNotSupportedSource != null) throw new IllegalStateException("!asyncSupported: " + _asyncNotSupportedSource); HttpChannelState state = getHttpChannelState(); if (_async == null) _async = new AsyncContextState(state); <START> AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse()); <END> state.startAsync(event); return _async; }

sample: 974
buggy_code: CompletableFuture<Void> getFailureOp(CommitData cd) { <START> return CompletableFuture.supplyAsync(() -> { <END> try { rollbackLocks(cd); } catch (Exception e) { throw new CompletionException(e); } return null; }, env.getSharedResources().getSyncCommitExecutor()); }
code_review: After `throws Exception` is dropped from rollbackLocks, seems like this code should be : ```java CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); } ```
target code: CompletableFuture < Void > getFailureOp ( CommitData cd ) { return rollbackLocks ( cd ) ; }
response: CompletableFuture<Void> getFailureOp(CommitData cd) { <START> return rollbackLocks(cd); <END> }

sample: 975
buggy_code: private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) { return symbol.owner().type().is("com.google.common.base.Preconditions") <START> && ("checkNotNull".equals(symbol.name()) || "checkArgument".equals(symbol.name()) || "checkState".equals(symbol.name()) ); <END> }
code_review: symbol.name() called 3 times? maybe worth a dedicated variable.
target code: private boolean isGuavaPrecondition ( Symbol . MethodSymbol symbol ) { String name = symbol . name ( ) ; return symbol . owner ( ) . type ( ) . is ( "com . google . common . base . Preconditions" ) && ( "checkNotNull" . equals ( name ) || "checkArgument" . equals ( name ) || "checkState" . equals ( name ) ) ; }
response: private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) { return symbol.owner().type().is("com.google.common.base.Preconditions") <START> && ("checkNotNull".equals(symbol.name()) || "checkArgument".equals(symbol.name()) || "checkState".equals(symbol.name()) ); <END> }

sample: 976
buggy_code: public void loadTrace(ITmfTrace trace) { <START> cancelUpdate(); <END> super.loadTrace(trace); initializeDataProvider(); }
code_review: We had that cancelUpdate() at the beginning of updateContent(). Now the UpdateThread doesn't get cancelled with TmfXYChartViewer.windowRangeUpdated() and TmfCommonXAxisChartViewer.setNbPoints().
target code: public void loadTrace ( ITmfTrace trace ) { super . loadTrace ( trace ) ; initializeDataProvider ( ) ; }
response: public void loadTrace(ITmfTrace trace) { <START> cancelUpdate(); <END> super.loadTrace(trace); initializeDataProvider(); }

sample: 977
buggy_code: public StringInputRowParser( @JsonProperty("parseSpec") ParseSpec parseSpec, @JsonProperty("encoding") String encoding ) { this.parseSpec = parseSpec; this.mapParser = new MapInputRowParser(parseSpec); this.parser = parseSpec.makeParser(); <START> parser.startFileFromBeginning(); <END> if (encoding != null) { this.charset = Charset.forName(encoding); } else { this.charset = DEFAULT_CHARSET; } }
code_review: StringInputRowParser is used by parser options that aren't file-oriented (you can use it on streams etc) so this isn't a good place to put this. imo, this should replace `reset()` and be called in places that `reset()` is currently called (like FileIteratingFirehose). With one addition: it needs to be called before the very first file too.
target code: public StringInputRowParser ( @JsonProperty ( "parseSpec" ) ParseSpec parseSpec , @JsonProperty ( "encoding" ) String encoding ) { this . parseSpec = parseSpec ; this . mapParser = new MapInputRowParser ( parseSpec ) ; this . parser = parseSpec . makeParser ( ) ; if ( encoding != null ) { this . charset = Charset . forName ( encoding ) ; } else { this . charset = DEFAULT_CHARSET ; } }
response: public StringInputRowParser( @JsonProperty("parseSpec") ParseSpec parseSpec, @JsonProperty("encoding") String encoding ) { this.parseSpec = parseSpec; this.mapParser = new MapInputRowParser(parseSpec); this.parser = parseSpec.makeParser(); <START> parser.startFileFromBeginning(); <END> if (encoding != null) { this.charset = Charset.forName(encoding); } else { this.charset = DEFAULT_CHARSET; } }

sample: 978
buggy_code: public Object getNegotiatedProperty(String propName) { assertComplete(); switch (propName) { case Sasl.QOP: return selectedQop.getName(); case Sasl.MAX_BUFFER: return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer); case Sasl.RAW_S<END>_SIZE: return Integer.toString(maxBuffer); } <START> return super.getNegotiatedProperty(propName); <END> }
code_review: The superclass only repeats the assertComplete() call. I don't think this PR adds any value.
target code: public Object getNegotiatedProperty ( String propName ) { assertComplete ( ) ; switch ( propName ) { case Sasl . QOP : return selectedQop . getName ( ) ; case Sasl . MAX_BUFFER : return Integer . toString ( actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer ) ; case Sasl . RAW_SEND_SIZE : return Integer . toString ( maxBuffer ) ; } return null ; }
response: public Object getNegotiatedProperty(String propName) { assertComplete(); switch (propName) { case Sasl.QOP: return selectedQop.getName(); case Sasl.MAX_BUFFER: return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer); case Sasl.RAW_S<END>_SIZE: return Integer.toString(maxBuffer); } <START> return null; <END> }

sample: 979
buggy_code: public static BooleanExpression asBoolean(boolean value) { <START> return asBoolean(Expressions.constant(value)); <END> }
code_review: this is inside Expressions, so maybe just `asBoolean(constant(value))`, the same with the others
target code: public static BooleanExpression asBoolean ( boolean value ) { return asBoolean ( constant ( value ) ) ; }
response: public static BooleanExpression asBoolean(boolean value) { <START> return asBoolean(constant(value)); <END> }

sample: 980
buggy_code: public void startPolicyEnforcement() throws IOException { if (m_pbd.getUsageSpecificLog().isDebugEnabled()) { m_pbd.getUsageSpecificLog().debug("Starting time based retention policy enforcement with retainMillis=" + m_retainMillis + " for PBD " + m_pbd.getNonce()); } m_reader = m_pbd.openForRead(CURSOR_NAME); <START> scheduleTaskFor(m_pbd.getNonce(), ()->deleteOldSegments(), 0); <END> }
code_review: You can do `this::deleteOldSegments` for the callable. It is more efficient lambda form
target code: public void startPolicyEnforcement ( ) throws IOException { if ( m_pbd . getUsageSpecificLog ( ) . isDebugEnabled ( ) ) { m_pbd . getUsageSpecificLog ( ) . debug ( "Starting time based retention policy enforcement with retainMillis = " + m_retainMillis + " for PBD " + m_pbd . getNonce ( ) ) ; } m_reader = m_pbd . openForRead ( CURSOR_NAME ) ; scheduleTaskFor ( m_pbd . getNonce ( ) , this : : deleteOldSegments , 0 ) ; }
response: public void startPolicyEnforcement() throws IOException { if (m_pbd.getUsageSpecificLog().isDebugEnabled()) { m_pbd.getUsageSpecificLog().debug("Starting time based retention policy enforcement with retainMillis=" + m_retainMillis + " for PBD " + m_pbd.getNonce()); } m_reader = m_pbd.openForRead(CURSOR_NAME); <START> scheduleTaskFor(m_pbd.getNonce(), this::deleteOldSegments, 0); <END> }

sample: 981
buggy_code: public void afterRun() throws Exception { if (recordStore.isWanReplicationEnabled()) { CacheRecord record = recordStore.getRecord(key); if (record != null) { publishWanUpdate(key, record); <START> } else { <END> publishWanRemove(key); } } super.afterRun(); }
code_review: Do you need to guard against `null` here as well?
target code: public void afterRun ( ) throws Exception { if ( recordStore == null ) { return ; } if ( recordStore . isWanReplicationEnabled ( ) ) { CacheRecord record = recordStore . getRecord ( key ) ; if ( record != null ) { publishWanUpdate ( key , record ) ; } else { publishWanRemove ( key ) ; } } super . afterRun ( ) ; }
response: public void afterRun() throws Exception { if (recordStore.isWanReplicationEnabled()) { CacheRecord record = recordStore.getRecord(key); if (record != null) { publishWanUpdate(key, record); } else { publishWanRemove(key); <START> } <END> } super.afterRun(); }

sample: 982
buggy_code: protected String getConfigRoot() { <START> return ClientConfigSections.HAZELCAST_CLIENT.name.toLowerCase(); <END> }
code_review: `toLowerCase`
target code: protected String getConfigRoot ( ) { return ClientConfigSections . HAZELCAST_CLIENT . name ; }
response: protected String getConfigRoot() { <START> return ClientConfigSections.HAZELCAST_CLIENT.name; <END> }

sample: 983
buggy_code: <START> public synchronized int getCapacity() { <END> return capacity; }
code_review: Does this method have to be synchronized, considering that `capacity` is `final`?
target code: public int getCapacity ( ) { return capacity ; }
response: <START> public int getCapacity() { <END> return capacity; }

sample: 984
buggy_code: private Set<IArtifactType> getAllArtTypes() { Set<IArtifactType> allArtTypes = new HashSet<>(); if (artifactTypes == null || !artifactTypes.isEmpty()) { <START> allArtTypes.addAll(artifactTypes); <END> } else { getArtifactTypesFromWorkItemTypes(); } return allArtTypes; }
code_review: why add 'null' to allArtTypes?
target code: private Set < IArtifactType > getAllArtTypes ( ) { Set < IArtifactType > allArtTypes = new HashSet < > ( ) ; if ( artifactTypes != null || ! artifactTypes . isEmpty ( ) ) { allArtTypes . addAll ( artifactTypes ) ; } else { allArtTypes = getArtifactTypesFromWorkItemTypes ( ) ; } return allArtTypes ; }
response: private Set<IArtifactType> getAllArtTypes() { Set<IArtifactType> allArtTypes = new HashSet<>(); if (artifactTypes == null || !artifactTypes.isEmpty()) { <START> allArtTypes.addAll(artifactTypes); <END> } else { getArtifactTypesFromWorkItemTypes(); } return allArtTypes; }

sample: 985
buggy_code: public void testContextListenerIsSet() throws Exception { try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class)) { tester.initialize(); Assert.assertTrue("Wizard is not on a valid state", tester.isValid()); Assert.assertTrue("Listener is not set", listener.isContextInitialized()); tester.execute(); <START> Assert.assertFalse("Listener is still set", listener.isContextInitialized()); <END> } }
code_review: This should be moved outside the try block
target code: public void testContextListenerIsSet ( ) throws Exception { try ( WizardCommandController tester = testHarness . createWizardController ( MyFirstWizard . class ) ) { tester . initialize ( ) ; Assert . assertTrue ( "Wizard is not on a valid state" , tester . isValid ( ) ) ; Assert . assertTrue ( "Listener is not set" , listener . isContextInitialized ( ) ) ; tester . execute ( ) ; } Assert . assertFalse ( "Listener is still set" , listener . isContextInitialized ( ) ) ; }
response: public void testContextListenerIsSet() throws Exception { try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class)) { tester.initialize(); Assert.assertTrue("Wizard is not on a valid state", tester.isValid()); Assert.assertTrue("Listener is not set", listener.isContextInitialized()); tester.execute(); <START> Assert.assertFalse("Listener is still set", listener.isContextInitialized()); <END> } }

sample: 986
buggy_code: <START> private Later(F0<A> producer) { <END> this.memo = P.hardMemo(producer); }
code_review: package private
target code: Later ( F0 < A > producer ) { this . memo = P . hardMemo ( producer ) ; }
response: <START> Later(F0<A> producer) { <END> this.memo = P.hardMemo(producer); }

sample: 987
buggy_code: private boolean isRunningFromCommandLine() { boolean runningFromCommandLine = false; // first look up all OptionProcessors and see if running from command line option is set Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class); Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator(); while (optionsIterator.hasNext()) { // find CommandLineOptionProcessor OptionProcessor processor = optionsIterator.next(); if (!(processor instanceof CommandLineOptionProcessor)) { continue; } // check if we are running from command line runningFromCommandLine = ((CommandLineOptionProcessor) processor).isRunFromCommandLine(); return runningFromCommandLine; } return false; <START> } <END>
code_review: Codacy flagged this method for "Avoid using a branching statement as the last in a loop." I think that is a reasonable call by Codacy and the code would be easier to read if runningFromCommandLine was set to true in the loop, followed by a break, and a single method return of runningFromCommandLine on what is currently line 136. Alternatively, one could also do away with runningFromCommandLine and have a return true statement in the loop, but I think the first alternative may be a little easier to read and will make Codacy content.
target code: private boolean isRunningFromCommandLine ( ) { // first look up all OptionProcessors and see if running from command line option is set Collection < ? extends OptionProcessor > optionProcessors = Lookup . getDefault ( ) . lookupAll ( OptionProcessor . class ) ; Iterator < ? extends OptionProcessor > optionsIterator = optionProcessors . iterator ( ) ; while ( optionsIterator . hasNext ( ) ) { // find CommandLineOptionProcessor OptionProcessor processor = optionsIterator . next ( ) ; if ( ( processor instanceof CommandLineOptionProcessor ) ) { // check if we are running from command line return ( ( CommandLineOptionProcessor ) processor ) . isRunFromCommandLine ( ) ; } } return false ; }
response: private boolean isRunningFromCommandLine() { boolean runningFromCommandLine = false; // first look up all OptionProcessors and see if running from command line option is set Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class); Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator(); while (optionsIterator.hasNext()) { // find CommandLineOptionProcessor OptionProcessor processor = optionsIterator.next(); if (!(processor instanceof CommandLineOptionProcessor)) { continue; } // check if we are running from command line runningFromCommandLine = ((CommandLineOptionProcessor) processor).isRunFromCommandLine(); break; } return runningFromCommandLine; <START> } <END>

sample: 988
buggy_code: <START> public Boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) { <END> for (CordovaPlugin plugin : this.pluginMap.values()) { if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) { return true; } } return false; }
code_review: Unless you want this to be tri-state, then "Boolean" should be "boolean". I don't see the need for tristate, so go with "boolean"
target code: public boolean onReceivedHttpAuthRequest ( CordovaWebView view , ICordovaHttpAuthHandler handler , String host , String realm ) { for ( CordovaPlugin plugin : this . pluginMap . values ( ) ) { if ( plugin != null && plugin . onReceivedHttpAuthRequest ( view , handler , host , realm ) ) { return true ; } } return false ; }
response: <START> public boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) { <END> for (CordovaPlugin plugin : this.pluginMap.values()) { if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) { return true; } } return false; }

sample: 989
buggy_code: private String createAndGetLockPath() throws InterruptedException, KeeperException { // Create locks if it does not exist <START> if (zk.exists(lockPath.toString(), false) == null) { <END> try { Util.mkdir(zk, lockPath.toString(), ZooDefs.Ids.OPEN_ACL_UNSAFE); } catch (CloudnameException e) { log.log( java.util.logging.Level.INFO, "CloudnameException while trying to get lock path " + absoluteLockPath, e); } } return lockPath + "/" + lockName; }
code_review: lockPath is already String
target code: private String createAndGetLockPath ( ) throws InterruptedException , KeeperException { // Create locks if it does not exist if ( zk . exists ( lockPath , false ) == null ) { try { Util . mkdir ( zk , lockPath , ZooDefs . Ids . OPEN_ACL_UNSAFE ) ; } catch ( CloudnameException e ) { log . log ( java . util . logging . Level . INFO , "CloudnameException while trying to get lock path " + absoluteLockPath , e ) ; } } return lockPath + " / " + lockName ; }
response: private String createAndGetLockPath() throws InterruptedException, KeeperException { // Create locks if it does not exist <START> if (zk.exists(lockPath, false) == null) { <END> try { Util.mkdir(zk, lockPath, ZooDefs.Ids.OPEN_ACL_UNSAFE); } catch (CloudnameException e) { log.log( java.util.logging.Level.INFO, "CloudnameException while trying to get lock path " + absoluteLockPath, e); } } return lockPath + "/" + lockName; }

sample: 990
buggy_code: public Tuple getTuple(EntityKey key, TupleContext tupleContext) { Entity entity = getEntity( key, tupleContext.getOptionsContext() ); if ( entity != null ) { return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } <START> else if ( isInTheQueue( key, tupleContext ) ) { <END> // The key has not been inserted in the db but it is in the queue return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } else { return null; } }
code_review: What I mean is, your dialect does not implement `BatchableGridDialect`, so items will never be put in to the operations queue.
target code: public Tuple getTuple ( EntityKey key , TupleContext tupleContext ) { Entity entity = getEntity ( key ) ; if ( entity != null ) { return new Tuple ( new RedisTupleSnapshot ( entity . getProperties ( ) ) ) ; } else { return null ; } }
response: public Tuple getTuple(EntityKey key, TupleContext tupleContext) { Entity entity = getEntity( key, tupleContext.getOptionsContext() ); if ( entity != null ) { return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } else { return null; } }

sample: 991
buggy_code: public void invoke(ClientEvent event) { try { method.invoke(listener, event); } catch (InvocationTargetException e) { log.errorInvokingListener(method, listener, e.getTargetException()); throw log.exceptionInvokingListener( e.getClass().getName(), method, listener, e.getTargetException()); } catch (Exception e) { throw log.exceptionInvokingListener( <START> e.getClass().getName(), method, listener, e); <END> } }
code_review: Isn't it enough to throw the logging exception instead of also logging locally ?
target code: public void invoke ( ClientEvent event ) { try { method . invoke ( listener , event ) ; } catch ( InvocationTargetException e ) { throw log . exceptionInvokingListener ( e . getClass ( ) . getName ( ) , method , listener , e . getTargetException ( ) ) ; } catch ( Exception e ) { throw log . exceptionInvokingListener ( e . getClass ( ) . getName ( ) , method , listener , e ) ; } }
response: public void invoke(ClientEvent event) { try { method.invoke(listener, event); } catch (InvocationTargetException e) { throw log.exceptionInvokingListener( e.getClass().getName(), method, listener, e.getTargetException()); } catch (Exception e) { throw log.exceptionInvokingListener( <START> e.getClass().getName(), method, listener, e); <END> } }

sample: 992
buggy_code: ConfigFileConfigProvider(@JsonProperty("configFile") String configFile){ this.configFile = configFile; <START> loadProperties(); <END> }
code_review: can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
target code: ConfigFileConfigProvider ( @JsonProperty ( "configFile" ) String configFile ) { loadProperties ( configFile ) ; }
response: ConfigFileConfigProvider(@JsonProperty("configFile") String configFile){ this.configFile = configFile; <START> loadProperties(configFile); <END> }

sample: 993
buggy_code: public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException { // Do nothing <START> System.out.println("### DefaultAddImageTaskIngestStream - addDataSource " + dataSourceObjectId); <END> }
code_review: No println's, please.
target code: public void addDataSource ( long dataSourceObjectId ) throws IngestStreamClosedException { // Do nothing }
response: public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException { // Do nothing }

sample: 994
buggy_code: private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite) { for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) { <START> Path path = declaredIntentionToWrite.getRootPath(); <END> if (declaredIntentionToWrite.isTemporaryTable()) { // for temporary table simply delete the entire directory deleteRecursivelyIfExists(declaredIntentionToWrite.getContext(), hdfsEnvironment, path); continue; } if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) { continue; } recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup"); } }
code_review: I don't know if they should be put inside this method or not. Should temp table be considered as staging directories?
target code: private void deleteEmptyStagingDirectories ( List < DeclaredIntentionToWrite > declaredIntentionsToWrite ) { for ( DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite ) { if ( declaredIntentionToWrite . getMode ( ) != WriteMode . STAGE_AND_MOVE_TO_TARGET_DIRECTORY ) { continue ; } Path path = declaredIntentionToWrite . getRootPath ( ) ; recursiveDeleteFilesAndLog ( declaredIntentionToWrite . getContext ( ) , path , ImmutableList . of ( ) , true , "staging directory cleanup" ) ; } }
response: private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite) { for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) { <START> Path path = declaredIntentionToWrite.getRootPath(); if (declaredIntentionToWrite.isTemporaryTable()) { // for temporary table simply delete the entire directory deleteRecursivelyIfExists(declaredIntentionToWrite.getContext(), hdfsEnvironment, path); continue; } if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) { continue; } recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup"); <END> } }

sample: 995
buggy_code: public void edit() { if (getWindow() != null) { return; } <START> EditDiskProfileModel model = <END> new EditDiskProfileModel(this, getCompatibilityVersion(), (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId()); setWindow(model); initProfileStorageDomains(model); }
code_review: format
target code: public void edit ( ) { if ( getWindow ( ) != null ) { return ; } EditDiskProfileModel model = new EditDiskProfileModel ( this , ( DiskProfile ) getSelectedItem ( ) , getEntity ( ) . getStoragePoolId ( ) ) ; setWindow ( model ) ; initProfileStorageDomains ( model ) ; }
response: public void edit() { if (getWindow() != null) { return; } <START> EditDiskProfileModel model = <END> new EditDiskProfileModel(this, getCompatibilityVersion(), (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId()); setWindow(model); initProfileStorageDomains(model); }

sample: 996
buggy_code: public void setUp() throws Exception { super.setUp(); gitDir = new File(project.getProject() .getLocationURI().getPath(), Constants.DOT_GIT); testRepository = new TestRepository(gitDir); testRepository.connect(project.getProject()); <START> testRepository.commit("initial commit"); <END> }
code_review: Please remove that line. It changes the tests.
target code: public void setUp ( ) throws Exception { super . setUp ( ) ; gitDir = new File ( project . getProject ( ) . getLocationURI ( ) . getPath ( ) , Constants . DOT_GIT ) ; testRepository = new TestRepository ( gitDir ) ; testRepository . connect ( project . getProject ( ) ) ; }
response: public void setUp() throws Exception { super.setUp(); gitDir = new File(project.getProject() .getLocationURI().getPath(), Constants.DOT_GIT); testRepository = new TestRepository(gitDir); testRepository.connect(project.getProject()); <START> testRepository.commit("initial commit"); <END> }

sample: 997
buggy_code: protected long getParentDid() { long deckID; <START> deckID = getCol().getDecks().selected(); <END> return deckID; }
code_review: should look like this but without the declaration above - they should be on one line ```suggestion long deckID = getCol().getDecks().selected(); ```
target code: protected long getParentDid ( ) { long deckID = getCol ( ) . getDecks ( ) . selected ( ) ; return deckID ; }
response: protected long getParentDid() { <START> long deckID = getCol().getDecks().selected(); <END> return deckID; }

sample: 998
buggy_code: public static String getFileExtension(File file) throws Exception { <START> return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); <END> }
code_review: Actually this part does not throw any Exception. Just remove `throws Exception` and we should be good. Beware of spaces vs tabs. Prefer using spaces for indentation please.
target code: public static String getFileExtension ( File file ) { return FilenameUtils . getExtension ( file . getAbsolutePath ( ) ) . toLowerCase ( ) ; }
response: public static String getFileExtension(File file) { <START> return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); <END> }

sample: 999
buggy_code: public void shouldPurgeAnAutoGenerationOption() throws Exception { <START> assertNotNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); <END> MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + "/" + getUuid()); req.addParameter("purge", ""); handle(req); assertNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); }
code_review: You do not need to call Integer.parseInt(getUuid()) more than once in a method.
target code: public void shouldPurgeAnAutoGenerationOption ( ) throws Exception { assertNotNull ( identifierSourceService . getAutoGenerationOption ( getId ( ) ) ) ; MockHttpServletRequest req = request ( RequestMethod . DELETE , getURI ( ) + " / " + getUuid ( ) ) ; req . addParameter ( "purge" , "" ) ; handle ( req ) ; assertNull ( identifierSourceService . getAutoGenerationOption ( getId ( ) ) ) ; }
response: public void shouldPurgeAnAutoGenerationOption() throws Exception { <START> int uuid = Integer.parseInt(getUuid()); assertNotNull(identifierSourceService.getAutoGenerationOption(uuid)); <END> MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + "/" + getUuid()); req.addParameter("purge", ""); handle(req); assertNull(identifierSourceService.getAutoGenerationOption(uuid)); }

sample: 1000
buggy_code: <START> private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) { <END> //long loadingStart = System.currentTimeMillis(); String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded); driver.get(standalonePerspectiveURL); BusyPopup.waitForDisappearance(); ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT); //double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000; //TODO: What is the acceptable loading time? Do we want to test this? //assertThat(perspectiveLoadingTime) // .as("It should take less than "+PERSPECTIVE_LOADING_TIMEOUT+" seconds to load the perspective " + perspectiveID + ".") // .isLessThan(PERSPECTIVE_LOADING_TIMEOUT); }
code_review: Any chance we could make this test `@Parameterized`? To test 35 different perspectives from within one test case seems evil. Alternatively (as I'm sniffing potential problems with the annotation and Arquillian.), can we at least make the looped code its own function and put some logging around it, so that we know when was it that the test actually failed? Of course, we could also have a different method for each of the perspectives - which would be the "cleanest" solution in this situation. But I sort of see how that would be overkill.
target code: private void loadPerspectiveAndCheckLoadingTime ( String perspectiveID , boolean headerIncluded ) { // long loadingStart = System . currentTimeMillis ( ) ; String standalonePerspectiveURL = getStandalonePerspectiveURL ( perspectiveID , headerIncluded ) ; driver . get ( standalonePerspectiveURL ) ; ApplicationLoadingPopup . waitForDisappearance ( PERSPECTIVE_LOADING_TIMEOUT ) ; BusyPopup . waitForDisappearance ( ) ; // double perspectiveLoadingTime = ( System . currentTimeMillis ( ) - loadingStart ) / ( double ) 1000 ; // TODO : What is the acceptable loading time ? Do we want to test this ? // assertThat ( perspectiveLoadingTime ) // . as ( "It should take less than " + PERSPECTIVE_LOADING_TIMEOUT + " seconds to load the perspective " + perspectiveID + " . " ) // . isLessThan ( PERSPECTIVE_LOADING_TIMEOUT ) ; }
response: <START> private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) { <END> long loadingStart = System.currentTimeMillis(); String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded); driver.get(standalonePerspectiveURL); BusyPopup.waitForDisappearance(); ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT); double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000; //TODO: What is the acceptable loading time? Do we want to test this? //assertThat(perspectiveLoadingTime) // .as("It should take less than "+PERSPECTIVE_LOADING_TIMEOUT+" seconds to load the perspective " + perspectiveID + ".") // .isLessThan(PERSPECTIVE_LOADING_TIMEOUT); }

sample: 1001
buggy_code: public default IVariableBinding[] getSyntheticOuterLocals() { return <START> null; <END> }
code_review: THis should return empty array
target code: public default IVariableBinding [ ] getSyntheticOuterLocals ( ) { return new IVariableBinding [ 0 ] ; }
response: public default IVariableBinding[] getSyntheticOuterLocals() { return <START> new IVariableBinding[0]; <END> }

sample: 1002
buggy_code: protected void executeCommand() { AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId()); if (profile == null) { setSucceeded(false); } else { sessionId = getParameters().getSessionId(); <START> sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId()); <END> sessionDataContainer.setSessionValid(getParameters().getSessionId(), false); setSucceeded(true); } }
code_review: Both should be initialized even for failures
target code: protected void executeCommand ( ) { AuthenticationProfile profile = sessionDataContainer . getProfile ( getParameters ( ) . getSessionId ( ) ) ; sessionId = getParameters ( ) . getSessionId ( ) ; sourceIp = sessionDataContainer . getSourceIp ( getParameters ( ) . getSessionId ( ) ) ; if ( profile == null ) { setSucceeded ( false ) ; } else { sessionDataContainer . setSessionValid ( getParameters ( ) . getSessionId ( ) , false ) ; setSucceeded ( true ) ; } }
response: protected void executeCommand() { AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId()); if (profile == null) { setSucceeded(false); } else { sessionId = getParameters().getSessionId(); <START> sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId()); sessionDataContainer.setSessionValid(getParameters().getSessionId(), false); <END> setSucceeded(true); } }

sample: 1003
buggy_code: public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) { if (TextSecurePreferences.isNotificationsEnabled(context)) { if (visibleThread == threadId) { DatabaseFactory.getThreadDatabase(context).setRead(threadId); sendInThreadNotification(context); } else { <START> updateNotification(context, masterSecret, true); <END> } } updateBadge(context); }
code_review: Sure you shouldn't do this if the thread is visible? This way, the notification will not disappear when the thread is visible for some reason.
target code: public static void updateNotification ( Context context , MasterSecret masterSecret , long threadId ) { if ( ! TextSecurePreferences . isNotificationsEnabled ( context ) ) { return ; } if ( visibleThread == threadId ) { DatabaseFactory . getThreadDatabase ( context ) . setRead ( threadId ) ; sendInThreadNotification ( context ) ; } else { updateNotification ( context , masterSecret , true ) ; } }
response: public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) { if (TextSecurePreferences.isNotificationsEnabled(context)) { if (visibleThread == threadId) { DatabaseFactory.getThreadDatabase(context).setRead(threadId); sendInThreadNotification(context); } else { updateNotification(context, masterSecret, true); } } updateBadge(context); }

sample: 1004
buggy_code: protected void fillOptions(Map<Enum, String> options) { options.put(EnumModel.VAL1, <START> EnumModel.VAL1.toString()); <END> options.put(EnumModel.VAL2, EnumModel.VAL2.toString()); options.put(EnumModel.VAL3, EnumModel.VAL3.toString()); options.put(EnumModel.VAL4, EnumModel.VAL4.toString()); }
code_review: not sure if makes sense, but instead of putting the `toString()` as values, I probably would use the Enum's `name() `method, as the `toString()` is usually been overridden...
target code: protected void fillOptions ( Map < Enum , String > options ) { options . put ( EnumModel . VAL1 , EnumModel . VAL1 . name ( ) ) ; options . put ( EnumModel . VAL2 , EnumModel . VAL2 . name ( ) ) ; options . put ( EnumModel . VAL3 , EnumModel . VAL3 . name ( ) ) ; options . put ( EnumModel . VAL4 , EnumModel . VAL4 . name ( ) ) ; }
response: protected void fillOptions(Map<Enum, String> options) { options.put(EnumModel.VAL1, <START> EnumModel.VAL1.name()); <END> options.put(EnumModel.VAL2, EnumModel.VAL2.name()); options.put(EnumModel.VAL3, EnumModel.VAL3.name()); options.put(EnumModel.VAL4, EnumModel.VAL4.name()); }

sample: 1005
buggy_code: public boolean removeQueues(Queue... queues) { <START> removeQueues(Arrays.asList(queues) <END> .stream() .map(Queue::getName)); return super.removeQueues(queues); }
code_review: The same `Arrays.stream()` can be applied here as well.
target code: public boolean removeQueues ( Queue . . . queues ) { removeQueues ( Arrays . stream ( queues ) . map ( Queue : : getName ) ) ; return super . removeQueues ( queues ) ; }
response: public boolean removeQueues(Queue... queues) { <START> removeQueues(Arrays.stream(queues) <END> .map(Queue::getName)); return super.removeQueues(queues); }

sample: 1006
buggy_code: private static Object castIntegerToObect(int value, Type type) { if (type == INTEGER || type == TINYINT || type == BIGINT) { return (long) value; } if (type == VARCHAR) { <START> return value + ""; <END> } if (type == DOUBLE) { return (double) value; } throw new UnsupportedOperationException(); }
code_review: String.valueOf()
target code: private static Object castIntegerToObect ( int value , Type type ) { if ( type == INTEGER || type == TINYINT || type == BIGINT ) { return ( long ) value ; } if ( type == VARCHAR ) { return String . valueOf ( value ) ; } if ( type == DOUBLE ) { return ( double ) value ; } throw new UnsupportedOperationException ( ) ; }
response: private static Object castIntegerToObect(int value, Type type) { if (type == INTEGER || type == TINYINT || type == BIGINT) { return (long) value; } if (type == VARCHAR) { <START> return String.valueOf(value); <END> } if (type == DOUBLE) { return (double) value; } throw new UnsupportedOperationException(); }

sample: 1007
buggy_code: public void testXmlConfig() throws IOException { EmbeddedCacheManager cm = new DefaultCacheManager("jpa-config.xml"); Cache<String, KeyValueEntity> specificCache = cm.getCache("specificCache"); validateConfig(specificCache); KeyValueEntity entity = new KeyValueEntity("k", "v"); specificCache.put(entity.getK(), entity); <START> cm.stop(); <END> }
code_review: `stop()` should be in a finally block, or you could use `TestingUtil.withCacheManager()`.
target code: public void testXmlConfig ( ) throws IOException { EmbeddedCacheManager cm = null ; try { cm = new DefaultCacheManager ( "jpa - config . xml" ) ; Cache < String , KeyValueEntity > specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } finally { if ( cm != null ) cm . stop ( ) ; } }
response: public void testXmlConfig() throws IOException { EmbeddedCacheManager cm = new DefaultCacheManager("jpa-config.xml"); Cache<String, KeyValueEntity> specificCache = cm.getCache("specificCache"); validateConfig(specificCache); KeyValueEntity entity = new KeyValueEntity("k", "v"); specificCache.put(entity.getK(), entity); <START> TestingUtil.withCacheManager(cm, new CacheManagerCallable(cm) { @Override public void call() { cm.stop(); } }); <END> }

sample: 1008
buggy_code: public boolean equals(Object o) { boolean equals = this == o || o instanceof <START> URIEditorInput && <END> getURI().equals(((URIEditorInput) o).getURI()); if (equals && o instanceof SessionEditorInput) { EObject input = getInput(false); if (input != null) { SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o; return input.equals(otherSessionEditorInput.getInput(false)); } } return equals; }
code_review: Shouldn't this be SessionEditorInput? Here equals() can return true for instances of different subclasses of URIEditorInput which point to the same URI. I have not checked, but maybe it happen could if have my aird opened at the same time inside a non-Sirius editor.
target code: public boolean equals ( Object o ) { boolean equals = this == o || o instanceof SessionEditorInput && getURI ( ) . equals ( ( ( SessionEditorInput ) o ) . getURI ( ) ) ; if ( equals && o instanceof SessionEditorInput ) { EObject input = getInput ( false ) ; if ( input != null ) { SessionEditorInput otherSessionEditorInput = ( SessionEditorInput ) o ; return input . equals ( otherSessionEditorInput . getInput ( false ) ) ; } } return equals ; }
response: public boolean equals(Object o) { boolean equals = this == o || o instanceof <START> SessionEditorInput && <END> getURI().equals(((URIEditorInput) o).getURI()); if (equals && o instanceof SessionEditorInput) { EObject input = getInput(false); if (input != null) { SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o; return input.equals(otherSessionEditorInput.getInput(false)); } } return equals; }

sample: 1009
buggy_code: private void loadChildEntities(LibraryDilution dilution) throws IOException { if (dilution.getLibrary() != null) { dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId())); } if (dilution.getTargetedSequencing() != null) { dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId())); } <START> dilution.setDilutionCreator(authorizationManager.getCurrentUsername()); <END> }
code_review: This will cause creator to change on every update
target code: private void loadChildEntities ( LibraryDilution dilution ) throws IOException { if ( dilution . getLibrary ( ) != null ) { dilution . setLibrary ( libraryDao . get ( dilution . getLibrary ( ) . getId ( ) ) ) ; } if ( dilution . getTargetedSequencing ( ) != null ) { dilution . setTargetedSequencing ( targetedSequencingDao . get ( dilution . getTargetedSequencing ( ) . getId ( ) ) ) ; } }
response: private void loadChildEntities(LibraryDilution dilution) throws IOException { if (dilution.getLibrary() != null) { dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId())); } if (dilution.getTargetedSequencing() != null) { dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId())); } if (dilution.getDilutionCreator() == null) { dilution.setDilutionCreator(authorizationManager.getCurrentUsername()); } }

sample: 1010
buggy_code: GdkColor getContextColor () { long /*int*/ fontHandle = fontHandle (); long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle); GdkRGBA rgba = new GdkRGBA (); if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) { rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba); } else { <START> int styleState = OS.gtk_widget_get_state_flags(handle); <END> rgba = display.styleContextGetColor (context, styleState, rgba); } return display.toGdkColor (rgba); }
code_review: No need to have the styleState variable at all.
target code: GdkColor getContextColor ( ) { long /* int */ fontHandle = fontHandle ( ) ; long /* int */ context = OS . gtk_widget_get_style_context ( fontHandle ) ; int styleState = OS . gtk_widget_get_state_flags ( handle ) ; GdkRGBA rgba = new GdkRGBA ( ) ; rgba = display . styleContextGetColor ( context , styleState , rgba ) ; return display . toGdkColor ( rgba ) ; }
response: GdkColor getContextColor () { long /*int*/ fontHandle = fontHandle (); long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle); GdkRGBA rgba = new GdkRGBA (); if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) { rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba); } else { <START> rgba = display.styleContextGetColor (context, OS.gtk_widget_get_state_flags(handle), rgba); <END> } return display.toGdkColor (rgba); }

sample: 1011
buggy_code: public Subquery parameter(String listId, Object... values) { if (values == null || values.length == 0 || values[0] == null) { return this; } where.setToNormal(); where.setToIntersection(); where.addParameter(listId, values); <START> return this; <END> }
code_review: These 2 can be called just once.
target code: public Subquery parameter ( String listId , Object . . . values ) { if ( values == null || values . length == 0 || values [ 0 ] == null ) { return this ; } where . setToIntersection ( ) ; where . addParameter ( listId , values ) ; return this ; }
response: public Subquery parameter(String listId, Object... values) { if (values == null || values.length == 0 || values[0] == null) { return this; } where.setToNormal(); where.setToIntersection(); where.addParameter(listId, values); <START> return this; <END> }

sample: 1012
buggy_code: public int hashCode() { <START> int result = (key ? 1 : 0); <END> result = 31 * result + (path != null ? path.hashCode() : 0); return result; }
code_review: Minor : parentheses are not needed
target code: public int hashCode ( ) { int result = key ? 1 : 0 ; result = 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; return result ; }
response: public int hashCode() { <START> int result = key ? 1 : 0; <END> result = 31 * result + (path != null ? path.hashCode() : 0); return result; }

sample: 1013
buggy_code: public boolean doSynchronousPing() { MerlinLog.d("Pinging : " + hostAddress); try { <START> int responseCode = responseCodeFetcher.from(hostAddress); <END> MerlinLog.d("Got response : " + responseCode); } catch (RequestException e) { if (e.causedByIO()) { return false; } throw e; } return true; }
code_review: Is this only used for logging?
target code: public boolean doSynchronousPing ( ) { MerlinLog . d ( "Pinging : " + hostAddress ) ; try { responseCodeFetcher . from ( hostAddress ) ; } catch ( RequestException e ) { if ( e . causedByIO ( ) ) { return false ; } throw e ; } return true ; }
response: public boolean doSynchronousPing() { <START> MerlinLog.d("Pinging : " + hostAddress); <END> try { int responseCode = responseCodeFetcher.from(hostAddress); MerlinLog.d("Got response : " + responseCode); } catch (RequestException e) { if (e.causedByIO()) { return false; } throw e; } return true; }

sample: 1014
buggy_code: public T hasThisElement(final Object val) { Assert.parametersNotNull("val", val); <START> return addCriteria(FilterOperator.ELEMENT_MATCH, val, not); <END> }
code_review: Is that bug reported? If not, it should be so we can track that it's getting fixed. Also, ensure that the bug fix should be done in a separate commit from the new feature work for elemMatch (I didn't check).
target code: public T hasThisElement ( final Object val ) { Assert . parametersNotNull ( "val" , val ) ; return addCriteria ( FilterOperator . ELEMENT_MATCH , val , false ) ; }
response: public T hasThisElement(final Object val) { Assert.parametersNotNull("val", val); <START> return addCriteria(FilterOperator.ELEMENT_MATCH, val, not); <END> }

sample: 1015
buggy_code: public Builder setSSHDirectory(final File sshDirectory) { this.sshDirectory = sshDirectory; <START> return this; <END> }
code_review: Since this class overrides the ```equals``` method, it also needs to override the ```hashCode``` method. Let me know if you have any questions on this.
target code: public Builder setSSHDirectory ( final File sshDirectory ) { Assert . assertNotNull ( sshDirectory ) ; this . sshDirectory = sshDirectory ; return this ; }
response: public Builder setSSHDirectory(final File sshDirectory) { this.sshDirectory = sshDirectory; return this; }

sample: 1016
buggy_code: public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException { List<Attribute> attributes = new ArrayList<>(); for (Service service : services) { <START> getRequiredAttributes(sess, service, facility, resource, user, member); <END> } return attributes; }
code_review: I believe you want to add result into the ``attributes`` list. Also, what if required attributes of passed services overlap? We probably should gather them into the set before returning as list.
target code: public List < Attribute > getRequiredAttributes ( PerunSession sess , List < Service > services , Facility facility , Resource resource , User user , Member member ) throws MemberResourceMismatchException { Set < Attribute > attributes = new HashSet < > ( ) ; for ( Service service : services ) { attributes . addAll ( getRequiredAttributes ( sess , service , facility , resource , user , member ) ) ; } return new ArrayList < > ( attributes ) ; }
response: public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException { List<Attribute> attributes = new ArrayList<>(); for (Service service : services) { <START> attributes.addAll(getRequiredAttributes(sess, service, facility, resource, user, member)); <END> } return attributes; }

sample: 1017
buggy_code: public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min, final int offset, final int count) { <START> sendCommand(ZREVRANGEBYSCORE, key, toByteArray(min), toByteArray(max), LIMIT.raw, toByteArray(offset), <END> toByteArray(count), WITHSCORES.raw); }
code_review: parameter sequence swapped: max, min is correct.
target code: public void zrevrangeByScoreWithScores ( final byte [ ] key , final double max , final double min , final int offset , final int count ) { sendCommand ( ZREVRANGEBYSCORE , key , toByteArray ( max ) , toByteArray ( min ) , LIMIT . raw , toByteArray ( offset ) , toByteArray ( count ) , WITHSCORES . raw ) ; }
response: public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min, final int offset, final int count) { <START> sendCommand(ZREVRANGEBYSCORE, key, toByteArray(max), toByteArray(min), LIMIT.raw, toByteArray(offset), <END> toByteArray(count), WITHSCORES.raw); }

sample: 1018
buggy_code: public void write(int b) throws IOException { mSingleCharWrite[0] = (byte) b; <START> write(mSingleCharWrite, 0, 1); <END> }
code_review: `write(mSingleCharWrite)`?
target code: public void write ( int b ) throws IOException { mSingleCharWrite [ 0 ] = ( byte ) b ; write ( mSingleCharWrite ) ; }
response: public void write(int b) throws IOException { mSingleCharWrite[0] = (byte) b; <START> write(mSingleCharWrite); <END> }

sample: 1019
buggy_code: public void deallocateFlow(String flowId) throws FlowNotFoundException, ProvisionerException { try { String netId = getNetworkSelector().findNetworkForFlowId(flowId); <START> getNclController().deallocateFlow(netId, flowId); <END> } catch (Exception e) { throw new ProvisionerException(e); } }
code_review: this method expects flowId, netId as parameters. Be careful with the order!
target code: public void deallocateFlow ( String flowId ) throws FlowNotFoundException , ProvisionerException { try { String netId = getNetworkSelector ( ) . findNetworkForFlowId ( flowId ) ; getNclController ( ) . deallocateFlow ( flowId , netId ) ; } catch ( Exception e ) { throw new ProvisionerException ( e ) ; } }
response: public void deallocateFlow(String flowId) throws FlowNotFoundException, ProvisionerException { try { String netId = getNetworkSelector().findNetworkForFlowId(flowId); <START> getNclController().deallocateFlow(netId, flowId); <END> } catch (Exception e) { throw new ProvisionerException(e); } }

sample: 1020
buggy_code: private String _encode(String strVal) { try { return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString()); } catch (UnsupportedEncodingException e) { <START> return e.getMessage(); <END> } }
code_review: Perhaps in this case the best is to just rethrow the exception as a RuntimeException
target code: private String _encode ( String strVal ) { try { return URLEncoder . encode ( strVal , StandardCharsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
response: private String _encode(String strVal) { try { return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString()); } catch (UnsupportedEncodingException e) { <START> throw new RuntimeException(e); <END> } }

sample: 1021
buggy_code: public boolean contains(Object o) { <START> boolean contains = super.contains(o); <END> if (!contains && o != null) { MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true); contains = me != null; } return contains; }
code_review: if o is null, should no we just return false ?
target code: public boolean contains ( Object o ) { boolean contains = false ; if ( o != null ) { contains = super . contains ( o ) ; if ( ! contains ) { MarshalledEntry < K , V > me = persistenceManager . loadFromAllStores ( o , true ) ; contains = me != null ; } } return contains ; }
response: public boolean contains(Object o) { <START> boolean contains = super.contains(o); <END> if (!contains && o != null) { MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true); contains = me != null; } return contains; }

sample: 1022
buggy_code: public boolean provides(IOperation operation) { if (!(operation instanceof CreateDecoratorsOperation)) { return false; } IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget(); <START> View view = decoratorTarget.getAdapter(View.class); <END> return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view)); }
code_review: The cast should not be removed to avoid compilation errors on Eclipse versions which do not have the generified getAdapter.
target code: public boolean provides ( IOperation operation ) { if ( ! ( operation instanceof CreateDecoratorsOperation ) ) { return false ; } IDecoratorTarget decoratorTarget = ( ( CreateDecoratorsOperation ) operation ) . getDecoratorTarget ( ) ; View view = ( View ) decoratorTarget . getAdapter ( View . class ) ; return view != null && DDiagramEditPart . MODEL_ID . equals ( SiriusVisualIDRegistry . getModelID ( view ) ) ; }
response: public boolean provides(IOperation operation) { if (!(operation instanceof CreateDecoratorsOperation)) { return false; } IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget(); <START> View view = (View) decoratorTarget.getAdapter(View.class); <END> return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view)); }

sample: 1023
buggy_code: public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() { CuratedContentPageObject ccp = new CuratedContentPageObject(driver); wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC); ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE); MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject( driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY); <START> <END> String oldUrl = driver.getCurrentUrl(); ccp.clickOnCuratedContentElementByIndex(2); Assertion.assertTrue(mercuryAlert.isAlertMessageVisible()); ccp.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl); }
code_review: remove extra line
target code: public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert ( ) { CuratedContentPageObject ccp = new CuratedContentPageObject ( driver ) ; wikiURL = urlBuilder . getUrlForWiki ( MercuryWikis . MERCURY_CC ) ; ccp . openMercuryArticleByNameWithNoCacheBuster ( wikiURL , MercurySubpages . CC_MAIN_PAGE ) ; MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject ( driver , MercuryAlertComponentObject . AlertMessage . NOT_EXISTING_CATEGORY ) ; String oldUrl = driver . getCurrentUrl ( ) ; ccp . clickOnCuratedContentElementByIndex ( 2 ) ; Assertion . assertTrue ( mercuryAlert . isAlertMessageVisible ( ) ) ; ccp . waitForLoadingSpinnerToFinish ( ) ; Assertion . assertUrlEqualToCurrentUrl ( driver , oldUrl ) ; }
response: public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() { CuratedContentPageObject ccp = new CuratedContentPageObject(driver); wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC); ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE); MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject( driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY); <START> <END> String oldUrl = driver.getCurrentUrl(); ccp.clickOnCuratedContentElementByIndex(2); Assertion.assertTrue(mercuryAlert.isAlertMessageVisible()); ccp.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl);

sample: 1024
buggy_code: private void testUpdateInterface(Guid interface_id) { VdsNetworkInterface iface = dao.get(interface_id); iface.setName(iface.getName().toUpperCase()); iface.setQos(newQos); dao.updateInterfaceForVds(iface); VdsNetworkInterface ifaced = dao.get(interface_id); <START> assertTrue(ifaced.getName().equals(iface.getName()) && ifaced.getQos().equals(iface.getQos())); <END> }
code_review: I would use a couple of assert equals since they give better output in case of failure. (Remember that the expected value should be the first one)
target code: private void testUpdateInterface ( Guid interface_id ) { VdsNetworkInterface iface = dao . get ( interface_id ) ; iface . setName ( iface . getName ( ) . toUpperCase ( ) ) ; iface . setQos ( newQos ) ; dao . updateInterfaceForVds ( iface ) ; VdsNetworkInterface ifaced = dao . get ( interface_id ) ; assertEquals ( iface . getName ( ) , ifaced . getName ( ) ) ; assertEquals ( iface . getQos ( ) , ifaced . getQos ( ) ) ; }
response: private void testUpdateInterface(Guid interface_id) { VdsNetworkInterface iface = dao.get(interface_id); iface.setName(iface.getName().toUpperCase()); iface.setQos(newQos); dao.updateInterfaceForVds(iface); VdsNetworkInterface ifaced = dao.get(interface_id); <START> assertEquals(iface.getName(), ifaced.getName()); assertEquals(iface.getQos(), ifaced.getQos()); <END> }

sample: 1025
buggy_code: public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException { if (patientProgram.getPatientProgramId() == null) { sessionFactory.getCurrentSession().save(patientProgram); } else { sessionFactory.getCurrentSession().merge(patientProgram); } <START> CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram); <END> return patientProgram; }
code_review: Shouldn't this be done before the patientProgram is saved, instead of after?
target code: public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } return patientProgram ; }
response: public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException { <START> CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram); <END> if (patientProgram.getPatientProgramId() == null) { sessionFactory.getCurrentSession().save(patientProgram); } else { sessionFactory.getCurrentSession().merge(patientProgram); } return patientProgram; }

sample: 1026
buggy_code: public UploadDirectoryToCDN(String username, String apiKey) { Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule()); BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER) .credentials(username, apiKey) .modules(modules) .buildView(BlobStoreContext.class); storage = context.getBlobStore(); <START> rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi(); <END> }
code_review: Does `unwrapApi` not work for some reason? Just curious...it would make a nice example of the new call, that's why I ask...
target code: public UploadDirectoryToCDN ( String username , String apiKey ) { BlobStoreContext context = ContextBuilder . newBuilder ( PROVIDER ) . credentials ( username , apiKey ) . buildView ( BlobStoreContext . class ) ; storage = context . getBlobStore ( ) ; rackspace = context . unwrap ( CloudFilesApiMetadata . CONTEXT_TOKEN ) . getApi ( ) ; // can use unwrapApi ( ) in jclouds 1 . 7 . 0 }
response: public UploadDirectoryToCDN(String username, String apiKey) { Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule()); BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER) .credentials(username, apiKey) .modules(modules) .buildView(BlobStoreContext.class); storage = context.getBlobStore(); <START> rackspace = context.unwrapApi(CloudFilesApi.class); <END> }

sample: 1027
buggy_code: public SslContextBuilder keyManager(KeyManager keyManager) { <START> if (forServer) { <END> checkNotNull(keyManager, "keyManager required for servers"); } this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager); keyCertChain = null; key = null; keyPassword = null; return this; }
code_review: The `forServer == false` flow looks wrong. If `null` is passed, then `KeyManagerFactoryWrapper` will throw (and we probably want the `keyManagerFactory` to be `null` in that case).
target code: public SslContextBuilder keyManager ( KeyManager keyManager ) { if ( forServer ) { checkNotNull ( keyManager , "keyManager required for servers" ) ; } if ( keyManager != null ) { this . keyManagerFactory = new KeyManagerFactoryWrapper ( keyManager ) ; } else { this . keyManagerFactory = null ; } keyCertChain = null ; key = null ; keyPassword = null ; return this ; }
response: public SslContextBuilder keyManager(KeyManager keyManager) { <START> if (forServer) { checkNotNull(keyManager, "keyManager required for servers"); } <END> this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager); keyCertChain = null; key = null; keyPassword = null; return this; }

sample: 1028
buggy_code: <START> public boolean isTypeSupported(Class<T> clazz) { <END> // TODO: Add other types? Float, etc if (String.class.isAssignableFrom(clazz) || Integer.class.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz)) { return true; } return false; }
code_review: Should this be protected, or do we really want to allow to call it outside this class?
target code: protected boolean isTypeSupported ( Class < T > clazz ) { // TODO : Add other types ? Float , etc if ( String . class . isAssignableFrom ( clazz ) || Integer . class . isAssignableFrom ( clazz ) || Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } return false ; }
response: <START> protected boolean isTypeSupported(Class<T> clazz) { <END> // TODO: Add other types? Float, etc if (String.class.isAssignableFrom(clazz) || Integer.class.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz)) { return true; } return false; }

sample: 1029
buggy_code: private List<Person> createModel() { List<Person> elements = new ArrayList<Person>(4); elements.add(new Person("Tom", "Schindl", "tom.schindl@bestsolution.at")); elements.add(new Person("Boris", "Bokowski", <START> "Boris_Bokowski@ca.ibm.com")); <END> elements.add(new Person("Tod", "Creasey", "Tod_Creasey@ca.ibm.com")); elements.add(new Person("Wayne", "Beaton", "wayne@eclipse.org")); return elements; }
code_review: Replace Boris?
target code: private List < Person > createModel ( ) { List < Person > elements = new ArrayList < Person > ( 4 ) ; elements . add ( new Person ( "Tom" , "Schindl" , "tom . schindl@bestsolution . at" ) ) ; elements . add ( new Person ( "Tod" , "Creasey" , "Tod_Creasey@ca . ibm . com" ) ) ; elements . add ( new Person ( "Wayne" , "Beaton" , "wayne@eclipse . org" ) ) ; return elements ; }
response: private List<Person> createModel() { List<Person> elements = new ArrayList<Person>(4); elements.add(new Person("Tom", "Schindl", "tom.schindl@bestsolution.at")); elements.add(new Person("Boris", "Bokowski", <START> "Boris_Bokowski@ca.ibm.com")); elements.add(new Person("Tod", "Creasey", "Tod_Creasey@ca.ibm.com")); elements.add(new Person("Wayne", "Beaton", "wayne@eclipse.org")); return elements; }

sample: 1030
buggy_code: protected void updateIteration() { <START> refreshIteration = refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE; <END> }
code_review: maybe better to separate the incerement and then check
target code: protected void updateIteration ( ) { refreshIteration = ( ++ refreshIteration ) % NUMBER_VMS_REFRESHES_BEFORE_SAVE ; }
response: protected void updateIteration() { <START> refreshIteration = (refreshIteration + 1) % NUMBER_VMS_REFRESHES_BEFORE_SAVE; <END> }

sample: 1031
buggy_code: public void add(E newInterval) { super.add(newInterval); <START> fListeners.stream().forEach(l -> l.elementAdded(this, newInterval)); <END> }
code_review: you can do fListeners.forEach() directly on Collections
target code: public void add ( E newInterval ) { super . add ( newInterval ) ; }
response: public void add(E newInterval) { super.add(newInterval); <START> fListeners.forEach(l -> l.elementAdded(this, newInterval)); <END> }

sample: 1032
buggy_code: public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) { this.docsToCheckAndEvents = docsToCheckAndEvents; <START> List<String> docs = new ArrayList<String>(); <END> docs.addAll(docsToCheckAndEvents.keySet()); setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs); }
code_review: `new ArrayList<String>();` -> `new ArrayList<>();`
target code: public RuleEvaluationWorker ( Map < String , Set < String > > docsToCheckAndEvents ) { this . docsToCheckAndEvents = docsToCheckAndEvents ; List < String > docs = new ArrayList < > ( ) ; docs . addAll ( docsToCheckAndEvents . keySet ( ) ) ; setDocuments ( Framework . getService ( RepositoryManager . class ) . getDefaultRepositoryName ( ) , docs ) ; }
response: public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) { this.docsToCheckAndEvents = docsToCheckAndEvents; <START> List<String> docs = new ArrayList<>(); <END> docs.addAll(docsToCheckAndEvents.keySet()); setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs); }

sample: 1033
buggy_code: private static String getTestingAlias(GoImportSpec testingImportSpec) { String alias = GoConstants.TESTING_PATH; <START> if (testingImportSpec != null) { <END> alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : ""; } return alias; }
code_review: alias variable is redundant
target code: private static String getTestingAlias ( GoImportSpec testingImportSpec ) { return testingImportSpec == null ? GoConstants . TESTING_PATH : ! testingImportSpec . isDot ( ) ? StringUtil . notNullize ( testingImportSpec . getAlias ( ) , GoConstants . TESTING_PATH ) : "" ; }
response: private static String getTestingAlias(GoImportSpec testingImportSpec) { String alias = GoConstants.TESTING_PATH; <START> if (testingImportSpec != null) { <END> alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : ""; } return alias; }

sample: 1034
buggy_code: public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) { <START> this.populate(source); <END> }
code_review: This should be using `super(source);` instead of the populate method (I know it was like this in `ComplianceStatusDTO`, and it is wrong there too).
target code: public SystemPurposeComplianceStatusDTO ( SystemPurposeComplianceStatusDTO source ) { super ( source ) ; }
response: public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) { <START> super(source); <END> }

sample: 1035
buggy_code: public MapOperation() { final ILogger logger = this.logger(); final int forcedEvictionRetryCount = getRetryCount(); evictions = new Eviction[]{ new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new AllEntriesEviction(logger, this), <START> new PartitionAllEntriesEviction(logger, this) <END> }; }
code_review: We create a new map-operation for every call, so moving `evictions` here doesn't make any difference.
target code: public MapOperation ( ) { }
response: public MapOperation() { final ILogger logger = this.logger(); final int forcedEvictionRetryCount = getRetryCount(); evictions = new Eviction[]{ new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new AllEntriesEviction(logger, this), new PartitionAllEntriesEviction(logger, this) }; }

sample: 1036
buggy_code: private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) { Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP); <START> if (timestamp instanceof String) return Instant.parse(timestamp.toString()); <END> return Instant.ofEpochMilli((long) timestamp); }
code_review: We do not use single line if-statements throughout the project. Yes it's a nitty point, but I'd prefer you change it to curly braces.
target code: private static Instant retrieveDeadlineTimestamp ( JobDataMap jobDataMap ) { Object timestamp = jobDataMap . get ( MESSAGE_TIMESTAMP ) ; if ( timestamp instanceof String ) { return Instant . parse ( timestamp . toString ( ) ) ; } return Instant . ofEpochMilli ( ( long ) timestamp ) ; }
response: private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) { Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP); <START> if (timestamp instanceof String) { return Instant.parse(timestamp.toString()); } <END> return Instant.ofEpochMilli((long) timestamp); }

sample: 1037
buggy_code: <START> public AggregatorFactory[] getMetrics() <END> { return metrics; }
code_review: Do all of these getters need to be public ? I think except `getBytesInMemory()`, others can be default package access.
target code: AggregatorFactory [ ] getMetrics ( ) { return metrics ; }
response: <START> AggregatorFactory[] getMetrics() <END> { return metrics; }

sample: 1038
buggy_code: public void prepare() throws IOException { e = SQLExecutor.builder(clusterService) <START> .enableDefaultTables() <END> .addTable("create table t (" + " id integer primary key," + " qty integer constraint check_qty_gt_zero check (qty > 0)," + " constraint check_id_ge_zero check (id >= 0)" + ")") .build(); plannerContext = e.getPlannerContext(clusterService.state()); }
code_review: ```suggestion ``` Please don't add tables that are not used. Wastes CPU cycles.
target code: public void prepare ( ) throws IOException { e = SQLExecutor . builder ( clusterService ) . addTable ( "create table t ( " + " id integer primary key , " + " qty integer constraint check_qty_gt_zero check ( qty > 0 ) , " + " constraint check_id_ge_zero check ( id >= 0 ) " + " ) " ) . build ( ) ; plannerContext = e . getPlannerContext ( clusterService . state ( ) ) ; }
response: public void prepare() throws IOException { e = SQLExecutor.builder(clusterService) <START> .enableDefaultTables() <END> .build(); plannerContext = e.getPlannerContext(clusterService.state()); }

sample: 1039
buggy_code: public void setUp() { <START> jUnitCore = new JUnitCore(); <END> testListener = new TestListener(); jUnitCore.addListener(testListener); }
code_review: In JUnit4-style tests, you can assign variables where they are defined (and make them final if you want :-). JUnit4 won't create an instance of the class until just before it is run, and it will make it eligible for garbage collection right after it is run.
target code: public void setUp ( ) { jUnitCore . addListener ( testListener ) ; }
response: public void setUp() { <START> jUnitCore = new JUnitCore(); <END> testListener = new TestListener(); jUnitCore.addListener(testListener); }

sample: 1040
buggy_code: protected boolean validate() { if (!canRunActionOnNonManagedVm()) { return false; } if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) { addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE); return false; } <START> ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this, <END> getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils())); return validator.validate(); }
code_review: I tend to agree. I mean the validator should not be used in other places, as its name indicates, but several times we extended the use of validators in the past so it may be the better approach to simplify its instantiation
target code: protected boolean validate ( ) { if ( ! canRunActionOnNonManagedVm ( ) ) { return false ; } if ( ! isInternalExecution ( ) && ! ObjectIdentityChecker . canUpdateField ( getVm ( ) , "clusterId" , getVm ( ) . getStatus ( ) ) ) { addValidationMessage ( EngineMessage . VM_STATUS_NOT_VALID_FOR_UPDATE ) ; return false ; } ChangeVmClusterValidator validator = ChangeVmClusterValidator . create ( this , getParameters ( ) . getClusterId ( ) , getParameters ( ) . getVmCustomCompatibilityVersion ( ) ) ; return validator . validate ( ) ; }
response: protected boolean validate() { if (!canRunActionOnNonManagedVm()) { return false; } if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) { addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE); return false; } <START> ChangeVmClusterValidator validator = new ChangeVmClusterValidator(this, <END> getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils()); return validator.validate(); }

sample: 1041
buggy_code: public TrustManagerFactory getTrustMgr(String serverName) { try { <START> KeyStore trustStore = trustMgrMap.get(serverName); <END> if (trustStore != null) { TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); fact.init(trustStore); return fact; } return null; } catch (NoSuchAlgorithmException | KeyStoreException e) { throw new RuntimeException(e); } }
code_review: I would prefer this code to be done in the `KeyStoreHelper` constructor and keep a `Map<String, TrustManagerFactory >` so can be detected at this moment and this is also like how we do for the SNI key manager mapping.
target code: public TrustManagerFactory getTrustMgr ( String serverName ) { return trustMgrMap . get ( serverName ) ; }
response: public TrustManagerFactory getTrustMgr(String serverName) { try { <START> KeyStore trustStore = trustMgrMap.get(serverName); <END> if (trustStore != null) { TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); fact.init(trustStore); return fact; } return null; } catch (NoSuchAlgorithmException | KeyStoreException e) { throw new RuntimeException(e); } }

sample: 1042
buggy_code: public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) { boolean tmp = this.isInModuleInfo; this.isInModuleInfo = true; TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator); <START> this.isInModuleInfo = tmp; <END> return edit; }
code_review: I suggest putting this into a finally block.
target code: public TextEdit formatModuleInfoFile ( int kind , String source , int offset , int length , int indentationLevel , String lineSeparator ) { boolean tmp = this . isInModuleInfo ; try { this . isInModuleInfo = true ; return format ( kind , source , new IRegion [ ] { new Region ( offset , length ) } , indentationLevel , lineSeparator ) ; } finally { this . isInModuleInfo = tmp ; } }
response: public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) { boolean tmp = this.isInModuleInfo; this.isInModuleInfo = true; TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator); try { <START> this.isInModuleInfo = tmp; <END> return edit; } finally { this.isInModuleInfo = tmp; } }

sample: 1043
buggy_code: public <K, V> RemoteCache<K, V> getCache(String cacheName) { <START> RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE ); <END> if ( cache == null ) { throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) ); } return cache; }
code_review: Should this become a property?
target code: public < K , V > RemoteCache < K , V > getCache ( String cacheName ) { RemoteCache < K , V > cache = hotrodClient . getCache ( cacheName ) ; if ( cache == null ) { throw log . expectedCachesNotDefined ( Collections . singleton ( cacheName ) ) ; } return cache ; }
response: public <K, V> RemoteCache<K, V> getCache(String cacheName) { <START> RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE ); <END> if ( cache == null ) { throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) ); } return cache; }

sample: 1044
buggy_code: public static Object valueForStringWithType(String value, VoltType type) { <START> if (type == null || type == VoltType.NULL) { <END> return null; } // leverage existing (rather heavyweight) code to convert param types Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value); // check the result type in an assert assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType())); return retval; }
code_review: do we allow `type == null`? It doesn't make sense to me to take a value without type info. probably add a precondition check to forbid that.
target code: public static Object valueForStringWithType ( String value , VoltType type ) { if ( type == VoltType . NULL ) { return null ; } // leverage existing ( rather heavyweight ) code to convert param types Object retval = ParameterConverter . tryToMakeCompatible ( type . classFromType ( ) , value ) ; // check the result type in an assert assert ( ParameterConverter . verifyParameterConversion ( retval , type . classFromType ( ) ) ) ; return retval ; }
response: public static Object valueForStringWithType(String value, VoltType type) { <START> if (type == null || type == VoltType.NULL) { <END> return null; } // leverage existing (rather heavyweight) code to convert param types Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value); // check the result type in an assert assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType())); return retval; }

sample: 1045
buggy_code: public void testContructor() throws IOException { String code = "S2020-04-04"; ReportingPeriod period = ReportingPeriod.from(code); assertEquals(period.getClass(), SinceX.class); <START> assertEquals(period.getClass(), SinceX.class); <END> }
code_review: doppelt?
target code: public void testContructor ( ) throws IOException { String code = "S2020 - 04 - 04" ; ReportingPeriod period = ReportingPeriod . from ( code ) ; assertEquals ( period . getClass ( ) , SinceX . class ) ; }
response: public void testContructor() throws IOException { String code = "S2020-04-04"; ReportingPeriod period = ReportingPeriod.from(code); assertEquals(period.getClass(), SinceX.class); <START> assertEquals(period.getClass(), SinceX.class); assertEquals(period.getClass(), SinceX.class); <END> }

sample: 1046
buggy_code: public void testGetConnectableFileStorageConnectionsByStorageType() { List<StorageServerConnections> conns = dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS); assertNotNull(conns); assertEquals(1, conns.size()); for (StorageServerConnections conn : conns) { <START> assertTrue(conn.getstorage_type() == StorageType.NFS); <END> } }
code_review: please user assertEquals
target code: public void testGetConnectableFileStorageConnectionsByStorageType ( ) { List < StorageServerConnections > conns = dao . getConnectableStorageConnectionsByStorageType ( FixturesTool . STORAGE_POOL_NFS_2 , StorageType . NFS ) ; assertNotNull ( conns ) ; assertEquals ( 1 , conns . size ( ) ) ; for ( StorageServerConnections conn : conns ) { assertEquals ( StorageType . NFS , conn . getstorage_type ( ) ) ; } }
response: public void testGetConnectableFileStorageConnectionsByStorageType() { List<StorageServerConnections> conns = dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS); assertNotNull(conns); assertEquals(1, conns.size()); for (StorageServerConnections conn : conns) { <START> assertEquals(conn.getstorage_type(), StorageType.NFS); <END> } }

sample: 1047
buggy_code: public static void setOverrideFileName(String... path) { fOverridePath = <START> (path == null) ? null : path; <END> fOverride = true; }
code_review: path
target code: public static void setOverrideFileName ( String . . . path ) { fOverridePath = path ; fOverride = true ; }
response: public static void setOverrideFileName(String... path) { fOverridePath = <START> (path == null) ? null : path; <END> fOverride = true; }

sample: 1048
buggy_code: void addChanges(Collection<String> filesToUpdate, Collection<IResource> resourcesToUpdate) { synchronized (lock) { files.addAll(filesToUpdate); resources.addAll(resourcesToUpdate); } <START> if (!filesToUpdate.isEmpty()) { <END> schedule(defaultDelay); } }
code_review: Small style nit: We don't use braces around simple statements.
target code: void addChanges ( Collection < String > filesToUpdate , Collection < IResource > resourcesToUpdate ) { synchronized ( lock ) { files . addAll ( filesToUpdate ) ; resources . addAll ( resourcesToUpdate ) ; } if ( ! filesToUpdate . isEmpty ( ) ) schedule ( defaultDelay ) ; }
response: void addChanges(Collection<String> filesToUpdate, Collection<IResource> resourcesToUpdate) { synchronized (lock) { files.addAll(filesToUpdate); resources.addAll(resourcesToUpdate); } <START> if (!filesToUpdate.isEmpty()) <END> schedule(defaultDelay); }

sample: 1049
buggy_code: public static synchronized String getEncryptionKey(String name) { <START> final String keyString = getUniqueId(name); <END> if (CACHED_ENCRYPTION_KEYS.get(keyString) == null) { generateEncryptionKey(keyString); } return CACHED_ENCRYPTION_KEYS.get(keyString); }
code_review: Why not use name as the key in CACHED_ENCRYPTION_KEYS?
target code: public static synchronized String getEncryptionKey ( String name ) { if ( CACHED_ENCRYPTION_KEYS . get ( name ) == null ) { generateEncryptionKey ( name ) ; } return CACHED_ENCRYPTION_KEYS . get ( name ) ; }
response: public static synchronized String getEncryptionKey(String name) { <START> final String keyString = getUniqueId(name); <END> if (CACHED_ENCRYPTION_KEYS.get(name) == null) { generateEncryptionKey(keyString); } return CACHED_ENCRYPTION_KEYS.get(name); }

sample: 1050
buggy_code: public void init(IEditorSite site, IEditorInput input) { super.init(site, input); TaskData taskData = getModel().getTaskData(); if (taskData != null) { GerritChange change = GerritUtil.getChange(taskData); final ChangeDetailX detail = change.getChangeDetail(); try { review = GerritUtil.toReview(detail); } catch (GerritException e) { <START> throw new RuntimeException(e); <END> } } }
code_review: That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
target code: public void init ( IEditorSite site , IEditorInput input ) { super . init ( site , input ) ; TaskData taskData = getModel ( ) . getTaskData ( ) ; if ( taskData != null ) { GerritChange change = GerritUtil . getChange ( taskData ) ; final ChangeDetailX detail = change . getChangeDetail ( ) ; review = GerritUtil . toReview ( detail ) ; } }
response: public void init(IEditorSite site, IEditorInput input) { super.init(site, input); TaskData taskData = getModel().getTaskData(); if (taskData != null) { GerritChange change = GerritUtil.getChange(taskData); final ChangeDetailX detail = change.getChangeDetail(); try { review = GerritUtil.toReview(detail); } catch (GerritException e) { <START> StatusHandler.log(new Status(IStatus.ERROR, GerritUiPlugin.PLUGIN_ID, "Could not load review", e)); <END> } } }

sample: 1051
buggy_code: public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { <START> return new SnapshotInfo(EMPTY_STRING); <END> }
code_review: This will create a new object every time the method is called. Is this wanted? If not it'd be better to store the object once and always return it (static field).
target code: public ISnapshotInfo getSnapshotInfo ( String sessionName , IProgressMonitor monitor ) throws ExecutionException { return null ; }
response: public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { <START> return new SnapshotInfo(EMPTY_STRING); <END> }

sample: 1052
buggy_code: public long getEntryLastModified() { if (modTimes == null) return 0; Long cutOff = Long.valueOf(super.getEntryLastModified()); <START> SortedSet<Long> head = modTimes.headSet(cutOff, true); <END> return head.isEmpty() ? 0 : head.last().longValue(); }
code_review: headSet(Object,boolean) is a Java 6 API. We need to define cutOff as super.getEntryLastModified() - 1 instead.
target code: public long getEntryLastModified ( ) { if ( modTimes == null ) return 0 ; Long cutOff = Long . valueOf ( super . getEntryLastModified ( ) + 1 ) ; SortedSet < Long > head = modTimes . headSet ( cutOff ) ; return head . isEmpty ( ) ? 0 : head . last ( ) . longValue ( ) ; }
response: public long getEntryLastModified() { if (modTimes == null) return 0; Long cutOff = Long.valueOf(super.getEntryLastModified() - 1); <START> SortedSet<Long> head = modTimes.headSet(cutOff, true); <END> return head.isEmpty() ? 0 : head.last().longValue(); }

sample: 1053
buggy_code: public ParameterizedSqlFactory(String initialSql) { sqlStringBuilder = new StringBuilder(initialSql); <START> parameters = new ArrayList(); <END> }
code_review: Initialization of the list should use generics. For this case, you can specify an empty generic-type placeholder and the compiler should be able to auto-detect what type should be used.
target code: public ParameterizedSqlFactory ( String initialSql ) { sqlStringBuilder = new StringBuilder ( initialSql ) ; parameters = new ArrayList < > ( ) ; }
response: public ParameterizedSqlFactory(String initialSql) { sqlStringBuilder = new StringBuilder(initialSql); <START> parameters = new ArrayList<>(); <END> }

sample: 1054
buggy_code: public long getReadyTimestamp(Constraints viewConstraints) { String normalizedConstraints = getNormalizedConstraints(viewConstraints); Path signalPath = new Path(signalDirectory, normalizedConstraints); // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath); return signalStatus.getModificationTime(); } catch (final FileNotFoundException ex) { // empty, will be thrown when the signal path doesn't exist } return -1; <START> } catch (NumberFormatException e) { <END> throw new DatasetException("Signal contents were modified to not be a number: " + signalPath, e); } catch (IOException e) { throw new DatasetIOException("Could not access signal path: " + signalPath, e); } }
code_review: Is this needed? What throws NumberFormatException?
target code: public long getReadyTimestamp ( Constraints viewConstraints ) { String normalizedConstraints = getNormalizedConstraints ( viewConstraints ) ; Path signalPath = new Path ( signalDirectory , normalizedConstraints ) ; // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem . getFileStatus ( signalPath ) ; return signalStatus . getModificationTime ( ) ; } catch ( final FileNotFoundException ex ) { // empty , will be thrown when the signal path doesn't exist } return - 1 ; } catch ( IOException e ) { throw new DatasetIOException ( "Could not access signal path : " + signalPath , e ) ; } }
response: public long getReadyTimestamp(Constraints viewConstraints) { String normalizedConstraints = getNormalizedConstraints(viewConstraints); Path signalPath = new Path(signalDirectory, normalizedConstraints); // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath); return signalStatus.getModificationTime(); } catch (final FileNotFoundException ex) { // empty, will be thrown when the signal path doesn't exist } return -1; <START> } catch (NumberFormatException e) { <END> throw new DatasetException("Signal contents were modified to not be a number: " + signalPath, e); } catch (IOException e) { throw new DatasetIOException("Could not access signal path: " + signalPath, e); } }

sample: 1055
buggy_code: private boolean hostHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); if (cluster == null) { return false; } ArchitectureType archType = cluster.getArchitecture(); return <START> (archType == ArchitectureType.ppc64) || <END> (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle); }
code_review: Use equals instead of '==' as follows (And do the same for the 2 other conditions): ArchitectureType.ppc64.equals(archType);
target code: private boolean hostHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; if ( cluster == null ) { return false ; } ArchitectureType archType = cluster . getArchitecture ( ) ; return ArchitectureType . ppc64 . equals ( archType ) || ArchitectureType . ppc64le . equals ( archType ) || ArchitectureType . ppcle . equals ( archType ) ; }
response: private boolean hostHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); if (cluster == null) { return false; } ArchitectureType archType = cluster.getArchitecture(); return <START> ArchitectureType.ppc64.equals(archType) || <END> (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle); }

sample: 1056
buggy_code: private static String getExtension(String name) { int ext = name.lastIndexOf('.'); return 0 < ext ? <START> name.substring(ext, name.length()) : <END> ""; }
code_review: name.substring(ext) is equivalent and shorter to write.
target code: private static String getExtension ( String name ) { int ext = name . lastIndexOf ( ' . ' ) ; return 0 < ext ? name . substring ( ext ) : "" ; }
response: private static String getExtension(String name) { int ext = name.lastIndexOf('.'); return 0 < ext ? <START> name.substring(ext) : <END> ""; }

sample: 1057
buggy_code: public void checkpoint() { <START> throw new UnsupportedOperationException("Checkpoint is not supported in NoopJournalSystem"); <END> }
code_review: more consistent to make this a no-op like other methods
target code: public void checkpoint ( ) { }
response: public void checkpoint() { <START> <END> }

sample: 1058
buggy_code: private void recalculateMacsCount() { if (!validate()) { setAvailableMacsCount(-1); return; } if (macRange.getMacPoolId() == null) { String from = getLeftBound().getEntity(); String to = getRightBound().getEntity(); <START> Long count <END> = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1; setAvailableMacsCount(count.intValue()); } }
code_review: macToLong returns 'long'
target code: private void recalculateMacsCount ( ) { if ( ! validate ( ) ) { setAvailableMacsCount ( - 1 ) ; return ; } if ( macRange . getMacPoolId ( ) == null ) { String from = getLeftBound ( ) . getEntity ( ) ; String to = getRightBound ( ) . getEntity ( ) ; long count = MacRangeValidation . macToLong ( to ) - MacRangeValidation . macToLong ( from ) + 1 ; setAvailableMacsCount ( ( int ) count ) ; } }
response: private void recalculateMacsCount() { if (!validate()) { setAvailableMacsCount(-1); return; } if (macRange.getMacPoolId() == null) { String from = getLeftBound().getEntity(); String to = getRightBound().getEntity(); <START> long count <END> = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1; setAvailableMacsCount((int) count); } }

sample: 1059
buggy_code: public void setup() { <START> buffer = (DiskBuffer) new DiskBuffer(BUFFER_DIR, maxEvents); <END> }
code_review: Is this cast necessary?
target code: public void setup ( ) { buffer = new DiskBuffer ( BUFFER_DIR , maxEvents ) ; }
response: public void setup() { <START> buffer = new DiskBuffer(BUFFER_DIR, maxEvents); <END> }

sample: 1060
buggy_code: private boolean filterInvalid(Position position) { <START> return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLongitude() > 180; <END> }
code_review: It would make sense to check minimum values as well.
target code: private boolean filterInvalid ( Position position ) { if ( filterInvalid == true ) { return ! position . getValid ( ) || position . getLatitude ( ) > 90 || position . getLongitude ( ) > 180 || position . getLatitude ( ) < - 90 || position . getLongitude ( ) < - 180 ; } return false ; }
response: private boolean filterInvalid(Position position) { <START> return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLatitude() < -90 || position.getLongitude() > 180 || position.getLongitude() < -180; <END> }

sample: 1061
buggy_code: public Set<Location> getAllowedLocations() { Set<Location> allowedLocations = new HashSet<Location>(); allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <START> return allowedLocations; <END> }
code_review: Understood. IntelliJ does however suggest this small change: return new HashSet<Location>( asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE));
target code: public Set < Location > getAllowedLocations ( ) { return new HashSet < Location > ( asList ( CONSTRUCTOR , METHOD , FIELD , OVERVIEW , PACKAGE , TYPE ) ) ; }
response: public Set<Location> getAllowedLocations() { Set<Location> allowedLocations = new HashSet<Location>(); allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <START> return new HashSet<Location>(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <END> }

sample: 1062
buggy_code: public String getTasksJsonString(long taskId) throws JSONException { TaskObject task = TaskObject.get(taskId); <START> return new ConvertSprintBacklog().getTaskJsonString(task); <END> }
code_review: getTaskJsonString()  static method
target code: public String getTasksJsonString ( long taskId ) throws JSONException { TaskObject task = TaskObject . get ( taskId ) ; return ConvertSprintBacklog . getTaskJsonString ( task ) ; }
response: public String getTasksJsonString(long taskId) throws JSONException { TaskObject task = TaskObject.get(taskId); <START> return ConvertSprintBacklog.getTaskJsonString(task); <END> }

sample: 1063
buggy_code: <START> private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { <END> TransactionSupport.executeInNewTransaction( new TransactionMethod<Void>() { @Override public Void runInTransaction() { // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); return null; } }); }
code_review: no need explicitly open transaction, only one save to DB, transaction will be open automaticly
target code: private void addVolumeToDb ( final GlusterVolumeEntity createdVolume ) { // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume . setClusterId ( getVdsGroupId ( ) ) ; DbFacade . getInstance ( ) . getGlusterVolumeDao ( ) . save ( createdVolume ) ; }
response: <START> private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { <END> // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); }

sample: 1064
buggy_code: public Sheet getDataSheet(File file) { stream = new PushbackInputStream(new FileInputStream(file)); Workbook wb = null; try { wb = WorkbookFactory.create(stream); } catch (Exception e) { <START> Log.error("Workbook creation exception:" + e); <END> } return wb.getSheetAt(0); }
code_review: It seems this have added a new import: org.jfree.util.Log, why not use the same log object as line 204? log.error("Workbook creation exception", e); ? Is there a reason behind using 2 different ways of logging errors?
target code: public Sheet getDataSheet ( File file ) { Workbook wb = null ; try { stream = new PushbackInputStream ( new FileInputStream ( file ) ) ; wb = WorkbookFactory . create ( stream ) ; } catch ( Exception e ) { log . error ( "Workbook creation exception : " + e ) ; } return wb . getSheetAt ( 0 ) ; }
response: public Sheet getDataSheet(File file) { stream = new PushbackInputStream(new FileInputStream(file)); Workbook wb = null; try { wb = WorkbookFactory.create(stream); } catch (Exception e) { <START> log.error("Workbook creation exception", e); <END> } return wb.getSheetAt(0); }

sample: 1065
buggy_code: public void updateAttributes() { OperatingSystem operatingSystem = getCurrentOperatingSystem(); if (operatingSystem != null) { OSProcess process = operatingSystem.getProcess(this.processID); if (process != null) { copyValuesToThisProcess(process); } else { <START> LOG.error("No process found: {}", this.processID); <END> } } else { LOG.error("Unsupported platform. No update performed."); } }
code_review: That's not much different than the current `getProcess(int processID)` except with an optional rather than null. (And the API for that is fixed so we can't change it.) That's not the problem I'm discussing... the problem is that someone writing `new OSProcess(1234)` will definitely get a Process object unless we throw an exception. We could throw an `InstantiationError`, for example, and require them to handle it. Or a `MissingResourceException`. Or return a class with the pid and essentially zero data. Perhaps I should have thought about this dilemma before suggesting the feature!
target code: public boolean updateAttributes ( ) { OSProcess process = operatingSystem . getProcess ( this . processID ) ; if ( process == null ) { LOG . debug ( "No process found : { } " , this . processID ) ; return false ; } copyValuesToThisProcess ( process ) ; return true ; }
response: public void updateAttributes() { OperatingSystem operatingSystem = getCurrentOperatingSystem(); if (operatingSystem != null) { OSProcess process = operatingSystem.getProcess(this.processID); if (process != null) { copyValuesToThisProcess(process); } else { <START> LOG.error("No process found: {}", this.processID); <END> } } else { LOG.error("Unsupported platform. No update performed."); } }

sample: 1066
buggy_code: public boolean isMissingHookConflict() { <START> return (this.conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue(); <END> }
code_review: avoid using this in these cases.
target code: public boolean isMissingHookConflict ( ) { return ( conflictStatus & MISSING_HOOK . getValue ( ) ) == MISSING_HOOK . getValue ( ) ; }
response: public boolean isMissingHookConflict() { <START> return (conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue(); <END> }

sample: 1067
buggy_code: public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups( final boolean recursive) { if (!recursive) { if (isResolved()) { return Collections.emptyMap(); <START> } else { <END> return Collections.singletonMap(getGroup().getGroupUUID(), this); } } else { return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>()); } }
code_review: Nit: My pref would be to eliminate the unneeded elses (117,120) since there are returns.
target code: public Map < AccountGroup . UUID , GroupMembersList > getUnresolvedGroups ( final boolean recursive ) { if ( ! recursive ) { if ( isResolved ( ) ) { return Collections . emptyMap ( ) ; } return Collections . singletonMap ( getGroup ( ) . getGroupUUID ( ) , this ) ; } return getAllUnresolvedGroups ( new HashSet < AccountGroup . Id > ( ) ) ; }
response: public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups( final boolean recursive) { if (!recursive) { if (isResolved()) { return Collections.emptyMap(); <START> } <END> return Collections.singletonMap(getGroup().getGroupUUID(), this); } else { return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>()); } }

sample: 1068
buggy_code: public boolean nextBoolean() throws IOException { requirePeek(); boolean value; try { <START> value = parser.getBooleanValue(); <END> } catch (JsonParseException e) { value = Boolean.parseBoolean(parser.getValueAsString()); } clearPeek(); return value; }
code_review: Can you use `parser.getCurrentToken()` to detect JSON type ?
target code: public boolean nextBoolean ( ) throws IOException { requirePeek ( ) ; boolean value = parser . getBooleanValue ( ) ; clearPeek ( ) ; return value ; }
response: public boolean nextBoolean() throws IOException { requirePeek(); boolean value; try { <START> value = parser.getBooleanValue(); <END> } catch (JsonParseException e) { value = Boolean.parseBoolean(parser.getValueAsString()); } clearPeek(); return value; }

sample: 1069
buggy_code: <START> boolean closeOnProtocolViolation() { <END> return closeOnProtocolViolation; }
code_review: why are all methods public except this one ?
target code: public boolean closeOnProtocolViolation ( ) { return closeOnProtocolViolation ; }
response: <START> public boolean closeOnProtocolViolation() { <END> return closeOnProtocolViolation; }

sample: 1070
buggy_code: <START> public String getSelinuxEnforceMode() { <END> if (selinuxEnforceMode == null) { // Nothing } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) { return constants.disabled(); } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) { return constants.permissive(); } else if (selinuxEnforceMode .equals(SELinuxMode.ENFORCING)) { return constants.enforcing(); } return constants.notAvailableLabel(); }
code_review: This should be done using the EnumTranslator. For example, see VmGeneralModel - > updateProperties(). In addition, add the appropriate values to LocalizedEnums.java an LocalizedEnums.properties.
target code: public String getSelinuxEnforceMode ( ) { return selinuxEnforceMode ; }
response: <START> public String getSelinuxEnforceMode() { <END> return EnumTranslator.getInstance().get(selinuxEnforceMode); }

sample: 1072
buggy_code: public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } // toolkit.paintBordersFor(main); this.layout(); }
code_review: Why do you perform this test on FeaturesProvider's class? This really looks strange and I do not see how this relates to the goal of this commit...
target code: public void init ( EObject original , EditingDomain editingDomain ) { List < EStructuralFeature > features = featuresProvider . getFeatures ( original ) ; initControlFactory ( editingDomain , original ) ; for ( final EStructuralFeature feature : features ) { createControlForFeature ( feature ) ; } // toolkit . paintBordersFor ( main ) ; this . layout ( ) ; }
response: public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } // toolkit.paintBordersFor(main); this.layout(); }

sample: 1073
buggy_code: public List<Annotation> getQualifiers() { return new ArrayList<Annotation>( <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ); }
code_review: I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList.
target code: public List < Annotation > getQualifiers ( ) { return Arrays . asList ( ( Annotation ) new org . jboss . arquillian . warp . servlet . AfterServlet ( ) { @Override public Class < ? extends Annotation > annotationType ( ) { return org . jboss . arquillian . warp . servlet . AfterServlet . class ; } } ) ; }
response: public List<Annotation> getQualifiers() { return <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ; }

sample: 1074
buggy_code: protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> Subject.doAs(subj, new PrivilegedExceptionAction<Void>() { <END> public Void run() throws Exception { remoteCacheManager = new RemoteCacheManager(config, true); return null; } }); remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); }
code_review: It should not be necessary to crate the RemoteCacheManager in a PrivligedAction. Only the GSSAPI mech requires a Subject to initialize the SASL client, and that should be passed in by the configuration
target code: protected void initialize ( Subject subj ) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig ( subj ) ; remoteCacheManager = new RemoteCacheManager ( config , true ) ; remoteCache = remoteCacheManager . getCache ( TEST_CACHE_NAME ) ; }
response: protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> remoteCacheManager = new RemoteCacheManager(config, true); <END> remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); }

sample: 1075
buggy_code: <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); }
code_review: Shouldn't this copy in `baseSelectors`? I know it it currently empty, but the code implies you want to add another selector to the base selectors.
target code: LauncherDiscoveryRequest buildRequest ( Bundle bundle ) { List < DiscoverySelector > selectors = new ArrayList < > ( baseSelectors . size ( ) + 1 ) ; selectors . addAll ( baseSelectors ) ; selectors . add ( BundleSelector . selectBundle ( bundle ) ) ; return LauncherDiscoveryRequestBuilder . request ( ) . configurationParameter ( BundleEngine . CHECK_UNRESOLVED , unresolved ) . selectors ( selectors ) . build ( ) ; }
response: <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.addAll(baseSelectors); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); }

sample: 1076
buggy_code: protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } }
code_review: there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.
target code: protected void statementExecuteUpdateBefore ( StatementProxy statement , String sql ) { super . statementExecuteUpdateBefore ( statement , sql ) ; Before ( statement , sql ) ; }
response: protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } }

sample: 1077
buggy_code: public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); <START> return new DecoderResult(cause); <END> }
code_review: nit: merge lines
target code: public static DecoderResult failure ( Throwable cause ) { return new DecoderResult ( ObjectUtil . checkNotNull ( cause , "cause" ) ) ; }
response: public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); return new DecoderResult(cause); }

sample: 1078
buggy_code: private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); }
code_review: Why 5? Just use the default unless there's a good reason not to.
target code: private void writeObject ( Schema schema , GenericRecord datum ) throws Exception { BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( new ByteArrayOutputStream ( ) , null ) ; GenericDatumWriter < GenericData . Record > writer = new GenericDatumWriter < GenericData . Record > ( schema ) ; writer . write ( schema , datum , encoder ) ; }
response: private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); }

sample: 1079
buggy_code: public Collection<String> getNames() { if (names == null) { <START> names = new HashSet<>(named.keySet()); <END> namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); } return Collections.unmodifiableSet(names); }
code_review: Sorry--what I meant before was to just build and return the collection on _every_ invocation, rather than storing it in a field. There's only one place calling this method now, so the caching doesn't buy us anything.
target code: public Collection < String > getNames ( ) { final Set < String > names = new HashSet < > ( named . keySet ( ) ) ; namedArgumentFinder . forEach ( args - > names . addAll ( args . getNames ( ) ) ) ; return Collections . unmodifiableSet ( names ) ; }
response: public Collection<String> getNames() { <START> Set<String> names = new HashSet<>(named.keySet()); namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); return Collections.unmodifiableSet(names); <END> }

sample: 1080
buggy_code: public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.error("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; }
code_review: Hmmm. I'm thinking we might want to turn this into a logger.warning instead. I'd use the error only if the program cannot proceed, while in this case the consumer code is responsible for reacting to a null return: this particular piece of code can cope perfectly well with it.
target code: public FBOConfig getFboConfig ( ResourceUrn fboName ) { FBOConfig fboConfig = fboConfigs . get ( fboName ) ; if ( fboConfig == null ) { logger . warn ( "Failed to retrieve FBOConfig '" + fboName + "' ! " ) ; } return fboConfig ; }
response: public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.warning("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; }

sample: 1081
buggy_code: <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; }
code_review: This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance (to clarify see the surrounding diff since this preview gets confused)
target code: protected void setKey ( Input newInput , char newKeyChar ) { this . input = newInput ; this . keyChar = newKeyChar ; }
response: <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; }

sample: 1082
buggy_code: public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; }
code_review: This doesn't seem right, the call to org.infinispan.configuration.cache.EvictionConfigurationBuilder#strategy(org.infinispan.eviction.EvictionStrategy) is missing completely, thus the default strategy will always be NONE.
target code: public Builder < EvictionConfiguration > configure ( OperationContext context , ModelNode model ) throws OperationFailedException { EvictionStrategy strategy = ModelNodes . asEnum ( STRATEGY . getDefinition ( ) . resolveModelAttribute ( context , model ) , EvictionStrategy . class ) ; this . builder . strategy ( strategy ) ; if ( strategy . isEnabled ( ) ) { this . builder . type ( EvictionType . COUNT ) . size ( MAX_ENTRIES . getDefinition ( ) . resolveModelAttribute ( context , model ) . asLong ( ) ) ; } return this ; }
response: public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.strategy(strategy).type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; }

sample: 1083
buggy_code: public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } }
code_review: `CompletableFuture<Boolean>` to avoid raw types
target code: public void closed ( BoltConnection connection ) { String id = connection . id ( ) ; try { CompletableFuture < Boolean > currentFuture = activeWorkItems . remove ( id ) ; if ( currentFuture != null ) { currentFuture . cancel ( true ) ; } } finally { activeConnections . remove ( id ) ; } }
response: public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture<Boolean> currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } }

sample: 1084
buggy_code: public void testIsExternalVM() throws IOException { try { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> }
code_review: https://i0.wp.com/100happybirthdaymemes.com/wp-content/uploads/2016/06/grumpy-cat-no-4.jpg In other words: throw the exception upwards and fail the test if parsing the XML fails.
target code: public void testIsExternalVM ( ) throws Exception { XmlDocument xmlDocument = new XmlDocument ( getXmlOvfData ( ) ) ; assertFalse ( "VM should not be external VM" , OvfUtils . isExternalVM ( xmlDocument ) ) ; }
response: public void testIsExternalVM() throws IOException { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> }

sample: 1085
buggy_code: public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> if (fileList == null) { return false; } for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; }
code_review: Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files
target code: public static boolean folderContains ( File folder , String filename ) { if ( folder == null ) { return false ; } File [ ] fileList = folder . listFiles ( ) ; if ( fileList == null ) { return false ; } for ( File f : fileList ) { if ( f . getName ( ) . equals ( filename ) ) { return true ; } } return false ; }
response: public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; }

sample: 1086
buggy_code: public void addWhiteListPatterns(String... patterns) { <START> this.whiteListPatterns.addAll(Arrays.asList(patterns)); <END> }
code_review: `Collections.addAll(whiteListPatterns, patterns)` can be used here.
target code: public void addWhiteListPatterns ( String . . . patterns ) { Collections . addAll ( this . whiteListPatterns , patterns ) ; }
response: public void addWhiteListPatterns(String... patterns) { <START> Collections.addAll(whiteListPatterns, patterns); <END> }

sample: 1087
buggy_code: private Long getRegistrationMillis(String playerName) { <START> if (!isRegistered(playerName.toLowerCase())) { <END> return null; } PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; }
code_review: I think that this check can be avoided as we already check if auth != null below
target code: private Long getRegistrationMillis ( String playerName ) { PlayerAuth auth = playerCache . getAuth ( playerName ) ; if ( auth == null ) { auth = dataSource . getAuth ( playerName ) ; } if ( auth != null ) { return auth . getRegistrationDate ( ) ; } return null ; }
response: private Long getRegistrationMillis(String playerName) { <START> PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; <END> }

sample: 1088
buggy_code: public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (numSegments < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; }
code_review: typo: capacityFactor instead of numSegments
target code: public HashConfigurationBuilder capacityFactor ( float capacityFactor ) { if ( capacityFactor < 0 ) throw new IllegalArgumentException ( "capacityFactor must be positive" ) ; this . capacityFactor = capacityFactor ; return this ; }
response: public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (capacityFactor < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; }

sample: 1089
buggy_code: public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } <START> allocateCurrentArray(); <END> }
code_review: This is not needed here
target code: public synchronized void onHeaders ( Response response ) { long length = response . getHeaders ( ) . getLongField ( HttpHeader . CONTENT_LENGTH . asString ( ) ) ; if ( length > maxLength ) { response . abort ( new ResponseTooLargeException ( ) ) ; } }
response: public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } allocateCurrentArray(); }

sample: 1090
buggy_code: public WorkspaceItem build() { try { return workspaceItem; <START> } catch (Exception e) { <END> return handleException(e); } }
code_review: The return statement can never throw an exception here. So please remove the try-catch block.
target code: public WorkspaceItem build ( ) { return workspaceItem ; }
response: public WorkspaceItem build() { return workspaceItem; <START> }

sample: 1091
buggy_code: <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); }
code_review: Why sorted map? TreeMap is sorted already?!
target code: public static SortedMap < String , Charset > requiredCharsets ( ) { return REQUIRED_CHARSETS ; }
response: <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); }

sample: 1092
buggy_code: protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED); <END> }
code_review: [minor] Split into two asserts or add a message showing what the offending value actually is?
target code: protected void checkProject ( Project project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . getProjectApi ( ) . getProject ( project . getId ( ) ) . toString ( ) ) ; assertTrue ( project . getState ( ) != null ) ; assertTrue ( project . getState ( ) != Project . State . UNRECOGNIZED ) ; }
response: protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue("Project state is null", project.getState() != null); assertTrue("Project state is UNRECOGNIZED", project.getState() != Project.State.UNRECOGNIZED); <END> }

sample: 1093
buggy_code: public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, GUID.create(), name, CoreBranches.COMMON, artifactType); <END> }
code_review: Please call ArtifactToken constructors without guid.
target code: public AtsProgramArtifactToken ( Long id , String name , ArtifactTypeToken artifactType ) { super ( id , name , CoreBranches . COMMON , artifactType ) ; }
response: public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, name, CoreBranches.COMMON, artifactType); <END> }

sample: 1094
buggy_code: public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> }
code_review: I think the deprecate is sufficient. Why also log a warning?
target code: public void setUseBulkWriteOperations ( final boolean useBulkWriteOperations ) { }
response: public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> }

sample: 1095
buggy_code: public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); }
code_review: When will this be false?
target code: public void setActionConfirmationMessage ( String message ) { boolean isNonEmptyMessage = message != null ; if ( isNonEmptyMessage ) { actionConfirmationMessage . setText ( message ) ; } }
response: public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); }

sample: 1096
buggy_code: public void close() throws InterruptedException { <START> close(false, false); <END> }
code_review: the second parameter can be removed
target code: public void close ( ) throws InterruptedException { close ( false ) ; }
response: public void close() throws InterruptedException { <START> close(false); <END> }

sample: 1097
buggy_code: protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb); } <START> } <END>
code_review: This class has a member variable called `indent` which will incur a data race in `recursivelyPrint`. This is easily fixable though by just making `indent` a parameter to `recursivelyPrint`. I realize it's debug-only code.
target code: protected void recursivelyPrint ( AbstractPlanNode node , StringBuilder sb ) { recursivelyPrint ( node , sb , 0 ) ; }
response: protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb, int indent) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb, indent); } <START> } <END>

sample: 1098
buggy_code: public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> if (logger.isDebugEnabled()) { <END> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); } }
code_review: if condition not needed.
target code: public void update ( int inputIndex ) { status . setTargetOutputRowCount ( super . update ( inputIndex , status . getOutPosition ( ) ) ) ; logger . debug ( "BATCH_STATS , incoming { } : { } " , inputIndex == 0 ? "left" : "right" , getRecordBatchSizer ( inputIndex ) ) ; }
response: public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); <END> }

sample: 1099
buggy_code: private int getNextPosition() throws CoreException { <START> if (nextMemberPosition == -1) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; }
code_review: Better: nextMemberPosition < 0
target code: private int getNextPosition ( ) throws CoreException { if ( nextMemberPosition < 0 ) { nextMemberPosition = 0 ; while ( nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord ( nextMemberPosition ) != 0 ) { nextMemberPosition ++ ; } } return nextMemberPosition ; }
response: private int getNextPosition() throws CoreException { <START> if (nextMemberPosition < 0) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; }

sample: 1100
buggy_code: public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", jobId, bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; }
code_review: nit: make `bulkRequest.numberOfActions()` a Supplier so it is only called if trace logging is enabled. ```suggestion logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); ```
target code: public BulkResponse executeRequest ( ) { if ( bulkRequest . numberOfActions ( ) == 0 ) { return null ; } logger . trace ( " [ { } ] ES API CALL : bulk request with { } actions" , ( ) - > jobId , ( ) - > bulkRequest . numberOfActions ( ) ) ; BulkResponse bulkResponse = resultsPersisterService . bulkIndexWithRetry ( bulkRequest , jobId , shouldRetry , msg - > auditor . warning ( jobId , "Bulk indexing of annotations failed " + msg ) ) ; bulkRequest = new BulkRequest ( AnnotationIndex . WRITE_ALIAS_NAME ) ; return bulkResponse ; }
response: public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; }

sample: 1101
buggy_code: public int size() { int size = 0; // We have to loop through to make sure to remove expired entries for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; }
code_review: isn't the iterator() excluding the expired and Tombstones?
target code: public int size ( ) { int size = 0 ; // We have to loop through to make sure to remove expired entries for ( Iterator < InternalCacheEntry < K , V > > iter = iterator ( ) ; iter . hasNext ( ) ; ) { iter . next ( ) ; if ( ++ size == Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return size ; }
response: public int size() { int size = 0; // We have to loop through to make sure to remove expired entries for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; }

sample: 1102
buggy_code: public static File getDiskCacheDir(Context context, String uniqueName) { // Check if media is mounted or storage is built-in, if so, try and use external cache dir // otherwise use internal cache dir. final String cachePath; <START> if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) <END> && context.getExternalCacheDir() != null) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); }
code_review: I'd prefer the old order so when Environment.getExternalStorageState() return null we don't get an NPE.
target code: public static File getDiskCacheDir ( Context context , String uniqueName ) { // Check if media is mounted or storage is built - in , if so , try and use external cache dir // otherwise use internal cache dir . final String cachePath ; if ( Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) && context . getExternalCacheDir ( ) != null ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return new File ( cachePath + File . separator + uniqueName ) ; }
response: public static File getDiskCacheDir(Context context, String uniqueName) { // Check if media is mounted or storage is built-in, if so, try and use external cache dir // otherwise use internal cache dir. final String cachePath; <START> if (context.getExternalCacheDir() != null && Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); }

sample: 1103
buggy_code: <START> String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); }
code_review: mark this method private as this is only used in this class.
target code: public static String getBucketName ( URI uri ) { if ( uri . getHost ( ) != null ) { return uri . getHost ( ) ; } if ( uri . getUserInfo ( ) == null ) { return uri . getAuthority ( ) ; } throw new IllegalArgumentException ( "Unable to determine S3 bucket from URI . " ) ; }
response: <START> private String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); }

sample: 1104
buggy_code: private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot)) <END> : new DefaultMustacheFactory(new PerClassMustacheResolver(key)); }
code_review: I think we could make this initialization more terse if we initialize `MustacheResolver` with the ternary operator and pass it to `DefaultMustacheFactory`. ```java new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)) ```
target code: private MustacheFactory createNewMustacheFactory ( Class < ? extends View > key ) { return new DefaultMustacheFactory ( fileRoot . isPresent ( ) ? new FileSystemResolver ( fileRoot . get ( ) ) : new PerClassMustacheResolver ( key ) ) ; }
response: private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)); <END> }

sample: 1105
buggy_code: public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && <START> !SystemElementsUtils.isSystemProtocol((Collaboration) eObject) && <END> !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; }
code_review: If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition.
target code: public boolean isValidValue ( final Object element ) { boolean result = super . isValidValue ( element ) ; if ( result ) { EObject eObject = EMFHelper . getEObject ( element ) ; result = ( ProtocolUtils . isProtocol ( eObject ) && ! SystemElementsUtils . isBaseProtocol ( ( Collaboration ) eObject ) ) ; } return result ; }
response: public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; }

sample: 1106
buggy_code: public void testLogin() throws Throwable { <START> InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); }
code_review: Very minor: consider another helper method for runOnMainSync() so we can focus on the interesting bit (loginTestTask.execute()). As a side note, executing from the main thread doesn't seem to be a requirement of "SaneAsyncTask" for whatever reason. However, it seems more proper to call execute on the main thread[0] since we think of it as a normal AsyncTask so I think we should keep it. [0] http://developer.android.com/reference/android/os/AsyncTask.html#execute(Params...)
target code: public void testLogin ( ) throws Throwable { runOnMainSync ( new Runnable ( ) { @Override public void run ( ) { loginTestTask . execute ( ) ; } } ) ; completionLatch . await ( ) ; }
response: public void testLogin() throws Throwable { <START> runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); }

sample: 1107
buggy_code: public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(), <END> ClientDnsLookup.USE_ALL_DNS_IPS); }
code_review: We don't need to call `toString()`
target code: public static void warnIfDeprecatedDnsLookupValue ( AbstractConfig config ) { String clientDnsLookupValue = config . getString ( CLIENT_DNS_LOOKUP_CONFIG ) ; if ( clientDnsLookupValue . equals ( ClientDnsLookup . DEFAULT . toString ( ) ) ) log . warn ( "Configuration ' { } ' with value ' { } ' is deprecated and will be removed in " + "future version . Please use ' { } ' or another non - deprecated value . " , CLIENT_DNS_LOOKUP_CONFIG , ClientDnsLookup . DEFAULT , ClientDnsLookup . USE_ALL_DNS_IPS ) ; }
response: public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT, <END> ClientDnsLookup.USE_ALL_DNS_IPS); }

sample: 1108
buggy_code: public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.getStats(); <END> }
code_review: I would like to remove the method getStats and would like to make the aggStats static.
target code: public HdfsCopyStats ( String source , File destination , boolean enableStatsFile , int maxVersionsStatsFile , boolean isFileCopy , HdfsPathInfo pathInfo ) { this . sourceFile = source ; this . totalBytesTransferred = 0L ; this . bytesTransferredSinceLastReport = 0L ; this . pathInfo = pathInfo ; this . lastReportNs = System . nanoTime ( ) ; this . startTimeMS = System . currentTimeMillis ( ) ; initializeStatsFile ( destination , enableStatsFile , maxVersionsStatsFile , isFileCopy ) ; }
response: public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.aggStats; <END> }

sample: 1109
buggy_code: private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId().toString())); <END> writer.writeEndElement(); }
code_review: toString() is not needed here, AFAIK.
target code: private void writeAlias ( VmDevice device ) { writer . writeStartElement ( "alias" ) ; writer . writeAttributeString ( "name" , String . format ( "ua - % s" , device . getId ( ) . getDeviceId ( ) ) ) ; writer . writeEndElement ( ) ; }
response: private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId())); <END> writer.writeEndElement(); }

sample: 1110
buggy_code: public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = checkNotNull(ImmutableList.copyOf(series)); <END> }
code_review: You shouldn't need the checkNotNull
target code: public ChartData ( IDataChartProvider < ? > provider , List < ChartSeries > series ) { fProvider = provider ; fSeries = ImmutableList . copyOf ( series ) ; }
response: public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = ImmutableList.copyOf(series); <END> }

sample: 1111
buggy_code: protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); <END> }
code_review: can this case be given? I mean having an entry for the given `uuid` but with no registrations?
target code: protected boolean isRegistered ( final String uuid ) { return handlers . containsKey ( uuid ) ; }
response: protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid); <END> }

sample: 1112
buggy_code: <START> public synchronized Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); }
code_review: @manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed.
target code: public Class < ? > defineClass ( String name , byte [ ] bytecode ) { return defineClass ( name , convertClassToResourcePath ( name ) , bytecode ) ; }
response: <START> public Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); }

sample: 1113
buggy_code: public boolean onOptionsItemSelected(MenuItem item) { // home references the app icon if (item.getItemId() == android.R.id.home) { toggle(); // toggles the state of the sliding menu <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; }
code_review: Could we get brackets around this if {}
target code: public boolean onOptionsItemSelected ( MenuItem item ) { // home references the app icon if ( item . getItemId ( ) == android . R . id . home ) { toggle ( ) ; // toggles the state of the sliding menu if ( getSlidingMenu ( ) . isMenuShowing ( ) && menu . isAdded ( ) ) { setTitle ( ( ( ITitleable ) menu ) . getTitle ( ) ) ; } return true ; } return false ; }
response: public boolean onOptionsItemSelected(MenuItem item) { // home references the app icon if (item.getItemId() == android.R.id.home) { toggle(); // toggles the state of the sliding menu <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) { <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; }

sample: 1114
buggy_code: public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> ex) { <END> throw new UncheckedIOException(ex); } }
code_review: super nit (okay to ignore): Here and below: For consistency, consider "e" rather than "ex". Typically we only use "ex" for nested catch blocks where the name "e" is already being used by the enclosing block.
target code: public static ParcelFileDescriptor fromSocket ( Socket socket ) { FileDescriptor fd = socket . getFileDescriptor$ ( ) ; try { return fd != null ? ParcelFileDescriptor . dup ( fd ) : null ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
response: public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> e) { <END> throw new UncheckedIOException(e); } }

sample: 1115
buggy_code: private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); //$NON-NLS-1$ if (prefix.length() == 0) { return null; } <START> return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path; <END> }
code_review: Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?
target code: private String getThemePrefixedPath ( String path ) { String prefix = themeProperties != null ? themeProperties . get ( IntroTheme . ATT_ID ) : null ; prefix = prefix == null ? "" : prefix . trim ( ) ; // $NON - NLS - 1$ if ( prefix . length ( ) == 0 ) { return null ; } return prefix + Path . SEPARATOR + path ; }
response: private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); //$NON-NLS-1$ if (prefix.length() == 0) { return null; } <START> return prefix + Path.SEPARATOR + path; <END> }

sample: 1116
buggy_code: protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> m_os.write(bytes); <END> }
code_review: what about the null case?
target code: protected void writeString ( int majorType , byte [ ] bytes ) throws IOException { int len = ( bytes == null ) ? 0 : bytes . length ; writeType ( majorType , len ) ; if ( len > 0 ) { m_os . write ( bytes ) ; } }
response: protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> if (bytes != null) { m_os.write(bytes); } <END> }

sample: 1117
buggy_code: private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } else if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END>
code_review: extra `else` statement, please remove
target code: private void checkLogData ( long address , ILogData logData ) { if ( logData == null || logData . getType ( ) == DataType . EMPTY ) { throw new RuntimeException ( "Unexpected return of empty data at address " + address + " on read" ) ; } if ( logData . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } }
response: private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END>

sample: 1118
buggy_code: private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), <END> sourceSelfTime); // merge the children callees. mergeChildren(destination, source); }
code_review: - space after comma - you need to pass the source duration as well
target code: private static void merge ( AggregatedCalledFunction destination , AggregatedCalledFunction source ) { long sourceDuration = source . getDuration ( ) ; long sourceSelfTime = source . getSelfTime ( ) ; destination . addToDuration ( sourceDuration ) ; destination . addToSelfTime ( sourceSelfTime ) ; destination . fStatistics . update ( source . fStatistics . getMaxSegment ( ) , source . fStatistics . getMinSegment ( ) , sourceDuration , sourceSelfTime ) ; // merge the children callees . mergeChildren ( destination , source ) ; }
response: private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(), source.fStatistics.getMinSegment(), sourceDuration, <END> sourceSelfTime); // merge the children callees. mergeChildren(destination, source); }

sample: 1119
buggy_code: @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); <END> } return null; }); }
code_review: Think this needs to go right below line 91. `parseResponse` can return `null` (line 133), which will cause this future to never complete.
target code: @Override protected void doEnqueue ( Callback < V > callback ) { sendRequest ( ) . handle ( ( response , t ) - > { if ( t != null ) { callback . onError ( t ) ; } else { try { V value = parseResponse ( response , bodyConverter ) ; callback . onSuccess ( value ) ; } catch ( Throwable t1 ) { propagateIfFatal ( t1 ) ; callback . onError ( t1 ) ; } } return null ; } ) ; }
response: @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); else callback.onError(new IllegalStateException("parseResponse returned null")); <END> } return null; }); }

sample: 1120
buggy_code: public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } return t; }
code_review: if (!isExplicit) { // ... around the try
target code: public SpiTransaction createServerTransaction ( boolean isExplicit , int isolationLevel ) { SpiTransaction t = transactionManager . createTransaction ( isExplicit , isolationLevel ) ; if ( isExplicit ) { try { transactionScopeManager . set ( t ) ; } catch ( PersistenceException existingTransactionError ) { t . end ( ) ; throw existingTransactionError ; } } return t ; }
response: public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); if (!isExplicit) { <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } } return t; }

sample: 1121
buggy_code: C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.put(t, child); <START> return child; <END> } else return children.get(t); }
code_review: What about thread safety here? I might be mistaken, but by just looking at this code snippet it looks like more than one thread could check the condition, receive `false` from the `contains()` method and execute the above code block. That might be the reason the blocking `putIfAbsent` method is used here?
target code: C baseApply ( ) { final TreeMap < String , String > t = new TreeMap < String , String > ( validate ( ) ) ; C child = children . get ( t ) ; if ( child == null ) { child = newChild ( ) ; children . put ( t , child ) ; } return child ; }
response: C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.putIfAbsent(t, child); <START> return child; <END> } else return children.get(t); }

sample: 1122
buggy_code: public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.startListeningForDirection(); <END> }
code_review: i'd maybe just "forward" the `onConnect` to the presenter instead
target code: public void onConnect ( String message ) { debugView . showPermanently ( getString ( R . string . connected ) ) ; switchableView . setDisplayedChild ( 1 ) ; }
response: public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.onConnect(message); <END> }

sample: 1123
buggy_code: public ByteBuffer[] nioBuffers(int index, int length) { if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) { return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() }; } <START> return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); <END> }
code_review: yup, this is incorrect, seems I failed somewhere, this logic has to be in `public ByteBuffer[] nioBuffers()`, gonna change it
target code: public ByteBuffer [ ] nioBuffers ( int index , int length ) { return new ByteBuffer [ ] { nioBuffer ( index , length ) } ; }
response: public ByteBuffer[] nioBuffers(int index, int length) { if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) { return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() }; } return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); }

sample: 1124
buggy_code: <START> public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { <END> this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors); }
code_review: why the instance-level lock suggestion, vs. what's been implemented here. seems like overkill
target code: public void setDisabledAdministrativeMonitors ( Set < String > disabledAdministrativeMonitors ) { synchronized ( this . disabledAdministrativeMonitors ) { this . disabledAdministrativeMonitors . clear ( ) ; this . disabledAdministrativeMonitors . addAll ( disabledAdministrativeMonitors ) ; } }
response: <START> public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { <END> this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors); }

sample: 1125
buggy_code: <START> public boolean waitUntilReadyToProcess(Properties jobProps) { <END> return true; }
code_review: Is this method going to be overridden in a subclass to provide a different behavior? This method can be protected if is not supposed to be overridden outside the package.
target code: protected boolean waitUntilReadyToProcess ( Properties jobProps ) { return true ; }
response: <START> protected boolean waitUntilReadyToProcess(Properties jobProps) { <END> return true; }

sample: 1126
buggy_code: private ArrayList<Comment> fetchAllComments(ArticleTable article) { <START> return (ArrayList<Comment>) hibernateTemplate.find("FROM Comment WHERE articleId = ?", article.getArticleId()); <END> }
code_review: Casting to `ArrayList` is brittle. Could we return `List<>` from here instead?
target code: private List < Comment > fetchAllComments ( ArticleTable article ) { return ( ArrayList < Comment > ) hibernateTemplate . find ( "FROM Comment WHERE articleId = ? " , article . getArticleId ( ) ) ; }
response: private List<Comment> fetchAllComments(ArticleTable article) { <START> return (ArrayList<Comment>) hibernateTemplate.find("FROM Comment WHERE articleId = ?", article.getArticleId()); <END> }

sample: 1127
buggy_code: <START> public String getPreview() { <END> StringBuilder bld= new StringBuilder(); bld.append("\n"); if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) { bld.append("long number1 = 10L;\n"); bld.append("float number2 = 10F;\n"); bld.append("double number3 = 10D;\n"); } else { bld.append("long number1 = 10l;\n"); bld.append("float number2 = 10f;\n"); bld.append("double number3 = 10d;\n"); } return bld.toString(); }
code_review: Missed this one in the previous review, needs updating as well!
target code: public String getPreview ( ) { StringBuilder bld = new StringBuilder ( ) ; bld . append ( "\n" ) ; if ( isEnabled ( CleanUpConstants . NUMBER_SUFFIX ) ) { bld . append ( "long number1 = 10L ; \n" ) ; } else { bld . append ( "long number1 = 10l ; \n" ) ; } return bld . toString ( ) ; }
response: <START> public String getPreview() { <END> StringBuilder bld= new StringBuilder(); bld.append("\n"); if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) { bld.append("long number1 = 10L;\n"); bld.append("float number2 = 10F;\n"); bld.append("double number3 = 10D;\n"); } else { bld.append("long number1 = 10l;\n"); bld.append("float number2 = 10f;\n"); bld.append("double number3 = 10d;\n"); } return bld.toString(); }

sample: 1128
buggy_code: private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) { int size = msg.getSerializedSize(); ByteBuf buf = allocator.heapBuffer(size, size); try { <START> msg.writeTo(new ByteBufOutputStream(buf)); <END> } catch (IOException e) { // This is in-memory serialization, should not fail throw new RuntimeException(e); } // Advance writer idx buf.writerIndex(buf.capacity()); return buf; }
code_review: Is this a race or corruption happens all the time? Change looks fine, but I did not understand the actual issue with the current code on why corruption happening.
target code: private static ByteBuf serializeProtobuf ( MessageLite msg , ByteBufAllocator allocator ) { int size = msg . getSerializedSize ( ) ; ByteBuf buf = allocator . heapBuffer ( size , size ) ; try { msg . writeTo ( new ByteBufOutputStream ( buf ) ) ; } catch ( IOException e ) { // This is in - memory serialization , should not fail throw new RuntimeException ( e ) ; } return buf ; }
response: private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) { int size = msg.getSerializedSize(); ByteBuf buf = allocator.heapBuffer(size, size); try { <START> msg.writeTo(new ByteBufOutputStream(buf)); <END> } catch (IOException e) { // This is in-memory serialization, should not fail throw new RuntimeException(e); } return buf; }

sample: 1129
buggy_code: public void testEncodeOutputControl() { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder(); Command command = new Command(); command.setDeviceId(1); command.setType(Command.TYPE_OUTPUT_CONTROL); command.set(Command.KEY_INDEX, 0); <START> command.set(Command.KEY_DATA, "1"); <END> assertEquals("(123456789012345AV001)", encoder.encodeCommand(command)); }
code_review: Is this the value we use for all other protocols?
target code: public void testEncodeOutputControl ( ) { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder ( ) ; Command command = new Command ( ) ; command . setDeviceId ( 1 ) ; command . setType ( Command . TYPE_OUTPUT_CONTROL ) ; command . set ( Command . KEY_DATA , "1" ) ; assertEquals ( " ( 123456789012345AV001 ) " , encoder . encodeCommand ( command ) ) ; }
response: public void testEncodeOutputControl() { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder(); Command command = new Command(); command.setDeviceId(1); command.setType(Command.TYPE_OUTPUT_CONTROL); command.set(Command.KEY_INDEX, 0); <START> command.set(Command.KEY_DATA, "1"); <END> assertEquals("(123456789012345AV001)", encoder.encodeCommand(command)); }

sample: 1130
buggy_code: void cancel() { super.cancel(); <START> if (callback != null) { <END> callback = null; } }
code_review: No `if` check needed, just always set the reference to `null`.
target code: @Override void cancel ( ) { super . cancel ( ) ; callback = null ; }
response: void cancel() { super.cancel(); <START> callback = null; <END> }

sample: 1131
buggy_code: public void cancel() { try { Field field = FileWatchdog.class.getDeclaredField("interrupted"); field.setAccessible(true); field.set(this, true); } catch (ReflectiveOperationException cause) { <START> throw new Error("Cannot cancel log4j watchdog", cause); <END> } }
code_review: `new Error` -> `new RuntimeException`
target code: public void cancel ( ) { try { Field field = FileWatchdog . class . getDeclaredField ( "interrupted" ) ; field . setAccessible ( true ) ; field . set ( this , true ) ; } catch ( ReflectiveOperationException cause ) { throw new RuntimeException ( "Cannot cancel log4j watchdog" , cause ) ; } }
response: public void cancel() { try { Field field = FileWatchdog.class.getDeclaredField("interrupted"); field.setAccessible(true); field.set(this, true); } catch (ReflectiveOperationException cause) { <START> throw new RuntimeException("Cannot cancel log4j watchdog", cause); <END> } }

sample: 1132
buggy_code: public static boolean isEditAllowed(@NonNull PageTitle title) { return <START> Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); <END> }
code_review: Very minor: it's probably cleaner just to initialized ENABLED_LANGUAGES using Arrays.asList
target code: public static boolean isEditAllowed ( @NonNull PageTitle title ) { return ENABLED_LANGUAGES . contains ( title . getWikiSite ( ) . languageCode ( ) ) ; }
response: public static boolean isEditAllowed(@NonNull PageTitle title) { return <START> Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); <END> }

sample: 1133
buggy_code: private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException { byte[] bytes = baos.toByteArray(); baos.reset(); <START> int testMessageNo = 1; <END> PacketFormat format = new PacketFormat(testMessageNo, bytes); format.serialize(baos); return new ByteArrayInputStream(baos.toByteArray()); }
code_review: Why is this hardcoded? and why is it 1 not 0?
target code: private InputStream simulateSendAndReceive ( ByteArrayOutputStream baos ) throws IOException { return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; }
response: private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException { byte[] bytes = baos.toByteArray(); baos.reset(); <START> int testMessageNo = 0; <END> PacketFormat format = new PacketFormat(testMessageNo, bytes); format.serialize(baos); return new ByteArrayInputStream(baos.toByteArray()); }

sample: 1134
buggy_code: public ShovingMatch(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, "{2}{U}"); // Until end of turn, all creatures gain "{tap}: Tap target creature." <START> Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost()); <END> ability.addTarget(new TargetCreaturePermanent()); this.getSpellAbility().addEffect( new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent()) .setText("Until end of turn, all creatures gain \"{T}: Tap target creature.\"") ); }
code_review: This wasn't necessary, I was using the constructor I added that defaults to battlefield because most activated abilities are on the battlefield anyway. It doesn't really matter, I just figured I'd mention it.
target code: public ShovingMatch ( UUID ownerId , CardSetInfo setInfo ) { super ( ownerId , setInfo , new CardType [ ] { CardType . INSTANT } , " { 2 } { U } " ) ; // Until end of turn , all creatures gain " { tap } : Tap target creature . " Ability ability = new SimpleActivatedAbility ( new TapTargetEffect ( ) , new TapSourceCost ( ) ) ; ability . addTarget ( new TargetCreaturePermanent ( ) ) ; this . getSpellAbility ( ) . addEffect ( new GainAbilityAllEffect ( ability , Duration . EndOfTurn , new FilterCreaturePermanent ( ) ) . setText ( "Until end of turn , all creatures gain \" { T } : Tap target creature . \"" ) ) ; }
response: public ShovingMatch(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, "{2}{U}"); // Until end of turn, all creatures gain "{tap}: Tap target creature." <START> Ability ability = new SimpleActivatedAbility(new TapTargetEffect(), new TapSourceCost()); <END> ability.addTarget(new TargetCreaturePermanent()); this.getSpellAbility().addEffect( new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent()) .setText("Until end of turn, all creatures gain \"{T}: Tap target creature.\"") ); }

sample: 1135
buggy_code: public void testCompareRanges() { <START> assertTrue(compareRanges("abcdefghij".getBytes(), 0, 10, "abcdefghij".getBytes(), 0, 10) == 0); <END> assertTrue(compareRanges("123abcdefghij".getBytes(), 3, 10, "abcdefghij".getBytes(), 0, 10) == 0); }
code_review: Use `assertEquals`
target code: public void testCompareRanges ( ) { assertEquals ( compareRanges ( "abcdefghij" . getBytes ( ) , 0 , 10 , "abcdefghij" . getBytes ( ) , 0 , 10 ) , 0 ) ; assertEquals ( compareRanges ( "123abcdefghij" . getBytes ( ) , 3 , 10 , "abcdefghij" . getBytes ( ) , 0 , 10 ) , 0 ) ; }
response: public void testCompareRanges() { <START> assertEquals(compareRanges("abcdefghij".getBytes(), 0, 10, "abcdefghij".getBytes(), 0, 10), 0); <END> assertTrue(compareRanges("123abcdefghij".getBytes(), 3, 10, "abcdefghij".getBytes(), 0, 10) == 0); }

sample: 1136
buggy_code: public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){ this.paymentDate = paymentDate; this.timeframe = timeframe; this.requestedAmount = requestedAmount; //??? if(build){ this.build = build; }else{ <START> this.building = build; <END> } }
code_review: Verificar necessidade desse else
target code: public void setRequiredParametersForCreation ( DateTime paymentDate , Timeframe timeframe , Integer requestedAmount , Boolean build ) { this . paymentDate = paymentDate ; this . timeframe = timeframe ; this . requestedAmount = requestedAmount ; if ( build ) { this . build = build ; } }
response: public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){ this.paymentDate = paymentDate; this.timeframe = timeframe; this.requestedAmount = requestedAmount; //??? if(build){ this.build = build; }else{ <START> this.building = build; <END> } } <START> <END>

sample: 1137
buggy_code: public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) <START> throws Exception <END> { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }
code_review: unnecessary `throws` (same for the constructor above).
target code: public TestElasticsearchIntegrationSmokeTest ( EmbeddedElasticsearchNode embeddedElasticsearchNode ) { super ( ( ) - > createElasticsearchQueryRunner ( embeddedElasticsearchNode , TpchTable . getTables ( ) ) ) ; this . embeddedElasticsearchNode = embeddedElasticsearchNode ; }
response: public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }

sample: 1138
buggy_code: public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> if (help) { <END> commandInvocation.println(commandInvocation.getHelpInfo()); } return CommandResult.SUCCESS; }
code_review: print help all the time? the command `> server` alone isn't valid.
target code: public CommandResult exec ( ContextAwareCommandInvocation commandInvocation ) { commandInvocation . println ( commandInvocation . getHelpInfo ( ) ) ; return CommandResult . SUCCESS ; }
response: public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> commandInvocation.println(commandInvocation.getHelpInfo()); <END> return CommandResult.SUCCESS; }

sample: 1139
buggy_code: for (OsType type : OsType.values()) { <START> osTypeValues.add(type.value().toLowerCase()); <END> }
code_review: .value() returns .name().toLowerCase()
target code: for ( OsType type : OsType . values ( ) ) { osTypeValues . add ( type . value ( ) ) ; }
response: for (OsType type : OsType.values()) { <START> osTypeValues.add(type.value()); <END> }

sample: 1140
buggy_code: private Menu fillMenu(Menu m) { for (IAction action : getActions()) { IContributionItem item; String actionText = action.getText(); if (actionText == null || actionText.isEmpty()) { item = new Separator(); } else { item = new ActionContributionItem(action); <START> } <END> item.fill(m, -1); } return m; }
code_review: Why don't you change getAction() to return a Collection<ContributionItem>?
target code: private Menu fillMenu ( Menu m ) { for ( IContributionItem item : getActions ( ) ) { item . fill ( m , - 1 ) ; } return m ; }
response: private Menu fillMenu(Menu m) { for (IAction action : getActions()) { IContributionItem item; String actionText = action.getText(); if (actionText == null || actionText.isEmpty()) { item = new Separator(); } else { item = new ActionContributionItem(action); <START> } <END> item.fill(m, -1); } return m; }

sample: 1141
buggy_code: public void testThreadNameWithoutNumberNoDemon() { <START> Assert.assertEquals(ThreadUtils.createThreadFactory(THREAD_NAME, false). <END> newThread(EMPTY_RUNNABLE).getName(), THREAD_NAME); }
code_review: In all `assert` method, the first argument is the "expected" value while the second one is the "actual" value. Can you swap them in this file to match that definition?
target code: public void testThreadNameWithoutNumberNoDemon ( ) { assertEquals ( THREAD_NAME , ThreadUtils . createThreadFactory ( THREAD_NAME , false ) . newThread ( EMPTY_RUNNABLE ) . getName ( ) ) ; }
response: public void testThreadNameWithoutNumberNoDemon() { <START> Assert.assertEquals(THREAD_NAME, ThreadUtils.createThreadFactory(THREAD_NAME, false). <END> newThread(EMPTY_RUNNABLE).getName()); }

sample: 1142
buggy_code: public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) { //noinspection unchecked <START> return (ModelAdaptor<T>) adaptors.get(attributeType); <END> }
code_review: ```suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType); ```
target code: public < T > ModelAdaptor < ? super T > getModelAdaptor ( Class < T > attributeType ) { // noinspection unchecked return ( ModelAdaptor < ? super T > ) adaptors . get ( attributeType ) ; }
response: public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) { //noinspection unchecked <START> return (ModelAdaptor<? super T>) adaptors.get(attributeType); <END> }

sample: 1143
buggy_code: public com.google.gwtorm.client.Key<?>[] members() { <START> return new com.google.gwtorm.client.Key<?>[] {accountId, patchKey}; <END> }
code_review: If you override accountId then the parentKey is automatically a member, and this needs to only include the patchKey.
target code: public com . google . gwtorm . client . Key < ? > [ ] members ( ) { return new com . google . gwtorm . client . Key < ? > [ ] { patchKey } ; }
response: public com.google.gwtorm.client.Key<?>[] members() { <START> return new com.google.gwtorm.client.Key<?>[] {patchKey}; <END> }

sample: 1144
buggy_code: public void init(final RuleModellerPage page) { this.page = page; if (page.plugin() instanceof BRLActionColumnPlugin) { <START> <END> } }
code_review: If it is then do what exactly? If we don't want to do anything do we need this ```if(..)``` block at all?
target code: public void init ( final RuleModellerPage page ) { this . page = page ; }
response: public void init(final RuleModellerPage page) { this.page = page; if (page.plugin() instanceof BRLActionColumnPlugin) { <START>this.brlActionColumnPlugin = (BRLActionColumnPlugin) page.plugin();<END> } }

sample: 1145
buggy_code: <START> @Override public TaskResult syncShards() { <END> return periodicShardSyncManager.start(); }
code_review: nit: Could you have `Override` in its own line.
target code: public TaskResult syncShards ( ) { return periodicShardSyncManager . start ( ) ; }
response: <START> @Override public TaskResult syncShards() { <END> return periodicShardSyncManager.start(); }

sample: 1146
buggy_code: static <T> List<T> without(List<T> list, Collection<Integer> indexes) { Set<Integer> indexesSet = ImmutableSet.copyOf(indexes); return IntStream.range(0, list.size()) .filter(index -> !indexesSet.contains(index)) <START> .mapToObj(ImmutableList.copyOf(list)::get) <END> .collect(toImmutableList()); }
code_review: Drop this `ImmutableList.copyOf` wrapper. It reduces clarity and we do expect random-access lists here anyway.
target code: static < T > List < T > without ( List < T > list , Collection < Integer > indexes ) { Set < Integer > indexesSet = ImmutableSet . copyOf ( indexes ) ; return IntStream . range ( 0 , list . size ( ) ) . filter ( index - > ! indexesSet . contains ( index ) ) . mapToObj ( list : : get ) . collect ( toImmutableList ( ) ) ; }
response: static <T> List<T> without(List<T> list, Collection<Integer> indexes) { Set<Integer> indexesSet = ImmutableSet.copyOf(indexes); return IntStream.range(0, list.size()) .filter(index -> !indexesSet.contains(index)) <START> .mapToObj(list::get) <END> .collect(toImmutableList()); }

sample: 1147
buggy_code: private Throwable getRealException(Throwable re) { if (re.getCause() == null) return re; Throwable cause = re.getCause(); <START> if (cause instanceof CacheException || cause instanceof RuntimeException || cause instanceof Error) <END> return getRealException(cause); else return re; }
code_review: CacheException instanceOf RuntimeException, I guess you can simplify here.
target code: private Throwable getRealException ( Throwable re ) { if ( re . getCause ( ) == null ) return re ; Throwable cause = re . getCause ( ) ; if ( cause instanceof RuntimeException || cause instanceof Error ) return getRealException ( cause ) ; else return re ; }
response: private Throwable getRealException(Throwable re) { if (re.getCause() == null) return re; Throwable cause = re.getCause(); <START> if (cause instanceof CacheException || cause instanceof Error) <END> return getRealException(cause); else return re; }

sample: 1148
buggy_code: public void layoutIfNecessary() { if (dirtySize != null && control != null && control instanceof Composite) { if (control.getSize().equals(dirtySize)) { <START> ((Composite) control).layout(); <END> flushChildren = false; } } dirtySize = null; }
code_review: What does this change do?
target code: public void layoutIfNecessary ( ) { if ( dirtySize != null && control != null && control instanceof Composite ) { if ( control . getSize ( ) . equals ( dirtySize ) ) { ( ( Composite ) control ) . layout ( flushChildren ) ; flushChildren = false ; } } dirtySize = null ; }
response: public void layoutIfNecessary() { if (dirtySize != null && control != null && control instanceof Composite) { if (control.getSize().equals(dirtySize)) { <START> ((Composite) control).layout(); <END> flushChildren = false; } } dirtySize = null; }

sample: 1149
buggy_code: public Attribute setLabelAttribute(Boolean isLabelAttr) { set(IS_LABEL_ATTRIBUTE, isLabelAttr); <START> if (isLabelAttr != null && isLabelAttr) <END> { setNillable(false); } return this; }
code_review: We ususally don't put the logic in the entity class. Will be confusing that this setter has side effects: `addAttribute("blah").setNillable(true).setLabelAttribute(true)`
target code: public Attribute setLabelAttribute ( Boolean isLabelAttr ) { set ( IS_LABEL_ATTRIBUTE , isLabelAttr ) ; return this ; }
response: public Attribute setLabelAttribute(Boolean isLabelAttr) { set(IS_LABEL_ATTRIBUTE, isLabelAttr); <START> if (isLabelAttr != null && isLabelAttr) <END> { setNillable(false); } return this; }

sample: 1150
buggy_code: public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof IntegrationEvaluationContextAware) { StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); if (bean instanceof IntegrationObjectSupport) { ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService(); <START> if (conversionService != null) { <END> evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService)); } } ((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext); } return bean; }
code_review: So, maybe just remove this code for now? And keep in mind it. However I remember this one: https://github.com/SpringSource/spring-integration/pull/827#issuecomment-20274110 I mean to rely just only on 'system-wide conversion service', not from endpoint.
target code: public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { if ( bean instanceof IntegrationEvaluationContextAware ) { StandardEvaluationContext evaluationContext = IntegrationContextUtils . getEvaluationContext ( this . beanFactory ) ; ( ( IntegrationEvaluationContextAware ) bean ) . setIntegrationEvaluationContext ( evaluationContext ) ; } return bean ; }
response: public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof IntegrationEvaluationContextAware) { StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); if (bean instanceof IntegrationObjectSupport) { ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService(); if (conversionService != null) { evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService)); } } ((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext); } return bean; }

sample: 1151
buggy_code: public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X { Handle h = JdbiUtil.getHandle(jdbi); R result = callback.withHandle(h); // close if not in transaction <START> JdbiUtil.closeIfNeeded(h); <END> return result; }
code_review: I believe we shouldn't close the handle here. It will be closed in the `afterCompletion` method. I think also it will probably be ignored because the handle is still binded to the active transaction.
target code: public < R , X extends Exception > R withHandle ( HandleCallback < R , X > callback ) throws X { Handle h = JdbiUtil . getHandle ( jdbi ) ; try { return callback . withHandle ( h ) ; } finally { JdbiUtil . closeIfNeeded ( h ) ; } }
response: public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X { Handle h = JdbiUtil.getHandle(jdbi); R result = callback.withHandle(h); return result; }

sample: 1152
buggy_code: <START> public LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition, <END> @Nullable IPath initialPath) { this.initialProject = project; this.initialPath = initialPath; this.allWatchedProjects = new HashSet<>(); this.serverDefinition = serverDefinition; this.connectedDocuments = new HashMap<>(); }
code_review: In this case, shouldn't we getrid of the project parameter here (if we know the project, we shouldn't specify an extra initial path, or we should explicitly use the initial path.
target code: private LanguageServerWrapper ( @Nullable IProject project , @NonNull LanguageServerDefinition serverDefinition , @Nullable IPath initialPath ) { this . initialProject = project ; this . initialPath = initialPath ; this . allWatchedProjects = new HashSet < > ( ) ; this . serverDefinition = serverDefinition ; this . connectedDocuments = new HashMap < > ( ) ; }
response: <START> public LanguageServerWrapper(@NonNull LanguageServerDefinition serverDefinition, <END> @Nullable IPath initialPath) { this.initialProject = project; this.initialPath = initialPath; this.allWatchedProjects = new HashSet<>(); this.serverDefinition = serverDefinition; this.connectedDocuments = new HashMap<>(); }

sample: 1153
buggy_code: public String getReplicaPath() { // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers. <START> return getMountPath() + File.separator + GetRequest.Cloud_Replica_Keyword + File.separator <END> + partitionId.toPathString(); }
code_review: minor: would prefer that `Cloud_Replica_Keyword` comes before mount path since that would order the path from least to most granular
target code: public String getReplicaPath ( ) { // GetRequest . Cloud_Replica_Keyword is added to avoid error on its peers . return GetRequest . Cloud_Replica_Keyword + File . separator + getMountPath ( ) + File . separator + partitionId . toPathString ( ) ; }
response: public String getReplicaPath() { // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers. <START> return GetRequest.Cloud_Replica_Keyword + File.separator + getMountPath() + File.separator <END> + partitionId.toPathString(); }

sample: 1154
buggy_code: public void addChildren(AlluxioURI path, Collection<UfsStatus> children) { UfsStatus status = mStatuses.get(path); // If this path doesn't yet exist, we can't keep track of the parent-child relationship // We can still add statuses to the cache regardless <START> if (status != null) { <END> mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children); } children.forEach(child -> { AlluxioURI childPath = path.joinUnsafe(child.getName()); addStatus(childPath, child); }); }
code_review: Why can't we add this parent->children listing cache even if the parent status is not in the other map?
target code: public Collection < UfsStatus > addChildren ( AlluxioURI path , Collection < UfsStatus > children ) { ConcurrentHashSet < UfsStatus > set = new ConcurrentHashSet < > ( ) ; children . forEach ( child - > { AlluxioURI childPath = path . joinUnsafe ( child . getName ( ) ) ; addStatus ( childPath , child ) ; set . add ( child ) ; } ) ; return mChildren . put ( path , set ) ; }
response: public void addChildren(AlluxioURI path, Collection<UfsStatus> children) { UfsStatus status = mStatuses.get(path); // If this path doesn't yet exist, we can't keep track of the parent-child relationship // We can still add statuses to the cache regardless <START> if (status != null) { <END> mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children); } children.forEach(child -> { AlluxioURI childPath = path.joinUnsafe(child.getName()); addStatus(childPath, child); }); }

sample: 1155
buggy_code: private void actionCompleted(SegmentHolder segmentHolder) { switch (segmentHolder.getType()) { case LOAD: segmentsToLoad.remove(segmentHolder.getSegment()); queuedSize.addAndGet(-segmentHolder.getSegmentSize()); break; case DROP: segmentsToDrop.remove(segmentHolder.getSegment()); break; default: throw new UnsupportedOperationException(); } callBackExecutor.execute( <START> () -> executeCallbacks(segmentHolder) <END> ); }
code_review: Pointless two level submission. `executeCallbacks()` submits each callback to itself another one time (this means that it's valuable to annotate each method in this class in which executor it's supposed to be run. Given that there are two different executors, plus "external", client code execution context (which we kind of shouldn't know where runs)
target code: private void actionCompleted ( SegmentHolder segmentHolder ) { switch ( segmentHolder . getType ( ) ) { case LOAD : segmentsToLoad . remove ( segmentHolder . getSegment ( ) ) ; queuedSize . addAndGet ( - segmentHolder . getSegmentSize ( ) ) ; break ; case DROP : segmentsToDrop . remove ( segmentHolder . getSegment ( ) ) ; break ; default : throw new UnsupportedOperationException ( ) ; } executeCallbacks ( segmentHolder ) ; }
response: private void actionCompleted(SegmentHolder segmentHolder) { switch (segmentHolder.getType()) { case LOAD: segmentsToLoad.remove(segmentHolder.getSegment()); queuedSize.addAndGet(-segmentHolder.getSegmentSize()); break; case DROP: segmentsToDrop.remove(segmentHolder.getSegment()); break; default: throw new UnsupportedOperationException(); } executeCallbacks(segmentHolder); }

sample: 1156
buggy_code: public ScheduledReporter build(MetricRegistry registry) { GraphiteReporter.Builder builder = builder(registry); <START> if ("udp".equalsIgnoreCase(this.transport)) { <END> return builder.build(new GraphiteUDP(host, port)); } else { return builder.build(new Graphite(host, port)); } }
code_review: Is `this` needed here? If not, consider dropping it.
target code: public ScheduledReporter build ( MetricRegistry registry ) { GraphiteReporter . Builder builder = builder ( registry ) ; if ( "udp" . equalsIgnoreCase ( transport ) ) { return builder . build ( new GraphiteUDP ( host , port ) ) ; } else { return builder . build ( new Graphite ( host , port ) ) ; } }
response: public ScheduledReporter build(MetricRegistry registry) { GraphiteReporter.Builder builder = builder(registry); <START> if ("udp".equalsIgnoreCase(transport)) { <END> return builder.build(new GraphiteUDP(host, port)); } else { return builder.build(new Graphite(host, port)); } }

sample: 1157
buggy_code: public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) { setStatusForOpponent(userId, getString(R.string.text_status_hang_up)); Log.d(TAG, "onReceiveHangUpFromUser userId= " + userId); if (!isPeerToPeerCall) { if (userId == userIDFullScreen) { Log.d(TAG, "setAnotherUserToFullScreen call userId= " + userId); setAnotherUserToFullScreen(); } <START> if (videoTrackMap != null && videoTrackMap.containsKey(userId)) { <END> Log.d(TAG, "onReceiveHangUpFromUser videoTrackMap.remove(userId)= " + userId); videoTrackMap.remove(userId); } } }
code_review:  )      onConnectionClosedForUser   ,       onConnectionClosedForUser ,    ? onConnectionClosedForUser          ,
target code: public void onReceiveHangUpFromUser ( QBRTCSession session , Integer userId ) { setStatusForOpponent ( userId , getString ( R . string . text_status_hang_up ) ) ; Log . d ( TAG , "onReceiveHangUpFromUser userId = " + userId ) ; if ( ! isPeerToPeerCall ) { if ( userId == userIDFullScreen ) { Log . d ( TAG , "setAnotherUserToFullScreen call userId = " + userId ) ; setAnotherUserToFullScreen ( ) ; } } }
response: public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) { setStatusForOpponent(userId, getString(R.string.text_status_hang_up)); Log.d(TAG, "onReceiveHangUpFromUser userId= " + userId); if (!isPeerToPeerCall) { if (userId == userIDFullScreen) { Log.d(TAG, "setAnotherUserToFullScreen call userId= " + userId); setAnotherUserToFullScreen(); } } }

sample: 1158
buggy_code: private boolean isThis(ExpressionTree expression) { <START> ExpressionTree expressionNoParenthesis = (ExpressionUtils.skipParentheses(expression)); <END> if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) { String targetName = ((IdentifierTree) expressionNoParenthesis).name(); return "this".equals(targetName); } return false; }
code_review: useless parentheses
target code: private boolean isThis ( ExpressionTree expression ) { ExpressionTree expressionNoParenthesis = ExpressionUtils . skipParentheses ( expression ) ; if ( expressionNoParenthesis . is ( Tree . Kind . IDENTIFIER ) ) { String targetName = ( ( IdentifierTree ) expressionNoParenthesis ) . name ( ) ; return "this" . equals ( targetName ) ; } return false ; }
response: private boolean isThis(ExpressionTree expression) { <START> ExpressionTree expressionNoParenthesis = ExpressionUtils.skipParentheses(expression); <END> if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) { String targetName = ((IdentifierTree) expressionNoParenthesis).name(); return "this".equals(targetName); } return false; }

sample: 1159
buggy_code: protected Map<String, Queue> getQueueNamesToQueues() { return this.queues.stream() <START> .collect(Collectors.toMap(q -> q.getActualName(), q -> q)); <END> }
code_review: `Queue::getActualName` ?
target code: protected Map < String , Queue > getQueueNamesToQueues ( ) { return this . queues . stream ( ) . collect ( Collectors . toMap ( Queue : : getActualName , q - > q ) ) ; }
response: protected Map<String, Queue> getQueueNamesToQueues() { return this.queues.stream() <START> .collect(Collectors.toMap(Queue::getActualName, q -> q)); <END> }

sample: 1160
buggy_code: public String toString() { Bundle myBundle = getBundle(); if (myBundle == null) return ""; //$NON-NLS-1$ String name = myBundle.getSymbolicName(); <START> return name == null ? Long.valueOf(myBundle.getBundleId()).toString() : name; <END> }
code_review: Using String.valueOf(myBundle.getBundleId()) would make more sense than .valueOf.toString
target code: public String toString ( ) { Bundle myBundle = getBundle ( ) ; if ( myBundle == null ) return "" ; // $NON - NLS - 1$ String name = myBundle . getSymbolicName ( ) ; return name == null ? String . valueOf ( myBundle . getBundleId ( ) ) : name ; }
response: public String toString() { Bundle myBundle = getBundle(); if (myBundle == null) return ""; //$NON-NLS-1$ String name = myBundle.getSymbolicName(); <START> return name == null ? String.valueOf(myBundle.getBundleId()) : name; <END> }

sample: 1161
buggy_code: public void workbenchSelectionChanged(ISelection selection) { Object o = SelectionUtils.getSelectedObject(selection); if (o instanceof TextSelection) { String text = ((TextSelection) o).getText(); m_sourceGraphControl.setSourceText(text); <START> } else if (o == null) { <END> m_sourceGraphControl.setSourceText(""); //$NON-NLS-1$ } }
code_review: The test on the "else" case isn't needed -- if it's anything but a TextSelection the text can be set to the emprty string.
target code: public void workbenchSelectionChanged ( ISelection selection ) { Object o = SelectionUtils . getSelectedObject ( selection ) ; if ( o instanceof TextSelection ) { String text = ( ( TextSelection ) o ) . getText ( ) ; m_sourceGraphControl . setSourceText ( text ) ; } else { m_sourceGraphControl . setSourceText ( "" ) ; // $NON - NLS - 1$ } }
response: public void workbenchSelectionChanged(ISelection selection) { Object o = SelectionUtils.getSelectedObject(selection); if (o instanceof TextSelection) { String text = ((TextSelection) o).getText(); m_sourceGraphControl.setSourceText(text); <START> } else { <END> m_sourceGraphControl.setSourceText(""); //$NON-NLS-1$ } }

sample: 1162
buggy_code: <START> public JBlock getOnDestroyViewAfterSuperBlock() { <END> if (onDestroyViewAfterSuperBlock == null) { setContentViewRelatedMethods(); } return onDestroyViewAfterSuperBlock; }
code_review: This could be private if you move the field creation to the holder as i suggested.
target code: private JBlock getOnDestroyViewAfterSuperBlock ( ) { if ( onDestroyViewAfterSuperBlock == null ) { setContentViewRelatedMethods ( ) ; } return onDestroyViewAfterSuperBlock ; }
response: <START> public JBlock getOnDestroyViewAfterSuperBlock() { <END> if (onDestroyViewAfterSuperBlock == null) { setContentViewRelatedMethods(); } return onDestroyViewAfterSuperBlock; }

sample: 1163
buggy_code: public boolean hasChildren(Object element) { <START> return ((MyModel) element).children.size() > 0; <END> }
code_review: Use isEmpty() to check whether the collection is empty or not.
target code: public boolean hasChildren ( Object element ) { return ! ( ( MyModel ) element ) . children . isEmpty ( ) ; }
response: public boolean hasChildren(Object element) { <START> return !((MyModel) element).children.isEmpty(); <END> }

sample: 1164
buggy_code: public GroupedPropertyList getPropertyList() { if (propertyList == null) { <START> try{ <END> boolean parallel = true; long t1 = System.currentTimeMillis(); propertyList = new GroupedPropertyList(individual, vreq, editing,parallel); log.debug(" getPropertyList parallel: "+parallel+" time :"+(System.currentTimeMillis()-t1)+" ms"); }catch(Exception e) { e.printStackTrace(); } } return propertyList; }
code_review: I believe we can remove the `try`/`catch` wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating?
target code: public GroupedPropertyList getPropertyList ( ) throws Exception { propertyList = new GroupedPropertyList ( individual , vreq , editing ) ; return propertyList ; }
response: public GroupedPropertyList getPropertyList() { if (propertyList == null) { <START> boolean parallel = true; long t1 = System.currentTimeMillis(); propertyList = new GroupedPropertyList(individual, vreq, editing,parallel); log.debug(" getPropertyList parallel: "+parallel+" time :"+(System.currentTimeMillis()-t1)+" ms"); <END> } return propertyList; }

sample: 1165
buggy_code: private void doTheTest(UserGroup g0) { String s = MARSHALER.marshal(g0); UserGroup ug = MARSHALER.unmarshal(s); <START> System.out.println(g0); <END> System.out.println(ug); System.out.println(s); assertTrue(g0.equals(ug)); }
code_review: Remove this ones
target code: private void doTheTest ( UserGroup g0 ) { String s = MARSHALER . marshal ( g0 ) ; UserGroup ug = MARSHALER . unmarshal ( s ) ; assertTrue ( g0 . equals ( ug ) ) ; }
response: private void doTheTest(UserGroup g0) { String s = MARSHALER.marshal(g0); UserGroup ug = MARSHALER.unmarshal(s); <START> System.out.println(g0); <END> System.out.println(ug); System.out.println(s); assertTrue(g0.equals(ug)); }

sample: 1166
buggy_code: String getConstraintType() { final ConstraintType constraintType = presenter.getConstraintType(); <START> if (constraintType == null) { <END> return presenter.inferComponentType(presenter.getConstraintValue()).value(); } else { return constraintType.toString(); } }
code_review: This too would benefit from the (proposed) `ConstraintType.EMPTY` enumeration item.
target code: private String getConstraintType ( ) { if ( presenter . getConstraintType ( ) == null ) { return presenter . inferComponentType ( presenter . getConstraintValue ( ) ) . value ( ) ; } else { return presenter . getConstraintType ( ) . toString ( ) ; } }
response: String getConstraintType() { final ConstraintType constraintType = presenter.getConstraintType(); <START> if (constraintType == ConstraintType.EMPTY) { <END> return presenter.inferComponentType(presenter.getConstraintValue()).value(); } else { return constraintType.toString(); } }

sample: 1167
buggy_code: private WikipediaApp getApplication() { <START> return (WikipediaApp) getPageActivity().getApplication(); <END> }
code_review: How about WikipediaApp.getInstance() instead?
target code: private WikipediaApp getApplication ( ) { return WikipediaApp . getInstance ( ) ; }
response: private WikipediaApp getApplication() { <START> return WikipediaApp.getInstance(); <END> }

sample: 1168
buggy_code: <START> public boolean isHostedEngineDirectLunDisk() { <END> return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias()); }
code_review: Should this be public or private? It is used only in the validator
target code: private boolean isHostedEngineDirectLunDisk ( ) { return disk . getDiskStorageType ( ) == DiskStorageType . LUN && StorageConstants . HOSTED_ENGINE_LUN_DISK_ALIAS . equals ( disk . getDiskAlias ( ) ) ; }
response: <START> private boolean isHostedEngineDirectLunDisk() { <END> return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias()); }

sample: 1169
buggy_code: <START> public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, <END> UUID collectionId, @Nullable Pageable optionalPageable, Projection projection) { try { Context context = obtainContext(); Collection collection = collectionService.find(context, collectionId); Community parentCommunity = (Community) collectionService.getParentObject(context, collection); if (collection == null) { throw new ResourceNotFoundException("No such collection: " + collectionId); } return converter.toRest(parentCommunity, projection); } catch (SQLException e) { throw new RuntimeException(e); } }
code_review: Same here, JavaDocs for this method please
target code: public CommunityRest getParentCommunity ( @Nullable HttpServletRequest httpServletRequest , UUID collectionId , @Nullable Pageable optionalPageable , Projection projection ) { try { Context context = obtainContext ( ) ; Collection collection = collectionService . find ( context , collectionId ) ; if ( collection == null ) { throw new ResourceNotFoundException ( "No such collection : " + collectionId ) ; } Community parentCommunity = ( Community ) collectionService . getParentObject ( context , collection ) ; return converter . toRest ( parentCommunity , projection ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } }
response: <START> public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, <END> UUID collectionId, @Nullable Pageable optionalPageable, Projection projection) { try { Context context = obtainContext(); Collection collection = collectionService.find(context, collectionId); Community parentCommunity = (Community) collectionService.getParentObject(context, collection); if (collection == null) { throw new ResourceNotFoundException("No such collection: " + collectionId); } return converter.toRest(parentCommunity, projection); } catch (SQLException e) { throw new RuntimeException(e); } }

sample: 1170
buggy_code: public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException, DotSecurityException { <START> List<WorkflowAction> actions = new ArrayList<>(); <END> for(WorkflowStep step : steps) { actions.addAll(workFlowFactory.findActions(step)); } actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user); return actions; }
code_review: Immutable
target code: public List < WorkflowAction > findActions ( List < WorkflowStep > steps , User user ) throws DotDataException , DotSecurityException { final ImmutableList . Builder < WorkflowAction > actions = new ImmutableList . Builder < > ( ) ; for ( WorkflowStep step : steps ) { actions . addAll ( workFlowFactory . findActions ( step ) ) ; } return APILocator . getPermissionAPI ( ) . filterCollection ( actions . build ( ) , PermissionAPI . PERMISSION_USE , true , user ) ; }
response: public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException, DotSecurityException { <START> List<WorkflowAction> actions = new ArrayList<>(); <END> for(WorkflowStep step : steps) { actions.addAll(workFlowFactory.findActions(step)); } actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user); return Collections.unmodifiableList(actions); }

sample: 1171
buggy_code: private String updateIconUri(MPart part) { MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId()); <START> String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); <END> part.getTransientData().put(ICON_URI_FOR_PART, iconURI); return iconURI; }
code_review: This code raises two more (previously existing) concerns: 1. Which iconURI has higher priority the descriptor or the part? 2. What happens if the iconURI of the descriptor is changed?
target code: private String updateIconUri ( MPart part ) { MPartDescriptor desc = modelService . getPartDescriptor ( part . getElementId ( ) ) ; String iconURI = part . getIconURI ( ) ; if ( iconURI == null && desc != null ) { iconURI = desc . getIconURI ( ) ; } part . getTransientData ( ) . put ( ICON_URI_FOR_PART , iconURI ) ; return iconURI ; }
response: private String updateIconUri(MPart part) { MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId()); <START> String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); part.getTransientData().put(ICON_URI_FOR_PART, iconURI); return iconURI; <END> }

sample: 1172
buggy_code: private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){ //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value Map<String, Pair<Class, Object>> map = new HashMap<>(); <START> return map; <END> }
code_review: This will throw redundancy warnings in IntelliJ
target code: private Map < String , Pair < Class , Object > > getOverriddenReturnTypes ( ) { // Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes // Provide the attribute name as key , and a pair of return type ( Class ) and an Object to be used as test value return new HashMap < > ( ) ; }
response: private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){ //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value Map<String, Pair<Class, Object>> map = new HashMap<>(); <START> return map; <END> }

sample: 1173
buggy_code: <START> public String getParentId(String testId) { <END> return (String) getHibernateTemplate().find("select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?", testId, sessionId).get(0); }
code_review: why is it public?
target code: private String getParentId ( String testId ) { return ( String ) getHibernateTemplate ( ) . find ( "select distinct w . parentId from WorkloadData w where w . taskId = ? and w . sessionId = ? " , testId , sessionId ) . get ( 0 ) ; }
response: <START> String getParentId(String testId) { <END> return (String) getHibernateTemplate().find("select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?", testId, sessionId).get(0); }

sample: 1174
buggy_code: protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { <START> setReturnValue(new ArrayList<>()); <END> return; } setReturnValue(filterDisks(diskList)); }
code_review: Why can't you just return diskList? If I'm not mistaken DbFacade does not return null lists, only empty
target code: protected void executeQueryCommand ( ) { List < Disk > diskList = DbFacade . getInstance ( ) . getDiskDao ( ) . getAllAttachableDisksByPoolId ( getParameters ( ) . getStoragePoolId ( ) , getParameters ( ) . getVmId ( ) , getUserID ( ) , getParameters ( ) . isFiltered ( ) ) ; if ( CollectionUtils . isEmpty ( diskList ) ) { setReturnValue ( diskList ) ; return ; } setReturnValue ( filterDisks ( diskList ) ) ; }
response: protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { <START> return diskList; <END> return; } setReturnValue(filterDisks(diskList)); }

sample: 1175
buggy_code: public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent( Filter filter, List<JoinableClause> clauses, VirtualColumns virtualColumns ) { // Some filters have potentially expensive hash codes that are lazily computed and cached. // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map, // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe. synchronized (analyses) { if (filter != null) { <START> filter.hashCode(); <END> } } JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns); return analyses.computeIfAbsent( key, (groupKey) -> { return JoinFilterAnalyzer.computeJoinFilterPreAnalysis( JoinableClauses.fromList(clauses), virtualColumns, filter, joinFilterRewriteConfig ); } ); }
code_review: Oh, is this why we don't need thread-safety on filter hashcode methods i guess? This seems kind of a funny way to prime them with the cached values, I think maybe the supplier.memoize pattern would be a little cleaner and make this not necessary?
target code: public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent ( Filter filter , List < JoinableClause > clauses , VirtualColumns virtualColumns ) { JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey ( filter , clauses , virtualColumns ) ; return analyses . computeIfAbsent ( key , ( groupKey ) - > { return JoinFilterAnalyzer . computeJoinFilterPreAnalysis ( JoinableClauses . fromList ( clauses ) , virtualColumns , filter , joinFilterRewriteConfig ) ; } ) ; }
response: public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent( Filter filter, List<JoinableClause> clauses, VirtualColumns virtualColumns ) { // Some filters have potentially expensive hash codes that are lazily computed and cached. // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map, // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe. synchronized (analyses) { if (filter != null) { <START> filter.hashCode(); <END> } } JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns); return analyses.computeIfAbsent( key, (groupKey) -> { return JoinFilterAnalyzer.computeJoinFilterPreAnalysis( JoinableClauses.fromList(clauses), virtualColumns, filter, joinFilterRewriteConfig ); } ); }

sample: 1176
buggy_code: protected AbstractFixedIntervalTask( String id, <START> TaskResource taskResource, <END> String dataSource, Interval interval ) { this(id, id, taskResource, dataSource, interval); }
code_review: there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ?
target code: protected AbstractFixedIntervalTask ( String id , TaskResource taskResource , String dataSource , Interval interval ) { this ( id , id , taskResource == null ? new TaskResource ( id , 1 ) : taskResource , dataSource , interval ) ; }
response: protected AbstractFixedIntervalTask( String id, <START> TaskResource taskResource, <END> String dataSource, Interval interval ) { this(id, id, taskResource, dataSource, interval); }

sample: 1177
buggy_code: private Object[][] finderSupportedResourceTypeData() { return new Object[][] <START> { <END> { FinderSupportedAssociationDataResource.class }, { FinderSupportedComplexKeyDataResource.class }, { FinderWithActionResource.class } }; }
code_review: You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
target code: private Object [ ] [ ] finderSupportedResourceTypeData ( ) { return new Object [ ] [ ] { { FinderSupportedAssociationDataResource . class } , { FinderSupportedComplexKeyDataResource . class } } ; }
response: private Object[][] finderSupportedResourceTypeData() { return new Object[][] { { FinderSupportedAssociationDataResource.class }, { FinderSupportedComplexKeyDataResource.class }, { FinderWithActionResource.class } }; }

sample: 1178
buggy_code: public void addNotEmptyIdConnection() { StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30"); newPosixConnection.setId(Guid.newGuid().toString()); parameters.setStorageServerConnection(newPosixConnection); parameters.setVdsId(Guid.Empty); <START> doReturn(newPosixConnection.getId()).when(command).isConnWithSameDetailsExists(newPosixConnection, null); <END> ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY); }
code_review: We actually don't need this line at all. The test check something else
target code: public void addNotEmptyIdConnection ( ) { StorageServerConnections newPosixConnection = createPosixConnection ( "multipass . my . domain . tlv . company . com :/ export / allstorage / data1" , StorageType . POSIXFS , "nfs" , "timeo = 30" ) ; newPosixConnection . setId ( Guid . newGuid ( ) . toString ( ) ) ; parameters . setStorageServerConnection ( newPosixConnection ) ; parameters . setVdsId ( Guid . Empty ) ; ValidateTestUtils . runAndAssertValidateFailure ( command , EngineMessage . ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY ) ; }
response: public void addNotEmptyIdConnection() { StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30"); newPosixConnection.setId(Guid.newGuid().toString()); parameters.setStorageServerConnection(newPosixConnection); parameters.setVdsId(Guid.Empty); <START> <END> ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY); }

sample: 1179
buggy_code: public void mercury_topbar_wikiaLogoRedirectsToFandomPage() { TopBar topBar = new ArticlePage() .open(MercurySubpages.MAIN_PAGE) .getTopBar(); <START> Assertion.assertTrue(topBar.isLogoVisible()); <END> topBar.clickWikiaLogo(); Assertion.assertTrue(topBar.getCurrentUrl().contains("www.wikia.com/fandom")); }
code_review: I think if it's not visible, click should fail, so is the assertion needed?
target code: public void mercury_topbar_wikiaLogoRedirectsToFandomPage ( ) { TopBar topBar = new ArticlePage ( ) . open ( MercurySubpages . MAIN_PAGE ) . getTopBar ( ) ; topBar . clickWikiaLogo ( ) ; Assertion . assertTrue ( topBar . getCurrentUrl ( ) . contains ( "www . wikia . com / fandom" ) ) ; }
response: public void mercury_topbar_wikiaLogoRedirectsToFandomPage() { TopBar topBar = new ArticlePage() .open(MercurySubpages.MAIN_PAGE) .getTopBar(); <START> topBar.clickWikiaLogo(); <END> Assertion.assertTrue(topBar.getCurrentUrl().contains("www.wikia.com/fandom")); }

sample: 1180
buggy_code: private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{ String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME); if(cfService == null) { <START> cfService = new ConfigurationServiceImplService(new URL(url+"?wsdl")); <END> } return cfService; }
code_review: Should this be initialized in a static / thread-safe context?
target code: protected ConfigurationServiceImplService getConfigService ( ) throws ConnectionManagerException , MalformedURLException { return cfService ; }
response: private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{ String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME); if(cfService == null) { <START> cfService = new ConfigurationServiceImplService(new URL(url+"?wsdl")); <END> } return cfService; }

sample: 1181
buggy_code: void testDtoListResponses() { FlowJsonObjectReader reader = new FlowJsonObjectReader(); TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {}; List<SurveyGroupDto> surveyList = null; try { surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference); } catch (IOException e) { // } assertNotEquals(surveyList, null); assertEquals(surveyList.size(), 1); <START> assertEquals(surveyList.get(0).getName(),"1.10.36 all questions"); <END> }
code_review: This is a minor detail but the the assertZZZ methods work like this assertZZZ(expected, actual), this is valid for the whole of your test files. Also please format the file as some "," have no space after them.
target code: void testDtoListResponses ( ) { FlowJsonObjectReader reader = new FlowJsonObjectReader ( ) ; TypeReference < SurveyGroupDto > typeReference = new TypeReference < SurveyGroupDto > ( ) { } ; List < SurveyGroupDto > surveyList = null ; try { surveyList = reader . readDtoListObject ( DTO_LIST_JSON_OBJECT , typeReference ) ; } catch ( IOException e ) { // ignoring exception } assertNotEquals ( null , surveyList ) ; assertEquals ( 1 , surveyList . size ( ) ) ; assertEquals ( "1 . 10 . 36 all questions" , surveyList . get ( 0 ) . getName ( ) ) ; }
response: void testDtoListResponses() { FlowJsonObjectReader reader = new FlowJsonObjectReader(); TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {}; List<SurveyGroupDto> surveyList = null; try { surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference); } catch (IOException e) { // } assertNotEquals(surveyList, null); assertEquals(surveyList.size(), 1); <START> assertEquals("1.10.36 all questions", surveyList.get(0).getName()); <END> }

sample: 1182
buggy_code: public GroupScan clone(List<SchemaPath> columns) { <START> HBaseUtils.verifyColumns(columns, hTableDesc); <END> HBaseGroupScan newScan = new HBaseGroupScan(this); newScan.columns = columns == null ? ALL_COLUMNS : columns; return newScan; }
code_review: We should replace null columns with all_columns before verification or we will get exception. You have changed initial order of statements.
target code: public GroupScan clone ( List < SchemaPath > columns ) { HBaseGroupScan newScan = new HBaseGroupScan ( this ) ; newScan . columns = columns == null ? ALL_COLUMNS : columns ; HBaseUtils . verifyColumns ( columns , hTableDesc ) ; return newScan ; }
response: public GroupScan clone(List<SchemaPath> columns) { <START> HBaseGroupScan newScan = new HBaseGroupScan(this); newScan.columns = columns == null ? ALL_COLUMNS : columns; HBaseUtils.verifyColumns(columns, hTableDesc); <END> return newScan; }

sample: 1183
buggy_code: <START> static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { <END> return t -> Result.failure( "Not yet implemented: " + Optional.ofNullable(t) .map(o -> o.getClass().getCanonicalName()) .orElse("null -- expected " + expectedClass.getCanonicalName())); }
code_review: Can be private method.
target code: private static < T , U > Function < T , Result < U > > reportMissing ( Class < ? > expectedClass ) { return t - > Result . failure ( "Not yet implemented : " + Optional . ofNullable ( t ) . map ( o - > o . getClass ( ) . getCanonicalName ( ) ) . orElse ( "null -- expected " + expectedClass . getCanonicalName ( ) ) ) ; }
response: <START> private static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { <END> return t -> Result.failure( "Not yet implemented: " + Optional.ofNullable(t) .map(o -> o.getClass().getCanonicalName()) .orElse("null -- expected " + expectedClass.getCanonicalName())); }

sample: 1184
buggy_code: private void rematchAllNetworksAndRequests() { // TODO: This may be slow, and should be optimized. final long now = SystemClock.elapsedRealtime(); final NetworkReassignment changes = computeNetworkReassignment(); if (VDBG || DDBG) log(changes.toString()); applyNetworkReassignment(changes, <START> oldDefaultNetwork, now); <END> }
code_review: hmm, I don't think this can get build pass.
target code: private void rematchAllNetworksAndRequests ( ) { // TODO : This may be slow , and should be optimized . final long now = SystemClock . elapsedRealtime ( ) ; final NetworkReassignment changes = computeNetworkReassignment ( ) ; if ( VDBG || DDBG ) log ( changes . toString ( ) ) ; applyNetworkReassignment ( changes , now ) ; }
response: private void rematchAllNetworksAndRequests() { // TODO: This may be slow, and should be optimized. final long now = SystemClock.elapsedRealtime(); final NetworkReassignment changes = computeNetworkReassignment(); if (VDBG || DDBG) log(changes.toString()); applyNetworkReassignment(changes, oldDefaultNetwork, now); }

sample: 1185
buggy_code: public String getScroller() { <START> return scroller == null ? DEFAULT_SCROLLER : scroller; <END> }
code_review: wdyt if we replace it by ` return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER)` if you agree you will have some adaptation on 10.10 (java 8)
target code: public String getScroller ( ) { return scroller ; }
response: public String getScroller() { <START> return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER); <END> }

sample: 1186
buggy_code: public String getMessage(){ <START> return this.message; <END> }
code_review: Nit: unnecessary this.
target code: public String getMessage ( ) { return message ; }
response: public String getMessage(){ <START> return message; <END> }

sample: 1187
buggy_code: public Type convertReadValueToType(String pvReadValue) { Type lvType = convertReadValueToUnmodifiedType(pvReadValue); for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) { logger.debug("type of {} before modifier:{} type={}", getDevicePropertyPath(), <START> lvTypeModifier.getModifierName(), lvType.toString()); <END> lvType = lvTypeModifier.modify4Read(lvType); logger.debug("type of {} after modifier:{} type={}", getDevicePropertyPath(), lvTypeModifier.getModifierName(), lvType.toString()); } return lvType; }
code_review: no need for `.toString()`
target code: public Type convertReadValueToType ( String pvReadValue ) { Type lvType = convertReadValueToUnmodifiedType ( pvReadValue ) ; for ( InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList ( ) ) { logger . debug ( "type of { } before modifier : { } type = { } " , getDevicePropertyPath ( ) , lvTypeModifier . getModifierName ( ) , lvType ) ; lvType = lvTypeModifier . modify4Read ( lvType ) ; logger . debug ( "type of { } after modifier : { } type = { } " , getDevicePropertyPath ( ) , lvTypeModifier . getModifierName ( ) , lvType ) ; } return lvType ; }
response: public Type convertReadValueToType(String pvReadValue) { Type lvType = convertReadValueToUnmodifiedType(pvReadValue); for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) { logger.debug("type of {} before modifier:{} type={}", getDevicePropertyPath(), <START> lvTypeModifier.getModifierName(), lvType); <END> lvType = lvTypeModifier.modify4Read(lvType); logger.debug("type of {} after modifier:{} type={}", getDevicePropertyPath(), lvTypeModifier.getModifierName(), lvType); } return lvType; }

sample: 1188
buggy_code: <START> public void clear() { <END> this.domainsVisibility.clear(); }
code_review: this should be synchronized as well
target code: public synchronized void clear ( ) { this . domainsVisibility . clear ( ) ; }
response: <START> public synchronized void clear() { <END> this.domainsVisibility.clear(); }

sample: 1189
buggy_code: public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> Long id = Long.parseLong(issueId + "0" + newCommentId); <END> URI selfUri = URI.create(TEST_JIRA_URL + "/rest/api/latest/issue/" + issueId + "/comment"); return new Comment(selfUri, comment, null, null, now, null, null, id); }
code_review: Since you are at it, can you please change this to `long` primitive type? :)
target code: public static Comment newComment ( long issueId , int newCommentId , String comment ) { DateTime now = DateTime . now ( ) ; long id = Long . parseLong ( issueId + "0" + newCommentId ) ; URI selfUri = URI . create ( TEST_JIRA_URL + " / rest / api / latest / issue / " + issueId + " / comment" ) ; return new Comment ( selfUri , comment , null , null , now , null , null , id ) ; }
response: public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> long id = Long.parseLong(issueId + "0" + newCommentId); <END> URI selfUri = URI.create(TEST_JIRA_URL + "/rest/api/latest/issue/" + issueId + "/comment"); return new Comment(selfUri, comment, null, null, now, null, null, id); }

sample: 1190
buggy_code: private void registerGlueCodeScope(ConfigurableApplicationContext context) { do { <START> synchronized (context) { <END> context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope()); context = (ConfigurableApplicationContext) context.getParent(); } } while (context != null); }
code_review: I don't think this works. We're swapping out `context` with a different instance. We should probably use a constant as a monitor.
target code: private void registerGlueCodeScope ( ConfigurableApplicationContext context ) { do { context . getBeanFactory ( ) . registerScope ( SCOPE_CUCUMBER_GLUE , new GlueCodeScope ( ) ) ; context = ( ConfigurableApplicationContext ) context . getParent ( ) ; } while ( context != null ) ; }
response: private void registerGlueCodeScope(ConfigurableApplicationContext context) { do { <START> synchronized (this) { <END> context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope()); context = (ConfigurableApplicationContext) context.getParent(); } } while (context != null); }

sample: 1191
buggy_code: private String truncateMessageLength(String message, int maxLength) { if (message.length() > maxLength) { <START> message = message.substring(0, maxLength + 1); <END> } return message; }
code_review: This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace "maxLength + 1" with just "maxLength".
target code: private String truncateMessageLength ( String message , int maxLength ) { if ( message . length ( ) > maxLength ) { message = message . substring ( 0 , maxLength ) ; } return message ; }
response: private String truncateMessageLength(String message, int maxLength) { if (message.length() > maxLength) { <START> message = message.substring(0, maxLength); <END> } return message; }

sample: 1192
buggy_code: public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException("boo"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated();; <END> ts.assertError(TestException.class); ts.assertErrorMessage("boo"); }
code_review: double `;`
target code: public void testErrorReceived ( ) { TestObserver < Object > ts = new TestObserver < Object > ( ) ; TestException ex = new TestException ( "boo" ) ; Flowable . error ( ex ) . ignoreElements ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; ts . assertErrorMessage ( "boo" ) ; }
response: public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException("boo"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated(); <END> ts.assertError(TestException.class); ts.assertErrorMessage("boo"); }

sample: 1193
buggy_code: public boolean select(Viewer viewer, Object parentElement, <START> Object element) { <END> if (!(element instanceof DisplayItem)) { return false; } if (actionSet == null) { return false; } return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet); }
code_review: unnecessary linebreak
target code: public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( ! ( element instanceof DisplayItem ) || actionSet == null ) { return false ; } return CustomizePerspectiveDialog . includeInSetStructure ( ( DisplayItem ) element , actionSet ) ; }
response: public boolean select(Viewer viewer, Object parentElement, <START> Object element) { <END> if (!(element instanceof DisplayItem)) { return false; } if (actionSet == null) { return false; } return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet); }

sample: 1194
buggy_code: public static void runJSTestSuite() throws InterruptedException { // FIXME Update this when we stop using ARM Emulators int timeout = Build.SUPPORTED_ABIS[0].contains("armeabi") ? 180 : 60; <START> JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); <END> }
code_review: Why not just bump it up to `180` across the board?
target code: public static void runJSTestSuite ( ) throws InterruptedException { // FIXME Change timeout back to 60 when we stop using ARM Emulators JSTestCase . runJSTestSuite ( JS_SUITE , data ( ) , 180 ) ; }
response: public static void runJSTestSuite() throws InterruptedException { // FIXME Update this when we stop using ARM Emulators int timeout = Build.SUPPORTED_ABIS[0].contains("armeabi") ? 180 : 180; <START> JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); <END> }

sample: 1195
buggy_code: public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context) { <START> HashMap<String, String> combinedProperties = new HashMap<>(); <END> for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) { combinedProperties.putAll(sessionMatchSpec.match(context)); } return ImmutableMap.copyOf(combinedProperties); }
code_review: Nit: declare as `Map`
target code: public Map < String , String > getSystemSessionProperties ( SessionConfigurationContext context ) { // later properties override earlier properties Map < String , String > combinedProperties = new HashMap < > ( ) ; for ( SessionMatchSpec sessionMatchSpec : sessionMatchSpecs ) { combinedProperties . putAll ( sessionMatchSpec . match ( context ) ) ; } return ImmutableMap . copyOf ( combinedProperties ) ; }
response: public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context) { <START> Map<String, String> combinedProperties = new HashMap<>(); <END> for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) { combinedProperties.putAll(sessionMatchSpec.match(context)); } return ImmutableMap.copyOf(combinedProperties); }

sample: 1196
buggy_code: public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) { new ThriftAccessLogger().log( String.format("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation)); <START> } <END>
code_review: I thought it would be something like ``` LOG.info("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation); ``` and ThriftAccessLogger.log would just go away
target code: public static void logAccess ( Integer requestId , InetAddress remoteAddress , Principal principal , String operation ) { LOG . info ( "Request ID : { } access from : { } principal : { } operation : { } " , requestId , remoteAddress , principal , operation ) ; }
response: public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) { <START> } <END>

sample: 1197
buggy_code: public static List<String> getComputerNames() { final ArrayList<String> names = new ArrayList<String>(); <START> for (Computer c : Jenkins.getActiveInstance().getComputers()) { <END> if (!c.getName().isEmpty()) { names.add(c.getName()); } } return names; }
code_review: `getActiveInstance` is deprecated, please use good old `getInstance`.
target code: public static List < String > getComputerNames ( ) { final ArrayList < String > names = new ArrayList < String > ( ) ; for ( Computer c : Jenkins . getInstance ( ) . getComputers ( ) ) { if ( ! c . getName ( ) . isEmpty ( ) ) { names . add ( c . getName ( ) ) ; } } return names ; }
response: public static List<String> getComputerNames() { final ArrayList<String> names = new ArrayList<String>(); <START> for (Computer c : Jenkins.getInstance().getComputers()) { <END> if (!c.getName().isEmpty()) { names.add(c.getName()); } } return names; }

sample: 1198
buggy_code: public void unbind(final String eventName, final SubscriptionEventListener listener) { validateArguments(eventName, listener); <START> final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); <END> synchronized (lock) { if (listeners != null) { listeners.remove(listener); if (listeners.isEmpty()) { eventNameToListenerMap.remove(eventName); } } } }
code_review: As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency.
target code: public void unbind ( final String eventName , final SubscriptionEventListener listener ) { validateArguments ( eventName , listener ) ; synchronized ( lock ) { final Set < SubscriptionEventListener > listeners = eventNameToListenerMap . get ( eventName ) ; if ( listeners != null ) { listeners . remove ( listener ) ; if ( listeners . isEmpty ( ) ) { eventNameToListenerMap . remove ( eventName ) ; } } } }
response: public void unbind(final String eventName, final SubscriptionEventListener listener) { validateArguments(eventName, listener); synchronized (lock) { <START> final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); <END> if (listeners != null) { listeners.remove(listener); if (listeners.isEmpty()) { eventNameToListenerMap.remove(eventName); } } } }

sample: 1199
buggy_code: public Iterable<AccountGroup> all() { <START> final List<AccountGroup> groups = new LinkedList<AccountGroup>(); <END> for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) { final AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return Collections.unmodifiableList(groups); }
code_review: If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster.
target code: public Iterable < AccountGroup > all ( ) { final List < AccountGroup > groups = new ArrayList < AccountGroup > ( ) ; for ( final AccountGroup . NameKey groupName : list . get ( ListKey . ALL ) ) { final AccountGroup group = get ( groupName ) ; if ( group != null ) { groups . add ( group ) ; } } return Collections . unmodifiableList ( groups ) ; }
response: public Iterable<AccountGroup> all() { <START> final List<AccountGroup> groups = new ArrayList<AccountGroup>(); <END> for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) { final AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return Collections.unmodifiableList(groups); }

sample: 1200
buggy_code: public void terminate(HazelcastInstance instance) { try { Address address = getNode(instance).address; terminateInstance(instance); if (isMockNetwork) { registry.removeInstance(address); } } finally { <START> TestJmxLeakHelper.checkJmxBeans(instance.getName()); <END> } }
code_review: We have a large number of tests that don't use `TestHazelcastInstanceFactory` at all and call `Hazelcast.newHazelcastInstance()` directly (in combination with `Hazelcast.shutdownAll()` / `HazelcastInstanceFactory.shutdownAll()` / `HazelcastInstanceFactory.terminateAll()`). Shouldn't those be checked as well, somehow?
target code: public void terminate ( HazelcastInstance instance ) { Address address = getNode ( instance ) . address ; terminateInstance ( instance ) ; if ( isMockNetwork ) { registry . removeInstance ( address ) ; } }
response: public void terminate(HazelcastInstance instance) { try { Address address = getNode(instance).address; terminateInstance(instance); if (isMockNetwork) { registry.removeInstance(address); } } finally { <START> TestJmxLeakHelper.checkJmxBeans(instance.getName()); <END> } }

sample: 1201
buggy_code: public void endSuccessfully() { super.endSuccessfully(); if (getParameters().getImportAsTemplate()) { Guid newTemplateId = createTemplate(); // No reason for this to happen, but checking just to make sure if (newTemplateId != null) { attachDiskToTemplate(newTemplateId); } } updateDiskStatus(ImageStatus.OK); <START> getReturnValue().setSucceeded(true); <END> }
code_review: please change to setSucceeded
target code: public void endSuccessfully ( ) { super . endSuccessfully ( ) ; if ( getParameters ( ) . getImportAsTemplate ( ) ) { Guid newTemplateId = createTemplate ( ) ; // No reason for this to happen , but checking just to make sure if ( newTemplateId != null ) { attachDiskToTemplate ( newTemplateId ) ; } } updateDiskStatus ( ImageStatus . OK ) ; setSucceeded ( true ) ; }
response: public void endSuccessfully() { super.endSuccessfully(); if (getParameters().getImportAsTemplate()) { Guid newTemplateId = createTemplate(); // No reason for this to happen, but checking just to make sure if (newTemplateId != null) { attachDiskToTemplate(newTemplateId); } } updateDiskStatus(ImageStatus.OK); <START> setSucceeded(true); <END> }

sample: 1202
buggy_code: <START> void validate() { <END> // No-op, no validation required }
code_review: Interesting wrapping style :)
target code: public void validate ( ) { // No - op , no validation required }
response: <START> void validate() { <END> // No-op, no validation required }

sample: 1203
buggy_code: private void scheduleImmediateDelivery() { cancelDelayedDelivery(); while (state == State.RUNNING) { DeliveryAttempt previous = immediateDelivery.get(); if (previous != null && !previous.isDone()) <START> previous.cancel(); <END> DeliveryAttempt current = new DeliveryAttempt(); if (immediateDelivery.compareAndSet(previous, current)) { current.executeNow(); return; } } }
code_review: deliverEvents does not handle interruptions, so this is essentially a no-op if `previous` is already executing.
target code: private void scheduleImmediateDelivery ( ) { cancelDelayedDelivery ( ) ; while ( state == State . RUNNING ) { DeliveryAttempt previous = immediateDelivery . get ( ) ; if ( previous != null ) previous . cancel ( ) ; DeliveryAttempt current = new DeliveryAttempt ( ) ; if ( immediateDelivery . compareAndSet ( previous , current ) ) { current . executeNow ( ) ; return ; } } }
response: private void scheduleImmediateDelivery() { cancelDelayedDelivery(); while (state == State.RUNNING) { DeliveryAttempt previous = immediateDelivery.get(); if (previous != null && !previous.isDone()) <START> previous.cancel(); <END> DeliveryAttempt current = new DeliveryAttempt(); if (immediateDelivery.compareAndSet(previous, current)) { current.executeNow(); return; } } }

sample: 1204
buggy_code: private static ObjectNode handleGaugeRollup(GaugeRollup rollup) { ObjectNode rollupNode = JsonNodeFactory.instance.objectNode(); <START> rollupNode.put("timestamp", rollup.getTimestamp()); <END> SimpleNumber rollupValue = rollup.getLatestValue(); rollupNode.put("latestVal", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue()); return handleBasicRollup(rollup, rollupNode); }
code_review: Why do gauges get timestamp twice?
target code: private static ObjectNode handleGaugeRollup ( GaugeRollup rollup ) { ObjectNode rollupNode = JsonNodeFactory . instance . objectNode ( ) ; SimpleNumber rollupValue = rollup . getLatestValue ( ) ; rollupNode . put ( "latestVal" , rollupValue . getDataType ( ) == ( SimpleNumber . Type . DOUBLE ) ? rollupValue . getValue ( ) . doubleValue ( ) : rollupValue . getValue ( ) . longValue ( ) ) ; return handleBasicRollup ( rollup , rollupNode ) ; }
response: private static ObjectNode handleGaugeRollup(GaugeRollup rollup) { ObjectNode rollupNode = JsonNodeFactory.instance.objectNode(); SimpleNumber rollupValue = rollup.getLatestValue(); rollupNode.put("latestVal", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue()); return handleBasicRollup(rollup, rollupNode); }

sample: 1205
buggy_code: public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, "{3}{G}{G}"); this.subtype.add(SubType.RHINO); this.power = new MageInt(3); this.toughness = new MageInt(5); // Vigilance this.addAbility(VigilanceAbility.getInstance()); // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it. <START> this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); <END> }
code_review: this doesn't need to have the ability and effect both be optional, just the ability is fine.
target code: public GarruksWarsteed ( UUID ownerId , CardSetInfo setInfo ) { super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , " { 3 } { G } { G } " ) ; this . subtype . add ( SubType . RHINO ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 5 ) ; // Vigilance this . addAbility ( VigilanceAbility . getInstance ( ) ) ; // When Garruk's Warsteed enters the battlefield , you may search your library and / or graveyard for a card named Garruk , Savage Herald , reveal it , and put it into your hand . If you search your library this way , shuffle it . this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SearchLibraryGraveyardPutInHandEffect ( filter , false , true ) ) ) ; }
response: public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, "{3}{G}{G}"); this.subtype.add(SubType.RHINO); this.power = new MageInt(3); this.toughness = new MageInt(5); // Vigilance this.addAbility(VigilanceAbility.getInstance()); // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it. <START> this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); <END> }

sample: 1206
buggy_code: private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) { lock.writeLock().lock(); try { if (cachedFileChannel.markDead()) { <START> try { <END> cachedFileChannel.fileChannel.close(); } catch (IOException e) { LOG.warn("Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file: {}", cachedFileChannel); } finally { IOUtils.close(LOG, cachedFileChannel.fileChannel); } // to guarantee the removed cachedFileChannel is what we want to remove. fileChannels.remove(logId, cachedFileChannel); } } finally { lock.writeLock().unlock(); } }
code_review: markDead doesn't need to be under a lock. The caller should call tryRetain() after receiving, which will either prevent markDead from having an effect, if it is called before it.
target code: private void releaseFileChannel ( long logId , CachedFileChannel cachedFileChannel ) { if ( cachedFileChannel . markDead ( ) ) { // to guarantee the removed cachedFileChannel is what we want to remove . fileChannels . remove ( logId , cachedFileChannel ) ; // close corresponding fileChannel try { cachedFileChannel . fileChannel . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file : { } " , cachedFileChannel ) ; } finally { IOUtils . close ( LOG , cachedFileChannel . fileChannel ) ; } } }
response: private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) { lock.writeLock().lock(); try { if (cachedFileChannel.markDead()) { <START> try { <END> cachedFileChannel.fileChannel.close(); } catch (IOException e) { LOG.warn("Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file: {}", cachedFileChannel); } finally { IOUtils.close(LOG, cachedFileChannel.fileChannel); } // to guarantee the removed cachedFileChannel is what we want to remove. fileChannels.remove(logId, cachedFileChannel); } } finally { lock.writeLock().unlock(); } }

sample: 1207
buggy_code: private static File getDefaultFile() { <START> File netrc; <END> File home = new File(System.getProperty("user.home")); //$NON-NLS-1$ netrc = new File(home, ".netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; netrc = new File(home, "_netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; return null; }
code_review: no need to declare this here, instead declare the type in line 141
target code: private static File getDefaultFile ( ) { File home = new File ( System . getProperty ( "user . home" ) ) ; // $NON - NLS - 1$ File netrc = new File ( home , " . netrc" ) ; // $NON - NLS - 1$ if ( netrc . exists ( ) ) return netrc ; netrc = new File ( home , "_netrc" ) ; // $NON - NLS - 1$ if ( netrc . exists ( ) ) return netrc ; return null ; }
response: private static File getDefaultFile() { <START> <END> File home = new File(System.getProperty("user.home")); //$NON-NLS-1$ File netrc = new File(home, ".netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; netrc = new File(home, "_netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; return null; }

sample: 1208
buggy_code: <START> static synchronized ServiceContext getServiceContext() { <END> if (serviceContext == null) { synchronized (Context.class) { if (serviceContext == null) { log.error("serviceContext is null. Creating new ServiceContext()"); serviceContext = ServiceContext.getInstance(); } } } log.trace("serviceContext: {}", serviceContext); return ServiceContext.getInstance(); }
code_review: I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block.
target code: static synchronized ServiceContext getServiceContext ( ) { synchronized ( Context . class ) { if ( serviceContext == null ) { log . error ( "serviceContext is null . Creating new ServiceContext ( ) " ) ; serviceContext = ServiceContext . getInstance ( ) ; } } log . trace ( "serviceContext : { } " , serviceContext ) ; return ServiceContext . getInstance ( ) ; }
response: <START> static synchronized ServiceContext getServiceContext() { <END> synchronized (Context.class) { if (serviceContext == null) { log.error("serviceContext is null. Creating new ServiceContext()"); serviceContext = ServiceContext.getInstance(); } } log.trace("serviceContext: {}", serviceContext); return ServiceContext.getInstance(); }

sample: 1209
buggy_code: public synchronized void activate() { <START> OTELog.getLogger("test").debug("something"); <END> listener = new Slf4jLogListener(); logService.addLogListener(listener); }
code_review: remove this line
target code: public synchronized void activate ( ) { listener = new Slf4jLogListener ( ) ; logService . addLogListener ( listener ) ; }
response: public synchronized void activate() { <START> OTELog.getLogger("test").debug("something"); listener = new Slf4jLogListener(); logService.addLogListener(listener); <END> }

sample: 1210
buggy_code: <START> public void testDeserialization() throws Exception { <END> for (Short version : versions) { composedBlobIdAndDeserialize(version); } }
code_review: I don't understand the need of this test. We have the next one which tests serialization and deserialization if I am not wrong. Or does this tests something more than the next one ?
target code: public void testDeserialization ( ) throws Exception { composedBlobIdAndDeserialize ( version ) ; }
response: public void testDeserialization() throws Exception { for (Short version : versions) { composedBlobIdAndDeserialize(version); } }

sample: 1211
buggy_code: private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) { <START> List<VMWithPlugInfo> vmsWithPlugInfo = <END> getCallsHandler().executeReadList ("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id)); return vmsWithPlugInfo; }
code_review: should be just return , no need for variable
target code: private List < VMWithPlugInfo > getVmsWithPlugInfo ( Guid id ) { return getCallsHandler ( ) . executeReadList ( "GetVmsByDiskId" , VMWithPlugInfoRowMapper . instance , getCustomMapSqlParameterSource ( ) . addValue ( "disk_guid" , id ) ) ; }
response: private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) { <START> return <END> getCallsHandler().executeReadList ("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id)); }

sample: 1212
buggy_code: public Jedis createResource() { <START> Jedis jedis = new Jedis(this); <END> try { jedis.select(db); } catch(JedisException e) { log.log(Level.SEVERE, "Can't select database due a Redis connection problem", e); } return jedis; }
code_review: @nykolaslima How about handling selecting db by constructor of BinaryJedis, as authentication takes place?
target code: public Jedis createResource ( ) { return new Jedis ( this ) ; }
response: public Jedis createResource() { <START> Jedis jedis = new Jedis(this, db); <END> try { jedis.select(db); } catch(JedisException e) { log.log(Level.SEVERE, "Can't select database due a Redis connection problem", e); } return jedis; }

sample: 1213
buggy_code: public JSchUIConnectionManager(IRemoteServices services) { fConnMgr = (JSchConnectionManager) services.getConnectionManager(); <START> fConnMgr.setDefaultAuthenticatorFactory(new IUserAuthenticatorFactory() { <END> @Override public IUserAuthenticator createUserAuthenticator(IRemoteConnection conn) { return new RemoteAuthenticator(conn); } }); }
code_review: Please keep initialization code out of the Activator class.
target code: public JSchUIConnectionManager ( IRemoteServices services ) { fConnMgr = ( JSchConnectionManager ) services . getConnectionManager ( ) ; }
response: public void start(BundleContext context) throws Exception { <START> fConnMgr = (JSchConnectionManager) RemoteServices.getRemoteServices(context).getConnectionManager(); <END> }

sample: 1214
buggy_code: public BoltDeclarer addConfigurations(Map<String, Object> conf) { <START> if (conf != null && !conf.isEmpty()) { <END> component.componentConf.putAll(conf); } return this; }
code_review: Nit: I think putAll is a no-op when the conf is empty, so you probably don't need to check.
target code: public BoltDeclarer addConfigurations ( Map < String , Object > conf ) { if ( conf != null ) { component . componentConf . putAll ( conf ) ; } return this ; }
response: public BoltDeclarer addConfigurations(Map<String, Object> conf) { <START> if (conf != null) { <END> component.componentConf.putAll(conf); } return this; }

sample: 1215
buggy_code: public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc, IBreakpointsTargetDMContext.class); IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId); for (IBreakpoint breakpoint : breakpoints) { <START> if (supportsBreakpoint(breakpoint) && breakpoint instanceof ICBreakpoint) { <END> setTargetFilter((ICBreakpoint) breakpoint, containerDmc); } } startTrackingBreakpoints(targetBpDmc, rm); }
code_review: Its a heavy read that bug! When you check if breakpoint applicable probably better reverse instanceof check and call. Instanceof is cheaper
target code: public void startTrackingBpForProcess ( final IContainerDMContext containerDmc , final RequestMonitor rm ) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts . getAncestorOfType ( containerDmc , IBreakpointsTargetDMContext . class ) ; IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( fDebugModelId ) ; for ( IBreakpoint breakpoint : breakpoints ) { if ( breakpoint instanceof ICBreakpoint && supportsBreakpoint ( breakpoint ) ) { setTargetFilter ( ( ICBreakpoint ) breakpoint , containerDmc ) ; } } startTrackingBreakpoints ( targetBpDmc , rm ) ; }
response: public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc, IBreakpointsTargetDMContext.class); IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId); for (IBreakpoint breakpoint : breakpoints) { <START> if (breakpoint instanceof ICBreakpoint && supportsBreakpoint(breakpoint)) { <END> setTargetFilter((ICBreakpoint) breakpoint, containerDmc); } } startTrackingBreakpoints(targetBpDmc, rm); }

sample: 1216
buggy_code: protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) { // stop periodical tasks to prevent race condition rt.getGarbageInformer().stop(); // wait until all garbage decisions are sent to logUnit servers. rt.getGarbageInformer().waitUntilAllTasksFinish(); // send garbage decisions to logUnit servers <START> while (rt.getGarbageInformer().getGarbageReceivingQueue().size() > 0) { rt.getGarbageInformer().gcUnsafe(); } <END> // run compaction on LogUnit servers logUnitServer.runCompaction(); rt.getAddressSpaceView().resetCaches(); rt.getAddressSpaceView().invalidateServerCaches(); }
code_review: Put this logic into GarbageInformer together with waitUntilAllTasksFinish as we discussed.
target code: protected void startCompaction ( CorfuRuntime rt , LogUnitServer logUnitServer ) { // stop periodical tasks to prevent race condition rt . getGarbageInformer ( ) . stop ( ) ; // wait until all garbage decisions are sent to logUnit servers . rt . getGarbageInformer ( ) . waitUntilAllTasksFinish ( ) ; // run compaction on LogUnit servers logUnitServer . runCompaction ( ) ; rt . getAddressSpaceView ( ) . resetCaches ( ) ; rt . getAddressSpaceView ( ) . invalidateServerCaches ( ) ; }
response: protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) { // stop periodical tasks to prevent race condition rt.getGarbageInformer().stop(); // wait until all garbage decisions are sent to logUnit servers. rt.getGarbageInformer().waitUntilAllTasksFinish(); // run compaction on LogUnit servers logUnitServer.runCompaction(); rt.getAddressSpaceView().resetCaches(); rt.getAddressSpaceView().invalidateServerCaches(); }

sample: 1217
buggy_code: private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException { try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) { ByteStreams.copy(from, channel); <START> return; <END> } }
code_review: This addition is pointless
target code: private void writeToChannelVersionOne ( WritableByteChannel channel ) throws IOException { try ( ReadableByteChannel from = Channels . newChannel ( combineStreams ( ) . getInput ( ) ) ) { ByteStreams . copy ( from , channel ) ; } }
response: private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException { try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) { ByteStreams.copy(from, channel); <START> return; <END> } }

sample: 1218
buggy_code: protected void setUp() throws Exception { super.setUp(); Statement stmt = con.createStatement(); /* Drop the test table if it already exists for some reason. It is not an error if it doesn't exist. */ TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP"); stmt.close(); /* Generally recommended with batch updates. By default we run all tests in this test case with autoCommit disabled. */ <START> con.setAutoCommit(false); <END> }
code_review: Please remove that
target code: protected void setUp ( ) throws Exception { super . setUp ( ) ; Statement stmt = con . createStatement ( ) ; /* Drop the test table if it already exists for some reason . It is not an error if it doesn't exist . */ TestUtil . createTable ( con , "testtz" , "col1 INTEGER , col2 TIMESTAMP" ) ; stmt . close ( ) ; }
response: protected void setUp() throws Exception { super.setUp(); Statement stmt = con.createStatement(); /* Drop the test table if it already exists for some reason. It is not an error if it doesn't exist. */ TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP"); stmt.close(); /* Generally recommended with batch updates. By default we run all tests in this test case with autoCommit disabled. */ con.setAutoCommit(false); }

sample: 1219
buggy_code: public List<Currency> getCurrencyForName(final String name) { List<Currency> list = _namesToCurrency.get(name); <START> if (list == null) { <END> return new ArrayList<>(); } return _namesToCurrency.get(name); }
code_review: These null checks will disappear if using a multimap
target code: public List < Currency > getCurrencyForName ( final String name ) { return _namesToCurrency . get ( name ) ; }
response: public List<Currency> getCurrencyForName(final String name) { List<Currency> list = _namesToCurrency.get(name); <START> if (list == null) { <END> return new ArrayList<>(); } return _namesToCurrency.get(name); }

sample: 1220
buggy_code: private static boolean parseAllowAlias(List<Option> options) { Option option = Option.findByName(options, "allow_alias"); if (option != null) { Object value = option.getValue(); <START> return value instanceof Boolean ? (Boolean) value : "true".equals(value); <END> } return false; }
code_review: What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
target code: private static boolean parseAllowAlias ( List < Option > options ) { Option option = Option . findByName ( options , "allow_alias" ) ; if ( option != null ) { Object value = option . getValue ( ) ; return value instanceof Boolean && ( Boolean ) value ; } return false ; }
response: private static boolean parseAllowAlias(List<Option> options) { Option option = Option.findByName(options, "allow_alias"); if (option != null) { Object value = option.getValue(); <START> return value instanceof Boolean ? (Boolean) value : "true".equals(value); <END> } return false; }

sample: 1221
buggy_code: public WebArchive createDeployment() { <START> if (resourceLocal) { <END> archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class ); } else { archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class ); } return archive; }
code_review: Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest.
target code: public WebArchive createDeployment ( ) { if ( resourceLocal ) { archive . addClasses ( MemberRegistrationWithResourceLocal . class ) ; } else { archive . addClasses ( MemberRegistrationWithJta . class , JtaResources . class ) ; } return archive ; }
response: public WebArchive createDeployment() { <START> if (resourceLocal) { <END> archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class ); } else { archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class ); } return archive; }

sample: 1222
buggy_code: private StorageDomain recoverStorageDomain(String sdUUID) { <START> log.info("about to recover SD {}", sdUUID); <END> StorageDomain storageDomain = new StorageDomain(); storageDomain.setId(sdUUID); updateStorageDomain(storageDomain); return storageDomain; }
code_review: log.debug ?
target code: private StorageDomain recoverStorageDomain ( String sdUUID ) { log . warn ( "about to recover SD { } " , sdUUID ) ; StorageDomain storageDomain = new StorageDomain ( ) ; storageDomain . setId ( sdUUID ) ; updateStorageDomain ( storageDomain ) ; return storageDomain ; }
response: private StorageDomain recoverStorageDomain(String sdUUID) { <START> log.debug("about to recover SD {}", sdUUID); <END> StorageDomain storageDomain = new StorageDomain(); storageDomain.setId(sdUUID); updateStorageDomain(storageDomain); return storageDomain; }

sample: 1223
buggy_code: public Event complianceCreated(Consumer consumer, Set<Entitlement> entitlements, ComplianceStatus compliance) { return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE, consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(), <START> consumer.getId(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, <END> null); }
code_review: We'll need the second usage of consumer.getId() replaced with consumer.getUuid() as well.
target code: public Event complianceCreated ( Consumer consumer , Set < Entitlement > entitlements , ComplianceStatus compliance ) { // Instead of an internal db id , compliance . created events now use // UUID for the 'consumerId' and 'entityId' fields , since Katello // is concerned only with the consumer UUID field . This is the first // part of a larger piece of work to simplify Event consumption . return new Event ( Event . Type . CREATED , Event . Target . COMPLIANCE , consumer . getName ( ) , principalProvider . get ( ) , consumer . getOwner ( ) . getId ( ) , consumer . getUuid ( ) , consumer . getUuid ( ) , null , buildComplianceDataJson ( consumer , entitlements , compliance ) , null , null ) ; }
response: public Event complianceCreated(Consumer consumer, Set<Entitlement> entitlements, ComplianceStatus compliance) { return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE, consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(), <START> consumer.getUuid(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, <END> null); }

sample: 1224
buggy_code: public static String toHexString(byte[] digest) { <START> StringBuffer buf <END> = new StringBuffer(); for (int i = 0; i < digest.length; i++) { if ((digest[i] & 0xFF) < 0x10) buf.append('0'); buf.append(Integer.toHexString(digest[i] & 0xFF)); } return buf.toString(); }
code_review: Use StringBuilder please.
target code: public static String toHexString ( byte [ ] digest ) { StringBuilder buf = new StringBuilder ( ) ; for ( byte element : digest ) { if ( ( element & 0xFF ) < 0x10 ) buf . append ( '0' ) ; buf . append ( Integer . toHexString ( element & 0xFF ) ) ; } return buf . toString ( ) ; }
response: public static String toHexString(byte[] digest) { <START> StringBuilder buf <END> = new StringBuilder(); for (int i = 0; i < digest.length; i++) { if ((digest[i] & 0xFF) < 0x10) buf.append('0'); buf.append(Integer.toHexString(digest[i] & 0xFF)); } return buf.toString(); }

sample: 1225
buggy_code: private boolean isLastKilledQueryGone() { boolean lastKilledQueryIsGone = (lastKilledQuery == null); <START> if (!lastKilledQueryIsGone) { <END> ClusterMemoryPool generalPool = pools.get(GENERAL_POOL); if (generalPool != null) { lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery); } } return lastKilledQueryIsGone; }
code_review: Invert this so it returns early
target code: private boolean isLastKilledQueryGone ( ) { if ( lastKilledQuery == null ) { return true ; } ClusterMemoryPool generalPool = pools . get ( GENERAL_POOL ) ; if ( generalPool == null ) { return false ; } return generalPool . getQueryMemoryReservations ( ) . containsKey ( lastKilledQuery ) ; }
response: private boolean isLastKilledQueryGone() { boolean lastKilledQueryIsGone = (lastKilledQuery == null); <START> if (lastKilledQueryIsGone) { <END> return lastKilledQueryIsGone; } ClusterMemoryPool generalPool = pools.get(GENERAL_POOL); if (generalPool != null) { lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery); } return lastKilledQueryIsGone; }

sample: 1226
buggy_code: public Batcher(ScheduledExecutorService workExecutor, int capacity, long delay, BatchProcessor<T> processor) { this.workExecutor = workExecutor; this.capacity = capacity; this.delay = delay; this.processor = processor; this.inbox = new ArrayList<T>(); this.scheduled = false; <START> this.lastProcessedTime = 0; <END> }
code_review: Is this change that makes batcher immediately execute after create new instance of Batcher and then added tasks smaller than capacity size?
target code: public Batcher ( ScheduledExecutorService workExecutor , int capacity , long delay , BatchProcessor < T > processor ) { this . workExecutor = workExecutor ; this . capacity = capacity ; this . delay = delay ; this . processor = processor ; }
response: public Batcher(ScheduledExecutorService workExecutor, int capacity, long delay, BatchProcessor<T> processor) { this.workExecutor = workExecutor; this.capacity = capacity; this.delay = delay; this.processor = processor; this.inbox = new ArrayList<T>(); this.scheduled = false; <START> this.lastProcessedTime = 0; this.lastProcessedTime = System.currentTimeMillis(); <END> }

sample: 1227
buggy_code: public static void removeMagicResponseContextFields(Map<String, Object> responseContext) { <START> responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); <END> responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED); }
code_review: This line should also be removed.
target code: public static void removeMagicResponseContextFields ( Map < String , Object > responseContext ) { responseContext . remove ( DirectDruidClient . QUERY_TOTAL_BYTES_GATHERED ) ; }
response: public static void removeMagicResponseContextFields(Map<String, Object> responseContext) { <START> responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED); <END> }

sample: 1228
buggy_code: private void validateAndClose() throws Exception { try { info("Validating static and Helix cluster maps"); verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout); if (validatingHelixClusterManager != null) { <START> ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, <END> "Helix cluster manager should not have encountered any errors"); } } finally { if (validatingHelixClusterManager != null) { validatingHelixClusterManager.close(); } for (HelixAdmin admin : adminForDc.values()) { admin.close(); } } }
code_review: no Exception is thrown in this method
target code: private void validateAndClose ( ) { try { info ( "Validating static and Helix cluster maps" ) ; verifyEquivalencyWithStaticClusterMap ( staticClusterMap . hardwareLayout , staticClusterMap . partitionLayout ) ; if ( validatingHelixClusterManager != null ) { ensureOrThrow ( validatingHelixClusterManager . getErrorCount ( ) == 0 , "Helix cluster manager should not have encountered any errors" ) ; } } finally { if ( validatingHelixClusterManager != null ) { validatingHelixClusterManager . close ( ) ; } for ( HelixAdmin admin : adminForDc . values ( ) ) { admin . close ( ) ; } } }
response: private void validateAndClose() { try { info("Validating static and Helix cluster maps"); verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout); if (validatingHelixClusterManager != null) { <START> ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, <END> "Helix cluster manager should not have encountered any errors"); } } finally { if (validatingHelixClusterManager != null) { validatingHelixClusterManager.close(); } for (HelixAdmin admin : adminForDc.values()) { admin.close(); } } }

sample: 1229
buggy_code: public int size() { if (currentOffset == NO_VALUES) { return 0; } <START> return maxOffset - currentOffset - 1; <END> }
code_review: Consider: `return currentOffset == NO_VALUES ? 0 : maxOffset - currentOffset - 1;`
target code: public int size ( ) { return isEmpty ( ) ? 0 : maxOffset - currentOffset ; }
response: public int size() { if (currentOffset == NO_VALUES) { return 0; } return maxOffset - currentOffset - 1; }

sample: 1230
buggy_code: <START> public void updateEditorPages(int activatedPage) { <END> removeAllPages(); addPages(); if (backToActivePage > 0 && backToActivePage < this.getPageCount()) { setActivePage(backToActivePage); } else { //Set active page if the backToActivePage is out of the range setActivePage(0); } setPartName(getPartName()); }
code_review: activatedPage is not used anymore
target code: public void updateEditorPages ( int activatedPage ) { updateEditorPages ( ) ; }
response: <START> public void updateEditorPages() { <END> removeAllPages(); addPages(); if (backToActivePage > 0 && backToActivePage < this.getPageCount()) { setActivePage(backToActivePage); } else { //Set active page if the backToActivePage is out of the range setActivePage(0); } setPartName(getPartName()); }

sample: 1231
buggy_code: public Object execute(ExecutionEvent event) throws ExecutionException { <START> Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); <END> if (checkCompositeRename != null) { return checkForCompositeRename(event, checkCompositeRename); } else { performRename(event); } return null; }
code_review: Looking at other HandlerUtil.getVariable() calls, the usual logic is to look for an instance of what you were looking for (in this case Boolean) and to treat any other situation as if null was provided. This would remove the need to check for Boolean in checkForCompositeRename and having code to issue an error log message which should never occur.
target code: public Object execute ( ExecutionEvent event ) throws ExecutionException { Object checkCompositeRename = HandlerUtil . getVariable ( event , LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY ) ; if ( checkCompositeRename instanceof Boolean ) { return checkForCompositeRename ( event ) ; } else { performRename ( event ) ; } return null ; }
response: public Object execute(ExecutionEvent event) throws ExecutionException { <START> Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); <END> if (checkCompositeRename instanceof Boolean) { return checkForCompositeRename(event, checkCompositeRename); } else { performRename(event); } return null; }

sample: 1232
buggy_code: <START> public Arguments setUntypedNullArgument(Argument untypedNullArgument) { <END> if (untypedNullArgument == null) { throw new IllegalArgumentException("the Argument itself may not be null"); } this.untypedNullArgument = untypedNullArgument; return this; }
code_review: Another non-permissible change
target code: public void setUntypedNullArgument ( Argument untypedNullArgument ) { if ( untypedNullArgument == null ) { throw new IllegalArgumentException ( "the Argument itself may not be null" ) ; } this . untypedNullArgument = untypedNullArgument ; }
response: <START> public Arguments setUntypedNullArgument(Argument untypedNullArgument) { <END> if (untypedNullArgument == null) { throw new IllegalArgumentException("the Argument itself may not be null"); } this.untypedNullArgument = untypedNullArgument; return this; }

sample: 1233
buggy_code: private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) { if (func.startsWith("Constant")) { <START> return drf.constantPerIssue(constantCost.replace("mn", "min")); <END> } if ("Linear".equals(func)) { return drf.linear(linearFactor.replace("mn", "min")); } return drf.linearWithOffset(linearFactor.replace("mn", "min"), linearOffset.replace("mn", "min")); }
code_review: @ivandalbosco I see that you just copied this piece from JS, but it's not perfect there :) We can drop `.replace("mn", "min")` everywhere (3 places). This was done as many RSPECs had legacy `mn` for minutes. It should be fixed now. It there is still some RSPEC using `mn` and plugin fails, then you better update this RSPEC
target code: private DebtRemediationFunction remediationFunction ( DebtRemediationFunctions drf ) { if ( func . startsWith ( "Constant" ) ) { return drf . constantPerIssue ( constantCost ) ; } if ( "Linear" . equals ( func ) ) { return drf . linear ( linearFactor ) ; } return drf . linearWithOffset ( linearFactor , linearOffset ) ; }
response: private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) { if (func.startsWith("Constant")) { <START> return drf.constantPerIssue(constantCost); <END> } if ("Linear".equals(func)) { return drf.linear(linearFactor); } return drf.linearWithOffset(linearFactor, linearOffset); }

sample: 1234
buggy_code: public void setAnalysisCache(final AnalysisCache cache) { if (cache == null && isAnalysisCacheFunctional()) { analysisCache = new NoopAnalysisCache(); // Log warning only once, if not explicitly disabled if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) { final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? "latest" : "pmd-" + PMDVersion.VERSION; <START> LOG.warning("This analysis could be faster, please consider using Incremental Analysis: " <END> + "https://pmd.github.io/" + version + "/pmd_userdocs_getting_started.html#incremental-analysis"); } } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled analysisCache = cache; } }
code_review: I find it very unintuitive to find this here... I'd suggest moving the log to `PMD.doPMD`, which is guaranteed to run once and a little more natural
target code: public void setAnalysisCache ( final AnalysisCache cache ) { // the doc says it's a noop if incremental analysis was disabled , // but it's actually the getter that enforces that this . analysisCache = cache == null ? new NoopAnalysisCache ( ) : cache ; }
response: public void setAnalysisCache(final AnalysisCache cache) { if (cache == null && isAnalysisCacheFunctional()) { analysisCache = new NoopAnalysisCache(); // Log warning only once, if not explicitly disabled if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) { final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? "latest" : "pmd-" + PMDVersion.VERSION; LOG.warning("This analysis could be faster, please consider using Incremental Analysis: " + "https://pmd.github.io/" + version + "/pmd_userdocs_getting_started.html#incremental-analysis"); } } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled analysisCache = cache; } }

sample: 1235
buggy_code: private static double sortableLongToDouble(long value) { <START> value = value ^ (value >> 63) & Long.MAX_VALUE; <END> return Double.longBitsToDouble(value); }
code_review: Same here. Add clarifying parenthesis
target code: private static double sortableLongToDouble ( long value ) { value = value ^ ( ( value > > 63 ) & Long . MAX_VALUE ) ; return Double . longBitsToDouble ( value ) ; }
response: private static double sortableLongToDouble(long value) { <START> value = (value ^ (value >> 63)) & Long.MAX_VALUE; <END> return Double.longBitsToDouble(value); }

sample: 1236
buggy_code: public static Exception extractExecutionExceptionCause(Exception e) { if (!(e instanceof ExecutionException)) { return e; } Throwable cause = e.getCause(); return cause == null ? e : (cause instanceof Exception ? (Exception) cause : new Exception(cause)); <START> } <END>
code_review: ``` if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause); ``` How about making return statement simpler?
target code: public static Exception extractExecutionExceptionCause ( Exception e ) { Throwable cause = e . getCause ( ) ; if ( ! ( e instanceof ExecutionException ) || cause == null ) { return e ; } return cause instanceof Exception ? ( Exception ) cause : new Exception ( cause ) ; }
response: public static Exception extractExecutionExceptionCause(Exception e) { if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause); <START> } <END>

sample: 1237
buggy_code: boolean isEmpty() { <START> return (validIndexSegments.isEmpty()); <END> }
code_review: minor: braces unnecessary
target code: boolean isEmpty ( ) { return validIndexSegments . isEmpty ( ) ; }
response: boolean isEmpty() { <START> return validIndexSegments.isEmpty(); <END> }

sample: 1238
buggy_code: Set getDefaultIgnoreTypeNames() { Set ignored = new HashSet(); String[] ignore = {"org.eclipse.core.runtime.Plugin", "java.lang.ClassLoader", "org.eclipse.team.internal.ccvs.core.CVSTeamProvider", "org.eclipse.core.internal.events.BuilderPersistentInfo", "org.eclipse.core.internal.resources.Workspace", "org.eclipse.core.internal.events.EventStats", "java.net.URL"}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$ <START> for (String element : ignore) { <END> ignored.add(element); } return ignored; }
code_review: Please do only whitespace changes in this commit.
target code: Set getDefaultIgnoreTypeNames ( ) { Set ignored = new HashSet ( ) ; String [ ] ignore = { "org . eclipse . core . runtime . Plugin" , "java . lang . ClassLoader" , "org . eclipse . team . internal . ccvs . core . CVSTeamProvider" , "org . eclipse . core . internal . events . BuilderPersistentInfo" , "org . eclipse . core . internal . resources . Workspace" , "org . eclipse . core . internal . events . EventStats" , "java . net . URL" } ; // $NON - NLS - 1$ // $NON - NLS - 2$ // $NON - NLS - 6$ for ( int i = 0 ; i < ignore . length ; i ++ ) { ignored . add ( ignore [ i ] ) ; } return ignored ; }
response: Set getDefaultIgnoreTypeNames() { Set ignored = new HashSet(); String[] ignore = {"org.eclipse.core.runtime.Plugin", "java.lang.ClassLoader", "org.eclipse.team.internal.ccvs.core.CVSTeamProvider", "org.eclipse.core.internal.events.BuilderPersistentInfo", "org.eclipse.core.internal.resources.Workspace", "org.eclipse.core.internal.events.EventStats", "java.net.URL"}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$ <START> for (String element : ignore) { <END> ignored.add(element); } return ignored; }

sample: 1239
buggy_code: public static boolean delete(File file) { if (!file.exists()) return true; if (file.isDirectory()) { File[] children = file.listFiles(); for (File <START> children1 : <END> children) { delete(children1); } } return file.delete(); }
code_review: child
target code: public static boolean delete ( File file ) { if ( ! file . exists ( ) ) return true ; if ( file . isDirectory ( ) ) { File [ ] children = file . listFiles ( ) ; for ( File child : children ) { delete ( child ) ; } } return file . delete ( ) ; }
response: public static boolean delete(File file) { if (!file.exists()) return true; if (file.isDirectory()) { File[] children = file.listFiles(); for (File child : children) { delete(child); } } return file.delete(); }

sample: 1240
buggy_code: public void logout(final IProgressMonitor monitor) throws XmlRpcException { userID = -1; token = null; (new BugzillaXmlRpcOperation<Integer>(this) { @SuppressWarnings("serial") @Override public Integer execute() throws XmlRpcException { try { <START> bugzillaClient.authenticate(monitor); <END> } catch (CoreException e) { // TODO Auto-generated catch block e.printStackTrace(); } Object response = call(monitor, XML_USER_LOGOUT, null); return -1; } }).execute(); return; }
code_review: Why do we call authenticate to log out? If we aren't already authenticated, why do we need to log out?
target code: public void logout ( final IProgressMonitor monitor ) throws XmlRpcException { ( new BugzillaXmlRpcOperation < Integer > ( this ) { @SuppressWarnings ( "serial" ) @Override public Integer execute ( ) throws XmlRpcException { Object response = call ( monitor , XML_USER_LOGOUT , null ) ; return - 1 ; } } ) . execute ( ) ; userID = - 1 ; token = null ; return ; }
response: public void logout(final IProgressMonitor monitor) throws XmlRpcException { userID = -1; token = null; (new BugzillaXmlRpcOperation<Integer>(this) { @SuppressWarnings("serial") @Override public Integer execute() throws XmlRpcException { try { <START> bugzillaClient.authenticate(monitor); <END> } catch (CoreException e) { // TODO Auto-generated catch block e.printStackTrace(); } Object response = call(monitor, XML_USER_LOGOUT, null); return -1; } }).execute(); return; }

sample: 1241
buggy_code: private double cleanNumber(double dirtyNumber) { <START> double clean; <END> if (dirtyNumber < 1) clean = 0; else clean = dirtyNumber; return clean; }
code_review: Could be simplified to: ```java return dirtyNumber < 1 ? 0 : dirtyNumber; ```
target code: private double cleanNumber ( double dirtyNumber ) { return dirtyNumber < 1 ? 0 : dirtyNumber ; }
response: private double cleanNumber(double dirtyNumber) { <START> <END> return dirtyNumber < 1 ? 0 : dirtyNumber; }

sample: 1242
buggy_code: public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); <END> }
code_review: Same here: The new flag `withAttempts` is not passed (used) the `paymentProcessor#getAccountPayments`
target code: public Pagination < Payment > getPayments ( final Long offset , final Long limit , final String pluginName , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getPayments ( offset , limit , pluginName , withPluginInfo , withAttempts , properties , tenantContext , internalCallContextFactory . createInternalTenantContext ( tenantContext ) ) ; }
response: public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); <END> }

sample: 1243
buggy_code: <START> private static Map<String, String> readMessagesFromBundle() { <END> try { ResourceBundle bundle = ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME); Map<String, String> messages = new HashMap<String, String>(); for (String key : bundle.keySet()) { messages.put(key, bundle.getString(key)); } return messages; } catch (MissingResourceException e) { log.error("Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME); throw new ApplicationException(e); } }
code_review: why do you need to convert the bundle to a map, instead of using it directly?
target code: private static ResourceBundle readMessagesFromBundle ( ) { try { return ResourceBundle . getBundle ( APP_ERRORS_MESSAGES_FILE_NAME ) ; } catch ( MissingResourceException e ) { log . error ( "Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME ) ; throw new ApplicationException ( e ) ; } }
response: <START> private static ResourceBundle readMessagesFromBundle() { <END> try { return ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME); } catch (MissingResourceException e) { log.error("Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME); throw new ApplicationException(e); } }

sample: 1244
buggy_code: public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; <START> if (getClass() != obj.getClass()) return false; <END> BigFraction otherValue = ((ILScore)obj).getValue(); return this.value.equals(otherValue); }
code_review: Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
target code: public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; BigFraction otherValue = ( ( ILScore ) obj ) . getValue ( ) ; return this . value . equals ( otherValue ) ; }
response: public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; BigFraction otherValue = ((ILScore)obj).getValue(); return this.value.equals(otherValue); }

sample: 1245
buggy_code: private boolean isValidReviewer(Account member, ChangeControl control) { if (member.isActive()) { IdentifiedUser user = identifiedUserFactory.create(member.getId()); // Does not account for draft status as a user might want to let a // reviewer see a draft. <START> if (control.forUser(user).isRefVisible()) { return true; } <END> } return false; }
code_review: [optional] this could be shortened to: return control.forUser(user).isRefVisible();
target code: private boolean isValidReviewer ( Account member , ChangeControl control ) { if ( member . isActive ( ) ) { IdentifiedUser user = identifiedUserFactory . create ( member . getId ( ) ) ; // Does not account for draft status as a user might want to let a // reviewer see a draft . return control . forUser ( user ) . isRefVisible ( ) ; } return false ; }
response: private boolean isValidReviewer(Account member, ChangeControl control) { if (member.isActive()) { IdentifiedUser user = identifiedUserFactory.create(member.getId()); // Does not account for draft status as a user might want to let a // reviewer see a draft. <START> return control.forUser(user).isRefVisible(); <END> } return false; }

sample: 1246
buggy_code: private boolean support( ValueGroup[] valueGroups ) { <START> return valueGroups.length == 1 && ValueGroup.NUMBER.equals( valueGroups[0] ); <END> }
code_review: please use == for enum comparisons like its done 2 lines above
target code: private boolean support ( ValueGroup [ ] valueGroups ) { return valueGroups . length == 1 && valueGroups [ 0 ] == ValueGroup . NUMBER ; }
response: private boolean support( ValueGroup[] valueGroups ) { <START> return valueGroups.length == 1 && ValueGroup.NUMBER == valueGroups[0]; <END> }

sample: 1247
buggy_code: <START> public String getConfigFile() <END> { return configFile; }
code_review: You can make this file `File`
target code: public File getConfigFile ( ) { return configFile ; }
response: <START> public File getConfigFile() <END> { return configFile; }

sample: 1248
buggy_code: <START> void close() { <END> writeQueue.add(WriteOperation.SHUTDOWN); writerService.shutdown(); }
code_review: Probably won't be used, but you should implement AutoCloseable, since you implement close() anyway.
target code: public void close ( ) { writeQueue . add ( WriteOperation . SHUTDOWN ) ; writerService . shutdown ( ) ; }
response: <START> void close() throws IOException { <END> writeQueue.add(WriteOperation.SHUTDOWN); writerService.shutdown(); }

sample: 1249
buggy_code: private void completeInner() { // A group is removed, so check if we need to call `unsubscribe` if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) { // It means `groups.isEmpty() && child.isUnsubscribed()` is true unsubscribe(); } // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { <END> // completionEmitted ensures we only emit onCompleted once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onCompleted(); } } } }
code_review: Wouldn't this be an `if/else`? If we just `unsubscribed` in the previous lines I don't think we should ever go through this flow.
target code: private void completeInner ( ) { // A group is removed , so check if we need to call `unsubscribe` if ( WIP_FOR_UNSUBSCRIBE_UPDATER . decrementAndGet ( this ) == 0 ) { // It means `groups . isEmpty ( ) && child . isUnsubscribed ( ) ` is true unsubscribe ( ) ; } else if ( groups . isEmpty ( ) && terminated == TERMINATED_WITH_COMPLETED ) { // if we have no outstanding groups ( all completed or unsubscribe ) and terminated on outer // completionEmitted ensures we only emit onCompleted once if ( COMPLETION_EMITTED_UPDATER . compareAndSet ( this , 0 , 1 ) ) { child . onCompleted ( ) ; } } }
response: private void completeInner() { // A group is removed, so check if we need to call `unsubscribe` if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) { // It means `groups.isEmpty() && child.isUnsubscribed()` is true unsubscribe(); } // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { <END> // completionEmitted ensures we only emit onCompleted once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onCompleted(); } } } else { // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_ERROR) { <END> // completionEmitted ensures we only emit onError once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onError(error); } } } } }

sample: 1250
buggy_code: protected boolean startError() { if (errorCount == 0) { <START> logger.error("Found one or more vector errors from " + opName); <END> } errorCount++; if (errorCount >= MAX_ERRORS) { return false; } return true; }
code_review: ```suggestion logger.error("Found one or more vector errors from {}", opName); ```
target code: protected boolean startError ( ) { if ( errorCount == 0 ) { warn ( "Found one or more vector errors from " + opName ) ; } errorCount ++ ; if ( errorCount >= MAX_ERRORS ) { return false ; } return true ; }
response: protected boolean startError() { if (errorCount == 0) { <START> logger.error("Found one or more vector errors from {}", opName); <END> } errorCount++; if (errorCount >= MAX_ERRORS) { return false; } return true; }

sample: 1251
buggy_code: protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) { List<Integer> resultLineNumbers = new ArrayList<>(); Reader reader = null; try { reader = new FileReader(fileName); resultLineNumbers = grep(reader, regexp, resultLines); }catch (IOException e) { e.printStackTrace(); } finally { <START> closeQuietly(reader); <END> } return resultLineNumbers; }
code_review: We use Java7, so you should use the try-with-resources feature.
target code: protected static List < Integer > grep ( File fileName , String regexp , List < String > resultLines ) { List < Integer > resultLineNumbers = new ArrayList < > ( ) ; try ( Reader reader = new FileReader ( fileName ) ) { resultLineNumbers = grep ( reader , regexp , resultLines ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return resultLineNumbers ; }
response: protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) { List<Integer> resultLineNumbers = new ArrayList<>(); try (Reader reader = new FileReader(fileName)) { resultLineNumbers = grep(reader, regexp, resultLines); }catch (IOException e) { e.printStackTrace(); } return resultLineNumbers; }

sample: 1252
buggy_code: private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) { <START> Intent launchIntent = new Intent(INTENT_ACTION); <END> launchIntent.putExtra(Intents.EXTRA_NAME, destName); launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode); launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude()); launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude()); activity.startService(launchIntent); }
code_review: Missing `final` (was indicated on the previous patch as well).
target code: private static void navigate ( final Activity activity , final String destName , final String destCode , final Geopoint coords ) { final Intent launchIntent = new Intent ( INTENT_ACTION ) ; launchIntent . putExtra ( Intents . EXTRA_NAME , destName ) . putExtra ( Intents . EXTRA_GEOCODE , destCode ) . putExtra ( Intents . EXTRA_LATITUDE , coords . getLatitude ( ) ) . putExtra ( Intents . EXTRA_LONGITUDE , coords . getLongitude ( ) ) ; activity . startService ( launchIntent ) ; }
response: private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) { <START> final Intent launchIntent = new Intent(INTENT_ACTION); <END> launchIntent.putExtra(Intents.EXTRA_NAME, destName); launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode); launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude()); launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude()); activity.startService(launchIntent); }

sample: 1253
buggy_code: public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) { <START> Preconditions.checkNotNull(serverContent, <END> "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); }
code_review: static import
target code: public TestMediaWikiApiImageFetchingStrategy ( Map < String , String > serverContent ) { checkNotNull ( serverContent , "Please specify some server content for images used during the tests . See : TestMediaWikiApiImageFetchingStrategy#serverContent" ) ; this . serverContent = ImmutableMap . copyOf ( serverContent ) ; }
response: public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) { <START> checkNotNull(serverContent, <END> "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); }

sample: 1254
buggy_code: private static boolean shouldCreateMyHandler(PsiElement element) { if (element instanceof LeafPsiElement) { LeafPsiElement leaf = (LeafPsiElement)element; return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf); } <START> else { <END> return false; } }
code_review: A redundant else statement
target code: private static boolean shouldCreateMyHandler ( PsiElement element ) { if ( element instanceof LeafPsiElement ) { LeafPsiElement leaf = ( LeafPsiElement ) element ; return leaf . getElementType ( ) == GoTypes . RETURN || leaf . getElementType ( ) == GoTypes . FUNC || isPanicCall ( leaf ) ; } return false ; }
response: private static boolean shouldCreateMyHandler(PsiElement element) { if (element instanceof LeafPsiElement) { LeafPsiElement leaf = (LeafPsiElement)element; return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf); } <START> return false; <END> }

sample: 1255
buggy_code: <START> private void cancelRxCommands() { <END> for (CommandHandle commandHandle : fRxCommands.values()) { if (commandHandle.getRequestMonitor() == null) continue; commandHandle.getRequestMonitor().setStatus(genStatus( "Connection is shut down")); //$NON-NLS-1$ commandHandle.getRequestMonitor().done(); } fRxCommands.clear(); }
code_review: Wouldn't it be safer to make this method synchronized?
target code: private synchronized void cancelRxCommands ( ) { for ( CommandHandle commandHandle : fRxCommands . values ( ) ) { if ( commandHandle . getRequestMonitor ( ) == null ) continue ; commandHandle . getRequestMonitor ( ) . setStatus ( genStatus ( "Connection is shut down" ) ) ; // $NON - NLS - 1$ commandHandle . getRequestMonitor ( ) . done ( ) ; } fRxCommands . clear ( ) ; }
response: <START> private synchronized void cancelRxCommands() { <END> for (CommandHandle commandHandle : fRxCommands.values()) { if (commandHandle.getRequestMonitor() == null) continue; commandHandle.getRequestMonitor().setStatus(genStatus( "Connection is shut down")); //$NON-NLS-1$ commandHandle.getRequestMonitor().done(); } fRxCommands.clear(); }

sample: 1256
buggy_code: private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores ) { Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService ); LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE; return new Supplier<StorageStatement>() { @Override public StorageStatement get() { return new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService, allocateCommandCreationContext() ); } <START> }; <END> }
code_review: No need to expand the lambda
target code: private Supplier < StorageStatement > storeStatementSupplier ( NeoStores neoStores ) { Supplier < IndexReaderFactory > indexReaderFactory = ( ) - > new IndexReaderFactory . Caching ( indexingService ) ; LockService lockService = takePropertyReadLocks ? this . lockService : NO_LOCK_SERVICE ; return ( ) - > new StoreStatement ( neoStores , indexReaderFactory , labelScanStore : : newReader , lockService , allocateCommandCreationContext ( ) ) ; }
response: private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores ) { Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService ); LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE; return () -> new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService, allocateCommandCreationContext() ); }

sample: 1257
buggy_code: <START> public static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { <END> byte[] byteArr = new byte[(boolArr.length + 7) / 8]; for (int i = 0; i < byteArr.length; i++) { byteArr[i] = readByte(boolArr, 8 * i); } return byteArr; }
code_review: Can be package-private?
target code: static byte [ ] convertBoolArrayToByteArray ( boolean [ ] boolArr ) { byte [ ] byteArr = new byte [ ( boolArr . length + 7 ) / 8 ] ; for ( int i = 0 ; i < byteArr . length ; i ++ ) { byteArr [ i ] = readByte ( boolArr , 8 * i ) ; } return byteArr ; }
response: <START> static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { <END> byte[] byteArr = new byte[(boolArr.length + 7) / 8]; for (int i = 0; i < byteArr.length; i++) { byteArr[i] = readByte(boolArr, 8 * i); } return byteArr; }

sample: 1258
buggy_code: public void all_composed_assertions_should_pass() { SoftAssertions delegate = new SoftAssertions(); delegate.assertThat(1).isEqualTo(1); delegate.assertAll(); softly.assertThat(1).isEqualTo(1); <START> softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 2); <END> softly.assertAlso(delegate); softly.assertAll(); assertThat(softly.wasSuccess()).isTrue(); }
code_review: Minor: use AssertJ `org.assertj.core.util.List.list` and static import for readability.
target code: public void all_composed_assertions_should_pass ( ) { // GIVEN SoftAssertions delegate = new SoftAssertions ( ) ; delegate . assertThat ( 1 ) . isEqualTo ( 1 ) ; delegate . assertAll ( ) ; softly . assertThat ( 1 ) . isEqualTo ( 1 ) ; softly . assertThat ( list ( 1 , 2 ) ) . containsOnly ( 1 , 2 ) ; // WHEN softly . assertAlso ( delegate ) ; softly . assertAll ( ) ; // THEN assertThat ( softly . wasSuccess ( ) ) . isTrue ( ) ; }
response: public void all_composed_assertions_should_pass() { SoftAssertions delegate = new SoftAssertions(); delegate.assertThat(1).isEqualTo(1); delegate.assertAll(); softly.assertThat(1).isEqualTo(1); <START> softly.assertThat(list(1, 2)).containsOnly(1, 2); <END> softly.assertAlso(delegate); softly.assertAll(); assertThat(softly.wasSuccess()).isTrue(); }

sample: 1259
buggy_code: public void viewInfoUpdated() { <START> this.reinitialize(); <END> }
code_review: * Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
target code: public void viewInfoUpdated ( ) { reinitialize ( ) ; }
response: public void viewInfoUpdated() { <START> super.reinitialize(); <END> }

sample: 1260
buggy_code: <START> public JSONPointer(List<String> refTokens) { <END> this.refTokens = refTokens; }
code_review: This should either be a **protected/private/or default** constructor, and the **List** should be copied so the Pointer can't be modified outside of the class. ``` java this.refTokens = refTokens.clone(); ``` as it is now, I could do this: ``` java Builder b = JSONPointer.builder().append("key1"); JSONPointer jp1 = b.build(); b.append("key2"); JSONPointer jp2 = b.build(); if(jp1.toString().equals(jp2.toString()){ throw new Exception("Oops, my pointers are sharing a backing array"); } ```
target code: public JSONPointer ( List < String > refTokens ) { this . refTokens = new ArrayList < String > ( refTokens ) ; }
response: <START> public JSONPointer(List<String> refTokens) { <END> this.refTokens = refTokens.clone(); }

sample: 1261
buggy_code: public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); <START> mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); <END> mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = ""; mFloppyPath = ""; mRunAndPause = false; _diskSize = 0; }
code_review: coudl be just ArrayList since now it is imported ^^ vv
target code: public VM ( ) { mVmStatic = new VmStatic ( ) ; mVmDynamic = new VmDynamic ( ) ; mVmStatistics = new VmStatistics ( ) ; mVmStatic . setImages ( new ArrayList < DiskImage > ( ) ) ; mVmStatic . setInterfaces ( new ArrayList < VmNetworkInterface > ( ) ) ; mDiskMap = new java . util . HashMap < String , DiskImage > ( ) ; mCdPath = "" ; mFloppyPath = "" ; mRunAndPause = false ; _diskSize = 0 ; }
response: public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); <START> mVmStatic.setImages(new ArrayList<DiskImage>()); <END> mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = ""; mFloppyPath = ""; mRunAndPause = false; _diskSize = 0; }

sample: 1262
buggy_code: <START> long consumerLag() { <END> return consumerLag; }
code_review: Would suggest to make it `private`.
target code: private long consumerLag ( ) { return consumerLag ; }
response: <START> private long consumerLag() { <END> return consumerLag; }

sample: 1263
buggy_code: public RegexGroupFilter(final int groupIdx) { if (groupIdx < 1) <START> throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, groupIdx)); <END> this.groupIdx = groupIdx - 1; }
code_review: In most other places we suppress boxing warnings by manually boxing in the code with Integer.valueOf() around the expression. This is especially true in MessageFormat.format invocations, which are very common in our error paths. I think that is the general approach preferred within JGit.
target code: public RegexGroupFilter ( final int groupIdx ) { if ( groupIdx < 1 ) throw new IllegalArgumentException ( MessageFormat . format ( HttpServerText . get ( ) . invalidIndex , valueOf ( groupIdx ) ) ) ; this . groupIdx = groupIdx - 1 ; }
response: public RegexGroupFilter(final int groupIdx) { if (groupIdx < 1) <START> throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, Integer.valueOf(groupIdx))); <END> this.groupIdx = groupIdx - 1; }

sample: 1264
buggy_code: public void testChunkFillingBlobSizeMultipleOfChunkSize() throws Exception { <START> blobSize = chunkSize * random.nextInt(10) + 1; <END> fillChunksAndAssertSuccess(); }
code_review: missing braces ? `blobSize` can end up to be 1 if `random.nextInt(10)` returns 0.
target code: public void testChunkFillingBlobSizeMultipleOfChunkSize ( ) throws Exception { blobSize = chunkSize * ( random . nextInt ( 10 ) + 1 ) ; fillChunksAndAssertSuccess ( ) ; }
response: public void testChunkFillingBlobSizeMultipleOfChunkSize() throws Exception { <START> blobSize = chunkSize * (random.nextInt(10) + 1); <END> fillChunksAndAssertSuccess(); }

sample: 1265
buggy_code: <START> EapAkaAttributeFactory() <END> {}
code_review: Suggest protected to signal that this is for the subclass
target code: protected EapAkaAttributeFactory ( ) { }
response: <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory()

sample: 1266
buggy_code: public byte[] toByteArray() { <START> return ByteBuffer.allocate(8).putLong(valueLong).array(); <END> }
code_review: I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file. This method was more for string, structs, etc. that we want to serialize.
target code: public byte [ ] toByteArray ( ) { return null ; }
response: public byte[] toByteArray() { <START> return null; <END> }

sample: 1267
buggy_code: public String getModeName() { String header = getHeader(); <START> return header.substring(0, header.indexOf(' ')); <END> }
code_review: there is no other way of getting article name?
target code: private String getModeName ( ) { String header = getHeader ( ) ; return header . substring ( 0 , header . indexOf ( ' ' ) ) ; }
response: public String getModeName() { String header = getHeader(); <START> return header.substring(0, header.indexOf(' ')); <END> }

sample: 1268
buggy_code: public int hashCode() { int result = bitSet; result = 31 * result + bitSet; <START> return result; <END> }
code_review: @vilchik-elena Why not simply returning `bitSet`?
target code: public int hashCode ( ) { return bitSet ; }
response: public int hashCode() { int result = bitSet; result = 31 * result + bitSet; <START> return bitSet; <END> }

sample: 1269
buggy_code: void setUnresolvedCompact(boolean unresolvedCompact) { this.unresolvedCompact = unresolvedCompact; if (outer != null) { <START> outer.setUnresolvedCompact(true); <END> } }
code_review: Not required
target code: void setUnresolvedCompact ( boolean unresolvedCompact ) { this . unresolvedCompact = unresolvedCompact ; }
response: void setUnresolvedCompact(boolean unresolvedCompact) { this.unresolvedCompact = unresolvedCompact; if (outer != null) { outer.setUnresolvedCompact(true); } }

sample: 1270
buggy_code: public static void afterClass() throws Exception { if (sLocalAlluxioJobCluster != null) { sLocalAlluxioJobCluster.stop(); } <START> sFileSystem.close(); <END> }
code_review: hrmmm, is this required? Will this happen already with the cluster teardown? And, is there redundant closing with the `after()` call?
target code: public static void afterClass ( ) throws Exception { if ( sLocalAlluxioJobCluster != null ) { sLocalAlluxioJobCluster . stop ( ) ; } }
response: public static void afterClass() throws Exception { if (sLocalAlluxioJobCluster != null) { sLocalAlluxioJobCluster.stop(); } <START> sFileSystem.close(); <END> }

sample: 1271
buggy_code: public void testTrimLongSuffix() throws Exception { <START> String longValue = "12345"; <END> assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "l")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "L")).isEqualTo(longValue); }
code_review: What If I give the empty string as an input of that method ?
target code: public void testTrimLongSuffix ( ) throws Exception { assertThat ( LiteralUtils . trimLongSuffix ( null ) ) . isEqualTo ( null ) ; assertThat ( LiteralUtils . trimLongSuffix ( "" ) ) . isEqualTo ( "" ) ; String longValue = "12345" ; assertThat ( LiteralUtils . trimLongSuffix ( longValue ) ) . isEqualTo ( longValue ) ; assertThat ( LiteralUtils . trimLongSuffix ( longValue + "l" ) ) . isEqualTo ( longValue ) ; assertThat ( LiteralUtils . trimLongSuffix ( longValue + "L" ) ) . isEqualTo ( longValue ) ; }
response: public void testTrimLongSuffix() throws Exception { <START> String longValue = "12345"; <END> assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "l")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "L")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix("")).isEqualTo(""); }

sample: 1272
buggy_code: public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> ret.put(node, null); return ret; }
code_review: spell out ret
target code: public Map < TableScanNode , Void > visitTableScan ( TableScanNode node , Void context ) { Map < TableScanNode , Void > result = new IdentityHashMap < > ( ) ; result . put ( node , null ) ; return result ; }
response: public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> result = new IdentityHashMap<>(); <END> result.put(node, null); return result; }

sample: 1273
buggy_code: public int getStreamIndex() { <START> return streamIndex; <END> }
code_review: should not be this private?
target code: private int getStreamIndex ( ) { return streamIndex ; }
response: public int getStreamIndex() { <START> return this.streamIndex; <END> }

sample: 1274
buggy_code: public Void call() throws IOException { if (task == null) { throw new IOException("The callable " + this + " has been serialized somehow, but it is actually not serializable"); } try { return task.call(); <START> } catch (Exception ex) { <END> if (ex instanceof IOException) { throw (IOException)ex; } throw new IOException(ex); } }
code_review: simpler: ``` } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e); } ```
target code: public Void call ( ) throws IOException { if ( task == null ) { throw new IOException ( "The callable " + this + " has been serialized somehow , but it is actually not serializable" ) ; } try { return task . call ( ) ; } catch ( IOException ex ) { throw ex ; } catch ( Exception ex ) { throw new IOException ( ex ) ; } }
response: public Void call() throws IOException { if (task == null) { throw new IOException("The callable " + this + " has been serialized somehow, but it is actually not serializable"); } try { return task.call(); <START> } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e); } <END> }

sample: 1275
buggy_code: public static File task(File projectDir, String dstName) throws IOException { File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName)); try { if (projectDir.renameTo(dstDir) && XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) { return dstDir; } else { throw new IOException("Cannot rename project directory " + projectDir.getAbsolutePath() + " to " + dstName); } } catch (IOException e) { <START> throw e; <END> } }
code_review: please remove the `try { .. } catch ( .. )` block altogether now.
target code: public static File task ( File projectDir , String dstName ) throws IOException { File dstDir = new File ( projectDir . getParent ( ) , FileMetaDataExtractor . encodeSpecialCharsForFileSystem ( dstName ) ) ; if ( projectDir . renameTo ( dstDir ) && XstreamSerializer . renameProject ( new File ( dstDir , CODE_XML_FILE_NAME ) , dstName ) ) { return dstDir ; } else { throw new IOException ( "Cannot rename project directory " + projectDir . getAbsolutePath ( ) + " to " + dstName ) ; } }
response: public static File task(File projectDir, String dstName) throws IOException { File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName)); if (projectDir.renameTo(dstDir) && XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) { return dstDir; } else { throw new IOException("Cannot rename project directory " + projectDir.getAbsolutePath() + " to " + dstName); } }

sample: 1276
buggy_code: private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) { operation.setStatus(StockOperationStatus.NEW); <START> IStockOperationType operationType = WellKnownOperationTypes.getAdjustment(); <END> operation.setInstanceType(operationType); Stockroom stockroom; stockroom = delegate.getStockroom(); operation.setSource(stockroom); operation.setOperationNumber(delegate.getOperationNumber()); Date dNow = new Date(); operation.setOperationDate(dNow); operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList())); return operation; }
code_review: Remove these extra variables that aren't used except in a setter.
target code: private StockOperation createOperation ( StockOperation operation , InventoryStockTake delegate ) { operation . setStatus ( StockOperationStatus . NEW ) ; IStockOperationType operationType = WellKnownOperationTypes . getAdjustment ( ) ; operation . setInstanceType ( operationType ) ; Stockroom stockroom = delegate . getStockroom ( ) ; operation . setSource ( stockroom ) ; operation . setOperationNumber ( delegate . getOperationNumber ( ) ) ; operation . setOperationDate ( new Date ( ) ) ; operation . setItems ( createOperationsItemSet ( operation , delegate . getItemStockSummaryList ( ) ) ) ; return operation ; }
response: private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) { operation.setStatus(StockOperationStatus.NEW); <START> operation.setInstanceType(WellKnownOperationTypes.getAdjustment()); <END> Stockroom stockroom; stockroom = delegate.getStockroom(); operation.setSource(stockroom); operation.setOperationNumber(delegate.getOperationNumber()); Date dNow = new Date(); operation.setOperationDate(dNow); operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList())); return operation; }

sample: 1277
buggy_code: <START> public MarshallingResponseBuilder messages(List<MarshallingMessage> messages) { <END> this.messages.addAll(messages); return this; }
code_review: not sure if there's a reason for removing the parametrized type MarshallingResponseBuilder<T>, see that when setting the messages you loose the type. The other methods state, addMessage, and resout has the type.
target code: public MarshallingResponseBuilder < T > messages ( List < MarshallingMessage > messages ) { this . messages . addAll ( messages ) ; return this ; }
response: <START> public MarshallingResponseBuilder<T> messages(List<MarshallingMessage> messages) { <END> this.messages.addAll(messages); return this; }

sample: 1278
buggy_code: <START> long getTokenCount() { <END> return tokens.get(); }
code_review: nit: I think we generally prefer to explicitly state the access modifiers.
target code: protected long getTokenCount ( ) { return tokens . get ( ) ; }
response: <START> public long getTokenCount() { <END> return tokens.get(); }

sample: 1279
buggy_code: public V getOrFill(K key, Callable<V> callable) { try { return callable.call() ; } catch (Exception e) { <START> e.printStackTrace(); <END> return null; } }
code_review: `printStackTrace()`? Isn't it better to use a logger?
target code: public V getOrFill ( K key , Callable < V > callable ) { try { return callable . call ( ) ; } catch ( Exception e ) { return null ; } }
response: public V getOrFill(K key, Callable<V> callable) { try { return callable.call() ; } catch (Exception e) { <START> logger.error("Error while filling the cache", e); <END> return null; } }

sample: 1280
buggy_code: void setUpHomeMenuIcon() { drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() <START> && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? <END> VISIBLE : GONE); }
code_review: This is too much specific logic that is spilling over into a very general function. The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does.
target code: void setUpHomeMenuIcon ( ) { drawerIconDot . setVisibility ( AccountUtil . isLoggedIn ( ) && Prefs . showActionFeedIndicator ( ) && ReleaseUtil . isPreBetaRelease ( ) ? VISIBLE : GONE ) ; }
response: void setUpHomeMenuIcon() { drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() <START> && ReleaseUtil.isPreBetaRelease() && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? <END> VISIBLE : GONE); }

sample: 1281
buggy_code: public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) { final ConfigValues configValue = getMaxMemConfigValueByOsId(osId); return Config.<Integer>getValue( configValue, <START> (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue() <END> ); }
code_review: Please remove unnecessary brackets: return Config.<Integer>getValue( configValue, compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue()
target code: public static int maxMemorySizeWithHotplugInMb ( int osId , Version compatibilityVersion ) { final ConfigValues configValue = getMaxMemConfigValueByOsId ( osId ) ; return Config . < Integer > getValue ( configValue , compatibilityVersion != null ? compatibilityVersion . getValue ( ) : Version . getLast ( ) . getValue ( ) ) ; }
response: public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) { final ConfigValues configValue = getMaxMemConfigValueByOsId(osId); return Config.<Integer>getValue( configValue, <START> compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue() <END> ); }

sample: 1282
buggy_code: public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel("Default properties will be used. Exception while properties retrieving: " + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; <START> updateTagFilter(); <END> updatePlace(place); } }); }
code_review: this is incorrect place for command
target code: public void getPropertiesUpdatePlace ( final TrendsPlace place ) { CommonDataService . Async . getInstance ( ) . getWebClientProperties ( new AsyncCallback < WebClientProperties > ( ) { @Override public void onFailure ( Throwable caught ) { new ExceptionPanel ( "Default properties will be used . Exception while properties retrieving : " + caught . getMessage ( ) ) ; updatePlace ( place ) ; } @Override public void onSuccess ( WebClientProperties result ) { webClientProperties = result ; updatePlace ( place ) ; } } ) ; }
response: public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel("Default properties will be used. Exception while properties retrieving: " + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; updatePlace(place); } }); }

sample: 1283
buggy_code: Context prepareDefaultContext(boolean parseAsFlume) { // Prepares a default context with Kafka Server Properties Context context = new Context(); context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl()); context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume)); <START> context.put("offsets.topic.replication.factor", "1"); <END> context.put(TOPIC_CONFIG, topic); return context; }
code_review: What does this change bring? Did we need this to get the test working?
target code: Context prepareDefaultContext ( boolean parseAsFlume ) { // Prepares a default context with Kafka Server Properties Context context = new Context ( ) ; context . put ( BOOTSTRAP_SERVERS_CONFIG , testUtil . getKafkaServerUrl ( ) ) ; context . put ( PARSE_AS_FLUME_EVENT , String . valueOf ( parseAsFlume ) ) ; context . put ( TOPIC_CONFIG , topic ) ; return context ; }
response: Context prepareDefaultContext(boolean parseAsFlume) { // Prepares a default context with Kafka Server Properties Context context = new Context(); context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl()); context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume)); context.put(TOPIC_CONFIG, topic); return context; }

sample: 1284
buggy_code: private String getDatacenter(InetAddressAndPort endpoint) { if (peersA.contains(endpoint)) return "datacenterA"; if (peersB.contains(endpoint)) return "datacenterB"; else if (peersC.contains(endpoint)) return "datacenterC"; <START> return "NA"; <END> }
code_review: Should probably return null
target code: private String getDatacenter ( InetAddressAndPort endpoint ) { if ( peersA . contains ( endpoint ) ) return "datacenterA" ; if ( peersB . contains ( endpoint ) ) return "datacenterB" ; else if ( peersC . contains ( endpoint ) ) return "datacenterC" ; return null ; }
response: private String getDatacenter(InetAddressAndPort endpoint) { if (peersA.contains(endpoint)) return "datacenterA"; if (peersB.contains(endpoint)) return "datacenterB"; else if (peersC.contains(endpoint)) return "datacenterC"; <START> return null; <END> }

sample: 1285
buggy_code: private DateTimeFormatter getFormatter(){ switch (this){ case days: return DateTimeFormat.forPattern("yyyy-MM-dd"); case months: return DateTimeFormat.forPattern("yyyy/MM"); case weeks: return DateTimeFormat.forPattern("yyyy/ww"); case years: return DateTimeFormat.forPattern("yyyy"); case quarters: // has to be extended by the calling function return DateTimeFormat.forPattern("yyyy"); case simpleSum: <START> break; <END> } return null; }
code_review: Constant simpleSum could even removed as this constant is never used outside this class.
target code: private DateTimeFormatter getFormatter ( ) { switch ( this ) { case days : return DateTimeFormat . forPattern ( "yyyy - MM - dd" ) ; case months : return DateTimeFormat . forPattern ( "yyyy / MM" ) ; case weeks : return DateTimeFormat . forPattern ( "yyyy / ww" ) ; case years : return DateTimeFormat . forPattern ( "yyyy" ) ; case quarters : // has to be extended by the calling function return DateTimeFormat . forPattern ( "yyyy" ) ; } return null ; }
response: private DateTimeFormatter getFormatter(){ switch (this){ case days: return DateTimeFormat.forPattern("yyyy-MM-dd"); case months: return DateTimeFormat.forPattern("yyyy/MM"); case weeks: return DateTimeFormat.forPattern("yyyy/ww"); case years: return DateTimeFormat.forPattern("yyyy"); case quarters: // has to be extended by the calling function return DateTimeFormat.forPattern("yyyy"); <START> break; <END> } return null; }

sample: 1286
buggy_code: public void setDefaultProperties(Map<String, Object> defaultProperties) { <START> this.defaultProperties = new HashMap<>(); <END> for (Object key : Collections.list(defaultProperties.propertyNames())) { this.defaultProperties.put((String) key, defaultProperties.get(key)); } }
code_review: I think this could be a one liner: ```java this.defaultProperties = new HashMap<>(defaultProperties); ```
target code: public void setDefaultProperties ( Map < String , Object > defaultProperties ) { this . defaultProperties = new HashMap < > ( defaultProperties ) ; }
response: public void setDefaultProperties(Map<String, Object> defaultProperties) { <START> this.defaultProperties = new HashMap<>(defaultProperties); <END> }

sample: 1287
buggy_code: <START> protected <END> MapSqlParameterSource createVnodeToPnodeParametersMapper( Integer pinnedIndex, Guid vNodeId) { return getCustomMapSqlParameterSource() .addValue("id", Guid.newGuid()) .addValue("vm_numa_node_id", vNodeId) .addValue("vds_numa_node_index", pinnedIndex); }
code_review: Can this be private?
target code: private MapSqlParameterSource createVnodeToPnodeParametersMapper ( Integer pinnedIndex , Guid vNodeId ) { return getCustomMapSqlParameterSource ( ) . addValue ( "id" , Guid . newGuid ( ) ) . addValue ( "vm_numa_node_id" , vNodeId ) . addValue ( "vds_numa_node_index" , pinnedIndex ) ; }
response: <START> private <END> MapSqlParameterSource createVnodeToPnodeParametersMapper( Integer pinnedIndex, Guid vNodeId) { return getCustomMapSqlParameterSource() .addValue("id", Guid.newGuid()) .addValue("vm_numa_node_id", vNodeId) .addValue("vds_numa_node_index", pinnedIndex); }

sample: 1288
buggy_code: public String read(String key) { String data = dataManager.read(key); <START> return (data != null) ? encode(cryptoBox.decrypt(iv, decode(data))) : data; <END> }
code_review: I would flip this for clarity: `return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data));`
target code: public String read ( String key ) { String data = dataManager . read ( key ) ; return ( data == null ) ? null : encode ( cryptoBox . decrypt ( iv , decode ( data ) ) ) ; }
response: public String read(String key) { String data = dataManager.read(key); <START> return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data)); <END> }

sample: 1289
buggy_code: <START> public void setUp() throws Exception { <END> super.init(); }
code_review: `super.init()` method never throw an exception.
target code: public void setUp ( ) { super . init ( ) ; }
response: <START> public void setUp() { <END> super.init(); }

sample: 1290
buggy_code: public S indexNullAs(F indexNullAs) { <START> indexNullAsValue = Optional.of( indexNullAs ); <END> return thisAsS(); }
code_review: `null` is not an acceptable value for `indexNullAs`. You can use `null` to represent "no value was selected", no need for an Optional.
target code: public S indexNullAs ( F indexNullAs ) { indexNullAsValue = indexNullAs ; return thisAsS ( ) ; }
response: public S indexNullAs(F indexNullAs) { <START> indexNullAsValue = indexNullAs; <END> return thisAsS(); }

sample: 1291
buggy_code: public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> Assert.assertEquals("http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png", extractedGenericImage.getImage()); <END> Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }
code_review: import static Assert.assertEquals()
target code: public void testGenericImageExtraction ( ) { org . atlasapi . media . entity . Series extractedGenericImage = extractor . extract ( seriesWithGenericImage ( ) ) ; Image genericImage = Iterables . getOnlyElement ( extractedGenericImage . getImages ( ) ) ; assertEquals ( "http :/ / ichef . bbci . co . uk / images / ic / 1024x576 / p028s846 . png" , extractedGenericImage . getImage ( ) ) ; assertEquals ( ImageType . GENERIC_IMAGE_CONTENT_ORIGINATOR , genericImage . getType ( ) ) ; }
response: public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> assertEquals("http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png", extractedGenericImage.getImage()); <END> Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }

sample: 1292
buggy_code: void testDescribeInstances() { for (String region : ec2Api.getConfiguredRegions()) { Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region); assertNotNull(allResults); <START> assertTrue(allResults.size() >= 0); <END> } }
code_review: How can a set be of a negative size?
target code: void testDescribeInstances ( ) { for ( String region : ec2Api . getConfiguredRegions ( ) ) { Set < ? extends Reservation < ? extends RunningInstance > > allResults = client . describeInstancesInRegion ( region ) ; assertNotNull ( allResults ) ; } }
response: void testDescribeInstances() { for (String region : ec2Api.getConfiguredRegions()) { Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region); assertNotNull(allResults); <START> assertTrue(allResults.size() >= 0); assertTrue(allResults.size() >= 0); <END> } }

sample: 1293
buggy_code: <START> public static String quoteString(String s) { <END> if (s == null) { return null; } if (!s.matches("^\".*\"$")) { return "\"" + s + "\""; } else { return s; } }
code_review: Package private should always be enough for testing. Use the same package for tests.
target code: static String quoteString ( String s ) { if ( s == null ) { return null ; } if ( ! s . matches ( " ^ \" .* \"$" ) ) { return "\"" + s + "\"" ; } else { return s ; } }
response: <START> String quoteString(String s) { <END> if (s == null) { return null; } if (!s.matches("^\".*\"$")) { return "\"" + s + "\""; } else { return s; } }

sample: 1294
buggy_code: public Object getMin() { if (primitiveType == PrimitiveTypeName.BINARY) { <START> if (originalType == OriginalType.UTF8) { <END> return ((Binary) min).toStringUsingUTF8(); } else { return new String(((Binary) min).getBytes()); } } return min; }
code_review: Had an offline discussion with Aman, we can remove this check and serialize everything using getBytes()
target code: public Object getMin ( ) { if ( primitiveType == PrimitiveTypeName . BINARY && min != null ) { return new String ( ( ( Binary ) min ) . getBytes ( ) ) ; } return min ; }
response: public Object getMin() { if (primitiveType == PrimitiveTypeName.BINARY) { <START> return new String(((Binary) min).getBytes()); <END> } return min; }

sample: 1295
buggy_code: public int hashCode() { <START> int result = name.hashCode(); <END> result = 31 * result + fullName.hashCode(); return result; }
code_review: fullName should be enough here too.
target code: public int hashCode ( ) { return fullName . hashCode ( ) ; }
response: public int hashCode() { <START> int result = fullName.hashCode(); <END> result = 31 * result + fullName.hashCode(); return result; }

sample: 1296
buggy_code: private SocketConfig createSocketConfig(int socketTimeout) { return SocketConfig.custom() .setSoReuseAddress(true) <START> .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) <END> .build(); }
code_review: I think rather than checking `> 0`, it would make things clearer if you had a static value like `DEFAULT_TIMEOUT = -1` and then use that in `createHttpClient` and change these checks to be `socketTimeout != DEFAULT_TIMEOUT`. Or something along those lines.
target code: private SocketConfig createSocketConfig ( int socketTimeout ) { return SocketConfig . custom ( ) . setSoReuseAddress ( true ) . setSoTimeout ( socketTimeout ) . build ( ) ; }
response: private SocketConfig createSocketConfig(int socketTimeout) { return SocketConfig.custom() .setSoReuseAddress(true) <START> .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) <END> .build(); }

sample: 1297
buggy_code: CommentBox(CodeMirror cm, CommentInfo info) { this.cm = cm; CommentRange range = info.range(); if (range != null) { fromTo = FromTo.fromCommentRange(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), <START> Configuration.create().set("className", <END> DiffTable.style.range())); } }
code_review: nit: line break after ( or before ".set" here.
target code: CommentBox ( CodeMirror cm , CommentInfo info ) { this . cm = cm ; CommentRange range = info . range ( ) ; if ( range != null ) { fromTo = FromTo . create ( range ) ; rangeMarker = cm . markText ( fromTo . getFrom ( ) , fromTo . getTo ( ) , Configuration . create ( ) . set ( "className" , DiffTable . style . range ( ) ) ) ; } }
response: CommentBox(CodeMirror cm, CommentInfo info) { this.cm = cm; CommentRange range = info.range(); if (range != null) { fromTo = FromTo.fromCommentRange(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), <START> Configuration.create() .set("className", <END> DiffTable.style.range())); } }

sample: 1298
buggy_code: public void removeTagFromImage(String imageName, String tagToBeRemoved) { selectImage(imageName); new ContextMenu("Remove Tag").select(); String fullTag = ""; Combo combo = new DefaultCombo(); List<String> comboItems = combo.getItems(); for (String item : comboItems) { if (item.contains(tagToBeRemoved)) { fullTag = item; break; } } combo.setSelection(fullTag); <START> ; <END> new FinishButton().click(); }
code_review: This is pretty lonely semicolon :wink:
target code: public void removeTagFromImage ( String imageName , String tagToBeRemoved ) { selectImage ( imageName ) ; new ContextMenu ( "Remove Tag" ) . select ( ) ; String fullTag = "" ; Combo combo = new DefaultCombo ( ) ; List < String > comboItems = combo . getItems ( ) ; for ( String item : comboItems ) { if ( item . contains ( tagToBeRemoved ) ) { fullTag = item ; break ; } } combo . setSelection ( fullTag ) ; new FinishButton ( ) . click ( ) ; }
response: public void removeTagFromImage(String imageName, String tagToBeRemoved) { selectImage(imageName); new ContextMenu("Remove Tag").select(); String fullTag = ""; Combo combo = new DefaultCombo(); List<String> comboItems = combo.getItems(); for (String item : comboItems) { if (item.contains(tagToBeRemoved)) { fullTag = item; break; } } combo.setSelection(fullTag); <START> new OkButton().click(); <END> new FinishButton().click(); }

sample: 1299
buggy_code: public void processOnVmStop(Collection<Guid> vmIds) { for (final Guid vmId : vmIds) { <START> log.infoFormat("process VM {0} that went down", vmId); <END> ThreadPoolUtil.execute(new Runnable() { @Override public void run() { Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext()); } }); } }
code_review: do we really need this log? now that it is a command we should have a log for running a command, no?
target code: public void processOnVmStop ( Collection < Guid > vmIds ) { for ( final Guid vmId : vmIds ) { ThreadPoolUtil . execute ( new Runnable ( ) { @Override public void run ( ) { Backend . getInstance ( ) . runInternalAction ( VdcActionType . ProcessDownVm , new IdParameters ( vmId ) ) ; } } ) ; } }
response: public void processOnVmStop(Collection<Guid> vmIds) { for (final Guid vmId : vmIds) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext()); } }); } }

sample: 1300
buggy_code: public BatchServerInventoryView( final ZkPathsConfig zkPaths, final CuratorFramework curator, final ObjectMapper jsonMapper, final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter ) { super( log, zkPaths.getAnnouncementsPath(), zkPaths.getLiveSegmentsPath(), curator, jsonMapper, new TypeReference<Set<DataSegment>>() { } ); Preconditions.checkNotNull(defaultFilter); <START> this.defaultFilter = defaultFilter; <END> }
code_review: nit: can just do this.defaultFilter = Preconditions.checkNotNull(defaultFilter)
target code: public BatchServerInventoryView ( final ZkPathsConfig zkPaths , final CuratorFramework curator , final ObjectMapper jsonMapper , final Predicate < Pair < DruidServerMetadata , DataSegment > > defaultFilter ) { super ( log , zkPaths . getAnnouncementsPath ( ) , zkPaths . getLiveSegmentsPath ( ) , curator , jsonMapper , new TypeReference < Set < DataSegment > > ( ) { } ) ; this . defaultFilter = Preconditions . checkNotNull ( defaultFilter ) ; }
response: public BatchServerInventoryView( final ZkPathsConfig zkPaths, final CuratorFramework curator, final ObjectMapper jsonMapper, final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter ) { super( log, zkPaths.getAnnouncementsPath(), zkPaths.getLiveSegmentsPath(), curator, jsonMapper, new TypeReference<Set<DataSegment>>() { } ); <START> this.defaultFilter = Preconditions.checkNotNull(defaultFilter); <END> }

sample: 1301
buggy_code: protected void configureEnvironment(final ClusterEnvironment.Builder builder) { <START> Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); <END> jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL); jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule()); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new CouchbaseJacksonModule()); objectMapper.registerModule(new JsonValueModule()); builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper)); }
code_review: Actually I don't think this is how it should work? We do not expose jackson directly to the user, and all the encoding and decoding happens on the spring side and not with the SDK itself.. shouldn't this go into the mapper/converter logic instead?
target code: protected void configureEnvironment ( final ClusterEnvironment . Builder builder ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; objectMapper . registerModule ( new CouchbaseJacksonModule ( ) ) ; objectMapper . registerModule ( new JsonValueModule ( ) ) ; builder . jsonSerializer ( JacksonJsonSerializer . create ( objectMapper ) ) ; }
response: protected void configureEnvironment(final ClusterEnvironment.Builder builder) { <START> Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); <END> jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL); jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule()); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new CouchbaseJacksonModule()); objectMapper.registerModule(new JsonValueModule()); builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper)); }

sample: 1302
buggy_code: public void processLockAcquire() { log.debug("Process lock acquire event"); isLeader = true; // Regardless of the role of this node, on leadership acquisition // we shall query the topology provider to get the most up to date // topologyConfigId, which might have changed during our time as non-leaders // and for which we might have missed the change notification and update it on // the sink manager so the value is cached to filter messages upon receive. fetchTopologyFromClusterManager(); <START> updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); <END> onLeadershipAcquire(); }
code_review: Just doing updateTopologyConfigID is not enough. While process a topology change event, the discovery service does more work refer to processTopologyChangeNotification. While combining two events topology change and leadership change together, it is a bit complex. Would suggest to not call the fetchTopologyFromClusterManager. First, the topology change is a notification API from clusterManager. Even with this call, it will fetch the cached value from clusterManagerAdapter. Second, it just add more complexity and doesn't completely solve the problem.
target code: public void processLockAcquire ( ) { log . debug ( "Process lock acquire event" ) ; isLeader . set ( true ) ; onLeadershipAcquire ( ) ; }
response: public void processLockAcquire() { log.debug("Process lock acquire event"); isLeader = true; // Regardless of the role of this node, on leadership acquisition // we shall query the topology provider to get the most up to date // topologyConfigId, which might have changed during our time as non-leaders // and for which we might have missed the change notification and update it on // the sink manager so the value is cached to filter messages upon receive. <START> updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); <END> onLeadershipAcquire(); }

sample: 1303
buggy_code: public DhcpInfo getDhcpInfo() { enforceAccessPermission(); if (mVerboseLoggingEnabled) { mLog.info("getDhcpInfo uid=%").c(Binder.getCallingUid()).flush(); } <START> DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo(); return dhcpInfo; <END> }
code_review: Normally you just return mClientModeImpl.getSyncDhcpInfo. If you really want to introduce a local make it final.
target code: public DhcpInfo getDhcpInfo ( ) { enforceAccessPermission ( ) ; if ( mVerboseLoggingEnabled ) { mLog . info ( "getDhcpInfo uid = % " ) . c ( Binder . getCallingUid ( ) ) . flush ( ) ; } return mClientModeImpl . syncGetDhcpInfo ( ) ; }
response: public DhcpInfo getDhcpInfo() { enforceAccessPermission(); if (mVerboseLoggingEnabled) { mLog.info("getDhcpInfo uid=%").c(Binder.getCallingUid()).flush(); } <START> final DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo(); return dhcpInfo; <END> }

sample: 1304
buggy_code: public void setUp() throws Exception { <START> MetadataStorageConnectorConfig config = jsonReadWriteRead( <END> "{" + "\"type\" : \"db\",\n" + "\"segmentTable\" : \"segments\"\n" + "}", MetadataStorageConnectorConfig.class ); connector = new TestDerbyConnector( Suppliers.ofInstance(config), Suppliers.ofInstance(tablesConfig) ); }
code_review: why do we use strings here?
target code: public void setUp ( ) throws Exception { connector = new TestDerbyConnector ( Suppliers . ofInstance ( new MetadataStorageConnectorConfig ( ) ) , Suppliers . ofInstance ( tablesConfig ) ) ; }
response: public void setUp() throws Exception { <START> MetadataStorageConnectorConfig config = jsonReadWriteRead( <END> "{" + "\"type\" : \"db\",\n" + "\"segmentTable\" : \"segments\"\n" + "}", MetadataStorageConnectorConfig.class ); connector = new TestDerbyConnector( Suppliers.ofInstance(config), Suppliers.ofInstance(tablesConfig) ); }

sample: 1305
buggy_code: protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException { if (result.healthy) { resp.setStatus(HttpServletResponse.SC_OK); } else { <START> resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); <END> } sendResponse(resp, result.toJson()); }
code_review: You should use `HttpServletResponse.SC_...` everywhere, no need for `HttpStatus` here.
target code: protected void sendHealthCheckResponse ( HttpServletResponse resp , HealthCheckResult result ) throws IOException { if ( result . healthy ) { resp . setStatus ( HttpServletResponse . SC_OK ) ; } else { resp . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; } sendResponse ( resp , result . toJson ( ) ) ; }
response: protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException { if (result.healthy) { resp.setStatus(HttpServletResponse.SC_OK); } else { <START> resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); <END> } sendResponse(resp, result.toJson()); }

sample: 1306
buggy_code: public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) { JsonRpcRequest request = new RequestBuilder("ManagedVolume.attach_volume") .withParameter("vol_id", <START> volumeId) <END> .withParameter("connection_info", connectionInfo) .build(); Map<String, Object> response = new FutureMap(this.client, request); Map<String, Object> info = (Map<String, Object>) response.get("info"); return new DeviceInfoReturn(info); }
code_review: Same for detach
target code: public DeviceInfoReturn attachManagedBlockStorageVolume ( Guid volumeId , Map < String , Object > connectionInfo ) { JsonRpcRequest request = new RequestBuilder ( "ManagedVolume . attach_volume" ) . withParameter ( "vol_id" , volumeId . toString ( ) ) . withParameter ( "connection_info" , connectionInfo ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) ; Map < String , Object > info = ( Map < String , Object > ) response . get ( "info" ) ; return new DeviceInfoReturn ( info ) ; }
response: public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) { JsonRpcRequest request = new RequestBuilder("ManagedVolume.attach_volume") .withParameter("vol_id", volumeId) .withParameter("connection_info", connectionInfo) .build(); Map<String, Object> response = new FutureMap(this.client, request); Map<String, Object> info = (Map<String, Object>) response.get("info"); return new DeviceInfoReturn(info); }

sample: 1307
buggy_code: public static void addHeaders(final HttpMessage httpMessage, final Header... headers) { Validate.notNull(httpMessage, "HttpMessage must not be null"); for (final Header header : headers) { <START> if (header.getName().equals(MantaHttpHeaders.REQUEST_ID)) { <END> continue; } httpMessage.addHeader(header); } }
code_review: As a paranoia sufferer, I would invert the equals to avoid the remote possibility of a NPE: ```java if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) { ```
target code: public static void addHeaders ( final HttpMessage httpMessage , final Header . . . headers ) { Validate . notNull ( httpMessage , "HttpMessage must not be null" ) ; for ( final Header header : headers ) { if ( MantaHttpHeaders . REQUEST_ID . equals ( header . getName ( ) ) ) { continue ; } httpMessage . addHeader ( header ) ; } }
response: public static void addHeaders(final HttpMessage httpMessage, final Header... headers) { Validate.notNull(httpMessage, "HttpMessage must not be null"); for (final Header header : headers) { <START> if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) { <END> continue; } httpMessage.addHeader(header); } }

sample: 1308
buggy_code: public String getServletMapping() { <START> if ("".equals(this.path) || "/".equals(this.path)) { <END> return "/"; } if (this.path.endsWith("/")) { return this.path + "*"; } return this.path + "/*"; }
code_review: `this.path` is initialized to a value so this is not necessary.
target code: public String getServletMapping ( ) { if ( this . path . equals ( "" ) || this . path . equals ( " / " ) ) { return " / " ; } if ( this . path . endsWith ( " / " ) ) { return this . path + " * " ; } return this . path + " /* " ; }
response: public String getServletMapping() { <START> if ("/".equals(this.path)) { <END> return "/"; } if (this.path.endsWith("/")) { return this.path + "*"; } return this.path + "/*"; }

sample: 1309
buggy_code: private static InetAddress toInetAddress(Slice ipAddress) { InetAddress address; try { <START> address = InetAddress.getByAddress(ipAddress.getBytes()); <END> } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Invalid IP address binary: " + ipAddress.toStringUtf8(), e); } return address; }
code_review: Now that this is a standalone function. You can just do `return InetAdress.get...` here, and remove the temporary variable.
target code: private static InetAddress toInetAddress ( Slice ipAddress ) { try { return InetAddress . getByAddress ( ipAddress . getBytes ( ) ) ; } catch ( UnknownHostException e ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , "Invalid IP address binary : " + ipAddress . toStringUtf8 ( ) , e ) ; } }
response: private static InetAddress toInetAddress(Slice ipAddress) { try { <START> return InetAddress.getByAddress(ipAddress.getBytes()); <END> } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Invalid IP address binary: " + ipAddress.toStringUtf8(), e); } }

sample: 1310
buggy_code: public int hashCode() { return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase); <START> } <END>
code_review: EqualsVerifier test please for equals and hashcode
target code: public int hashCode ( ) { return Objects . hash ( sqls , sqlFirehoseDatabaseConnector , foldCase ) ; }
response: public int hashCode() { return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase); <START> }

sample: 1311
buggy_code: protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) { <START> return null; <END> }
code_review: Can we return an empty list here instead?
target code: protected final List < ResultDocument > getSearchResults ( ExecutionContext ctx ) { // This should be called at all throw new IllegalStateException ( ) ; }
response: protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) { <START> return Collections.emptyList(); <END> }

sample: 1312
buggy_code: protected boolean isAppConfiguredInSourceServerXml(String fileName) { <START> boolean bConfigured = false; <END> Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.contains(fileName)) { log.debug("Application configuration is found in server.xml : " + fileName); bConfigured = true; } return bConfigured; }
code_review: Seems like there's a spacing issue here, two spaces instead of 4.
target code: protected boolean isAppConfiguredInSourceServerXml ( String fileName ) { Set < String > locations = getAppConfigLocationsFromSourceServerXml ( ) ; if ( locations . contains ( fileName ) ) { log . debug ( "Application configuration is found in server . xml : " + fileName ) ; return true ; } else { return false ; } }
response: protected boolean isAppConfiguredInSourceServerXml(String fileName) { <START> boolean bConfigured = false; <END> Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.contains(fileName)) { log.debug("Application configuration is found in server.xml : " + fileName); bConfigured = true; } return bConfigured; }

sample: 1313
buggy_code: private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException { <START> log.info("about to reinitialize dc"); <END> DataCenter dataCenter = new DataCenter(); dataCenter.setId(dcId); updateDataCenter(dataCenter); return dataCenter; }
code_review: log.debug ?
target code: private DataCenter reInitializeDataCenter ( String dcId ) throws RuntimeException { log . warn ( "about to reinitialize dc" ) ; DataCenter dataCenter = new DataCenter ( ) ; dataCenter . setId ( dcId ) ; updateDataCenter ( dataCenter ) ; return dataCenter ; }
response: private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException { <START> log.debug("about to reinitialize dc"); <END> DataCenter dataCenter = new DataCenter(); dataCenter.setId(dcId); updateDataCenter(dataCenter); return dataCenter; }

sample: 1314
buggy_code: public void send(Send request) throws IOException { if (!connected) { throw new ClosedChannelException(); } while (!request.isSendComplete()) { request.writeTo(writeChannel); } <START> request.release(); <END> }
code_review: who releases the request if an IOException is thrown?
target code: public void send ( Send request ) throws IOException { try { if ( ! connected ) { throw new ClosedChannelException ( ) ; } while ( ! request . isSendComplete ( ) ) { request . writeTo ( writeChannel ) ; } } finally { request . release ( ) ; } }
response: public void send(Send request) throws IOException { if (!connected) { throw new ClosedChannelException(); } while (!request.isSendComplete()) { request.writeTo(writeChannel); } <START> try { request.release(); } catch (IOException e) { throw e; } <END> }

sample: 1315
buggy_code: public void canParseNamedCaptureGroupsFromPattern() { assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""), hasSize(0)); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("(?<user>.*)"), contains("user")); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)"), <START> containsInAnyOrder("poolName", "poolMember", "poolAddr", "slotNum")); <END> }
code_review: Can we revert this and keep the order deterministic?
target code: public void canParseNamedCaptureGroupsFromPattern ( ) { assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( "" ) , hasSize ( 0 ) ) ; assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( " ( ? < user > .* ) " ) , contains ( "user" ) ) ; assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( "Node / ( ? < poolName > .* ? ) / ( ? < poolMember > \\S + ) address ( ? < poolAddr > \\S + ) monitor status down . .* \\ ( slot ( ? < slotNum > [ 0 - 9 ] + ) \\ ) " ) , contains ( "poolName" , "poolMember" , "poolAddr" , "slotNum" ) ) ; }
response: public void canParseNamedCaptureGroupsFromPattern() { assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""), hasSize(0)); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("(?<user>.*)"), contains("user")); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)"), <START> contains("poolName", "poolMember", "poolAddr", "slotNum")); <END> }

sample: 1316
buggy_code: public void testActivateAppUnknownApp() throws Exception { App app = when(mock(App.class).isActive()).thenReturn(false).getMock(); MvcResult result = mockMvc.perform(post(AppsController.URI + "/id/activate")).andReturn(); <START> assertEquals(result.getResolvedException().getMessage(), "Unknown app 'id'"); <END> }
code_review: I'd then check the exception class plus parameters, not the message that isn't even sent to the user.
target code: public void testActivateAppUnknownApp ( ) throws Exception { App app = when ( mock ( App . class ) . isActive ( ) ) . thenReturn ( false ) . getMock ( ) ; MvcResult result = mockMvc . perform ( post ( AppsController . URI + " / id / activate" ) ) . andReturn ( ) ; throw result . getResolvedException ( ) ; }
response: public void testActivateAppUnknownApp() throws Exception { App app = when(mock(App.class).isActive()).thenReturn(false).getMock(); MvcResult result = mockMvc.perform(post(AppsController.URI + "/id/activate")).andReturn(); <START> assertEquals(result.getResolvedException().getClass(), UnknownAppException.class); <END> }

sample: 1317
buggy_code: public void onReceive(Context ctx, Intent intent) { String action = intent.getAction(); switch (action) { case INSTALL_ACTION: // for play store devices only: // * invoke the receiver and open the page: // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar"` // * invoke the receiver but don't open the app (bad url): // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=gibberish&campaign_id=foo&install_id=bar"` installReferrer(ctx, intent); break; case Intent.ACTION_BOOT_COMPLETED: // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED` recordChannelId(ctx); NotificationPollService.start(ctx.getApplicationContext()); break; <START> default: <END> L.d("action=" + action); break; } }
code_review: Doesn't the InstallReceiver depend on a WikipediaApp instance being created by the system? Since NotificationPollService.start() is already called there, I think this would call it a second time
target code: public void onReceive ( Context ctx , Intent intent ) { String action = intent . getAction ( ) ; switch ( action ) { case INSTALL_ACTION : // for play store devices only : // * invoke the receiver and open the page : // `adb shell am broadcast - a com . android . vending . INSTALL_REFERRER - n org . wikipedia . dev / org . wikipedia . analytics . InstallReceiver -- es "referrer" "referrer_url = https % 3A % 2F % 2Fen . wikipedia . org % 2Fwiki % 2FWombat & campaign_id = foo & install_id = bar"` // * invoke the receiver but don't open the app ( bad url ) : // `adb shell am broadcast - a com . android . vending . INSTALL_REFERRER - n org . wikipedia . dev / org . wikipedia . analytics . InstallReceiver -- es "referrer" "referrer_url = gibberish & campaign_id = foo & install_id = bar"` installReferrer ( ctx , intent ) ; break ; case Intent . ACTION_BOOT_COMPLETED : // `adb shell am broadcast - a android . intent . action . BOOT_COMPLETED` recordChannelId ( ctx ) ; break ; default : L . d ( "action = " + action ) ; break ; } }
response: public void onReceive(Context ctx, Intent intent) { String action = intent.getAction(); switch (action) { case INSTALL_ACTION: // for play store devices only: // * invoke the receiver and open the page: // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar"` // * invoke the receiver but don't open the app (bad url): // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=gibberish&campaign_id=foo&install_id=bar"` installReferrer(ctx, intent); break; case Intent.ACTION_BOOT_COMPLETED: // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED` recordChannelId(ctx); <START> NotificationPollService.start(ctx.getApplicationContext()); <END> break; default: L.d("action=" + action); break; } }

sample: 1318
buggy_code: private String getTokenToUse(String authTokenCredentialId, String token) { if (!StringUtils.isEmpty(authTokenCredentialId)) { <START> StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId, null); <END> if (credentials != null) { logger.fine("Using Integration Token Credential ID."); return credentials.getSecret().getPlainText(); } } logger.fine("Using Integration Token."); return token; }
code_review: can this have an overloaded method please so we don't have to pass null around? ```suggestion StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId); ```
target code: private String getTokenToUse ( String authTokenCredentialId , String token ) { if ( ! StringUtils . isEmpty ( authTokenCredentialId ) ) { StringCredentials credentials = CredentialsObtainer . lookupCredentials ( authTokenCredentialId ) ; if ( credentials != null ) { logger . fine ( "Using Integration Token Credential ID . " ) ; return credentials . getSecret ( ) . getPlainText ( ) ; } } logger . fine ( "Using Integration Token . " ) ; return token ; }
response: private String getTokenToUse(String authTokenCredentialId, String token) { if (!StringUtils.isEmpty(authTokenCredentialId)) { <START> StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId); <END> if (credentials != null) { logger.fine("Using Integration Token Credential ID."); return credentials.getSecret().getPlainText(); } } logger.fine("Using Integration Token."); return token; }

sample: 1319
buggy_code: void onGetBlobError(Exception e, GetBlobOptions options) { <START> if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { <END> onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); } }
code_review: and then you may be able to drop the `options != null` check.
target code: void onGetBlobError ( Exception e , GetBlobOptions options ) { if ( options . getOperationType ( ) == GetBlobOptions . OperationType . BlobInfo ) { onGetBlobInfoError ( e ) ; } else { onGetBlobDataError ( e , options ) ; } }
response: void onGetBlobError(Exception e, GetBlobOptions options) { <START> if (options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { <END> onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); } }

sample: 1320
buggy_code: <START> public void setSelectedChapter(@NonNull Chapter chapter) { <END> if (mSelectedChapter != null) { trackView(); } this.mSelectedChapter = chapter; }
code_review: If you add `@NonNull` here than it's not worth checking the `null` again inside. You should safely assume that the client of the method is fulfilling the non null pre-condition. The IDE will tell the client of the method that a null argument should not be passed. So, either you remove `@NonNull` or remove the check for `!= null` inside.
target code: public void setSelectedChapter ( @NonNull Chapter chapter ) { if ( mSelectedChapter != null ) { trackView ( ) ; } mSelectedChapter = chapter ; }
response: public void setSelectedChapter(@NonNull Chapter chapter) { if (mSelectedChapter != null) { trackView(); } this.mSelectedChapter = chapter; }

sample: 1321
buggy_code: public void open(GenericInputSplit split) throws IOException { super.open(split); <START> if (serializableIter != null) <END> it = serializableIter; else it = this.dataSet.iterator(); }
code_review: we always use parentheses, also for one-line statements.
target code: public void open ( GenericInputSplit split ) throws IOException { super . open ( split ) ; if ( serializableIter != null ) { it = serializableIter ; } else { it = this . dataSet . iterator ( ) ; } }
response: public void open(GenericInputSplit split) throws IOException { super.open(split); <START> if (serializableIter != null) <END> it = serializableIter; else it = this.dataSet.iterator(); }

sample: 1322
buggy_code: @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Check logcat!"); setContentView(tv); printArgs("The", "Quick", "Brown", "Fox"); Log.i("Fibonacci", "fibonacci's 4th number is " + fibonacci(4)); Greeter greeter = new Greeter("Jake"); Log.d("Greeting", greeter.sayHello()); startSleepyThread(); <START> synchronized (Boolean.TRUE){} <END> }
code_review: Can we remove this? I realize what it was for but I don't think it should be kept around in the example.
target code: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; TextView tv = new TextView ( this ) ; tv . setText ( "Check logcat ! " ) ; setContentView ( tv ) ; printArgs ( "The" , "Quick" , "Brown" , "Fox" ) ; Log . i ( "Fibonacci" , "fibonacci's 4th number is " + fibonacci ( 4 ) ) ; Greeter greeter = new Greeter ( "Jake" ) ; Log . d ( "Greeting" , greeter . sayHello ( ) ) ; startSleepyThread ( ) ; }
response: @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Check logcat!"); setContentView(tv); printArgs("The", "Quick", "Brown", "Fox"); Log.i("Fibonacci", "fibonacci's 4th number is " + fibonacci(4)); Greeter greeter = new Greeter("Jake"); Log.d("Greeting", greeter.sayHello()); startSleepyThread(); }

sample: 1323
buggy_code: private ContentValues ensureAfter() { ContentValues values = mAfterContentValues; if (values == null) { values = new ContentValues(); mAfterContentValues = values; // also create mAfterKeys <START> mAfterKeys = new HashSet<>(); <END> } return values; }
code_review: Please remove `mAfterKeys` while you're at it. It was only a workaround for the absence of `ContentValues.keySet()` on Android 2.x. Since we don't support Android 2 any more you can remove it in most places and replace by `mAfterContentValues.keySet()` where it's being read.
target code: private ContentValues ensureAfter ( ) { ContentValues values = mAfterContentValues ; if ( values == null ) { values = new ContentValues ( ) ; mAfterContentValues = values ; } return values ; }
response: private ContentValues ensureAfter() { ContentValues values = mAfterContentValues; if (values == null) { values = new ContentValues(); mAfterContentValues = values; // also create mAfterKeys <START> mAfterKeys = new HashSet<>(); <END> } return values; }

sample: 1324
buggy_code: private Task<? extends Serializable> createDbTask(Database dbObj) { // note that we do not set location - for repl load, we want that auto-created. CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false, <START> updateDbProps(dbObj, context.dumpDirectory, true)); <END> // If it exists, we want this to be an error condition. Repl Load is not intended to replace a // db. // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on. DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc); return TaskFactory.get(work, context.hiveConf); }
code_review: The parameter can bee removed
target code: private Task < ? extends Serializable > createDbTask ( Database dbObj ) { // note that we do not set location - for repl load , we want that auto - created . CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc ( dbObj . getName ( ) , dbObj . getDescription ( ) , null , false , updateDbProps ( dbObj , context . dumpDirectory ) ) ; // If it exists , we want this to be an error condition . Repl Load is not intended to replace a // db . // TODO : we might revisit this in create - drop - recreate cases , needs some thinking on . DDLWork2 work = new DDLWork2 ( new HashSet < > ( ) , new HashSet < > ( ) , createDbDesc ) ; return TaskFactory . get ( work , context . hiveConf ) ; }
response: private Task<? extends Serializable> createDbTask(Database dbObj) { // note that we do not set location - for repl load, we want that auto-created. CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false, <START> updateDbProps(dbObj, context.dumpDirectory); <END> // If it exists, we want this to be an error condition. Repl Load is not intended to replace a // db. // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on. DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc); return TaskFactory.get(work, context.hiveConf); }

sample: 1325
buggy_code: public long writeTo(Write writeChannel) throws IOException { long sizeWritten = 0; ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite); sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite); if(sizeWritten != sizeToWrite) { throw new IOException("Not able to write fully. Expected : " + sizeToWrite + " Actual : " + sizeWritten ); } <START> return sizeWritten; <END> }
code_review: what is the purpose of maxWriteTimeInMs now? how is it being used?
target code: public long writeTo ( Write writeChannel ) throws IOException { ReadableByteChannel readableByteChannel = Channels . newChannel ( streamToWrite ) ; writeChannel . appendFrom ( readableByteChannel , sizeToWrite ) ; return sizeToWrite ; }
response: public long writeTo(Write writeChannel) throws IOException { long sizeWritten = 0; ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite); sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite); if(sizeWritten != sizeToWrite) { throw new IOException("Not able to write fully. Expected : " + sizeToWrite + " Actual : " + sizeWritten ); } <START> return sizeWritten; <END> }

sample: 1326
buggy_code: static void addSnapshotJarToClassPath( File jarFile, Path intermediateClassPath, FileSystem fs, Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory. final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName()); // existing is used to prevent uploading file multiple times in same run. <START> if (!existing.contains(hdfsPath) || !fs.exists(hdfsPath)) { <END> uploadJar(jarFile, hdfsPath, fs); existing.add(hdfsPath); } job.addFileToClassPath(hdfsPath); }
code_review: exists check is not done for SNAPSHOT jars intentionally so that they get updated everytime. SNAPSHOT jars are to be used for testing only and are designed to get updated on each run. Or else there would be no reason for method 'addSnapshotJarToClassPath' to exist. i guess your failure is a result of running concurrent jobs with SNAPSHOT jars.
target code: static void addSnapshotJarToClassPath ( File jarFile , Path intermediateClassPath , FileSystem fs , Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory . final Path hdfsPath = new Path ( intermediateClassPath , jarFile . getName ( ) ) ; // Prevent uploading same file multiple times in same run . if ( ! fs . exists ( hdfsPath ) ) { uploadJar ( jarFile , hdfsPath , fs ) ; } job . addFileToClassPath ( hdfsPath ) ; }
response: static void addSnapshotJarToClassPath( File jarFile, Path intermediateClassPath, FileSystem fs, Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory. final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName()); // existing is used to prevent uploading file multiple times in same run. <START> if (!existing.contains(hdfsPath)) { <END> uploadJar(jarFile, hdfsPath, fs); existing.add(hdfsPath); } job.addFileToClassPath(hdfsPath); }

sample: 1327
buggy_code: public void start(ComponentContext context) { super.start(context); configs.forEach(this::createStreamIfNotExists); processorDescriptors.forEach(this::initProcessor); if (! componentListenerAdded) { // this must be done only once while start method can be called multiple time on hot reload Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener()); <START> componentListenerAdded = true; <END> } }
code_review: It's better to make the listener unregister itself at stop time instead of storing a boolean. See for instance `WorkManagerImpl.init` and the implementation of `afterStop`.
target code: public void start ( ComponentContext context ) { super . start ( context ) ; configs . forEach ( this : : createStreamIfNotExists ) ; processorDescriptors . forEach ( this : : initProcessor ) ; Framework . getRuntime ( ) . getComponentManager ( ) . addListener ( new ComponentsLifeCycleListener ( ) ) ; }
response: public void start(ComponentContext context) { super.start(context); configs.forEach(this::createStreamIfNotExists); processorDescriptors.forEach(this::initProcessor); if (! componentListenerAdded) { // this must be done only once while start method can be called multiple time on hot reload Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener()); <START> componentListenerAdded = true; <END> } } public void stop(ComponentContext context) { super.stop(context); Framework.getRuntime().getComponentManager().removeListener(this); }

sample: 1328
buggy_code: public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException { TextMessage message = session.createTextMessage("task:" + propertiesBean.getProperty("engine.unique.id") + ":" + id + ":" + status + ":" + miliseconds); producer.send(message, DeliveryMode.PERSISTENT, 6, 0); <START> log.debug("[{}] Task state {} sent to dispatcher.", id, status); <END> }
code_review: Please keep it in info level.
target code: public void reportTaskStatus ( int id , Task . TaskStatus status , long miliseconds ) throws JMSException { TextMessage message = session . createTextMessage ( "task : " + propertiesBean . getProperty ( "engine . unique . id" ) + " : " + id + " : " + status + " : " + miliseconds ) ; producer . send ( message , DeliveryMode . PERSISTENT , 6 , 0 ) ; log . info ( " [ { } ] Task state { } sent to dispatcher . " , id , status ) ; }
response: public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException { TextMessage message = session.createTextMessage("task:" + propertiesBean.getProperty("engine.unique.id") + ":" + id + ":" + status + ":" + miliseconds); producer.send(message, DeliveryMode.PERSISTENT, 6, 0); <START> log.info("[{}] Task state {} sent to dispatcher.", id, status); <END> }

sample: 1329
buggy_code: public final BeanMetaData<T> getCurrentBeanMetaData() { <START> if ( currentBeanType != null && currentBeanMetaData == null ) { <END> currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType ); } return currentBeanMetaData; }
code_review: Why is it done lazily? Seems we'll need it in any case?
target code: public final BeanMetaData < T > getCurrentBeanMetaData ( ) { return currentBeanMetaData ; }
response: public final BeanMetaData<T> getCurrentBeanMetaData() { <START> if ( currentBeanType != null && currentBeanMetaData == null ) { currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType ); } <END> return currentBeanMetaData; }

sample: 1330
buggy_code: protected Object handleObjectGet() throws Exception { String workspace = getAttribute("workspace"); ServiceInfo service; if (workspace != null) { WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace); service = geoServer.getService(ws, clazz); } else { service = geoServer.getService(clazz); } if (service == null) { throw new RestletException("Service for workspace " + workspace + " does not exist", Status.CLIENT_ERROR_NOT_FOUND); } <START> return service.clone(true); <END> }
code_review: Given this is configuration, wouldn't it make more sense to show the parameters in the output, accept them in input, and then fix validation like it's done in the UI?
target code: protected Object handleObjectGet ( ) throws Exception { String workspace = getAttribute ( "workspace" ) ; ServiceInfo service ; if ( workspace != null ) { WorkspaceInfo ws = geoServer . getCatalog ( ) . getWorkspaceByName ( workspace ) ; service = geoServer . getService ( ws , clazz ) ; } else { service = geoServer . getService ( clazz ) ; } if ( service == null ) { throw new RestletException ( "Service for workspace " + workspace + " does not exist" , Status . CLIENT_ERROR_NOT_FOUND ) ; } return service ; }
response: protected Object handleObjectGet() throws Exception { String workspace = getAttribute("workspace"); ServiceInfo service; if (workspace != null) { WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace); service = geoServer.getService(ws, clazz); } else { service = geoServer.getService(clazz); } if (service == null) { throw new RestletException("Service for workspace " + workspace + " does not exist", Status.CLIENT_ERROR_NOT_FOUND); } <START> return service.clone(); <END> }

sample: 1331
buggy_code: private String buildHashedPayload(HttpRequest request) { String hashedPayload = ""; try { byte[] unhashedBytes = request.getPayload() == null ? "".getBytes() : ByteStreams.toByteArray(request .getPayload().getInput()); <START> hashedPayload = sha256(unhashedBytes); <END> } catch (IOException e) { throw new HttpException("Error signing request", e); } return hashedPayload; }
code_review: Return the result of `sha256` instead of using the local variable.
target code: private static String buildHashedPayload ( HttpRequest request ) { try { byte [ ] unhashedBytes = request . getPayload ( ) == null ? "" . getBytes ( ) : ByteStreams . toByteArray ( request . getPayload ( ) . getInput ( ) ) ; return sha256 ( unhashedBytes ) ; } catch ( IOException e ) { throw new HttpException ( "Error signing request" , e ) ; } }
response: private String buildHashedPayload(HttpRequest request) { String hashedPayload = ""; try { byte[] unhashedBytes = request.getPayload() == null ? "".getBytes() : ByteStreams.toByteArray(request .getPayload().getInput()); <START> return sha256(unhashedBytes); <END> } catch (IOException e) { throw new HttpException("Error signing request", e); } return hashedPayload; }

sample: 1332
buggy_code: public Map<Long, EventDefinition> getEventDefs(StreamInput id) { <START> return null; <END> }
code_review: It's a little harsh to return null because the deprecated method should work as the original implementation, right? Can't this method read the StreamInputReader and get the information from there?
target code: public Map < Long , EventDefinition > getEventDefs ( StreamInput id ) { return new HashMap < Long , EventDefinition > ( ) ; }
response: public Map<Long, EventDefinition> getEventDefs(StreamInput id) { <START> return StreamInputReader.getEventDefs(id); <END> }

sample: 1333
buggy_code: public void testSetTitleIconStartMargin() throws Throwable { int startMargin = 100; int navIconWidth = 100; mActivityRule.runOnUiThread(() -> { mToolbar.setNavigationIconContainerWidth(navIconWidth); mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon); mToolbar.setTitleIconStartMargin(startMargin); }); <START> InstrumentationRegistry.getInstrumentation().waitForIdleSync(); <END> onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin))); }
code_review: You don't need this. onView() will wait
target code: public void testSetTitleIconStartMargin ( ) throws Throwable { int startMargin = 100 ; int navIconWidth = 100 ; mActivityRule . runOnUiThread ( ( ) - > { mToolbar . setNavigationIconContainerWidth ( navIconWidth ) ; mToolbar . setTitleIcon ( android . R . drawable . sym_def_app_icon ) ; mToolbar . setTitleIconStartMargin ( startMargin ) ; } ) ; onView ( withId ( R . id . title_icon ) ) . check ( matches ( withLeft ( navIconWidth + startMargin ) ) ) ; }
response: public void testSetTitleIconStartMargin() throws Throwable { int startMargin = 100; int navIconWidth = 100; mActivityRule.runOnUiThread(() -> { mToolbar.setNavigationIconContainerWidth(navIconWidth); mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon); mToolbar.setTitleIconStartMargin(startMargin); }); onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin))); }

sample: 1334
buggy_code: Publisher<CoreEvent> getDownstreamPublisher() { return downstreamFlux <START> .compose(downstreamPublisher -> Mono.subscriberContext() <END> .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> { innerFlux.subscriberContext(downstreamContext).subscribe(); upstreamFlux.subscriberContext(downstreamContext).subscribe(); }))); }
code_review: static import
target code: Publisher < CoreEvent > getDownstreamPublisher ( ) { return downstreamFlux . compose ( downstreamPublisher - > subscriberContext ( ) . flatMapMany ( downstreamContext - > downstreamPublisher . doOnSubscribe ( s - > { innerFlux . subscriberContext ( downstreamContext ) . subscribe ( ) ; upstreamFlux . subscriberContext ( downstreamContext ) . subscribe ( ) ; } ) ) ) ; }
response: Publisher<CoreEvent> getDownstreamPublisher() { return downstreamFlux <START> .compose(downstreamPublisher -> subscriberContext() <END> .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> { innerFlux.subscriberContext(downstreamContext).subscribe(); upstreamFlux.subscriberContext(downstreamContext).subscribe(); }))); }

sample: 1335
buggy_code: public void onFailure(Throwable t) { log.error("Unable to RefreshCapabilities: {}", ExceptionUtils.getRootCauseMessage(t)); log.debug("Exception", t); <START> postProcessRefresh(false, releaseLock.getAndSet(false)); <END> }
code_review: This change may cause the lock not to be released in some cases. With this change, in case of a failure VdsManager is responsible for releasing the lock. The VdsManager releases the lock only in case it catches an immediate exception. In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked.
target code: public void onFailure ( Throwable t ) { log . error ( "Unable to RefreshCapabilities : { } " , ExceptionUtils . getRootCauseMessage ( t ) ) ; log . debug ( "Exception" , t ) ; postProcessRefresh ( false ) ; }
response: public void onFailure(Throwable t) { log.error("Unable to RefreshCapabilities: {}", ExceptionUtils.getRootCauseMessage(t)); log.debug("Exception", t); <START> postProcessRefresh(false, releaseLock.getAndSet(false)); <END> }

sample: 1336
buggy_code: public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships, int highLabelId, int highRelationshipTypeId ) { this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId, <START> new SilentMigrationProgressMonitor().NO_OP_SECTION ); <END> }
code_review: There is no reason to create new instance if SilentMigrationProgressMonitor here since NO_OP_SECTION is static
target code: public CountsComputer ( long lastCommittedTransactionId , NodeStore nodes , RelationshipStore relationships , int highLabelId , int highRelationshipTypeId ) { this ( lastCommittedTransactionId , nodes , relationships , highLabelId , highRelationshipTypeId , SilentMigrationProgressMonitor . NO_OP_SECTION ) ; }
response: public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships, int highLabelId, int highRelationshipTypeId ) { this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId, <START> SilentMigrationProgressMonitor.NO_OP_SECTION ); <END> }

sample: 1337
buggy_code: public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) { List<Tree> commas = Lists.newArrayList(); for (InternalSyntaxToken comma : commaTokens) { commas.add(comma); } <START> return new ArrayLiteralTreeImpl(commas); <END> }
code_review: @vilchik-elena can't we directly use commaTokens?
target code: public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements ( List < InternalSyntaxToken > commaTokens ) { return new ArrayLiteralTreeImpl ( new ArrayList < Tree > ( commaTokens ) ) ; }
response: public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) { <START> return new ArrayLiteralTreeImpl(commaTokens); <END> }

sample: 1338
buggy_code: public void onSuccess() { log.debug("Command succeeded, releasing macs {}.", <START> Arrays.toString(super.macs.toArray())); <END> releaseMacs(); }
code_review: why not to rely on AbstractCollection..toString?
target code: public void onSuccess ( ) { log . debug ( "Command succeeded , releasing macs { } . " , super . macs ) ; releaseMacs ( ) ; }
response: public void onSuccess() { log.debug("Command succeeded, releasing macs {}.", <START> super.macs); <END> releaseMacs(); }

sample: 1339
buggy_code: <START> SubresourceParameter(String value) { <END> super("t", value); }
code_review: Make the constructor public
target code: public SubresourceParameter ( String value ) { super ( "t" , value ) ; }
response: <START> public SubresourceParameter(String value) { <END> super("t", value); }

sample: 1340
buggy_code: private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) { <START> return expirationTimeInMs < referenceTimeInMs && expirationTimeInMs != Utils.Infinite_Time; <END> }
code_review: flip the order of the checks - more intuitive IMO. Something like saying "time is valid and is less than" rather than "time is less than and valid"
target code: private boolean isExpired ( long expirationTimeInMs , long referenceTimeInMs ) { return expirationTimeInMs != Utils . Infinite_Time && expirationTimeInMs < referenceTimeInMs ; }
response: private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) { <START> return expirationTimeInMs != Utils.Infinite_Time && expirationTimeInMs < referenceTimeInMs; <END> }

sample: 1341
buggy_code: public void testEncodeSpatial() throws Exception { Document doc = encode(FilterMockData.intersects(), FES.Filter); assertEquals("fes:Filter", doc.getDocumentElement().getNodeName()); Element e = getElementByQName(doc, FES.Intersects); assertNotNull(e); <START> print(e); <END> assertNotNull(getElementByQName(e, FES.ValueReference)); assertNotNull(getElementByQName(e, GML.Point)); }
code_review: Please do not print to stdout/stderr. Please log instead so output can be silenced by the build infrastructure.
target code: public void testEncodeSpatial ( ) throws Exception { Document doc = encode ( FilterMockData . intersects ( ) , FES . Filter ) ; assertEquals ( "fes : Filter" , doc . getDocumentElement ( ) . getNodeName ( ) ) ; Element e = getElementByQName ( doc , FES . Intersects ) ; assertNotNull ( e ) ; assertNotNull ( getElementByQName ( e , FES . ValueReference ) ) ; assertNotNull ( getElementByQName ( e , GML . Point ) ) ; }
response: public void testEncodeSpatial() throws Exception { Document doc = encode(FilterMockData.intersects(), FES.Filter); assertEquals("fes:Filter", doc.getDocumentElement().getNodeName()); Element e = getElementByQName(doc, FES.Intersects); assertNotNull(e); <START> LOGGER.info(e); <END> assertNotNull(getElementByQName(e, FES.ValueReference)); assertNotNull(getElementByQName(e, GML.Point)); }

sample: 1342
buggy_code: public View getTopContainer(final View view) { View topView = null; <START> EObject container; <END> if (view != null) { container = view.eContainer(); if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) { container = container.eContainer(); } if (container instanceof View) { topView = (View) container; } } return topView; }
code_review: The local variable is declared in bad scope.
target code: public View getTopContainer ( final View view ) { View topView = null ; if ( view != null ) { EObject container = view . eContainer ( ) ; if ( isStereotypeCompartment ( container ) || isStereotypeBrace ( container ) || isStereotypeLabel ( container ) ) { container = container . eContainer ( ) ; } if ( container instanceof View ) { topView = ( View ) container ; } } return topView ; }
response: public View getTopContainer(final View view) { View topView = null; <START> EObject container = null; <END> if (view != null) { container = view.eContainer(); if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) { container = container.eContainer(); } if (container instanceof View) { topView = (View) container; } } return topView; }

sample: 1343
buggy_code: public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository, StreamRepository streamRepository, XDParser parser) { super(zkConnection, repository, streamRepository, parser, stream); this.zkConnection = zkConnection; this.parser = parser; <START> updateModuleDefinitions(); <END> }
code_review: I don't think this method should be called in a constructor.
target code: public StreamDeployer ( ZooKeeperConnection zkConnection , StreamDefinitionRepository repository , StreamRepository streamRepository , XDParser parser ) { super ( zkConnection , repository , streamRepository , parser , stream ) ; this . zkConnection = zkConnection ; this . parser = parser ; }
response: public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository, StreamRepository streamRepository, XDParser parser) { super(zkConnection, repository, streamRepository, parser, stream); this.zkConnection = zkConnection; this.parser = parser; <START> updateModuleDefinitions(); <END> }

sample: 1344
buggy_code: public String toString() { Object oScope = scope; Object oKey = key; <START> if (oScope instanceof MarshalledValue) { <END> oScope = ((MarshalledValue) oScope).get(); } if (oKey instanceof MarshalledValue) { oKey = ((MarshalledValue) oKey).get(); } return "ScopedKey{scope = " + oScope + ", key = " + oKey + "}"; }
code_review: Is this really necessary? AFAIK the scope and key should never be MarshalledValues.
target code: public String toString ( ) { return "ScopedKey { scope = " + scope + " , key = " + key + " } " ; }
response: public String toString() { Object oScope = scope; Object oKey = key; <START> if (oScope instanceof MarshalledValue) { oScope = ((MarshalledValue) oScope).get(); } if (oKey instanceof MarshalledValue) { oKey = ((MarshalledValue) oKey).get(); } <END> return "ScopedKey{scope = " + oScope + ", key = " + oKey + "}"; }

sample: 1345
buggy_code: static String left(String str, int len) { <START> if (str == null || str.isEmpty() || len == 0) { <END> return ""; } if (len > 0) { return str.substring(0, Math.min(len, str.length())); } final int finalLen = str.length() + len; return finalLen > 0 ? str.substring(0, finalLen) : ""; }
code_review: `str == null` cannot be true here as this was already checked upfront by https://github.com/crate/crate/pull/8879/files#diff-7a2324ee3f0c0f2c921e7ffeb1740058R70 (it also correctly results in `null` there). We could also move this empty string or 0 length up under that check as it would be same for both functions.
target code: private static String left ( String str , int len ) { if ( len > 0 ) { return str . substring ( 0 , Math . min ( len , str . length ( ) ) ) ; } final int finalLen = str . length ( ) + len ; return finalLen > 0 ? str . substring ( 0 , finalLen ) : "" ; }
response: static String left(String str, int len) { <START> if (len > 0) { return str.substring(0, Math.min(len, str.length())); } final int finalLen = str.length() + len; return finalLen > 0 ? str.substring(0, finalLen) : ""; <END> }

sample: 1346
buggy_code: public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm, BindingResult bindingResult, @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader) { <START> if (roleForm == null) <END> { throw new RequestBodyValidationException("Empty request body", bindingResult); } if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult); } // Convert RoleForm to Role Role role = conversionService.convert(roleForm, Role.class); return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader); }
code_review: It should never happen, since `org.springframework.web.bind.annotation.RequestBody#required` is `default true`
target code: public ResponseEntity addRole ( @RequestBody @Validated RoleForm roleForm , BindingResult bindingResult , @RequestHeader ( HttpHeaders . ACCEPT ) String acceptHeader ) { if ( bindingResult . hasErrors ( ) ) { throw new RequestBodyValidationException ( FAILED_ADD_ROLE , bindingResult ) ; } Role role = conversionService . convert ( roleForm , Role . class ) ; return processConfig ( config - > addRole ( config , role ) , ( ) - > SUCCESSFUL_ADD_ROLE , acceptHeader ) ; }
response: public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm, BindingResult bindingResult, @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader) { if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult); } // Convert RoleForm to Role Role role = conversionService.convert(roleForm, Role.class); return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader); }

sample: 1347
buggy_code: <START> public AbstractJsonGetter(Getter parent) { <END> super(parent); }
code_review: Minor: you can decrease the visibility modifier for some methods here and change some methods to be static.
target code: AbstractJsonGetter ( Getter parent ) { super ( parent ) ; }
response: <START> public AbstractJsonGetter(Getter parent) { <END> super(parent); }

sample: 1348
buggy_code: NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) { Objects.requireNonNull(vdsNumaNodeDao); <START> this.vdsNumaNodeDao = vdsNumaNodeDao; <END> }
code_review: how about this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao) ?
target code: NumaValidator ( VdsNumaNodeDao vdsNumaNodeDao ) { this . vdsNumaNodeDao = Objects . requireNonNull ( vdsNumaNodeDao ) ; }
response: NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) { <START> this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao); <END> }

sample: 1349
buggy_code: public List<ClientModel> getClients() { <START> return session.realms().getClients(this, 0, session.realms().getClientsCount(this).intValue()); <END> }
code_review: getClients(this, null, null)
target code: public List < ClientModel > getClients ( ) { return session . realms ( ) . getClients ( this ) ; }
response: public List<ClientModel> getClients() { <START> return session.realms().getClients(this, null, null); <END> }

sample: 1350
buggy_code: public List<String> getTokens() { ArrayList<String> ret = new ArrayList<>(this.tokenCount); <START> <END> for (int i = 0; i < this.tokenCount; i++) { ret.add(getToken(i)); } return ret; }
code_review: Coding best practices: Interface i = new Implementation();
target code: public List < String > getTokens ( ) { List < String > ret = new ArrayList < String > ( tokenCount ) ; for ( int i = 0 ; i < tokenCount ; i ++ ) { ret . add ( getToken ( i ) ) ; } return ret ; }
response: public List<String> getTokens() { List<String> ret = new ArrayList<>(this.tokenCount); <START> <END> for (int i = 0; i < this.tokenCount; i++) { ret.add(getToken(i)); } return ret; }

sample: 1351
buggy_code: public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) { Preconditions.checkArgument(maxWidth >= 1, "MaxWidth for given endpoint should be at least one."); this.endpoint = endpoint; this.affinity = affinity; this.mandatory = mandatory; this.maxWidth = maxWidth; <START> this.numLocalWorkUnits = 0; <END> }
code_review: Not needed. By default it will always be initialized to 0
target code: public EndpointAffinity ( final DrillbitEndpoint endpoint , final double affinity , final boolean mandatory , final int maxWidth ) { Preconditions . checkArgument ( maxWidth >= 1 , "MaxWidth for given endpoint should be at least one . " ) ; this . endpoint = endpoint ; this . affinity = affinity ; this . mandatory = mandatory ; this . maxWidth = maxWidth ; }
response: public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) { Preconditions.checkArgument(maxWidth >= 1, "MaxWidth for given endpoint should be at least one."); this.endpoint = endpoint; this.affinity = affinity; this.mandatory = mandatory; this.maxWidth = maxWidth; }

sample: 1352
buggy_code: public void run() { <START> LOG.trace("BacklogMetricEmitter running for entities"); <END> executor = new ScheduledThreadPoolExecutor(10); List<Future> futures = new ArrayList<>(); try { for (Entity entity : entityBacklogs.keySet()) { futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity)))); } waitForFuturesToComplete(futures); } finally { executor.shutdown(); } }
code_review: Intentional change. Keep the originial.
target code: public void run ( ) { LOG . debug ( "BacklogMetricEmitter running for entities" ) ; executor = new ScheduledThreadPoolExecutor ( 10 ) ; List < Future > futures = new ArrayList < > ( ) ; try { for ( Entity entity : entityBacklogs . keySet ( ) ) { futures . add ( executor . submit ( new BacklogCalcService ( entity , entityBacklogs . get ( entity ) ) ) ) ; } waitForFuturesToComplete ( futures ) ; } finally { executor . shutdown ( ) ; } }
response: public void run() { <START> LOG.trace("BacklogMetricEmitter running for entities"); <END> executor = new ScheduledThreadPoolExecutor(10); List<Future> futures = new ArrayList<>(); try { for (Entity entity : entityBacklogs.keySet()) { futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity)))); } waitForFuturesToComplete(futures); } finally { executor.shutdown(); } }

sample: 1353
buggy_code: public void onBackPressed() { if (projectListFragment != null) { projectListFragment.cancelLoadProjectTask(); Log.d(TAG, "Back press detected!"); <START> } <END> super.onBackPressed(); }
code_review: projectListFragment is always set, no null check needed Please remove log output
target code: public void onBackPressed ( ) { projectListFragment . cancelLoadProjectTask ( ) ; super . onBackPressed ( ) ; }
response: public void onBackPressed() { projectListFragment.cancelLoadProjectTask(); <START> super.onBackPressed(); }

sample: 1354
buggy_code: private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) { // do the state transition only if that VM is really running on SRC if (getParameters().getVdsId().equals(curVm.getRunOnVds())) { ResourceManager.getInstance().InternalSetVmStatus(curVm, <START> parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, curVm.getStatusUpdatedTime()); <END> } }
code_review: not needed (the value is null and won't be used anyway)
target code: private void changeStatus ( DestroyVmVDSCommandParameters parameters , VM curVm ) { // do the state transition only if that VM is really running on SRC if ( getParameters ( ) . getVdsId ( ) . equals ( curVm . getRunOnVds ( ) ) ) { ResourceManager . getInstance ( ) . InternalSetVmStatus ( curVm , parameters . getGracefully ( ) ? VMStatus . PoweringDown : VMStatus . Down ) ; } }
response: private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) { // do the state transition only if that VM is really running on SRC if (getParameters().getVdsId().equals(curVm.getRunOnVds())) { ResourceManager.getInstance().InternalSetVmStatus(curVm, <START> parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, null); <END> } }

sample: 1355
buggy_code: <START> public TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, <END> Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) { this.selection = checkNotNull(selection); this.publisher = checkNotNull(publisher); this.contentUri = checkNotNull(contentUri); this.transactionId = checkNotNull(transactionId); this.transactionStatus = checkNotNull(transactionStatus); }
code_review: Should this be private?
target code: private TransactionQuery ( Selection selection , Publisher publisher , Optional < String > contentUri , Optional < String > transactionId , Optional < TransactionStateType > transactionStatus ) { this . selection = checkNotNull ( selection ) ; this . publisher = checkNotNull ( publisher ) ; this . contentUri = checkNotNull ( contentUri ) ; this . transactionId = checkNotNull ( transactionId ) ; this . transactionStatus = checkNotNull ( transactionStatus ) ; }
response: <START> private TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, <END> Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) { this.selection = checkNotNull(selection); this.publisher = checkNotNull(publisher); this.contentUri = checkNotNull(contentUri); this.transactionId = checkNotNull(transactionId); this.transactionStatus = checkNotNull(transactionStatus); }

sample: 1356
buggy_code: private static boolean appendPort(final String scheme, final int port) { <START> return port > -1 && ((HTTP.equals(scheme) && port != 80) || (HTTPS.equals(scheme) && port != 443)); <END> }
code_review: maybe not necessary, but protocol is case-insensitive - maybe should be equalsIgnoreCase used?
target code: private static boolean appendPort ( final String scheme , final int port ) { return port > - 1 && ( ( HTTP . equalsIgnoreCase ( scheme ) && port != 80 ) || ( HTTPS . equalsIgnoreCase ( scheme ) && port != 443 ) ) ; }
response: private static boolean appendPort(final String scheme, final int port) { <START> return port > -1 && ((HTTP.equalsIgnoreCase(scheme) && port != 80) || (HTTPS.equalsIgnoreCase(scheme) && port != 443)); <END> }

sample: 1357
buggy_code: public void addPage(BenchmarkData data) { int pageCount = data.getPageCount(); <START> Page page = data.getDataPage(); <END> PartitionedOutputOperator operator = data.createPartitionedOutputOperator(); for (int i = 0; i < pageCount; i++) { operator.addInput(page); } operator.finish(); }
code_review: We can inline these two vars
target code: public void addPage ( BenchmarkData data ) { PartitionedOutputOperator operator = data . createPartitionedOutputOperator ( ) ; for ( int i = 0 ; i < data . getPageCount ( ) ; i ++ ) { operator . addInput ( data . getDataPage ( ) ) ; } operator . finish ( ) ; }
response: public void addPage(BenchmarkData data) { int pageCount = data.getPageCount(); <START> PartitionedOutputOperator operator = data.createPartitionedOutputOperator(); for (int i = 0; i < pageCount; i++) { operator.addInput(data.getDataPage()); } operator.finish(); <END> }

sample: 1358
buggy_code: private Element timeZone() { <START> return textElement(BlogConstants.TIMEZONE, entity.getTimeZone()); <END> }
code_review: Use import static
target code: private Element timeZone ( ) { return textElement ( TIMEZONE , entity . getTimeZone ( ) ) ; }
response: private Element timeZone() { <START> return textElement(TIMEZONE, entity.getTimeZone()); <END> }

sample: 1359
buggy_code: private DbUser getDbUserForPrincipalName(String principalName, String authzName) { ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord( EngineExtensionsManager.getInstance().getExtensionByName(authzName), <START> principalName, true, true); <END> if (principalRecord == null) { throw new RuntimeException(String.format("Unable to find principal %s in domain '%s'", principalName, authzName)); } return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord)); }
code_review: so do not resolve groups and no recursive as you going to search it anyway.
target code: private DbUser getDbUserForPrincipalName ( String principalName , String authzName ) { ExtMap principalRecord = AuthzUtils . fetchPrincipalRecord ( EngineExtensionsManager . getInstance ( ) . getExtensionByName ( authzName ) , principalName , false , false ) ; if ( principalRecord == null ) { throw new RuntimeException ( String . format ( "Unable to find principal % s in domain ' % s'" , principalName , authzName ) ) ; } return new DbUser ( DirectoryUtils . mapPrincipalRecordToDirectoryUser ( authzName , principalRecord ) ) ; }
response: private DbUser getDbUserForPrincipalName(String principalName, String authzName) { ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord( EngineExtensionsManager.getInstance().getExtensionByName(authzName), <START> principalName, false, false); <END> if (principalRecord == null) { throw new RuntimeException(String.format("Unable to find principal %s in domain '%s'", principalName, authzName)); } return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord)); }

sample: 1360
buggy_code: public PatternScatterGraphView() { super(ID); <START> this.addPartPropertyListener(new IPropertyChangeListener() { @Override public void propertyChange(PropertyChangeEvent event) { if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) { Object newValue = event.getNewValue(); if (newValue instanceof String) { String data = (String) newValue; fViewInfo.setViewData(data); setPartName(fViewInfo.getLabel()); loadLatencyView(); <END> } } } }); }
code_review: lambda?
target code: public PatternScatterGraphView ( ) { super ( ID ) ; this . addPartPropertyListener ( event - > { if ( event . getProperty ( ) . equals ( TmfXmlStrings . XML_LATENCY_OUTPUT_DATA ) ) { Object newValue = event . getNewValue ( ) ; if ( newValue instanceof String ) { String data = ( String ) newValue ; fViewInfo . setViewData ( data ) ; setPartName ( fViewInfo . getLabel ( ) ) ; loadLatencyView ( ) ; } } } ) ; }
response: public PatternScatterGraphView() { super(ID); <START> this.addPartPropertyListener(event -> { if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) { Object newValue = event.getNewValue(); if (newValue instanceof String) { String data = (String) newValue; fViewInfo.setViewData(data); setPartName(fViewInfo.getLabel()); loadLatencyView(); <END> } } }); }

sample: 1361
buggy_code: public void setMaxSpeed(double maxSpeed) { <START> if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { <END> this.maxSpeed = maxSpeed; } }
code_review: I believe `&&` should be here also
target code: public void setMaxSpeed ( double maxSpeed ) { if ( maxSpeed > this . maxSpeed ) { this . maxSpeed = maxSpeed ; } }
response: public void setMaxSpeed(double maxSpeed) { <START> if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { <END> this.maxSpeed = maxSpeed; } }

sample: 1362
buggy_code: <START> Object getValue(Object obj) throws Exception { <END> throw new HazelcastException("Path agnostic value extraction is not supported"); }
code_review: Minor: can remove `throws`
target code: Object getValue ( Object obj ) { throw new HazelcastException ( "Path agnostic value extraction is not supported" ) ; }
response: <START> Object getValue(Object obj) { <END> throw new HazelcastException("Path agnostic value extraction is not supported"); }

sample: 1363
buggy_code: public boolean apply(Resource resource) { Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources); <START> boolean result = Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); <END> return result; }
code_review: Except for debugging purpose, the "result" local does not seem necessary.
target code: public boolean apply ( Resource resource ) { Predicate < EObject > hasOuterRef = new EObjectHasReferencesTo ( modifiedResources ) ; return Iterators . any ( EcoreUtil . < EObject > getAllProperContents ( resource , false ) , hasOuterRef ) ; }
response: public boolean apply(Resource resource) { Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources); <START> return Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); <END> }

sample: 1364
buggy_code: private URI endSessionEndpoint(OAuth2AuthenticationToken token) { String registrationId = token.getAuthorizedClientRegistrationId(); <START> ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); <END> Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get("end_session_endpoint"); URI result = null; if (endSessionEndpoint != null) { result = URI.create(endSessionEndpoint.toString()); } return result; }
code_review: `clientRegistration` may be `null`. Please add a null check here.
target code: private URI endSessionEndpoint ( OAuth2AuthenticationToken token ) { String registrationId = token . getAuthorizedClientRegistrationId ( ) ; ClientRegistration clientRegistration = this . clientRegistrationRepository . findByRegistrationId ( registrationId ) ; URI result = null ; if ( clientRegistration != null ) { Object endSessionEndpoint = clientRegistration . getProviderDetails ( ) . getConfigurationMetadata ( ) . get ( "end_session_endpoint" ) ; if ( endSessionEndpoint != null ) { result = URI . create ( endSessionEndpoint . toString ( ) ) ; } } return result ; }
response: private URI endSessionEndpoint(OAuth2AuthenticationToken token) { String registrationId = token.getAuthorizedClientRegistrationId(); <START> ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); if (clientRegistration == null) { return null; } <END> Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get("end_session_endpoint"); URI result = null; if (endSessionEndpoint != null) { result = URI.create(endSessionEndpoint.toString()); } return result; }

sample: 1366
buggy_code: public void testQuantileAtValueBigint() { QuantileDigest qdigest = new QuantileDigest(1); addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)", toHexString(qdigest)), <START> DOUBLE, <END> 1.0); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)", toHexString(qdigest)), DOUBLE, 0.6); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)", toHexString(qdigest)), DOUBLE, 0.0); }
code_review: I see some surprising results here when adding additional test cases for doubles: * `Double.NaN` as the input value returns 1.0 (Edit: Double.MIN_VALUE is fine, I forgot this was just slightly greater than 0)
target code: public void testQuantileAtValueBigint ( ) { QuantileDigest qdigest = new QuantileDigest ( 1 ) ; addAll ( qdigest , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; functionAssertions . assertFunction ( format ( "quantile_at_value ( CAST ( X' % s' AS qdigest ( bigint ) ) , 20 ) " , toHexString ( qdigest ) ) , DOUBLE , null ) ; functionAssertions . assertFunction ( format ( "quantile_at_value ( CAST ( X' % s' AS qdigest ( bigint ) ) , 6 ) " , toHexString ( qdigest ) ) , DOUBLE , 0 . 6 ) ; functionAssertions . assertFunction ( format ( "quantile_at_value ( CAST ( X' % s' AS qdigest ( bigint ) ) , - 1 ) " , toHexString ( qdigest ) ) , DOUBLE , null ) ; }
response: public void testQuantileAtValueBigint() { QuantileDigest qdigest = new QuantileDigest(1); addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)", toHexString(qdigest)), DOUBLE, 1.0); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)", toHexString(qdigest)), DOUBLE, 0.6); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)", toHexString(qdigest)), DOUBLE, 0.0); }

sample: 1367
buggy_code: public boolean isOverutilized() { <START> return memoryManager.isOverUtilized(); <END> }
code_review: I'm ok with either capitalization. But it needs to be consistent. The `overutilized` 2 lines above is capitalized differently.
target code: public boolean isOverutilized ( ) { return memoryManager . isOverutilized ( ) ; }
response: public boolean isOverutilized() { <START> return memoryManager.isOverutilized(); <END> }

sample: 1368
buggy_code: public String explain() throws CouchbaseLiteException { <START> if (c4query == null) <END> check(); synchronized (getDatabase().getLock()) { return c4query.explain(); } }
code_review: c4query should also be synchronized. Move c4query checks to the check method itself. The same thing for the execute() method. See https://github.com/couchbase/couchbase-lite-ios/blob/feature/2.0/Objective-C/CBLQuery.mm#L605-L606
target code: public String explain ( ) throws CouchbaseLiteException { synchronized ( getDatabase ( ) . getLock ( ) ) { check ( ) ; return c4query . explain ( ) ; } }
response: public String explain() throws CouchbaseLiteException { <START> check(); synchronized (getDatabase().getLock()) { return c4query.explain(); } <END> }

sample: 1369
buggy_code: public boolean isObjectFactory() { <START> return getTargetTypeParameter() != null || getParameters().isEmpty(); <END> }
code_review: just return `false` here.
target code: public boolean isObjectFactory ( ) { return false ; }
response: public boolean isObjectFactory() { <START> return false; <END> }

sample: 1370
buggy_code: <START> StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories, <END> boolean fair) { Assert.notNull(factory, "factory cannot be null"); Assert.notNull(keyDirectories, "keyDirectories cannot be null"); Assert.isTrue(keyDirectories.size() > 0, "At least one KeyDirectory is required"); this.factory = factory; this.keyDirectories.addAll(keyDirectories); this.fair = fair; this.iterator = this.keyDirectories.iterator(); }
code_review: Shound't this ctor be `public` or at least `protected`? Otherwise I don't see reason in all those `protected` methods below.
target code: public StandardRotationPolicy ( DelegatingSessionFactory < ? > factory , List < KeyDirectory > keyDirectories , boolean fair ) { Assert . notNull ( factory , "factory cannot be null" ) ; Assert . notNull ( keyDirectories , "keyDirectories cannot be null" ) ; Assert . isTrue ( keyDirectories . size ( ) > 0 , "At least one KeyDirectory is required" ) ; this . factory = factory ; this . keyDirectories . addAll ( keyDirectories ) ; this . fair = fair ; this . iterator = this . keyDirectories . iterator ( ) ; }
response: <START> public StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories, <END> boolean fair) { Assert.notNull(factory, "factory cannot be null"); Assert.notNull(keyDirectories, "keyDirectories cannot be null"); Assert.isTrue(keyDirectories.size() > 0, "At least one KeyDirectory is required"); this.factory = factory; this.keyDirectories.addAll(keyDirectories); this.fair = fair; this.iterator = this.keyDirectories.iterator(); }

sample: 1371
buggy_code: public void add(EntityType entity) { validateAddAllowed(entity); <START> createAcl(entity); <END> super.add(entity); }
code_review: Tricky! `validateAddAllowed` currently checks if you have the WRITE_META permission on the entity. Acl gets created after the check. This breaks OneClickImporter
target code: public void add ( EntityType entity ) { createAcl ( entity ) ; super . add ( entity ) ; }
response: public void add(EntityType entity) { <START> createAcl(entity); <END> validateAddAllowed(entity); super.add(entity); }

sample: 1372
buggy_code: private ArtifactCoordinates getArtifactCoordinates(Path p) { <START> return ThrowingFunction.unchecked(RepositoryFiles::readCoordinates).apply((RepositoryPath) p); <END> }
code_review: @adavid9 can you please add `throws IOException` here and use `TrowingFunction` at `GroupRepositoryProvider.search` ?
target code: private ArtifactCoordinates getArtifactCoordinates ( Path p ) throws IOException { return RepositoryFiles . readCoordinates ( ( RepositoryPath ) p ) ; }
response: private ArtifactCoordinates getArtifactCoordinates(Path p) throws IOException { <START> return RepositoryFiles.readCoordinates((RepositoryPath) p); <END> }

sample: 1373
buggy_code: <START> public IPinUpdater<? extends ActivityNode> instantiate(ActivityNode node){ <END> IPinUpdater<? extends ActivityNode> updater = null; if(node instanceof CallBehaviorAction){ updater = new CallBehaviorActionPinUpdater(); }else if(node instanceof CallOperationAction){ updater = new CallOperationActionPinUpdater(); }else if(node instanceof SendSignalAction){ updater = new SendSignalActionPinUpdater(); } return updater; }
code_review: To avoid accidental class casts, you can use the following signature: public <T extends ActivityNode> IPinUpdater<T> instantiate(T node) Then unchecked casts can be regrouped into this method (Rather than in each Clients)
target code: public < T extends ActivityNode > IPinUpdater < T > instantiate ( ActivityNode node ) { IPinUpdater < T > updater = null ; if ( node instanceof CallBehaviorAction ) { updater = ( IPinUpdater < T > ) new CallBehaviorActionPinUpdater ( ) ; } else if ( node instanceof CallOperationAction ) { updater = ( IPinUpdater < T > ) new CallOperationActionPinUpdater ( ) ; } else if ( node instanceof SendSignalAction ) { updater = ( IPinUpdater < T > ) new SendSignalActionPinUpdater ( ) ; } return updater ; }
response: <START> public <T extends ActivityNode> IPinUpdater<T> instantiate(T node){ <END> IPinUpdater<T> updater = null; if(node instanceof CallBehaviorAction){ updater = (IPinUpdater<T>) new CallBehaviorActionPinUpdater(); }else if(node instanceof CallOperationAction){ updater = (IPinUpdater<T>) new CallOperationActionPinUpdater(); }else if(node instanceof SendSignalAction){ updater = (IPinUpdater<T>) new SendSignalActionPinUpdater(); } return updater; }

sample: 1374
buggy_code: public boolean supportsScroll() { StorageConfiguration conf = coreFeature.getStorageConfiguration(); // DBS mem and marklogic are not yet supported <START> return conf.isDBSMongoDB() || conf.isVCS(); <END> }
code_review: Please don't do cleanups in the same commit as bugfixes/features/improvements
target code: public boolean supportsScroll ( ) { StorageConfiguration conf = coreFeature . getStorageConfiguration ( ) ; // DBS mem and marklogic are not yet supported return ( conf . isDBSMongoDB ( ) || conf . isVCS ( ) ) ; }
response: public boolean supportsScroll() { StorageConfiguration conf = coreFeature.getStorageConfiguration(); // DBS mem and marklogic are not yet supported <START> return conf.isDBSMongoDB() || conf.isVCS(); <END> }

sample: 1375
buggy_code: public void onResume() { super.onResume(); addCachedDevices(); <START> if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) <END> removeAllDevices(); if (mStartScanOnResume) { mLocalAdapter.startScanning(true); mStartScanOnResume = false; } }
code_review: Style issue: please use braces in a multiline conditional.
target code: public void onResume ( ) { super . onResume ( ) ; addCachedDevices ( ) ; if ( mLocalAdapter . getBluetoothState ( ) != BluetoothAdapter . STATE_ON ) { removeAllDevices ( ) ; } if ( mStartScanOnResume ) { mLocalAdapter . startScanning ( true ) ; mStartScanOnResume = false ; } }
response: public void onResume() { super.onResume(); addCachedDevices(); <START> if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) { <END> removeAllDevices(); } if (mStartScanOnResume) { mLocalAdapter.startScanning(true); mStartScanOnResume = false; } }

sample: 1376
buggy_code: protected void upgradeNexusVersion() throws IOException { final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() ); final String previousVersion = getConfiguration().getNexusVersion(); if ( currentVersion.equals( previousVersion ) ) { setInstanceUpgraded( false ); } else { setInstanceUpgraded( true ); getConfiguration().setNexusVersion( currentVersion ); storeConfiguration(); <START> eventMulticaster.notifyEventListeners( new NexusVersionChangedEvent( this, previousVersion, <END> currentVersion ) ); } }
code_review: Not sure i'd go with events (yet). Model upgrade was not emitting events either, and Status flags with this change would be properly set. Let's go with baby steps, and not introduce events for these yet (unless some other good reason mentioned for it's need)
target code: protected void upgradeNexusVersion ( ) throws IOException { final String currentVersion = checkNotNull ( applicationStatusSource . getSystemStatus ( ) . getVersion ( ) ) ; final String previousVersion = getConfiguration ( ) . getNexusVersion ( ) ; if ( currentVersion . equals ( previousVersion ) ) { setInstanceUpgraded ( false ) ; } else { setInstanceUpgraded ( true ) ; getConfiguration ( ) . setNexusVersion ( currentVersion ) ; storeConfiguration ( ) ; } }
response: protected void upgradeNexusVersion() throws IOException { final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() ); final String previousVersion = getConfiguration().getNexusVersion(); if ( currentVersion.equals( previousVersion ) ) { setInstanceUpgraded( false ); } else { setInstanceUpgraded( true ); getConfiguration().setNexusVersion( currentVersion ); storeConfiguration(); } }

sample: 1377
buggy_code: <START> public DefDeclaration(String name, Type returnType, List<NameBinding> argNames, <END> TypedAST body, boolean isClassDef, FileLocation location) { if (argNames == null) { argNames = new LinkedList<NameBinding>(); } this.type = getMethodType(argNames, returnType); this.name = name; this.body = (ExpressionAST) body; this.argNames = argNames; this.isClass = isClassDef; this.location = location; }
code_review: Can you make the old constructor call the new one (with a default value for the additional parameter)?
target code: public DefDeclaration ( String name , Type returnType , List < NameBinding > argNames , TypedAST body , boolean isClassDef , FileLocation location ) { this ( name , returnType , null , argNames , body , isClassDef , location ) ; }
response: <START> public DefDeclaration(String name, Type returnType, List<NameBinding> argNames, <END> TypedAST body, boolean isClassDef, FileLocation location) { this(name, returnType, argNames, body, isClassDef, location, false); }

sample: 1378
buggy_code: <START> public Waiter<HeadBucketRequest> bucketNotExists() { <END> return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>() .withSdkFunction(new HeadBucketFunction(client)) .withAcceptors( new HttpFailureStatusAcceptor(404, WaiterState.SUCCESS)) .withDefaultPollingStrategy( new PollingStrategy(new MaxAttemptsRetryStrategy(20), new FixedDelayStrategy(5))) .withExecutorService(executorService).build(); }
code_review: Can we all add the generic parameters for the acceptors? (Like `HttpFailureStatusAcceptor<HeadBucketResult>`?)
target code: public Waiter < HeadBucketRequest > bucketNotExists ( ) { return new WaiterBuilder < HeadBucketRequest , HeadBucketResult > ( ) . withSdkFunction ( new HeadBucketFunction ( client ) ) . withAcceptors ( new HttpFailureStatusAcceptor < HeadBucketResult > ( 404 , WaiterState . SUCCESS ) ) . withDefaultPollingStrategy ( new PollingStrategy ( new MaxAttemptsRetryStrategy ( 20 ) , new FixedDelayStrategy ( 5 ) ) ) . withExecutorService ( executorService ) . build ( ) ; }
response: <START> public Waiter<HeadBucketRequest> bucketNotExists() { <END> return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>() .withSdkFunction(new HeadBucketFunction(client)) .withAcceptors( new HttpFailureStatusAcceptor<HeadBucketResult>(404, WaiterState.SUCCESS)) .withDefaultPollingStrategy( new PollingStrategy(new MaxAttemptsRetryStrategy(20), new FixedDelayStrategy(5))) .withExecutorService(executorService).build(); }

sample: 1379
buggy_code: public TextArea createWidget() { final TextArea textArea = GWT.create(TextArea.class); textArea.addKeyDownHandler(keyDownEvent -> { final int keyCode = keyDownEvent.getNativeKeyCode(); <START> if (keyCode == KeyCodes.KEY_TAB) { <END> destroyResources(); gridPanel.setFocus(true); keyDownEvent.preventDefault(); } keyDownEvent.stopPropagation(); }); textArea.addMouseDownHandler(DomEvent::stopPropagation); return textArea; }
code_review: @jomarko A couple of question: 1) from the ticket description it seems that somehow both TAB and ESC should be managed (in different way) but I do not see that here: is the ESC managed elsewhere or in different way? 2) is this kind of interaction specific ot ScenarioSImulation? Is it not the same for other grid editor? If the behavior should be the same on different component, then it should be better to create a builder/getter somewhere else (some abstract/parent class) to avoid duplicate this snippet
target code: public TextArea createWidget ( ) { final TextArea textArea = GWT . create ( TextArea . class ) ; textArea . addMouseDownHandler ( DomEvent : : stopPropagation ) ; return textArea ; }
response: public TextArea createWidget() { final TextArea textArea = GWT.create(TextArea.class); textArea.addKeyDownHandler(keyDownEvent -> { final int keyCode = keyDownEvent.getNativeKeyCode(); <START> if (keyCode == KeyCodes.KEY_TAB) { <END> destroyResources(); gridPanel.setFocus(true); keyDownEvent.preventDefault(); } keyDownEvent.stopPropagation(); }); textArea.addMouseDownHandler(DomEvent::stopPropagation); return textArea; }

sample: 1380
buggy_code: public void testHierarchyView() { DockerImagesTab imageTab = openDockerImagesTab(); buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab); if (mockitoIsUsed()) { <START> setupDataForMockito(); <END> } DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab(); List<TreeItem> treeItems = hierarchyTab.getTreeItems(); compareTextInFirstNode(treeItems, "alpine:3.3"); List<TreeItem> treeItems2 = treeItems.get(0).getItems(); compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST); }
code_review: Why is setupDataForMockito() called here when it is designated with the @Before keyword below? I have seen this in a few other tests as well.
target code: public void testHierarchyView ( ) { DockerImagesTab imageTab = openDockerImagesTab ( ) ; buildImage ( IMAGE_TEST_BUILD , DOCKERFILE_FOLDER , imageTab ) ; if ( mockitoIsUsed ( ) ) { buildImage ( ) ; } DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab ( ) ; List < TreeItem > treeItems = hierarchyTab . getTreeItems ( ) ; compareTextInFirstNode ( treeItems , "alpine : 3 . 3" ) ; List < TreeItem > treeItems2 = treeItems . get ( 0 ) . getItems ( ) ; compareTextInFirstNode ( treeItems2 , IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST ) ; }
response: public void testHierarchyView() { DockerImagesTab imageTab = openDockerImagesTab(); buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab); DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab(); List<TreeItem> treeItems = hierarchyTab.getTreeItems(); compareTextInFirstNode(treeItems, "alpine:3.3"); List<TreeItem> treeItems2 = treeItems.get(0).getItems(); compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST); }

sample: 1381
buggy_code: <START> void doBadOffsetInputTest(String name, long offset) { <END> try { new Offset(name, offset); fail("Should have thrown because one of the inputs is invalid"); } catch (IllegalArgumentException e) { // expected. } }
code_review: private
target code: private void doBadOffsetInputTest ( String name , long offset ) { try { new Offset ( name , offset ) ; fail ( "Should have thrown because one of the inputs is invalid" ) ; } catch ( IllegalArgumentException e ) { // expected . } }
response: <START> private void doBadOffsetInputTest(String name, long offset) { <END> try { new Offset(name, offset); fail("Should have thrown because one of the inputs is invalid"); } catch (IllegalArgumentException e) { // expected. } }

sample: 1382
buggy_code: private void enablePhiro() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); if (!sharedPreferences.getBoolean(Constants.PHIRO_INITIALIZED, false)) { <START> BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true); <END> sharedPreferences.edit().putBoolean(Constants.PHIRO_INITIALIZED, true).apply(); } }
code_review: why is the same code still present in the SettingsActivity?
target code: private void enablePhiro ( ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; if ( ! sharedPreferences . getBoolean ( PHIRO_INITIALIZED , false ) ) { BaseSettingsActivity . setPhiroSharedPreferenceEnabled ( this , true ) ; sharedPreferences . edit ( ) . putBoolean ( PHIRO_INITIALIZED , true ) . apply ( ) ; } }
response: private void enablePhiro() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); if (!sharedPreferences.getBoolean(Constants.PHIRO_INITIALIZED, false)) { <START> BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true); <END> sharedPreferences.edit().putBoolean(Constants.PHIRO_INITIALIZED, true).apply(); } }

sample: 1383
buggy_code: private void checkReturnedValue(ReturnStatementTree tree, String nonNullAnnotation) { SymbolicValue returnedValue = programState.peekValue(); Constraint constraint = programState.getConstraint(returnedValue); if (constraint == null) { <START> reportIssue(tree, "This method''s return value is marked \"{0}\" but null may be returned.", nonNullAnnotation); <END> } else if (constraint.isNull()) { reportIssue(tree, "This method''s return value is marked \"{0}\" but null is returned.", nonNullAnnotation); } }
code_review: We should not raise issues in this case, as we are not certain. As we are not (yet) doing cross-procedural analysis, doing the assumption that we may end up with a null value with necessarily raise  lot of FPs.
target code: private void checkReturnedValue ( ReturnStatementTree tree , String nonNullAnnotation ) { SymbolicValue returnedValue = programState . peekValue ( ) ; Constraint constraint = programState . getConstraint ( returnedValue ) ; if ( constraint != null && constraint . isNull ( ) ) { reportIssue ( tree , "This method''s return value is marked \" { 0 } \" but null is returned . " , nonNullAnnotation ) ; } }
response: private void checkReturnedValue(ReturnStatementTree tree, String nonNullAnnotation) { SymbolicValue returnedValue = programState.peekValue(); Constraint constraint = programState.getConstraint(returnedValue); if (constraint == null) { <START> reportIssue(tree, "This method''s return value is marked \"{0}\" but null may be returned.", nonNullAnnotation); <END> } else if (constraint.isNull()) { reportIssue(tree, "This method''s return value is marked \"{0}\" but null is returned.", nonNullAnnotation); } }

sample: 1384
buggy_code: private void verifyEditResultCode(EditingResult result) { <START> assertThat(result.getResult(), equalTo(SUCCESS)); <END> }
code_review: Minor: consider replacing equalTo with is from Hamcrest here and below.
target code: private void verifyEditResultCode ( EditingResult result ) { assertThat ( result . getResult ( ) , is ( SUCCESS ) ) ; }
response: private void verifyEditResultCode(EditingResult result) { <START> assertThat(result.getResult(), is(SUCCESS)); <END> }

sample: 1385
buggy_code: <START> public EnginesPreferencePage() { <END> }
code_review: should call super(); explicitly
target code: public EnginesPreferencePage ( ) { super ( ) ; }
response: public EnginesPreferencePage() { super(); }

sample: 1386
buggy_code: public List<AmbryReplica> getReplicaIds() { <START> return clusterManagerCallback.getReplicaIdsForPartition(this) <END> .stream() .map(r -> (AmbryReplica) r) .collect(Collectors.toList()); }
code_review: Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in `ClusterManagerCallback`.
target code: public List < AmbryReplica > getReplicaIds ( ) { return clusterManagerCallback . getReplicaIdsForPartition ( this ) ; }
response: public List<AmbryReplica> getReplicaIds() { <START> return clusterManagerCallback.getReplicaIdsForPartition(this) <END> .stream() .map(r -> (AmbryReplica) r) .collect(Collectors.toList()); }

sample: 1387
buggy_code: private String blockingSSLConnect(int socketBufSize) throws IOException { String connectionId = selector.connect(new InetSocketAddress("localhost", server.port), socketBufSize, socketBufSize, PortType.SSL); while (!selector.connected().contains(connectionId)) { <START> System.out.println("here"); <END> selector.poll(10000L); } return connectionId; }
code_review: remove?
target code: private String blockingSSLConnect ( int socketBufSize ) throws IOException { String connectionId = selector . connect ( new InetSocketAddress ( "localhost" , server . port ) , socketBufSize , socketBufSize , PortType . SSL ) ; while ( ! selector . connected ( ) . contains ( connectionId ) ) { selector . poll ( 10000L ) ; } return connectionId ; }
response: private String blockingSSLConnect(int socketBufSize) throws IOException { String connectionId = selector.connect(new InetSocketAddress("localhost", server.port), socketBufSize, socketBufSize, PortType.SSL); while (!selector.connected().contains(connectionId)) { <START> System.out.println("here"); selector.poll(10000L); <END> } return connectionId; }

sample: 1388
buggy_code: <START> public EDDifferentialPrivacy(double epsilon, double delta, <END> DataGeneralizationScheme generalization) { super(delta); this.epsilon = epsilon; this.generalization = generalization; this.beta = calculateBeta(epsilon); this.k = calculateK(getDelta(), epsilon, this.beta); }
code_review: Why does this constructor not simply call the other one?
target code: public EDDifferentialPrivacy ( double epsilon , double delta , DataGeneralizationScheme generalization ) { this ( epsilon , delta , generalization , false ) ; }
response: <START> public EDDifferentialPrivacy(double epsilon, double delta, <END> DataGeneralizationScheme generalization) { this(epsilon, delta); this.generalization = generalization; }

sample: 1389
buggy_code: private final String getSessionIndex(Assertion subjectAssertion) { List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements(); if(authnStatements != null && authnStatements.size() > 0) { AuthnStatement statement = authnStatements.get(0); <START> return statement.getSessionIndex(); <END> } return null; }
code_review: Can `statement` be null?
target code: private final String getSessionIndex ( Assertion subjectAssertion ) { List < AuthnStatement > authnStatements = subjectAssertion . getAuthnStatements ( ) ; if ( authnStatements != null && authnStatements . size ( ) > 0 ) { AuthnStatement statement = authnStatements . get ( 0 ) ; if ( statement != null ) { return statement . getSessionIndex ( ) ; } } return null ; }
response: private final String getSessionIndex(Assertion subjectAssertion) { List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements(); if(authnStatements != null && authnStatements.size() > 0) { AuthnStatement statement = authnStatements.get(0); <START> return statement.getSessionIndex(); <END> } return null; }

sample: 1390
buggy_code: public void visitNode(Tree tree) { if (!hasSemantic()) { return; } MethodTree method = (MethodTree) tree; <START> if (!INPUT_STREAM_READ.matches(method) || method.block() == null) { <END> return; } method.accept(new ReturnStatementVisitor()); }
code_review: I would switch those two conditions.
target code: public void visitNode ( Tree tree ) { if ( ! hasSemantic ( ) ) { return ; } MethodTree method = ( MethodTree ) tree ; if ( method . block ( ) != null && INPUT_STREAM_READ . matches ( method ) ) { method . accept ( new ReturnStatementVisitor ( ) ) ; } }
response: public void visitNode(Tree tree) { if (!hasSemantic()) { return; } MethodTree method = (MethodTree) tree; <START> if (method.block() == null || !INPUT_STREAM_READ.matches(method)) { <END> return; } method.accept(new ReturnStatementVisitor()); }

sample: 1391
buggy_code: protected void onFinishInflate() { super.onFinishInflate(); View.inflate(getContext(), R.layout.merge_login_view, this); loginButton = Views.findById(this, R.id.sign_in_button); <START> loginButton.setSize(SignInButton.SIZE_WIDE); <END> }
code_review: Can't be set in xml ?
target code: protected void onFinishInflate ( ) { super . onFinishInflate ( ) ; View . inflate ( getContext ( ) , R . layout . merge_login_view , this ) ; loginButton = Views . findById ( this , R . id . sign_in_button ) ; }
response: protected void onFinishInflate() { super.onFinishInflate(); View.inflate(getContext(), R.layout.merge_login_view, this); loginButton = Views.findById(this, R.id.sign_in_button); loginButton.setSize(SignInButton.SIZE_WIDE); }

sample: 1392
buggy_code: <START> private int encode(int bucketIndex, int value) <END> { return (bucketIndex << VALUE_BITS) | value; }
code_review: static
target code: private static int encode ( int bucketIndex , int value ) { return ( bucketIndex < < VALUE_BITS ) | value ; }
response: <START> private static int encode(int bucketIndex, int value) <END> { return (bucketIndex << VALUE_BITS) | value; }

sample: 1393
buggy_code: public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) { <START> if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !uberfireDocksInteractionEvent.getTargetDock().getIdentifier().equals(TestToolsPresenter.IDENTIFIER)) { <END> populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier()); } }
code_review: Are you sure that `getTargetDock().getIdentifier()` is always not `null`? I suggest to rewrite the condition as `!TestToolsPresenter.IDENTIFIER.equals(uberfireDocksInteractionEvent.getTargetDock().getIdentifier())`
target code: public void onUberfireDocksInteractionEvent ( @Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent ) { if ( isUberfireDocksInteractionEventToManage ( uberfireDocksInteractionEvent ) && ! TestToolsPresenter . IDENTIFIER . equals ( uberfireDocksInteractionEvent . getTargetDock ( ) . getIdentifier ( ) ) ) { populateRightDocks ( uberfireDocksInteractionEvent . getTargetDock ( ) . getIdentifier ( ) ) ; } }
response: public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) { <START> if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !TestToolsPresenter.IDENTIFIER.equals(uberfireDocksInteractionEvent.getTargetDock().getIdentifier())) { <END> populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier()); } }

sample: 1394
buggy_code: public String getDocType() { if (Objects.isNull(docType)) { List<SelectItem> allDocTypes = getAllDoctypes(); for (SelectItem item : allDocTypes) { <START> if ("Monograph".equals(item.getValue())) { <END> setDocType((String) item.getValue()); return docType; } } setDocType((String) allDocTypes.get(0).getValue()); } return docType; }
code_review: No, such a feature has not been requested so far. The current state is that each division can be the type of root element. It was discussed that we might later add a possibility that these types can be restricted. In the context, one could also implement the selection of a standard type.
target code: public String getDocType ( ) { if ( Objects . isNull ( docType ) && ! allDocTypes . isEmpty ( ) ) { setDocType ( ( String ) allDocTypes . get ( 0 ) . getValue ( ) ) ; } return docType ; }
response: public String getDocType() { if (Objects.isNull(docType)) { List<SelectItem> allDocTypes = getAllDoctypes(); for (SelectItem item : allDocTypes) { if ("Monograph".equals(item.getValue())) { setDocType((String) item.getValue()); return docType; } } setDocType((String) allDocTypes.get(0).getValue()); } return docType; }

sample: 1395
buggy_code: <START> public boolean shouldUseCommitTemplate() { <END> return Activator.getDefault().getPreferenceStore() .getBoolean(UIPreferences.COMMIT_DIALOG_MESSAGE_TEMPLATE) && getCommitMessage() == null && getCommitTemplate().isPresent(); }
code_review: why is this needed ?
target code: public boolean shouldUseCommitTemplate ( ) { return getCommitMessage ( ) == null && getCommitTemplate ( ) . isPresent ( ) ; }
response: <START> public boolean shouldUseCommitTemplate() { <END> return Activator.getDefault().getPreferenceStore() .getBoolean(UIPreferences.COMMIT_DIALOG_MESSAGE_TEMPLATE) && getCommitMessage() == null && getCommitTemplate().isPresent(); }

sample: 1396
buggy_code: public void waitUntilAllBlocked() { try { _blockersDoneLatch.await(); } <START> catch (Exception ex) { <END> } }
code_review: missing exception. either log, rethrow runtime or rename exception ignored. Expand Exception
target code: public void waitUntilAllBlocked ( ) throws InterruptedException { _blockersDoneLatch . await ( ) ; }
response: public void waitUntilAllBlocked() { try { _blockersDoneLatch.await(); } <START> catch (InterruptedException ex) { <END> } }

sample: 1397
buggy_code: private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) { if (pathSegments != null) for (PathSegment segement : pathSegments) { MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters(); if (matrixParams != null && !matrixParams.isEmpty()) for (String key : matrixParams.keySet()) { if (key.equals(param)) return true; <START> } <END> } return false; }
code_review: Why not if (matrixParams.containsKey(param) { ... } ?
target code: private static boolean hasMatrixParam ( List < PathSegment > pathSegments , String param ) { if ( pathSegments != null ) for ( PathSegment segement : pathSegments ) { MultivaluedMap < String , String > matrixParams = segement . getMatrixParameters ( ) ; if ( matrixParams != null && ! matrixParams . isEmpty ( ) && matrixParams . containsKey ( param ) ) return true ; } return false ; }
response: private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) { if (pathSegments != null) for (PathSegment segement : pathSegments) { MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters(); if (matrixParams != null && !matrixParams.isEmpty()) for (String key : matrixParams.keySet()) { if (key.equals(param)) return true; <START> } <END> } return false; }

sample: 1398
buggy_code: public void setAttached(boolean attached) { <START> attached = attached; <END> }
code_review: this is self assignment - please modify to: this.attached = attached
target code: public void setAttached ( boolean attached ) { this . attached = attached ; }
response: public void setAttached(boolean attached) { <START> this.attached = attached; <END> }

sample: 1399
buggy_code: public void visited(RevObject o) { <START> lowestDepthVisited.put(o, Long.valueOf(walk.getTreeDepth())); <END> }
code_review: Stupid question: why long/Long? walk.getTreeDepth() returns int, so why not use Integer (also in the Map, and intValue() above)?
target code: public void visited ( RevObject o ) { lowestDepthVisited . put ( o , Integer . valueOf ( walk . getTreeDepth ( ) ) ) ; }
response: public void visited(RevObject o) { <START> lowestDepthVisited.put(o, Integer.valueOf(walk.getTreeDepth())); <END> }

sample: 1400
buggy_code: private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) { for (Object[] item : list) { <START> item[index] = new Long((long) item[index]); <END> } return list; }
code_review: Is this superfluous casting?
target code: private List < Object [ ] > convertIntegerToLong ( List < Object [ ] > list , int index ) { for ( Object [ ] item : list ) { item [ index ] = ( long ) item [ index ] ; } return list ; }
response: private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) { for (Object[] item : list) { <START> item[index] = new Long((long) item[index]); <END> } return list; }

sample: 1401
buggy_code: private void flushAll() throws AuthException { for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) { CacheResource cacheResource = new CacheResource(e.getPluginName(), e.getExportName(), e.getProvider()); if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) { continue; } flushCache.get().apply(cacheResource, <START> new FlushCache.Input()); <END> } }
code_review: No new for constant object in loop. Either pass null, or construct the instance outside of the looop.
target code: private void flushAll ( ) throws AuthException { for ( DynamicMap . Entry < Cache < ? , ? > > e : cacheMap ) { CacheResource cacheResource = new CacheResource ( e . getPluginName ( ) , e . getExportName ( ) , e . getProvider ( ) ) ; if ( FlushCache . WEB_SESSIONS . equals ( cacheResource . getName ( ) ) ) { continue ; } flushCache . apply ( cacheResource , null ) ; } }
response: private void flushAll() throws AuthException { for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) { CacheResource cacheResource = new CacheResource(e.getPluginName(), e.getExportName(), e.getProvider()); if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) { continue; } flushCache.get().apply(cacheResource, <START> null); <END> } }

sample: 1402
buggy_code: <START> public static Map<String, IAnalysisModule> getAnalysisModules() { <END> if (fAnalysisModules.isEmpty()) { TmfAnalysisType analysis = TmfAnalysisType.getInstance(); List<IAnalysisModule> modules = analysis.getAnalysisModules(); for (IAnalysisModule module : modules) { fAnalysisModules.add(module); } } return getExecutableModules(); }
code_review: I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course) ?
target code: public static Map < String , IAnalysisModule > getAnalysisModules ( ) { synchronized ( fAnalysisModules ) { if ( fAnalysisModules . isEmpty ( ) ) { TmfAnalysisType analysis = TmfAnalysisType . getInstance ( ) ; List < IAnalysisModule > modules = analysis . getAnalysisModules ( ) ; for ( IAnalysisModule module : modules ) { fAnalysisModules . add ( module ) ; } } } return getExecutableModules ( ) ; }
response: <START> public static Map<String, IAnalysisModule> getAnalysisModules() { <END> if (fAnalysisModules.isEmpty()) { TmfAnalysisType analysis = TmfAnalysisType.getInstance(); List<IAnalysisModule> modules = analysis.getAnalysisModules(); for (IAnalysisModule module : modules) { fAnalysisModules.add(module); } } return getExecutableModules(); }

sample: 1403
buggy_code: void validateValueParameter(String name, Object value) { Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith(); <START> if (validators != null && validators.length>0) { <END> for(final Class<? extends IValueValidator> validator: validators) { validateValueParameter(validator, name, value); } } }
code_review: Spaces.
target code: void validateValueParameter ( String name , Object value ) { final Class < ? extends IValueValidator > validators [ ] = wrappedParameter . validateValueWith ( ) ; if ( validators != null && validators . length > 0 ) { for ( final Class < ? extends IValueValidator > validator : validators ) { validateValueParameter ( validator , name , value ) ; } } }
response: void validateValueParameter(String name, Object value) { Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith(); <START> if (validators != null && validators.length > 0) { <END> for(final Class<? extends IValueValidator> validator: validators) { validateValueParameter(validator, name, value); } } }

sample: 1404
buggy_code: <START> public <C> Stream<Match> match(Object object, Captures captures, C context) <END> { if (previous.isPresent()) { return previous.get().match(object, captures, context) .flatMap(match -> accept(object, match.captures(), context)); } else { return accept(object, captures, context); } }
code_review: final?
target code: public final < C > Stream < Match > match ( Object object , Captures captures , C context ) { if ( previous . isPresent ( ) ) { return previous . get ( ) . match ( object , captures , context ) . flatMap ( match - > accept ( object , match . captures ( ) , context ) ) ; } else { return accept ( object , captures , context ) ; } }
response: <START> public <C> Stream<Match> match(Object object, Captures captures, C context) <END> { if (previous.isPresent()) { return previous.get().match(object, captures, context) .flatMap(match -> accept(object, match.captures(), context)); } else { return accept(object, captures, context); } }

sample: 1405
buggy_code: public ArticlePageObject savePage() { waitForElementInViewPort(editSummary); waitForElementInViewPort(reviewChangesButton); waitForElementVisibleByElement(savePanel); publishButton.click(); <START> PageObjectLogging.log("savePage", "The 2nd Publish Button is clicked", true); <END> return new ArticlePageObject(driver); }
code_review: Global listener catch each click. You don't need to log it.
target code: public ArticlePageObject savePage ( ) { waitForElementInViewPort ( editSummary ) ; waitForElementInViewPort ( reviewChangesButton ) ; waitForElementVisibleByElement ( savePanel ) ; publishButton . click ( ) ; return new ArticlePageObject ( driver ) ; }
response: public ArticlePageObject savePage() { waitForElementInViewPort(editSummary); waitForElementInViewPort(reviewChangesButton); waitForElementVisibleByElement(savePanel); publishButton.click(); return new ArticlePageObject(driver); }

sample: 1406
buggy_code: public void executeCommand(CommandSender sender, List<String> arguments) { // Get the list of banned players Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers(); Set<String> namedBanned = new HashSet<>(bannedPlayers.size()); for (OfflinePlayer offlinePlayer : bannedPlayers) { namedBanned.add(offlinePlayer.getName()); } <START> purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[0])); <END> }
code_review: Please revert. I know it's an IntelliJ warning but why should we tell Java to create an array generically by reflection when we literally know the size beforehand?
target code: public void executeCommand ( CommandSender sender , List < String > arguments ) { // Get the list of banned players Set < OfflinePlayer > bannedPlayers = bukkitService . getBannedPlayers ( ) ; Set < String > namedBanned = new HashSet < > ( bannedPlayers . size ( ) ) ; for ( OfflinePlayer offlinePlayer : bannedPlayers ) { namedBanned . add ( offlinePlayer . getName ( ) ) ; } purgeService . purgePlayers ( sender , namedBanned , bannedPlayers . toArray ( new OfflinePlayer [ bannedPlayers . size ( ) ] ) ) ; }
response: public void executeCommand(CommandSender sender, List<String> arguments) { // Get the list of banned players Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers(); Set<String> namedBanned = new HashSet<>(bannedPlayers.size()); for (OfflinePlayer offlinePlayer : bannedPlayers) { namedBanned.add(offlinePlayer.getName()); } <START> purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[bannedPlayers.size()])); <END> }

sample: 1407
buggy_code: <START> public static Keyspace getKeyspace() { <END> return keyspace; }
code_review: Why do we need to make this public? It should be package scoped, protected would work as well. All Astyanax classes in com.rackspace.blueflood.io.astyanax.\* should be able to call this method without it being public.
target code: protected static Keyspace getKeyspace ( ) { return keyspace ; }
response: <START> static Keyspace getKeyspace() { <END> return keyspace; }

sample: 1408
buggy_code: void setNewElementYPosition(final Element elementReference, final Element newElement) { <START> int referencePosition = getDndListComponent().getPositionY(elementReference); <END> getDndListComponent().setPositionY(newElement, referencePosition); }
code_review: just for consistency, can we use `final int`?
target code: void setNewElementYPosition ( final Element elementReference , final Element newElement ) { final int referencePosition = getDndListComponent ( ) . getPositionY ( elementReference ) ; getDndListComponent ( ) . setPositionY ( newElement , referencePosition ) ; }
response: void setNewElementYPosition(final Element elementReference, final Element newElement) { <START> final int referencePosition = getDndListComponent().getPositionY(elementReference); <END> getDndListComponent().setPositionY(newElement, referencePosition); }

sample: 1409
buggy_code: public void layoutTopRight(CTabFolder ctf) { Composite trComp = getTRComposite(ctf); if (trComp.getChildren().length > 0) { trComp.setVisible(true); ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP); } else { ctf.setTopRight(null); trComp.setVisible(false); } trComp.pack(); <START> ctf.layout(true, true); <END> }
code_review: I'm not sure if we should fix it in this way. Removing the CTabFolder.layout invocation is a part of the optimization process that is needed to fix the issue exposed by the "JRockit Mission Control " application. It blocks the similar applications to be migrated to the E4 (poor GUI rendering performance) Daniel
target code: public void layoutTopRight ( CTabFolder ctf ) { Composite trComp = getTRComposite ( ctf ) ; if ( trComp . getChildren ( ) . length > 0 ) { trComp . setVisible ( true ) ; ctf . setTopRight ( trComp , SWT . RIGHT | SWT . WRAP ) ; } else { ctf . setTopRight ( null ) ; trComp . setVisible ( false ) ; } trComp . pack ( ) ; trComp . layout ( true , true ) ; }
response: public void layoutTopRight(CTabFolder ctf) { Composite trComp = getTRComposite(ctf); if (trComp.getChildren().length > 0) { trComp.setVisible(true); ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP); } else { ctf.setTopRight(null); trComp.setVisible(false); } trComp.pack(); }

sample: 1410
buggy_code: ByteBuf buffer() throws IOException { if (buf == null) { buf = Netty4Utils.toByteBuf(context.get()); context = null; <START> } <END> return buf; }
code_review: Can we `assert context == null` here?
target code: ByteBuf buffer ( ) throws IOException { if ( buf == null ) { buf = Netty4Utils . toByteBuf ( context . get ( ) ) ; context = null ; } assert context == null ; return buf ; }
response: ByteBuf buffer() throws IOException { if (buf == null) { buf = Netty4Utils.toByteBuf(context.get()); context = null; assert context == null; <START> } <END> return buf; }

sample: 1411
buggy_code: public String getName() { String name = super.getName(); <START> if (name == null || name.isEmpty()) { <END> return ""; } else { return name; } }
code_review: Now we have `isEmpty` method for Strings in Utils. Is it good idea to use it here as well? https://github.com/kiegroup/kie-wb-common/blob/master/kie-wb-common-stunner/kie-wb-common-stunner-core/kie-wb-common-stunner-api/kie-wb-common-stunner-core-api/src/main/java/org/kie/workbench/common/stunner/core/util/StringUtils.java
target code: public String getName ( ) { String name = super . getName ( ) ; if ( StringUtils . isEmpty ( name ) ) { return "" ; } else { return name ; } }
response: public String getName() { String name = super.getName(); <START> if (name == null || name.isEmpty()) { <END> return ""; } else { return name; } }

sample: 1412
buggy_code: private void verifyInvalidValueSize(IndexValue value, String logSegmentName) { try { int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity()); ByteBuffer invalidValue = ByteBuffer.allocate(capacity); invalidValue.put(value.getBytes().array(), 0, capacity); <START> new IndexValue(logSegmentName, invalidValue, version); <END> fail( "Contruction of IndexValue expected to fail with invalid byte buffer capacity of " + invalidValue.capacity()); } catch (IllegalArgumentException e) { } }
code_review: minor: put _only_ the statement you expect to fail in `try`.
target code: private void verifyInvalidValueSize ( IndexValue value , String logSegmentName ) { int capacity = TestUtils . RANDOM . nextInt ( value . getBytes ( ) . capacity ( ) ) ; ByteBuffer invalidValue = ByteBuffer . allocate ( capacity ) ; invalidValue . put ( value . getBytes ( ) . array ( ) , 0 , capacity ) ; try { new IndexValue ( logSegmentName , invalidValue , version ) ; fail ( "Contruction of IndexValue expected to fail with invalid byte buffer capacity of " + invalidValue . capacity ( ) ) ; } catch ( IllegalArgumentException e ) { } }
response: private void verifyInvalidValueSize(IndexValue value, String logSegmentName) { try { int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity()); ByteBuffer invalidValue = ByteBuffer.allocate(capacity); invalidValue.put(value.getBytes().array(), 0, capacity); <START> new IndexValue(logSegmentName, invalidValue, version); <END> } catch (IllegalArgumentException e) { fail( "Contruction of IndexValue expected to fail with invalid byte buffer capacity of " + invalidValue.capacity()); } }

sample: 1413
buggy_code: void dispose() { if (semanticResourcesUpdater != null) { semanticResourcesUpdater.dispose(); semanticResourcesUpdater = null; <START> } <END> }
code_review: session could be set to null on dispose().
target code: void dispose ( ) { session = null ; if ( semanticResourcesUpdater != null ) { semanticResourcesUpdater . dispose ( ) ; semanticResourcesUpdater = null ; } }
response: void dispose() { if (semanticResourcesUpdater != null) { semanticResourcesUpdater.dispose(); semanticResourcesUpdater = null; <START> } session = null; <END> }

sample: 1414
buggy_code: public void deleteByContentType(final ContentTypeIf type) throws DotDataException{ <START> final DotConnect dc = new DotConnect(); <END> dc.setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE); dc.addParam(type.id()); dc.addParam(type.id()); dc.loadResults(); }
code_review: you can do this things in one line such as ``` new DotConnect().setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE).addParam(type.id()).addParam(type.id()).loadResults(); ```
target code: public void deleteByContentType ( final ContentTypeIf type ) throws DotDataException { new DotConnect ( ) . setSQL ( sql . DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE ) . addParam ( type . id ( ) ) . addParam ( type . id ( ) ) . loadResults ( ) ; }
response: public void deleteByContentType(final ContentTypeIf type) throws DotDataException{ <START> new DotConnect().setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE).addParam(type.id()).addParam(type.id()).loadResults(); <END> }

sample: 1415
buggy_code: public int getUniqueNotificationId() { if (uniqueNotificationIdCounter == null) { uniqueNotificationIdCounter = new AtomicInteger(0); <START> } <END> return uniqueNotificationIdCounter.incrementAndGet(); }
code_review: Is the if block still needed?
target code: public int getUniqueNotificationId ( ) { return uniqueNotificationIdCounter . incrementAndGet ( ) ; }
response: public int getUniqueNotificationId() { if (uniqueNotificationIdCounter == null) { uniqueNotificationIdCounter = new AtomicInteger(0); } return uniqueNotificationIdCounter.incrementAndGet(); }

sample: 1417
buggy_code: public HllSketchMergeBufferAggregator( final ColumnValueSelector<HllSketch> selector, final int lgK, final TgtHllType tgtHllType, final int size ) { this.selector = selector; this.lgK = lgK; this.tgtHllType = tgtHllType; this.size = size; this.emptyUnion = new byte[size]; //noinspection ResultOfObjectAllocationIgnored (Union writes to "emptySketch" as a side effect of construction) <START> new Union(lgK, WritableMemory.wrap(emptyUnion, ByteOrder.LITTLE_<END>IAN)); <END> }
code_review: No need to force byte order when wrapping byte[]
target code: public HllSketchMergeBufferAggregator ( final ColumnValueSelector < HllSketch > selector , final int lgK , final TgtHllType tgtHllType , final int size ) { this . selector = selector ; this . lgK = lgK ; this . tgtHllType = tgtHllType ; this . size = size ; this . emptyUnion = new byte [ size ] ; // noinspection ResultOfObjectAllocationIgnored ( Union writes to "emptyUnion" as a side effect of construction ) new Union ( lgK , WritableMemory . wrap ( emptyUnion ) ) ; }
response: public HllSketchMergeBufferAggregator( final ColumnValueSelector<HllSketch> selector, final int lgK, final TgtHllType tgtHllType, final int size ) { this.selector = selector; this.lgK = lgK; this.tgtHllType = tgtHllType; this.size = size; this.emptyUnion = new byte[size]; //noinspection ResultOfObjectAllocationIgnored (Union writes to "emptySketch" as a side effect of construction) <START> new Union(lgK, WritableMemory.wrap(emptyUnion)); <END> }

sample: 1418
buggy_code: public void checkIPAdress() { Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address)); <START> assertEquals(validate.isEmpty(), expectedResult); <END> }
code_review: The expected value should be 1st, it affects error messages by junit
target code: public void checkIPAdress ( ) { Set < ConstraintViolation < IPAdress > > validate = validator . validate ( new IPAdress ( address ) ) ; assertEquals ( expectedResult , validate . isEmpty ( ) ) ; }
response: public void checkIPAdress() { Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address)); <START> assertEquals(expectedResult, validate.isEmpty()); <END> }

sample: 1419
buggy_code: public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { try { // Ignore first call, which comes from onCreate() if (currentFormat != null) calc(); } catch (GeopointException e) { <START> context.showToast(e.getMessage()); <END> spinner.setSelection(currentFormat.ordinal()); return; } currentFormat = coordInputFormatEnum.fromInt(pos); settings.setCoordInputFormat(currentFormat); updateGUI(); }
code_review: No good idea. ;)
target code: public void onItemSelected ( AdapterView < ? > parent , View view , int pos , long id ) { // Ignore first call , which comes from onCreate ( ) if ( currentFormat != null && ! calc ( ) ) { // An error occurred , reset spinner to current format spinner . setSelection ( currentFormat . ordinal ( ) ) ; return ; } currentFormat = coordInputFormatEnum . fromInt ( pos ) ; settings . setCoordInputFormat ( currentFormat ) ; updateGUI ( ) ; }
response: public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { try { // Ignore first call, which comes from onCreate() if (currentFormat != null) calc(); } catch (GeopointException e) { context.showToast(e.getMessage()); spinner.setSelection(currentFormat.ordinal()); return; } currentFormat = coordInputFormatEnum.fromInt(pos); settings.setCoordInputFormat(currentFormat); updateGUI(); }

sample: 1420
buggy_code: public boolean visitTableWithType(String schemaName, String tableName, TableType type) { Preconditions .checkNotNull(type, "Error. Type information for table %s.%s provided is null.", schemaName, tableName); records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString())); <START> return false; <END> }
code_review: why return `false`?
target code: private void visitTableWithType ( String schemaName , String tableName , TableType type ) { Preconditions . checkNotNull ( type , "Error . Type information for table % s . % s provided is null . " , schemaName , tableName ) ; records . add ( new Records . Table ( IS_CATALOG_NAME , schemaName , tableName , type . toString ( ) ) ) ; return ; }
response: public boolean visitTableWithType(String schemaName, String tableName, TableType type) { Preconditions .checkNotNull(type, "Error. Type information for table %s.%s provided is null.", schemaName, tableName); records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString())); <START> return true; <END> }

sample: 1421
buggy_code: public boolean add(XWikiAttachment attachment) { <START> return set(attachment) != null; <END> }
code_review: Comparing with null is not enough. You might replace an existing attachment with a different instance in which case you should return true. In short if the return is different from the input then something changed.
target code: public boolean add ( XWikiAttachment attachment ) { XWikiAttachment set = set ( attachment ) ; return set != attachment ; }
response: public boolean add(XWikiAttachment attachment) { <START> return set(attachment) != attachment; <END> }

sample: 1422
buggy_code: public String toString() { <START> return Objects.toStringHelper(this).add("liveWorkerNum", mLiveWorkerNum) <END> .add("lostWorkerNum", mLostWorkerNum).add("capacityBytes", mCapacityBytes) .add("usedBytes", mUsedBytes).add("freeBytes", mFreeBytes) .add("capacityBytesOnTiers", mCapacityBytesOnTiers) .add("usedBytesOnTiers", mUsedBytesOnTiers).toString(); }
code_review: ditto: sort by name please
target code: public String toString ( ) { return Objects . toStringHelper ( this ) . add ( "capacityBytes" , mCapacityBytes ) . add ( "capacityBytesOnTiers" , mCapacityBytesOnTiers ) . add ( "freeBytes" , mFreeBytes ) . add ( "liveWorkerNum" , mLiveWorkerNum ) . add ( "lostWorkerNum" , mLostWorkerNum ) . add ( "usedBytes" , mUsedBytes ) . add ( "usedBytesOnTiers" , mUsedBytesOnTiers ) . toString ( ) ; }
response: public String toString() { <START> return Objects.toStringHelper(this).add("capacityBytes", mCapacityBytes) <END> .add("capacityBytesOnTiers", mCapacityBytesOnTiers) .add("freeBytes", mFreeBytes).add("liveWorkerNum", mLiveWorkerNum) .add("lostWorkerNum", mLostWorkerNum).add("usedBytes", mUsedBytes) .add("usedBytesOnTiers", mUsedBytesOnTiers).toString(); }

sample: 1423
buggy_code: public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) { await().pollInterval(250, TimeUnit.MILLISECONDS) .atMost(10, TimeUnit.SECONDS) <START> .until(() -> !j.jenkins.get().getQueue().isBlockedByShutdown(task)); <END> }
code_review: ```suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task)); ```
target code: public static final void assertJenkinsNotInQuietMode ( final JenkinsRule j ) { await ( ) . pollInterval ( 250 , TimeUnit . MILLISECONDS ) . atMost ( 10 , TimeUnit . SECONDS ) . until ( ( ) - > ! j . jenkins . getQueue ( ) . isBlockedByShutdown ( task ) ) ; }
response: public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) { await().pollInterval(250, TimeUnit.MILLISECONDS) .atMost(10, TimeUnit.SECONDS) <START> .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task)); <END> }

sample: 1424
buggy_code: private TreeLayer <START> getTreeLayer() <END> { NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class); ILayer layer = natTable.getLayer(); if (layer instanceof PapyrusGridLayer) { PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer; ILayer rowLayer = gridLayer.getRowHeaderLayer(); if (rowLayer instanceof RowHeaderHierarchicalLayerStack) { return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer(); } } throw new UnknownError("TreeLayer has not been found"); //$NON-NLS-1$ }
code_review: The method signature doesn't specify the Exception which could be thrown.
target code: private TreeLayer getTreeLayer ( ) throws Exception { NatTable natTable = ( NatTable ) getTableManager ( ) . getAdapter ( NatTable . class ) ; ILayer layer = natTable . getLayer ( ) ; if ( layer instanceof PapyrusGridLayer ) { PapyrusGridLayer gridLayer = ( PapyrusGridLayer ) layer ; ILayer rowLayer = gridLayer . getRowHeaderLayer ( ) ; if ( rowLayer instanceof RowHeaderHierarchicalLayerStack ) { return ( ( RowHeaderHierarchicalLayerStack ) rowLayer ) . getTreeLayer ( ) ; } } throw new UnknownError ( "TreeLayer has not been found" ) ; // $NON - NLS - 1$ }
response: private TreeLayer <START> getTreeLayer() throws UnknownError <END> { NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class); ILayer layer = natTable.getLayer(); if (layer instanceof PapyrusGridLayer) { PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer; ILayer rowLayer = gridLayer.getRowHeaderLayer(); if (rowLayer instanceof RowHeaderHierarchicalLayerStack) { return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer(); } } throw new UnknownError("TreeLayer has not been found"); //$NON-NLS-1$ }

sample: 1425
buggy_code: public boolean equals(@Nullable Object obj) { <START> if (!(obj instanceof DataDrivenValueSelf)) { <END> return false; } return true; }
code_review: return directly
target code: public boolean equals ( @Nullable Object obj ) { if ( ! ( obj instanceof DataDrivenValueSelf ) ) { return false ; } return super . equals ( obj ) ; }
response: public boolean equals(@Nullable Object obj) { <START> if (!(obj instanceof DataDrivenValueSelf)) { <END> return false; } return true; }

sample: 1426
buggy_code: public void differentUrlForPostsAndVideo() { <START> SearchInput searchInput = new SearchInput().searchInputValue(); <END> SearchInput searchInputSubmit = new SearchInput().searchInputSubmit(); String URL = driver.getCurrentUrl(); Assert.assertEquals(URL, "http://qa.fandom.wikia.com/?s=TEST"); SearchInput postsResult = new SearchInput().searchResultsPosts(); String postUrl = driver.getCurrentUrl(); SearchInput videosResult = new SearchInput().searchResultsVideos(); String videoUrl = driver.getCurrentUrl(); Assert.assertNotEquals(postUrl, videoUrl); }
code_review: ![MAJOR](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-major.png) Remove this unused "searchInput" local variable. [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](http://sonar-s1/coding_rules#rule_key=squid%3AS1481)
target code: public void differentUrlForPostsAndVideo ( ) { SearchInput searchInput = new SearchInput ( ) . searchInputValue ( ) ; SearchInput searchInputSubmit = new SearchInput ( ) . searchInputSubmit ( ) ; SearchInput postsResult = new SearchInput ( ) . searchResultsPosts ( ) ; String postUrl = driver . getCurrentUrl ( ) ; SearchInput videosResult = new SearchInput ( ) . searchResultsVideos ( ) ; String videoUrl = driver . getCurrentUrl ( ) ; Assert . assertNotEquals ( postUrl , videoUrl ) ; }
response: public void differentUrlForPostsAndVideo() { <START> SearchInput searchInputSubmit = new SearchInput().searchInputSubmit(); String URL = driver.getCurrentUrl(); Assert.assertEquals(URL, "http://qa.fandom.wikia.com/?s=TEST"); SearchInput postsResult = new SearchInput().searchResultsPosts(); String postUrl = driver.getCurrentUrl(); SearchInput videosResult = new SearchInput().searchResultsVideos(); String videoUrl = driver.getCurrentUrl(); Assert.assertNotEquals(postUrl, videoUrl); }

sample: 1427
buggy_code: <START> String convert(Blob blob) { <END> if (blob.getLength() == 0L) { return ""; } try (InputStream stream = blob.getStream()) { Xml2TextHandler xml2text = new Xml2TextHandler(); return xml2text.parse(stream); } catch (IOException | SAXException | ParserConfigurationException e) { throw new ConversionException("Error during XML2Text conversion", e); } }
code_review: I would deprecate it and add a new one.
target code: protected String convert ( Blob blob ) { if ( blob . getLength ( ) == 0L ) { return "" ; } try ( InputStream stream = blob . getStream ( ) ) { Xml2TextHandler xml2text = new Xml2TextHandler ( ) ; return xml2text . parse ( stream ) ; } catch ( IOException | SAXException | ParserConfigurationException e ) { throw new ConversionException ( "Error during XML2Text conversion" , blob , e ) ; } }
response: <START> String convert(Blob blob) { <END> if (blob.getLength() == 0L) { return ""; } try (InputStream stream = blob.getStream()) { Xml2TextHandler xml2text = new Xml2TextHandler(); return xml2text.parse(stream); } catch (IOException | SAXException | ParserConfigurationException e) { throw new ConversionException("Error during XML2Text conversion", e); } }

sample: 1428
buggy_code: <START> public static void validateHeaderConfigAction(String action) { <END> if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) { throw new ConfigException(String.format("Invalid header config action: '%s'. " + "Expected one of %s", action, HEADER_ACTIONS)); } }
code_review: This should be package-level protected: ```suggestion // Visible for testing static void validateHeaderConfigAction(String action) { ```
target code: static void validateHeaderConfigAction ( String action ) { if ( ! HEADER_ACTIONS . stream ( ) . anyMatch ( action : : equalsIgnoreCase ) ) { throw new ConfigException ( String . format ( "Invalid header config action : ' % s' . " + "Expected one of % s" , action , HEADER_ACTIONS ) ) ; } }
response: // Visible for testing static void validateHeaderConfigAction(String action) { if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) { throw new ConfigException(String.format("Invalid header config action: '%s'. " + "Expected one of %s", action, HEADER_ACTIONS)); } }

sample: 1429
buggy_code: private String getVariableLabel(VariableMetadata variableMetadata) { if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) { return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + " " + <START> variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length(), variableMetadata.getName().length()); <END> } else { return variableMetadata.getName(); } }
code_review: `variableMetadata.getName().length()` invocation is redundant.
target code: private String getVariableLabel ( VariableMetadata variableMetadata ) { if ( variableMetadata . getName ( ) . startsWith ( CASE_VARIABLE_PREFIX ) ) { return translationService . getValue ( CASE_VARIABLE_LABEL_PREFIX ) + " " + variableMetadata . getName ( ) . substring ( CASE_VARIABLE_PREFIX . length ( ) ) ; } else { return variableMetadata . getName ( ) ; } }
response: private String getVariableLabel(VariableMetadata variableMetadata) { if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) { return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + " " + <START> variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length()); <END> } else { return variableMetadata.getName(); } }

sample: 1430
buggy_code: private Long findFreeId(){ <START> while(personRepository.findOne(lastId) != null){ // New person <END> lastId++; } return lastId; }
code_review: [existsById(long id)](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#existsById-ID-) 
target code: private Long findFreeId ( ) { while ( personRepository . exists ( lastId ) ) { // New person lastId ++ ; } return lastId ; }
response: private Long findFreeId(){ <START> while(personRepository.existsById(lastId)){ // New person <END> lastId++; } return lastId; }

sample: 1431
buggy_code: public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { <START> Assume.assumeTrue(mCameraId != null); <END> mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); // Wait for the CameraDevice.onOpened callback. mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); // Wait for the CameraDevice.onClosed callback. mUseCase.mDeviceStateCallback.waitForOnClosed(1); }
code_review: Move to setUp(). You can make mCameraId a local variable again.
target code: public void cameraDeviceCallsAreForwardedToCallback ( ) throws InterruptedException { mUseCase . addStateChangeListener ( mCameraRepository . getCamera ( getCameraIdForLensFacingUnchecked ( mConfig . getLensFacing ( ) ) ) ) ; mUseCase . doNotifyActive ( ) ; mCameraRepository . onGroupActive ( mUseCaseGroup ) ; // Wait for the CameraDevice . onOpened callback . mUseCase . mDeviceStateCallback . waitForOnOpened ( 1 ) ; mCameraRepository . onGroupInactive ( mUseCaseGroup ) ; // Wait for the CameraDevice . onClosed callback . mUseCase . mDeviceStateCallback . waitForOnClosed ( 1 ) ; }
response: public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { Assume.assumeTrue(mCameraId != null); mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); // Wait for the CameraDevice.onOpened callback. mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); // Wait for the CameraDevice.onClosed callback. mUseCase.mDeviceStateCallback.waitForOnClosed(1); }

sample: 1432
buggy_code: public String getDescription() { <START> return getStatuteType().getName().getContent(I18N.getLocale()) <END> + (studentStatute instanceof SeniorStatute ? (" (" + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + ") ") : ""); }
code_review: Beware that invoking [`getContent(I18N.getLocale())`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L461-L475) is different than just invoking [`getContent()`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L480-L496).
target code: public String getDescription ( ) { return getStatuteType ( ) . getName ( ) . getContent ( ) + ( studentStatute instanceof SeniorStatute ? ( " ( " + ( ( SeniorStatute ) studentStatute ) . getRegistration ( ) . getDegree ( ) . getPresentationName ( ) + " ) " ) : "" ) ; }
response: public String getDescription() { <START> return getStatuteType().getName().getContent() <END> + (studentStatute instanceof SeniorStatute ? (" (" + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + ") ") : ""); }

sample: 1433
buggy_code: <START> public boolean teleportToSpawn() { <END> Location target = server.getWorlds().get(0).getSpawnLocation(); EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null)); if (event.isCancelled()) { return false; } target = event.getTo(); teleport(target); return true; }
code_review: Do this and the other method need to be public? Would `protected` suffice?
target code: protected boolean teleportToSpawn ( ) { Location target = server . getWorlds ( ) . get ( 0 ) . getSpawnLocation ( ) ; EntityPortalEvent event = EventFactory . callEvent ( new EntityPortalEvent ( this , location . clone ( ) , target , null ) ) ; if ( event . isCancelled ( ) ) { return false ; } target = event . getTo ( ) ; teleport ( target ) ; return true ; }
response: <START> protected boolean teleportToSpawn() { <END> Location target = server.getWorlds().get(0).getSpawnLocation(); EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null)); if (event.isCancelled()) { return false; } target = event.getTo(); teleport(target); return true; }

sample: 1434
buggy_code: public String[] getGroupFilters() { <START> String[] result = null; <END> IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class); if (before != null) { result = ((ConfigurationAnnotation) before).getGroupFilters(); } return result; }
code_review: Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ?
target code: public String [ ] getGroupFilters ( ) { IBeforeMethod before = m_annotationFinder . findAnnotation ( getConstructorOrMethod ( ) , IBeforeMethod . class ) ; if ( before == null ) { return new String [ 0 ] ; } return before . getGroupFilters ( ) ; }
response: public String[] getGroupFilters() { <START> String[] result = new String[0]; <END> IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class); if (before != null) { result = ((ConfigurationAnnotation) before).getGroupFilters(); } return result; }

sample: 1435
buggy_code: <START> protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, <END> long defaultValue, long base ) throws IOException { this.pagedFile = pagedFile; this.entrySize = entrySize; this.entriesPerPage = pagedFile.pageSize() / entrySize; this.length = length; this.defaultValue = defaultValue; this.base = base; try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) ) { setLength( cursorToSetLength, length ); } if ( defaultValue != 0 ) { setDefaultValue( defaultValue ); } }
code_review: some of the protected items here can be package private
target code: PageCacheNumberArray ( PagedFile pagedFile , int entrySize , long length , long defaultValue , long base ) throws IOException { this . pagedFile = pagedFile ; this . entrySize = entrySize ; this . entriesPerPage = pagedFile . pageSize ( ) / entrySize ; this . length = length ; this . defaultValue = defaultValue ; this . base = base ; try ( PageCursor cursorToSetLength = pagedFile . io ( 0 , PF_SHARED_WRITE_LOCK ) ) { setLength ( cursorToSetLength , length ) ; } if ( defaultValue != 0 ) { setDefaultValue ( defaultValue ) ; } }
response: <START> protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, <END> long defaultValue, long base ) throws IOException { this.pagedFile = pagedFile; this.entrySize = entrySize; this.entriesPerPage = pagedFile.pageSize() / entrySize; this.length = length; this.defaultValue = defaultValue; this.base = base; try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) ) { setLength( cursorToSetLength, length ); } if ( defaultValue != 0 ) { setDefaultValue( defaultValue ); } }

sample: 1436
buggy_code: public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions) { this.yieldSignal = requireNonNull(yieldSignal, "yieldSignal is null"); this.blocks = requireNonNull(page, "page is null").getBlocks(); this.selectedPositions = requireNonNull(selectedPositions, "selectedPositions is null"); this.nextIndexOrPosition = selectedPositions.getOffset(); if (selectedPositions.isList()) { this.positions = selectedPositions.getPositions(); } else { this.positions = null; <START> } <END> }
code_review: Don't precompute `selectedPositions.getPositions`. It is unnecessary. And it makes the code harder to follow.
target code: public InterpretedPageProjectionOutput ( DriverYieldSignal yieldSignal , Page page , SelectedPositions selectedPositions ) { this . yieldSignal = requireNonNull ( yieldSignal , "yieldSignal is null" ) ; this . blocks = requireNonNull ( page , "page is null" ) . getBlocks ( ) ; this . selectedPositions = requireNonNull ( selectedPositions , "selectedPositions is null" ) ; this . nextIndexOrPosition = selectedPositions . getOffset ( ) ; }
response: public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions) { this.yieldSignal = requireNonNull(yieldSignal, "yieldSignal is null"); this.blocks = requireNonNull(page, "page is null").getBlocks(); this.selectedPositions = requireNonNull(selectedPositions, "selectedPositions is null"); this.nextIndexOrPosition = selectedPositions.getOffset(); if (selectedPositions.isList()) { this.positions = selectedPositions.getPositions(); } else { this.positions = null; <START> } <END> }

sample: 1437
buggy_code: public String getDicomViewerUrl(Study study) { if (study == null) throw new IllegalArgumentException("study cannot be null"); else if (study.getStudyInstanceUid() == null) throw new IllegalArgumentException("studyInstanceUid cannot be null"); <START> return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + "studyUID=" <END> + study.getStudyInstanceUid() : null; }
code_review: this ternary will not behave as stated in the 1. should annotation
target code: public String getDicomViewerUrl ( Study study ) { if ( study == null ) throw new IllegalArgumentException ( "study cannot be null" ) ; else if ( study . getStudyInstanceUid ( ) == null ) throw new IllegalArgumentException ( "studyInstanceUid cannot be null" ) ; return radiologyProperties . getDicomViewerUrl ( ) + "studyUID = " + study . getStudyInstanceUid ( ) ; }
response: public String getDicomViewerUrl(Study study) { if (study == null) throw new IllegalArgumentException("study cannot be null"); else if (study.getStudyInstanceUid() == null) throw new IllegalArgumentException("studyInstanceUid cannot be null"); <START> return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + "studyUID=" + study.getStudyInstanceUid() : null; <END> }

sample: 1438
buggy_code: private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) { <START> Declaration declFromXpath = null; <END> if (!isXPath && pattern.hasXPath()) { Declaration xPathDecl = pattern.getXPathDeclaration(); if (xPathDecl != null) { for ( Declaration decl : constraint.getRequiredDeclarations() ) { if (xPathDecl.equals( decl )) { declFromXpath = decl; break; } } } } return declFromXpath; }
code_review: ..and change as well the variable name `declFromXpath` to `declCorrXpath` also here.
target code: private Declaration getDeclarationCorrespondingToXpath ( Pattern pattern , boolean isXPath , Constraint constraint ) { if ( ! isXPath && pattern . hasXPath ( ) ) { Declaration xPathDecl = pattern . getXPathDeclaration ( ) ; if ( xPathDecl != null ) { for ( Declaration decl : constraint . getRequiredDeclarations ( ) ) { if ( xPathDecl . equals ( decl ) ) { return decl ; } } } } return null ; }
response: private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) { <START> Declaration declCorrXpath = null; <END> if (!isXPath && pattern.hasXPath()) { Declaration xPathDecl = pattern.getXPathDeclaration(); if (xPathDecl != null) { for ( Declaration decl : constraint.getRequiredDeclarations() ) { if (xPathDecl.equals( decl )) { declCorrXpath = decl; break; } } } } return declCorrXpath; }

sample: 1439
buggy_code: public void setQueryTimeout( int seconds ) throws AlreadyClosedSqlException, <START> InvalidParameterSqlException, <END> SQLException { throwIfClosed(); super.setQueryTimeout(seconds); }
code_review: the parent setQueryTimeout will throw a SQLException if the parameter is invalid, so this method now no longer throws an InvalidParameterSqlException
target code: public void setQueryTimeout ( int seconds ) throws AlreadyClosedSqlException , SQLException { throwIfClosed ( ) ; super . setQueryTimeout ( seconds ) ; }
response: public void setQueryTimeout( int seconds ) throws AlreadyClosedSqlException, <START> SQLException <END> { throwIfClosed(); super.setQueryTimeout(seconds); }

sample: 1440
buggy_code: private List<Disk> manualAggregateSnapshots() { List<Disk> <START> Param = <END> new ArrayList<>(); DiskImage diskWithSnaps = diskWithSnapshots; diskWithSnaps.getSnapshots().addAll(snapshotsList); Param.add(diskWithSnapshots); Param.add(diskWithoutSnapshots); Param.add(ovfImage); Param.add(cinderDisk); return Param; }
code_review: Please use Java conventions - param
target code: private List < DiskImage > manualAggregateSnapshots ( ) { DiskImage diskWithSnaps = diskWithSnapshots ; diskWithSnaps . getSnapshots ( ) . addAll ( snapshotsList ) ; return Arrays . asList ( diskWithSnapshots , diskWithoutSnapshots , ovfImage , cinderDisk ) ; }
response: private List<Disk> manualAggregateSnapshots() { List<Disk> <START> param = <END> new ArrayList<>(); DiskImage diskWithSnaps = diskWithSnapshots; diskWithSnaps.getSnapshots().addAll(snapshotsList); param.add(diskWithSnapshots); param.add(diskWithoutSnapshots); param.add(ovfImage); param.add(cinderDisk); return param; }

sample: 1441
buggy_code: public IndexingConfigurationBuilder autoConfig(boolean autoConfig) { <START> enable(); <END> attributes.attribute(AUTO_CONFIG).set(autoConfig); return this; }
code_review: Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true?
target code: public IndexingConfigurationBuilder autoConfig ( boolean autoConfig ) { if ( autoConfig ) enable ( ) ; attributes . attribute ( AUTO_CONFIG ) . set ( autoConfig ) ; return this ; }
response: public IndexingConfigurationBuilder autoConfig(boolean autoConfig) { <START> if (autoConfig) enable(); <END> attributes.attribute(AUTO_CONFIG).set(autoConfig); return this; }

sample: 1442
buggy_code: private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) { return <START> CollectionUtils .isNotEmpty(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, <END> VmDeviceGeneralType.HOSTDEV, vfName)); }
code_review: dao will return either an empty list or populated one, but never null.
target code: private boolean shouldBeDirectlyAttached ( String vfName , Guid vmId ) { return ! vmDeviceDao . getVmDeviceByVmIdTypeAndDevice ( vmId , VmDeviceGeneralType . HOSTDEV , vfName ) . isEmpty ( ) ; }
response: private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) { return <START> !vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, <END> VmDeviceGeneralType.HOSTDEV, vfName).isEmpty(); }

sample: 1443
buggy_code: <START> private void safeCloseStream(Closeable stream) { <END> if (stream != null) { try { stream.close(); } catch (IOException e) { // swallow error in this case Logger.e(TAG, "Failed to close the stream: ", "", ADALError.IO_EXCEPTION, e); } } }
code_review: static
target code: private static void safeCloseStream ( Closeable stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { // swallow error in this case Logger . e ( TAG , "Failed to close the stream : " , "" , ADALError . IO_EXCEPTION , e ) ; } } }
response: <START> private static void safeCloseStream(Closeable stream) { <END> if (stream != null) { try { stream.close(); } catch (IOException e) { // swallow error in this case Logger.e(TAG, "Failed to close the stream: ", "", ADALError.IO_EXCEPTION, e); } } }

sample: 1444
buggy_code: public static String zkSecuritySysConfigString() { String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM); String clientEnabled = System.getProperty(ZK_SASL_CLIENT); <START> String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY); <END> return "[" + JAVA_LOGIN_CONFIG_PARAM + "=" + loginConfig + ", " + ZK_SASL_CLIENT + "=" + (clientEnabled == null ? "default:" + DEFAULT_ZK_SASL_CLIENT : clientEnabled) + ", " + ZK_LOGIN_CONTEXT_NAME_KEY + "=" + (contextName == null ? "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME : contextName) + "]"; }
code_review: How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
target code: public static String zkSecuritySysConfigString ( ) { String loginConfig = System . getProperty ( JAVA_LOGIN_CONFIG_PARAM ) ; String clientEnabled = System . getProperty ( ZK_SASL_CLIENT , "default : " + DEFAULT_ZK_SASL_CLIENT ) ; String contextName = System . getProperty ( ZK_LOGIN_CONTEXT_NAME_KEY , "default : " + DEFAULT_ZK_LOGIN_CONTEXT_NAME ) ; return " [ " + JAVA_LOGIN_CONFIG_PARAM + " = " + loginConfig + " , " + ZK_SASL_CLIENT + " = " + clientEnabled + " , " + ZK_LOGIN_CONTEXT_NAME_KEY + " = " + contextName + " ] " ; }
response: public static String zkSecuritySysConfigString() { String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM); String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); <START> String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); <END> return "[" + JAVA_LOGIN_CONFIG_PARAM + "=" + loginConfig + ", " + ZK_SASL_CLIENT + "=" + clientEnabled + ", " + ZK_LOGIN_CONTEXT_NAME_KEY + "=" + contextName + "]"; }

sample: 1445
buggy_code: <START> public void updateNode(final @Nonnull Node node) throws IOException { <END> if (node == nodes.get(node.getNodeName())) { Queue.withLock(new Runnable() { @Override public void run() { jenkins.trimLabels(); } }); persistNode(node); } }
code_review: I would recommend returning a boolean, `true` for a successful update and `false` for the "no-op" case
target code: public boolean updateNode ( final @Nonnull Node node ) throws IOException { if ( node == nodes . get ( node . getNodeName ( ) ) ) { Queue . withLock ( new Runnable ( ) { @Override public void run ( ) { jenkins . trimLabels ( ) ; } } ) ; persistNode ( node ) ; return true ; } return false ; }
response: <START> public boolean updateNode(final @Nonnull Node node) throws IOException { <END> if (node == nodes.get(node.getNodeName())) { Queue.withLock(new Runnable() { @Override public void run() { jenkins.trimLabels(); } }); persistNode(node); return true; } return false; }

sample: 1446
buggy_code: public void onSaveInstanceState(Bundle outState) { <START> if (backStack != null) { <END> // update the topmost entry in the backstack updateCurrentBackStackItem(); outState.putParcelableArrayList("backStack", backStack); } }
code_review: The rest of this class expects backStack to be nonnull. I recommend we initialize backStack to an empty mutable list and specify @NonNull in the setter.
target code: public void onSaveInstanceState ( Bundle outState ) { // update the topmost entry in the back stack updateCurrentBackStackItem ( ) ; outState . putParcelableArrayList ( "backStack" , backStack ) ; }
response: public void onSaveInstanceState(Bundle outState) { <START> // update the topmost entry in the backstack updateCurrentBackStackItem(); outState.putParcelableArrayList("backStack", backStack); <END> }

sample: 1447
buggy_code: public Trader(String name, double cashInHand) { <START> super(); <END> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }
code_review: Is this necessary?
target code: public Trader ( String name , double cashInHand ) { // super ( ) ; this . name = name ; this . cashInHand = cashInHand ; this . position = new ArrayList < Order > ( ) ; this . ordersPlaced = new ArrayList < Order > ( ) ; }
response: public Trader(String name, double cashInHand) { <START> super(); <END> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }

sample: 1448
buggy_code: <START> private Iterable<ITask> getTasksAssosciatedWithReviewTask(ITask reviewTask) { <END> String lookupUrl = reviewTask.getUrl(); // TODO: Fetch from mapping with the lookupUrl String taskUrl = "http://someurl"; AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager() .getConnectorForRepositoryTaskUrl(taskUrl); String taskId = repository.getTaskIdFromTaskUrl(taskUrl); String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl); ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId); if (assosciatedTask == null) { return Collections.emptyList(); } return ImmutableSet.of(assosciatedTask); }
code_review: There can only be one associated task.
target code: private ITask getTasksAssosciatedWithReviewTask ( ITask reviewTask ) { String lookupUrl = reviewTask . getUrl ( ) ; // TODO : Fetch from mapping with the lookupUrl String taskUrl = "http :/ / someurl" ; AbstractRepositoryConnector repository = TasksUiPlugin . getRepositoryManager ( ) . getConnectorForRepositoryTaskUrl ( taskUrl ) ; String taskId = repository . getTaskIdFromTaskUrl ( taskUrl ) ; String repositoryUrl = repository . getRepositoryUrlFromTaskUrl ( taskUrl ) ; ITask assosciatedTask = taskList . getTask ( repositoryUrl , taskId ) ; return assosciatedTask ; }
response: <START> private ITask getTasksAssosciatedWithReviewTask(ITask reviewTask) { <END> String lookupUrl = reviewTask.getUrl(); // TODO: Fetch from mapping with the lookupUrl String taskUrl = "http://someurl"; AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager() .getConnectorForRepositoryTaskUrl(taskUrl); String taskId = repository.getTaskIdFromTaskUrl(taskUrl); String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl); ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId); return assosciatedTask; }

sample: 1449
buggy_code: <START> protected void toLegacyText(StringBuilder builder) <END> { builder.append(this.value); }
code_review: Override
target code: protected void toLegacyText ( StringBuilder builder ) { builder . append ( this . value ) ; super . toLegacyText ( builder ) ; }
response: <START> protected void toLegacyText(StringBuilder builder) <END> { builder.append(this.value); }

sample: 1450
buggy_code: <START> public static boolean isRoute(URL url) { <END> return ROUTE_PROTOCOL.equals(url.getProtocol()) || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY)); }
code_review: `public static boolean isRoute(final URL url)`
target code: public static boolean isRoute ( URL url ) { return ROUTE_PROTOCOL . equals ( url . getProtocol ( ) ) || ROUTERS_CATEGORY . equals ( url . getParameter ( CATEGORY_KEY , DEFAULT_CATEGORY ) ) ; }
response: <START> public static boolean isRoute(final URL url) { <END> return ROUTE_PROTOCOL.equals(url.getProtocol()) || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY)); }

sample: 1451
buggy_code: void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); // Busy loop. int[] vs2; <START> synchronized (lock) { <END> vs2 = values; } int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); }
code_review: I would delete this synchronized block. Values cannot be modified while we're reading it since we already saw state as 2. It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that.
target code: void thread2 ( ) { int [ ] vs1 ; synchronized ( lock ) { vs1 = values ; state = 1 ; } int s ; do { synchronized ( lock ) { s = state ; } } while ( s != 2 ) ; // Busy loop . int [ ] vs2 = values ; int v1 = vs1 [ 0 ] ; int v2 = vs2 [ 0 ] ; System . out . println ( "b17689750TestMonitor failed : " + v1 + " , " + v2 ) ; }
response: void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); // Busy loop. int[] vs2; <START> synchronized (lock) { <END> vs2 = values; } int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); }

sample: 1452
buggy_code: public void testWriteAndReadObject() throws Exception { <START> InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); <END> String expected = "test input"; String actual = (String) writeAndReadObject(serializationService, expected); assertNotNull(actual); assertEquals(expected, actual); }
code_review: Isn't it easier to have the serializationService as a field on this test? Are there any serializationServices created with different settings? Having it as field instead of local variable, will simplify the test methods.
target code: public void testWriteAndReadObject ( ) throws Exception { String expected = "test input" ; String actual = ( String ) writeAndReadObject ( expected ) ; assertNotNull ( actual ) ; assertEquals ( expected , actual ) ; }
response: public void testWriteAndReadObject() throws Exception { <START> InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); <END> String expected = "test input"; String actual = (String) writeAndReadObject(serializationService, expected); assertNotNull(actual); assertEquals(expected, actual); }

sample: 1453
buggy_code: public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } final ArArchiveEntry other = (ArArchiveEntry) obj; if (name == null) { return other.name == null; <START> } else return name.equals(other.name); <END> }
code_review: please add braces for the else block.
target code: public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } final ArArchiveEntry other = ( ArArchiveEntry ) obj ; if ( name == null ) { return other . name == null ; } else { return name . equals ( other . name ) ; } }
response: public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } final ArArchiveEntry other = (ArArchiveEntry) obj; if (name == null) { return other.name == null; <START> } else { return name.equals(other.name); <END> } }

sample: 1454
buggy_code: public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) { if (bufferList == null || bufferList.isEmpty()) { throw new IllegalArgumentException("Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"); } <START> buffers = new ArrayList<>(bufferList); <END> size = computeSize(bufferList); }
code_review: why do you need to wrap it in a new `ArrayList`? Seems wasteful.
target code: public ByteBufferReadableStreamChannel ( List < ByteBuffer > bufferList ) { if ( bufferList == null || bufferList . isEmpty ( ) ) { throw new IllegalArgumentException ( "Input List of ByteBuffer cannot be null / empty for ByteBufferReadableStreamChannel" ) ; } buffers = bufferList ; size = computeSize ( bufferList ) ; }
response: public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) { if (bufferList == null || bufferList.isEmpty()) { throw new IllegalArgumentException("Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"); } <START> buffers = bufferList; <END> size = computeSize(bufferList); }

sample: 1455
buggy_code: boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces, final List<VdsNetworkInterface> allInterfacesForVds) { for (final VmNetworkInterface vmIf : vmNetworkInterfaces) { boolean found = false; for (final VdsNetworkInterface vdsIf : allInterfacesForVds) { if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) { found = true; break; } } if (!found) { <START> log.debug("VDS is not ok for running the VM as network is missing"); <END> return false; } } return true; }
code_review: I don't know if it's necessary to log this message for each host, since for other unmet conditions we don't log anything. If it looks necessary to you then at least VDS ID would be helpful to know (assuming VM ID is already printed elsewehere).
target code: boolean areRequiredNetworksAvailable ( final List < VmNetworkInterface > vmNetworkInterfaces , final List < VdsNetworkInterface > allInterfacesForVds ) { for ( final VmNetworkInterface vmIf : vmNetworkInterfaces ) { boolean found = false ; for ( final VdsNetworkInterface vdsIf : allInterfacesForVds ) { if ( StringUtils . equals ( vmIf . getNetworkName ( ) , vdsIf . getNetworkName ( ) ) ) { found = true ; break ; } } if ( ! found ) { return false ; } } return true ; }
response: boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces, final List<VdsNetworkInterface> allInterfacesForVds) { for (final VmNetworkInterface vmIf : vmNetworkInterfaces) { boolean found = false; for (final VdsNetworkInterface vdsIf : allInterfacesForVds) { if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) { found = true; break; } } if (!found) { <START> log.debug("VDS is not ok for running the VM as network is missing"); <END> return false; } } return true; }

sample: 1456
buggy_code: public void testStash() { try { // 1) call stash create command git.stashCreate().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); // 2) call stash list git.stashList().call(); // 3) apply stash git.stashApply().call(); // 4) verify stash applied by outputting file readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); <START> } catch (Exception e) { <END> e.printStackTrace(); } }
code_review: Never catch exceptions in test code unless you actually want to do something use. Just declare that this method throws Exception
target code: public void testStash ( ) throws Exception { // 1 ) call stash create command git . stashCreate ( ) . call ( ) ; readFile ( "Stash Created" , git . getRepository ( ) . getWorkTree ( ) + " / File1 . txt" ) ; // 2 ) call stash list git . stashList ( ) . call ( ) ; // 3 ) apply stash git . stashApply ( ) . call ( ) ; // 4 ) verify stash applied by outputting file readFile ( "Stash Created" , git . getRepository ( ) . getWorkTree ( ) + " / File1 . txt" ) ; }
response: public void testStash() throws Exception { // 1) call stash create command git.stashCreate().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); // 2) call stash list git.stashList().call(); // 3) apply stash git.stashApply().call(); // 4) verify stash applied by outputting file readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); <START> }

sample: 1457
buggy_code: public List<WorkerInfo> getWorkerInfoList() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } try { return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY); } catch (ExecutionException e) { <START> throw new UnavailableException("Unable to get worker info list from cache"); <END> } }
code_review: Can we include the information from `e` in this exception message?
target code: public List < WorkerInfo > getWorkerInfoList ( ) throws UnavailableException { if ( mSafeModeManager . isInSafeMode ( ) ) { throw new UnavailableException ( ExceptionMessage . MASTER_IN_SAFEMODE . getMessage ( ) ) ; } try { return mWorkerInfoCache . get ( WORKER_INFO_CACHE_KEY ) ; } catch ( ExecutionException e ) { throw new UnavailableException ( "Unable to get worker info list from cache" , e ) ; } }
response: public List<WorkerInfo> getWorkerInfoList() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } try { return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY); } catch (ExecutionException e) { <START> throw new UnavailableException("Unable to get worker info list from cache", e); <END> } }

sample: 1458
buggy_code: public static void tearDownTestCase() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } }
code_review: Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
target code: public static void tearDownTestCase ( ) throws Exception { }
response: public static void tearDownTestCase() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } } public void tearDown() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } }

sample: 1459
buggy_code: public void checkSelectFilter(final String label, final String value) { selectInputs.computeIfPresent(label, (key, values) -> { values.forEach(i -> { <START> if ((i.getValue().equals(value) || i.getValue() == value) && i.getChecked() == false) { <END> i.setChecked(true); } }); return values; }); }
code_review: Why do we have equality check here? it should have been done by the equals.
target code: public void checkSelectFilter ( final String label , final String value ) { selectInputs . computeIfPresent ( label , ( key , values ) - > { values . forEach ( i - > { if ( i . getValue ( ) . equals ( value ) && i . getChecked ( ) == false ) { i . setChecked ( true ) ; } } ) ; return values ; } ) ; }
response: public void checkSelectFilter(final String label, final String value) { selectInputs.computeIfPresent(label, (key, values) -> { values.forEach(i -> { <START> if (i.getValue().equals(value) && i.getChecked() == false) { <END> i.setChecked(true); } }); return values; }); }

sample: 1460
buggy_code: public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) { <START> super(); <END> this.storageJobId = storageJobId; this.subchainInfo = subchainInfo; }
code_review: needed?
target code: public ColdMergeVDSCommandParameters ( Guid storageJobId , SubchainInfo subchainInfo ) { this . storageJobId = storageJobId ; this . subchainInfo = subchainInfo ; }
response: public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) { <START> super(); <END> this.storageJobId = storageJobId; this.subchainInfo = subchainInfo; }

sample: 1461
buggy_code: private void putResize (K key, V value) { K[] keyTable = this.keyTable; V[] valueTable = this.valueTable; for (int i = place(key); ; i = (i + 1) & mask) { // space is available so we insert and break (resize is later) if (keyTable[i] == null) { keyTable[i] = key; valueTable[i] = value; break; } } <START> if (++size >= threshold) { <END> resize(keyTable.length << 1); } }
code_review: I think we don't need to check this, as we know that the resize will not result in the threshold being exceeded.
target code: private void putResize ( K key , V value ) { K [ ] keyTable = this . keyTable ; V [ ] valueTable = this . valueTable ; for ( int i = place ( key ) ; ; i = ( i + 1 ) & mask ) { // space is available so we insert and break if ( keyTable [ i ] == null ) { keyTable [ i ] = key ; valueTable [ i ] = value ; break ; } } ++ size ; }
response: private void putResize (K key, V value) { K[] keyTable = this.keyTable; V[] valueTable = this.valueTable; for (int i = place(key); ; i = (i + 1) & mask) { // space is available so we insert and break (resize is later) if (keyTable[i] == null) { keyTable[i] = key; valueTable[i] = value; break; } } <START> resize(keyTable.length << 1); <END> }

sample: 1462
buggy_code: protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() { public void onSuccess(final ProjectDetail result) { enableForm(true); display(result); <START> addPanel.setVisible(result.canModifyData); <END> delRight.setVisible(result.canModifyData); } }); }
code_review: This isn't canModifyData. I think you've overloaded the variable for too many meanings. What we need is: * canModifyDescription * canModifyMergeType * canModifyAgreements * canModifyAccess The first 3 are true only if projectControl.isOwner() is true. The last one is true if projectControl.isOwnerAnyRef() is true, and is what you want to be using here for addPanel.
target code: protected void onLoad ( ) { enableForm ( false ) ; super . onLoad ( ) ; Util . PROJECT_SVC . projectDetail ( projectName , new GerritCallback < ProjectDetail > ( ) { public void onSuccess ( final ProjectDetail result ) { enableForm ( true ) ; display ( result ) ; } } ) ; }
response: protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() { public void onSuccess(final ProjectDetail result) { enableForm(true); display(result); <START> addPanel.setVisible(result.canModifyData); <END> delRight.setVisible(result.canModifyData); } }); }

sample: 1463
buggy_code: public static EncodeFormat checkedValueOf(String name) { try { <START> return Enum.valueOf(EncodeFormat.class, name); <END> } catch (Exception ex) { VoltDB.crashLocalVoltDB("Illegal encoding format " + name, true, ex); } return null; }
code_review: Why not use `EncodeFormat.valueOf`
target code: public static EncodeFormat checkedValueOf ( String name ) { try { return valueOf ( EncodeFormat . class , name ) ; } catch ( Exception ex ) { VoltDB . crashLocalVoltDB ( "Illegal encoding format " + name , true , ex ) ; } return null ; }
response: public static EncodeFormat checkedValueOf(String name) { try { <START> return EncodeFormat.valueOf(name); <END> } catch (Exception ex) { VoltDB.crashLocalVoltDB("Illegal encoding format " + name, true, ex); } return null; }

sample: 1464
buggy_code: public Set<K> keySet(Predicate predicate) { checkNotNull(predicate, "Predicate cannot be null!"); Set<K> resultingSet = new HashSet<K>(); Set<QueryableEntry> query = indexes.query(predicate); if (query != null) { for (QueryableEntry entry : query) { <START> K key = (K) serializationService.toObject(entry.getKeyData()); <END> resultingSet.add(key); } } else { doFullKeyScan(predicate, resultingSet); } return resultingSet; }
code_review: Minor: there is a shortcut `toObject()` method for doing the deserialization in this class and in `DefaultQueryCache`. Maybe that should be used to be consistent at all places.
target code: public Set < K > keySet ( Predicate predicate ) { checkNotNull ( predicate , "Predicate cannot be null ! " ) ; Set < K > resultingSet = new HashSet < K > ( ) ; Set < QueryableEntry > query = indexes . query ( predicate ) ; if ( query != null ) { for ( QueryableEntry entry : query ) { K key = toObject ( entry . getKeyData ( ) ) ; resultingSet . add ( key ) ; } } else { doFullKeyScan ( predicate , resultingSet ) ; } return resultingSet ; }
response: public Set<K> keySet(Predicate predicate) { checkNotNull(predicate, "Predicate cannot be null!"); Set<K> resultingSet = new HashSet<K>(); Set<QueryableEntry> query = indexes.query(predicate); if (query != null) { for (QueryableEntry entry : query) { <START> K key = (K) entry.getKey(); <END> resultingSet.add(key); } } else { doFullKeyScan(predicate, resultingSet); } return resultingSet; }

sample: 1465
buggy_code: public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter(); oo.setMyLocations(new HashSet<>()); <START> Assertions.assertThrows(APIException.class,() ->RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField("locations"))); <END> }
code_review: also a tiny thing, but sometimes you miss a whitespace after the `->`
target code: public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound ( ) throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter ( ) ; oo . setMyLocations ( new HashSet < > ( ) ) ; RequiredDataAdvice . getChildCollection ( oo , ClassWithBadGetter . class . getDeclaredField ( "locations" ) ) ; }
response: public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter(); oo.setMyLocations(new HashSet<>()); <START> Assertions.assertThrows(APIException.class,() -> RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField("locations"))); <END> }

sample: 1466
buggy_code: protected void configure() { <START> DynamicSet.setOf(binder(), CacheRemovalListener.class); <END> install(new FactoryModule() { @Override protected void configure() { factory(ForwardingRemovalListener.Factory.class); } }); bind(DefaultCacheFactory.class); bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class); bind(PersistentCacheFactory.class).to(H2CacheFactory.class); listener().to(H2CacheFactory.class); }
code_review: This should be declared in GerritGlobalModule.
target code: protected void configure ( ) { install ( new FactoryModule ( ) { @Override protected void configure ( ) { factory ( ForwardingRemovalListener . Factory . class ) ; } } ) ; bind ( DefaultCacheFactory . class ) ; bind ( MemoryCacheFactory . class ) . to ( DefaultCacheFactory . class ) ; bind ( PersistentCacheFactory . class ) . to ( H2CacheFactory . class ) ; listener ( ) . to ( H2CacheFactory . class ) ; }
response: protected void configure() { DynamicSet.setOf(binder(), CacheRemovalListener.class); install(new FactoryModule() { @Override protected void configure() { factory(ForwardingRemovalListener.Factory.class); } }); bind(DefaultCacheFactory.class); bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class); bind(PersistentCacheFactory.class).to(H2CacheFactory.class); listener().to(H2CacheFactory.class); }

sample: 1467
buggy_code: private void createDisabledImage() { <START> if (this.disabledImage != null && !this.disabledImage.isDisposed()) <END> disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); }
code_review: This doesn't seem right: we're building `disabledImage` from `image`, so we need to check that `image` has not been disabled. I think something like the following? if (this.image != null && !this.image.isDisposed()) { if (this.disabledImage != null && !this.disabledImage.isDisposed()) { this.disabledImage.dispose(); } disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); }
target code: private void createDisabledImage ( ) { // Only create a new disabledImage when the disabledImage == null or // disposed to avoid a GDI Handler leak See Bug 486531 if ( this . disabledImage == null || this . disabledImage . isDisposed ( ) ) if ( this . image != null && ! this . image . isDisposed ( ) ) disabledImage = new Image ( this . image . getDevice ( ) , this . image , SWT . IMAGE_DISABLE ) ; }
response: private void createDisabledImage() { if (this.image != null && !this.image.isDisposed()) { if (this.disabledImage != null && !this.disabledImage.isDisposed()) { this.disabledImage.dispose(); } disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); } }

sample: 1468
buggy_code: public synchronized void releaseSample(DecoderInputBuffer sample) { <START> sample.data.clear(); <END> mSamplePool.offerLast(sample); }
code_review: Should probably be sample.clear().
target code: public synchronized void releaseSample ( DecoderInputBuffer sample ) { sample . clear ( ) ; mSamplePool . offerLast ( sample ) ; }
response: public synchronized void releaseSample(DecoderInputBuffer sample) { <START> sample.clear(); <END> mSamplePool.offerLast(sample); }

sample: 1469
buggy_code: private String buildClipboardMessage(Row row) { <START> StringBuilder builder = new StringBuilder(); <END> builder.append(row.getLevel()) .append(", ") .append(row.getMessage()); return builder.toString(); }
code_review: Looks like this builder just concatenate 3 strings without any loops. I guess, it is unnecessary here.
target code: private String buildClipboardMessage ( Row row ) { return row . getLevel ( ) + " , " + row . getMessage ( ) ; }
response: private String buildClipboardMessage(Row row) { <START> StringBuilder builder = new StringBuilder(); <END> builder.append(row.getLevel()) .append(", ") .append(row.getMessage()); return builder.toString(); }

sample: 1470
buggy_code: <START> public RepositoryObject getParent() { <END> return driver.getParentObject(this); }
code_review: Since a Tombstone is no longer in the hierarchy (result of removing the proxy), this method should probably either return a null or throw an exception
target code: public RepositoryObject getParent ( ) { // tombstone is not in the hierarchy , so doesn't have a parent return null ; }
response: <START> public RepositoryObject getParent() { <END> return null; }

sample: 1471
buggy_code: private void setLastUsedBranch() { String lastBranch = settings.get(lastBranchKey); <START> if (lastBranch != null) { <END> branchText.setText(lastBranch); } }
code_review: no braces here, more occurrences in this file
target code: private void setLastUsedBranch ( ) { String lastBranch = settings . get ( lastBranchKey ) ; if ( lastBranch != null ) branchText . setText ( lastBranch ) ; }
response: private void setLastUsedBranch() { String lastBranch = settings.get(lastBranchKey); <START> if (lastBranch != null) <END> branchText.setText(lastBranch); }

sample: 1472
buggy_code: public String toString() { return toStringHelper(this) .omitNullValues() <START> .add("equiCriteria", this.equiCriteria) <END> .add("filter", filter.orElse(null)) .toString(); }
code_review: `this` is not needed?
target code: public String toString ( ) { return toStringHelper ( this ) . omitNullValues ( ) . add ( "equiCriteria" , equiCriteria ) . add ( "filter" , filter . orElse ( null ) ) . toString ( ) ; }
response: public String toString() { return toStringHelper(this) .omitNullValues() <START> .add("equiCriteria", equiCriteria) <END> .add("filter", filter.orElse(null)) .toString(); }

sample: 1473
buggy_code: private void validateKeyPatternsInConfig(Dictionary<String, ?> config) { Enumeration<String> keys = config.keys(); while (keys.hasMoreElements()) { String key = keys.nextElement(); // the config-key enumeration contains additional keys that we // don't want to process here ... if ("service.pid".equals(key)) { continue; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key); if (!matcher.matches()) { logger.error("Given plugwise-config-key '" + key <START> + "' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"); <END> continue; } } }
code_review: Seems more appropriately `logger.warn`.
target code: private void validateKeyPatternsInConfig ( Dictionary < String , ? > config ) { Enumeration < String > keys = config . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = keys . nextElement ( ) ; // the config - key enumeration contains additional keys that we // don't want to process here . . . if ( "service . pid" . equals ( key ) ) { continue ; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN . matcher ( key ) ; if ( ! matcher . matches ( ) ) { logger . warn ( "Given plugwise - config - key '" + key + "' does not follow the expected pattern ' < PlugwiseId > . < mac|type|port|interval > '" ) ; continue ; } } }
response: private void validateKeyPatternsInConfig(Dictionary<String, ?> config) { Enumeration<String> keys = config.keys(); while (keys.hasMoreElements()) { String key = keys.nextElement(); // the config-key enumeration contains additional keys that we // don't want to process here ... if ("service.pid".equals(key)) { continue; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key); if (!matcher.matches()) { logger.warn("Given plugwise-config-key '" + key <START> + "' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"); <END> continue; } } }

sample: 1474
buggy_code: public Void visitFilter(FilterNode node, Void context) { <START> String expression = isExpression(node.getPredicate()) ? node.getPredicate().toString() : formatter.formatRowExpression(node.getPredicate()); <END> printNode(node, "Filter", expression, NODE_COLORS.get(NodeType.FILTER)); return node.getSource().accept(this, context); }
code_review: `GraphvizPrinter` (and all other plan printer) should not expect an `Expression`. Rather than having `isExpression` here, let's fix the tests if they are failing.
target code: public Void visitFilter ( FilterNode node , Void context ) { String expression = formatter . formatRowExpression ( node . getPredicate ( ) ) ; printNode ( node , "Filter" , expression , NODE_COLORS . get ( NodeType . FILTER ) ) ; return node . getSource ( ) . accept ( this , context ) ; }
response: public Void visitFilter(FilterNode node, Void context) { <START> String expression = formatter.formatRowExpression(node.getPredicate()); <END> printNode(node, "Filter", expression, NODE_COLORS.get(NodeType.FILTER)); return node.getSource().accept(this, context); }

sample: 1475
buggy_code: public void run() { resetGlobalProgress(); indexingAll = true; for (ObjectType objectType : ObjectType.values()) { startIndexing(objectType); } try { sleep(pause); } catch (InterruptedException e) { <START> Thread.currentThread().interrupt(); <END> logger.error("Thread interrupted: " + e.getMessage()); } currentIndexState = ObjectType.NONE; indexingAll = false; pollingChannel.send(INDEXING_FINISHED_MESSAGE); }
code_review: Move this line after logging the error, so in any case the error get logged.
target code: public void run ( ) { resetGlobalProgress ( ) ; indexingAll = true ; for ( ObjectType objectType : ObjectType . values ( ) ) { startIndexing ( objectType ) ; } try { sleep ( pause ) ; } catch ( InterruptedException e ) { logger . error ( "Thread interrupted : " + e . getMessage ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; } currentIndexState = ObjectType . NONE ; indexingAll = false ; pollingChannel . send ( INDEXING_FINISHED_MESSAGE ) ; }
response: public void run() { resetGlobalProgress(); indexingAll = true; for (ObjectType objectType : ObjectType.values()) { startIndexing(objectType); } try { sleep(pause); } catch (InterruptedException e) { <START> logger.error("Thread interrupted: " + e.getMessage()); Thread.currentThread().interrupt(); <END> } currentIndexState = ObjectType.NONE; indexingAll = false; pollingChannel.send(INDEXING_FINISHED_MESSAGE); }

sample: 1476
buggy_code: public boolean isAC3() { <START> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".equals(getCodecA()) || "liba52".equals(getCodecA())); <END> }
code_review: `return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));`
target code: public boolean isAC3 ( ) { return getCodecA ( ) != null && ( "ac3" . equals ( getCodecA ( ) ) || getCodecA ( ) . contains ( "a52" ) ) ; }
response: public boolean isAC3() { <START> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA())); <END> }

sample: 1477
buggy_code: ShardRewriter createShardRewriter( FileSystemContext fileSystemContext, FileSystem fileSystem, long transactionId, OptionalInt bucketNumber, UUID shardUuid, int shardRowCount, Optional<UUID> deltaShardUuid, boolean tableSupportsDeltaDelete, Map<String, Type> columns) { if (tableSupportsDeltaDelete) { return new DeltaShardRewriter( shardUuid, shardRowCount, deltaShardUuid, deletionExecutor, transactionId, bucketNumber, this, fileSystemContext, fileSystem); } <START> else { <END> return new InplaceShardRewriter( shardUuid, columns, deletionExecutor, transactionId, bucketNumber, nodeId, this, fileSystem, storageService, shardRecorder, backupManager); } }
code_review: redundant
target code: ShardRewriter createShardRewriter ( FileSystemContext fileSystemContext , FileSystem fileSystem , long transactionId , OptionalInt bucketNumber , UUID shardUuid , int shardRowCount , Optional < UUID > deltaShardUuid , boolean tableSupportsDeltaDelete , Map < String , Type > columns ) { if ( tableSupportsDeltaDelete ) { return new DeltaShardRewriter ( shardUuid , shardRowCount , deltaShardUuid , deletionExecutor , transactionId , bucketNumber , this , fileSystemContext , fileSystem ) ; } return new InplaceShardRewriter ( shardUuid , columns , deletionExecutor , transactionId , bucketNumber , nodeId , this , fileSystem , storageService , shardRecorder , backupManager ) ; }
response: ShardRewriter createShardRewriter( FileSystemContext fileSystemContext, FileSystem fileSystem, long transactionId, OptionalInt bucketNumber, UUID shardUuid, int shardRowCount, Optional<UUID> deltaShardUuid, boolean tableSupportsDeltaDelete, Map<String, Type> columns) { if (tableSupportsDeltaDelete) { return new DeltaShardRewriter( shardUuid, shardRowCount, deltaShardUuid, deletionExecutor, transactionId, bucketNumber, this, fileSystemContext, fileSystem); } <START> else { <END> return new InplaceShardRewriter( shardUuid, columns, deletionExecutor, transactionId, bucketNumber, nodeId, this, fileSystem, storageService, shardRecorder, backupManager); } }

sample: 1478
buggy_code: public void init() { setLabel("Plugin"); addAttribute(ID, ROLE_ID).setLabel("Identifier"); addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel("Label"); <START> addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel("Description").setDataType(HTML); <END> }
code_review: TEXT datatype would be more appropriate.
target code: public void init ( ) { setLabel ( "Plugin" ) ; addAttribute ( ID , ROLE_ID ) . setLabel ( "Identifier" ) ; addAttribute ( LABEL , ROLE_LABEL , ROLE_LOOKUP ) . setNillable ( false ) . setUnique ( true ) . setLabel ( "Label" ) ; addAttribute ( DESCRIPTION , ROLE_LOOKUP ) . setLabel ( "Description" ) ; }
response: public void init() { setLabel("Plugin"); addAttribute(ID, ROLE_ID).setLabel("Identifier"); addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel("Label"); <START> addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel("Description").setDataType(TEXT); <END> }

sample: 1479
buggy_code: <START> @Override public Long call() throws IOException{ <END> String oldname = Thread.currentThread().getName(); Thread.currentThread().setName(oldname+"Decode-"+this.parent.columnChunkMetaData.toString()); this.parent.processPages(recordsToReadInThisPass); Thread.currentThread().setName(oldname); return recordsToReadInThisPass; }
code_review: Space between IOException and {
target code: @Override public Long call ( ) throws IOException { String oldname = Thread . currentThread ( ) . getName ( ) ; try { Thread . currentThread ( ) . setName ( oldname + "Decode - " + this . parent . columnChunkMetaData . toString ( ) ) ; this . parent . processPages ( recordsToReadInThisPass ) ; return recordsToReadInThisPass ; } finally { Thread . currentThread ( ) . setName ( oldname ) ; } }
response: <START> @Override public Long call() throws IOException { <END> String oldname = Thread.currentThread().getName(); Thread.currentThread().setName(oldname+"Decode-"+this.parent.columnChunkMetaData.toString()); this.parent.processPages(recordsToReadInThisPass); Thread.currentThread().setName(oldname); return recordsToReadInThisPass; }

sample: 1480
buggy_code: public CompositeMetricsCollector(MetricsCollector... collectors) { <START> this.collectors = new ArrayList<>(asList(collectors)); <END> }
code_review: Does additional list creation (`new ArrayList<>()`) provide any benefits when compared with the following? ```java this.collectors = asList(collectors); ```
target code: public CompositeMetricsCollector ( MetricsCollector . . . collectors ) { this . collectors = asList ( collectors ) ; }
response: public CompositeMetricsCollector(MetricsCollector... collectors) { <START> this.collectors = asList(collectors); <END> }

sample: 1481
buggy_code: @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { loadContacts(); } else { <START> Toast.makeText(getApplicationContext(), "Read contacts permission denied", <END> Toast.LENGTH_LONG).show(); finish(); } } else { super.onRequestPermissionsResult(requestCode, permissions, grantResults); } }
code_review: to nitpick: just use `this` instead of the application.
target code: @Override public void onRequestPermissionsResult ( int requestCode , @NonNull String [ ] permissions , @NonNull int [ ] grantResults ) { if ( requestCode == REQUEST_READ_CONTACTS ) { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { loadContacts ( ) ; } else { Toast . makeText ( this , "Read contacts permission denied" , Toast . LENGTH_LONG ) . show ( ) ; finish ( ) ; } } else { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; } }
response: @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { loadContacts(); } else { <START> Toast.makeText(this, "Read contacts permission denied", <END> Toast.LENGTH_LONG).show(); finish(); } } else { super.onRequestPermissionsResult(requestCode, permissions, grantResults); } }

sample: 1482
buggy_code: private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) { StringBuilder fg= new StringBuilder(); appendColor(fg, fgRGB); StringBuilder bg= new StringBuilder(); appendColor(bg, bgRGB); <START> buffer.append("body {color:" + fg.toString() + "; background-color:" + bg.toString() + ";}"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ <END> }
code_review: I must be missing something. Why not simply buffer.append("body {color:"); appendColor(buffer, fgRGB); buffer.append("; background-color:"); appendColor(buffer, bgRGB); buffer.append(";}"); ?
target code: private static void appendBodyColorsRule ( StringBuilder buffer , RGB fgRGB , RGB bgRGB ) { StringBuilder fg = new StringBuilder ( ) ; appendColor ( fg , fgRGB ) ; StringBuilder bg = new StringBuilder ( ) ; appendColor ( bg , bgRGB ) ; buffer . append ( "body { color : " ) ; // $NON - NLS - 1$ appendColor ( buffer , fgRGB ) ; buffer . append ( " ; background - color : " ) ; // $NON - NLS - 1$ appendColor ( buffer , bgRGB ) ; buffer . append ( " ; } " ) ; // $NON - NLS - 1$ }
response: private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) { StringBuilder fg= new StringBuilder(); appendColor(fg, fgRGB); StringBuilder bg= new StringBuilder(); appendColor(bg, bgRGB); <START> buffer.append("body {color:"); appendColor(buffer, fgRGB); buffer.append("; background-color:"); appendColor(buffer, bgRGB); buffer.append(";}"); <END> }

sample: 1483
buggy_code: <START> public static synchronized VoltDBInterface instance() { <END> if (singleton == null) { singleton = new RealVoltDB(); } return singleton; }
code_review: what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this
target code: public static VoltDBInterface instance ( ) { return singleton ; }
response: <START> public static VoltDBInterface instance() { <END> if (singleton == null) { singleton = new RealVoltDB(); } return singleton; }

sample: 1484
buggy_code: public int getRenderState() { int state = speed.ordinal(); if (getReverse()) state = 14; if (isPowered()) { if (getReverse()) state += 1; else state += 7; <START> } <END> return state; }
code_review: You can simplify this by reordering the states.
target code: public int getRenderState ( ) { int state = speed . ordinal ( ) ; if ( getReverse ( ) ) state = 4 ; if ( isPowered ( ) ) state += 5 ; return state ; }
response: public int getRenderState() { int state = speed.ordinal(); if (getReverse()) state = 14; if (isPowered()) { if (getReverse()) state += 1; else state += 7; } <START> <END> return state; }

sample: 1485
buggy_code: public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception { doAnswer(invocation -> { <START> Errors errors = (Errors) invocation.getArgument(1); <END> errors.rejectValue("absenceSettings", "error"); return null; }).when(settingsValidator).validate(any(), any()); perform(post("/web/settings")) .andExpect(view().name("settings/settings_form")); }
code_review: Den cast auf (Errors) ist hier berflssig.
target code: public void ensureSettingsSavedShowsFormIfValidationFails ( ) throws Exception { doAnswer ( invocation - > { Errors errors = invocation . getArgument ( 1 ) ; errors . rejectValue ( "absenceSettings" , "error" ) ; return null ; } ) . when ( settingsValidator ) . validate ( any ( ) , any ( ) ) ; perform ( post ( " / web / settings" ) ) . andExpect ( view ( ) . name ( "settings / settings_form" ) ) ; }
response: public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception { doAnswer(invocation -> { <START> Errors errors = invocation.getArgument(1); <END> errors.rejectValue("absenceSettings", "error"); return null; }).when(settingsValidator).validate(any(), any()); perform(post("/web/settings")) .andExpect(view().name("settings/settings_form")); }

sample: 1486
buggy_code: private String extractConnectionKey(final iOSVariant iOSVariant) { final StringBuilder sb = new StringBuilder() <START> .append(iOSVariant.getVariantID()) <END> .append(iOSVariant.isProduction() ? "-prod" : "-dev"); return sb.toString(); }
code_review: I know this is not directly part of this PR, but this could be changed to `new StringBuilder(iOSVariant.getVariantID())` to avoid one useless `append` (the `StringBuilder()` constructor create StringBuilder with capacity 16, that we immediately expand with the next append)
target code: private String extractConnectionKey ( final iOSVariant iOSVariant ) { final StringBuilder sb = new StringBuilder ( iOSVariant . getVariantID ( ) ) . append ( iOSVariant . isProduction ( ) ? " - prod" : " - dev" ) ; return sb . toString ( ) ; }
response: private String extractConnectionKey(final iOSVariant iOSVariant) { final StringBuilder sb = new StringBuilder(iOSVariant.getVariantID()) <START> .append(iOSVariant.isProduction() ? "-prod" : "-dev"); return sb.toString(); }

sample: 1487
buggy_code: public void printCertificates() { DefaultTable table = new DefaultTable(); for (int i = 0; i < table.rowCount(); i++) { <START> System.out.println("On index " + i + " is : " + table.getItem(i).getText(1)); <END> } }
code_review: Use logger instead for sysout for logging.
target code: public void printCertificates ( ) { DefaultTable table = new DefaultTable ( ) ; for ( int i = 0 ; i < table . rowCount ( ) ; i ++ ) { log . info ( "On index " + i + " is : " + table . getItem ( i ) . getText ( 1 ) ) ; } }
response: public void printCertificates() { DefaultTable table = new DefaultTable(); for (int i = 0; i < table.rowCount(); i++) { <START> logger.info("On index " + i + " is : " + table.getItem(i).getText(1)); <END> } }

sample: 1488
buggy_code: public void lockEdge() throws Exception { edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.READ, true); edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.WRITE, true); edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.WRITE, true); <START> edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.READ, false); <END> }
code_review: can we revert back to using `LockMode.X` instead of `LockResource.LockMode.X`?
target code: public void lockEdge ( ) throws Exception { edgeLockTest ( LockMode . WRITE , LockMode . READ , true ) ; edgeLockTest ( LockMode . READ , LockMode . WRITE , true ) ; edgeLockTest ( LockMode . WRITE , LockMode . WRITE , true ) ; edgeLockTest ( LockMode . READ , LockMode . READ , false ) ; }
response: public void lockEdge() throws Exception { edgeLockTest(LockMode.WRITE, LockMode.READ, true); edgeLockTest(LockMode.READ, LockMode.WRITE, true); edgeLockTest(LockMode.WRITE, LockMode.WRITE, true); <START> edgeLockTest(LockMode.READ, LockMode.READ, false); <END> }

sample: 1489
buggy_code: private String getClientId() { <START> return ( (ClientMessageBusImpl) clientMessageBus ).getClientId(); <END> }
code_review: cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no?
target code: String getClientId ( ) { return clientMessageBus . getClientId ( ) ; }
response: private String getClientId() { <START> return clientMessageBus.getClientId(); <END> }

sample: 1490
buggy_code: private void configureManagementNetwork() { final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds()); if (networkConfigurator.awaitVdsmResponse()) { try { networkConfigurator.refreshNetworkConfiguration(); networkConfigurator.createManagementNetworkIfRequired(); } catch (VDSNetworkException e) { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); <START> } catch (VdsInstallException e) { <END> throw new VdsInstallException(VDSStatus.NonOperational, "Failed to configure manamgent network on the host"); } } else { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); } }
code_review: Are you sure VdsInstallException is the right exception here?
target code: private void configureManagementNetwork ( ) { final NetworkConfigurator networkConfigurator = new NetworkConfigurator ( getVds ( ) ) ; if ( ! networkConfigurator . awaitVdsmResponse ( ) ) { throw new VdsInstallException ( VDSStatus . NonResponsive , "Network error during communication with the host" ) ; } try { networkConfigurator . refreshNetworkConfiguration ( ) ; networkConfigurator . createManagementNetworkIfRequired ( ) ; } catch ( VDSNetworkException e ) { throw new VdsInstallException ( VDSStatus . NonResponsive , "Network error during communication with the host" , e ) ; } catch ( Exception e ) { throw new VdsInstallException ( VDSStatus . NonOperational , "Failed to configure manamgent network on the host" , e ) ; } }
response: private void configureManagementNetwork() { final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds()); if (networkConfigurator.awaitVdsmResponse()) { try { networkConfigurator.refreshNetworkConfiguration(); networkConfigurator.createManagementNetworkIfRequired(); } catch (VDSNetworkException e) { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); <START> } catch (VdsInstallException e) { <END> throw new VdsInstallException(VDSStatus.NonOperational, "Failed to configure management network on the host"); } } else { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); } }

sample: 1491
buggy_code: <START> public static Response newResetResponse(Header header) { return newRestartResponse(header, newNoServerError()); } <END>
code_review: I think you forgot to change this to - `return newResetResponse(header, newNoServerError());`
target code: public static Response newResetResponse ( Header header ) { return newResetResponse ( header , newNoServerError ( ) ) ; }
response: <START> public static Response newResetResponse(Header header) { return newResetResponse(header, newNoServerError()); } <END>

sample: 1492
buggy_code: <START> private static Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { <END> if (!primaryValue.isPresent()) { return safetyValue; } return primaryValue; }
code_review: Why does this need to be `static`?
target code: private Optional < TimeValue > getTimeValue ( Optional < TimeValue > primaryValue , Optional < TimeValue > safetyValue ) { if ( ! primaryValue . isPresent ( ) ) { return safetyValue ; } return primaryValue ; }
response: <START> private Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { <END> if (!primaryValue.isPresent()) { return safetyValue; } return primaryValue; }

sample: 1493
buggy_code: public Uris(String scheme, String host) { this.scheme = scheme; this.host = host; this.port = 0; <START> this.rcnamespace = "0|120"; <END> }
code_review: This should be a constant, not a magic string.
target code: public Uris ( String scheme , String host ) { this . scheme = scheme ; this . host = host ; this . port = 0 ; }
response: public Uris(String scheme, String host) { this.scheme = scheme; this.host = host; this.port = 0; <START> this.rcnamespace = "0|120"; <END> }

sample: 1494
buggy_code: private void carryOntoHistory(RevCommit c, int carry) { stack = null; for (;;) { carryOntoHistoryInnerLoop(c, carry); CarryStack s = stack; if (s != null) { <START> stack = s.prev; c = s.c; carry = s.carry; <END> continue; } break; } }
code_review: can change the order to save a temp variable s.
target code: private void carryOntoHistory ( RevCommit c , int carry ) { stack = null ; for ( ; ; ) { carryOntoHistoryInnerLoop ( c , carry ) ; if ( stack != null ) { c = stack . c ; carry = stack . carry ; stack = stack . prev ; continue ; } break ; } }
response: private void carryOntoHistory(RevCommit c, int carry) { stack = null; for (;;) { carryOntoHistoryInnerLoop(c, carry); CarryStack s = stack; if (s != null) { <START> c = s.c; carry = s.carry; stack = s.prev; <END> continue; } break; } }

sample: 1495
buggy_code: private FactHandle[] insertFacts(KieSession ksession, int n) { FactHandle[] fhs = new FactHandle[n]; for (int i = 0; i < n; i++) { fhs[i] = ksession.insert(i); <START> ksession.insert("" + String.valueOf(i)); <END> } return fhs; }
code_review: Could be just ksession.insert(String.valueOf(i));
target code: private FactHandle [ ] insertFacts ( KieSession ksession , int n ) { FactHandle [ ] fhs = new FactHandle [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { fhs [ i ] = ksession . insert ( i ) ; ksession . insert ( String . valueOf ( i ) ) ; } return fhs ; }
response: private FactHandle[] insertFacts(KieSession ksession, int n) { FactHandle[] fhs = new FactHandle[n]; for (int i = 0; i < n; i++) { fhs[i] = ksession.insert(i); <START> ksession.insert(String.valueOf(i)); <END> } return fhs; }

sample: 1496
buggy_code: public SecureStore get() { <START> return injector.getInstance(getSecureStoreImpl()); <END> }
code_review: This will create a new instance every time. Cache the instance in a member variable?
target code: public SecureStore get ( ) { if ( instance == null ) { instance = injector . getInstance ( getSecureStoreImpl ( ) ) ; } return instance ; }
response: public SecureStore get() { <START> return injector.getInstance(getSecureStoreImpl()); <END> }

sample: 1497
buggy_code: protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) { if (getUpdateSwingFromScoutLock().isAcquired()) { return; } // if (swingTransferable != null) { <START> if (getScoutObject() != null) { <END> final ITreeNode scoutNode = treePathToScoutNode(path); // notify Scout (asynchronous !) Runnable t = new Runnable() { @Override public void run() { getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode); } }; getSwingEnvironment().invokeScoutLater(t, 0); // end notify } } }
code_review: if (swingTransferable != null && getScoutObject() != null) {...}
target code: protected void handleSwingDropTargetChanged ( TreePath path , Transferable swingTransferable ) { if ( getUpdateSwingFromScoutLock ( ) . isAcquired ( ) ) { return ; } // if ( swingTransferable != null && getScoutObject ( ) != null ) { final ITreeNode scoutNode = treePathToScoutNode ( path ) ; // notify Scout ( asynchronous ! ) Runnable t = new Runnable ( ) { @Override public void run ( ) { getScoutObject ( ) . getUIFacade ( ) . fireNodeDropTargetChangedFromUI ( scoutNode ) ; } } ; getSwingEnvironment ( ) . invokeScoutLater ( t , 0 ) ; // end notify } }
response: protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) { if (getUpdateSwingFromScoutLock().isAcquired()) { return; } // if (swingTransferable != null) { <START> if (getScoutObject() != null) { <END> final ITreeNode scoutNode = treePathToScoutNode(path); // notify Scout (asynchronous !) Runnable t = new Runnable() { @Override public void run() { getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode); } }; getSwingEnvironment().invokeScoutLater(t, 0); // end notify } } }

sample: 1498
buggy_code: <START> public void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { <END> validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold); this.diskUsageThreshold = diskSpaceThreshold; this.diskUsageWarnThreshold = diskUsageWarnThreshold; }
code_review: I don't see this called anywhere in the patch. Is there a reason to make it public?
target code: void setDiskSpaceThreshold ( float diskSpaceThreshold , float diskUsageWarnThreshold ) { validateThreshold ( diskSpaceThreshold , diskUsageWarnThreshold ) ; this . diskUsageThreshold = diskSpaceThreshold ; this . diskUsageWarnThreshold = diskUsageWarnThreshold ; }
response: <START> void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { <END> validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold); this.diskUsageThreshold = diskSpaceThreshold; this.diskUsageWarnThreshold = diskUsageWarnThreshold; }

sample: 1499
buggy_code: public static void setInstance(Object source, @MappingTarget Object target) { Integer level = LEVEL.get(); fireMethodCalled( level, "setInstance", source, target ); if ( level == null ) { LEVEL.set( 1 ); MAPPING.set( new IdentityHashMap<Object, Object>() ); } else { <START> LEVEL.set( level.intValue() + 1 ); <END> } MAPPING.get().put( source, target ); }
code_review: not needed unboxing
target code: public static void setInstance ( Object source , @MappingTarget Object target ) { Integer level = LEVEL . get ( ) ; fireMethodCalled ( level , "setInstance" , source , target ) ; if ( level == null ) { LEVEL . set ( 1 ) ; MAPPING . set ( new IdentityHashMap < Object , Object > ( ) ) ; } else { LEVEL . set ( level + 1 ) ; } MAPPING . get ( ) . put ( source , target ) ; }
response: public static void setInstance(Object source, @MappingTarget Object target) { Integer level = LEVEL.get(); fireMethodCalled( level, "setInstance", source, target ); if ( level == null ) { LEVEL.set( 1 ); MAPPING.set( new IdentityHashMap<Object, Object>() ); } else { <START> LEVEL.set( level + 1 ); <END> } MAPPING.get().put( source, target ); }

sample: 1500
buggy_code: <START> public List<StandardPreset> getAllStandardPresets() throws MiddlewareQueryException { <END> return this.workbenchDataManager.getStandardPresetDAO().getAll(); }
code_review: Remove throws MiddlewareQueryException
target code: public List < StandardPreset > getAllStandardPresets ( ) { return this . workbenchDataManager . getStandardPresetDAO ( ) . getAll ( ) ; }
response: <START> public List<StandardPreset> getAllStandardPresets() { <END> return this.workbenchDataManager.getStandardPresetDAO().getAll(); }

sample: 1501
buggy_code: protected void executeVDSCommand() { if (_vdsManager != null) { try { <START> _vdsManager.getLockObj().lock(); <END> executeVdsIdCommand(); } finally { _vdsManager.getLockObj().unlock(); } } else { executeVdsIdCommand(); } }
code_review: why did you change this?
target code: protected void executeVDSCommand ( ) { if ( _vdsManager != null ) { synchronized ( _vdsManager . getLockObj ( ) ) { executeVdsIdCommand ( ) ; } } else { executeVdsIdCommand ( ) ; } }
response: protected void executeVDSCommand() { if (_vdsManager != null) { try { <START> _vdsManager.getLockObj().lock(); <END> executeVdsIdCommand(); } finally { _vdsManager.getLockObj().unlock(); } } else { executeVdsIdCommand(); } }

sample: 1502
buggy_code: public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc("We are introducing ${myStringInCtxt} !", WEBVIEW_R<END>ITION); TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc()); <START> List<TemplateInput> params = Arrays.asList( <END> factory("myStringInCtxt", StringValue, "Beautiful String") ); templateBase.saveParams(TEMPLATE_NAME, params, true); Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME); assertNotNull(result); assertEquals("We are introducing Beautiful String !", result.getString()); }
code_review: Could you use `List#of` or `Collections#singletonList`?
target code: public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt ( ) throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc ( "We are introducing $ { myStringInCtxt } ! " , WEBVIEW_RENDITION ) ; TemplateBasedDocument templateBase = createTemplateBasedDoc ( templateSrc . getAdaptedDoc ( ) ) ; List < TemplateInput > params = List . of ( factory ( "myStringInCtxt" , StringValue , "Beautiful String" ) ) ; templateBase . saveParams ( TEMPLATE_NAME , params , true ) ; Blob result = templateBase . renderWithTemplate ( TEMPLATE_NAME ) ; assertNotNull ( result ) ; assertEquals ( "We are introducing Beautiful String ! " , result . getString ( ) ) ; }
response: public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc("We are introducing ${myStringInCtxt} !", WEBVIEW_R<END>ITION); TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc()); <START> List<TemplateInput> params = Collections.singletonList( <END> factory("myStringInCtxt", StringValue, "Beautiful String") ); templateBase.saveParams(TEMPLATE_NAME, params, true); Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME); assertNotNull(result); assertEquals("We are introducing Beautiful String !", result.getString()); }

sample: 1503
buggy_code: public static PDPrintStyle getLineStyle (JSONObject oskariStyle) { PDPrintStyle style = new PDPrintStyle(); <START> JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, "stroke", () -> new JSONObject()); <END> setStrokeStyle(style, stroke); // polygon doesn't have cap style setLabelStyle(style, oskariStyle); style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,"lineCap"), 0)); return style; }
code_review: Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the code work properly.
target code: public static PDPrintStyle getLineStyle ( JSONObject oskariStyle ) { JSONObject stroke = oskariStyle . optJSONObject ( "stroke" ) ; PDPrintStyle style = new PDPrintStyle ( ) ; setStrokeStyle ( style , stroke ) ; setLabelStyle ( style , oskariStyle ) ; return style ; }
response: public static PDPrintStyle getLineStyle (JSONObject oskariStyle) { PDPrintStyle style = new PDPrintStyle(); <START> JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, "stroke", () -> new JSONObject()); if (stroke.length() == 0) { return style; } <END> setStrokeStyle(style, stroke); // polygon doesn't have cap style setLabelStyle(style, oskariStyle); style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,"lineCap"), 0)); return style; }

sample: 1504
buggy_code: public static void init(Configuration conf) { if (!initDone) { DefaultConfiguration.conf = conf; DefaultConfiguration.initDone = true; <START> } <END> }
code_review: All of the methods on this class should be `synchronized`. Otherwise this change looks good.
target code: public static synchronized void init ( Configuration conf ) { if ( ! initDone ) { DefaultConfiguration . conf = conf ; DefaultConfiguration . initDone = true ; } }
response: public static synchronized void init(Configuration conf) { if (!initDone) { DefaultConfiguration.conf = conf; DefaultConfiguration.initDone = true; <START> } <END> }

sample: 1505
buggy_code: private void rollBackToTimestamp(long timestamp) { if (getVersionUnsafe() > timestamp) { try { rollbackObjectUnsafe(timestamp); // Rollback successfully got us to the right // version, we're done. <START> if (getVersionUnsafe() == timestamp) { <END> return; } } catch (NoRollbackException nre) { log.warn("Rollback[{}] to {} failed {}", this, timestamp, nre); resetUnsafe(); } } }
code_review: We return even if this is false. Should we do something in the else case?
target code: private void rollBackToTimestamp ( long timestamp ) { if ( getVersionUnsafe ( ) > timestamp ) { try { rollbackObjectUnsafe ( timestamp ) ; } catch ( NoRollbackException nre ) { log . warn ( "Rollback [ { } ] to { } failed { } " , this , timestamp , nre ) ; resetUnsafe ( ) ; } } }
response: private void rollBackToTimestamp(long timestamp) { if (getVersionUnsafe() > timestamp) { try { rollbackObjectUnsafe(timestamp); // Rollback successfully got us to the right // version, we're done. <START> if (getVersionUnsafe() == timestamp) { <END> return; } else { // We return even if this is false. Should we do something in the else case? } } catch (NoRollbackException nre) { log.warn("Rollback[{}] to {} failed {}", this, timestamp, nre); resetUnsafe(); } } }

sample: 1506
buggy_code: public void prepare(Properties options) { Objects.requireNonNull(mapper, "mapper can not be null"); Objects.requireNonNull(topicSelector, "topicSelector can not be null"); <START> producer = new KafkaProducer<K, V>(options); <END> }
code_review: Nit: I think `new KafkaProducer<>(options)` will work here
target code: public void prepare ( Properties options ) { Objects . requireNonNull ( mapper , "mapper can not be null" ) ; Objects . requireNonNull ( topicSelector , "topicSelector can not be null" ) ; producer = new KafkaProducer < > ( options ) ; }
response: public void prepare(Properties options) { Objects.requireNonNull(mapper, "mapper can not be null"); Objects.requireNonNull(topicSelector, "topicSelector can not be null"); <START> producer = new KafkaProducer<>(options); <END> }

sample: 1507
buggy_code: protected Control createSWTControl(Composite parent) throws DatabindingFailedException { final Control control = super.createSWTControl(parent); <START> final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { <END> new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory); return control; }
code_review: this must be disposed
target code: protected Control createSWTControl ( Composite parent ) throws DatabindingFailedException { final Control control = super . createSWTControl ( parent ) ; composedAdapterFactory = new ComposedAdapterFactory ( new AdapterFactory [ ] { new ReflectiveItemProviderAdapterFactory ( ) , new ComposedAdapterFactory ( ComposedAdapterFactory . Descriptor . Registry . INSTANCE ) } ) ; adapterFactoryItemDelegator = new AdapterFactoryItemDelegator ( composedAdapterFactory ) ; return control ; }
response: protected Control createSWTControl(Composite parent) throws DatabindingFailedException { final Control control = super.createSWTControl(parent); <START> final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { <END> new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory); return control; }

sample: 1508
buggy_code: public boolean isRegistered(VeluxProduct product) { logger.trace("isRegistered(VeluxProduct {}) called.", product.toString()); if (product.isV2()) { return isRegistered(product.getSerialNumber()); <START> } else { <END> return isRegistered(product.getProductUniqueIndex()); } }
code_review: `else` is redundant here.
target code: public boolean isRegistered ( VeluxProduct product ) { logger . trace ( "isRegistered ( VeluxProduct { } ) called . " , product . toString ( ) ) ; if ( product . isV2 ( ) ) { return isRegistered ( product . getSerialNumber ( ) ) ; } return isRegistered ( product . getProductUniqueIndex ( ) ) ; }
response: public boolean isRegistered(VeluxProduct product) { logger.trace("isRegistered(VeluxProduct {}) called.", product.toString()); if (product.isV2()) { return isRegistered(product.getSerialNumber()); <START> } <END> return isRegistered(product.getProductUniqueIndex()); }

sample: 1509
buggy_code: public void tearDown() throws Exception { FileUtils.deleteQuietly(nuxeoHome); // Restore or clear all the system properties manipulated by the current test <START> originSystemProps.forEach((key, originValue) -> { <END> if (originValue == null) { System.clearProperty(key); } else { System.setProperty(key, originValue); } }); originSystemProps.clear(); }
code_review: You can call the value just `value`
target code: public void tearDown ( ) throws Exception { FileUtils . deleteQuietly ( nuxeoHome ) ; // Restore or clear all the system properties manipulated by the current test originSystemProps . forEach ( ( key , value ) - > { if ( value == null ) { System . clearProperty ( key ) ; } else { System . setProperty ( key , value ) ; } } ) ; originSystemProps . clear ( ) ; }
response: public void tearDown() throws Exception { FileUtils.deleteQuietly(nuxeoHome); // Restore or clear all the system properties manipulated by the current test <START> originSystemProps.forEach((key, value) -> { <END> if (value == null) { System.clearProperty(key); } else { System.setProperty(key, value); } }); originSystemProps.clear(); }

sample: 1510
buggy_code: private void checkDeployedProject(String projectName) { ServersView2 serversView = new ServersView2(); serversView.open(); ServerModule module = serversView.getServer(FULL_SERVER_NAME) .getModule(new RegexMatcher(".*" + projectName + ".*")); new WaitUntil(new ServerModuleHasState(module, ServerState.<START>ED), TimePeriod.getCustom(30)); ModuleLabel moduleLabel = module.getLabel(); ServerState moduleState = moduleLabel.getState(); <START> assertTrue("Module has not been started!", moduleState == ServerState.<START>ED); <END> }
code_review: Are these two lines of definitions necessary? Isn't it shorter to just use module.getLabel().getState() in assert?
target code: private void checkDeployedProject ( String projectName ) { ServersView2 serversView = new ServersView2 ( ) ; serversView . open ( ) ; ServerModule module = serversView . getServer ( FULL_SERVER_NAME ) . getModule ( new RegexMatcher ( " .* " + projectName + " .* " ) ) ; new WaitUntil ( new ServerModuleHasState ( module , ServerState . STARTED ) , TimePeriod . getCustom ( 30 ) ) ; ModuleLabel moduleLabel = module . getLabel ( ) ; assertTrue ( "Module has not been started ! " , moduleLabel . getState ( ) == ServerState . STARTED ) ; }
response: private void checkDeployedProject(String projectName) { ServersView2 serversView = new ServersView2(); serversView.open(); ServerModule module = serversView.getServer(FULL_SERVER_NAME) .getModule(new RegexMatcher(".*" + projectName + ".*")); new WaitUntil(new ServerModuleHasState(module, ServerState.<START>ED), TimePeriod.getCustom(30)); <START> assertTrue("Module has not been started!", module.getLabel().getState() == ServerState.<START>ED); <END> }

sample: 1511
buggy_code: SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) { <START> return new StandardSlackService(baseUrl, teamDomain, null, authTokenCredentialId, botUser, room); <END> }
code_review: Oh please, no! Don't ship a null object! :cry:
target code: SlackService getSlackService ( final String baseUrl , final String teamDomain , final String authTokenCredentialId , final boolean botUser , final String room ) { return new StandardSlackService ( baseUrl , teamDomain , authTokenCredentialId , botUser , room ) ; }
response: SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) { <START> return new StandardSlackService(baseUrl, teamDomain, authTokenCredentialId, botUser, room); <END> }

sample: 1512
buggy_code: private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) { if ( isAnnotationPresent( type, processedAnnotations ) ) { return true; } } } <START> if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { <END> return true; } return false; }
code_review: I would move this one first.
target code: private boolean isAnnotationPresent ( AnnotatedType annotatedType , Set < Annotation > processedAnnotations ) { if ( isAnnotationPresentIn ( annotatedType . getDeclaredAnnotations ( ) , processedAnnotations ) ) { return true ; } if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( ( AnnotatedParameterizedType ) annotatedType ) . getAnnotatedActualTypeArguments ( ) ) { if ( isAnnotationPresent ( type , processedAnnotations ) ) { return true ; } } } return false ; }
response: private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) { if ( isAnnotationPresent( type, processedAnnotations ) ) { return true; } } } <START> if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { return true; } <END> return false; }

sample: 1513
buggy_code: static int staticFunc() { InvokeStatic f = new InvokeStatic() { // Noncompliant @Override <START> public String func(int n) { <END> unknown(); staticFunc(); return 0; } }; return f.func(); }
code_review: int func();
target code: static int staticFunc ( ) { InvokeStatic f = new InvokeStatic ( ) { // Noncompliant @Override public int func ( ) { unknown ( ) ; staticFunc ( ) ; return 0 ; } } ; return f . func ( ) ; }
response: static int staticFunc() { InvokeStatic f = new InvokeStatic() { // Noncompliant @Override <START> public int func() { <END> unknown(); staticFunc(); return 0; } }; return f.func(); }

sample: 1514
buggy_code: private synchronized void resetGeneration() { this.generation = Generation.NO_GENERATION; rejoinNeeded = true; // only reset the state to un-joined when it is not already in rebalancing <START> if (state != MemberState.REBALANCING) <END> state = MemberState.UNJOINED; }
code_review: But we are moving to UNJOINED anyway, so it won't affect the result right?
target code: private synchronized void resetGeneration ( ) { this . rejoinNeeded = true ; this . generation = Generation . NO_GENERATION ; }
response: private synchronized void resetGeneration() { this.generation = Generation.NO_GENERATION; rejoinNeeded = true; // only reset the state to un-joined when it is not already in rebalancing <START> if (state != MemberState.REBALANCING) <END> state = MemberState.UNJOINED; }

sample: 1515
buggy_code: public Path generateArtifact(URI uri, int size) throws IOException { <START> new NpmPackageGenerator(Paths.get(uri)); <END> buildPublishJson(); return getPackagePath(); }
code_review: why you need this here?
target code: public Path generateArtifact ( URI uri , int size ) throws IOException { buildPublishJson ( ) ; return getPackagePath ( ) ; }
response: public Path generateArtifact(URI uri, int size) throws IOException { <START> new NpmPackageGenerator(Paths.get(uri)); <END> buildPublishJson(); return getPackagePath(); }

sample: 1516
buggy_code: public void nextTuple() { Utils.sleep(100); <START> Random rand = new Random(); <END> Integer value = rand.nextInt(1000); collector.emit(new Values(value)); }
code_review: Minor nit, declaring a new Random each time is not really good practice.
target code: public void nextTuple ( ) { Utils . sleep ( 100 ) ; collector . emit ( new Values ( rand . nextInt ( 1000 ) ) ) ; }
response: public void nextTuple() { Utils.sleep(100); <START> Random rand = new Random(); <END> Integer value = rand.nextInt(1000); collector.emit(new Values(value)); }

sample: 1517
buggy_code: <START> public void register(final Class<?> clazz, final Object converter) { <END> otherWord = ""; }
code_review: these 3 methods are `public` do you really need them?
target code: private void register ( final Class < ? > clazz , final Object converter ) { otherWord = "" ; }
response: <START> private void register(final Class<?> clazz, final Object converter) { <END> otherWord = ""; }

sample: 1518
buggy_code: public void testMarkerOnLastLineNoNewline_495842() throws Exception { try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("", false)))) { writer.write(getAboveComment().trim()); } <START> PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); <END> indexFiles(); PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false); String result = runQuickFixOneFile(); assertContainedIn("int func() { } // @suppress(\"No return\")", result); }
code_review: Why are we setting it to true during indexing?
target code: public void testMarkerOnLastLineNoNewline_495842 ( ) throws Exception { try ( BufferedWriter writer = new BufferedWriter ( new FileWriter ( loadcode ( "" , false ) ) ) ) { writer . write ( getAboveComment ( ) . trim ( ) ) ; } PreferenceConstants . getPreferenceStore ( ) . setValue ( PreferenceConstants . ENSURE_NEWLINE_AT_EOF , false ) ; indexFiles ( ) ; String result = runQuickFixOneFile ( ) ; PreferenceConstants . getPreferenceStore ( ) . setValue ( PreferenceConstants . ENSURE_NEWLINE_AT_EOF , true ) ; assertContainedIn ( "int func ( ) { } // @suppress ( \"No return\" ) " , result ) ; }
response: public void testMarkerOnLastLineNoNewline_495842() throws Exception { try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("", false)))) { writer.write(getAboveComment().trim()); } <START> PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); <END> indexFiles(); PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false); String result = runQuickFixOneFile(); assertContainedIn("int func() { } // @suppress(\"No return\")", result); }

sample: 1519
buggy_code: public void onLanguageTabSelected(String selectedLanguageCode) { <START> Log.e("####", "HERE"); <END> searchLanguageCode = selectedLanguageCode; startSearch(query, query != null && query.length() > 1); }
code_review: What is the Log.e for?
target code: public void onLanguageTabSelected ( String selectedLanguageCode ) { searchLanguageCode = selectedLanguageCode ; startSearch ( query , query != null && query . length ( ) > 1 ) ; }
response: public void onLanguageTabSelected(String selectedLanguageCode) { <START> Log.e("####", "HERE"); <END> searchLanguageCode = selectedLanguageCode; startSearch(query, query != null && query.length() > 1); }

sample: 1520
buggy_code: public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter) { <START> Log.d("Logging EntityProcessor", "before insert"); <END> T result = mDelegate.insert(db, entityAdapter, isSyncAdapter); Log.d("Logging EntityProcessor", "after insert on " + entityAdapter.id()); return result; }
code_review: Move the tag to a constant?
target code: public T insert ( SQLiteDatabase db , T entityAdapter , boolean isSyncAdapter ) { Log . d ( TAG , "before insert" ) ; T result = mDelegate . insert ( db , entityAdapter , isSyncAdapter ) ; Log . d ( TAG , "after insert on " + entityAdapter . id ( ) ) ; return result ; }
response: public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter) { <START> Log.d(TAG, "before insert"); <END> T result = mDelegate.insert(db, entityAdapter, isSyncAdapter); Log.d(TAG, "after insert on " + entityAdapter.id()); return result; }

sample: 1521
buggy_code: protected UfsStatus(UfsStatus status) { mIsDirectory = status.mIsDirectory; mName = status.mName; mOwner = status.mOwner; mGroup = status.mGroup; mMode = status.mMode; mLastModifiedTimeMs = status.mLastModifiedTimeMs; <START> mXAttr = status.mXAttr; <END> }
code_review: This won't copy the map?
target code: protected UfsStatus ( UfsStatus status ) { mIsDirectory = status . mIsDirectory ; mName = status . mName ; mOwner = status . mOwner ; mGroup = status . mGroup ; mMode = status . mMode ; mLastModifiedTimeMs = status . mLastModifiedTimeMs ; mXAttr = status . mXAttr == null ? null : new HashMap < > ( status . mXAttr ) ; }
response: protected UfsStatus(UfsStatus status) { mIsDirectory = status.mIsDirectory; mName = status.mName; mOwner = status.mOwner; mGroup = status.mGroup; mMode = status.mMode; mLastModifiedTimeMs = status.mLastModifiedTimeMs; <START> mXAttr = new HashMap<>(status.mXAttr); <END> }

sample: 1522
buggy_code: boolean isProjectStyle() { if (myIsFrameworkStyle) { return false; } ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true); assert repository != null : <START> repository.getDisplayName(); <END> return repository.hasResourceItem(ResourceType.STYLE, myStyleName); }
code_review: if repository is null, this will throw an NPE.
target code: boolean isProjectStyle ( ) { if ( myIsFrameworkStyle ) { return false ; } ProjectResourceRepository repository = ProjectResourceRepository . getProjectResources ( myConfiguration . getModule ( ) , true ) ; assert repository != null : myConfiguration . getModule ( ) . getName ( ) ; return repository . hasResourceItem ( ResourceType . STYLE , myStyleName ) ; }
response: boolean isProjectStyle() { if (myIsFrameworkStyle) { return false; } ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true); assert repository != null : <START> repository.getDisplayName(); <END> return repository.hasResourceItem(ResourceType.STYLE, myStyleName); }

sample: 1523
buggy_code: public void setUserProperty(String prop, String value) { getUserProperties().put(prop, value); <START> Context.clearCacheForCurrentUser(); <END> }
code_review: Let's use @CacheEvict(value="userSearchLocales") public User saveUser(User user, String password) instead. We will get rid of CacheManager in Context as well. It would be better to evict just for the specified user, but our key consists of user and currentLocale. SaveUser is not called that often so invalidating all entries is no issue anyway.
target code: public void setUserProperty ( String prop , String value ) { getUserProperties ( ) . put ( prop , value ) ; }
response: public void setUserProperty(String prop, String value) { getUserProperties().put(prop, value); <START> Context.clearCacheForCurrentUser(); <END> }

sample: 1524
buggy_code: JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) { this.processor = processor; this.xmlPathInJar = xmlPathInJar; //Ensure that dynamic list operations supported <START> this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); <END> }
code_review: You can revert this change because you don't need it in this specific class.
target code: JarFileUtils ( IPostProcessor processor , String xmlPathInJar , List < String > testNames ) { this . processor = processor ; this . xmlPathInJar = xmlPathInJar ; this . testNames = testNames ; }
response: JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) { this.processor = processor; this.xmlPathInJar = xmlPathInJar; //Ensure that dynamic list operations supported <START> this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); <END> }

sample: 1525
buggy_code: public String resolve(String variable, String defaultValue) { IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver(); //ignoring argument here, as we want to fall back on the propertiesProvider. String result = delegate.resolve(variable, null); if (result == null) { try { <START> result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); <END> } catch (CoreException e) { throw new ExpressionResolutionException(e); } } return result; }
code_review: will properties provider return the defaultValue in case of no network or value not found ?
target code: public String resolve ( String variable , String defaultValue ) { IVariableResolver delegate = new ExpressionResolver . SystemPropertiesVariableResolver ( ) ; // ignoring default value first , as we want to fall back on the // propertiesProvider later . String result = delegate . resolve ( variable , null ) ; if ( result == null ) { result = propertiesProvider . getValue ( variable , defaultValue ) ; } return result ; }
response: public String resolve(String variable, String defaultValue) { IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver(); //ignoring argument here, as we want to fall back on the propertiesProvider. String result = delegate.resolve(variable, null); if (result == null) { try { <START> result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); <END> } catch (CoreException e) { throw new ExpressionResolutionException(e); } } return result; }

sample: 1526
buggy_code: public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) { if (vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId()) .getDiskInterface() == DiskInterface.VirtIO_SCSI)) { return true; } <START> return false; <END> }
code_review: you can simply return the result of anyMatch without the 'if' and 'return true/false' statements. imo, it would also be nicer to extract the "i -> i.getDiskVmElementForVm(vmBase.getId()).getDiskInterface() == DiskInterface.VirtIO_SCSI" part to a separate method "isVirtioScsiDisk" to make it easier to read
target code: public static boolean isVirtIoScsiDiskInterfaceExists ( VmBase vmBase ) { return vmBase . getImages ( ) . stream ( ) . anyMatch ( i - > i . getDiskVmElementForVm ( vmBase . getId ( ) ) . getDiskInterface ( ) == DiskInterface . VirtIO_SCSI ) ; }
response: public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) { return vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId()) .getDiskInterface() == DiskInterface.VirtIO_SCSI); }

sample: 1527
buggy_code: public void setContext(String context){ <START> typingRule.setContext(BloodTestContext.valueOf(context.replaceAll("\\s","").toUpperCase(Locale.FRENCH))); <END> }
code_review: Is there a reason for using `Locale.FRENCH`? Also, why is it needed to remove all spaces? Are you just trying to do a `trim()`, or are you removing spaces between words?
target code: public void setContext ( String context ) { typingRule . setContext ( BloodTestContext . valueOf ( context . replaceAll ( "\\s" , "" ) . toUpperCase ( ) ) ) ; }
response: public void setContext(String context){ <START> typingRule.setContext(BloodTestContext.valueOf(context.trim().toUpperCase())); <END> }

sample: 1528
buggy_code: private String readClasspathResource(String c) throws IOException { InputStream is = getClass().getResourceAsStream(c); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }
code_review: close already done in Util.read(..)
target code: private String readClasspathResource ( String c ) throws IOException { InputStream is = getClass ( ) . getResourceAsStream ( c ) ; return Util . read ( is ) ; }
response: private String readClasspathResource(String c) throws IOException { InputStream is = getClass().getResourceAsStream(c); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }

sample: 1529
buggy_code: protected void build(UnitVmModel frontend, VM backend) { <START> String name = (String) frontend.getName().getEntity(); <END> VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem(); backend.setVmtGuid(template.getId()); backend.setName(name); backend.setVmDescription((String) frontend.getDescription().getEntity()); backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity()); }
code_review: can be inlined
target code: protected void build ( UnitVmModel frontend , VM backend ) { VmTemplate template = ( VmTemplate ) frontend . getTemplate ( ) . getSelectedItem ( ) ; backend . setVmtGuid ( template . getId ( ) ) ; backend . setName ( ( String ) frontend . getName ( ) . getEntity ( ) ) ; backend . setVmDescription ( ( String ) frontend . getDescription ( ) . getEntity ( ) ) ; backend . setCustomProperties ( frontend . getCustomPropertySheet ( ) . getEntity ( ) ) ; }
response: protected void build(UnitVmModel frontend, VM backend) { VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem(); backend.setVmtGuid(template.getId()); backend.setName((String) frontend.getName().getEntity()); backend.setVmDescription((String) frontend.getDescription().getEntity()); backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity()); }

sample: 1530
buggy_code: public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception { int resultWhenTrue = 4; int resultWhenFalse = 2; List<Drug> allDrugs = conceptService.getAllDrugs(); assertEquals(resultWhenTrue, allDrugs.size()); <START> allDrugs = conceptService.getAllDrugs(false); <END> assertEquals(resultWhenFalse, allDrugs.size()); }
code_review: @mavrk one test should only be for one method and one combination of parameters. and the goal is that every public method in the service layer is tested. so you should write tests for the methods * getAllDrugs() * getAllDrugs(includeRetired) and for the latter you need one test passing true and one passing false. another case is also what if there are no drugs will it return an empty list? I know this is tedious but thats because when this was written [TDD|https://en.wikipedia.org/wiki/Test-driven_development] which would start with tests wasnt used.
target code: public void getAllDrugs_shouldReturnAListOfAllDrugs ( ) throws Exception { int resultWhenTrue = 4 ; List < Drug > allDrugs = conceptService . getAllDrugs ( ) ; assertEquals ( resultWhenTrue , allDrugs . size ( ) ) ; }
response: public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception { int resultWhenTrue = 4; int resultWhenFalse = 2; List<Drug> allDrugs = conceptService.getAllDrugs(); assertEquals(resultWhenTrue, allDrugs.size()); allDrugs = conceptService.getAllDrugs(false); assertEquals(resultWhenFalse, allDrugs.size()); }

sample: 1531
buggy_code: public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades( CurrencyPair currencyPair) throws IOException { <START> final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> <END> transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair)); return transactionHistory.getData(); }
code_review: those inner classes make reading all of this much worse
target code: public List < BithumbTransactionHistory > getBithumbTrades ( CurrencyPair currencyPair ) throws IOException { final BithumbResponse < List < BithumbTransactionHistory > > transactionHistory = bithumb . transactionHistory ( BithumbUtils . getBaseCurrency ( currencyPair ) ) ; return transactionHistory . getData ( ) ; }
response: public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades( CurrencyPair currencyPair) throws IOException { <START> final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair)); <END> return transactionHistory.getData(); }

sample: 1532
buggy_code: public void addChild(String name, Long id) { <START> if (mChildren.put(name, id) == null) { <END> mWeight.incrementAndGet(); } }
code_review: `mChildren` could be `null`
target code: public void addChild ( String name , Long id ) { if ( mChildren != null && mChildren . put ( name , id ) == null ) { mWeight . incrementAndGet ( ) ; } }
response: public void addChild(String name, Long id) { <START> if (mChildren != null && mChildren.put(name, id) == null) { <END> mWeight.incrementAndGet(); } }

sample: 1533
buggy_code: static void reTryKerberos(boolean enabled) { if (enabled) { log.debug("Try relogin kerberos at first!"); try { if (UserGroupInformation.isLoginKeytabBased()) { UserGroupInformation.getLoginUser().reloginFromKeytab(); } else if (UserGroupInformation.isLoginTicketBased()) { UserGroupInformation.getLoginUser().reloginFromTicketCache(); } } catch (IOException e) { <START> log.error("Try relogin kerberos failed!"); <END> throw new RuntimeException(e); } } }
code_review: nit: This will result in double logging
target code: static void reTryKerberos ( boolean enabled ) { if ( enabled ) { log . debug ( "Try relogin kerberos at first ! " ) ; try { if ( UserGroupInformation . isLoginKeytabBased ( ) ) { UserGroupInformation . getLoginUser ( ) . reloginFromKeytab ( ) ; } else if ( UserGroupInformation . isLoginTicketBased ( ) ) { UserGroupInformation . getLoginUser ( ) . reloginFromTicketCache ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }
response: static void reTryKerberos(boolean enabled) { if (enabled) { log.debug("Try relogin kerberos at first!"); try { if (UserGroupInformation.isLoginKeytabBased()) { UserGroupInformation.getLoginUser().reloginFromKeytab(); } else if (UserGroupInformation.isLoginTicketBased()) { UserGroupInformation.getLoginUser().reloginFromTicketCache(); } } catch (IOException e) { <START> log.error("Try relogin kerberos failed!", e); <END> throw new RuntimeException(e); } } }

sample: 1534
buggy_code: void resetLogic() { for (int i = 0; i < fieldSize; i++) <START> for (int j = 0; j < fieldSize; j++) fieldArray[i][j] = 0; <END> playerMark = CROSS_MARK; aIMark = ZERO_MARK; turn = 0; //first turn autoGameEnabled = false; }
code_review: braces
target code: void resetLogic ( ) { for ( int i = 0 ; i < fieldSize ; i ++ ) for ( int j = 0 ; j < fieldSize ; j ++ ) { fieldArray [ i ] [ j ] = 0 ; } playerMark = CROSS_MARK ; aIMark = ZERO_MARK ; turn = 0 ; // first turn autoGameEnabled = false ; }
response: void resetLogic() { for (int i = 0; i < fieldSize; i++) { for (int j = 0; j < fieldSize; j++) fieldArray[i][j] = 0; } playerMark = CROSS_MARK; aIMark = ZERO_MARK; turn = 0; //first turn autoGameEnabled = false; }

sample: 1535
buggy_code: protected Stream<URL> listBundleComponents(Bundle bundle) { String list = OSGiRuntimeService.getComponentsList(bundle); String name = bundle.getSymbolicName(); log.debug("PartialBundle: " + name + " components: " + list); if (list == null) { return Stream.empty(); } else { <START> return Arrays.stream(list.split("[, \t\n\r\f]")).map(bundle::getEntry).filter(Objects::nonNull); <END> } }
code_review: Could you replace `Arrays#stream` by `Stream#of` for consistency ?
target code: protected Stream < URL > listBundleComponents ( Bundle bundle ) { String list = OSGiRuntimeService . getComponentsList ( bundle ) ; String name = bundle . getSymbolicName ( ) ; log . debug ( "PartialBundle : " + name + " components : " + list ) ; if ( list == null ) { return Stream . empty ( ) ; } else { return Stream . of ( list . split ( " [ , \t\n\r\f ] " ) ) . map ( bundle : : getEntry ) . filter ( Objects : : nonNull ) ; } }
response: protected Stream<URL> listBundleComponents(Bundle bundle) { String list = OSGiRuntimeService.getComponentsList(bundle); String name = bundle.getSymbolicName(); log.debug("PartialBundle: " + name + " components: " + list); if (list == null) { return Stream.empty(); } else { <START> return Stream.of(list.split("[, \t\n\r\f]")).map(bundle::getEntry).filter(Objects::nonNull); <END> } }

sample: 1536
buggy_code: public void testLoadDataObjectsWithNonNullWorkspaceProject() { <START> assertTrue(dataObjectsService.loadDataObjects(workspaceProject).isEmpty()); <END> }
code_review: Please use assertj assertion. In case of fail it gives error message explaining different list sizes. Current implementation will just print assertion error, expected true but was false with no reference to list size.
target code: public void testLoadDataObjectsWithNonNullWorkspaceProject ( ) { assertThat ( dataObjectsService . loadDataObjects ( workspaceProject ) ) . isEmpty ( ) ; }
response: public void testLoadDataObjectsWithNonNullWorkspaceProject() { <START> assertThat(dataObjectsService.loadDataObjects(workspaceProject)).isEmpty(); <END> }

sample: 1537
buggy_code: <START> public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { <END> Graphics2D g2 = img.createGraphics(); if (backgroundColor != null) { g2.setBackground(backgroundColor); g2.clearRect(0, 0, width, height); } ImageRenderer renderer = new ImageRenderer(); renderer.draw(mt, g2, width, height, rootLayer, pm); return g2; }
code_review: Why this function is public ? It will be used outside of this class ?
target code: private Graphics2D prepareImageRenderer ( MapTransform mt , BufferedImage img , ProgressMonitor pm ) { Graphics2D g2 = img . createGraphics ( ) ; if ( backgroundColor != null ) { g2 . setBackground ( backgroundColor ) ; g2 . clearRect ( 0 , 0 , width , height ) ; } ImageRenderer renderer = new ImageRenderer ( ) ; renderer . draw ( mt , g2 , width , height , rootLayer , pm ) ; return g2 ; }
response: <START> public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { <END> Graphics2D g2 = img.createGraphics(); if (backgroundColor != null) { g2.setBackground(backgroundColor); g2.clearRect(0, 0, width, height); } ImageRenderer renderer = new ImageRenderer(); renderer.draw(mt, g2, width, height, rootLayer, pm); return g2; }

sample: 1538
buggy_code: public static void refreshResources(IResource[] resources, IProgressMonitor monitor) throws CoreException { try { SubMonitor progress = SubMonitor.convert(monitor, CoreText.ProjectUtil_refreshing, resources.length); for (IResource resource : resources) { if (progress.isCanceled()) break; resource.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); <START> progress.worked(1); <END> } } finally { monitor.done(); } }
code_review: Not needed, delete.
target code: public static void refreshResources ( IResource [ ] resources , IProgressMonitor monitor ) throws CoreException { try { SubMonitor progress = SubMonitor . convert ( monitor , CoreText . ProjectUtil_refreshing , resources . length ) ; for ( IResource resource : resources ) { if ( progress . isCanceled ( ) ) break ; resource . refreshLocal ( IResource . DEPTH_INFINITE , progress . newChild ( 1 ) ) ; } } finally { monitor . done ( ) ; } }
response: public static void refreshResources(IResource[] resources, IProgressMonitor monitor) throws CoreException { try { SubMonitor progress = SubMonitor.convert(monitor, CoreText.ProjectUtil_refreshing, resources.length); for (IResource resource : resources) { if (progress.isCanceled()) break; resource.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); <START> <END> } } finally { monitor.done(); } }

sample: 1539
buggy_code: private boolean isInSelection(Event event) { if (selection.x == selection.y) return false; int offset = getOffsetAtPoint(event.x, event.y, null, true); if (selection.x <= offset && offset < selection.y) return true; <START> else return false; <END> }
code_review: we can just use 'return false' instead of 'else return false'
target code: private boolean isInSelection ( Event event ) { if ( selection . x == selection . y ) return false ; int offset = getOffsetAtPoint ( event . x , event . y , null , true ) ; if ( selection . x <= offset && offset < selection . y ) return true ; return false ; }
response: private boolean isInSelection(Event event) { if (selection.x == selection.y) return false; int offset = getOffsetAtPoint(event.x, event.y, null, true); if (selection.x <= offset && offset < selection.y) return true; <START> return false; <END> }

sample: 1540
buggy_code: <START> public void setUp() throws Exception { cuMarshalService = new CUMarshalServiceImpl(); xmlFile = new File(EXAMPLE_FILE_NAME); } <END>
code_review: Is the throws Exception needed here?
target code: public void setUp ( ) { cuMarshalService = new CUMarshalServiceImpl ( ) ; xmlFile = new File ( EXAMPLE_FILE_NAME ) ; }
response: <START> public void setUp() { cuMarshalService = new CUMarshalServiceImpl(); xmlFile = new File(EXAMPLE_FILE_NAME); } <END>

sample: 1541
buggy_code: public void actionPerformed(ActionEvent e) { if(e.getSource() == okButton){ //controller should be passed to this class only if there is need to modification content of Keystore. <START> System.out.println(certControll); <END> if (certControll != null) { certControll.setAddToKeystore(true); } this.dispose(); }else if(e.getSource() == cancelButton){ if (certControll != null) { certControll.setAddToKeystore(false); } this.dispose(); } }
code_review: System.out? Booh!
target code: public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == okButton ) { // controller should be passed to this class only if there is need to modification content of Keystore . if ( certControll != null ) { certControll . setAddToKeystore ( true ) ; } this . dispose ( ) ; } else if ( e . getSource ( ) == cancelButton ) { if ( certControll != null ) { certControll . setAddToKeystore ( false ) ; } this . dispose ( ) ; } }
response: public void actionPerformed(ActionEvent e) { if(e.getSource() == okButton){ //controller should be passed to this class only if there is need to modification content of Keystore. <START> if (certControll != null) { certControll.setAddToKeystore(true); } <END> this.dispose(); }else if(e.getSource() == cancelButton){ if (certControll != null) { certControll.setAddToKeystore(false); } this.dispose(); } }

sample: 1542
buggy_code: public FilteredSourceFiles( List<Path> rawSrcFiles, BuildTarget buildTarget, GoToolchain goToolchain, GoPlatform platform, List<FileType> fileTypes) { this.rawSrcFiles = rawSrcFiles; this.extraSrcFiles = new ArrayList<>(); <START> initFilterSteps(buildTarget, goToolchain, platform, fileTypes); <END> }
code_review: instead of initializing `filterSteps` in `initFilterSteps` could you do the following? ``` filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes); ```
target code: public FilteredSourceFiles ( List < Path > rawSrcFiles , BuildTarget buildTarget , GoToolchain goToolchain , GoPlatform platform , List < FileType > fileTypes ) { this ( rawSrcFiles , ImmutableList . of ( ) , buildTarget , goToolchain , platform , fileTypes ) ; }
response: public FilteredSourceFiles( List<Path> rawSrcFiles, BuildTarget buildTarget, GoToolchain goToolchain, GoPlatform platform, List<FileType> fileTypes) { this.rawSrcFiles = rawSrcFiles; this.extraSrcFiles = new ArrayList<>(); <START> filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes); <END> }

sample: 1543
buggy_code: <START> public static char complementBase(char base, boolean RNA) { <END> if (base == 'A' && RNA) return 'U'; if (base == 'A') return 'T'; if (base == 'T' && !RNA) return 'A'; if (base == 'U' && RNA) return 'A'; if (base == 'C') return 'G'; if (base == 'G') return 'C'; return ' '; }
code_review: Isn't this already present elsewhere in biojava?
target code: protected static char complementBase ( char base , boolean RNA ) { if ( base == 'A' && RNA ) return 'U' ; if ( base == 'A' ) return 'T' ; if ( base == 'T' && ! RNA ) return 'A' ; if ( base == 'U' && RNA ) return 'A' ; if ( base == 'C' ) return 'G' ; if ( base == 'G' ) return 'C' ; return ' ' ; }
response: <START> public static char complementBase(char base, boolean RNA) { <END> if (base == 'A' && RNA) return 'U'; if (base == 'A') return 'T'; if (base == 'T' && !RNA) return 'A'; if (base == 'U' && RNA) return 'A'; if (base == 'C') return 'G'; if (base == 'G') return 'C'; return ' '; }

sample: 1544
buggy_code: public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this.classLoader = Thread.currentThread().getContextClassLoader(); <END> }
code_review: Replace with `this(in, null)`
target code: public TCCLObjectInputStream ( InputStream in ) throws IOException { this ( in , null ) ; }
response: public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this(in, null); <END> }

sample: 1545
buggy_code: private void run() { try { boolean valid = connectionSanityCheck.isValid(); if (!valid) { onInvalidConnection.run(); } } catch (Exception e) { <START> logger.warn("Impossible to correctly monitor the Axon Server connection state."); <END> } }
code_review: Add the cause to the log.
target code: private void run ( ) { try { boolean valid = connectionSanityCheck . isValid ( ) ; if ( ! valid ) { onInvalidConnection . run ( ) ; } } catch ( Exception e ) { logger . warn ( "Impossible to correctly monitor the Axon Server connection state . " , e ) ; } }
response: private void run() { try { boolean valid = connectionSanityCheck.isValid(); if (!valid) { onInvalidConnection.run(); } } catch (Exception e) { <START> logger.warn("Impossible to correctly monitor the Axon Server connection state.", e); <END> } }

sample: 1546
buggy_code: protected String getStateParameter(final WebContext context) { <START> final String stateParameter; <END> final String stateData = getState(); if (CommonHelper.isNotBlank(stateData)) { stateParameter = stateData; } else { stateParameter = CommonHelper.randomString(10); } return stateParameter; }
code_review: Why did you remove the `stateData`?
target code: protected String getStateParameter ( final WebContext context ) { final String stateParameter ; if ( CommonHelper . isNotBlank ( stateData ) ) { stateParameter = stateData ; } else { stateParameter = CommonHelper . randomString ( 10 ) ; } return stateParameter ; }
response: protected String getStateParameter(final WebContext context) { <START> final String stateData = getState(); <END> if (CommonHelper.isNotBlank(stateData)) { return stateData; } else { return CommonHelper.randomString(10); } }

sample: 1547
buggy_code: public DSpaceCommandLineParameter(String parameter) { <START> this(StringUtils.substringBefore(parameter, " "), StringUtils.substringAfter(parameter, " ")); <END> }
code_review: This logic seems potentially fragile. What if someone accidentally types in *two spaces*, e.g. `-c[space][space]test`. Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)? If we could just use that CLI API directly, it'd be better than rewriting it ourselves.
target code: protected DSpaceCommandLineParameter ( String parameter ) { this ( StringUtils . substringBefore ( parameter , " " ) , StringUtils . substringAfter ( parameter , " " ) ) ; }
response: public DSpaceCommandLineParameter(String parameter) { <START> this(StringUtils.substringBefore(parameter, " "), StringUtils.substringAfter(parameter, " ")); <END> }

sample: 1548
buggy_code: protected Transferable createTransferable(JComponent c) { indices = list.getSelectedIndices(); <START> if (list.isSelectionEmpty()) return null; <END> return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList()); }
code_review: Does this have to be after the above line? Seems like it may as well be right before. Or you could just check that the returned list is empty. Or you can do both.
target code: protected Transferable createTransferable ( JComponent c ) { if ( list . isSelectionEmpty ( ) ) return null ; indices = list . getSelectedIndices ( ) ; return new ActionTransferable ( ( ArrayList < Action > ) list . getSelectedValuesList ( ) ) ; }
response: protected Transferable createTransferable(JComponent c) { indices = list.getSelectedIndices(); <START> if (list.isSelectionEmpty()) return null; <END> return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList()); }

sample: 1549
buggy_code: public List<NimbusInfo> getAllNimbuses() { List<NimbusInfo> nimbusInfos = new ArrayList<>(); try { Collection<Participant> participants = leaderLatch.get().getParticipants(); for (Participant participant : participants) { nimbusInfos.add(Zookeeper.toNimbusInfo(participant)); } } catch (Exception e) { LOG.warn("failed to get nimbuses", e); <START> } <END> return nimbusInfos; }
code_review: Again don't eat the exception throw it, and wrap it if you cannot update the interface.
target code: public List < NimbusInfo > getAllNimbuses ( ) throws Exception { List < NimbusInfo > nimbusInfos = new ArrayList < > ( ) ; Collection < Participant > participants = leaderLatch . get ( ) . getParticipants ( ) ; for ( Participant participant : participants ) { nimbusInfos . add ( Zookeeper . toNimbusInfo ( participant ) ) ; } return nimbusInfos ; }
response: public List<NimbusInfo> getAllNimbuses() { List<NimbusInfo> nimbusInfos = new ArrayList<>(); try { Collection<Participant> participants = leaderLatch.get().getParticipants(); for (Participant participant : participants) { nimbusInfos.add(Zookeeper.toNimbusInfo(participant)); } } catch (Exception e) { LOG.warn("failed to get nimbuses", e); throw new RuntimeException(e); } return nimbusInfos; }

sample: 1550
buggy_code: <START> protected void doBegin() throws TransactionException { <END> if (txManager == null) { throw new IllegalStateException(CoreMessages .objectNotRegistered("javax.transaction.TransactionManager", "Transaction Manager").getMessage()); } try { txManager.setTransactionTimeout(getTimeoutInSeconds()); txManager.begin(); synchronized (this) { transaction = txManager.getTransaction(); } } catch (Exception e) { throw new TransactionException(cannotStartTransaction("XA"), e); } }
code_review: deprecate this
target code: protected void doBegin ( ) throws TransactionException { if ( txManager == null ) { throw new IllegalStateException ( objectNotRegistered ( "javax . transaction . TransactionManager" , "Transaction Manager" ) . getMessage ( ) ) ; } try { txManager . setTransactionTimeout ( getTimeoutInSeconds ( ) ) ; txManager . begin ( ) ; synchronized ( this ) { transaction = txManager . getTransaction ( ) ; } } catch ( Exception e ) { throw new TransactionException ( cannotStartTransaction ( "XA" ) , e ) ; } }
response: <START> protected void doBegin() throws TransactionException { <END> if (txManager == null) { throw new IllegalStateException(CoreMessages .objectNotRegistered("javax.transaction.TransactionManager", "Transaction Manager").getMessage()); } try { txManager.setTransactionTimeout(getTimeoutInSeconds()); txManager.begin(); synchronized (this) { transaction = txManager.getTransaction(); } } catch (Exception e) { throw new TransactionException(cannotStartTransaction("XA"), e); } }

sample: 1551
buggy_code: public int hashCode() { int hash = 7; hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0); <START> return hash; <END> }
code_review: Why not use `org.modeshape.common.util.HashCode.compute(...)` instead of this? Or better yet, why not just return `name.hashCode()`? (When can `name` be null?)
target code: public int hashCode ( ) { return name . hashCode ( ) ; }
response: public int hashCode() { int hash = 7; hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0); return hash; }

sample: 1552
buggy_code: public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) { Exception exception = null; frontendMetrics.securityServicePostProcessRequestRate.mark(); long startTimeMs = System.currentTimeMillis(); if (!isOpen) { exception = new RestServiceException("SecurityService is closed", RestServiceErrorCode.ServiceUnavailable); } else if (restRequest == null || callback == null) { throw new IllegalArgumentException("RestRequest or Callback is null"); } <START> callback.onCompletion(null, exception); <END> frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs); }
code_review: this should be before the callback I think
target code: public void postProcessRequest ( RestRequest restRequest , Callback < Void > callback ) { Exception exception = null ; frontendMetrics . securityServicePostProcessRequestRate . mark ( ) ; long startTimeMs = System . currentTimeMillis ( ) ; if ( ! isOpen ) { exception = new RestServiceException ( "SecurityService is closed" , RestServiceErrorCode . ServiceUnavailable ) ; } else if ( restRequest == null || callback == null ) { throw new IllegalArgumentException ( "RestRequest or Callback is null" ) ; } frontendMetrics . securityServicePostProcessRequestTimeInMs . update ( System . currentTimeMillis ( ) - startTimeMs ) ; callback . onCompletion ( null , exception ) ; }
response: public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) { Exception exception = null; frontendMetrics.securityServicePostProcessRequestRate.mark(); long startTimeMs = System.currentTimeMillis(); if (!isOpen) { exception = new RestServiceException("SecurityService is closed", RestServiceErrorCode.ServiceUnavailable); } else if (restRequest == null || callback == null) { throw new IllegalArgumentException("RestRequest or Callback is null"); } <START> frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs); callback.onCompletion(null, exception); <END> }

sample: 1553
buggy_code: <START> private IMethod[] <END> toArray(List<IMethod> methods) { return methods.toArray(new IMethod[methods.size()]); }
code_review: static
target code: private static IMethod [ ] toArray ( List < IMethod > methods ) { return methods . toArray ( new IMethod [ methods . size ( ) ] ) ; }
response: <START> private static IMethod[] <END> toArray(List<IMethod> methods) { return methods.toArray(new IMethod[methods.size()]); }

sample: 1554
buggy_code: public UserProfileParameters() { <START> profile.setId(Guid.newGuid()); <END> }
code_review: update wouldn't work if the id is always a new id setting a new id is the job of add command
target code: public UserProfileParameters ( ) { }
response: public UserProfileParameters() { <START> profile.setId(Guid.newGuid()); <END> }

sample: 1555
buggy_code: public void onActivityPaused(Activity activity) { if (null != mCurInAppNotification) { <START> mCurInAppNotification.dismiss(); <END> } }
code_review: It is safe to call dismiss multiple times, in the source for dismiss(), there's a nice global if check along the lines of (mView != null && isVisible()) or something.
target code: public void onActivityPaused ( Activity activity ) { }
response: public void onActivityPaused(Activity activity) { if (null != mCurInAppNotification) { <START> mCurInAppNotification.dismiss(); <END> } }

sample: 1556
buggy_code: <START> public void createReplyReplyDone() { <END> createButton(buttonparent, buttonReply_ID, buttonReply_caption, true); createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true); buttonBar.pack(); }
code_review: Done
target code: private void createReplyReplyDone ( ) { createButton ( buttonparent , buttonReply_ID , buttonReply_caption , true ) ; createButton ( buttonparent , buttonReplyDone_ID , buttonReplyDone_caption , true ) ; buttonBar . pack ( ) ; }
response: <START> public void createReplyReplyDone() { <END> createButton(buttonparent, buttonReply_ID, buttonReply_caption, true); createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true); buttonBar.pack(); }

sample: 1557
buggy_code: public void noMoreBubble() { config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), "1"); initExecutor(); final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory(); taskFactory.delayMs = 1000; executor.executeOnPartitions(taskFactory, newPartitions()); final DummyOperation op = new DummyOperation(); executor.execute(op); assertTrueEventually(new AssertTask() { @Override public void run() { assertTrue(op.completed); } <START> }, SECONDS.toMillis(5)); <END> }
code_review: `SECONDS.toMillis(5)` -> `5`. Timeout parameter of `assertTrueEventually(..)` is in seconds, not milliseconds.
target code: public void noMoreBubble ( ) { config . setProperty ( PARTITION_OPERATION_THREAD_COUNT . getName ( ) , "1" ) ; initExecutor ( ) ; final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory ( ) ; taskFactory . delayMs = 1000 ; executor . executeOnPartitions ( taskFactory , newPartitions ( ) ) ; final DummyOperation op = new DummyOperation ( ) ; executor . execute ( op ) ; assertTrueEventually ( new AssertTask ( ) { @Override public void run ( ) { assertTrue ( op . completed ) ; } } , 5 ) ; }
response: public void noMoreBubble() { config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), "1"); initExecutor(); final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory(); taskFactory.delayMs = 1000; executor.executeOnPartitions(taskFactory, newPartitions()); final DummyOperation op = new DummyOperation(); executor.execute(op); assertTrueEventually(new AssertTask() { @Override public void run() { assertTrue(op.completed); } <START> }, 5); <END> }

sample: 1558
buggy_code: public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() { CohortMembership cohortMembership = new CohortMembership(12); <START> boolean result = cohortMembership.equals(cohortMembership); <END> assertTrue(result); }
code_review: I guess we could just assert without the temporary variable.
target code: public void equal_shouldReturnTrueIfObjectReferenceAreTheSame ( ) { CohortMembership cohortMembership = new CohortMembership ( 12 ) ; assertTrue ( cohortMembership . equals ( cohortMembership ) ) ; }
response: public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() { CohortMembership cohortMembership = new CohortMembership(12); <START> assertTrue(cohortMembership.equals(cohortMembership)); <END> }

sample: 1559
buggy_code: <START> public DynamicState withPendingLocalization(Future<Void> pendingDownload) { <END> return new DynamicState(this.state, this.newAssignment, this.container, this.currentAssignment, this.pendingLocalization, this.startTime, pendingDownload, this.profileActions, this.pendingStopProfileActions); }
code_review: nit, could return: withPendingLocalization(this.pendingLocalization, pendingDownload);
target code: public DynamicState withPendingLocalization ( Future < Void > pendingDownload ) { return withPendingLocalization ( this . pendingLocalization , pendingDownload ) ; }
response: <START> public DynamicState withPendingLocalization(Future<Void> pendingDownload) { <END> return withPendingLocalization(this.pendingLocalization, pendingDownload); }

sample: 1560
buggy_code: public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) { try { final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password, clientVersionInfo); if (!information.isPresent()) { /* to many bad attempts, otherwise we get an exception */ ModelUtil.logWarning( MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay)); } return <START> information.isPresent(); <END> } catch (final AccessControlException ex) { /* regular bad attempt */ return false; } }
code_review: We could also return true here, which seems to be more obvious to me
target code: public boolean verifyUser ( String username , String password , ESClientVersionInfo clientVersionInfo ) { try { final Optional < ESAuthenticationInformation > information = doVerifyUser ( username , password , clientVersionInfo ) ; if ( ! information . isPresent ( ) ) { /* too many bad attempts , otherwise we get an exception */ ModelUtil . logWarning ( MessageFormat . format ( Messages . LoginService_VerifyUserTooManyFailedRequests , username , delay ) ) ; } return true ; } catch ( final AccessControlException ex ) { /* regular bad attempt */ return false ; } }
response: public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) { try { final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password, clientVersionInfo); if (!information.isPresent()) { /* to many bad attempts, otherwise we get an exception */ ModelUtil.logWarning( MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay)); } return <START> true; <END> } catch (final AccessControlException ex) { /* regular bad attempt */ return false; } }

sample: 1561
buggy_code: public void test() throws Exception { ExternalBuildReport report = new ExternalBuildReport("http://some.url.com"); assertEquals("View External Report", report.getDisplayName()); assertEquals("graph.gif", report.getIconFileName()); <START> assertEquals("graph.gif", report.getIconFileName()); <END> assertEquals("http://some.url.com", report.getUrlName()); assertEquals(null, report.getTarget()); }
code_review: duplicate assert
target code: public void test ( ) throws Exception { ExternalBuildReport report = new ExternalBuildReport ( "http :/ / some . url . com" ) ; assertEquals ( "View External Report" , report . getDisplayName ( ) ) ; assertEquals ( "graph . gif" , report . getIconFileName ( ) ) ; assertEquals ( "http :/ / some . url . com" , report . getUrlName ( ) ) ; assertEquals ( null , report . getTarget ( ) ) ; }
response: public void test() throws Exception { ExternalBuildReport report = new ExternalBuildReport("http://some.url.com"); assertEquals("View External Report", report.getDisplayName()); assertEquals("graph.gif", report.getIconFileName()); <START> assertEquals("http://some.url.com", report.getUrlName()); <END> assertEquals(null, report.getTarget()); }

sample: 1562
buggy_code: public void publishEvent(Object event) { <START> publishEvent(new PayloadApplicationEvent<Object>(null, event)); <END> }
code_review: The null `source` looks odd.
target code: public void publishEvent ( Object event ) { publishEvent ( new PayloadApplicationEvent < > ( this , event ) ) ; }
response: public void publishEvent(Object event) { <START> publishEvent(new PayloadApplicationEvent<Object>(this, event)); <END> }

sample: 1563
buggy_code: public boolean isList() { <START> if (isProperty) <END> return prop.isList(); else return false; }
code_review: Personally for all these simple things, I would simple it down to a ternary operation for code simplicity. Always keep in mind code size.
target code: public boolean isList ( ) { return isProperty && prop . isList ( ) ; }
response: public boolean isList() { <START> return isProperty ? prop.isList() : false; <END> }

sample: 1564
buggy_code: private GlusterGeoRepSession getGeoRepSession() { if (getParameters().getGeoRepSessionId() != null) { return geoRepDao.getById(getParameters().getGeoRepSessionId()); } <START> return null; <END> }
code_review: I don't think we need this check nor this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) when needed, if getParameters().getGeoRepSessionId() we will simply won't get any result
target code: private GlusterGeoRepSession getGeoRepSession ( ) { return geoRepDao . getById ( getParameters ( ) . getGeoRepSessionId ( ) ) ; }
response: private GlusterGeoRepSession getGeoRepSession() { return geoRepDao.getById(getParameters().getGeoRepSessionId()); }

sample: 1565
buggy_code: protected Statement createFailOnTimeoutStatement( <START> Statement statement, Description description) throws Exception { <END> return FailOnTimeout.builder() .withTimeout(timeout, timeUnit) .withLookingForStuckThread(lookForStuckThread) .withDescription(description) .build(statement); }
code_review: Unfortunately this method is protected. Changing the signature may break someone. @junit-team/junit-committers how should we handle this? We could not add the new feature without breaking the extension point. I'm in favour of modifying the methods signature and making it private. Users should create a new rule instead of extending Timeout. They could use the builder for creating the statement.
target code: private Statement createFailOnTimeoutStatement ( Statement statement , Description description ) throws Exception { return FailOnTimeout . builder ( ) . withDescription ( description ) . build ( createFailOnTimeoutStatement ( statement ) ) ; }
response: private Statement createFailOnTimeoutStatement( <START> Statement statement, Description description) throws Exception { <END> return FailOnTimeout.builder() .withTimeout(timeout, timeUnit) .withLookingForStuckThread(lookForStuckThread) .withDescription(description) .build(statement); }

sample: 1566
buggy_code: @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator( IntIterator stops ) { Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); int stopIndex = stops.next(); while (stopIndex > 0) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stopIndex)); stopIndex = stops.next(); } <START> return activeTripPatternsForGivenStops.iterator(); <END> }
code_review: The loop fails if `stops` contains _the first_ stop (`0`). The method should be: ``` Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); while (stops.hasNext()) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next())); } return activeTripPatternsForGivenStops.iterator(); ```
target code: @Override public Iterator < ? extends TripPatternInfo < TripSchedule > > patternIterator ( IntIterator stops ) { Set < TripPatternInfo < TripSchedule > > activeTripPatternsForGivenStops = new HashSet < > ( ) ; while ( stops . hasNext ( ) ) { activeTripPatternsForGivenStops . addAll ( activeTripPatternsPerStop . get ( stops . next ( ) ) ) ; } return activeTripPatternsForGivenStops . iterator ( ) ; }
response: @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator( IntIterator stops ) { Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); <START> while (stops.hasNext()) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next())); } <END> return activeTripPatternsForGivenStops.iterator(); }

sample: 1567
buggy_code: public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) { this.context = context; this.type = type; <START> this.qualifiers = asSet(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE); <END> this.qualifiers.addAll(qualifiers); }
code_review: This is likely unnecessary. The set of qualifiers is expected to contain all elements. See also `org.jboss.weld.bootstrap.WeldStartup.createContexts(ServiceRegistry)` and other places where this constructor is used.
target code: public ContextHolder ( T context , Class < T > type , Set < Annotation > qualifiers ) { this . context = context ; this . type = type ; this . qualifiers = qualifiers ; }
response: public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) { this.context = context; this.type = type; <START> this.qualifiers = qualifiers; <END> this.qualifiers.addAll(qualifiers); }

sample: 1568
buggy_code: public void setUp() { <START> jenkins.CLI.get().setEnabled(true); <END> Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols()); agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName()); j.jenkins.setAgentProtocols(agentProtocols); }
code_review: Unnecessary; it is still enabled by default in core, disabled in wizard.
target code: public void setUp ( ) { Set < String > agentProtocols = new HashSet < > ( j . jenkins . getAgentProtocols ( ) ) ; agentProtocols . add ( ExtensionList . lookupSingleton ( CliProtocol2 . class ) . getName ( ) ) ; j . jenkins . setAgentProtocols ( agentProtocols ) ; }
response: public void setUp() { Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols()); agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName()); j.jenkins.setAgentProtocols(agentProtocols); }

sample: 1569
buggy_code: public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = <START> 1; <END> }
code_review: There is a lack of symmetry here. `positionGap` should be initialized in both ctors.
target code: public FieldWrapper ( HighlightExecutionContext executionContext , HighlighterContext context , BasicQueryWeigher weigher ) { this . executionContext = executionContext ; this . context = context ; this . weigher = weigher ; }
response: public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = <START> 1; <END> } public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher, int positionGap) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = positionGap; }

sample: 1570
buggy_code: public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups) { this.streams = ImmutableList.copyOf(requireNonNull(streams, "streams is null")); this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, "columnEncodings is null")); <START> this.stripeEncryptionGroups = requireNonNull(stripeEncryptionGroups, "stripeEncryptionGroups is null"); <END> }
code_review: `ImmutableList.copyOf`
target code: public StripeFooter ( List < Stream > streams , List < ColumnEncoding > columnEncodings , List < Slice > stripeEncryptionGroups ) { this . streams = ImmutableList . copyOf ( requireNonNull ( streams , "streams is null" ) ) ; this . columnEncodings = ImmutableList . copyOf ( requireNonNull ( columnEncodings , "columnEncodings is null" ) ) ; this . stripeEncryptionGroups = ImmutableList . copyOf ( requireNonNull ( stripeEncryptionGroups , "stripeEncryptionGroups is null" ) ) ; }
response: public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups) { this.streams = ImmutableList.copyOf(requireNonNull(streams, "streams is null")); this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, "columnEncodings is null")); <START> this.stripeEncryptionGroups = ImmutableList.copyOf(requireNonNull(stripeEncryptionGroups, "stripeEncryptionGroups is null")); <END> }

sample: 1571
buggy_code: public Double getValue() { //do not miss the last tuple try { <START> estimator.accumulate(cx); <END> } catch (ExecException ex) { throw new RuntimeException("Error while accumulating sample frequency: " + ex); } return estimator.getEntropy(); }
code_review: i'm not sure how getValue() is supposed to be called, but I would make it work correctly even if it is called twice. that is, set cx back to zero after you accumulate.
target code: public Double getValue ( ) { // do not miss the last tuple try { this . estimator . accumulate ( this . cx ) ; } catch ( ExecException ex ) { throw new RuntimeException ( "Error while accumulating sample frequency : " + ex ) ; } return this . estimator . getEntropy ( ) ; }
response: public Double getValue() { //do not miss the last tuple try { <START> estimator.accumulate(cx); cx = 0; <END> } catch (ExecException ex) { throw new RuntimeException("Error while accumulating sample frequency: " + ex); } return estimator.getEntropy(); }

sample: 1572
buggy_code: private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) { boolean result = true; ResultSet rs = null; try { rs = metaData.getSchemas(); while (rs.next() && result) { result = false; } } catch (SQLException e) { throw JdbcUtils.wrapException(e, "retrieve schema and catalog metadata", JdbcActionType.METADATA); } finally { FileHelper.safeClose(rs); <START> close(null); <END> } return result; }
code_review: Hmm I think we should remove this line. Seems like it's not needed since `close(null)` will just do nothing. Maybe it's a left-over line from some previous version of the file where the result set got closed properly or something :-)
target code: private boolean usesCatalogsAsSchemas ( DatabaseMetaData metaData ) { boolean result = true ; ResultSet rs = null ; try { rs = metaData . getSchemas ( ) ; while ( rs . next ( ) && result ) { result = false ; } } catch ( SQLException e ) { throw JdbcUtils . wrapException ( e , "retrieve schema and catalog metadata" , JdbcActionType . METADATA ) ; } finally { FileHelper . safeClose ( rs ) ; } return result ; }
response: private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) { boolean result = true; ResultSet rs = null; try { rs = metaData.getSchemas(); while (rs.next() && result) { result = false; } } catch (SQLException e) { throw JdbcUtils.wrapException(e, "retrieve schema and catalog metadata", JdbcActionType.METADATA); } finally { FileHelper.safeClose(rs); <START> close(null); <END> } return result; }

sample: 1573
buggy_code: public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) { if (!event.isPre()) { emitSessionDestroyedEvent((String) event.getKey()); } <START> } <END>
code_review: those `if (!event.isPre())` can be avoided by adding `@Listener(observation = Observation.POST)` at class level
target code: public void processCacheEntryDestroyed ( CacheEntryRemovedEvent event ) { emitSessionDestroyedEvent ( ( String ) event . getKey ( ) ) ; }
response: public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) { emitSessionDestroyedEvent((String) event.getKey()); <START> } <END>

sample: 1574
buggy_code: public void invalidate(@Nullable String path) { if (path == null) { <START> return; <END> } invalidate(Uri.parse(path)); }
code_review: Flip the `if` and move the invalidate call up inside
target code: public void invalidate ( @Nullable String path ) { if ( path != null ) { invalidate ( Uri . parse ( path ) ) ; } }
response: public void invalidate(@Nullable String path) { if (path != null) { invalidate(Uri.parse(path)); } <START> return; <END> }

sample: 1575
buggy_code: public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null && disconnectableRegisterer == null) { return this.withConnectableCallbacks().withDisconnectableCallbacks(); } else if (connectableRegisterer == null) { return this.withConnectableCallbacks(); } else if (disconnectableRegisterer == null) { return this.withDisconnectableCallbacks(); } <START> return this; <END> }
code_review: could this block be simplified? ``` java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; } ```
target code: public MerlinBuilder withRxCallbacks ( ) { rxCallbacksManager = new RxCallbacksManager ( ) ; if ( connectableRegisterer == null ) { withConnectableCallbacks ( ) ; } if ( disconnectableRegisterer == null ) { withDisconnectableCallbacks ( ) ; } return this ; }
response: public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } <START> return this; <END> }

sample: 1576
buggy_code: public static String localizeProvider(String name) { if (name==null) { Assert.isTrue(false); return null; <START> } <END> switch (name) { case DIRECT_PROVIDER: return Messages.ProxySelector_0; case ECLIPSE_PROVIDER: return Messages.ProxySelector_1; case NATIVE_PROVIDER: return Messages.ProxySelector_2; default: break; } Assert.isTrue(false); return null; }
code_review: I don't like this code duplication. How about if (name != null) { switch (name) { ... } } Assert.isTrue(false); return null;
target code: public static String localizeProvider ( String name ) { if ( name != null ) { switch ( name ) { case DIRECT_PROVIDER : return Messages . ProxySelector_0 ; case ECLIPSE_PROVIDER : return Messages . ProxySelector_1 ; case NATIVE_PROVIDER : return Messages . ProxySelector_2 ; default : break ; } } Assert . isTrue ( false ) ; return null ; }
response: public static String localizeProvider(String name) { if (name==null) { Assert.isTrue(false); return null; } switch (name) { case DIRECT_PROVIDER: return Messages.ProxySelector_0; case ECLIPSE_PROVIDER: return Messages.ProxySelector_1; case NATIVE_PROVIDER: return Messages.ProxySelector_2; default: break; } Assert.isTrue(false); return null; }

sample: 1577
buggy_code: <START> public String removeSuffix(String loaderFileName, char suffixTerm) { <END> return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm)); }
code_review: Does this need to be public?
target code: private String removeSuffix ( String loaderFileName , char suffixTerm ) { return loaderFileName . substring ( 0 , loaderFileName . lastIndexOf ( suffixTerm ) ) ; }
response: <START> String removeSuffix(String loaderFileName, char suffixTerm) { <END> return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm)); }

sample: 1578
buggy_code: private BootstrapConfigurationImpl() { this.defaultProviderClassName = null; this.constraintValidatorFactoryClassName = null; this.messageInterpolatorClassName = null; this.traversableResolverClassName = null; this.parameterNameProviderClassName = null; this.clockProviderClassName = null; <START> this.valueExtractorClassNames = new HashSet<>( 0 ); <END> this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES; this.isExecutableValidationEnabled = true; this.constraintMappingResourcePaths = newHashSet(); this.properties = newHashMap(); }
code_review: Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
target code: private BootstrapConfigurationImpl ( ) { this . defaultProviderClassName = null ; this . constraintValidatorFactoryClassName = null ; this . messageInterpolatorClassName = null ; this . traversableResolverClassName = null ; this . parameterNameProviderClassName = null ; this . clockProviderClassName = null ; this . valueExtractorClassNames = new HashSet < > ( ) ; this . validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES ; this . isExecutableValidationEnabled = true ; this . constraintMappingResourcePaths = new HashSet < > ( ) ; this . properties = new HashMap < > ( ) ; }
response: private BootstrapConfigurationImpl() { this.defaultProviderClassName = null; this.constraintValidatorFactoryClassName = null; this.messageInterpolatorClassName = null; this.traversableResolverClassName = null; this.parameterNameProviderClassName = null; this.clockProviderClassName = null; <START> this.valueExtractorClassNames = newHashSet(); <END> this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES; this.isExecutableValidationEnabled = true; this.constraintMappingResourcePaths = newHashSet(); this.properties = newHashMap(); }

sample: 1579
buggy_code: public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException { file.getParentFile().mkdirs(); try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) { ByteStreams.copy(is, os); } finally { CloseQuietly.close(is); } <START> return FileUtils.FileCopyResult.buildResult(file.toPath()); <END> }
code_review: I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions.
target code: public static long copyToFileAndClose ( InputStream is , File file ) throws IOException { file . getParentFile ( ) . mkdirs ( ) ; try ( OutputStream os = new BufferedOutputStream ( new FileOutputStream ( file ) ) ) { return ByteStreams . copy ( is , os ) ; } finally { CloseQuietly . close ( is ) ; } }
response: public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException { file.getParentFile().mkdirs(); try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) { ByteStreams.copy(is, os); } finally { CloseQuietly.close(is); } <START> return FileUtils.FileCopyResult.buildResult(file.toPath()); <END> }

sample: 1580
buggy_code: <START> @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) { <END> return canceled.compareAndSet( false, true ); }
code_review: If you are using an AtomicBoolean (and dont do anything else), you no longer need the synchronized keyword here.
target code: @Override public boolean cancel ( final boolean mayInterruptIfRunning ) { return canceled . compareAndSet ( false , true ) ; }
response: <START> @Override public boolean cancel( final boolean mayInterruptIfRunning ) { <END> return canceled.compareAndSet( false, true ); }

sample: 1581
buggy_code: protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) { return items .entrySet() .stream() .filter(e -> e.getKey().equals(command)) .findFirst() .orElse(null) <START> .getValue(); <END> }
code_review: hey @manstis , quick looking at this seems that a potential NPE can be produced here? I mean for `orElse(null).getValue()`?
target code: protected AbstractToolbarItem < S > getItem ( final ToolbarCommand < ? > command ) { return items . entrySet ( ) . stream ( ) . filter ( e - > e . getKey ( ) . equals ( command ) ) . findFirst ( ) . map ( Map . Entry : : getValue ) . orElse ( null ) ; }
response: protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) { return items .entrySet() .stream() .filter(e -> e.getKey().equals(command)) .findFirst() .orElse(null) .getValue(); }

sample: 1582
buggy_code: public CellIdentityCdma() { <START> super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, <END> null, null); mNetworkId = Integer.MAX_VALUE; mSystemId = Integer.MAX_VALUE; mBasestationId = Integer.MAX_VALUE; mLongitude = Integer.MAX_VALUE; mLatitude = Integer.MAX_VALUE; mAlphaLong = null; mAlphaShort = null; }
code_review: TAG
target code: public CellIdentityCdma ( ) { super ( TAG , TYPE_CDMA , null , null ) ; mNetworkId = Integer . MAX_VALUE ; mSystemId = Integer . MAX_VALUE ; mBasestationId = Integer . MAX_VALUE ; mLongitude = Integer . MAX_VALUE ; mLatitude = Integer . MAX_VALUE ; mAlphaLong = null ; mAlphaShort = null ; }
response: public CellIdentityCdma() { <START> super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, <END> null, null); mNetworkId = Integer.MAX_VALUE; mSystemId = Integer.MAX_VALUE; mBasestationId = Integer.MAX_VALUE; mLongitude = Integer.MAX_VALUE; mLatitude = Integer.MAX_VALUE; mAlphaLong = null; mAlphaShort = null; } <REVIEW>

sample: 1583
buggy_code: private void header(@NonNull final BecauseYouReadCard card) { CardLargeHeaderView header = new CardLargeHeaderView(getContext()) .setTitle(card.title()) .setSubtitle(card.subtitle()) <START> .setPageTitle(card.pageTitle().getDisplayText()) <END> .setImage(card.image()); header(header); }
code_review: Would encapsulating the underlying implementation of BecauseYouReadCard be better or do we need the PageTitle elsewhere? I'm thinking of my recent PageTitle.getText() bug where I meant to call getDisplayText(). At least the bug could only live in one place. If we expose a large object like PageTitle, we have lots of flexibility to do things beyond what a Card is really meant for. There's some notes on some of the tradeoffs here: https://en.wikipedia.org/wiki/Law_of_Demeter.
target code: private void header ( @NonNull final BecauseYouReadCard card ) { CardLargeHeaderView header = new CardLargeHeaderView ( getContext ( ) ) . setTitle ( card . title ( ) ) . setSubtitle ( card . subtitle ( ) ) . setPageTitle ( card . pageTitle ( ) ) . setImage ( card . image ( ) ) ; header ( header ) ; }
response: private void header(@NonNull final BecauseYouReadCard card) { CardLargeHeaderView header = new CardLargeHeaderView(getContext()) .setTitle(card.title()) .setSubtitle(card.subtitle()) <START> .setPageTitle(card.getPageTitle()) <END> .setImage(card.image()); header(header); }

sample: 1584
buggy_code: private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS; try { <START> checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString())); <END> } catch (NumberFormatException e) { log.warn(String.format("Invalid format for %s parameter, using default value instead", PARAM_MONGODB_CHECK_TIMEOUT), e); } return checkTimeout; }
code_review: `DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString()` -> `String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS)` now that it's an `int`
target code: private int getCheckTimeoutInSeconds ( ConfigurationGenerator cg ) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS ; try { checkTimeout = Integer . parseInt ( cg . getUserConfig ( ) . getProperty ( PARAM_MONGODB_CHECK_TIMEOUT , String . valueOf ( DEFAULT_CHECK_TIMEOUT_IN_SECONDS ) ) ) ; } catch ( NumberFormatException e ) { log . warn ( String . format ( "Invalid format for % s parameter , using default value instead" , PARAM_MONGODB_CHECK_TIMEOUT ) , e ) ; } return checkTimeout ; }
response: private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS; try { <START> checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS))); <END> } catch (NumberFormatException e) { log.warn(String.format("Invalid format for %s parameter, using default value instead", PARAM_MONGODB_CHECK_TIMEOUT), e); } return checkTimeout; }

sample: 1585
buggy_code: private void closeConnection(String deviceId) { DeviceConfig device = deviceConfigCache.get(deviceId); if (device == null) { <START> logger.error("Could not find device '{}'", deviceId); <END> return; } EpsonProjectorDevice remoteController = device.getConnection(); if (remoteController != null) { try { logger.debug("Closing connection to device '{}' ", deviceId); remoteController.disconnect(); } catch (EpsonProjectorException e) { logger.debug("Error occurred when closing connection to device '{}'", deviceId); } } }
code_review: This should be a WARN instead of an ERROR.
target code: private void closeConnection ( String deviceId ) { DeviceConfig device = deviceConfigCache . get ( deviceId ) ; if ( device == null ) { logger . warn ( "Could not find device ' { } '" , deviceId ) ; return ; } EpsonProjectorDevice remoteController = device . getConnection ( ) ; if ( remoteController != null ) { try { logger . debug ( "Closing connection to device ' { } ' " , deviceId ) ; remoteController . disconnect ( ) ; } catch ( EpsonProjectorException e ) { logger . debug ( "Error occurred when closing connection to device ' { } '" , deviceId ) ; } } }
response: private void closeConnection(String deviceId) { DeviceConfig device = deviceConfigCache.get(deviceId); if (device == null) { <START> logger.warn("Could not find device '{}'", deviceId); <END> return; } EpsonProjectorDevice remoteController = device.getConnection(); if (remoteController != null) { try { logger.debug("Closing connection to device '{}' ", deviceId); remoteController.disconnect(); } catch (EpsonProjectorException e) { logger.debug("Error occurred when closing connection to device '{}'", deviceId); } } }

sample: 1586
buggy_code: public void testSimpleAnnotation() { assertGeneratedMatches( <START> Lists.newArrayList("import javax.annotation.Nullable;"), <END> Lists.newArrayList("@Nullable"), Lists.newArrayList("@javax.annotation.Nullable")); }
code_review: I'd prefer ImmutableList.of throughout.
target code: public void testSimpleAnnotation ( ) { assertGeneratedMatches ( ImmutableList . of ( "import javax . annotation . Nullable ; " ) , ImmutableList . of ( "@Nullable" ) , ImmutableList . of ( "@javax . annotation . Nullable" ) ) ; }
response: public void testSimpleAnnotation() { assertGeneratedMatches( <START> ImmutableList.of("import javax.annotation.Nullable;"), <END> ImmutableList.of("@Nullable"), ImmutableList.of("@javax.annotation.Nullable")); }

sample: 1587
buggy_code: public void testUnionPointWithEmptyLineString() { <START> assertUnion("POINT (1 2)", "LINESTRING EMPTY", "GEOMETRYCOLLECTION (POINT (1 2))"); <END> }
code_review: I'd expect the union of `POINT (1, 2)` and `LINESTRING EMPTY` to be `POINT (1, 2)`, but this test asserts the result to be `GEOMETRYCOLLECTION (POINT (1 2))`.
target code: public void testUnionPointWithEmptyLineString ( ) { assertUnion ( "POINT ( 1 2 ) " , "LINESTRING EMPTY" , "POINT ( 1 2 ) " ) ; }
response: public void testUnionPointWithEmptyLineString() { <START> assertUnion("POINT (1 2)", "LINESTRING EMPTY", "POINT (1 2)"); <END> }

sample: 1588
buggy_code: <START> public Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) <END> { super(entity, entityRenderer, x, y, z); this.layerRenderer = layerRenderer; }
code_review: protected?
target code: protected Layers ( EntityLivingBase entity , RenderLivingBase < T > entityRenderer , LayerRenderer < T > layerRenderer , double x , double y , double z ) { super ( entity , entityRenderer , x , y , z ) ; this . layerRenderer = layerRenderer ; }
response: <START> protected Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) <END> { super(entity, entityRenderer, x, y, z); this.layerRenderer = layerRenderer; }

sample: 1589
buggy_code: public void deleteOldDeployments(final IServer server) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder(); Arrays.stream(server.getModules()) <START> .forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); <END> }
code_review: Seems the output name cache should be reset here, not below.
target code: public void deleteOldDeployments ( final IServer server ) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder ( ) ; Arrays . stream ( server . getModules ( ) ) . forEach ( module - > deleteOldDeployment ( module , deploymentsRootFolder , server ) ) ; }
response: public void deleteOldDeployments(final IServer server) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder(); Arrays.stream(server.getModules()) <START> .forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); <END> }

sample: 1590
buggy_code: public CronTab(String format, int line, Hash hash) throws ANTLRException { <START> set(format, line, hash); <END> }
code_review: I would recommend to use <code>this()</code> in this constructor
target code: public CronTab ( String format , int line , Hash hash ) throws ANTLRException { this ( format , line , hash , null ) ; }
response: public CronTab(String format, int line, Hash hash) throws ANTLRException { <START> this(format, line, hash); <END> }

sample: 1591
buggy_code: public boolean isKeyFrame(byte[] buff, int off, int len) { <START> if (buff == null || len < 1 || buff.length < len) <END> { return false; } int nalType = buff[off] & kTypeMask; // Single NAL Unit Packet if (nalType == kFuA) { // Fragmented NAL units (FU-A). if (parseFuaNaluForKeyFrame(buff, off, len)) { return true; } } else { if (parseSingleNaluForKeyFrame(buff, off, len)) { return true; } } return false; }
code_review: @mdaneshi, do you think it would make sense to have something like this in every static methods that you wrote? ``` if (buf == null || Math.min(buf.length, len) < off + 1 /* required array length for this method to work correctly */) { return false; } ``` I know this is not a common practice currently in libjitsi and we sometimes are a little sloppy when we access arrays, but I believe we should change this and write more defensive code whenever possible.
target code: public static boolean isKeyFrame ( byte [ ] buff , int off , int len ) { if ( buff == null || buff . length < off + Math . max ( len , 1 ) ) { return false ; } int nalType = buff [ off ] & kTypeMask ; // Single NAL Unit Packet if ( nalType == kFuA ) { // Fragmented NAL units ( FU - A ) . if ( parseFuaNaluForKeyFrame ( buff , off , len ) ) { return true ; } } else { if ( parseSingleNaluForKeyFrame ( buff , off , len ) ) { return true ; } } return false ; }
response: public boolean isKeyFrame(byte[] buff, int off, int len) { <START> if (buff == null || len < 1 || buff.length < len) <END> { return false; } int nalType = buff[off] & kTypeMask; // Single NAL Unit Packet if (nalType == kFuA) { // Fragmented NAL units (FU-A). if (parseFuaNaluForKeyFrame(buff, off, len)) { return true; } } else { if (parseSingleNaluForKeyFrame(buff, off, len)) { return true; } } return false; }

sample: 1592
buggy_code: <START> public ResponseEntity<?> delete(@RequestBody List<Long> printerIds) throws IOException { <END> for (long id : printerIds) { Printer printer = printerService.get(id); if (printer != null) { printerService.remove(printer); } } return new ResponseEntity<>(HttpStatus.OK); }
code_review: `@ResponseStatus(HttpStatus.NO_RESPONSE)` Then you can change return type to void and remove the return statement
target code: public void delete ( @RequestBody List < Long > printerIds ) throws IOException { for ( long id : printerIds ) { Printer printer = printerService . get ( id ) ; if ( printer != null ) { printerService . remove ( printer ) ; } } }
response: <START> @ResponseStatus(HttpStatus.NO_RESPONSE) public void delete(@RequestBody List<Long> printerIds) throws IOException { <END> for (long id : printerIds) { Printer printer = printerService.get(id); if (printer != null) { printerService.remove(printer); } } }

sample: 1593
buggy_code: public DiskWriteModel getDisk(int deviceId) { return fDisks.computeIfAbsent(deviceId, k -> new <START> DiskWriteModel(deviceId, checkNotNull(getStateSystemBuilder()))); <END> }
code_review: Use k, like you did in the other files
target code: public DiskWriteModel getDisk ( int deviceId ) { return fDisks . computeIfAbsent ( deviceId , k - > new DiskWriteModel ( k , checkNotNull ( getStateSystemBuilder ( ) ) ) ) ; }
response: public DiskWriteModel getDisk(int deviceId) { return fDisks.computeIfAbsent(deviceId, k -> new <START> DiskWriteModel(k, checkNotNull(getStateSystemBuilder()))); <END> }

sample: 1594
buggy_code: public void testIsConditionValidWhenHeaderIsValid() throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52("header1"); final ConditionCol52 conditionCol2 = fakeConditionCol52("header2"); final Validator validator = new Validator(fakeCompositeColumn(conditionCol1, conditionCol2)); <START> assertFalse(validator.isConditionValid(conditionCol2)); <END> }
code_review: In the context of GUVNOR-2821 I would expect `assertTrue` here, can you please update the `fakeConditionCol52` method to achieve this? Let me know if you don't see my point.
target code: public void testIsConditionValidWhenHeaderIsValid ( ) throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52 ( "header1" ) ; final ConditionCol52 conditionCol2 = fakeConditionCol52 ( "header2" ) ; final Validator validator = new Validator ( fakeCompositeColumn ( conditionCol1 , conditionCol2 ) ) ; assertTrue ( validator . isConditionValid ( conditionCol2 ) ) ; }
response: public void testIsConditionValidWhenHeaderIsValid() throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52("header1"); final ConditionCol52 conditionCol2 = fakeConditionCol52("header2"); final Validator validator = new Validator(fakeCompositeColumn(conditionCol1, conditionCol2)); <START> assertTrue(validator.isConditionValid(conditionCol2)); <END> }

sample: 1595
buggy_code: public StatsManagerMetrics(MetricRegistry registry) { <START> this.registry = registry; <END> statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, "StatsPublishFailureCount")); totalFetchAndAggregateTime = registry.histogram(MetricRegistry.name(StatsManager.class, "TotalFetchAndAggregateTime")); fetchAndAggregateTimePerStore = registry.histogram(MetricRegistry.name(StatsManager.class, "FetchAndAggregateTimePerStore")); }
code_review: does this need to be a class member?
target code: public StatsManagerMetrics ( MetricRegistry registry ) { statsPublishFailureCount = registry . counter ( MetricRegistry . name ( StatsManager . class , "StatsPublishFailureCount" ) ) ; totalFetchAndAggregateTime = registry . histogram ( MetricRegistry . name ( StatsManager . class , "TotalFetchAndAggregateTime" ) ) ; fetchAndAggregateTimePerStore = registry . histogram ( MetricRegistry . name ( StatsManager . class , "FetchAndAggregateTimePerStore" ) ) ; }
response: public StatsManagerMetrics(MetricRegistry registry) { <START> this.registry = registry; <END> statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, "StatsPublishFailureCount")); totalFetchAndAggregateTime = registry.histogram(MetricRegistry.name(StatsManager.class, "TotalFetchAndAggregateTime")); fetchAndAggregateTimePerStore = registry.histogram(MetricRegistry.name(StatsManager.class, "FetchAndAggregateTimePerStore")); }

sample: 1596
buggy_code: BlobStatus(List<String> replicaList) { if (replicaList != null && replicaList.size() > 0) { unavailable.addAll(replicaList); } <START> } <END>
code_review: minor: the `replicaList.size() > 0` check isn't really needed
target code: BlobStatus ( List < String > replicaList ) { if ( replicaList != null ) { unavailable . addAll ( replicaList ) ; } }
response: BlobStatus(List<String> replicaList) { if (replicaList != null) { unavailable.addAll(replicaList); } <START> } <END>

sample: 1597
buggy_code: <START> protected MemcachedClientCallback createMemcachedClientCallback() { <END> return new MemcachedClientCallback() { @Override public byte[] get(final String key) throws IOException { return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key )); } }; }
code_review: MemcachedClientCallback should be renamed to StorageClientCallback
target code: protected MemcachedClientCallback createMemcachedClientCallback ( ) { return new MemcachedClientCallback ( ) { @Override public byte [ ] get ( final String key ) { return _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; } } ; }
response: <START> protected StorageClientCallback createMemcachedClientCallback() { <END> return new StorageClientCallback() { @Override public byte[] get(final String key) throws IOException { return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key )); } }; }

sample: 1598
buggy_code: public void clientId() throws IOException { <START> Stripe.clientId = "ca_test"; <END> chargeBody = resource("charge.json"); }
code_review: Your tests don't rely on `Stripe.clientId` at all, so you should remove this line, rename the method, and get rid of `tearDownMockAndClientId()` entirely.
target code: public void clientId ( ) throws IOException { chargeBody = resource ( "charge . json" ) ; }
response: public void setUp() throws IOException { <START> chargeBody = resource("charge.json"); <END> }

sample: 1599
buggy_code: private XADataSource createXaDataSourceInstance(String className) { try { Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader()); Object instance = BeanUtils.instantiate(dataSourceClass); Assert.isInstanceOf(XADataSource.class, instance); return (XADataSource) instance; } catch (Exception ex) { throw new IllegalStateException( <START> "Unable to create XADataSource instance from '" + className + "'"); <END> } }
code_review: Maybe it would be good to include the causing exception so user knows why it couldn't be created.
target code: private XADataSource createXaDataSourceInstance ( String className ) { try { Class < ? > dataSourceClass = ClassUtils . forName ( className , this . getClass ( ) . getClassLoader ( ) ) ; Object instance = BeanUtils . instantiate ( dataSourceClass ) ; Assert . isInstanceOf ( XADataSource . class , instance ) ; return ( XADataSource ) instance ; } catch ( Exception ex ) { throw new IllegalStateException ( "Unable to create XADataSource instance from '" + className + "'" , ex ) ; } }
response: private XADataSource createXaDataSourceInstance(String className) { try { Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader()); Object instance = BeanUtils.instantiate(dataSourceClass); Assert.isInstanceOf(XADataSource.class, instance); return (XADataSource) instance; } catch (Exception ex) { throw new IllegalStateException( <START> "Unable to create XADataSource instance from '" + className + "'", ex); <END> } }

sample: 1600
buggy_code: protected Optional<ExampleProjectError> getError(Path projectPath) { POM pom = this.getPom(pomService, projectPath); <START> if (pom.getModules().isEmpty() || pom.getModules() == null) { <END> return Optional.empty(); } else { return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(), "")); } }
code_review: You need to swap the order of nullcheck / isEmpty, otherwise it will lead to NPE (if getModules returns null, not sure that's possible) and this validator will fail.
target code: protected Optional < ExampleProjectError > getError ( Path projectPath ) { POM pom = this . getPom ( pomService , projectPath ) ; if ( pom . getModules ( ) == null || pom . getModules ( ) . isEmpty ( ) ) { return Optional . empty ( ) ; } else { return Optional . of ( new ExampleProjectError ( CheckModulesValidator . class . getCanonicalName ( ) , "" ) ) ; } }
response: protected Optional<ExampleProjectError> getError(Path projectPath) { POM pom = this.getPom(pomService, projectPath); <START> if (pom.getModules() == null || pom.getModules().isEmpty()) { <END> return Optional.empty(); } else { return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(), "")); } }

sample: 1601
buggy_code: public boolean isOpen() { <START> return mBaseTransport.isOpen() && mTransport != null && mTransport.isOpen(); <END> }
code_review: When is `mTransport == null`? Isn't it always set to something in `open()`? Also, why do you need to check `mBaseTransport`?
target code: public boolean isOpen ( ) { return mTransport != null && mTransport . isOpen ( ) ; }
response: public boolean isOpen() { <START> return mTransport != null && mTransport.isOpen(); <END> }

sample: 1602
buggy_code: public static void restoreSystemProperties() { System.clearProperty("org.uberfire.nio.git.daemon.enabled"); <START> System.clearProperty("org.uberfire.nio.git.ssh.enabled"); <END> System.clearProperty("org.uberfire.sys.repo.monitor.disabled"); }
code_review: why enabled? why restore those?
target code: public static void restoreSystemProperties ( ) { System . clearProperty ( "org . uberfire . sys . repo . monitor . disabled" ) ; System . clearProperty ( "org . uberfire . nio . git . daemon . enabled" ) ; System . clearProperty ( "org . uberfire . nio . git . ssh . enabled" ) ; System . clearProperty ( "org . uberfire . sys . repo . monitor . disabled" ) ; }
response: public static void restoreSystemProperties() { System.clearProperty("org.uberfire.nio.git.daemon.enabled"); System.clearProperty("org.uberfire.nio.git.ssh.enabled"); System.clearProperty("org.uberfire.sys.repo.monitor.disabled"); }

sample: 1603
buggy_code: protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id, Patch patch) throws AuthorizeException, SQLException { final Group group = dsoService.find(context, id); if (group != null && isPatchUnprocessable(context, group)) { <START> throw new UnprocessableEntityException("This group cannot be patched."); <END> } patchDSpaceObject(apiCategory, model, id, patch); }
code_review: I'd rather see more specific error messages here, as there's a few different scenarios here we should be aware of: * A permanent group's name can *never* be patched. But, its description can be updated. * Same with a Community/Collection group's name (not editable) & description (editable), unless it's detached. In which case it can be patched. So, at a minimum, it seems like we need different errors & checks here. Permanent groups can *never* have name updates, but can have description updates. Community/Collection groups can be updated if the Community/Collection is deleted, but are otherwise considered "permanent".
target code: protected void patch ( Context context , HttpServletRequest request , String apiCategory , String model , UUID id , Patch patch ) throws AuthorizeException , SQLException { patchDSpaceObject ( apiCategory , model , id , patch ) ; }
response: protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id, Patch patch) throws AuthorizeException, SQLException { final Group group = dsoService.find(context, id); if (group != null && isPatchUnprocessable(context, group)) { <START> throw new UnprocessableEntityException("This group cannot be patched."); <END> } patchDSpaceObject(apiCategory, model, id, patch); }

sample: 1604
buggy_code: protected String computeMetricName(Message<?> message) { <START> String counterName = nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); <END> return counterName; }
code_review: no need to assign to counterName just to return on next line. However, we probably should add a null check for the evaluationContext.
target code: protected String computeMetricName ( Message < ? > message ) { return nameExpression . getValue ( evaluationContext , message , CharSequence . class ) . toString ( ) ; }
response: protected String computeMetricName(Message<?> message) { <START> return nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); <END> }

sample: 1605
buggy_code: public boolean supportsBitmapIndex(final BitmapIndexSelector selector) { // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has // an index and does not have multiple values. The lack of multiple values is important because expression // filters treat multi-value arrays as nulls, which doesn't permit index based filtering. <START> return requiredBindings.isEmpty() <END> || (requiredBindings.size() == 1 && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings))); }
code_review: Could you break this statement into multiple for readability?
target code: public boolean supportsBitmapIndex ( final BitmapIndexSelector selector ) { if ( requiredBindings . isEmpty ( ) ) { // Constant expression . return true ; } else if ( requiredBindings . size ( ) == 1 ) { // Single - column expression . We can use bitmap indexes if this column has an index and does not have // multiple values . The lack of multiple values is important because expression filters treat multi - value // arrays as nulls , which doesn't permit index based filtering . final String column = Iterables . getOnlyElement ( requiredBindings ) ; return selector . getBitmapIndex ( column ) != null && ! selector . hasMultipleValues ( column ) ; } else { // Multi - column expression . return false ; } }
response: public boolean supportsBitmapIndex(final BitmapIndexSelector selector) { // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has // an index and does not have multiple values. The lack of multiple values is important because expression // filters treat multi-value arrays as nulls, which doesn't permit index based filtering. <START> return requiredBindings.isEmpty() || (requiredBindings.size() == 1 && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings))); <END> }

sample: 1606
buggy_code: <START> public <END> void setM(Market currentMarket) { this.currentMarket = currentMarket; }
code_review: this method should be changed to private
target code: private void setM ( Market currentMarket ) { this . currentMarket = currentMarket ; }
response: <START> private <END> void setM(Market currentMarket) { this.currentMarket = currentMarket; }

sample: 1607
buggy_code: private long countMapWithAtleastOneQueryCache(Node node) { return maps.stream().filter(distributedObject -> { MapConfig config = node.getConfig().getMapConfig(distributedObject.getName()); if (config != null) { <START> return config.getQueryCacheConfigs().size() >= 1; <END> } return false; }).count(); }
code_review: Please write it as `!config.getQueryCacheConfigs().isEmpty()` instead of checking the size.
target code: private long countMapWithAtleastOneQueryCache ( Node node ) { return maps . stream ( ) . filter ( distributedObject - > { MapConfig config = node . getConfig ( ) . getMapConfig ( distributedObject . getName ( ) ) ; if ( config != null ) { return ! config . getQueryCacheConfigs ( ) . isEmpty ( ) ; } return false ; } ) . count ( ) ; }
response: private long countMapWithAtleastOneQueryCache(Node node) { return maps.stream().filter(distributedObject -> { MapConfig config = node.getConfig().getMapConfig(distributedObject.getName()); if (config != null) { <START> return !config.getQueryCacheConfigs().isEmpty(); <END> } return false; }).count(); }

sample: 1608
buggy_code: public void addModifiedColumns( GlobalConfiguration globalCfg, Value value, Element parent, PropertyAuditingData propertyAuditingData) { String columnName = propertyAuditingData.getModifiedFlagName(); if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); <START> } <END> MetadataTools.addModifiedFlagProperty( parent, propertyAuditingData.getName(), globalCfg.getModifiedFlagSuffix(), columnName ); }
code_review: probably it is better to change it to ``` String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); } else { columnName = propertyAuditingData.getModifiedFlagName(); } ```
target code: public void addModifiedColumns ( GlobalConfiguration globalCfg , Value value , Element parent , PropertyAuditingData propertyAuditingData ) { final String columnName ; if ( propertyAuditingData . isModifiedFlagNameExplicitlySpecified ( ) ) { columnName = propertyAuditingData . getExplicitModifiedFlagName ( ) ; } else { columnName = propertyAuditingData . getModifiedFlagName ( ) ; } MetadataTools . addModifiedFlagProperty ( parent , propertyAuditingData . getName ( ) , globalCfg . getModifiedFlagSuffix ( ) , columnName ) ; }
response: public void addModifiedColumns( GlobalConfiguration globalCfg, Value value, Element parent, PropertyAuditingData propertyAuditingData) { String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); <START> } <END> MetadataTools.addModifiedFlagProperty( parent, propertyAuditingData.getName(), globalCfg.getModifiedFlagSuffix(), columnName ); }

sample: 1609
buggy_code: private boolean isFailedEqualityComparison(Throwable exception) { if (!(exception instanceof ConditionNotSatisfiedError)) return false; <START> final ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; <END> Condition condition = conditionNotSatisfiedError.getCondition(); ExpressionInfo expr = condition.getExpression(); return expr != null && expr.isEqualityComparison() && // it is equality conditionNotSatisfiedError.getCause() == null; // and it is not failed because of exception }
code_review: Why is this final and condition not? Same issue on line 130. Since final is normally not used for local variables in spock, I'd remove it.
target code: private boolean isFailedEqualityComparison ( Throwable exception ) { if ( ! ( exception instanceof ConditionNotSatisfiedError ) ) return false ; ConditionNotSatisfiedError conditionNotSatisfiedError = ( ConditionNotSatisfiedError ) exception ; Condition condition = conditionNotSatisfiedError . getCondition ( ) ; ExpressionInfo expr = condition . getExpression ( ) ; return expr != null && expr . isEqualityComparison ( ) && // it is equality conditionNotSatisfiedError . getCause ( ) == null ; // and it is not failed because of exception }
response: private boolean isFailedEqualityComparison(Throwable exception) { if (!(exception instanceof ConditionNotSatisfiedError)) return false; <START> ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; <END> Condition condition = conditionNotSatisfiedError.getCondition(); ExpressionInfo expr = condition.getExpression(); return expr != null && expr.isEqualityComparison() && // it is equality conditionNotSatisfiedError.getCause() == null; // and it is not failed because of exception }

sample: 1610
buggy_code: public final RedirectAction getLogoutRedirectAction(final WebContext context) { // it's an AJAX request -> unauthorized (instead of a redirection) <START> if (ajaxRequestResolver.isAjax(context)) { <END> logger.info("AJAX request detected -> returning 401"); cleanRequestedUrl(context); return null; } // authentication has already been tried -> unauthorized final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX); if (CommonHelper.isNotBlank(attemptedAuth)) { return null; } init(context); return retrieveLogoutRedirectAction(context); }
code_review: These checks are not necessary for logout.
target code: public final RedirectAction getLogoutRedirectAction ( final WebContext context ) { init ( context ) ; return retrieveLogoutRedirectAction ( context ) ; }
response: public final RedirectAction getLogoutRedirectAction(final WebContext context) { // it's an AJAX request -> unauthorized (instead of a redirection) <START> if (ajaxRequestResolver.isAjax(context)) { <END> logger.info("AJAX request detected -> returning 401"); cleanRequestedUrl(context); return null; } // authentication has already been tried -> unauthorized final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX); if (CommonHelper.isNotBlank(attemptedAuth)) { return null; } init(context); return retrieveLogoutRedirectAction(context); } // Review: These checks are not necessary for logout.

sample: 1611
buggy_code: public void setMainTabSelectedItem(Erratum selectedItem) { <START> logger.info("setMainTabSelectedItem"); //$NON-NLS-1$ <END> updateErrataDetailFormPanel(selectedItem); }
code_review: debug/trace/remove?
target code: public void setMainTabSelectedItem ( Erratum selectedItem ) { updateErrataDetailFormPanel ( selectedItem ) ; }
response: public void setMainTabSelectedItem(Erratum selectedItem) { <START> logger.debug("setMainTabSelectedItem"); //$NON-NLS-1$ <END> updateErrataDetailFormPanel(selectedItem); }

sample: 1612
buggy_code: public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) { this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION); this.namespace = namespace; this.config = config.getPrefixedView(namespace); this.dcInfo = dcInfo; // TODO: Remove this when DiscoveryManager is finally no longer used <START> DiscoveryManager.getInstance().setEurekaInstanceConfig(this); <END> }
code_review: If we need to do this, I feel like we can at least do this somewhere else. A binding for something like DiscoveryManagerInitializer with dependencies on these Config classes might work.
target code: public EurekaArchaius2InstanceConfig ( Config config , String namespace , DataCenterInfo dcInfo ) { this . defaultAppGroup = config . getString ( FALLBACK_APP_GROUP_KEY , Values . UNKNOWN_APPLICATION ) ; this . namespace = namespace ; this . config = config . getPrefixedView ( namespace ) ; this . dcInfo = dcInfo ; }
response: public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) { this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION); this.namespace = namespace; this.config = config.getPrefixedView(namespace); this.dcInfo = dcInfo; // TODO: Remove this when DiscoveryManager is finally no longer used <START> DiscoveryManager.getInstance().setEurekaInstanceConfig(this); <END> }

sample: 1613
buggy_code: public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) { AssertionType assertion = getAssertion(context, null); if (assertion != null) { assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString()); } <START> return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, this.getWebContextProperties(context)); <END> }
code_review: Right here (and in the equivalent 3.0 class) is the only place you're using "this" where a field isn't shadowed, is this intentional?
target code: public AdhocQueryResponse respondingGatewayCrossGatewayQuery ( AdhocQueryRequest body , WebServiceContext context ) { AssertionType assertion = getAssertion ( context , null ) ; if ( assertion != null ) { assertion . setImplementsSpecVersion ( UDDI_SPEC_VERSION . SPEC_2_0 . toString ( ) ) ; } return inboundDocQuery . respondingGatewayCrossGatewayQuery ( body , assertion , getWebContextProperties ( context ) ) ; }
response: public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) { AssertionType assertion = getAssertion(context, null); if (assertion != null) { assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString()); } <START> return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, getWebContextProperties(context)); <END> }

sample: 1614
buggy_code: public void allBindingsChanged(BindingProvider provider) { logger.trace("allBindingsChanged() called."); <START> if (provider instanceof VeluxBindingProvider) { <END> } super.allBindingsChanged(provider); }
code_review: Drop this empty block.
target code: public void allBindingsChanged ( BindingProvider provider ) { logger . trace ( "allBindingsChanged ( ) called . " ) ; super . allBindingsChanged ( provider ) ; }
response: public void allBindingsChanged(BindingProvider provider) { logger.trace("allBindingsChanged() called."); <START> if (provider instanceof VeluxBindingProvider) { <END> } super.allBindingsChanged(provider); }

sample: 1615
buggy_code: private Map<String, String> makeParserFields() { final Map<String, String> fieldMapping = Maps.newHashMap(); for (final SchemaPath sp : getColumns()) { final String drillField = sp.getRootSegment().getPath(); try { <START> final String parserField = HttpdParser.parserFormattedFieldName(drillField); <END> fieldMapping.put(drillField, parserField); } catch (Exception e) { LOG.info("Putting field: " + drillField + " into map", e); } } return fieldMapping; }
code_review: Please, remove `final` modifiers as they seem to be redundant.
target code: private Map < String , String > makeParserFields ( ) { Map < String , String > fieldMapping = new HashMap < > ( ) ; for ( final SchemaPath sp : getColumns ( ) ) { String drillField = sp . getRootSegment ( ) . getPath ( ) ; try { String parserField = HttpdParser . parserFormattedFieldName ( drillField ) ; fieldMapping . put ( drillField , parserField ) ; } catch ( Exception e ) { LOG . info ( "Putting field : " + drillField + " into map" , e ) ; } } return fieldMapping ; }
response: private Map<String, String> makeParserFields() { final Map<String, String> fieldMapping = Maps.newHashMap(); for (final SchemaPath sp : getColumns()) { final String drillField = sp.getRootSegment().getPath(); try { <START> String parserField = HttpdParser.parserFormattedFieldName(drillField); <END> fieldMapping.put(drillField, parserField); } catch (Exception e) { LOG.info("Putting field: " + drillField + " into map", e); } } return fieldMapping; }

sample: 1616
buggy_code: public Builder client(@NonNull OkHttpClient client) { if (client == null) { throw new NullPointerException("client == null"); } if (downloader != null) { throw new IllegalArgumentException("Downloader already set."); } downloader = new OkHttp3Downloader(client, client.cache(), true); return this; <START> } <END>
code_review: Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your `newBuilder()` desire.
target code: public Builder client ( @NonNull OkHttpClient client ) { if ( client == null ) { throw new NullPointerException ( "client == null" ) ; } downloader = new OkHttp3Downloader ( client , client . cache ( ) , true ) ; return this ; }
response: public Builder client(@NonNull OkHttpClient client) { if (client == null) { throw new NullPointerException("client == null"); } downloader = new OkHttp3Downloader(client, client.cache(), true); return this; <START> } <END>

sample: 1617
buggy_code: protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) { final Activity activity = placeManager.getActivity(placeRequest); <START> if (activity != null) { <END> final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } else { return Optional.empty(); } }
code_review: Just a small remark feel free to skip it. It would have a nicer look if you keep if else logic direct like if (activity == null) { return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); }
target code: protected Optional < CoverageReportView > getCoverageReportView ( PlaceRequest placeRequest ) { final Activity activity = placeManager . getActivity ( placeRequest ) ; if ( activity == null ) { return Optional . empty ( ) ; } else { final AbstractWorkbenchActivity coverageActivity = ( AbstractWorkbenchActivity ) activity ; return Optional . of ( ( CoverageReportView ) coverageActivity . getWidget ( ) ) ; } }
response: protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) { final Activity activity = placeManager.getActivity(placeRequest); <START> if (activity == null) { <END> return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } }

sample: 1618
buggy_code: private void edit() { if (getWindow() != null) { return; } AffinityGroup affinityGroup = getSelectedItem(); if (affinityGroup == null) { return; } <START> sortVms(affinityGroup); <END> AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver()); model.init(); setWindow(model); }
code_review: Generally you don't sort the VMs, and in the one case where you do - you don't really sort them either, but just move one to the top of the list. So firstly, consider dropping this method, making edit() protected and add the logic only in VmAffinityGroupListModel. Secondly, you could drop the comparator there and just iterate over the items to find the specific ID and move it to the top of the list, the comparator thing isn't necessary.
target code: private void edit ( ) { if ( getWindow ( ) != null ) { return ; } AffinityGroup affinityGroup = getSelectedItem ( ) ; if ( affinityGroup == null ) { return ; } AffinityGroupModel model = new EditAffinityGroupModel ( affinityGroup , this , getClusterResolver ( ) ) ; model . init ( ) ; setWindow ( model ) ; }
response: private void edit() { if (getWindow() != null) { return; } AffinityGroup affinityGroup = getSelectedItem(); if (affinityGroup == null) { return; } AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver()); model.init(); setWindow(model); }

sample: 1619
buggy_code: public void testIteratorCloses() throws Exception { Kabob bob = db.getJdbi().onDemand(Kabob.class); Iterator<Something> itty = bob.iterateAll(); <START> assertThat(itty.hasNext()).isFalse(); <END> }
code_review: Considering the expected exception for this test, it seems like the `assertThat` is superfluous, and all we really want is `itty.hasNext();`
target code: public void testIteratorCloses ( ) throws Exception { Kabob bob = db . getJdbi ( ) . onDemand ( Kabob . class ) ; Iterator < Something > itty = bob . iterateAll ( ) ; itty . hasNext ( ) ; }
response: public void testIteratorCloses() throws Exception { Kabob bob = db.getJdbi().onDemand(Kabob.class); Iterator<Something> itty = bob.iterateAll(); <START> itty.hasNext(); <END> }

sample: 1620
buggy_code: public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) { Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing); Boolean match = true; <START> assertEquals(swappedIngredients.size(), ings.size()); <END> for (String i : ings) { if (!swappedIngredients.contains(i)) { match = false; break; } } assertTrue(match); }
code_review: Cant the class name be included here so we know where this method is being called from.
target code: public static void assertSwappedIngredientsMatch ( ObjectInstance ing , State s , List < String > ings ) { Set < String > swappedIngredients = IngredientFactory . getRecursiveContentsAndSwapped ( s , ing ) ; Boolean match = true ; Assert . assertEquals ( swappedIngredients . size ( ) , ings . size ( ) ) ; for ( String i : ings ) { if ( ! swappedIngredients . contains ( i ) ) { match = false ; break ; } } Assert . assertTrue ( match ) ; }
response: public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) { Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing); Boolean match = true; <START> assertEquals(swappedIngredients.size(), ings.size()); <END> for (String i : ings) { if (!swappedIngredients.contains(i)) { match = false; break; } } assertTrue(match); }

sample: 1621
buggy_code: public List<Document> getClientDocuments(String clientId) throws MambuApiException { <START> if (clientId == null || clientId.trim().isEmpty()) { <END> throw new IllegalArgumentException("ClientId ID must not be null or empty"); } return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId); }
code_review: Edge case of duplicate code ;) It could be extracted to a common private method with two params for id and type. Up to you if you want to change it or not ;)
target code: public List < Document > getClientDocuments ( String clientId ) throws MambuApiException { if ( clientId == null || clientId . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "ClientId ID must not be null or empty" ) ; } return new DocumentsService ( mambuAPIService ) . getDocuments ( CLIENTS , clientId ) ; }
response: public List<Document> getClientDocuments(String clientId) throws MambuApiException { <START> if (clientId == null || clientId.trim().isEmpty()) { <END> throw new IllegalArgumentException("ClientId ID must not be null or empty"); } return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId); }

sample: 1622
buggy_code: public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertFalse("checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain", <END> command.checkDisksInBackupStorage()); }
code_review: Now this should return true, since there are disks on the storage domain (Remember that you don't check the validate only the method checkDisksInBackupStorage) Change to assertTrue
target code: public void testFailForCheckDisksNotInBackupStorage ( ) { final VM vm = new VM ( ) ; command . setVm ( vm ) ; when ( vmDao . get ( command . getParameters ( ) . getVmId ( ) ) ) . thenReturn ( vm ) ; command . setCluster ( new Cluster ( ) ) ; Guid storageDomainId = initDiskImage ( vm ) ; when ( storageDomainStaticDao . get ( storageDomainId ) ) . thenReturn ( backupStorageDomain ( true ) ) ; assertTrue ( "checkDisksNotInBackupStorage ( ) fails to run because one or more disk is in backup domain" , command . checkDisksInBackupStorage ( ) ) ; }
response: public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertTrue("checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain", <END> command.checkDisksInBackupStorage()); }

sample: 1623
buggy_code: public long skip(long n) { if (n > 0) { long skip = bytes.length - pos; if (skip > n) skip = n; pos += skip; return skip; } else { int idx = Math.min(bytes.length, pos); long skip = idx + n; <START> pos = (int) skip; <END> return skip; } }
code_review: shouldn't be the ```max()``` between ```offset``` and ```skip``` to avoid the ```pos``` to be previous than ```offset```?
target code: public long skip ( long n ) { if ( n > 0 ) { long skip = bytes . length - pos ; if ( skip > n ) skip = n ; pos += skip ; return skip ; } else { int idx = Math . min ( bytes . length , pos ) ; long skip = idx + n ; // Calculate max to avoid skipping before offset pos = ( int ) Math . max ( skip , offset ) ; return skip ; } }
response: public long skip(long n) { if (n > 0) { long skip = bytes.length - pos; if (skip > n) skip = n; pos += skip; return skip; } else { int idx = Math.min(bytes.length, pos); long skip = idx + n; <START> pos = (int) Math.max(offset, skip); <END> return skip; } }

sample: 1624
buggy_code: public void actionPerformed(AnActionEvent e) { BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); <START> s.cleanup(); <END> }
code_review: You may want to put this into a try/finally block.
target code: public void actionPerformed ( AnActionEvent e ) { BaseAction . State s = setupAction ( e ) ; try { List < String > lastTask = Collections . singletonList ( s . getLastRanTask ( ) ) ; s . performTasks ( lastTask ) ; } finally { s . cleanup ( ) ; } }
response: public void actionPerformed(AnActionEvent e) { BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); <START> try { s.cleanup(); } finally { s.cleanup(); } <END> }

sample: 1625
buggy_code: public void addAll(SerializableStatus status) { Assert.isLegal(status != null); SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren(); for (SerializableStatus <START> statuse : <END> statuses) { add(statuse); } }
code_review: rename to s
target code: public void addAll ( SerializableStatus status ) { Assert . isLegal ( status != null ) ; SerializableStatus [ ] statuses = ( SerializableStatus [ ] ) status . getChildren ( ) ; for ( SerializableStatus s : statuses ) { add ( s ) ; } }
response: public void addAll(SerializableStatus status) { Assert.isLegal(status != null); SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren(); for (SerializableStatus <START> s : <END> statuses) { add(s); } }

sample: 1626
buggy_code: protected boolean canDoAction() { <START> return super.canDoAction() && VdsGroupExists() && logicalNetworkExists() && changesAreClusterCompatible(); <END> }
code_review: how about moving logicalNetworkExists() after changesAreClusterCompatible() ? in case changesAreClusterCompatible() returns false, it will save one DB call :)
target code: protected boolean canDoAction ( ) { return super . canDoAction ( ) && VdsGroupExists ( ) && changesAreClusterCompatible ( ) && logicalNetworkExists ( ) ; }
response: protected boolean canDoAction() { <START> return super.canDoAction() && VdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists(); <END> }

sample: 1627
buggy_code: protected void reloadCache() { schemaMappingCache.invalidateAll(); // this preloads the list of schema names Set<String> schemas = getSchemaNames(); // invalidate and remove from the schema table mapping all records, start from scratch for (String key : schemaTableMapping.keySet()) { schemaTableMapping.get(key).invalidateAll(); schemaTableMapping.remove(key); <START> } <END> for (final String schema : schemas) { // this preloads the list of table names for each schema getTableNames(schema); } }
code_review: any reason you can't just iterate through the values? schemaTableMapping.values().foreach(v -> v.invalidateAll()); schemaTableMapping.clear();
target code: protected void reloadCache ( ) { schemaMappingCache . invalidateAll ( ) ; // this preloads the list of schema names Set < String > schemas = getSchemaNames ( ) ; // invalidate and remove from the schema table mapping all records , start from scratch schemaTableMapping . keySet ( ) . forEach ( key - > { schemaTableMapping . get ( key ) . invalidateAll ( ) ; } ) ; schemaTableMapping . clear ( ) ; for ( final String schema : schemas ) { // this preloads the list of table names for each schema getTableNames ( schema ) ; } }
response: protected void reloadCache() { schemaMappingCache.invalidateAll(); // this preloads the list of schema names Set<String> schemas = getSchemaNames(); // invalidate and remove from the schema table mapping all records, start from scratch for (String key : schemaTableMapping.keySet()) { schemaTableMapping.get(key).invalidateAll(); schemaTableMapping.remove(key); <START> } <END> for (final String schema : schemas) { // this preloads the list of table names for each schema getTableNames(schema); } }

sample: 1628
buggy_code: public void testSetUser() { Configuration configuration = generateConfiguration(); configuration.setUser("24601", "m@rp.fr", "MM"); <START> assertEquals(User.class, configuration.getUser().getClass()); <END> assertEquals("24601", configuration.getUser().getId()); assertEquals("m@rp.fr", configuration.getUser().getEmail()); assertEquals("MM", configuration.getUser().getName()); }
code_review: This assertion could be removed as it seems to test the Java type system rather than our code
target code: public void testSetUser ( ) { Configuration configuration = generateConfiguration ( ) ; configuration . setUser ( "24601" , "m@rp . fr" , "MM" ) ; assertEquals ( "24601" , configuration . getUser ( ) . getId ( ) ) ; assertEquals ( "m@rp . fr" , configuration . getUser ( ) . getEmail ( ) ) ; assertEquals ( "MM" , configuration . getUser ( ) . getName ( ) ) ; }
response: public void testSetUser() { Configuration configuration = generateConfiguration(); configuration.setUser("24601", "m@rp.fr", "MM"); <START> assertEquals("24601", configuration.getUser().getId()); <END> assertEquals("m@rp.fr", configuration.getUser().getEmail()); assertEquals("MM", configuration.getUser().getName()); }

sample: 1629
buggy_code: private void writeStringToFile(File file, String str) throws IOException { <START> try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.toString()))) { <END> bw.write(str); } }
code_review: No need to call `file.toString()` -> `FileWriter` can take `File` in the constructor as well.
target code: private void writeStringToFile ( File file , String str ) throws IOException { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ) { bw . write ( str ) ; } }
response: private void writeStringToFile(File file, String str) throws IOException { <START> try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) { <END> bw.write(str); } }

sample: 1630
buggy_code: private RelNode possiblyWrapRootWithOuterLimitFromContext( RelRoot root ) { Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT); if (outerLimitObj == null) { return root.rel; } <START> Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); <END> if (outerLimit == null) { return root.rel; } return LogicalSort.create( root.rel, root.collation, makeBigIntLiteral(0), makeBigIntLiteral(outerLimit) ); }
code_review: Minor: the two calls could be collapsed, since `DimensionHandlerUtils.convertObjectToLong` handles nulls just fine.
target code: private RelNode possiblyWrapRootWithOuterLimitFromContext ( RelRoot root ) { Object outerLimitObj = plannerContext . getQueryContext ( ) . get ( PlannerContext . CTX_SQL_OUTER_LIMIT ) ; Long outerLimit = DimensionHandlerUtils . convertObjectToLong ( outerLimitObj , true ) ; if ( outerLimit == null ) { return root . rel ; } return LogicalSort . create ( root . rel , root . collation , makeBigIntLiteral ( 0 ) , makeBigIntLiteral ( outerLimit ) ) ; }
response: private RelNode possiblyWrapRootWithOuterLimitFromContext( RelRoot root ) { Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT); <START> Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); <END> if (outerLimit == null) { return root.rel; } return LogicalSort.create( root.rel, root.collation, makeBigIntLiteral(0), makeBigIntLiteral(outerLimit) ); }

sample: 1631
buggy_code: <START> public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException { <END> QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig(); try { Properties zkProp = getDefaultZKProperties(); zkProp.setProperty("server.1", "localhost:2888:2888"); quorumPeerConfig.parseProperties(zkProp); fail("ConfigException is expected"); } catch (ConfigException ce) { String expectedMessage = "Client and election port must be different! Please update the configuration file on server.1"; assertEquals(expectedMessage, ce.getMessage()); } }
code_review: nit - ConfigException is unused
target code: public void testSamePortConfiguredForClientAndElection ( ) throws IOException , ConfigException { QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig ( ) ; Properties zkProp = getDefaultZKProperties ( ) ; zkProp . setProperty ( "server . 1" , "localhost : 2888 : 2888" ) ; quorumPeerConfig . parseProperties ( zkProp ) ; }
response: <START> public void testSamePortConfiguredForClientAndElection() throws IOException { <END> QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig(); try { Properties zkProp = getDefaultZKProperties(); zkProp.setProperty("server.1", "localhost:2888:2888"); quorumPeerConfig.parseProperties(zkProp); fail("ConfigException is expected"); } catch (ConfigException ce) { String expectedMessage = "Client and election port must be different! Please update the configuration file on server.1"; assertEquals(expectedMessage, ce.getMessage()); } }

sample: 1632
buggy_code: public static URLConnection openURLConnection(URL url) <START> throws IOException, ConnectException { <END> return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT); }
code_review: ConnectException is not actually thrown by anything... it shouldn't be declared in the `throws`
target code: public static URLConnection openURLConnection ( URL url ) throws IOException { return openURLConnection ( url , DEFAULT_CONNECTION_TIMEOUT ) ; }
response: public static URLConnection openURLConnection(URL url) <START> throws IOException { <END> return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT); }

sample: 1633
buggy_code: public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) { <START> for (VdcActionParametersBase param : parameters) { <END> param.setParentCommand(command.getActionType()); param.setParentParameters(command.getParameters()); } }
code_review: 1. let's replace with params.forEach 2. it makes more sense that this method will reside in HostSetupNetworksParametersBuilder - I don't see how its related to "ReportFailedChildHostOperationsUtil"
target code: public void updateParentCommandId ( ArrayList < VdcActionParametersBase > parameters , CommandBase command ) { parameters . forEach ( param - > { param . setParentCommand ( command . getActionType ( ) ) ; param . setParentParameters ( command . getParameters ( ) ) ; } ) ; }
response: public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) { <START> parameters.forEach(param -> { <END> param.setParentCommand(command.getActionType()); param.setParentParameters(command.getParameters()); }); }

sample: 1634
buggy_code: public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) { RollupType rollupType = null; String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey); if ( rollupTypeStr != null ) { rollupType = RollupType.fromString(rollupTypeStr); } if ( rollupType == null ) { rollupType = RollupType.BF_BASIC; } <START> return getNumericMetricDataForRange(locator, range, gran, rollupType); <END> }
code_review: nm. I misread the diff. I thought ```getDatapointsForRange()``` only called ```getNumericMetricDataForRange()```
target code: public MetricData getDatapointsForRange ( Locator locator , Range range , Granularity gran ) { RollupType rollupType = RollupType . BF_BASIC ; String rollupTypeStr = metaCache . safeGet ( locator , rollupTypeCacheKey ) ; if ( rollupTypeStr != null ) { rollupType = RollupType . fromString ( rollupTypeStr ) ; } return getNumericMetricDataForRange ( locator , range , gran , rollupType ) ; }
response: public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) { RollupType rollupType = null; String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey); if ( rollupTypeStr != null ) { rollupType = RollupType.fromString(rollupTypeStr); } if ( rollupType == null ) { rollupType = RollupType.BF_BASIC; } <START> return getNumericMetricDataForRange(locator, range, gran, rollupType); <END> }

sample: 1635
buggy_code: public boolean shouldProcessRequestedCashAdvancesFromSaeData() { <START> return (getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND).equalsIgnoreCase(KFSConstants.ParameterValues.YES)); <END> }
code_review: to be null safe on here, I would suggest using stringutils.equalsignorecase or start the expression with the constant
target code: public boolean shouldProcessRequestedCashAdvancesFromSaeData ( ) { return ( StringUtils . equalsIgnoreCase ( getConcurParameterValue ( ConcurParameterConstants . CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND ) , KFSConstants . ParameterValues . YES ) ) ; }
response: public boolean shouldProcessRequestedCashAdvancesFromSaeData() { <START> return (KFSConstants.ParameterValues.YES.equalsIgnoreCase(getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND))); <END> }

sample: 1636
buggy_code: static Path resolvePath(Path file, String workingDirectory) { <START> return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, <END> file.getFileName().toString())))); }
code_review: Looks that works OK, but for me it's hard to read. I would rather see better readable return.
target code: static Path resolvePath ( Path file , String workingDirectory ) { if ( file == null ) { return null ; } else if ( file . isAbsolute ( ) ) { return file ; } else if ( file . getFileName ( ) . startsWith ( File . separator ) ) { return file . toAbsolutePath ( ) ; } else { return Paths . get ( workingDirectory , file . getFileName ( ) . toString ( ) ) ; } }
response: static Path resolvePath(Path file, String workingDirectory) { <START> return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, file.getFileName().toString())))); }

sample: 1637
buggy_code: public void removeServiceEventListener(Object listener) { assert getExecutor().isInExecutorThread(); ListenerEntry entry = new ListenerEntry(listener, null); <START> if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_LISTENERS) { <END> String msg = new Formatter().format( "%s %s removed as a service listener to %s (id=%s)", //$NON-NLS-1$ DsfPlugin.getDebugTime(), LoggingUtils.toString(listener), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fListeners.remove(entry); }
code_review: Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.
target code: public void removeServiceEventListener ( Object listener ) { assert getExecutor ( ) . isInExecutorThread ( ) ; ListenerEntry entry = new ListenerEntry ( listener , null ) ; if ( DsfDebugOptions . DEBUG_SESSION_LISTENERS ) { String msg = new Formatter ( ) . format ( " % s % s removed as a service listener to % s ( id = % s ) " , // $NON - NLS - 1$ DsfPlugin . getDebugTime ( ) , LoggingUtils . toString ( listener ) , LoggingUtils . toString ( this ) , getId ( ) ) . toString ( ) ; DsfDebugOptions . trace ( msg ) ; } fListeners . remove ( entry ) ; }
response: public void removeServiceEventListener(Object listener) { assert getExecutor().isInExecutorThread(); ListenerEntry entry = new ListenerEntry(listener, null); <START> if (DsfDebugOptions.DEBUG_SESSION_LISTENERS) { <END> String msg = new Formatter().format( "%s %s removed as a service listener to %s (id=%s)", //$NON-NLS-1$ DsfPlugin.getDebugTime(), LoggingUtils.toString(listener), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fListeners.remove(entry); }

sample: 1638
buggy_code: private static void validateEntityLabel(EntityType entityType) { String label = entityType.getLabel(); <START> if (label.isEmpty()) <END> { throw new MolgenisValidationException( new ConstraintViolation(format("Label of EntityType [%s] is empty", entityType.getId()))); } else if (label.trim().equals("")) { throw new MolgenisValidationException(new ConstraintViolation( format("Label of EntityType [%s] contains only white space", entityType.getId()))); } }
code_review: I smell an incoming NPE here...
target code: private static void validateEntityLabel ( EntityType entityType ) { String label = entityType . getLabel ( ) ; if ( label != null ) { if ( label . isEmpty ( ) ) { throw new MolgenisValidationException ( new ConstraintViolation ( format ( "Label of EntityType [ % s ] is empty" , entityType . getId ( ) ) ) ) ; } else if ( label . trim ( ) . equals ( "" ) ) { throw new MolgenisValidationException ( new ConstraintViolation ( format ( "Label of EntityType [ % s ] contains only white space" , entityType . getId ( ) ) ) ) ; } } }
response: private static void validateEntityLabel(EntityType entityType) { String label = entityType.getLabel(); <START> if (label == null || label.isEmpty()) <END> { throw new MolgenisValidationException( new ConstraintViolation(format("Label of EntityType [%s] is empty", entityType.getId()))); } else if (label.trim().equals("")) { throw new MolgenisValidationException(new ConstraintViolation( format("Label of EntityType [%s] contains only white space", entityType.getId()))); } }

sample: 1639
buggy_code: public void deleteIfExists(File path, String user, String logPrefix) throws IOException { <START> LOG.info("Deleting path {}", path); <END> Path p = path.toPath(); if (Files.exists(p)) { try { FileUtils.forceDelete(path); } catch (FileNotFoundException ignored) {} } }
code_review: We could just call deleteIfExists(path) since it's same.
target code: public void deleteIfExists ( File path , String user , String logPrefix ) throws IOException { // by default no need to do this as a different user deleteIfExists ( path ) ; }
response: public void deleteIfExists(File path, String user, String logPrefix) throws IOException { <START> LOG.info("Deleting path {}", path); <END> Path p = path.toPath(); if (Files.exists(p)) { try { FileUtils.forceDelete(path); } catch (FileNotFoundException ignored) {} } }

sample: 1640
buggy_code: protected void releaseTransport(Transport transport) { <START> if (dedicatedTransport == null) { <END> //we aren't using this transport. we can release it super.releaseTransport(transport); } }
code_review: This could be even `if (dedicatedTransport != transport)`
target code: protected void releaseTransport ( Transport transport ) { if ( dedicatedTransport != transport ) { // we aren't using this transport . we can release it super . releaseTransport ( transport ) ; } }
response: protected void releaseTransport(Transport transport) { <START> if (dedicatedTransport != transport) { <END> //we aren't using this transport. we can release it super.releaseTransport(transport); } }

sample: 1641
buggy_code: String prepare(String name, Map<String, Map<String, String>> domain) { StringBuilder builder = new StringBuilder(name); while (domain.containsKey(name)) { <START> builder.append("~"); <END> } domain.put(builder.toString(), new LinkedHashMap<>()); return builder.toString(); }
code_review: You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized.
target code: String prepare ( String name , Map < String , Map < String , String > > domain ) { StringBuilder builder = new StringBuilder ( name ) ; while ( domain . containsKey ( name ) ) { builder . append ( "~" ) ; } String val = builder . toString ( ) ; domain . put ( val , new LinkedHashMap < > ( ) ) ; return val ; }
response: String prepare(String name, Map<String, Map<String, String>> domain) { while (domain.containsKey(name)) { <START> name += "~"; <END> } domain.put(name, new LinkedHashMap<>()); return name; }

sample: 1642
buggy_code: public synchronized void deleteFile() { closeFile(); File historyTreeFile = fConfig.getStateFile(); try { if (!historyTreeFile.delete()) { /* We didn't succeed in deleting the file */ Activator.getDefault().logError("Failed to delete" + historyTreeFile.getName()); //$NON-NLS-1$ } <START> } catch (SecurityException e) { <END> Activator.getDefault().logError(e.getMessage(), e); } }
code_review: is this a RuntimeException? In which case you probably don't want to catch it.
target code: public synchronized void deleteFile ( ) { closeFile ( ) ; File historyTreeFile = fConfig . getStateFile ( ) ; if ( ! historyTreeFile . delete ( ) ) { /* We didn't succeed in deleting the file */ Activator . getDefault ( ) . logError ( "Failed to delete" + historyTreeFile . getName ( ) ) ; // $NON - NLS - 1$ } }
response: public synchronized void deleteFile() { closeFile(); File historyTreeFile = fConfig.getStateFile(); try { if (!historyTreeFile.delete()) { /* We didn't succeed in deleting the file */ Activator.getDefault().logError("Failed to delete" + historyTreeFile.getName()); //$NON-NLS-1$ } <START> } catch (SecurityException e) { <END> Activator.getDefault().logError(e.getMessage(), e); } }

sample: 1643
buggy_code: public void delete(UserEntityFile userEntityFile) { <START> getEntityManager().remove(userEntityFile); <END> }
code_review: Replace method content with... super.delete(userEntityFile); ...as the underlying code will not only delete the entity but also fire an event about it.
target code: public void delete ( UserEntityFile userEntityFile ) { super . delete ( userEntityFile ) ; }
response: public void delete(UserEntityFile userEntityFile) { <START> super.delete(userEntityFile); <END> }

sample: 1644
buggy_code: <START> public void init() { <END> if (dubboConfigBinder == null) { try { dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); } catch (BeansException ignored) { if (log.isDebugEnabled()) { log.debug("DubboConfigBinder Bean can't be found in ApplicationContext."); } // Use Default implementation dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); } } dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); }
code_review: If we allow to create sub class of this **DubboConfigBindingBeanPostProcessor ** and some **init method** get override then it might cause issue. So better to make init final or provide. What do you say?
target code: private void init ( ) { if ( dubboConfigBinder == null ) { try { dubboConfigBinder = applicationContext . getBean ( DubboConfigBinder . class ) ; } catch ( BeansException ignored ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DubboConfigBinder Bean can't be found in ApplicationContext . " ) ; } // Use Default implementation dubboConfigBinder = createDubboConfigBinder ( applicationContext . getEnvironment ( ) ) ; } } dubboConfigBinder . setIgnoreUnknownFields ( ignoreUnknownFields ) ; dubboConfigBinder . setIgnoreInvalidFields ( ignoreInvalidFields ) ; }
response: <START> public final void init() { <END> if (dubboConfigBinder == null) { try { dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); } catch (BeansException ignored) { if (log.isDebugEnabled()) { log.debug("DubboConfigBinder Bean can't be found in ApplicationContext."); } // Use Default implementation dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); } } dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); }

sample: 1645
buggy_code: public static void removeDuplicateImages(Feed feed) { Set<String> known = new HashSet<String>(); for (FeedItem item : feed.getItems()) { <START> String url = (item.hasItemImage()) ? item.getImage().getDownload_url() : null; <END> if (url != null) { if (known.contains(url)) { item.setImage(null); } else { known.add(url); } } } }
code_review: I find it even easier to read without the `(...)`
target code: public static void removeDuplicateImages ( Feed feed ) { Set < String > known = new HashSet < String > ( ) ; for ( FeedItem item : feed . getItems ( ) ) { String url = item . hasItemImage ( ) ? item . getImage ( ) . getDownload_url ( ) : null ; if ( url != null ) { if ( known . contains ( url ) ) { item . setImage ( null ) ; } else { known . add ( url ) ; } } } }
response: public static void removeDuplicateImages(Feed feed) { Set<String> known = new HashSet<String>(); for (FeedItem item : feed.getItems()) { <START> String url = item.hasItemImage() ? item.getImage().getDownload_url() : null; <END> if (url != null) { if (known.contains(url)) { item.setImage(null); } else { known.add(url); } } } }

sample: 1646
buggy_code: protected void selectedItemsChanged() { <START> super.onSelectedItemChanged(); <END> updateActionAvailability(); }
code_review: Shouldn't this also be changed to super.selectedItemsChanged()?
target code: protected void selectedItemsChanged ( ) { super . selectedItemsChanged ( ) ; updateActionAvailability ( ) ; }
response: protected void selectedItemsChanged() { <START> super.selectedItemsChanged(); <END> updateActionAvailability(); }

sample: 1647
buggy_code: public int[] borrowIntArray(int positionCount) { int[] array; <START> while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { <END> estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length); --intArraysTop; } if (intArraysTop < 0) { array = new int[positionCount]; estimatedSizeInBytes += sizeOfIntArray(positionCount); } else { array = intArrays[intArraysTop]; --intArraysTop; } ++borrowedIntArrays; return array; }
code_review: Shouldn't this loop release memory of "discarded" arrays? E.g. intArrays[intArraysTop] = null?
target code: public int [ ] borrowIntArray ( int positionCount ) { int [ ] array ; while ( intArraysTop >= 0 && intArrays [ intArraysTop ] . length < positionCount ) { estimatedSizeInBytes -= sizeOfIntArray ( intArrays [ intArraysTop ] . length ) ; intArrays [ intArraysTop ] = null ; -- intArraysTop ; } if ( intArraysTop < 0 ) { array = new int [ positionCount ] ; estimatedSizeInBytes += sizeOfIntArray ( positionCount ) ; } else { array = intArrays [ intArraysTop ] ; -- intArraysTop ; } ++ borrowedIntArrays ; return array ; }
response: public int[] borrowIntArray(int positionCount) { int[] array; <START> while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { <END> estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length); intArrays[intArraysTop] = null; --intArraysTop; } if (intArraysTop < 0) { array = new int[positionCount]; estimatedSizeInBytes += sizeOfIntArray(positionCount); } else { array = intArrays[intArraysTop]; --intArraysTop; } ++borrowedIntArrays; return array; }

sample: 1648
buggy_code: <START> public Collection<MergeStrategySection> getAllMergeStrategySections() { <END> List<MergeStrategySection> all = new ArrayList<MergeStrategySection>(); all.addAll(getLocalMergeStrategySections()); all.addAll(getInheritedMergeStrategySections()); return all; }
code_review: I suspect that you want to preserve order here and return a List?
target code: public List < MergeStrategySection > getAllMergeStrategySections ( ) { List < MergeStrategySection > all = new ArrayList < MergeStrategySection > ( ) ; all . addAll ( getLocalMergeStrategySections ( ) ) ; all . addAll ( getInheritedMergeStrategySections ( ) ) ; return all ; }
response: <START> public List<MergeStrategySection> getAllMergeStrategySections() { <END> List<MergeStrategySection> all = new ArrayList<MergeStrategySection>(); all.addAll(getLocalMergeStrategySections()); all.addAll(getInheritedMergeStrategySections()); return all; }

sample: 1649
buggy_code: public String getDeleteDescription() { <START> return getName() + (getAlias() == null ? "" : " (" + getAlias() + ")"); <END> }
code_review: Alias should never be null.
target code: public String getDeleteDescription ( ) { return getName ( ) + " ( " + getAlias ( ) + " ) " ; }
response: public String getDeleteDescription() { <START> return getName() + " (" + getAlias() + ")"; <END> }

sample: 1650
buggy_code: boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) <START> throws CouchbaseLiteException { <END> if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID())) return false; setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision return true; }
code_review: Is CouchbaseLiteException thrown from anything in this method? Or it should return void but throw CouchbaseLiteException instead?
target code: boolean selectCommonAncestor ( ReadOnlyDocument doc1 , ReadOnlyDocument doc2 ) { if ( ! c4doc . getRawDoc ( ) . selectCommonAncestorRevision ( doc1 . getRevID ( ) , doc2 . getRevID ( ) ) ) return false ; setC4Doc ( c4doc ) ; // self . c4Doc = _c4Doc ; // This will update to the selected revision return true ; }
response: boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) <START> throws CouchbaseLiteException { <END> if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID())) return false; setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision return true; }

sample: 1651
buggy_code: <START> public void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { <END> this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId; }
code_review: `protected`. It would be bad to allow end-user to mutate on this local property.
target code: protected void setHazelcastRegisteredEventListenerId ( String hazelcastRegisteredEventListenerId ) { this . hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId ; }
response: <START> protected void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { <END> this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId; }

sample: 1652
buggy_code: protected String getFileName(ITask task, Predicate<String> fileExists) { String encodedFileName = CoreUtil.asFileName(task.getTaskId()); // for backwards-compatibility with versions that always encoded file names, // we will use an encoded name if the file with an encoded name already exists <START> if (encodedFileName.length() <= FILENAME_MAX_LEN && fileExists.test(encodedFileName)) { <END> return encodedFileName; } // if file with encoded name does not exist, we will only encode file name if it is required String fileName; if (requiresEncoding(task.getTaskId())) { fileName = encodedFileName; } else { fileName = task.getTaskId(); } // trim the file name if it is too long return trimFilenameIfRequired(fileName); }
code_review: In what case can the file exist but be too long? If we are on a system with a longer filename limit, we should just use the existing file and not worry about the length, I think.
target code: protected String getFileName ( ITask task , Predicate < String > fileExists ) { String encodedFileName = CoreUtil . asFileName ( task . getTaskId ( ) ) ; // for backwards - compatibility with versions that always encoded file names , // we will use an encoded name if the file with an encoded name already exists if ( fileExists . test ( encodedFileName ) ) { return encodedFileName ; } // if file with encoded name does not exist , we will only encode file name if it is required String fileName ; if ( requiresEncoding ( task . getTaskId ( ) ) ) { fileName = encodedFileName ; } else { fileName = task . getTaskId ( ) ; } // trim the file name if it is too long return trimFilenameIfRequired ( fileName ) ; }
response: protected String getFileName(ITask task, Predicate<String> fileExists) { String encodedFileName = CoreUtil.asFileName(task.getTaskId()); // for backwards-compatibility with versions that always encoded file names, // we will use an encoded name if the file with an encoded name already exists <START> if (fileExists.test(encodedFileName)) { <END> return encodedFileName; } // if file with encoded name does not exist, we will only encode file name if it is required String fileName; if (requiresEncoding(task.getTaskId())) { fileName = encodedFileName; } else { fileName = task.getTaskId(); } // trim the file name if it is too long return trimFilenameIfRequired(fileName); }

sample: 1653
buggy_code: public boolean createIndex(String indexName) { Assert.notNull(indexName, "No index defined for Query"); try { CreateIndexRequest indexRequest = createIndexRequest(indexName); <START> return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); <END> } catch (Exception e) { throw new ElasticsearchException("Failed to create index " + indexName, e); } }
code_review: why the extraction to a variable? I would keep it inlined: ``` return client.indices().create(createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged(); ```
target code: public boolean createIndex ( String indexName ) { Assert . notNull ( indexName , "No index defined for Query" ) ; try { return client . indices ( ) . create ( createIndexRequest ( indexName ) , RequestOptions . DEFAULT ) . isAcknowledged ( ) ; } catch ( Exception e ) { throw new ElasticsearchException ( "Failed to create index " + indexName , e ) ; } }
response: public boolean createIndex(String indexName) { Assert.notNull(indexName, "No index defined for Query"); try { CreateIndexRequest indexRequest = createIndexRequest(indexName); return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); } catch (Exception e) { throw new ElasticsearchException("Failed to create index " + indexName, e); } }

sample: 1654
buggy_code: public static Properties defaultProperties() { Properties properties = BaseHttpApiMetadata.defaultProperties(); <START> properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, "<remote-service-key-given-by-shipyard-cli>"); <END> return properties; }
code_review: What is this property used for?
target code: public static Properties defaultProperties ( ) { return BaseHttpApiMetadata . defaultProperties ( ) ; }
response: public static Properties defaultProperties() { Properties properties = BaseHttpApiMetadata.defaultProperties(); <START> properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, "<remote-service-key-given-by-shipyard-cli>"); <END> return properties; }

sample: 1655
buggy_code: protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) { if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) { return false; } if (ctx.isOriginLocal()) { // The return value only matters on the originator. // Conditional commands also check the previous value only on the originator. if (!command.readsExistingValues()) { return false; } // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues(); <START> if (command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) { <END> return false; } } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well? if (!command.alwaysReadsExistingValues()) { return false; } } return true; }
code_review: It seems this could be changed to `return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP))`
target code: protected boolean writeNeedsRemoteValue ( InvocationContext ctx , WriteCommand command , Object key ) { if ( command . hasFlag ( Flag . CACHE_MODE_LOCAL ) ) { return false ; } if ( ctx . isOriginLocal ( ) ) { // The return value only matters on the originator . // Conditional commands also check the previous value only on the originator . if ( ! command . readsExistingValues ( ) ) { return false ; } // TODO Could make DELTA_WRITE / ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return ! command . hasFlag ( Flag . SKIP_REMOTE_LOOKUP ) || command . alwaysReadsExistingValues ( ) ; return ! command . hasFlag ( Flag . SKIP_REMOTE_LOOKUP ) ; } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well ? return command . alwaysReadsExistingValues ( ) ; } }
response: protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) { if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) { return false; } if (ctx.isOriginLocal()) { // The return value only matters on the originator. // Conditional commands also check the previous value only on the originator. if (!command.readsExistingValues()) { return false; } // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues(); <START> return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP); <END> } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well? if (!command.alwaysReadsExistingValues()) { return false; } } return true; }

sample: 1656
buggy_code: public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName, <START> LibraryTemplateService libraryTemplateService) throws IOException { <END> super("libraryReceipt", LibraryDto.class, "Libraries", dto, quantity); if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException("Aliquot class cannot be null"); this.project = project; this.aliquotClass = aliquotClass; this.defaultSciName = defaultSciName; this.libraryTemplateService = libraryTemplateService; newBox = dto.getBox(); }
code_review: ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the declaration of thrown exception 'java.io.IOException', as it cannot be thrown from constructor's body. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck)
target code: public BulkReceiveLibraryBackend ( LibraryDto dto , Integer quantity , Project project , SampleClass aliquotClass , String defaultSciName , LibraryTemplateService libraryTemplateService ) { super ( "libraryReceipt" , LibraryDto . class , "Libraries" , dto , quantity ) ; if ( isDetailedSampleEnabled ( ) && aliquotClass == null ) throw new InvalidParameterException ( "Aliquot class cannot be null" ) ; this . project = project ; this . aliquotClass = aliquotClass ; this . defaultSciName = defaultSciName ; this . libraryTemplateService = libraryTemplateService ; newBox = dto . getBox ( ) ; }
response: public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName, <START> LibraryTemplateService libraryTemplateService) { <END> super("libraryReceipt", LibraryDto.class, "Libraries", dto, quantity); if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException("Aliquot class cannot be null"); this.project = project; this.aliquotClass = aliquotClass; this.defaultSciName = defaultSciName; this.libraryTemplateService = libraryTemplateService; newBox = dto.getBox(); }

sample: 1657
buggy_code: public void evict(AccountExternalId id) { byKey.remove(id.getKey()); byAccountId.remove(id.getAccountId()); <START> byEmail.remove(new EmailWrapper(id.getEmailAddress())); <END> }
code_review: getEmailAddress can return null.
target code: public void evict ( AccountExternalId id ) { byKey . remove ( id . getKey ( ) ) ; byAccountId . remove ( id . getAccountId ( ) ) ; if ( id . getEmailAddress ( ) != null ) { byEmail . remove ( new EmailWrapper ( id . getEmailAddress ( ) ) ) ; } }
response: public void evict(AccountExternalId id) { byKey.remove(id.getKey()); byAccountId.remove(id.getAccountId()); <START> byEmail.remove(new EmailWrapper(id.getEmailAddress())); <END> }

sample: 1659
buggy_code: <START> public AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) { <END> }
code_review: seems like these constructors should set `protected` properties on the base class. They're called via `super` below.
target code: protected AbstractBlockFamily ( BlockFamilyDefinition definition , BlockShape shape , BlockBuilderHelper blockBuilder ) { }
response: <START> protected AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) { <END> }

sample: 1660
buggy_code: public void onStop() { super.onStop(); mGoogleApiClient.stopAutoManage(getActivity()); <START> if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) { <END> mGoogleApiClient.disconnect(); } }
code_review: Maybe we can move the null check on `mGoogleApiClient` a level above so to protect also the access to `stopAutoManage`. wdyt?
target code: public void onStop ( ) { super . onStop ( ) ; if ( mGoogleApiClient != null ) { mGoogleApiClient . stopAutoManage ( getActivity ( ) ) ; if ( mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } } }
response: public void onStop() { super.onStop(); <START> if (mGoogleApiClient != null) { <END> mGoogleApiClient.stopAutoManage(getActivity()); if (mGoogleApiClient.isConnected()) { mGoogleApiClient.disconnect(); } } }

sample: 1661
buggy_code: protected Guid getQuotaId() { <START> if (getNewDisk() != null && (isInternalManagedDisk())) { <END> return ((DiskImage) getNewDisk()).getQuotaId(); } return null; }
code_review: please remove redundant brackets (isInter...)
target code: protected Guid getQuotaId ( ) { if ( getNewDisk ( ) != null && isInternalManagedDisk ( ) ) { return ( ( DiskImage ) getNewDisk ( ) ) . getQuotaId ( ) ; } return null ; }
response: protected Guid getQuotaId() { <START> if (getNewDisk() != null && isInternalManagedDisk()) { <END> return ((DiskImage) getNewDisk()).getQuotaId(); } return null; }

sample: 1662
buggy_code: public JClogin() { <START> logger.trace("JClogin(constructor) called."); <END> logger.trace("JClogin(this={}) called.",this); }
code_review: One of these two trace lines should be removed.
target code: public JClogin ( ) { logger . trace ( "JClogin ( constructor ) called . " ) ; }
response: public JClogin() { <START> logger.trace("JClogin(this={}) called.",this); <END> logger.trace("JClogin(constructor) called."); }

sample: 1663
buggy_code: public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) { this.adaptor = adaptor; this.xenonEngine = xenonEngine; this.adaptorName = adaptor.getName(); this.connectionFactory = connectionFactory; <START> connections = Utils.emptyMap(1); <END> }
code_review: I think using this util obfuscates the code
target code: public ScriptingJobs ( ScriptingAdaptor adaptor , XenonEngine xenonEngine , SchedulerConnectionFactory connectionFactory ) { this . adaptor = adaptor ; this . xenonEngine = xenonEngine ; this . adaptorName = adaptor . getName ( ) ; this . connectionFactory = connectionFactory ; connections = new HashMap < > ( ) ; }
response: public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) { this.adaptor = adaptor; this.xenonEngine = xenonEngine; this.adaptorName = adaptor.getName(); this.connectionFactory = connectionFactory; <START> connections = new HashMap<>(); <END> }

sample: 1664
buggy_code: public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) { <START> this.prefix = Strings.isNullOrEmpty(prefix) ? "" : prefix + "/"; <END> this.layers = layers; }
code_review: I really dislike how this confuses things. Most of the `/`s are in the templates, but then this one special slash is being added here. This is a really good opportunity for future mistakes. Maybe this is a case for changing from using `String.format()` with templates that all do essentially the same thing for varying numbers of parameters to say just using `String.join()`.
target code: public TMSKeyBuilder ( final String prefix , TileLayerDispatcher layers ) { this . prefix = prefix ; this . layers = layers ; }
response: public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) { <START> this.prefix = Strings.isNullOrEmpty(prefix) ? "" : prefix; <END> this.layers = layers; }

sample: 1665
buggy_code: public void testLeftJoinMissingStats() { PlanNodeStatsEstimate leftStats = planNodeStats( 0, <START> new SymbolStatistics(LEFT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), <END> new SymbolStatistics(LEFT_OTHER_COLUMN, SymbolStatsEstimate.unknown())); PlanNodeStatsEstimate rightStats = planNodeStats( 0, new SymbolStatistics(RIGHT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), new SymbolStatistics(RIGHT_OTHER_COLUMN, SymbolStatsEstimate.unknown())); assertJoinStats(LEFT, leftStats, rightStats, leftStats); }
code_review: nit: I somehow liked the old, more concise `UNKNOWN_STATS`
target code: public void testLeftJoinMissingStats ( ) { PlanNodeStatsEstimate leftStats = planNodeStats ( 0 , new SymbolStatistics ( LEFT_JOIN_COLUMN , SymbolStatsEstimate . unknown ( ) ) , new SymbolStatistics ( LEFT_OTHER_COLUMN , SymbolStatsEstimate . unknown ( ) ) ) ; PlanNodeStatsEstimate rightStats = planNodeStats ( 0 , new SymbolStatistics ( RIGHT_JOIN_COLUMN , SymbolStatsEstimate . unknown ( ) ) , new SymbolStatistics ( RIGHT_OTHER_COLUMN , SymbolStatsEstimate . unknown ( ) ) ) ; assertJoinStats ( LEFT , leftStats , rightStats , PlanNodeStatsEstimate . unknown ( ) ) ; }
response: public void testLeftJoinMissingStats() { PlanNodeStatsEstimate leftStats = planNodeStats( 0, <START> new SymbolStatistics(LEFT_JOIN_COLUMN, UNKNOWN_STATS), <END> new SymbolStatistics(LEFT_OTHER_COLUMN, UNKNOWN_STATS)); PlanNodeStatsEstimate rightStats = planNodeStats( 0, new SymbolStatistics(RIGHT_JOIN_COLUMN, UNKNOWN_STATS), new SymbolStatistics(RIGHT_OTHER_COLUMN, UNKNOWN_STATS)); assertJoinStats(LEFT, leftStats, rightStats, leftStats); }

sample: 1666
buggy_code: public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException { PrintWriter printWriter = tryCreate(); if (printWriter != null) { mergeTemplate(printWriter); commit(printWriter); registerGinBinding(); } else { getLogger().debug("Jackson Mapper Provider already generated. Returning."); } <START> return Lists.newArrayList(getClassDefinition()); <END> }
code_review: Didn't you remove guava from GWTP?
target code: public Collection < ClassDefinition > generate ( ExtensionContext input ) throws UnableToCompleteException { PrintWriter printWriter = tryCreate ( ) ; if ( printWriter != null ) { mergeTemplate ( printWriter ) ; commit ( printWriter ) ; registerGinBinding ( ) ; } else { getLogger ( ) . debug ( "Jackson Mapper Provider already generated . Returning . " ) ; } return Arrays . asList ( getClassDefinition ( ) ) ; }
response: public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException { PrintWriter printWriter = tryCreate(); if (printWriter != null) { mergeTemplate(printWriter); commit(printWriter); registerGinBinding(); } else { getLogger().debug("Jackson Mapper Provider already generated. Returning."); } <START> return Collections.singletonList(getClassDefinition()); <END> }

sample: 1667
buggy_code: @Test public void shouldHandleSchemeInsensitiveCase() { String[] schemes = { "http", "https", "HTTP", "HTTPS", "HTtP", }; for (String scheme : schemes) { final Uri uri = URI_1.buildUpon().scheme(scheme).build(); final Boolean shouldHandle = networkHandler.canHandleRequest( <START> TestUtils.mockRequest(uri) <END> ); assertThat(shouldHandle).isTrue(); } }
code_review:  ah. a good reason to make `picasso3` the package name, so long as it has common names like `Request` in the API.
target code: @Test public void shouldHandleSchemeInsensitiveCase ( ) { String [ ] schemes = { "http" , "https" , "HTTP" , "HTTPS" , "HTtP" , } ; for ( String scheme : schemes ) { Uri uri = URI_1 . buildUpon ( ) . scheme ( scheme ) . build ( ) ; assertThat ( networkHandler . canHandleRequest ( TestUtils . mockRequest ( uri ) ) ) . isTrue ( ) ; } }
response: @Test public void shouldHandleSchemeInsensitiveCase() { String[] schemes = { "http", "https", "HTTP", "HTTPS", "HTtP", }; for (String scheme : schemes) { final Uri uri = URI_1.buildUpon().scheme(scheme).build(); final Boolean shouldHandle = networkHandler.canHandleRequest( <START> TestUtils.mockRequest(uri) <END> ); assertThat(shouldHandle).isTrue(); } }

sample: 1668
buggy_code: public void populate(CoreSession session) throws ClientException { UserManager um = Framework.getLocalService(UserManager.class); Framework.doPrivileged(() -> { // Create some users if (um != null) { createUsersAndGroups(um); } <START> }); <END> }
code_review: if (um != null) { Framework.doPrivileged(() -> createUsersAndGroups(um)); }
target code: public void populate ( CoreSession session ) throws ClientException { UserManager um = Framework . getLocalService ( UserManager . class ) ; // Create some users if ( um != null ) { Framework . doPrivileged ( ( ) - > createUsersAndGroups ( um ) ) ; } }
response: public void populate(CoreSession session) throws ClientException { UserManager um = Framework.getLocalService(UserManager.class); // Create some users if (um != null) { Framework.doPrivileged(() -> createUsersAndGroups(um)); } <START> } <END>

sample: 1669
buggy_code: public void stop(BundleContext context) throws Exception { try { Job.getJobManager().join(LUCENE_JOB_FAMILY, null); <START> plugin = null; <END> } finally { super.stop(context); } }
code_review: Might be also in finally?
target code: public void stop ( BundleContext context ) throws Exception { try { Job . getJobManager ( ) . join ( LUCENE_JOB_FAMILY , null ) ; } finally { plugin = null ; super . stop ( context ) ; } }
response: public void stop(BundleContext context) throws Exception { try { Job.getJobManager().join(LUCENE_JOB_FAMILY, null); <START> plugin = null; <END> } finally { super.stop(context); } }

sample: 1670
buggy_code: public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { ObjectUtil.checkNotNull(unit, "unit"); if (delay < 0) { delay = 0; } validateScheduled0(delay, unit); return schedule(new ScheduledFutureTask<Void>( this, <START> ObjectUtil.checkNotNull(command, "command"), <END> deadlineNanos(unit.toNanos(delay)))); }
code_review: move null check back as first action to not change behaviour.
target code: public ScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { ObjectUtil . checkNotNull ( command , "command" ) ; ObjectUtil . checkNotNull ( unit , "unit" ) ; if ( delay < 0 ) { delay = 0 ; } validateScheduled0 ( delay , unit ) ; return schedule ( new ScheduledFutureTask < Void > ( this , command , deadlineNanos ( unit . toNanos ( delay ) ) ) ) ; }
response: public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { ObjectUtil.checkNotNull(unit, "unit"); if (delay < 0) { delay = 0; } validateScheduled0(delay, unit); return schedule(new ScheduledFutureTask<Void>( this, <START> deadlineNanos(unit.toNanos(delay)), <END> ObjectUtil.checkNotNull(command, "command"))); }

sample: 1671
buggy_code: public Integer invoke() { Integer result = 0; try (InputStream in = cache.getViaStream(key)) { int read = 0; while ((read = in.read(buffer)) != -1) result = result + read; return value = result; } catch (IOException e) { throw new RuntimeException(e); <START> } catch (NullPointerException e) { <END> return null; } }
code_review: I think that `if (in == null) return null` is a slightly better way to deal with this...
target code: public Integer invoke ( ) { Integer result = 0 ; try ( InputStream in = cache . getViaStream ( key ) ) { if ( in == null ) return null ; int read = 0 ; while ( ( read = in . read ( buffer ) ) != - 1 ) result = result + read ; return value = result ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
response: public Integer invoke() { Integer result = 0; try (InputStream in = cache.getViaStream(key)) { if (in == null) return null; int read = 0; while ((read = in.read(buffer)) != -1) result = result + read; return value = result; } catch (IOException e) { throw new RuntimeException(e); <START> } catch (NullPointerException e) { <END> return null; } }

sample: 1672
buggy_code: public CoreEvent process(CoreEvent event) throws MuleException { try { return processToApply(event, this); } catch (Exception error) { Throwable cause = error.getCause(); <START> if (cause instanceof RetryContextInitializationException && <END> cause.getCause() instanceof ExpressionRuntimeException) { // Runtime exception caused by Retry Ctx initialization, propagating throw ((ExpressionRuntimeException) cause.getCause()); } else { // Not caused by context initialization. Throwing as raised. throw error; } } }
code_review: check for `cause != null`
target code: public CoreEvent process ( CoreEvent event ) throws MuleException { try { return processToApply ( event , this ) ; } catch ( Exception error ) { Throwable cause = error . getCause ( ) ; if ( cause != null && cause instanceof RetryContextInitializationException && cause . getCause ( ) instanceof ExpressionRuntimeException ) { // Runtime exception caused by Retry Ctx initialization , propagating throw ( ( ExpressionRuntimeException ) cause . getCause ( ) ) ; } else { // Not caused by context initialization . Throwing as raised . throw error ; } } }
response: public CoreEvent process(CoreEvent event) throws MuleException { try { return processToApply(event, this); } catch (Exception error) { Throwable cause = error.getCause(); <START> if (cause != null && <END> cause.getCause() instanceof ExpressionRuntimeException) { // Runtime exception caused by Retry Ctx initialization, propagating throw ((ExpressionRuntimeException) cause.getCause()); } else { // Not caused by context initialization. Throwing as raised. throw error; } } }

sample: 1673
buggy_code: private static void addChildren(Map<String, List<PatchLineComment>> parentMap, List<PatchLineComment> children, List<PatchLineComment> outResult) { if (children != null) { for (PatchLineComment c : children) { outResult.add(c); <START> addChildren(parentMap, parentMap.get(c.getKey()), outResult); <END> } } }
code_review: Missing a .get() here after .getKey() as the UUID is the key in the map, not the PatchLineComment.Key object instance.
target code: private static void addChildren ( Map < String , List < PatchLineComment > > parentMap , List < PatchLineComment > children , List < PatchLineComment > outResult ) { if ( children != null ) { for ( PatchLineComment c : children ) { outResult . add ( c ) ; addChildren ( parentMap , parentMap . get ( c . getKey ( ) . get ( ) ) , outResult ) ; } } }
response: private static void addChildren(Map<String, List<PatchLineComment>> parentMap, List<PatchLineComment> children, List<PatchLineComment> outResult) { if (children != null) { for (PatchLineComment c : children) { outResult.add(c); <START> addChildren(parentMap, parentMap.get(c.getKey().get()), outResult); <END> } } }

sample: 1674
buggy_code: public void dispose() { <START> LogManager.logInfo("Disposing", this); //$NON-NLS-1$ <END> fWindow= null; }
code_review: What is this logging buying us ? Do we really need so much of it?
target code: public void dispose ( ) { fWindow = null ; }
response: public void dispose() { <START> LogManager.logInfo("Disposing", this); //$NON-NLS-1$ <END> fWindow= null; }

sample: 1675
buggy_code: public boolean equals(byte[] obj, Object otherObj) { if (obj == otherObj) return true; <START> if (obj == null || byte[].class != obj.getClass()) return false; <END> if (otherObj == null || byte[].class != otherObj.getClass()) return false; byte[] byteArray = obj; byte[] otherByteArray = (byte[]) otherObj; return Arrays.equals(byteArray, otherByteArray); }
code_review: the second part of the OR is redundant: byte[].class != obj.getClass()
target code: public boolean equals ( byte [ ] obj , Object otherObj ) { if ( obj == otherObj ) return true ; if ( obj == null ) return false ; if ( otherObj == null || byte [ ] . class != otherObj . getClass ( ) ) return false ; byte [ ] otherByteArray = ( byte [ ] ) otherObj ; return Arrays . equals ( obj , otherByteArray ) ; }
response: public boolean equals(byte[] obj, Object otherObj) { if (obj == otherObj) return true; <START> if (obj == null || !(obj instanceof byte[])) return false; <END> if (otherObj == null || byte[].class != otherObj.getClass()) return false; byte[] byteArray = obj; byte[] otherByteArray = (byte[]) otherObj; return Arrays.equals(byteArray, otherByteArray); }

sample: 1676
buggy_code: <START> public EngineSearcherTotalHitsMatcher(Query query, int totalHits) { <END> this.query = query; this.totalHits = totalHits; }
code_review: can be private
target code: private EngineSearcherTotalHitsMatcher ( Query query , int totalHits ) { this . query = query ; this . totalHits = totalHits ; }
response: <START> private EngineSearcherTotalHitsMatcher(Query query, int totalHits) { <END> this.query = query; this.totalHits = totalHits; }

sample: 1677
buggy_code: protected boolean processEntryForContext(final ILogData data) { if (data != null) { try { <START> final Object payload = data.getPayload(runtime); <END> } catch (Throwable e) { log.error("Exception caught at address {}, {}, {}", data.getGlobalAddress(), data.getStreams(), data.getType()); throw e; } } return false; }
code_review: Why don't you push this down to `LogData::getPayload` ? (since that's when deserialize is actually invoked)
target code: protected boolean processEntryForContext ( final ILogData data ) { if ( data != null ) { final Object payload = data . getPayload ( runtime ) ; } return false ; }
response: protected boolean processEntryForContext(final ILogData data) { if (data != null) { try { <START> final Object payload = data.getPayload(runtime); <END> } catch (Throwable e) { log.error("Exception caught at address {}, {}, {}", data.getGlobalAddress(), data.getStreams(), data.getType()); throw e; } } return false; }

sample: 1678
buggy_code: public boolean isQueryCacheable(Query query) { // O(n) impl, but I don't think we'll ever have a million query types here <START> return !query.isDescending() && !unCacheable.contains(query.getType()); <END> }
code_review: any reason for disabling cache for descending order queries ?
target code: public boolean isQueryCacheable ( Query query ) { // O ( n ) impl , but I don't think we'll ever have a million query types here return ! unCacheable . contains ( query . getType ( ) ) ; }
response: public boolean isQueryCacheable(Query query) { // O(n) impl, but I don't think we'll ever have a million query types here <START> return !unCacheable.contains(query.getType()); <END> }

sample: 1679
buggy_code: public static boolean isMoeFile(IResource resource) { if(resource instanceof IFile ) { <START> String fileExtension = resource.getFileExtension(); return fileExtension != null && resource.getFileExtension().equals(MODEL_OBJECT_ELEMENTFILE_EXTENSION); <END> } return false; }
code_review: Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).
target code: public static boolean isMoeFile ( IResource resource ) { return resource instanceof IFile && MODEL_OBJECT_ELEMENTFILE_EXTENSION . equals ( resource . getFileExtension ( ) ) ; }
response: public static boolean isMoeFile(IResource resource) { if(resource instanceof IFile ) { <START> return MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()); <END> } return false; }

sample: 1680
buggy_code: <START> public Property[] getProperties() { <END> return m_properties.toArray(new Property[m_properties.size()]); }
code_review: could we change to List<Properties> or is this API fixed?
target code: public List < Property > getProperties ( ) { return m_properties ; }
response: <START> public List<Property> getProperties() { <END> return m_properties; }

sample: 1681
buggy_code: public void setup() throws NoSuchFieldException, IllegalAccessException { // Before "onCreate", we need to record the instance count for the test <START> instanceCountField = OpenHelperManager.class.getDeclaredField("instanceCount"); <END> instanceCountField.setAccessible(true); instanceCount = instanceCountField.getInt(null); activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get(); }
code_review: No need for this. The tests must be independent, hence the instance count here should be zero.
target code: public void setup ( ) { activity = Robolectric . buildActivity ( OrmLiteActivity_ . class ) . create ( ) . get ( ) ; }
response: public void setup() throws NoSuchFieldException, IllegalAccessException { // Before "onCreate", we need to record the instance count for the test <START> instanceCountField = OpenHelperManager.class.getDeclaredField("instanceCount"); <END> instanceCountField.setAccessible(true); instanceCount = instanceCountField.getInt(null); activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get(); }

sample: 1682
buggy_code: public static Injector getInjector() { if ( injector == null ) { <START> injector = Guice.createInjector( new GuiceModule( emf ) ); <END> } return injector; }
code_review: Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice.
target code: public static Injector getInjector ( ) { if ( injector == null ) { injector = Guice . createInjector ( new GuiceModule ( ) ) ; } return injector ; }
response: public static Injector getInjector() { if ( injector == null ) { <START> injector = Guice.createInjector( new GuiceModule( emf ) ); <END> } return injector; }

sample: 1683
buggy_code: public void serialize() throws Exception { String xml = serializer.serialize(header); <START> System.out.println(xml); <END> XMLAssert.assertXpathExists("/subscriptionHeader/contentUri", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader/name", xml); }
code_review: We don't like System.out :)
target code: public void serialize ( ) throws Exception { String xml = serializer . serialize ( header ) ; XMLAssert . assertXpathExists ( " / subscriptionHeader / contentUri" , xml ) ; XMLAssert . assertXpathExists ( " / subscriptionHeader / packageHeader" , xml ) ; XMLAssert . assertXpathExists ( " / subscriptionHeader / packageHeader / name" , xml ) ; }
response: public void serialize() throws Exception { String xml = serializer.serialize(header); <START> log.debug(xml); <END> XMLAssert.assertXpathExists("/subscriptionHeader/contentUri", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader/name", xml); }

sample: 1684
buggy_code: protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos) <START> { <END> TileEntity tile = world.getTileEntity(pos); return tile instanceof IMicroblockContainerTile ? (IMicroblockContainerTile) tile : null; }
code_review: Instanceof nightmare?
target code: protected IMicroblockContainerTile getMicroblockTile ( IBlockAccess world , BlockPos pos ) { TileEntity tile = world . getTileEntity ( pos ) ; if ( tile == null ) { return null ; } return getMicroblockTile ( tile ) ; }
response: protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos) <START> { <END> TileEntity tile = world.getTileEntity(pos); return tile instanceof IMicroblockContainerTile ? (IMicroblockContainerTile) tile : null;

sample: 1685
buggy_code: <START> public void setMethod(final ZonemasterRequest.Method method) { <END> this.method = method.getMethod(); this.id = method.getId(); }
code_review: should be a protected method
target code: protected void setMethod ( final ZonemasterRequest . Method method ) { this . method = method . getMethod ( ) ; this . id = method . getId ( ) ; }
response: <START> protected void setMethod(final ZonemasterRequest.Method method) { <END> this.method = method.getMethod(); this.id = method.getId(); }

sample: 1686
buggy_code: <START> public Dimension getFloatingItemOffset() { <END> if (editPart instanceof FloatingLabelEditPart) { return ((FloatingLabelEditPart) editPart).getFloatingItemOffset(); } return new Dimension(); }
code_review: Multi return is forbidden.
target code: public Dimension getFloatingItemOffset ( ) { Dimension offset = null ; if ( editPart instanceof FloatingLabelEditPart ) { offset = ( ( FloatingLabelEditPart ) editPart ) . getFloatingItemOffset ( ) ; } return offset != null ? offset : new Dimension ( ) ; }
response: <START> public Dimension getFloatingItemOffset() { <END> if (editPart instanceof FloatingLabelEditPart) { return ((FloatingLabelEditPart) editPart).getFloatingItemOffset(); } Dimension dimension = new Dimension(); return dimension; }

sample: 1687
buggy_code: private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException { ITerminalConnector con = cons.get(irc.getAddress()); if(con == null) { con = TerminalConnectorExtension.makeTerminalConnector( "org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector"); //$NON-NLS-1$ cons.put(irc.getAddress(),con); <START> } else if(irc.isOpen()) { <END> return null; } else { irc.open(new NullProgressMonitor()); return null; } return con; }
code_review: irc is not open if con is null initially. The logic here is a bit muddled.
target code: private static synchronized ITerminalConnector getConnector ( IRemoteConnection irc ) throws RemoteConnectionException { ITerminalConnector con = cons . get ( irc . getAddress ( ) ) ; if ( con == null ) { con = TerminalConnectorExtension . makeTerminalConnector ( "org . eclipse . ptp . remote . internal . terminal . RemoteToolsConnector" ) ; // $NON - NLS - 1$ cons . put ( irc . getAddress ( ) , con ) ; } return con ; }
response: private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException { ITerminalConnector con = cons.get(irc.getAddress()); if(con == null) { con = TerminalConnectorExtension.makeTerminalConnector( "org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector"); //$NON-NLS-1$ cons.put(irc.getAddress(),con); <START> } else if(irc.isOpen()) { <END> return null; } else { irc.open(new NullProgressMonitor()); return null; } return con; }

sample: 1688
buggy_code: public long getGlobalClassLoaderId() { <START> return (long) ClassLoaderIdentifier.GLOBAL_ID; <END> }
code_review: Why not declare GLOBAL_ID as a long?
target code: public long getGlobalClassLoaderId ( ) { return ClassLoaderIdentifier . GLOBAL_ID ; }
response: public long getGlobalClassLoaderId() { <START> return ClassLoaderIdentifier.GLOBAL_ID; <END> }

sample: 1689
buggy_code: private int getCmasSeverity() { switch (messageIdentifier) { case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME; case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED: <START> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY: <END> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE; default: return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN; } }
code_review: Even though these two are "CMAS Severe Alerts", shouldn't getCmasSeverity() still return CMAS_SEVERITY_EXTREME? Spec says "Severity of Extreme, Urgency of Expected..."
target code: private int getCmasSeverity ( ) { switch ( messageIdentifier ) { case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY : return SmsCbCmasInfo . CMAS_SEVERITY_EXTREME ; case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY : return SmsCbCmasInfo . CMAS_SEVERITY_SEVERE ; default : return SmsCbCmasInfo . CMAS_SEVERITY_UNKNOWN ; } }
response: private int getCmasSeverity() { switch (messageIdentifier) { case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME; case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY: <START> return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME; <END> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE; default: return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN; } }

sample: 1690
buggy_code: public Collection<String> getAliases(final KeyStore keyStore) throws ScriptSignatureException { try { if (keyStore != null) return Collections.list(keyStore.aliases()); } catch (KeyStoreException e) { throw new ScriptSignatureException("Keystore not initialized properly. Try again.", e); } <START> throw new ScriptSignatureException("Keystore not initialized properly. Try again.", null); <END> }
code_review: instead of thowing we could return an empty list
target code: public Collection < String > getAliases ( final KeyStore keyStore ) { try { if ( keyStore != null ) return Collections . list ( keyStore . aliases ( ) ) ; } catch ( KeyStoreException e ) { return null ; } return null ; }
response: public Collection<String> getAliases(final KeyStore keyStore) throws ScriptSignatureException { try { if (keyStore != null) return Collections.list(keyStore.aliases()); } catch (KeyStoreException e) { throw new ScriptSignatureException("Keystore not initialized properly. Try again.", e); } <START> return Collections.emptyList(); <END> }

sample: 1691
buggy_code: public List<Expression> getExpressions() { <START> List<Expression> result = new ArrayList<Expression>(groupByAttributes); <END> result.add(expression); return result; }
code_review: Type argument Expression is not need.
target code: public List < Expression > getExpressions ( ) { List < Expression > result = new ArrayList < > ( groupByAttributes ) ; result . add ( expression ) ; return result ; }
response: public List<Expression> getExpressions() { <START> List<Expression> result = new ArrayList<>(groupByAttributes); <END> result.add(expression); return result; }

sample: 1692
buggy_code: <START> public boolean isIdentityProvider() { <END> try { PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES); for (ActivityInfo activityInfo : packageInfo.activities) { if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) { return true; } } } catch (NameNotFoundException e) { SalesforceSDKLogger.e(TAG, "Exception occurred while examining application info", e); } return false; }
code_review: Could we keep this API private?
target code: private boolean isIdentityProvider ( ) { try { PackageInfo packageInfo = context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_ACTIVITIES ) ; for ( ActivityInfo activityInfo : packageInfo . activities ) { if ( activityInfo . name . equals ( IDPAccountPickerActivity . class . getName ( ) ) ) { return true ; } } } catch ( NameNotFoundException e ) { SalesforceSDKLogger . e ( TAG , "Exception occurred while examining application info" , e ) ; } return false ; }
response: <START> private boolean isIdentityProvider() { <END> try { PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES); for (ActivityInfo activityInfo : packageInfo.activities) { if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) { return true; } } } catch (NameNotFoundException e) { SalesforceSDKLogger.e(TAG, "Exception occurred while examining application info", e); } return false; }

sample: 1693
buggy_code: <START> public List<BlockedItem> getBlockedItems() { <END> return new ArrayList<BlockedItem>(snapshot.blockedProjects); }
code_review: @olivergondza noted in the commit that this should not be public as it is for testing only
target code: protected List < BlockedItem > getBlockedItems ( ) { return new ArrayList < BlockedItem > ( snapshot . blockedProjects ) ; }
response: <START> List<BlockedItem> getBlockedItems() { <END> return new ArrayList<BlockedItem>(snapshot.blockedProjects); }

sample: 1694
buggy_code: public IStatus validate(String path) { if (fTrace == null) { <START> return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TraceTypeHelper_ValidateNoTrace); <END> } return fTrace.validate(null, path); }
code_review: I don't think it makes sense for the trace to be null here. We shouldn't have to create a new Message file for this case...
target code: public IStatus validate ( String path ) { return fTrace . validate ( null , path ) ; }
response: public IStatus validate(String path) { if (fTrace == null) { <START> return new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Trace is null"); <END> } return fTrace.validate(null, path); }

sample: 1695
buggy_code: public static boolean isTCCPacket(ByteArrayBuffer baf) { int rc = RTCPHeaderUtils.getReportCount(baf); <START> return isRTPFBPacket(baf) && rc == FMT; <END> }
code_review: just wondering...is it worth putting the `rc == FMT` check first for a short-circuiting efficiency improvement?
target code: public static boolean isTCCPacket ( ByteArrayBuffer baf ) { int rc = RTCPHeaderUtils . getReportCount ( baf ) ; return rc == FMT && isRTPFBPacket ( baf ) ; }
response: public static boolean isTCCPacket(ByteArrayBuffer baf) { int rc = RTCPHeaderUtils.getReportCount(baf); <START> return rc == FMT && isRTPFBPacket(baf); <END> }

sample: 1696
buggy_code: private Result waitForCompletion() throws InterruptedException, IOException { // wait for the completion Result result; <START> while((result = checkForCompletion()) != null) { <END> Thread.sleep(1000); } return result; }
code_review: @bkmeneguello Are you sure that <code>!=</code> is correct?
target code: private Result waitForCompletion ( ) throws InterruptedException , IOException { // wait for the completion Result result ; while ( ( result = checkForCompletion ( ) ) == null ) { Thread . sleep ( 1000 ) ; } return result ; }
response: private Result waitForCompletion() throws InterruptedException, IOException { // wait for the completion Result result; <START> while((result = checkForCompletion()) == null) { <END> Thread.sleep(1000); } return result; }

sample: 1697
buggy_code: public void testUnderlyingReaders() throws IOException, FormatException { FakeReader reader = new FakeReader(); FileStitcher fs = new FileStitcher(reader); assertNotNull(fs.getUnderlyingReaders()); fs.setId("test_z<0-2>.fake"); assertNotNull(fs.getUnderlyingReaders()); <START> } <END>
code_review: Missing fs.close()
target code: public void testUnderlyingReaders ( ) throws IOException , FormatException { FakeReader reader = new FakeReader ( ) ; FileStitcher fs = new FileStitcher ( reader ) ; assertNotNull ( fs . getUnderlyingReaders ( ) ) ; fs . setId ( "test_z < 0 - 2 > . fake" ) ; assertNotNull ( fs . getUnderlyingReaders ( ) ) ; fs . close ( ) ; }
response: public void testUnderlyingReaders() throws IOException, FormatException { FakeReader reader = new FakeReader(); FileStitcher fs = new FileStitcher(reader); assertNotNull(fs.getUnderlyingReaders()); fs.setId("test_z<0-2>.fake"); assertNotNull(fs.getUnderlyingReaders()); fs.close(); <START> } <END>

sample: 1698
buggy_code: public void shouldGetDiagnosisByUuid() { <START> String uuid = "4e663d66-6b78-11e0-93c3-18a905e044dc"; <END> int diagnosisId = 1; Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(uuid); assertEquals(diagnosisId, (int) diagnosis.getId()); }
code_review: We can get rid of these variables if they are being used in one place.
target code: public void shouldGetDiagnosisByUuid ( ) { Diagnosis diagnosis = diagnosisDAO . getDiagnosisByUuid ( "4e663d66 - 6b78 - 11e0 - 93c3 - 18a905e044dc" ) ; assertEquals ( 1 , ( int ) diagnosis . getId ( ) ) ; }
response: public void shouldGetDiagnosisByUuid() { <START> String uuid = "4e663d66-6b78-11e0-93c3-18a905e044dc"; <END> int diagnosisId = 1; Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(uuid); assertEquals(1, (int) diagnosis.getId()); }

sample: 1699
buggy_code: public void setUpCallToAction(String callToActionText) { if (callToActionText == null) { callToActionContainer.setVisibility(GONE); } else { callToActionContainer.setVisibility(VISIBLE); <START> callToActionTextView.setText(callToActionText); <END> } }
code_review: I don't think the logic is necessary. We can have the default visibility as `GONE`.
target code: public void setUpCallToAction ( String callToActionText ) { if ( callToActionText != null ) { callToActionContainer . setVisibility ( VISIBLE ) ; callToActionTextView . setText ( callToActionText ) ; } else { callToActionContainer . setVisibility ( GONE ) ; } }
response: public void setUpCallToAction(String callToActionText) { if (callToActionText == null) { callToActionContainer.setVisibility(GONE); } else { callToActionContainer.setVisibility(VISIBLE); <START> callToActionTextView.setText(callToActionText); <END> } }

sample: 1700
buggy_code: <START> public AbstractTableViewer <END> getTableViewer() { return actionContext.getViewer(); }
code_review: Could this be protected as well?
target code: protected AbstractTableViewer getTableViewer ( ) { return actionContext . getViewer ( ) ; }
response: <START> protected AbstractTableViewer <END> getTableViewer() { return actionContext.getViewer(); }

sample: 1701
buggy_code: <START> void start() { <END> if (!started) { log.info("Starting prefetching thread."); executorService.execute(new DefaultGetRecordsCacheDaemon()); } started = true; }
code_review: This probably should be public, and in the interface.
target code: public void start ( ) { if ( ! started ) { log . info ( "Starting prefetching thread . " ) ; executorService . execute ( new DefaultGetRecordsCacheDaemon ( ) ) ; } started = true ; }
response: <START> public void start() { <END> if (!started) { log.info("Starting prefetching thread."); executorService.execute(new DefaultGetRecordsCacheDaemon()); } started = true; }

sample: 1702
buggy_code: public SymbolTableBuilder(String fullyQualifiedModuleName) { <START> this.fullyQualifiedModuleName = new ArrayList<>(Arrays.asList(fullyQualifiedModuleName.split("\\."))); <END> }
code_review: Why `new ArrayList<>(`?
target code: public SymbolTableBuilder ( String fullyQualifiedModuleName ) { this . fullyQualifiedModuleName = Arrays . asList ( fullyQualifiedModuleName . split ( "\\ . " ) ) ; }
response: public SymbolTableBuilder(String fullyQualifiedModuleName) { <START> this.fullyQualifiedModuleName = Arrays.asList(fullyQualifiedModuleName.split("\\.")); <END> }

sample: 1703
buggy_code: public long getNextTimestamp() throws TimestampIOException { long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT); <START> long maxTS = _maxReservedTimestamp; // avoid the double volatile read <END> if (nextTS > maxTS) { reserveNextBlock(nextTS); } _numTimestampsCreated.incrementAndGet(); // JMX metric return nextTS; }
code_review: Double volatile read is gone. Can get rid of maxTS.
target code: public long getNextTimestamp ( ) throws TimestampIOException { long nextTS = _timestampCounter . addAndGet ( TIMESTAMP_INCREMENT ) ; if ( nextTS > _maxReservedTimestamp ) { reserveNextBlock ( nextTS ) ; } _numTimestampsCreated . incrementAndGet ( ) ; // JMX metric return nextTS ; }
response: public long getNextTimestamp() throws TimestampIOException { long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT); <START> if (nextTS > _maxReservedTimestamp) { reserveNextBlock(nextTS); } <END> _numTimestampsCreated.incrementAndGet(); // JMX metric return nextTS; }

sample: 1704
buggy_code: public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) { <START> this.mTileCanvasViewGroup = new WeakReference<>( viewGroup ); <END> this.mTile = new WeakReference<>( tile ); }
code_review: please remove `this.` on this line and the next
target code: public TileRenderRunnable ( TileCanvasViewGroup viewGroup , Tile tile ) { mTileCanvasViewGroup = new WeakReference < > ( viewGroup ) ; mTile = new WeakReference < > ( tile ) ; }
response: public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) { <START> mTileCanvasViewGroup = new WeakReference<>( viewGroup ); <END> mTile = new WeakReference<>( tile ); }

sample: 1705
buggy_code: public Response viewDataverse(@PathParam("identifier") String idtf) { return allowCors(response(req -> ok( json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))), false, <START> settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false) <END> )))); }
code_review: @matthew-a-dunlap please update the docs on `:ExcludeEmailFromExport`. Thanks!
target code: public Response viewDataverse ( @PathParam ( "identifier" ) String idtf ) { return allowCors ( response ( req - > ok ( json ( execCommand ( new GetDataverseCommand ( req , findDataverseOrDie ( idtf ) ) ) , settingsService . isTrueForKey ( SettingsServiceBean . Key . ExcludeEmailFromExport , false ) ) ) ) ) ; }
response: public Response viewDataverse(@PathParam("identifier") String idtf) { return allowCors(response(req -> ok( json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))), false, <START> settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false) <END> )))); }

sample: 1706
buggy_code: public ResourceNotFoundException(IdString id) { <START> super(id.encoded()); <END> }
code_review: Should this better be: super(id.get()) ? At least in some other places [1] we provide the decoded id to ResourceNotFoundException(String). Shouldn't it be the same in all places, either always the decoded id or always the encoded id? [1] https://gerrit-review.googlesource.com/#/c/41733/1/gerrit-server/src/main/java/com/google/gerrit/server/group/GroupsCollection.java
target code: public ResourceNotFoundException ( IdString id ) { super ( id . get ( ) ) ; }
response: public ResourceNotFoundException(IdString id) { <START> super(id.get()); <END> }

sample: 1707
buggy_code: private AppiumDriver getDriverSafe() { WebDriver driver = getDriver(); if (driver instanceof EventFiringWebDriver) { driver = ((EventFiringWebDriver) driver).getWrappedDriver(); <START> if (driver instanceof AppiumDriver) { <END> return (AppiumDriver) driver; } } throw new ClassCastException("Appium Driver can not be casted from the actual driver."); }
code_review: if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe(); then there is no sense in if (driver instanceof AppiumDriver)
target code: private WebDriver getDriverSafe ( ) { WebDriver driver = getDriver ( ) ; if ( driver instanceof EventFiringWebDriver ) { driver = ( ( EventFiringWebDriver ) driver ) . getWrappedDriver ( ) ; } return driver ; }
response: private AppiumDriver getDriverSafe() { WebDriver driver = getDriver(); if (driver instanceof EventFiringWebDriver) { driver = ((EventFiringWebDriver) driver).getWrappedDriver(); <START> return (AppiumDriver) driver; <END> } throw new ClassCastException("Appium Driver can not be casted from the actual driver."); }

sample: 1708
buggy_code: public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException { BufferedImage tempImg = ImageIO.read(actualFile); File tempFile = File.createTempFile("print-test", ".png"); ImageIO.write(tempImg, "png", tempFile); <START> assertSimilarity(ImageIO.read(tempFile), maxDistance); <END> }
code_review: You forgot to revert that
target code: public void assertSimilarity ( final File actualFile , final double maxDistance ) throws IOException { assertSimilarity ( ImageIO . read ( actualFile ) , maxDistance ) ; }
response: public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException { BufferedImage tempImg = ImageIO.read(actualFile); File tempFile = File.createTempFile("print-test", ".png"); ImageIO.write(tempImg, "png", tempFile); <START> assertSimilarity(ImageIO.read(tempFile), maxDistance); <END> }

sample: 1709
buggy_code: public URI getLocationHeaderAsURI() { try { return locationHeader != null ? new URI(locationHeader) : null; } catch (URISyntaxException e) { if (LRALogger.logger.isInfoEnabled()) { <START> LRALogger.logger.infof("LRARecord.doEnd missing Location header on ACCEPTED response %s failed: %s", <END> getRequestURI(), e.getMessage()); } return null; } }
code_review: Good catch. I also just spotted that a few other log messages in tryDoEnd are attribued to this. It will be clearer to just remove the LRARecord.doEnd prefix I think.
target code: public URI getLocationHeaderAsURI ( ) throws URISyntaxException { return locationHeader != null ? new URI ( locationHeader ) : null ; }
response: public URI getLocationHeaderAsURI() { try { return locationHeader != null ? new URI(locationHeader) : null; } catch (URISyntaxException e) { if (LRALogger.logger.isInfoEnabled()) { <START> LRALogger.logger.infof("missing Location header on ACCEPTED response %s failed: %s", <END> getRequestURI(), e.getMessage()); } return null; } }

sample: 1710
buggy_code: public void setup(Method method) throws Exception { logger.info("test name: " + method.getName()); <START> KerberosHelper.loginFromKeytab(MerlinConstants.CURRENT_USER_NAME); <END> bundles[0] = Util.readELBundles()[0][0]; bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix()); bundles[0].generateUniqueBundle(); bundles[0].setProcessWorkflow(aggregateWorkflowDir); }
code_review: This seems redundant to me as we are logging in as the current user in the base class.
target code: public void setup ( Method method ) throws Exception { logger . info ( "test name : " + method . getName ( ) ) ; bundles [ 0 ] = Util . readELBundles ( ) [ 0 ] [ 0 ] ; bundles [ 0 ] = new Bundle ( bundles [ 0 ] , cluster . getEnvFileName ( ) , cluster . getPrefix ( ) ) ; bundles [ 0 ] . generateUniqueBundle ( ) ; bundles [ 0 ] . setProcessWorkflow ( aggregateWorkflowDir ) ; }
response: public void setup(Method method) throws Exception { logger.info("test name: " + method.getName()); <START> KerberosHelper.loginFromKeytab(MerlinConstants.CURRENT_USER_NAME); <END> bundles[0] = Util.readELBundles()[0][0]; bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix()); bundles[0].generateUniqueBundle(); bundles[0].setProcessWorkflow(aggregateWorkflowDir); }

sample: 1711
buggy_code: public View getOverflowMenuAnchor() { View view = getToolbar().findViewById(R.id.menu_overflow_button); <START> return getToolbar(); <END> }
code_review: Any reason not to check value of the view?
target code: public View getOverflowMenuAnchor ( ) { View view = getToolbar ( ) . findViewById ( R . id . menu_overflow_button ) ; return view == null ? getToolbar ( ) : view ; }
response: public View getOverflowMenuAnchor() { View view = getToolbar().findViewById(R.id.menu_overflow_button); <START> if (view != null) { return view; } return getToolbar(); <END> }

sample: 1712
buggy_code: public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos) throws IOException { if (closed) { throw new IllegalStateException("The NetworkClient is closed."); } List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>(); for (RequestInfo requestInfo : requestInfos) { pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo, null)); } List<NetworkSend> sends = prepareSends(responseInfoList); selector.poll(POLL_TIMEOUT_MS, sends); handleSelectorEvents(responseInfoList); <START> return responseInfoList; <END> }
code_review: I thought we will catch the exception and call close() here and then rethrow
target code: public List < ResponseInfo > sendAndPoll ( List < RequestInfo > requestInfos ) throws IOException { if ( closed ) { throw new IllegalStateException ( "The NetworkClient is closed . " ) ; } List < ResponseInfo > responseInfoList = new ArrayList < ResponseInfo > ( ) ; for ( RequestInfo requestInfo : requestInfos ) { pendingRequests . add ( new RequestMetadata ( time . milliseconds ( ) , requestInfo ) ) ; } List < NetworkSend > sends = prepareSends ( responseInfoList ) ; selector . poll ( POLL_TIMEOUT_MS , sends ) ; handleSelectorEvents ( responseInfoList ) ; return responseInfoList ; }
response: public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos) throws IOException { if (closed) { throw new IllegalStateException("The NetworkClient is closed."); } List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>(); for (RequestInfo requestInfo : requestInfos) { pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo, null)); } List<NetworkSend> sends = prepareSends(responseInfoList); selector.poll(POLL_TIMEOUT_MS, sends); handleSelectorEvents(responseInfoList); return responseInfoList; }

sample: 1713
buggy_code: public void handleQuotaColumnVisibility() { isQuotaVisible = false; SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem(); if (treeItem != null <START> && SystemTreeItemType.DataCenter.equals(treeItem.getType())) { <END> StoragePool storagePool = (StoragePool) treeItem.getEntity(); if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) { isQuotaVisible = true; } } onDiskViewTypeChanged(); }
code_review: As far as I know, enums can be used with the ==/!= operators. It's a matter of style, but I prefer them (since an instance of an enum is really the same referenced entity as the enum constant). However, you can do whatever you like, either is fine by me.
target code: public void handleQuotaColumnVisibility ( ) { isQuotaVisible = false ; SystemTreeItemModel treeItem = ( SystemTreeItemModel ) CommonModel . getInstance ( ) . getSystemTree ( ) . getSelectedItem ( ) ; if ( treeItem != null && SystemTreeItemType . DataCenter == treeItem . getType ( ) ) { StoragePool storagePool = ( StoragePool ) treeItem . getEntity ( ) ; if ( QuotaEnforcementTypeEnum . DISABLED != storagePool . getQuotaEnforcementType ( ) ) { isQuotaVisible = true ; } } onDiskViewTypeChanged ( ) ; }
response: public void handleQuotaColumnVisibility() { isQuotaVisible = false; SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem(); if (treeItem != null <START> && SystemTreeItemType.DataCenter == treeItem.getType()) { <END> StoragePool storagePool = (StoragePool) treeItem.getEntity(); if (QuotaEnforcementTypeEnum.DISABLED != storagePool.getQuotaEnforcementType()) { isQuotaVisible = true; } } onDiskViewTypeChanged(); }

sample: 1714
buggy_code: public CompletableFuture<StaticResource> getResource(String name) { StaticResource template = templates.get(name); if (template != null) { return CompletableFuture.completedFuture(template); } return delegate .getResource(name) .exceptionally((th) -> { templates.putIfAbsent(name, null); return null; } ) <START> .thenApply( (file) -> { templates.putIfAbsent(name, file); return file; }); <END> }
code_review: shouldn't you force the put? Otherwise, what is returned might be different than what's in the cache, it's also possible that doesn't matter.
target code: public CompletableFuture < Optional < StaticResource > > getResource ( String name ) { Optional < StaticResource > template = templates . get ( name ) ; if ( template != null ) { return CompletableFuture . completedFuture ( template ) ; } return delegate . getResource ( name ) . exceptionally ( ( th ) - > { return Optional . empty ( ) ; } ) . thenApply ( ( file ) - > { templates . put ( name , file ) ; return file ; } ) ; }
response: public CompletableFuture<StaticResource> getResource(String name) { StaticResource template = templates.get(name); if (template != null) { return CompletableFuture.completedFuture(template); } return delegate .getResource(name) .exceptionally((th) -> { templates.putIfAbsent(name, null); return null; } ) <START> .thenApply( (file) -> { templates.put(name, file); return file; }); <END> }

sample: 1715
buggy_code: public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable { assumeTrue(OpenSsl.isTlsv13Supported()); <START> assumeTrue(OpenSsl.isBoringSSL()); <END> testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false); }
code_review: OpenSSL also supports it in a similar way on the server-side. See SSL_OP_NO_TICKET on this page: https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_options.html.
target code: public void testSessionTicketsWithTLSv13AndNoKey ( ) throws Throwable { assumeTrue ( OpenSsl . isTlsv13Supported ( ) ) ; testSessionTickets ( SslUtils . PROTOCOL_TLS_V1_3 , false ) ; }
response: public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable { assumeTrue(OpenSsl.isTlsv13Supported()); testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false); }

sample: 1716
buggy_code: <START> public void setUp() { <END> TmfEventMatching.registerMatchObject(new TcpEventMatching()); TmfEventMatching.registerMatchObject(new TcpLttngEventMatching()); }
code_review: a BeforeClass has to be static (it doesn't tell you until you actually try to run it) I was wondering why this passed Hudson, but then remembered the perf tests don't run, yet...
target code: public static void setUp ( ) { TmfEventMatching . registerMatchObject ( new TcpEventMatching ( ) ) ; TmfEventMatching . registerMatchObject ( new TcpLttngEventMatching ( ) ) ; }
response: <START> public static void setUp() { <END> TmfEventMatching.registerMatchObject(new TcpEventMatching()); TmfEventMatching.registerMatchObject(new TcpLttngEventMatching()); }

sample: 1717
buggy_code: protected void updateTitle(String brand) { <START> if (brand != null) { <END> IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager(); setTitle(brandManager.getConnectorLabel(getConnector(), brand)); } }
code_review: Would it make more sense to mark the brand parameter of setBrand as @NonNull instead of checking it here?
target code: protected void updateTitle ( String brand ) { IBrandManager brandManager = TasksUiPlugin . getDefault ( ) . getBrandManager ( ) ; setTitle ( brandManager . getConnectorLabel ( getConnector ( ) , brand ) ) ; }
response: protected void updateTitle(String brand) { <START> IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager(); setTitle(brandManager.getConnectorLabel(getConnector(), brand)); <END> }

sample: 1718
buggy_code: public static int getSegmentForKey(Object key, Cache cache) { KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class); if (keyPartitioner != null) { return keyPartitioner.getSegment(key); } <START> return SegmentSpecificCommand.UNKNOWN_SEGMENT; <END> }
code_review: I'd rather throw an exception
target code: public static int getSegmentForKey ( Object key , Cache cache ) { KeyPartitioner keyPartitioner = extractComponent ( cache , KeyPartitioner . class ) ; return keyPartitioner . getSegment ( key ) ; }
response: public static int getSegmentForKey(Object key, Cache cache) { KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class); if (keyPartitioner != null) { return keyPartitioner.getSegment(key); } <START> throw new IllegalStateException("No key partitioner found for cache " + cache.getName()); <END> }


sample: 100
buggy_code: void remove(MessageGroup group) { Object correlationKey = group.getGroupId(); <START> if (this.groupIds.contains(correlationKey)) { <END> this.messageStore.removeMessageGroup(correlationKey); this.groupIds.remove(correlationKey); } }
code_review: That's not logic for this method. If we are here, we have to be already sure that it is our own group. The real problem is definitely in the `ForceReleaseMessageGroupProcessor` implementation. We have to check for its presence there. All other logic should not be affected. Please, make this `remove()` method `protected`.
target code: protected void remove ( MessageGroup group ) { Object correlationKey = group . getGroupId ( ) ; this . messageStore . removeMessageGroup ( correlationKey ) ; this . groupIds . remove ( group . getGroupId ( ) ) ; }
response: protected void remove ( MessageGroup group ) { Object correlationKey = group . getGroupId ( ) ; if ( ForceReleaseMessageGroupProcessor . class . isInstance ( group . getProcessor ( ) ) ) { this . messageStore . removeMessageGroup ( correlationKey ) ; this . groupIds . remove ( correlationKey ) ; } }

sample: 101
buggy_code: public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException { <START> if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) { <END> // Generally this logic should only be triggered once during first call. log.warn("Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API", cachedGroupMetadata.groupId(), consumerGroupId); cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId, JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty()); } sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false); }
code_review: Hmm, this feels like premature optimization. The offsets map is more likely to be a problem. Also, I'm not sure we should restrict the usage. It is possible today to send offsets for multiple groups. Is there a good reason to restrict this even if it doesn't make sense in streams?
target code: public void sendOffsetsToTransaction ( Map < TopicPartition , OffsetAndMetadata > offsets , String consumerGroupId ) throws ProducerFencedException { sendOffsetsToTransaction ( offsets , new ConsumerGroupMetadata ( consumerGroupId ) ) ; }
response: public void sendOffsetsToTransaction ( Map < TopicPartition , OffsetAndMetadata > offsets , String consumerGroupId ) throws ProducerFencedException { ConsumerGroupMetadata cachedGroupMetadata = new ConsumerGroupMetadata ( consumerGroupId , JoinGroupRequest . UNKNOWN_GENERATION_ID , JoinGroupRequest . UNKNOWN_MEMBER_ID , Optional . empty ( ) ) ; sendOffsetsToTransactionInternal ( offsets , cachedGroupMetadata , false ) ; }

sample: 102
buggy_code: public boolean cancel(final Exception rootReason) { if (transitionCancel(rootReason)) { final Exception reason = new CancellationException(rootReason); try { traceFailure(reason); } catch (Throwable ex) { <START> LOGGER.warn("Exception thrown in logging trace for failure!", ex); <END> } getSettableDelegate().fail(reason); return true; } return false; }
code_review: The issue we found was when the original `reason` could not be logged due to an error in its `toString`. Do we have any concern that logging the _new_ error might have the same issue? Would it be better to have two stages to this? 1. Catch the logging error, then try to log that error. 2. Catch _that_ error if it happens, and log a generic, static message.
target code: public boolean cancel ( final Exception rootReason ) { if ( transitionCancel ( rootReason ) ) { final Exception reason = new CancellationException ( rootReason ) ; try { traceFailure ( reason ) ; } catch ( Throwable ex ) { LOGGER . warn ( "Exception thrown in logging trace for failure ! " , ex ) ; } finally { // guard any exception that may throw from catch block getSettableDelegate ( ) . fail ( reason ) ; } return true ; } return false ; }
response: public boolean cancel ( final Exception rootReason ) { if ( transitionCancel ( rootReason ) ) { final Exception reason = new CancellationException ( rootReason ) ; try { traceFailure ( reason ) ; } catch ( Throwable ex ) { LOGGER . warn ( "Exception thrown in logging trace for failure ! " , ex ) ; try { LOGGER . error ( "Failed to log cancellation reason : " + ex . getMessage ( ) ) ; } catch ( Throwable t ) { // ignore } } getSettableDelegate ( ) . fail ( reason ) ; return true ; } return false ; }

sample: 103
buggy_code: <START> int allVersionsCombined() <END> { return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION; }
code_review: Can be private
target code: private int allVersionsCombined ( ) { return formatIdentifier > > > SHIFT_FORMAT_IDENTIFIER | formatVersion > > > SHIFT_FORMAT_VERSION ; }
response: private int allVersionsCombined ( ) { return formatIdentifier > > > SHIFT_FORMAT_IDENTIFIER | formatVersion > > > SHIFT_FORMAT_VERSION ; }

sample: 104
buggy_code: <START> protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException { <END> writer.writeStartElement(Element.SIMPLE_CONNECTION); writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl()); writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass()); writeOptional(writer, Attribute.USERNAME, configuration.username()); writeOptional(writer, Attribute.PASSWORD, configuration.password()); writer.writeEndElement(); }
code_review: the connection configuration is never serialized.
target code: private void writeJDBCStoreConnection ( XMLExtendedStreamWriter writer , SimpleConnectionFactoryConfiguration configuration ) throws XMLStreamException { writer . writeStartElement ( Element . SIMPLE_CONNECTION ) ; writeOptional ( writer , Attribute . CONNECTION_URL , configuration . connectionUrl ( ) ) ; writeOptional ( writer , Attribute . DRIVER_CLASS , configuration . driverClass ( ) ) ; writeOptional ( writer , Attribute . USERNAME , configuration . username ( ) ) ; writeOptional ( writer , Attribute . PASSWORD , configuration . password ( ) ) ; writer . writeEndElement ( ) ; }
response: < START > protected void writeJDBCStoreConnection ( XMLExtendedStreamWriter writer , SimpleConnectionFactoryConfiguration configuration ) throws XMLStreamException { writer . writeStartElement ( Element . SIMPLE_CONNECTION ) ; writeOptional ( writer , Attribute . CONNECTION_URL , configuration . getConnectionUrl ( ) ) ; writeOptional ( writer , Attribute . DRIVER_CLASS , configuration . getDriverClass ( ) ) ; writeOptional ( writer , Attribute . USERNAME , configuration . getUsername ( ) ) ; writeOptional ( writer , Attribute . PASSWORD , configuration . getPassword ( ) ) ; writer . writeEndElement ( ) ; } < END >

sample: 105
buggy_code: <START> static ByteBuf copyData(ByteBufList list) { <END> ByteBuf buf = Unpooled.buffer(list.readableBytes()); for (int i = 0; i < list.size(); i++) { buf.writeBytes(list.getBuffer(i).slice()); } return buf; }
code_review: "public" or "private" ?
target code: private static ByteBuf copyData ( ByteBufList list ) { ByteBuf buf = Unpooled . buffer ( list . readableBytes ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { buf . writeBytes ( list . getBuffer ( i ) . slice ( ) ) ; } return buf ; }
response: private static ByteBuf copyData ( ByteBufList list ) { ByteBuf buf = Unpooled . buffer ( list . readableBytes ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { buf . writeBytes ( list . getBuffer ( i ) . slice ( ) ) ; } return buf ; }

sample: 106
buggy_code: private String getXMI_ID(final EObject eobject) { if (eobject.eResource() instanceof XMIResource) { return ((XMIResource) eobject.eResource()).getID(eobject); } <START> ; <END> return null; }
code_review: Useless
target code: private String getXMI_ID ( final EObject eobject ) { if ( eobject . eResource ( ) instanceof XMIResource ) { return ( ( XMIResource ) eobject . eResource ( ) ) . getID ( eobject ) ; } return null ; }
response: private String getXMI_ID ( final EObject eobject ) { if ( eobject . eResource ( ) instanceof XMIResource ) { return ( ( XMIResource ) eobject . eResource ( ) ) . getID ( eobject ) ; } return null ; }

sample: 107
buggy_code: <START> @Override public float getPressure () { <END> return 0; }
code_review: Can you format these overrides?
target code: public float getPressure ( ) { return 0 ; }
response: @Override public float getPressure ( ) { return 0 ; }

sample: 108
buggy_code: private boolean checkForJournalFlush() { // System.err.printf("checkForJournalFlush: queue size=%d; journal size = %d\n", queue.size(), journal.size()) ; // System.err.printf("checkForJournalFlush: QueueBatchSize=%d; MaxQueueThreshold=%d; JournalThresholdSize=%d\n", // QueueBatchSize, MaxQueueThreshold, JournalThresholdSize) ; <START> if ( QueueBatchSize == 0 ) <END> return true ; if ( queue.size() >= QueueBatchSize ) // Based on number of queued commits // The MaxQueueThreshold is handled in processDelayedReplayQueue. return true ; boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ; if ( journalSizeFlush ) // JENA-1222 // Based on Journal file growing large in terms of bytes return true ; // No test for excessive queue length (MaxQueueThreshold). // That happens in notifyCommit (writer exit). return false ; }
code_review: I'm probably missing something, but it seems like this is part of the next case (isn't `queue.size() >= 0` an invariant?). Is this called out just to emphasize that setting `0` => "no queuing"?
target code: private boolean checkForJournalFlush ( ) { if ( queue . size ( ) >= QueueBatchSize ) return true ; boolean journalSizeFlush = ( JournalThresholdSize > 0 && journal . size ( ) > JournalThresholdSize ) ; if ( journalSizeFlush ) // JENA - 1222 // Based on Journal file growing large in terms of bytes return true ; // No test here for excessive queue length ( MaxQueueThreshold ) . return false ; }
response: private boolean checkForJournalFlush ( ) { if ( QueueBatchSize == 0 ) return true ; if ( queue . size ( ) >= QueueBatchSize ) return true ; boolean journalSizeFlush = ( JournalThresholdSize > 0 && journal . size ( ) > JournalThresholdSize ) ; if ( journalSizeFlush ) return true ; return false ; }

sample: 109
buggy_code: private ProjectState newProjectState(ProjectConfig local) { <START> PrologEnvironment.Factory envFactory = null; GitRepositoryManager gitMgr = null; ProjectControl.AssistedFactory projectControlFactory = null; RulesCache rulesCache = null; SitePaths sitePaths = null; List<CommentLinkInfo> commentLinks = null; all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local)); <END> return all.get(local.getProject().getNameKey()); }
code_review: Use add(ProjectConfig) method here instead of repeating the same code?
target code: private ProjectState newProjectState ( ProjectConfig local ) { add ( local ) ; return all . get ( local . getProject ( ) . getNameKey ( ) ) ; }
response: private ProjectState newProjectState ( ProjectConfig local ) { PrologEnvironment . Factory envFactory = null ; GitRepositoryManager gitMgr = null ; ProjectControl . AssistedFactory projectControlFactory = null ; RulesCache rulesCache = null ; SitePaths sitePaths = null ; List < CommentLinkInfo > commentLinks = null ; ProjectState projectState = new ProjectState ( sitePaths , projectCache , allProjectsName , projectControlFactory , envFactory , gitMgr , rulesCache , commentLinks , local ) ; all . add ( projectState ) ; return projectState ; }

sample: 110
buggy_code: public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId <START> + "AND p.status_id != " + Persona.PersonaStatus.DELETED.getStatusId(); <END> CentralRepository cr = CentralRepository.getInstance(); if (cr != null) { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId; PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback(); cr.executeSelectSQL(queryClause, queryCallback); return queryCallback.getPersonaAccountsList(); } return new ArrayList<>(); }
code_review: There's a re-declaration error here, that got fixed on the parent branch. That needs to get merged in here.
target code: public static Collection < PersonaAccount > getPersonaAccountsForAccount ( long accountId ) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts . account_id = " + accountId + "AND p . status_id != " + Persona . PersonaStatus . DELETED . getStatusId ( ) ; CentralRepository cr = CentralRepository . getInstance ( ) ; if ( cr != null ) { PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback ( ) ; cr . executeSelectSQL ( queryClause , queryCallback ) ; return queryCallback . getPersonaAccountsList ( ) ; } return new ArrayList < > ( ) ; }
response: public static Collection < PersonaAccount > getPersonaAccountsForAccount ( long accountId ) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts . account_id = " + accountId + " AND p . status_id != " + Persona . PersonaStatus . DELETED . getStatusId ( ) ; CentralRepository cr = CentralRepository . getInstance ( ) ; if ( cr != null ) { PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback ( ) ; cr . executeSelectSQL ( queryClause , queryCallback ) ; return queryCallback . getPersonaAccountsList ( ) ; } return new ArrayList < > ( ) ; }

sample: 111
buggy_code: public boolean hasMultipleValues(final String dimension) { if (isVirtualColumn(dimension)) { return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues(); } final Column column = index.getColumn(dimension); <START> if (column == null || !columnSupportsFiltering(column)) { <END> return false; } else { return column.getCapabilities().hasMultipleValues(); } }
code_review: The same question, how "column supports filtering" relates to "has multiple values"?
target code: public boolean hasMultipleValues ( final String dimension ) { if ( isVirtualColumn ( dimension ) ) { return virtualColumns . getVirtualColumn ( dimension ) . capabilities ( dimension ) . hasMultipleValues ( ) ; } final Column column = index . getColumn ( dimension ) ; return column != null && column . getCapabilities ( ) . hasMultipleValues ( ) ; }
response: public boolean hasMultipleValues ( final String dimension ) { if ( isVirtualColumn ( dimension ) ) { return virtualColumns . getVirtualColumn ( dimension ) . capabilities ( dimension ) . hasMultipleValues ( ) ; } else { final Column column = index . getColumn ( dimension ) ; if ( column != null && columnSupportsFiltering ( column ) ) { return column . getCapabilities ( ) . hasMultipleValues ( ) ; } else { return false ; } } }

sample: 112
buggy_code: public void resumeNode(String id) { <START> waitServerUntilAvailable.apply(getNode(id)); <END> api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE)); }
code_review: This won't work? You wait until the node is powered on when you want to resume it. This will take forever.
target code: public void resumeNode ( String id ) { api . serverApi ( ) . updateStatus ( id , Server . UpdateStatus . create ( Types . ServerAction . POWER_ON , Types . ServerActionMethod . HARDWARE ) ) ; }
response: public void resumeNode ( String id ) { api . serverApi ( ) . updateStatus ( id , Server . UpdateStatus . create ( Types . ServerAction . POWER_ON , Types . ServerActionMethod . HARDWARE ) ) ; }

sample: 113
buggy_code: public IStyledLabelProvider[] getLabelProviders() { <START> if (fLabelProviders == null) { <END> fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders(); } return fLabelProviders; }
code_review: either make this a get method that returns the result, or have it be a "load" method. Having it do both is unexpected (same for above method)
target code: public IStyledLabelProvider [ ] getLabelProviders ( ) { return fLabelProviders ; }
response: public IStyledLabelProvider [ ] loadLabelProviders ( ) { if ( fLabelProviders == null ) { fLabelProviders = CHEProviderSettings . getCCallHierarchyLabelProviders ( ) ; } return fLabelProviders ; }

sample: 114
buggy_code: public void registerOperations(ManagementResourceRegistration resourceRegistration) { if (showResources) { resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler()); } else { resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE); <START> resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE); <END> } }
code_review: Why are these registered at all? What invokes them?
target code: public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { super . registerOperations ( resourceRegistration ) ; resourceRegistration . registerOperationHandler ( ShowJaxrsResourcesHandler . DEFINITION , new ShowJaxrsResourcesHandler ( ) ) ; }
response: It is unclear why the operations are being registered and what invokes them . Therefore , the code has been refactored to remove the unnecessary registration of operations . public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { if ( showResources ) { resourceRegistration . registerOperationHandler ( ShowJaxrsResourcesHandler . DEFINITION , new ShowJaxrsResourcesHandler ( ) ) ; } }

sample: 115
buggy_code: public int hashCode() { <START> int result = processId.hashCode(); <END> result = 31 * result + taskId.hashCode(); result = 31 * result + taskName.hashCode(); result = 31 * result + formName.hashCode(); return result; }
code_review: And one for luck ;-)
target code: public int hashCode ( ) { int result = processId . hashCode ( ) ; result = ~~result ; result = 31 * result + taskId . hashCode ( ) ; result = ~~result ; result = 31 * result + taskName . hashCode ( ) ; result = ~~result ; result = 31 * result + formName . hashCode ( ) ; result = ~~result ; return result ; }
response: public int hashCode ( ) { int result = 17 ; result = 31 * result + processId . hashCode ( ) ; result = 31 * result + taskId . hashCode ( ) ; result = 31 * result + taskName . hashCode ( ) ; result = 31 * result + formName . hashCode ( ) ; return result ; }

sample: 116
buggy_code: <START> public synchronized void stop(final String reason) <END> { new Thread( "Shutdown Thread" ) { @Override public void run() { independentThreadStop( reason, true ); } }.start(); }
code_review: Can probably remove synchronized now?
target code: public void stop ( final String reason ) { new Thread ( "Shutdown Thread" ) { @Override public void run ( ) { independentThreadStop ( reason , true ) ; } } . start ( ) ; }
response: < START > public void stop ( final String reason ) < END > { new Thread ( "Shutdown Thread" ) { @Override public void run ( ) { independentThreadStop ( reason , true ) ; } } . start ( ) ; }

sample: 117
buggy_code: public boolean equals(Object o) { if (!(o instanceof Map.Entry)) <START> return <END> false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; return ((key == null ? e.getKey() == null : key.equals(e.getKey())) && (value == null ? e.getValue() == null : value.equals(e.getValue()))); }
code_review: braces
target code: public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return ( ( key == null ? e . getKey ( ) == null : key . equals ( e . getKey ( ) ) ) && ( value == null ? e . getValue ( ) == null : value . equals ( e . getValue ( ) ) ) ) ; }
response: public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return ( ( key == null ? e . getKey ( ) == null : key . equals ( e . getKey ( ) ) ) && ( value == null ? e . getValue ( ) == null : value . equals ( e . getValue ( ) ) ) ) ; }

sample: 118
buggy_code: <START> public PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException { <END> super(driver, properties, Dialect.POSTGRESQL); }
code_review: protected ?
target code: protected PostgreSqlEngine ( final PdbProperties properties , final String driver ) throws DatabaseEngineException { super ( driver , properties , Dialect . POSTGRESQL ) ; }
response: protected PostgreSqlEngine ( final PdbProperties properties , final String driver ) throws DatabaseEngineException { super ( driver , properties , Dialect . POSTGRESQL ) ; }

sample: 119
buggy_code: <START> public void dispose() { <END> clearCachedSwingEditor(); }
code_review: make dispose synchronized, then we could remove the volatile keyword in the class member.
target code: public synchronized void dispose ( ) { clearCachedSwingEditor ( ) ; }
response: public synchronized void dispose ( ) { clearCachedSwingEditor ( ) ; }

sample: 120
buggy_code: public void run() { if(thread == null || !Thread.currentThread().equals(thread)) { <START> thread = new Thread(this); <END> thread.start(); } else { try { if (logger.isInfoEnabled()) logger.info("Start reconnecting " + provider); provider.register( getUIService().getDefaultSecurityAuthority(provider)); } catch (OperationFailedException ex) { logger.error("cannot re-register provider will keep going", ex); } } }
code_review: I'm thinking that new thread is not needed for the reconnect task. This thread should be dead already by the time a new reconnect is needed and I see `Timer` instance serving the purpose of this thread. What do you think?
target code: public void run ( ) { try { if ( logger . isInfoEnabled ( ) ) logger . info ( "Start reconnecting " + provider ) ; provider . register ( getUIService ( ) . getDefaultSecurityAuthority ( provider ) ) ; } catch ( OperationFailedException ex ) { logger . error ( "cannot re - register provider will keep going" , ex ) ; } }
response: public void run ( ) { try { if ( logger . isInfoEnabled ( ) ) logger . info ( "Start reconnecting " + provider ) ; provider . register ( getUIService ( ) . getDefaultSecurityAuthority ( provider ) ) ; } catch ( OperationFailedException ex ) { logger . error ( "cannot re - register provider will keep going" , ex ) ; } }

sample: 121
buggy_code: public void checkProperties(Properties properties) { <START> properties.setProperty("log4j.shutdownCallbackRegistry", "io.druid.common.config.Log4jShutdown"); <END> properties.setProperty("log4j.shutdownHookEnabled", "true"); }
code_review: Couldn't this actually depend on the class and generate the name from that?
target code: public void checkProperties ( Properties properties ) { if ( ! properties . contains ( "log4j . shutdownCallbackRegistry" ) ) { properties . setProperty ( "log4j . shutdownCallbackRegistry" , "io . druid . common . config . Log4jShutdown" ) ; } if ( ! properties . contains ( "log4j . shutdownHookEnabled" ) ) { properties . setProperty ( "log4j . shutdownHookEnabled" , "true" ) ; } }
response: public void checkProperties ( Properties properties , Class < ? > clazz ) { properties . setProperty ( "log4j . shutdownCallbackRegistry" , clazz . getPackage ( ) . getName ( ) + " . Log4jShutdown" ) ; properties . setProperty ( "log4j . shutdownHookEnabled" , "true" ) ; }

sample: 122
buggy_code: public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class); assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, ""); <END> // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }
code_review: ```suggestion assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE); ```
target code: public void testUnmarshallTopLevelEmptyEventProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_START_EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartTimerEvent emptyTop = getStartNodeById ( diagram , EMPTY_TOP_LEVEL_EVENT_ID , StartTimerEvent . class ) ; assertGeneralSet ( emptyTop . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertTimerEventEmpty ( emptyTop . getExecutionSet ( ) , NON_INTERRUPTING , EMPTY_VALUE ) ; // Know issue . Should be uncommented after https :/ / issues . jboss . org / browse / JBPM - 7038 will be fixed // assertDataIOSet ( emptySubprocess . getDataIOSet ( ) , EMPTY_VALUE ) ; }
response: public void testUnmarshallTopLevelEmptyEventProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_START_EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartTimerEvent emptyTop = getStartNodeById ( diagram , EMPTY_TOP_LEVEL_EVENT_ID , StartTimerEvent . class ) ; assertGeneralSet ( emptyTop . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertTimerEventEmpty ( emptyTop . getExecutionSet ( ) , NON_INTERRUPTING , EMPTY_VALUE ) ; // Know issue . Should be uncommented after https :/ / issues . jboss . org / browse / JBPM - 7038 will be fixed // assertDataIOSet ( emptySubprocess . getDataIOSet ( ) , EMPTY_VALUE ) ; }

sample: 123
buggy_code: private EmbeddedExpirableMetadata( long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) { super(version); this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan); <START> this.maxIdle = maxIdleUnit.toMillis(maxIdle); <END> }
code_review: We should handle maxIdle as well
target code: private EmbeddedExpirableMetadata ( long lifespan , TimeUnit lifespanUnit , long maxIdle , TimeUnit maxIdleUnit , EntryVersion version ) { super ( version ) ; this . lifespan = lifespan < 0 ? - 1 : lifespanUnit . toMillis ( lifespan ) ; this . maxIdle = maxIdle < 0 ? - 1 : maxIdleUnit . toMillis ( maxIdle ) ; }
response: private EmbeddedExpirableMetadata ( long lifespan , TimeUnit lifespanUnit , long maxIdle , TimeUnit maxIdleUnit , EntryVersion version ) { super ( version ) ; this . lifespan = lifespan < 0 ? lifespan : lifespanUnit . toMillis ( lifespan ) ; this . maxIdle = maxIdle < 0 ? maxIdle : maxIdleUnit . toMillis ( maxIdle ) ; }

sample: 124
buggy_code: protected void setMatcherString(String pattern) { if (pattern.length() == 0) { searchPattern = null; } else { SearchPattern patternMatcher = new SearchPattern(); if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) { <START> pattern = "*" + pattern; //$NON-NLS-1$ <END> } patternMatcher.setPattern(pattern); searchPattern = patternMatcher; } }
code_review: @Lars Do you think that for consistency (and maybe another slight performance enhancement) this line should be changed as well?
target code: protected void setMatcherString ( String pattern ) { if ( pattern . length ( ) == 0 ) { searchPattern = null ; } else { SearchPattern patternMatcher = new SearchPattern ( ) ; if ( pattern . indexOf ( ' * ' ) != 0 && pattern . indexOf ( ' ? ' ) != 0 && pattern . indexOf ( ' . ' ) != 0 ) { pattern = ' * ' + pattern ; } patternMatcher . setPattern ( pattern ) ; searchPattern = patternMatcher ; } }
response: protected void setMatcherString ( String pattern ) { if ( pattern . isEmpty ( ) ) { searchPattern = null ; } else { SearchPattern patternMatcher = new SearchPattern ( ) ; if ( ! pattern . startsWith ( " * " ) && ! pattern . startsWith ( " ? " ) && ! pattern . startsWith ( " . " ) ) { pattern = " * " + pattern ; } patternMatcher . setPattern ( pattern ) ; searchPattern = patternMatcher ; } }

sample: 125
buggy_code: public DefaultEditorSession(final ManagedSession session, final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager, final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager, final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager, final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) { this.session = session; <START> this.commandRegistry = clientCommandRegistry.setSession(session); <END> this.sessionCommandManager = sessionCommandManager; this.requestCommandManager = requestCommandManager; this.canvasCommandManager = canvasCommandManager; }
code_review: yeah let's remove this :)
target code: public DefaultEditorSession ( final ManagedSession session , final CanvasCommandManager < AbstractCanvasHandler > canvasCommandManager , final @Session SessionCommandManager < AbstractCanvasHandler > sessionCommandManager , final @Request SessionCommandManager < AbstractCanvasHandler > requestCommandManager , final ClientCommandRegistry < org . kie . workbench . common . stunner . core . command . Command < AbstractCanvasHandler , CanvasViolation > > clientCommandRegistry ) { this . session = session ; this . commandRegistry = clientCommandRegistry ; this . sessionCommandManager = sessionCommandManager ; this . requestCommandManager = requestCommandManager ; this . canvasCommandManager = canvasCommandManager ; }
response: public DefaultEditorSession ( final ManagedSession session , final CanvasCommandManager < AbstractCanvasHandler > canvasCommandManager , final @Session SessionCommandManager < AbstractCanvasHandler > sessionCommandManager , final @Request SessionCommandManager < AbstractCanvasHandler > requestCommandManager , final ClientCommandRegistry < org . kie . workbench . common . stunner . core . command . Command < AbstractCanvasHandler , CanvasViolation > > clientCommandRegistry ) { this . session = session ; this . commandRegistry = clientCommandRegistry ; this . commandRegistry . setSession ( session ) ; this . sessionCommandManager = sessionCommandManager ; this . requestCommandManager = requestCommandManager ; this . canvasCommandManager = canvasCommandManager ; }

sample: 126
buggy_code: private String transformToHeaderValue(Directive... directives) { <START> final StringBuilder sb = new StringBuilder(); <END> for (int i = 0; i < directives.length - 1; i++) { sb.append(directives[i].headerValue).append(", "); } sb.append(directives[directives.length - 1].headerValue); return sb.toString(); }
code_review: For consistency across the project, please remove the `final` keyword here.
target code: private String transformToHeaderValue ( Directive . . . directives ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < directives . length - 1 ; i ++ ) { sb . append ( directives [ i ] . headerValue ) . append ( " , " ) ; } sb . append ( directives [ directives . length - 1 ] . headerValue ) ; return sb . toString ( ) ; }
response: private String transformToHeaderValue ( Directive . . . directives ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < directives . length - 1 ; i ++ ) { sb . append ( directives [ i ] . headerValue ) . append ( " , " ) ; } sb . append ( directives [ directives . length - 1 ] . headerValue ) ; return sb . toString ( ) ; }

sample: 127
buggy_code: private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) { for (CloudProvisioningListener cl : CloudProvisioningListener.all()) { try { cl.onFailure(plannedNode, cause); } catch (Throwable e) { LOGGER.log(Level.SEVERE, "Unexpected uncaught exception encountered while " + "processing onFailure() listener call in " + cl + " for agent " + plannedNode.displayName, e); <START> if (e instanceof Error) { <END> throw e; } } } }
code_review: üêú De-facto we process errors in the logging handler. E.g. logging constructs the string, and it may cause OutOfMemoryError, which suppresses the original one. I'd rather vote that Errors are being rethrown without any processing
target code: private static void fireOnFailure ( final NodeProvisioner . PlannedNode plannedNode , final Throwable cause ) { for ( CloudProvisioningListener cl : CloudProvisioningListener . all ( ) ) { try { cl . onFailure ( plannedNode , cause ) ; } catch ( Error e ) { throw e ; } catch ( Throwable e ) { LOGGER . log ( Level . SEVERE , "Unexpected uncaught exception encountered while " + "processing onFailure ( ) listener call in " + cl + " for agent " + plannedNode . displayName , e ) ; } } }
response: private static void fireOnFailure ( final NodeProvisioner . PlannedNode plannedNode , final Throwable cause ) { for ( CloudProvisioningListener cl : CloudProvisioningListener . all ( ) ) { try { cl . onFailure ( plannedNode , cause ) ; } catch ( Throwable e ) { LOGGER . log ( Level . SEVERE , "Unexpected uncaught exception encountered while " + "processing onFailure ( ) listener call in " + cl + " for agent " + plannedNode . displayName , e ) ; if ( e instanceof Error ) { throw e ; } } } }

sample: 128
buggy_code: public synchronized boolean isLastMQNotifLongAgo() { long delay = 18 * 3600; // 24h - 3h = 18h long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay; if (threshold < Calendar.getInstance().getTimeInMillis()) { Logger.d(TAG, "{} - Last MQ notif was yesterday", getCurrentModeName()); return true; } else { <START> Logger.d(TAG, "{} - Last MQ notif was recent, do not notify", getCurrentModeName()); <END> return false; } }
code_review: These two logs could be `Logger.v()`. That's all, good to go!
target code: public synchronized boolean isLastMQNotifLongAgo ( ) { long delay = 18 * 3600 ; // 24h - 3h = 18h long threshold = sharedPreferences . getLong ( getCurrentModeName ( ) + LAST_MORNING_Q_TIMESTAMP , - delay ) + delay ; if ( threshold < Calendar . getInstance ( ) . getTimeInMillis ( ) ) { Logger . v ( TAG , " { } - Last MQ notif was yesterday" , getCurrentModeName ( ) ) ; return true ; } else { Logger . v ( TAG , " { } - Last MQ notif was recent , do not notify" , getCurrentModeName ( ) ) ; return false ; } }
response: public synchronized boolean isLastMQNotifLongAgo ( ) { long delay = 18 * 3600 ; // 24h - 3h = 18h long threshold = sharedPreferences . getLong ( getCurrentModeName ( ) + LAST_MORNING_Q_TIMESTAMP , - delay ) + delay ; if ( threshold < Calendar . getInstance ( ) . getTimeInMillis ( ) ) { Logger . d ( TAG , " { } - Last MQ notif was yesterday" , getCurrentModeName ( ) ) ; return true ; } else { Logger . v ( TAG , " { } - Last MQ notif was recent , do not notify" , getCurrentModeName ( ) ) ; return false ; } }

sample: 129
buggy_code: public CrewMember apply(org.atlasapi.media.entity.CrewMember input) { if (input instanceof org.atlasapi.media.entity.Actor) { return translateLegacyActor((org.atlasapi.media.entity.Actor) input); <START> } else if(Objects.nonNull(input)) { <END> return translateLegacyCrewMember(input); } else { return null; } }
code_review: Ditto `input != null`
target code: public CrewMember apply ( org . atlasapi . media . entity . CrewMember input ) { // we carry IDs through from Owl to Deer , reject anything without one if ( null == input . getId ( ) ) { return null ; } if ( input instanceof org . atlasapi . media . entity . Actor ) { return translateLegacyActor ( ( org . atlasapi . media . entity . Actor ) input ) ; } else if ( null != input ) { return translateLegacyCrewMember ( input ) ; } else { return null ; } }
response: public CrewMember apply ( org . atlasapi . media . entity . CrewMember input ) { if ( input instanceof org . atlasapi . media . entity . Actor ) { return translateLegacyActor ( ( org . atlasapi . media . entity . Actor ) input ) ; } else if ( input != null ) { return translateLegacyCrewMember ( input ) ; } else { return null ; } }

sample: 130
buggy_code: public void testSocket() throws Exception { Socket s = new Socket(); s.connect(server.getLocalAddress()); s.close(); assertEquals(Collections.EMPTY_MAP, <START> tagger.getLiveDescriptors()); <END> }
code_review: Did you want to assert something before close in all these cases? i.e. it's not empty.
target code: public void testSocket ( ) throws Exception { Socket s = new Socket ( ) ; s . connect ( server . getLocalAddress ( ) ) ; assertEquals ( 1 , tagger . getLiveDescriptors ( ) . size ( ) ) ; s . close ( ) ; assertEquals ( Collections . EMPTY_MAP , tagger . getLiveDescriptors ( ) ) ; }
response: public void testSocket ( ) throws Exception { Socket s = new Socket ( ) ; s . connect ( server . getLocalAddress ( ) ) ; Map < String , Object > liveDescriptors = tagger . getLiveDescriptors ( ) ; s . close ( ) ; assertFalse ( liveDescriptors . isEmpty ( ) ) ; }

sample: 131
buggy_code: public ValuesMatcher( Map<String, Integer> outputSymbolAliases, Optional<Integer> expectedOutputSymbolCount, Optional<List<List<Expression>>> expectedRows) { <START> this.outputSymbolAliases = ImmutableMap.copyOf(requireNonNull(outputSymbolAliases, "outputSymbolAliases is null")); <END> this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, "expectedOutputSymbolCount is null"); this.expectedRows = requireNonNull(expectedRows, "expectedRows is null"); }
code_review: `requireNonNull` is not needed given `copyOf` checks for nullability.
target code: public ValuesMatcher ( Map < String , Integer > outputSymbolAliases , Optional < Integer > expectedOutputSymbolCount , Optional < List < List < Expression > > > expectedRows ) { this . outputSymbolAliases = ImmutableMap . copyOf ( outputSymbolAliases ) ; this . expectedOutputSymbolCount = requireNonNull ( expectedOutputSymbolCount , "expectedOutputSymbolCount is null" ) ; this . expectedRows = requireNonNull ( expectedRows , "expectedRows is null" ) ; }
response: public ValuesMatcher ( Map < String , Integer > outputSymbolAliases , Optional < Integer > expectedOutputSymbolCount , Optional < List < List < Expression > > > expectedRows ) { this . outputSymbolAliases = ImmutableMap . copyOf ( outputSymbolAliases ) ; this . expectedOutputSymbolCount = expectedOutputSymbolCount ; this . expectedRows = expectedRows ; }

sample: 132
buggy_code: protected Button getButton(int id) { <START> return buttons.get(new Integer(id)); <END> }
code_review: Can just pass id and let Java autoboxing take care of it.
target code: protected Button getButton ( int id ) { return buttons . get ( id ) ; }
response: protected Button getButton ( int id ) { return buttons . get ( id ) ; }

sample: 133
buggy_code: public void setInitializationData(IConfigurationElement config, String propertyName, Object data) { if (data instanceof <START> Hashtable) { <END> Hashtable<?, ?> table = (Hashtable<?, ?>) data; color = (String) table.get("color"); //$NON-NLS-1$ } }
code_review: Better: Map
target code: public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) { if ( data instanceof Hashtable < ? , ? > ) { Hashtable < ? , ? > map = ( Hashtable < ? , ? > ) data ; color = ( String ) map . get ( "color" ) ; // $NON - NLS - 1$ } }
response: public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) { if ( data instanceof Map ) { Map < ? , ? > map = ( Map < ? , ? > ) data ; color = ( String ) map . get ( "color" ) ; // $NON - NLS - 1$ } }

sample: 134
buggy_code: public void addRequestCleanupHandler(HttpServletRequest request) { RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() { @Override public void cleanup(HttpServletRequest req) { try { close(); } catch (OperationException cause) { <START> throw new NuxeoException(cause); <END> } } }); }
code_review: `cause` ‚Äî> `e` please
target code: public void addRequestCleanupHandler ( HttpServletRequest request ) { RequestContext . getActiveContext ( request ) . addRequestCleanupHandler ( new RequestCleanupHandler ( ) { @Override public void cleanup ( HttpServletRequest req ) { try { close ( ) ; } catch ( OperationException e ) { throw new NuxeoException ( e ) ; } } } ) ; }
response: public void addRequestCleanupHandler ( HttpServletRequest request ) { RequestContext . getActiveContext ( request ) . addRequestCleanupHandler ( new RequestCleanupHandler ( ) { @Override public void cleanup ( HttpServletRequest req ) { try { close ( ) ; } catch ( OperationException e ) { throw new NuxeoException ( e ) ; } } } ) ; }

sample: 135
buggy_code: public void visitStatementList(PyStatementListTree pyStatementListTree) { <START> if (isStmtListIncrementsNestingLevel(pyStatementListTree) && !pyStatementListTree.parent().is(Kind.FILE_INPUT)) { <END> nestingLevelStack.peek().increment(); super.visitStatementList(pyStatementListTree); nestingLevelStack.peek().decrement(); } else { super.visitStatementList(pyStatementListTree); } }
code_review: Why not move the logic about `Kind.FILE_INPUT` inside `isStmtListIncrementsNestingLevel`?
target code: public void visitStatementList ( PyStatementListTree pyStatementListTree ) { if ( isStmtListIncrementsNestingLevel ( pyStatementListTree ) ) { nestingLevelStack . peek ( ) . increment ( ) ; super . visitStatementList ( pyStatementListTree ) ; nestingLevelStack . peek ( ) . decrement ( ) ; } else { super . visitStatementList ( pyStatementListTree ) ; } }
response: public void visitStatementList ( PyStatementListTree pyStatementListTree ) { if ( isStmtListIncrementsNestingLevel ( pyStatementListTree . parent ( ) . isNot ( Kind . FILE_INPUT ) ) ) { nestingLevelStack . peek ( ) . increment ( ) ; super . visitStatementList ( pyStatementListTree ) ; nestingLevelStack . peek ( ) . decrement ( ) ; } else { super . visitStatementList ( pyStatementListTree ) ; } }  In the refactored code , the logic about `Kind . FILE_INPUT` has been moved inside the `isStmtListIncrementsNestingLevel` method . The `isNot` method is used to check if the parent node is not of type `Kind . FILE_INPUT` . This simplifies the code and makes it more readable .

sample: 136
buggy_code: private static void checkLxmlParseCall(SubscriptionContext ctx) { CallExpression callExpression = (CallExpression) ctx.syntaxNode(); if (checkCallExpressionFqn(callExpression, LXML_PARSE)) { CallExpression parserCall = getParserCall( getArgValueAsCallExpression( TreeUtils.nthArgumentOrKeyword(1, "parser", callExpression.arguments()))); if (parserCall != null && isUnsafeParserUsage(parserCall)) { <START> ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, MESSAGE); <END> } } }
code_review: no need to add the same message to the secondary location
target code: private static void checkLxmlParseCall ( SubscriptionContext ctx ) { CallExpression callExpression = ( CallExpression ) ctx . syntaxNode ( ) ; if ( checkCallExpressionFqn ( callExpression , LXML_PARSE ) ) { CallExpression parserCall = getParserCall ( getArgValueAsCallExpression ( TreeUtils . nthArgumentOrKeyword ( 1 , "parser" , callExpression . arguments ( ) ) ) ) ; if ( parserCall != null && isUnsafeParserUsage ( parserCall ) ) { ctx . addIssue ( parserCall , MESSAGE ) . secondary ( callExpression , null ) ; } } }
response: private static void checkLxmlParseCall ( SubscriptionContext ctx ) { CallExpression callExpression = ( CallExpression ) ctx . syntaxNode ( ) ; if ( checkCallExpressionFqn ( callExpression , LXML_PARSE ) ) { CallExpression parserCall = getParserCall ( getArgValueAsCallExpression ( TreeUtils . nthArgumentOrKeyword ( 1 , "parser" , callExpression . arguments ( ) ) ) ) ; if ( parserCall != null && isUnsafeParserUsage ( parserCall ) ) { ctx . addIssue ( parserCall , MESSAGE ) . secondary ( callExpression ) ; } } }

sample: 137
buggy_code: public int getVisibility(IBinding member) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST); return members.getAccessibility(member); } catch (CoreException e) { CCorePlugin.log(e); <START> throw new IllegalArgumentException(member.getName() + " is not a member of " + getName()); //$NON-NLS-1$ <END> } }
code_review: The same error is reported twice.
target code: public int getVisibility ( IBinding member ) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock ( getLinkage ( ) , record + MEMBERLIST ) ; return members . getVisibility ( member ) ; } catch ( CoreException e ) { CCorePlugin . log ( e ) ; throw new IllegalArgumentException ( member . getName ( ) + " is not a member of " + getName ( ) ) ; // $NON - NLS - 1$ } }
response: public int getVisibility ( IBinding member ) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock ( getLinkage ( ) , record + MEMBERLIST ) ; return members . getAccessibility ( member ) ; } catch ( CoreException e ) { CCorePlugin . log ( e ) ; throw new IllegalArgumentException ( member . getName ( ) + " is not a member of " + getName ( ) ) ; } }

sample: 138
buggy_code: public Map<String,Object> getDynamicTemplateData() { if(dynamicTemplateData == null) <START> return Collections.<String,Object>emptyMap(); <END> return dynamicTemplateData; }
code_review: Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement. Alternatively, a more succinct way of writing this method would be: ``` return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData; ```
target code: public Map < String , Object > getDynamicTemplateData ( ) { return dynamicTemplateData == null ? Collections . < String , Object > emptyMap ( ) : dynamicTemplateData ; }
response: public Map < String , Object > getDynamicTemplateData ( ) { return ( dynamicTemplateData == null ) ? Collections . < String , Object > emptyMap ( ) : dynamicTemplateData ; }

sample: 139
buggy_code: <START> public String getVersion() { <END> return version; }
code_review: I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
target code: String getVersion ( ) { return version ; }
response: private String version ; public String getVersion ( ) { return version ; }

sample: 140
buggy_code: public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException { Utils.checkPerunSession(sess); // Authorization if(!AuthzResolver.isAuthorized(sess, Role.PERUNADMIN) && <START> !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) { <END> throw new PrivilegeException(sess, "getUsers"); } return getUsersManagerBl().getUsers(sess); }
code_review: You can drop PERUNADMIN check here. And also in all other such methods in this file please.
target code: public List < User > getUsers ( PerunSession sess ) throws InternalErrorException , PrivilegeException { Utils . checkPerunSession ( sess ) ; // Authorization if ( ! AuthzResolver . isAuthorized ( sess , Role . PERUNOBSERVER ) ) { throw new PrivilegeException ( sess , "getUsers" ) ; } return getUsersManagerBl ( ) . getUsers ( sess ) ; }
response: public List < User > getUsers ( PerunSession sess ) throws InternalErrorException , PrivilegeException { Utils . checkPerunSession ( sess ) ; // Authorization if ( ! AuthzResolver . isAuthorized ( sess , Role . PERUNOBSERVER ) ) { throw new PrivilegeException ( sess , "getUsers" ) ; } return getUsersManagerBl ( ) . getUsers ( sess ) ; }

sample: 141
buggy_code: protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); <START> if (cluster.isSetRequiredSwitchType()) { <END> SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } }
code_review: Negation missing? if (!cluster.isSetRequiredSwitchType()) {
target code: protected void setDefaultSwitchTypeIfNeeded ( ) { Cluster cluster = getCluster ( ) ; if ( ! cluster . isSetRequiredSwitchType ( ) ) { SwitchType defaultSwitchType = DefaultSwitchType . getDefaultSwitchType ( cluster . getCompatibilityVersion ( ) ) ; cluster . setRequiredSwitchTypeForCluster ( defaultSwitchType ) ; } }
response: protected void setDefaultSwitchTypeIfNeeded ( ) { Cluster cluster = getCluster ( ) ; if ( ! cluster . isSetRequiredSwitchType ( ) ) { SwitchType defaultSwitchType = DefaultSwitchType . getDefaultSwitchType ( cluster . getCompatibilityVersion ( ) ) ; cluster . setRequiredSwitchTypeForCluster ( defaultSwitchType ) ; } }

sample: 142
buggy_code: public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI) <START> throws IOException <END> { throw new UnsupportedOperationException("GetBlockLocations is not supported."); }
code_review: Removed.
target code: public List < BlockLocationInfo > getBlockLocations ( AlluxioURI alluxioURI ) { throw new UnsupportedOperationException ( "GetBlockLocations is not supported . " ) ; }
response: public List < BlockLocationInfo > getBlockLocations ( AlluxioURI alluxioURI ) throws IOException { // implementation goes here }

sample: 143
buggy_code: public CustomTxtParserWizard() { super(); <START> setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle); <END> }
code_review: can this be in the second ctor and call this(null) here?
target code: public CustomTxtParserWizard ( ) { this ( null ) ; }
response: public CustomTxtParserWizard ( ) { this ( null ) ; } public CustomTxtParserWizard ( String title ) { super ( ) ; setWindowTitle ( title != null ? title : Messages . CustomTxtParserInputWizardPage_windowTitle ) ; }

sample: 144
buggy_code: <START> protected Provider<AdditionalProperties> createProvider(String name) { <END> Provider<AdditionalProperties> p = mock(Provider.class); when(p.getName()).thenReturn(name); return p; }
code_review: Don't see how this change is necessary
target code: private Provider < AdditionalProperties > createProvider ( String name ) { Provider < AdditionalProperties > p = mock ( Provider . class ) ; when ( p . getName ( ) ) . thenReturn ( name ) ; return p ; }
response: protected Provider < AdditionalProperties > createProvider ( String name ) { Provider < AdditionalProperties > provider = mock ( Provider . class ) ; when ( provider . getName ( ) ) . thenReturn ( name ) ; return provider ; }

sample: 145
buggy_code: public static int mapApiToArtVersion(int api) { if (api < 19) { return NO_VERSION; } switch (api) { case 19: case 20: return 7; case 21: return 39; case 22: return 45; case 23: return 64; case 24: case 25: return 79; case 26: return 124; case 27: return 131; case 28: // 144 is the current version in the master branch of AOSP as of 2018-05-22 return 144; } <START> return 143; <END> }
code_review: You can change the 28 case to a default case, and remove this.
target code: public static int mapApiToArtVersion ( int api ) { if ( api < 19 ) { return NO_VERSION ; } switch ( api ) { case 19 : case 20 : return 7 ; case 21 : return 39 ; case 22 : return 45 ; case 23 : return 64 ; case 24 : case 25 : return 79 ; case 26 : return 124 ; case 27 : return 131 ; default : // 144 is the current version in the master branch of AOSP as of 2018 - 05 - 22 return 144 ; } }
response: public static int mapApiToArtVersion ( int api ) { if ( api < 19 ) { return NO_VERSION ; } switch ( api ) { case 19 : case 20 : return 7 ; case 21 : return 39 ; case 22 : return 45 ; case 23 : return 64 ; case 24 : case 25 : return 79 ; case 26 : return 124 ; case 27 : return 131 ; default : return 143 ; } }

sample: 146
buggy_code: public void onAppendColumnEvent() { AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP); scenarioSimulationEventHandler.onEvent(event); verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class)); <START> verify(scenarioGridPanelMock).setFocus(true); <END> }
code_review: @jomarko If it is possible to move all those "context.getScenarioGridPanel().setFocus(true);" inside commonExecution, then move this "verify(scenarioGridPanelMock).setFocus(true);" inside "commonExecution" Test
target code: public void onAppendColumnEvent ( ) { AppendColumnEvent event = new AppendColumnEvent ( COLUMN_GROUP ) ; scenarioSimulationEventHandler . onEvent ( event ) ; verify ( scenarioSimulationEventHandler ) . commonExecution ( eq ( scenarioSimulationContextLocal ) , isA ( AppendColumnCommand . class ) , eq ( true ) ) ; }
response: public void onAppendColumnEvent ( ) { AppendColumnEvent event = new AppendColumnEvent ( COLUMN_GROUP ) ; scenarioSimulationEventHandler . onEvent ( event ) ; verify ( scenarioSimulationEventHandler , times ( 1 ) ) . commonExecution ( eq ( scenarioSimulationContextLocal ) , isA ( AppendColumnCommand . class ) ) ; } @Test public void onAppendColumnEvent_shouldSetFocusOnScenarioGridPanel ( ) { // given doNothing ( ) . when ( scenarioGridPanelMock ) . setFocus ( true ) ; AppendColumnCommand command = new AppendColumnCommand ( ) ; // when scenarioSimulationEventHandler . commonExecution ( scenarioSimulationContextLocal , command ) ; // then verify ( scenarioGridPanelMock ) . setFocus ( true ) ; }

sample: 147
buggy_code: public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception { byte[] bytes = serialize( instance ); T result = ( T )deserialize( bytes ); <START> Object adapter = result.getDisplay().getAdapter( IDisplayAdapter.class ); <END> IDisplayAdapter displayAdapter = ( IDisplayAdapter )adapter; displayAdapter.attachThread(); return result; }
code_review: Since getAdapter() has a generic interface, there is no need to type cast anymore.
target code: public static < T > T serializeAndDeserialize ( T instance ) throws Exception { byte [ ] bytes = serialize ( instance ) ; return ( T ) deserialize ( bytes ) ; }
response: public static < T extends Widget > T serializeAndDeserialize ( T instance ) throws Exception { byte [ ] bytes = serialize ( instance ) ; T result = deserialize ( bytes ) ; IDisplayAdapter displayAdapter = result . getDisplay ( ) . getAdapter ( IDisplayAdapter . class ) ; displayAdapter . attachThread ( ) ; return result ; }

sample: 148
buggy_code: <START> public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) { <END> for (PreReceiveHook hook : hooks) { hook.onPreReceive(rp, commands); } }
code_review: maybe line wrap?
target code: public void onPreReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( int i = 0 ; i < count ; i ++ ) hooks [ i ] . onPreReceive ( rp , commands ) ; }
response: < START > public void onPreReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( PreReceiveHook hook : hooks ) { hook . onPreReceive ( rp , commands ) ; } } < END >

sample: 149
buggy_code: public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) { if (annotation == null) { throw new NullPointerException("Cannot add a null annotation"); } annotations.add(annotation); <START> annotations.addAll(Arrays.asList(additionalAnnotations)); <END> return this; }
code_review: This only checks the first parameter for `null`. Could you update the version that takes in a `List` to check the entries for `null`s and update this line to call that version?
target code: public DescriptionBuilder withAdditionalAnnotations ( Annotation annotation , Annotation . . . additionalAnnotations ) { List < Annotation > annotations = new ArrayList < Annotation > ( ) ; annotations . add ( annotation ) ; annotations . addAll ( Arrays . asList ( additionalAnnotations ) ) ; return withAdditionalAnnotations ( annotations ) ; }
response: public DescriptionBuilder withAdditionalAnnotations ( Annotation annotation , Annotation . . . additionalAnnotations ) { if ( annotation == null ) { throw new NullPointerException ( "Cannot add a null annotation" ) ; } List < Annotation > allAnnotations = new ArrayList < > ( ) ; allAnnotations . add ( annotation ) ; if ( additionalAnnotations != null ) { for ( Annotation a : additionalAnnotations ) { if ( a == null ) { throw new NullPointerException ( "Cannot add a null annotation" ) ; } allAnnotations . add ( a ) ; } } annotations . addAll ( allAnnotations ) ; return this ; }

sample: 150
buggy_code: public void onAttach(final Activity activity) { super.onAttach(activity); try { mListener = (Listener) activity; <START> } catch (final ClassCastException e) { <END> Lg.e(activity.getClass().getName(), " should implement ", Listener.class.getName()); } }
code_review: instanceof?
target code: public void onAttach ( final Activity activity ) { super . onAttach ( activity ) ; if ( activity instanceof Listener ) { mListener = ( Listener ) activity ; } else { Lg . e ( activity . getClass ( ) . getName ( ) , " should implement " , Listener . class . getName ( ) ) ; } }
response: public void onAttach ( final Activity activity ) { super . onAttach ( activity ) ; if ( activity instanceof Listener ) { mListener = ( Listener ) activity ; } else { Lg . e ( activity . getClass ( ) . getName ( ) , " should implement " , Listener . class . getName ( ) ) ; } }

sample: 151
buggy_code: private void preloadDataSet(){ preloadedDataSet = load(iter.next()); totalOutcomes = preloadedDataSet.getLabels().size(1); inputColumns = preloadedDataSet.getFeatureMatrix().size(1); <START> batch = preloadedDataSet.numExamples(); <END> }
code_review: Need to be careful here. We can't always assume classification problems. Maybe use -1 (last dimension) instead?
target code: private void preloadDataSet ( ) { preloadedDataSet = load ( iter . next ( ) ) ; totalOutcomes = preloadedDataSet . getLabels ( ) . size ( 1 ) ; inputColumns = preloadedDataSet . getFeatureMatrix ( ) . size ( 1 ) ; }
response: private void preloadDataSet ( ) { preloadedDataSet = load ( iter . next ( ) ) ; totalOutcomes = preloadedDataSet . getLabels ( ) . size ( - 1 ) ; inputColumns = preloadedDataSet . getFeatureMatrix ( ) . size ( - 1 ) ; batch = preloadedDataSet . numExamples ( ) ; }

sample: 152
buggy_code: public void startup(Application application, ComponentStartupStatus ss) { FileOps.ensureDir(deltaClientZone); FileOps.clearAll(deltaClientZone); zone = Zone.connect(deltaClientZone); deltaLink = DeltaLinkHTTP.connect(deltaServerURL); deltaClient = DeltaClient.create(zone, deltaLink); jmsMessagingClient = application.getJMSMessagingClient(); <START> log.info(String.format("DeltaClient connected to DeltaServer at %s with zone %s", deltaServerURL, deltaClientZone)); <END> }
code_review: `log.info()` to `ss.info()`.
target code: public void startup ( Application application , ComponentStartupStatus ss ) { FileOps . ensureDir ( deltaClientZone ) ; FileOps . clearAll ( deltaClientZone ) ; Zone zone = Zone . connect ( deltaClientZone ) ; deltaLink = DeltaLinkHTTP . connect ( deltaServerURL ) ; deltaClient = DeltaClient . create ( zone , deltaLink ) ; jmsMessagingClient = application . getJMSMessagingClient ( ) ; ss . info ( String . format ( "DeltaClient connected to DeltaServer at % s with zone % s" , deltaServerURL , deltaClientZone ) ) ; }
response: public void startup ( Application application , ComponentStartupStatus ss ) { FileOps . ensureDir ( deltaClientZone ) ; FileOps . clearAll ( deltaClientZone ) ; zone = Zone . connect ( deltaClientZone ) ; deltaLink = DeltaLinkHTTP . connect ( deltaServerURL ) ; deltaClient = DeltaClient . create ( zone , deltaLink ) ; jmsMessagingClient = application . getJMSMessagingClient ( ) ; ss . info ( String . format ( "DeltaClient connected to DeltaServer at % s with zone % s" , deltaServerURL , deltaClientZone ) ) ; }

sample: 153
buggy_code: protected void onInit() { super.onInit(); if (this.connectionFactory == null) { <START> this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort()); <END> this.connectionFactory.setDeserializer(new ByteArrayLfSerializer()); this.connectionFactory.setBeanFactory(getBeanFactory()); if (this.applicationEventPublisher != null) { this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher); } this.connectionFactory.afterPropertiesSet(); } this.connectionFactory.registerListener(this); }
code_review: I think we don't need this change. We have similar structure in the `UdpSyslogReceivingChannelAdapter` below but you don't override the `onInit()` logic there.
target code: protected void onInit ( ) { super . onInit ( ) ; if ( this . connectionFactory == null ) { this . connectionFactory = new TcpNioServerConnectionFactory ( getPort ( ) ) ; this . connectionFactory . setDeserializer ( new ByteArrayLfSerializer ( ) ) ; this . connectionFactory . setBeanFactory ( getBeanFactory ( ) ) ; if ( this . applicationEventPublisher != null ) { this . connectionFactory . setApplicationEventPublisher ( this . applicationEventPublisher ) ; } this . connectionFactory . afterPropertiesSet ( ) ; } this . connectionFactory . registerListener ( this ) ; }
response: protected void onInit ( ) { super . onInit ( ) ; if ( this . connectionFactory == null ) { this . connectionFactory = new TcpNioServerConnectionFactory ( super . getPort ( ) ) ; this . connectionFactory . setDeserializer ( new ByteArrayLfSerializer ( ) ) ; this . connectionFactory . setBeanFactory ( getBeanFactory ( ) ) ; if ( this . applicationEventPublisher != null ) { this . connectionFactory . setApplicationEventPublisher ( this . applicationEventPublisher ) ; } this . connectionFactory . afterPropertiesSet ( ) ; this . connectionFactory . registerListener ( this ) ; } }

sample: 154
buggy_code: <START> public static Pair<Integer, Integer> getPrecisionAndScale(String type) { <END> String param = type.substring(8, type.length() - 1); String[] params = param.split(","); return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim())); }
code_review: are there some unit tests for this? Will this handle extraneous whitespaces well?
target code: public static Pair < Integer , Integer > getPrecisionAndScale ( String type ) { type = type . trim ( ) ; String param = type . substring ( 8 , type . length ( ) - 1 ) ; String [ ] params = param . split ( " , " ) ; return new Pair < > ( Integer . parseInt ( params [ 0 ] . trim ( ) ) , Integer . parseInt ( params [ 1 ] . trim ( ) ) ) ; }
response: public static Pair < Integer , Integer > getPrecisionAndScale ( String type ) { String param = type . substring ( 8 , type . length ( ) - 1 ) . trim ( ) ; String [ ] params = param . split ( "\\s * , \\s * " ) ; return new Pair < > ( Integer . parseInt ( params [ 0 ] ) , Integer . parseInt ( params [ 1 ] ) ) ; }  Explanation : - Added ` . trim ( ) ` to remove any extraneous whitespaces before and after the parameter string . - Used `\\s * , \\s * ` as the delimiter for `split ( ) ` to handle any whitespaces before or after the comma . - Removed ` . trim ( ) ` from `Integer . parseInt ( ) ` as it is not necessary .

sample: 155
buggy_code: <START> static String constructSegmentPath(String baseKey, String storageDir) <END> { return JOINER.join( baseKey.isEmpty() ? null : baseKey, storageDir ) + "/index.zip"; }
code_review: we don't know if these were used in extensions, can the things that were public remain so?
target code: public static String constructSegmentPath ( String baseKey , String storageDir ) { return JOINER . join ( baseKey . isEmpty ( ) ? null : baseKey , storageDir ) + " / index . zip" ; }
response: < START > private static String constructSegmentPath ( String baseKey , String storageDir ) { if ( baseKey . isEmpty ( ) ) { return storageDir + " / index . zip" ; } else { return baseKey + " / " + storageDir + " / index . zip" ; } } < END >

sample: 156
buggy_code: public MappingIterator(Collection<S> source, Function<S, D> transformation) { this.sourceIt = source.iterator(); this.transformation = transformation; <START> readNext(); <END> }
code_review: I find it strange that the constructor already does some work. Might catch someone by surprise, especially if he wants to concatenate several iterators. I'd like this better if only hasNext() or next() actually advanced. It's more predictable. Maybe similar to the logic in CachingKeyPairProvider$CancellingKeyPairIterator . That one is similar to MappingIterator<Path, KeyPair>.
target code: public MappingIterator ( Collection < S > source , Function < S , D > transformation ) { this . sourceIt = source . iterator ( ) ; this . transformation = transformation ; }
response: public MappingIterator ( Collection < S > source , Function < S , D > transformation ) { this . sourceIt = source . iterator ( ) ; this . transformation = transformation ; } public boolean hasNext ( ) { return sourceIt . hasNext ( ) ; } public D next ( ) { S nextSource = sourceIt . next ( ) ; return transformation . apply ( nextSource ) ; }

sample: 157
buggy_code: public boolean removeAll(Collection<?> c) { boolean changed = false; for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) { <START> if (map.remove(x.getFilename(), x)) { <END> changed = true; } } if (changed) { updatedMap(); } return changed; }
code_review: remove(a,b) is going to use equals which is not right for XWikiAttachment. You should use remove(a) != b instead.
target code: public boolean removeAll ( Collection < ? > c ) { boolean changed = false ; for ( XWikiAttachment x : ( Collection < ? extends XWikiAttachment > ) c ) { if ( map . get ( x . getFilename ( ) ) == x ) { map . remove ( x . getFilename ( ) ) ; changed = true ; } } if ( changed ) { updatedMap ( ) ; } return changed ; }
response: public boolean removeAll ( Collection < ? > c ) { boolean changed = false ; for ( XWikiAttachment x : ( Collection < ? extends XWikiAttachment > ) c ) { if ( map . remove ( x . getFilename ( ) ) != x ) { changed = true ; } } if ( changed ) { updatedMap ( ) ; } return changed ; }

sample: 158
buggy_code: public void run(String... strings) throws Exception { <START> System.out.println(">>> Starting Audit App... "); <END> }
code_review: @erdemedeiros let's remove all the system outs
target code: public void run ( String . . . strings ) throws Exception { }
response: public void run ( String . . . strings ) throws Exception { // Starting Audit App }

sample: 159
buggy_code: public CollectEnvCommand(FileSystemContext fsContext) { super(fsContext); <START> mCommands = new HashMap<>(); mCommandsAlt = new HashMap<>(); <END> registerCommands(); }
code_review: This is already initialized by super class.
target code: public CollectEnvCommand ( FileSystemContext fsContext ) { super ( fsContext ) ; registerCommands ( ) ; }
response: public CollectEnvCommand ( FileSystemContext fsContext ) { super ( fsContext ) ; registerCommands ( ) ; }

sample: 160
buggy_code: protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException("BlobStorageService cannot be null"); <START> } else { <END> this.blobStorageService = blobStorageService; logger.trace("BlobStorage service set to {}", blobStorageService.getClass()); } }
code_review: The "else" seems unnecessary
target code: protected void setBlobStorageService ( BlobStorageService blobStorageService ) { if ( blobStorageService == null ) { throw new IllegalArgumentException ( "BlobStorageService cannot be null" ) ; } this . blobStorageService = blobStorageService ; logger . trace ( "BlobStorage service set to { } " , blobStorageService . getClass ( ) ) ; }
response: protected void setBlobStorageService ( BlobStorageService blobStorageService ) { if ( blobStorageService == null ) { throw new IllegalArgumentException ( "BlobStorageService cannot be null" ) ; } this . blobStorageService = blobStorageService ; logger . trace ( "BlobStorage service set to { } " , blobStorageService . getClass ( ) ) ; }

sample: 161
buggy_code: public void dispose() { app.getChildren().remove(windowModel); coolBarManager.dispose(); menuManager.dispose(); statusLineManager.dispose(); <START> windowModel.setToBeRendered(false); <END> windowModel.getContext().deactivate(); windowModel.getContext().dispose(); ((Shell) windowModel.getWidget()).dispose(); }
code_review: I don't think this hurts but line 96 already sets this window.tbr to false and I have not seen that this property has changed.
target code: public void dispose ( ) { app . getChildren ( ) . remove ( windowModel ) ; coolBarManager . dispose ( ) ; menuManager . dispose ( ) ; statusLineManager . dispose ( ) ; windowModel . getContext ( ) . deactivate ( ) ; windowModel . getContext ( ) . dispose ( ) ; ( ( Shell ) windowModel . getWidget ( ) ) . dispose ( ) ; }
response: public void dispose ( ) { app . getChildren ( ) . remove ( windowModel ) ; coolBarManager . dispose ( ) ; menuManager . dispose ( ) ; statusLineManager . dispose ( ) ; windowModel . getContext ( ) . deactivate ( ) ; windowModel . getContext ( ) . dispose ( ) ; ( ( Shell ) windowModel . getWidget ( ) ) . dispose ( ) ; }

sample: 162
buggy_code: public void setUp() { n = new CacheManagerNotifierImpl(); cl = new CacheManagerListener(); <START> TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor())); <END> n.start(); n.addListener(cl); }
code_review: The executor shouldn't be needed here either
target code: public void setUp ( ) { n = new CacheManagerNotifierImpl ( ) ; cl = new CacheManagerListener ( ) ; n . start ( ) ; n . addListener ( cl ) ; }
response: public void setUp ( ) { n = new CacheManagerNotifierImpl ( ) ; cl = new CacheManagerListener ( ) ; TestingUtil . inject ( n , TestingUtil . named ( KnownComponentNames . ASYNC_NOTIFICATION_EXECUTOR , new WithinThreadExecutor ( ) ) ) ; n . start ( ) ; n . addListener ( cl ) ; }

sample: 163
buggy_code: public char getLabel() { <START> char rv; <END> switch (getType()) { case INPUT_VAL: rv = buttonData.inputVal; break; case AUTO_CHAR: rv = buttonData.autoChar; break; case CUSTOM: rv = buttonData.customChar; break; default: rv='*'; // Should never happen. } return rv; }
code_review: Should be `final char rv;`.
target code: public char getLabel ( ) { final char rv ; switch ( getType ( ) ) { case INPUT_VAL : rv = buttonData . inputVal ; break ; case AUTO_CHAR : rv = buttonData . autoChar ; break ; case CUSTOM : rv = buttonData . customChar ; break ; default : rv = ' * ' ; // Should never happen . } return rv ; }
response: public char getLabel ( ) { final char rv ; switch ( getType ( ) ) { case INPUT_VAL : rv = buttonData . inputVal ; break ; case AUTO_CHAR : rv = buttonData . autoChar ; break ; case CUSTOM : rv = buttonData . customChar ; break ; default : rv = ' * ' ; // Should never happen . } return rv ; }

sample: 164
buggy_code: public ReleasableBytesReference retainedSlice(int from, int length) { BytesReference slice = delegate.slice(from, length); <START> refCounted.incRef(); <END> return new ReleasableBytesReference(slice, refCounted); }
code_review: I would prefer to move this call to the private `ReleasableBytesReference` constructor.
target code: public ReleasableBytesReference retainedSlice ( int from , int length ) { return new ReleasableBytesReference ( delegate . slice ( from , length ) , refCounted ) ; }
response: public ReleasableBytesReference retainedSlice ( int from , int length ) { BytesReference slice = delegate . slice ( from , length ) ; return new ReleasableBytesReference ( slice , refCounted . incRef ( ) ) ; }

sample: 165
buggy_code: public static <T> Iterable<T> latest(final Observable<? extends T> source) { return new Iterable<T>() { @Override public Iterator<T> iterator() { LatestObserverIterator<T> lio = new LatestObserverIterator<T>(); <START> lio.subscription = source.materialize().subscribe(lio); <END> return lio; } }; }
code_review: This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value `lio` essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call `this.unsubscribe()` on L101.
target code: public static < T > Iterable < T > latest ( final Observable < ? extends T > source ) { return new Iterable < T > ( ) { @Override public Iterator < T > iterator ( ) { LatestObserverIterator < T > lio = new LatestObserverIterator < T > ( ) ; source . materialize ( ) . subscribe ( lio ) ; return lio ; } } ; }
response: public static < T > Iterable < T > latest ( final Observable < ? extends T > source ) { return new Iterable < T > ( ) { @Override public Iterator < T > iterator ( ) { LatestObserverIterator < T > lio = new LatestObserverIterator < T > ( ) ; lio . subscription = source . materialize ( ) . subscribe ( lio ) ; return lio ; } } ; } private static class LatestObserverIterator < T > extends SafeSubscriber < Notification < ? extends T > > implements Iterator < T > { private Notification < ? extends T > next ; private boolean hasNext = false ; @Override public void onNext ( Notification < ? extends T > args ) { if ( args . isOnCompleted ( ) ) { unsubscribe ( ) ; } else { hasNext = true ; next = args ; } } @Override public void onError ( Throwable e ) { throw new RuntimeException ( e ) ; } @Override public void onCompleted ( ) { // Do nothing } @Override public boolean hasNext ( ) { if ( ! hasNext ) { next = takeNext ( ) ; } return hasNext ; } @Override public T next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } hasNext = false ; return next . getValue ( ) ; } private Notification < ? extends T > takeNext ( ) { if ( subscription . isUnsubscribed ( ) ) { throw new NoSuchElementException ( ) ; } hasNext

sample: 166
buggy_code: public static MessageType fromId(String id) { for(MessageType current : values()) { if(current.getId().equals(id)) { return current; } } <START> return UNKNOWN; <END> }
code_review: Discussion: does it make sense to return an enum entry here that I guess only exists for this method? Other alternatives could be to return `null` here, or an Optional
target code: public static Optional < MessageType > fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return Optional . of ( current ) ; } } return Optional . empty ( ) ; }
response: public static MessageType fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return current ; } } return null ; }  or  public static Optional < MessageType > fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return Optional . of ( current ) ; } } return Optional . empty ( ) ; }  Note : The refactored code returns `null` or an `Optional` instead of an enum entry that only exists for this method .

sample: 167
buggy_code: private boolean isHostNetworkUnreacable(VDS vds) { VdsDynamic vdsDynamic = vds.getDynamicData(); return ((vdsDynamic.getStatus() == VDSStatus.Down) || (vdsDynamic.getStatus() == VDSStatus.Reboot) || (vdsDynamic.getStatus() == VDSStatus.NonOperational <START> && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE)); <END> }
code_review: Please remove unnecessary brackets: return vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE); Even remaining brackets are not necessary, but they makes code more readable
target code: private boolean isHostNetworkUnreacable ( VDS vds ) { VdsDynamic vdsDynamic = vds . getDynamicData ( ) ; return ( vdsDynamic . getStatus ( ) == VDSStatus . Down || vdsDynamic . getStatus ( ) == VDSStatus . Reboot || ( vdsDynamic . getStatus ( ) == VDSStatus . NonOperational && vdsDynamic . getNonOperationalReason ( ) == NonOperationalReason . NETWORK_UNREACHABLE ) ) ; }
response: private boolean isHostNetworkUnreacable ( VDS vds ) { VdsDynamic vdsDynamic = vds . getDynamicData ( ) ; return vdsDynamic . getStatus ( ) == VDSStatus . Down || vdsDynamic . getStatus ( ) == VDSStatus . Reboot || ( vdsDynamic . getStatus ( ) == VDSStatus . NonOperational && vdsDynamic . getNonOperationalReason ( ) == NonOperationalReason . NETWORK_UNREACHABLE ) ; }

sample: 168
buggy_code: <START> ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) { <END> this.scriptMessageProcessor = scriptMessageProcessor; }
code_review: Having the Java Config style, it'd better to make this class `public`.
target code: public ScriptExecutingMessageSource ( AbstractScriptExecutingMessageProcessor < ? > scriptMessageProcessor ) { this . scriptMessageProcessor = scriptMessageProcessor ; }
response: public class ScriptExecutingMessageSource { public ScriptExecutingMessageSource ( AbstractScriptExecutingMessageProcessor < ? > scriptMessageProcessor ) { this . scriptMessageProcessor = scriptMessageProcessor ; } }

sample: 169
buggy_code: public void typeInSearchField(String content, int length) { waitForElementVisibleByElement(searchInput); <START> searchInput.sendKeys(content.substring(0, length)); <END> PageObjectLogging.log( "typeInSearchField", "String >>" + content.substring(0, length) + "<< was typed in string field", true ); }
code_review: How come there needs to be a substring for this?
target code: public void typeInSearchField ( String content , int length ) { waitForElementVisibleByElement ( searchInput ) ; searchInput . sendKeys ( content . substring ( 0 , 3 ) ) ; PageObjectLogging . log ( "typeInSearchField" , "String > > " + content . substring ( 0 , length ) + " < < was typed in string field" , true ) ; }
response: public void typeInSearchField ( String content ) { waitForElementVisibleByElement ( searchInput ) ; searchInput . sendKeys ( content ) ; PageObjectLogging . log ( "typeInSearchField" , "String > > " + content + " < < was typed in string field" , true ) ; }  Explanation : The substring was used to limit the length of the input string to be typed in the search field . However , it is not necessary to limit the length of the input string as the `sendKeys` method can handle the entire string . Therefore , the substring can be removed .

sample: 170
buggy_code: public Iterable<E> read(Configuration configuration) throws IOException { // TODO: what to do with Configuration? create new view? DatasetReader<E> reader = view.newReader(); <START> return reader; // TODO: who calls close? <END> }
code_review: Inline.
target code: public Iterable < E > read ( Configuration configuration ) throws IOException { // TODO : what to do with Configuration ? create new view ? return view . newReader ( ) ; // TODO : who calls close ? }
response: public Iterable < E > read ( Configuration configuration ) throws IOException { DatasetReader < E > reader = view . newReader ( ) ; return reader ; }

sample: 171
buggy_code: public void setRefreshInterval(final long refreshInterval) { <START> REFRESH_INTERVAL_IN_SECONDS = refreshInterval; <END> }
code_review: if it is not constant, please convert to lower case?
target code: public void setRefreshInterval ( final long refreshInterval ) { this . refreshInterval = refreshInterval ; }
response: public void setRefreshInterval ( final long refreshInterval ) { final long refreshIntervalInSeconds = refreshInterval ; }

sample: 172
buggy_code: public void onNewImageFromCamera() { <START> if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) { <END> navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA); } else { interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null); } }
code_review: These copy-paste sections are starting to clutter up the presenter. Please try to extract a common denominator (e.g. a function) to reduce repeating code snippets.
target code: public void onNewImageFromCamera ( ) { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; }
response: public void onNewImageFromCamera ( ) { if ( navigator . isSdkAboveOrEqualM ( ) && ! navigator . doIHavePermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) ) { navigator . askForPermission ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA ) ; } else { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; } } // Extracted function private boolean checkPermissionAndAsk ( String permission , int requestCode ) { if ( navigator . isSdkAboveOrEqualM ( ) && ! navigator . doIHavePermission ( permission ) ) { navigator . askForPermission ( new String [ ] { permission } , requestCode ) ; return false ; } else { return true ; } } public void onNewImageFromCamera ( ) { if ( checkPermissionAndAsk ( Manifest . permission . WRITE_EXTERNAL_STORAGE , PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA ) ) { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; } }

sample: 173
buggy_code: public void testEquals() throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, "UTF8", <START> 10, true, false, true); <END> FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, "UTF8", 10, true, false, true); assertEquals(conf1, conf2); FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, "UTF8", 10, false, false, true); assertFalse(conf1.equals(conf3)); }
code_review: Please make sure there are overloaded constructors available for the old constructor signature. Then you also wont have to change this existing test.
target code: public void testEquals ( ) throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true ) ; FixedWidthConfiguration conf2 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true ) ; assertEquals ( conf1 , conf2 ) ; FixedWidthConfiguration conf3 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , false ) ; assertFalse ( conf1 . equals ( conf3 ) ) ; }
response: public void testEquals ( ) throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true , false , true ) ; FixedWidthConfiguration conf2 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true , false , true ) ; assertEquals ( conf1 , conf2 ) ; FixedWidthConfiguration conf3 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , false , false , true ) ; assertFalse ( conf1 . equals ( conf3 ) ) ; } public class FixedWidthConfiguration { private int width ; private String encoding ; private boolean ignoreMissing ; private boolean ignoreExtra ; private boolean ignoreEmptyLines ; public FixedWidthConfiguration ( int width , String encoding , boolean ignoreMissing , boolean ignoreExtra , boolean ignoreEmptyLines ) { this . width = width ; this . encoding = encoding ; this . ignoreMissing = ignoreMissing ; this . ignoreExtra = ignoreExtra ; this . ignoreEmptyLines = ignoreEmptyLines ; } public FixedWidthConfiguration ( int width , String encoding , int ignoreMissing , boolean ignoreExtra , boolean ignoreEmptyLines ) { this . width = width ; this . encoding = encoding ; this . ignoreMissing = ignoreMissing == 1 ; this . ignoreExtra = ignoreExtra ; this . ignoreEmptyLines = ignoreEmptyLines ; } // getters and setters @Override public boolean equals ( Object o ) { if ( this == o )

sample: 174
buggy_code: public void showLinkPreview(PageTitle title, int entrySource) { final String linkPreviewFragmentTag = "link_preview_dialog"; if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) { <START> linkPreview = LinkPreviewDialog.newInstance(title, entrySource); <END> linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag); } }
code_review: You actually don't need a private variable for storing the link preview. If you look at the line directly above, the findFragmentByTag() function finds the dialog by its tag name (also specified above). You can cast the return value of this function into a LinkPreviewDialog, and call dismiss() on it.
target code: public void showLinkPreview ( PageTitle title , int entrySource ) { final String linkPreviewFragmentTag = "link_preview_dialog" ; if ( getSupportFragmentManager ( ) . findFragmentByTag ( linkPreviewFragmentTag ) == null ) { LinkPreviewDialog linkPreview = LinkPreviewDialog . newInstance ( title , entrySource ) ; linkPreview . show ( getSupportFragmentManager ( ) , linkPreviewFragmentTag ) ; } }
response: public void showLinkPreview ( PageTitle title , int entrySource ) { final String linkPreviewFragmentTag = "link_preview_dialog" ; LinkPreviewDialog linkPreview = ( LinkPreviewDialog ) getSupportFragmentManager ( ) . findFragmentByTag ( linkPreviewFragmentTag ) ; if ( linkPreview == null ) { linkPreview = LinkPreviewDialog . newInstance ( title , entrySource ) ; linkPreview . show ( getSupportFragmentManager ( ) , linkPreviewFragmentTag ) ; } else { linkPreview . dismiss ( ) ; } }

sample: 175
buggy_code: public void clear() { <START> if (loader instanceof CacheStore) <END> try { ((CacheStore) loader).clear(); } catch (CacheLoaderException e) { throw newCacheLoaderException(e); } }
code_review: IMO, if you use `if (...) { ... }`, it makes the code easy to read. I meant the `{` and `}` are missing :) edit: the same for the following `if`s
target code: public void clear ( ) { if ( loader instanceof CacheStore ) { try { ( ( CacheStore ) loader ) . clear ( ) ; } catch ( CacheLoaderException e ) { throw newCacheLoaderException ( e ) ; } } }
response: public void clear ( ) { if ( loader instanceof CacheStore ) { try { ( ( CacheStore ) loader ) . clear ( ) ; } catch ( CacheLoaderException e ) { throw newCacheLoaderException ( e ) ; } } }

sample: 176
buggy_code: public ApplicabilityIds getApplicabilityIds() { // TBD - Replace with call to IApplicabilityService calls once implemented <START> ApplicabilityIds ids = new ApplicabilityIds(); <END> // ids.getApplicabilityIds().add(new ApplicabilityId(345L, "ARC-210")); // ids.getApplicabilityIds().add(new ApplicabilityId(366L, "COMM")); // ids.getApplicabilityIds().add(new ApplicabilityId(376L, "ASM")); // ids.getApplicabilityIds().add(new ApplicabilityId(368L, "UTF")); // ids.getApplicabilityIds().add(new ApplicabilityId(466L, "MDR")); return ids; }
code_review: This file needs some work to ensure it works with client.
target code: public ApplicabilityIds getApplicabilityIds ( ) { return null ; }
response: public ApplicabilityIds getApplicabilityIds ( ) { // Replace with call to IApplicabilityService calls once implemented ApplicabilityIds ids = new ApplicabilityIds ( ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 345L , "ARC - 210" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 366L , "COMM" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 376L , "ASM" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 368L , "UTF" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 466L , "MDR" ) ) ; return ids ; }

sample: 177
buggy_code: <START> MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) { <END> if (!negotiated.matchesAll()) return negotiated; MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType(); if (storageMediaType == null) return negotiated; if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN; if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON; return negotiated; }
code_review: private?
target code: private MediaType tryNarrowMediaType ( MediaType negotiated , AdvancedCache < ? , ? > cache ) { if ( ! negotiated . matchesAll ( ) ) return negotiated ; MediaType storageMediaType = cache . getValueDataConversion ( ) . getStorageMediaType ( ) ; if ( storageMediaType == null ) return negotiated ; if ( storageMediaType . equals ( MediaType . APPLICATION_OBJECT ) ) return TEXT_PLAIN ; if ( storageMediaType . match ( MediaType . APPLICATION_PROTOSTREAM ) ) return APPLICATION_JSON ; return negotiated ; }
response: private MediaType tryNarrowMediaType ( MediaType negotiated , AdvancedCache < ? , ? > cache ) { if ( ! negotiated . matchesAll ( ) ) return negotiated ; MediaType storageMediaType = cache . getValueDataConversion ( ) . getStorageMediaType ( ) ; if ( storageMediaType == null ) return negotiated ; if ( storageMediaType . equals ( MediaType . APPLICATION_OBJECT ) ) return MediaType . TEXT_PLAIN ; if ( storageMediaType . match ( MediaType . APPLICATION_PROTOSTREAM ) ) return MediaType . APPLICATION_JSON ; return negotiated ; }

sample: 178
buggy_code: protected void addJAROption(Composite comp) { fJarButton = new Button(comp, SWT.CHECK); fJarButton.setText(getJarButtonText()); <START> fJarButton.addSelectionListener(widgetSelectedAdapter(e -> { <END> })); }
code_review: This does not do anything. Can be removed
target code: protected void addJAROption ( Composite comp ) { fJarButton = new Button ( comp , SWT . CHECK ) ; fJarButton . setText ( getJarButtonText ( ) ) ; }
response: protected void addJAROption ( Composite comp ) { fJarButton = new Button ( comp , SWT . CHECK ) ; fJarButton . setText ( getJarButtonText ( ) ) ; }

sample: 179
buggy_code: public String getTurnDescription( Translation tr ) { <START> if (rawName || !name.isEmpty()) <END> return getName(); return tr.tr("finish"); }
code_review: The additional check is not used in other instructions, is it needed?
target code: public String getTurnDescription ( Translation tr ) { if ( rawName ) return getName ( ) ; return tr . tr ( "finish" ) ; }
response: public String getTurnDescription ( Translation tr ) { if ( ! name . isEmpty ( ) ) { return getName ( ) ; } return tr . tr ( "finish" ) ; }

sample: 180
buggy_code: private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions(); presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton()); try { createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true); } catch (Exception e) { <START> throw e; <END> } }
code_review: Catch?
target code: private void fetchPresenterWidgetTemplate ( PresenterOptions presenterOptions ) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions ( ) ; presenterWidgetOptions . setSingleton ( presenterConfigModel . isUseSingleton ( ) ) ; createdPresenterWidgetTemplates = CreatePresenterWidget . run ( presenterOptions , presenterWidgetOptions , true ) ; }
response: private void fetchPresenterWidgetTemplate ( PresenterOptions presenterOptions ) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions ( ) ; presenterWidgetOptions . setSingleton ( presenterConfigModel . isUseSingleton ( ) ) ; createdPresenterWidgetTemplates = CreatePresenterWidget . run ( presenterOptions , presenterWidgetOptions , true ) ; }

sample: 181
buggy_code: public String toString() { StringWriter writer = new StringWriter(); try { new ObjectMapper().writeValue(writer, graph); } catch (Exception e) { log.debug ("Error while constructing new ObjectMapper",e); <START> } <END> return writer.toString(); }
code_review: Make this as a log.error statement. And needs to have space after the ","
target code: public String toString ( ) { StringWriter writer = new StringWriter ( ) ; try { new ObjectMapper ( ) . writeValue ( writer , graph ) ; } catch ( Exception e ) { log . error ( "Error while constructing new ObjectMapper" , e ) ; } return writer . toString ( ) ; }
response: public String toString ( ) { StringWriter writer = new StringWriter ( ) ; try { new ObjectMapper ( ) . writeValue ( writer , graph ) ; } catch ( Exception e ) { log . error ( "Error while constructing new ObjectMapper" , e ) ; } return writer . toString ( ) ; }

sample: 182
buggy_code: public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) { //TODO: check non-null this.topic = topic; this.connector = task.connector(); this.task = task.task(); <START> this.discoverTimestamp = discoverTimestamp; <END> }
code_review: How about replacing these four lines with: ``` this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp); ``` and then removing the TODO line?
target code: public TopicStatus ( String topic , ConnectorTaskId task , long discoverTimestamp ) { this ( topic , task . connector ( ) , task . task ( ) , discoverTimestamp ) ; }
response: public TopicStatus ( String topic , ConnectorTaskId task , long discoverTimestamp ) { this ( topic , Objects . requireNonNull ( task ) . connector ( ) , task . task ( ) , discoverTimestamp ) ; } private TopicStatus ( String topic , String connector , int task , long discoverTimestamp ) { this . topic = topic ; this . connector = connector ; this . task = task ; this . discoverTimestamp = discoverTimestamp ; }

sample: 183
buggy_code: private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length) { switch (type) { case POINT: return readPoint(input); case MULTI_POINT: case LINE_STRING: case MULTI_LINE_STRING: case POLYGON: case MULTI_POLYGON: return readSimpleGeometry(input, inputSlice, type, length); case GEOMETRY_COLLECTION: return readGeometryCollection(input, inputSlice); case ENVELOPE: <START> return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null); <END> default: throw new IllegalArgumentException("Unexpected type: " + type); } }
code_review: Just add an envelope section to `createFromEsriGeometry` method in this file
target code: private static OGCGeometry readGeometry ( BasicSliceInput input , Slice inputSlice , GeometryType type , int length ) { switch ( type ) { case POINT : return readPoint ( input ) ; case MULTI_POINT : case LINE_STRING : case MULTI_LINE_STRING : case POLYGON : case MULTI_POLYGON : return readSimpleGeometry ( input , inputSlice , type , length ) ; case GEOMETRY_COLLECTION : return readGeometryCollection ( input , inputSlice ) ; case ENVELOPE : return createFromEsriGeometry ( readEnvelope ( input ) , false ) ; default : throw new IllegalArgumentException ( "Unexpected type : " + type ) ; } }
response: private static OGCGeometry readGeometry ( BasicSliceInput input , Slice inputSlice , GeometryType type , int length ) { switch ( type ) { case POINT : return readPoint ( input ) ; case MULTI_POINT : case LINE_STRING : case MULTI_LINE_STRING : case POLYGON : case MULTI_POLYGON : return readSimpleGeometry ( input , inputSlice , type , length ) ; case GEOMETRY_COLLECTION : return readGeometryCollection ( input , inputSlice ) ; case ENVELOPE : return OGCGeometry . createFromEsriGeometry ( readEnvelope ( input ) , null ) ; default : throw new IllegalArgumentException ( "Unexpected type : " + type ) ; } }

sample: 184
buggy_code: public void close() { <START> sketch = null; <END> }
code_review: Could set `null` to the `values` field too
target code: public void close ( ) { sketch = null ; values = null ; }
response: public void close ( ) { sketch = null ; values = null ; }

sample: 185
buggy_code: public boolean shouldSpill() { // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV) long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch; long reserveForOutgoing = batchMemoryManager.getOutputBatchSize(); <START> long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing; <END> boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow; if ( needsSpill ) { logger.debug("should spill now - batch size {}, mem avail {}, reserved for outgoing {}", batchSize, memoryAvailableNow, reserveForOutgoing); } return needsSpill; // go spill if too little memory is available }
code_review: We still need to account for the probe batch size here when we are processing a spilled partition. If we try to account for it in he PostBuildCalculator it will already be too late, because we will have already prefetched the probe side batch.
target code: public boolean shouldSpill ( ) { // Expected new batch size like the current , plus the Hash Values vector ( 4 bytes per HV ) long batchSize = ( batchMemoryManager . getRecordBatchSizer ( RIGHT_INDEX ) . getRowAllocWidth ( ) + 4 ) * recordsPerBatch ; long reserveForOutgoing = batchMemoryManager . getOutputBatchSize ( ) ; long memoryAvailableNow = allocator . getLimit ( ) - allocator . getAllocatedMemory ( ) ; boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow - reserveForOutgoing ; if ( needsSpill ) { logger . debug ( "should spill now - batch size { } , mem avail { } , reserved for outgoing { } " , batchSize , memoryAvailableNow , reserveForOutgoing ) ; } return needsSpill ; // go spill if too little memory is available }
response: public boolean shouldSpill ( ) { long batchSize = ( batchMemoryManager . getRecordBatchSizer ( RIGHT_INDEX ) . getRowAllocWidth ( ) + 4 ) * recordsPerBatch ; long reserveForOutgoing = batchMemoryManager . getOutputBatchSize ( ) ; long memoryAvailableNow = allocator . getLimit ( ) - allocator . getAllocatedMemory ( ) - reserveForOutgoing - batchMemoryManager . getRecordBatchSizer ( LEFT_INDEX ) . getRowAllocWidth ( ) * recordsPerBatch ; boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow ; if ( needsSpill ) { logger . debug ( "should spill now - batch size { } , mem avail { } , reserved for outgoing { } " , batchSize , memoryAvailableNow , reserveForOutgoing ) ; } return needsSpill ; }

sample: 186
buggy_code: public void close() { try { Await.result(beam.close()); } catch (Exception e) { final String errorMsg = "Error while closing Druid beam client"; LOG.error(errorMsg, e); <START> throw new RuntimeException(errorMsg); <END> } }
code_review: same as above. we shouldn't be throwing run-time exceptions when close is called.
target code: public void close ( ) { try { Await . result ( beam . close ( ) ) ; } catch ( Exception e ) { LOG . error ( "Error while closing Druid beam client" , e ) ; } }
response: public void close ( ) { try { Await . result ( beam . close ( ) ) ; } catch ( Exception e ) { final String errorMsg = "Error while closing Druid beam client" ; LOG . error ( errorMsg , e ) ; throw new IOException ( errorMsg , e ) ; } }

sample: 187
buggy_code: private boolean isPlatformKeybindingBug517068Fixed() { Bundle bundle = Platform.getBundle("org.eclipse.e4.ui.bindings"); //$NON-NLS-1$ Version currentVersion = bundle.getVersion(); <START> Version fixVersion = new Version(0, 12, 100); <END> return currentVersion.compareTo(fixVersion) >= 0; }
code_review: Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
target code: private boolean isPlatformKeybindingBug517068Fixed ( ) { Bundle bundle = Platform . getBundle ( "org . eclipse . e4 . ui . bindings" ) ; // $NON - NLS - 1$ Version currentVersion = bundle . getVersion ( ) ; Version fixVersion = new Version ( 0 , 12 , 1 ) ; return currentVersion . compareTo ( fixVersion ) >= 0 ; }
response: private boolean isPlatformKeybindingBug517068Fixed ( ) { Bundle bundle = Platform . getBundle ( "org . eclipse . e4 . ui . bindings" ) ; // $NON - NLS - 1$ Version currentVersion = bundle . getVersion ( ) ; Version fixVersion = new Version ( 0 , 12 , 1 ) ; return currentVersion . compareTo ( fixVersion ) >= 0 ; }

sample: 188
buggy_code: public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 ) { <START> if ( StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) <END> && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ) ) { return true; } return false; }
code_review: Why not just: return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) && StringUtils.equals( p1.getPrefix(), p2.getPrefix() );
target code: public static boolean isPluginPrefixAndArtifactIdEquals ( Plugin p1 , Plugin p2 ) { return StringUtils . equals ( p1 . getArtifactId ( ) , p2 . getArtifactId ( ) ) && StringUtils . equals ( p1 . getPrefix ( ) , p2 . getPrefix ( ) ) ; }
response: public static boolean isPluginPrefixAndArtifactIdEquals ( Plugin p1 , Plugin p2 ) { return StringUtils . equals ( p1 . getArtifactId ( ) , p2 . getArtifactId ( ) ) && StringUtils . equals ( p1 . getPrefix ( ) , p2 . getPrefix ( ) ) ; }

sample: 189
buggy_code: public <VT> MessageOut<T> withParameter(ParameterType type, VT value) { <START> List<Object> newParameters = new ArrayList<>(parameters.size() + 3); <END> newParameters.addAll(parameters); newParameters.add(type); newParameters.add(value); return new MessageOut<T>(verb, payload, serializer, newParameters); }
code_review: I think tuple size used to be 3. I'll fix it.
target code: public < VT > MessageOut < T > withParameter ( ParameterType type , VT value ) { List < Object > newParameters = new ArrayList < > ( parameters . size ( ) + 2 ) ; newParameters . addAll ( parameters ) ; newParameters . add ( type ) ; newParameters . add ( value ) ; return new MessageOut < T > ( verb , payload , serializer , newParameters ) ; }
response: public < VT > MessageOut < T > withParameter ( ParameterType type , VT value ) { List < Object > newParameters = new ArrayList < > ( parameters . size ( ) + 2 ) ; newParameters . addAll ( parameters ) ; newParameters . add ( type ) ; newParameters . add ( value ) ; return new MessageOut < T > ( verb , payload , serializer , newParameters ) ; }

sample: 190
buggy_code: private boolean validateTimeRange() { boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty(); return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) <= 0; <START> } <END>
code_review: should this be < 0? do we want to import a 0 nanosecond range?
target code: private boolean validateTimeRange ( ) { boolean isEmpty = fStartTimeRangeText . getText ( ) . isEmpty ( ) || fEndTimeRangeText . getText ( ) . isEmpty ( ) ; return ! isEmpty && parseTimeRange ( ) && fStartTimestamp . compareTo ( fEndTimestamp ) < 0 ; }
response: private boolean validateTimeRange ( ) { boolean isEmpty = fStartTimeRangeText . getText ( ) . isEmpty ( ) || fEndTimeRangeText . getText ( ) . isEmpty ( ) ; return ! isEmpty && parseTimeRange ( ) && fStartTimestamp . compareTo ( fEndTimestamp ) < 0 ; }

sample: 191
buggy_code: public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) { String filenamePath = ""; StringBuilder filenameBuilder = new StringBuilder(); filenameBuilder.append(fieldbookProperties.getUploadDirectory()); filenameBuilder.append(File.separator); filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename)); <START> filenamePath = filenameBuilder.toString(); <END> return filenamePath; }
code_review: Move filenamePath declaration to this line and make it final
target code: public static String getFileNamePath ( final String filename , final FieldbookProperties fieldbookProperties ) { final StringBuilder filenameBuilder = new StringBuilder ( ) ; filenameBuilder . append ( fieldbookProperties . getUploadDirectory ( ) ) ; filenameBuilder . append ( File . separator ) ; filenameBuilder . append ( SettingsUtil . cleanSheetAndFileName ( filename ) ) ; final String filenamePath = filenameBuilder . toString ( ) ; return filenamePath ; }
response: public static String getFileNamePath ( final String filename , final FieldbookProperties fieldbookProperties ) { final String filenamePath ; StringBuilder filenameBuilder = new StringBuilder ( ) ; filenameBuilder . append ( fieldbookProperties . getUploadDirectory ( ) ) ; filenameBuilder . append ( File . separator ) ; filenameBuilder . append ( SettingsUtil . cleanSheetAndFileName ( filename ) ) ; filenamePath = filenameBuilder . toString ( ) ; return filenamePath ; }

sample: 192
buggy_code: protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) { executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() { @SuppressWarnings("synthetic-access") @Override public StoragePoolIsoMap runInTransaction() { <START> CompensationContext context = getCompensationContext(); <END> context.snapshotEntityStatus(map, map.getstatus()); map.setstatus(status); getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus()); getCompensationContext().stateChanged(); return null; } }); }
code_review: this line can be removed
target code: protected void changeStorageDomainStatusInTransaction ( final StoragePoolIsoMap map , final StorageDomainStatus status ) { executeInNewTransaction ( new TransactionMethod < StoragePoolIsoMap > ( ) { @Override public StoragePoolIsoMap runInTransaction ( ) { CompensationContext context = getCompensationContext ( ) ; context . snapshotEntityStatus ( map , map . getstatus ( ) ) ; updateStatus ( map , status ) ; getCompensationContext ( ) . stateChanged ( ) ; return null ; } } ) ; }
response: protected void changeStorageDomainStatusInTransaction ( final StoragePoolIsoMap map , final StorageDomainStatus status ) { executeInNewTransaction ( new TransactionMethod < StoragePoolIsoMap > ( ) { @SuppressWarnings ( "synthetic - access" ) @Override public StoragePoolIsoMap runInTransaction ( ) { CompensationContext context = getCompensationContext ( ) ; context . snapshotEntityStatus ( map , map . getStatus ( ) ) ; map . setStatus ( status ) ; getStoragePoolIsoMapDao ( ) . updateStatus ( map . getId ( ) , map . getStatus ( ) ) ; getCompensationContext ( ) . stateChanged ( ) ; return null ; } } ) ; }

sample: 193
buggy_code: public void visitMemberSelectExpression(MemberSelectExpressionTree tree) { if (tree.expression().is(Tree.Kind.IDENTIFIER)) { IdentifierTree identifier = (IdentifierTree) tree.expression(); <START> final Symbol owner = identifier.symbol().owner(); <END> if (owner != null && owner.isMethodSymbol()) { // No need to investigate selection on local symbols return; } } if (tree.expression().symbolType().isSubtypeOf("java.lang.Class")) { // No need to investigate selection on a Class object return; } super.visitMemberSelectExpression(tree); }
code_review: remove `final` modifier.
target code: public void visitMemberSelectExpression ( MemberSelectExpressionTree tree ) { if ( tree . expression ( ) . is ( Tree . Kind . IDENTIFIER ) ) { IdentifierTree identifier = ( IdentifierTree ) tree . expression ( ) ; Symbol owner = identifier . symbol ( ) . owner ( ) ; if ( owner != null && owner . isMethodSymbol ( ) ) { // No need to investigate selection on local symbols return ; } } if ( tree . expression ( ) . symbolType ( ) . isSubtypeOf ( "java . lang . Class" ) ) { // No need to investigate selection on a Class object return ; } super . visitMemberSelectExpression ( tree ) ; }
response: public void visitMemberSelectExpression ( MemberSelectExpressionTree tree ) { if ( tree . expression ( ) . is ( Tree . Kind . IDENTIFIER ) ) { IdentifierTree identifier = ( IdentifierTree ) tree . expression ( ) ; Symbol owner = identifier . symbol ( ) . owner ( ) ; if ( owner != null && owner . isMethodSymbol ( ) ) { // No need to investigate selection on local symbols return ; } } if ( tree . expression ( ) . symbolType ( ) . isSubtypeOf ( "java . lang . Class" ) ) { // No need to investigate selection on a Class object return ; } super . visitMemberSelectExpression ( tree ) ; }

sample: 194
buggy_code: public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED); checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED); <START> if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { <END> BiFunctionExecutingEntryProcessor<K, V> ep = new BiFunctionExecutingEntryProcessor<>(remappingFunction); return executeOnKeyInternal(key, ep); } else { return computeIfPresentLocally(key, remappingFunction); } }
code_review: Hi, @mmedenjak is right we need a fallback mechanism when server is not available. Having a fallback mechanism have greater scope. Lets make the `computeIfPresentLocally` only implementation for now for the client. The optimisation for the client can be addressed later.
target code: public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) { checkNotNull ( key , NULL_KEY_IS_NOT_ALLOWED ) ; checkNotNull ( key , NULL_BIFUNCTION_IS_NOT_ALLOWED ) ; return computeIfPresentLocally ( key , remappingFunction ) ; }
response: public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) { checkNotNull ( key , NULL_KEY_IS_NOT_ALLOWED ) ; checkNotNull ( remappingFunction , NULL_BIFUNCTION_IS_NOT_ALLOWED ) ; return computeIfPresentLocally ( key , remappingFunction ) ; }

sample: 195
buggy_code: public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) { Tuple tuple = task.getTuple(stream, values); List<Integer> tasks = task.getOutgoingTasks(stream, values); <START> if (tasks.size() == 0) { <END> return; } for (Integer t : tasks) { transfer.transfer(t, tuple); } }
code_review: we don't need this check right. For loop won't enter if tasks are empty. We should avoid having multiple returns.
target code: public void sendUnanchored ( Task task , String stream , List < Object > values , ExecutorTransfer transfer ) { Tuple tuple = task . getTuple ( stream , values ) ; List < Integer > tasks = task . getOutgoingTasks ( stream , values ) ; for ( Integer t : tasks ) { transfer . transfer ( t , tuple ) ; } }
response: public void sendUnanchored ( Task task , String stream , List < Object > values , ExecutorTransfer transfer ) { Tuple tuple = task . getTuple ( stream , values ) ; List < Integer > tasks = task . getOutgoingTasks ( stream , values ) ; if ( ! tasks . isEmpty ( ) ) { for ( Integer t : tasks ) { transfer . transfer ( t , tuple ) ; } } }

sample: 196
buggy_code: AffinityResourceDefinition(PathElement path) { <START> super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new ReloadRequiredAddStepHandler(), new ReloadRequiredRemoveStepHandler()); <END> }
code_review: Unless I'm mistaken, you don't need to reload the whole server, just restart the services of the parent resource. You can leverage RestartParentResourceRegistration for this.
target code: AffinityResourceDefinition ( PathElement path ) { super ( path , UndertowExtension . getResolver ( Constants . HANDLER , Constants . AFFINITY , path . getValue ( ) ) ) ; }
response: AffinityResourceDefinition ( PathElement path ) { super ( path , UndertowExtension . getResolver ( Constants . HANDLER , Constants . AFFINITY , path . getValue ( ) ) , new RestartParentResourceRegistration ( ) , new RestartParentResourceRegistration ( ) ) ; }

sample: 197
buggy_code: @Override public E poll() { lock.lock(); try { if (queue.isEmpty()) { return null; } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> return null; <END> } finally { lock.unlock(); } }
code_review: throws
target code: @Override public E poll ( ) { lock . lock ( ) ; try { if ( queue . isEmpty ( ) ) { return null ; } E peek = queue . peek ( ) ; queue . remove ( ) ; return peek ; } catch ( IOException e ) { throw QueueFile . < Error > getSneakyThrowable ( e ) ; } finally { lock . unlock ( ) ; } }
response: @Override public E poll ( ) throws IOException { lock . lock ( ) ; try { if ( queue . isEmpty ( ) ) { return null ; } E peek = queue . peek ( ) ; queue . remove ( ) ; return peek ; } finally { lock . unlock ( ) ; } }

sample: 198
buggy_code: public void testTimeout() throws SystemException, RemoteException { <START> log.info("Method stateful #testTimeout called"); <END> Transaction txn; txn = tm.getTransaction(); TxTestUtil.enlistTestXAResource(txn); TxTestUtil.enlistTestXAResource(txn); try { TxTestUtil.waitForTimeout(tm); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RemoteException("Interupted during waiting for transaction timeout", ie); } }
code_review: log.tracef
target code: public void testTimeout ( ) throws SystemException , RemoteException { log . trace ( "Method stateful #testTimeout called" ) ; Transaction txn ; txn = tm . getTransaction ( ) ; TxTestUtil . enlistTestXAResource ( txn ) ; TxTestUtil . enlistTestXAResource ( txn ) ; try { TxTestUtil . waitForTimeout ( tm ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RemoteException ( "Interupted during waiting for transaction timeout" , ie ) ; } }
response: public void testTimeout ( ) throws SystemException , RemoteException { log . tracef ( "Method stateful #testTimeout called" ) ; Transaction txn ; txn = tm . getTransaction ( ) ; TxTestUtil . enlistTestXAResource ( txn ) ; TxTestUtil . enlistTestXAResource ( txn ) ; try { TxTestUtil . waitForTimeout ( tm ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RemoteException ( "Interupted during waiting for transaction timeout" , ie ) ; } }

sample: 199
buggy_code: <START> public UnstagedComparator(boolean sortAlphabetically) { <END> this.alphabeticallySort = sortAlphabetically; }
code_review: doesn't need to be public
target code: private UnstagedComparator ( boolean sortAlphabetically ) { this . alphabeticallySort = sortAlphabetically ; }
response: private UnstagedComparator ( boolean sortAlphabetically ) { this . alphabeticallySort = sortAlphabetically ; }

BLEU: 70.9 ; EM: 30.0
Python file executed successfully.
Cloning into 'tree-sitter-java'...
ngram match: 0.7090042840830206, weighted ngram match: 0.7198635071914383, syntax_match: 0.7311485841552656, dataflow_match: 0.6363636363636364
CodeBLEU score: 69.91
Python file executed successfully.
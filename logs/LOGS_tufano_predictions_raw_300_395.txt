sample: 300
buggy_code: <START> private static boolean isStringParameter( <END> @NonNull Expression expression, @NonNull JavaContext context) { if (expression instanceof StringLiteral) { return true; } else { JavaParser.ResolvedNode resolvedNode = context.resolve(expression); if (resolvedNode instanceof JavaParser.ResolvedField) { if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) { return true; } } } return false; }
code_review: instead of this, use (at the callsite where you have the JavaContext) TypeDescriptor type = context.getType(expression); return type != null && type.matchesSignature(JavaContext.TYPE_STRING);
target code: private static boolean isStringParameter ( @NonNull Expression expression , @NonNull JavaContext context ) { if ( expression instanceof StringLiteral ) { return true ; } else { ResolvedNode resolvedNode = context . resolve ( expression ) ; if ( resolvedNode instanceof ResolvedField ) { if ( ( ( ResolvedField ) resolvedNode ) . getValue ( ) instanceof String ) { return true ; } } } return false ; }
response: private static boolean isStringParameter ( @NonNull Expression expression , @NonNull JavaContext context ) { TypeDescriptor type = context . getType ( expression ) ; return type != null && type . matchesSignature ( JavaContext . TYPE_STRING ) ; }

sample: 301
buggy_code: protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) { <START> TopologyDetails td = getNextHighest(); <END> return getScore(availableCpu, availableMemory, availableGenericResources, td); }
code_review: Nit: could we inline this to avoid unnecessary object creation
target code: protected double getScore ( double availableCpu , double availableMemory , Map < String , Double > availableGenericResources ) { return getScore ( availableCpu , availableMemory , availableGenericResources , getNextHighest ( ) ) ; }
response: protected double getScore ( double availableCpu , double availableMemory , Map < String , Double > availableGenericResources ) { return getScore ( availableCpu , availableMemory , availableGenericResources , getNextHighest ( ) ) ; }

sample: 302
buggy_code: public <T extends Action> List<T> getActions(Class<T> type) { <START> List<T> _actions = Util.filter(getPersistedActions(), type); <END> for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) { _actions.addAll(Util.filter(createFor(taf), type)); } return Collections.unmodifiableList(_actions); }
code_review: I think this should be reverted, so it would still take into account additions from pre-`TransientActionFactory` implementations.
target code: public < T extends Action > List < T > getActions ( Class < T > type ) { List < T > _actions = Util . filter ( getActions ( ) , type ) ; for ( TransientActionFactory < ? > taf : TransientActionFactory . factoriesFor ( getClass ( ) , type ) ) { _actions . addAll ( Util . filter ( createFor ( taf ) , type ) ) ; } return Collections . unmodifiableList ( _actions ) ; }
response: public < T extends Action > List < T > getActions ( Class < T > type ) { List < T > _actions = new ArrayList < > ( getPersistedActions ( type ) ) ; for ( TransientActionFactory < ? > taf : TransientActionFactory . factoriesFor ( getClass ( ) , type ) ) { _actions . addAll ( Util . filter ( createFor ( taf ) , type ) ) ; } return Collections . unmodifiableList ( _actions ) ; } private < T extends Action > List < T > getPersistedActions ( Class < T > type ) { List < T > persistedActions = Util . filter ( getPersistedActions ( ) , type ) ; if ( persistedActions . isEmpty ( ) && type != Action . class ) { persistedActions = getPersistedActions ( Action . class ) ; } return persistedActions ; }

sample: 303
buggy_code: public void addRepresentation (ImageData srcImageData, int zoom) { if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT); int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom); if (imageSelectorIndex == device.getImageSelector ()) { init(srcImageData); <START> init(); <END> } else { data [imageSelectorIndex] = srcImageData; } }
code_review: ImageData for current image needs to be updated in the array?
target code: public void addRepresentation ( ImageData srcImageData , int zoom ) { if ( srcImageData == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; int imageSelectorIndex = DPIUtil . mapZoomToImageSelectorIndex ( zoom ) ; if ( imageSelectorIndex == getImageSelector ( ) ) { init ( srcImageData ) ; init ( ) ; } data [ imageSelectorIndex ] = srcImageData ; }
response: public void addRepresentation ( ImageData srcImageData , int zoom ) { if ( srcImageData == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } int imageSelectorIndex = DPIUtil . mapZoomToImageSelectorIndex ( zoom ) ; if ( imageSelectorIndex == device . getImageSelector ( ) ) { data [ imageSelectorIndex ] = srcImageData ; } else { init ( srcImageData ) ; } }

sample: 304
buggy_code: private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType); <START> defaultEnvironment.setup(); <END> return defaultEnvironment; }
code_review: you don't need to do that if you're already calling `loadProperties` in the public constructor, right? https://github.com/caelum/vraptor4/pull/973/files#diff-b7b62c45c7478eb642acfb81c12a4227R82
target code: private DefaultEnvironment buildEnvironment ( EnvironmentType environmentType ) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment ( environmentType ) ; return defaultEnvironment ; }
response: private DefaultEnvironment buildEnvironment ( EnvironmentType environmentType ) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment ( environmentType ) ; defaultEnvironment . loadProperties ( ) ; return defaultEnvironment ; }

sample: 305
buggy_code: public int hashCode() { <START> return getRepositoryName() != null ? getRepositoryName().hashCode() : <END> System.identityHashCode(this); }
code_review: Style-nit: This is hard to read. Maybe: if (getRepositoryName() != null) return getRepositoryName().hashCode(); return System.identityHashCode(this);
target code: public int hashCode ( ) { if ( getRepositoryName ( ) != null ) return getRepositoryName ( ) . hashCode ( ) ; return System . identityHashCode ( this ) ; }
response: public int hashCode ( ) { if ( getRepositoryName ( ) != null ) return getRepositoryName ( ) . hashCode ( ) ; return System . identityHashCode ( this ) ; }

sample: 306
buggy_code: public List<String> getExtensions() { <START> return extensions == null ? DEFAULT_EXTS : extensions; <END> }
code_review: Can be removed and return only extensions without assigning logic.
target code: public List < String > getExtensions ( ) { return extensions ; }
response: public List < String > getExtensions ( ) { return extensions ; }

sample: 307
buggy_code: public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria(); addRestrictionOnPatient(radiologyOrderCriteria, patient); <START> List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list(); <END> return result == null ? new ArrayList<RadiologyOrder>() : result; }
code_review: use final
target code: public List < RadiologyOrder > getRadiologyOrdersByPatient ( Patient patient ) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria ( ) ; addRestrictionOnPatient ( radiologyOrderCriteria , patient ) ; final List < RadiologyOrder > result = ( List < RadiologyOrder > ) radiologyOrderCriteria . list ( ) ; return result == null ? new ArrayList < RadiologyOrder > ( ) : result ; }
response: public List < RadiologyOrder > getRadiologyOrdersByPatient ( final Patient patient ) { final Criteria radiologyOrderCriteria = createRadiologyOrderCriteria ( ) ; addRestrictionOnPatient ( radiologyOrderCriteria , patient ) ; final List < RadiologyOrder > result = ( List < RadiologyOrder > ) radiologyOrderCriteria . list ( ) ; return result == null ? new ArrayList < RadiologyOrder > ( ) : result ; }

sample: 308
buggy_code: public Weld addExtensions(Class<? extends Extension>... extensionClasses) { <START> Object[] constructorParams = new Object[] {}; <END> for (Class<? extends Extension> extensionClass : extensionClasses) { try { Extension extension = SecurityActions.newInstance(extensionClass); addExtension(extension); } catch (Exception ex) { CommonLogger.LOG.unableToInstantiate(extensionClass, constructorParams, ex); } } return this; }
code_review: This variable is useless in most cases. I would rather pass `new Object[] {}` to log method directly.
target code: public Weld addExtensions ( Class < ? extends Extension > . . . extensionClasses ) { for ( Class < ? extends Extension > extensionClass : extensionClasses ) { try { Extension extension = SecurityActions . newInstance ( extensionClass ) ; addExtension ( extension ) ; } catch ( Exception ex ) { CommonLogger . LOG . unableToInstantiate ( extensionClass , new Object [ ] { } , ex ) ; } } return this ; }
response: public Weld addExtensions ( Class < ? extends Extension > . . . extensionClasses ) { for ( Class < ? extends Extension > extensionClass : extensionClasses ) { try { Extension extension = SecurityActions . newInstance ( extensionClass ) ; addExtension ( extension ) ; } catch ( Exception ex ) { CommonLogger . LOG . unableToInstantiate ( extensionClass , new Object [ ] { } , ex ) ; } } return this ; }

sample: 309
buggy_code: public RTTestsParser() { super(Messages._Warnings_RTTests_ParserName(), Messages._Warnings_RTTests_LinkName(), Messages._Warnings_RTTests_TrendName(), <START> CYCLICTEST_WARNING_PATTERN, true); <END> }
code_review: If the last parameter is `true` then you need to overwrite `isLineInteresting`.
target code: public RTTestsParser ( ) { super ( Messages . _Warnings_RTTests_ParserName ( ) , Messages . _Warnings_RTTests_LinkName ( ) , Messages . _Warnings_RTTests_TrendName ( ) , CYCLICTEST_WARNING_PATTERN ) ; }
response: public RTTestsParser ( ) { super ( Messages . _Warnings_RTTests_ParserName ( ) , Messages . _Warnings_RTTests_LinkName ( ) , Messages . _Warnings_RTTests_TrendName ( ) , CYCLICTEST_WARNING_PATTERN , true ) ; if ( isLineInteresting ( ) ) { setIgnoreLines ( 1 ) ; } } @Override protected boolean isLineInteresting ( ) { return true ; }

sample: 310
buggy_code: private ValidationResult hostExists() { <START> if (getVds() == null) { <END> return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST); } return ValidationResult.VALID; }
code_review: You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
target code: private ValidationResult hostExists ( ) { return getVds ( ) == null ? new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_HOST_NOT_EXIST ) : ValidationResult . VALID ; }
response: private ValidationResult hostExists ( ) { return getVds ( ) == null ? new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_HOST_NOT_EXIST ) : ValidationResult . VALID ; }

sample: 311
buggy_code: public static ToolTipString fromString(String text) { <START> Objects.requireNonNull(text, "fromString cannot take null"); //$NON-NLS-1$ <END> return new ToolTipString(text, toHtmlString(text)); }
code_review: You can remove all the requireNonNull due to @NNBD. I'm surprised we're allowed to use it, doing an explicit null check would be a compilation error...
target code: public static ToolTipString fromString ( String text ) { return new ToolTipString ( text , toHtmlString ( text ) ) ; }
response: public static ToolTipString fromString ( String text ) { return new ToolTipString ( text , toHtmlString ( text ) ) ; }

sample: 312
buggy_code: public DataRadioStation getNextById(String id) { <START> if (listStations.size() == 0) <END> return null; for (int i = 0; i < listStations.size() - 1; i++) { if (listStations.get(i).ID.equals(id)) { return listStations.get(i + 1); } } return listStations.get(0); }
code_review: `if (listStations.isEmpty())`
target code: public DataRadioStation getNextById ( String id ) { if ( listStations . isEmpty ( ) ) return null ; for ( int i = 0 ; i < listStations . size ( ) - 1 ; i ++ ) { if ( listStations . get ( i ) . ID . equals ( id ) ) { return listStations . get ( i + 1 ) ; } } return listStations . get ( 0 ) ; }
response: public DataRadioStation getNextById ( String id ) { if ( listStations . isEmpty ( ) ) { return null ; } for ( int i = 0 ; i < listStations . size ( ) - 1 ; i ++ ) { if ( listStations . get ( i ) . ID . equals ( id ) ) { return listStations . get ( i + 1 ) ; } } return listStations . get ( 0 ) ; }

sample: 313
buggy_code: public static void setBiomeArrayMethod(boolean jeidPresent) { try { if (jeidPresent) { biomeArrayMethod = Chunk.class.getMethod("getIntBiomeArray"); } else <START> biomeArrayMethod = Chunk.class.getMethod("getBiomeArray"); <END> } catch (NoSuchMethodException e) { throw new RuntimeException(e); } }
code_review: Please add the `{}` for the one-liner
target code: public static void setBiomeArrayMethod ( boolean jeidPresent ) { try { if ( jeidPresent ) { biomeArrayMethod = Chunk . class . getMethod ( "getIntBiomeArray" ) ; } else { biomeArrayMethod = Chunk . class . getMethod ( "getBiomeArray" ) ; } } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } }
response: public static void setBiomeArrayMethod ( boolean jeidPresent ) { try { if ( jeidPresent ) { biomeArrayMethod = Chunk . class . getMethod ( "getIntBiomeArray" ) ; } else { biomeArrayMethod = Chunk . class . getMethod ( "getBiomeArray" ) ; } } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } }

sample: 314
buggy_code: public String getDescription() { return "Transform files representing a structured table under an Alluxio directory." + "\n\n" + "Files are coalesced and converted to parquet format." + "\n\n" + "Definition is in format like 'write(hive).option(hive.num.files, 100)'," + "currently, the only modification you can do to the example definition is " <START> + "the number of files in the option." <END> }
code_review: I think since this will change in future release, it's better to let it be here so it's easier to update.
target code: public String getDescription ( ) { return "Transform files representing a structured table under an Alluxio directory . " + "\n\n" + "Files are coalesced and converted to parquet format . " + "\n\n" + "Definition is in format like 'write ( hive ) . option ( hive . num . files , 100 ) ' , " + "currently , the only modification you can do to the example definition is " + "the number of files in the option . " ; }
response: public String getDescription ( ) { return "Transform files representing a structured table under an Alluxio directory . \n\n" + "Files are coalesced and converted to parquet format . \n\n" + "Definition is in format like 'write ( hive ) . option ( hive . num . files , 100 ) ' , " + "currently , the only modification you can do to the example definition is " + "the number of files in the option . " ; }

sample: 315
buggy_code: <START> public static void validateNonNegative(int[] data, String paramName){ <END> boolean nonnegative = true; for(int value : data){ if(value < 0) { nonnegative = false; } } Preconditions.checkArgument(nonnegative, "Values for %s must be >= 0, got: %s", paramName, data); }
code_review: Handling of nulls? You have some in the later methods, but not here... If null is acceptable, we should return null here. If not, let's either add a lombok ```@NonNull``` or a ```Preconditions.checkNotNull(```. At present, nulls will give a non-useful NPE.
target code: public static void validateNonNegative ( int [ ] data , String paramName ) { if ( data == null ) { return ; } boolean nonnegative = true ; for ( int value : data ) { if ( value < 0 ) { nonnegative = false ; } } Preconditions . checkArgument ( nonnegative , "Values for % s must be >= 0 , got : % s" , paramName , data ) ; }
response: < START > public static int [ ] validateNonNegative ( int [ ] data , String paramName ) { Preconditions . checkNotNull ( data , "Data cannot be null" ) ; boolean nonnegative = true ; for ( int value : data ) { if ( value < 0 ) { nonnegative = false ; break ; } } Preconditions . checkArgument ( nonnegative , "Values for % s must be >= 0 , got : % s" , paramName , data ) ; return data ; } < END > Note : I assumed that the method should return the same array that was passed as an argument . If that's not the case , the return type can be changed accordingly .

sample: 316
buggy_code: <START> public SetContentTypeFilter() { <END> try { mimetypeToExtensionMap = new Properties(); mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream( "mimetypeToExtension.txt"))); contentTypeProperties = new Properties(); contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream( "toContentType.properties"))); } catch (IOException e) { log.error("Failed to load mimetype mappings", e); } }
code_review: Looking at this (and i realize this is my own crappy code), its really a configuration error for the files to fail to load, and we really don't want to be eating that and just putting something in the log. Could you either remove the try block and make this constructor throw the IOException, or rethrow an exception with a little extra context? Up to you which you prefer.
target code: public SetContentTypeFilter ( ) throws IOException { mimetypeToExtensionMap = new Properties ( ) ; mimetypeToExtensionMap . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "mimetypeToExtension . txt" ) ) ) ; contentTypeProperties = new Properties ( ) ; contentTypeProperties . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "toContentType . properties" ) ) ) ; }
response: public SetContentTypeFilter ( ) throws IOException { mimetypeToExtensionMap = new Properties ( ) ; mimetypeToExtensionMap . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "mimetypeToExtension . txt" ) ) ) ; contentTypeProperties = new Properties ( ) ; contentTypeProperties . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "toContentType . properties" ) ) ) ; } catch ( IOException e ) { throw new IOException ( "Failed to load mimetype mappings" , e ) ; }

sample: 317
buggy_code: private SwiftApi api(String authUrl, Properties overrides) throws IOException { if (overrides == null){ overrides = new Properties(); <START> } <END> overrides.setProperty(CREDENTIAL_TYPE, "tempAuthCredentials"); return ContextBuilder.newBuilder(new SwiftApiMetadata()) .credentials("user", "password") .endpoint(authUrl) .overrides(overrides) .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor()))) .buildApi(SwiftApi.class); }
code_review: Instead of passing null, remove this check and call this method with a new Properties object.
target code: private SwiftApi api ( String authUrl , Properties overrides ) throws IOException { overrides . setProperty ( CREDENTIAL_TYPE , "tempAuthCredentials" ) ; return ContextBuilder . newBuilder ( new SwiftApiMetadata ( ) ) . credentials ( "user" , "password" ) . endpoint ( authUrl ) . overrides ( overrides ) . modules ( ImmutableSet . of ( new ExecutorServiceModule ( sameThreadExecutor ( ) ) ) ) . buildApi ( SwiftApi . class ) ; }
response: private SwiftApi api ( String authUrl , Properties overrides ) throws IOException { overrides = new Properties ( ) ; overrides . setProperty ( CREDENTIAL_TYPE , "tempAuthCredentials" ) ; return ContextBuilder . newBuilder ( new SwiftApiMetadata ( ) ) . credentials ( "user" , "password" ) . endpoint ( authUrl ) . overrides ( overrides ) . modules ( ImmutableSet . of ( new ExecutorServiceModule ( sameThreadExecutor ( ) ) ) ) . buildApi ( SwiftApi . class ) ; }

sample: 318
buggy_code: public void setAcceptableValues(Collection<K> values) { buttons.clear(); panels.clear(); wrapperPanel.clear(); <START> for (final K value : values) { <END> addValue(value); } updateButtons(); }
code_review: add null check
target code: public void setAcceptableValues ( Collection < K > values ) { buttons . clear ( ) ; panels . clear ( ) ; wrapperPanel . clear ( ) ; if ( values != null ) { for ( final K value : values ) { addValue ( value ) ; } } updateButtons ( ) ; }
response: public void setAcceptableValues ( Collection < K > values ) { if ( values == null ) { throw new IllegalArgumentException ( "Values cannot be null" ) ; } buttons . clear ( ) ; panels . clear ( ) ; wrapperPanel . clear ( ) ; for ( final K value : values ) { addValue ( value ) ; } updateButtons ( ) ; }

sample: 319
buggy_code: public Bucket getOrCreateBucket(String bucketName) { try { Bucket bucket = storage.get(bucketName); if (bucket == null) { log.debug(String.format("Creating a new bucket %s", bucketName)); return storage.create(BucketInfo.of(bucketName)); } return bucket; } catch (StorageException e) { <START> throw new NuxeoException(e); <END> } }
code_review: `StorageException` is a runtime exception, no need to catch and rethrow it (several occurrences).
target code: public Bucket getOrCreateBucket ( String bucketName ) { Bucket bucket = storage . get ( bucketName ) ; if ( bucket == null ) { log . debug ( String . format ( "Creating a new bucket % s" , bucketName ) ) ; return storage . create ( BucketInfo . of ( bucketName ) ) ; } return bucket ; }
response: public Bucket getOrCreateBucket ( String bucketName ) { Bucket bucket = storage . get ( bucketName ) ; if ( bucket == null ) { log . debug ( String . format ( "Creating a new bucket % s" , bucketName ) ) ; return storage . create ( BucketInfo . of ( bucketName ) ) ; } return bucket ; }  Explanation : Since `StorageException` is a runtime exception , there is no need to catch and rethrow it . The refactored code removes the try - catch block and directly returns the `Bucket` object if it exists , or creates a new one if it doesn't .

sample: 320
buggy_code: private void onFragmentLoaded() { if (searchAdapter == null) { searchAdapter = new SearchlistAdapter(getActivity(), itemAccess); setListAdapter(searchAdapter); } searchAdapter.notifyDataSetChanged(); setListShown(true); String query = getArguments().getString(ARG_QUERY); <START> setEmptyText(getString(R.string.no_results_for_query) + " \"" + query + "\""); <END> }
code_review: You need to keep in mind that the sentence construction in other languages could be different, so the query string doesn't always show at the end. You should use %1$s in your string on values/strings.xml and pass the query term as an extra argument to getString()
target code: private void onFragmentLoaded ( ) { if ( searchAdapter == null ) { searchAdapter = new SearchlistAdapter ( getActivity ( ) , itemAccess ) ; setListAdapter ( searchAdapter ) ; } searchAdapter . notifyDataSetChanged ( ) ; setListShown ( true ) ; String query = getArguments ( ) . getString ( ARG_QUERY ) ; setEmptyText ( getString ( R . string . no_results_for_query , query ) ) ; }
response: private void onFragmentLoaded ( ) { if ( searchAdapter == null ) { searchAdapter = new SearchlistAdapter ( getActivity ( ) , itemAccess ) ; setListAdapter ( searchAdapter ) ; } searchAdapter . notifyDataSetChanged ( ) ; setListShown ( true ) ; String query = getArguments ( ) . getString ( ARG_QUERY ) ; setEmptyText ( getString ( R . string . no_results_for_query , query ) ) ; }

sample: 321
buggy_code: private Iterable<Ref> getSortedRefs() throws Exception { List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL); <START> if (all instanceof RefMap <END> || (all instanceof SortedMap && ((SortedMap) all).comparator() == null)) { return all; } return RefComparator.sort(all); }
code_review: Thanks. Marking resolved.
target code: private Iterable < Ref > getSortedRefs ( ) throws Exception { List < Ref > all = db . getRefDatabase ( ) . getRefsByPrefix ( ALL ) ; // TODO ( jrn ) check if we can reintroduce fast - path by e . g . implementing // SortedList return RefComparator . sort ( all ) ; }
response: private Iterable < Ref > getSortedRefs ( ) throws Exception { List < Ref > all = db . getRefDatabase ( ) . getRefsByPrefix ( ALL ) ; if ( all instanceof RefMap || ( all instanceof SortedMap && ( ( SortedMap ) all ) . comparator ( ) == null ) ) { return all ; } return RefComparator . sort ( all ) ; }

sample: 322
buggy_code: private static void convertAAAProfilesResult(AsyncQuery aQuery) { aQuery.converterCallback = new IAsyncConverter() { @Override public Object Convert(Object source, AsyncQuery _asyncQuery) { List<String> results = new ArrayList<String>(); <START> for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source) <END> : new ArrayList<ProfileEntry>()) { results.add(profileEntry.getProfile()); } return results; } }; }
code_review: I don't understand why you need to create a new ArrayList for a collection that is coming from a query - it is necessarily not being used by anyone else. Also, why cast what's coming from the backend to an ArrayList? This means you're committing to a specific implementation. I think a cast to Collection is more appropriate. If it's important for you to have the end result in specifically an ArrayList (and not any other kind of collection), then I would create a new ArrayList, but still cast the result from the backend to Collection.
target code: private static void convertAAAProfilesResult ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { List < String > results = new ArrayList < String > ( ) ; for ( ProfileEntry profileEntry : source != null ? ( Collection < ProfileEntry > ) source : new ArrayList < ProfileEntry > ( ) ) { results . add ( profileEntry . getProfile ( ) ) ; } return results ; } } ; }
response: private static void convertAAAProfilesResult ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { List < String > results = new ArrayList < String > ( ) ; for ( ProfileEntry profileEntry : source != null ? new ArrayList < ProfileEntry > ( ( Collection < ProfileEntry > ) source ) : new ArrayList < ProfileEntry > ( ) ) { results . add ( profileEntry . getProfile ( ) ) ; } return results ; } } ; }

sample: 323
buggy_code: <START> public FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier, <END> final CellEditorControlsView.Presenter cellEditorControls, final KindPopoverView.Presenter editor, final Optional<String> editorTitle, final FunctionGrid gridWidget) { super(cellEditorControls, editor, editorTitle); this.functionSupplier = functionSupplier; this.gridWidget = gridWidget; }
code_review: Since the `class` has _package_ protected access the constructor can probably have _package_ protection too?
target code: FunctionKindRowColumnHeaderMetaData ( final Supplier < FunctionDefinition > functionSupplier , final CellEditorControlsView . Presenter cellEditorControls , final KindPopoverView . Presenter editor , final Optional < String > editorTitle , final FunctionGrid gridWidget ) { super ( cellEditorControls , editor , editorTitle ) ; this . functionSupplier = functionSupplier ; this . gridWidget = gridWidget ; }
response: < START > FunctionKindRowColumnHeaderMetaData ( final Supplier < FunctionDefinition > functionSupplier , final CellEditorControlsView . Presenter cellEditorControls , final KindPopoverView . Presenter editor , final Optional < String > editorTitle , final FunctionGrid gridWidget ) { super ( cellEditorControls , editor , editorTitle ) ; this . functionSupplier = functionSupplier ; this . gridWidget = gridWidget ; }

sample: 324
buggy_code: public List<ProxiedPlayer> matchPlayer(String partialName) { List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>(); for (ProxiedPlayer iPlayer : this.getPlayers()) { String iterPlayerName = iPlayer.getName(); if (partialName.equalsIgnoreCase(iterPlayerName)) { matched.add(iPlayer); break; } <START> if (iterPlayerName.toLowerCase().contains(partialName.toLowerCase())) { <END> matched.add(iPlayer); } } return matched; }
code_review: Wouldn't starts with make more sense?
target code: public List < ProxiedPlayer > matchPlayer ( String partialName ) { List < ProxiedPlayer > matched = new ArrayList < ProxiedPlayer > ( ) ; for ( ProxiedPlayer iPlayer : this . getPlayers ( ) ) { String iterPlayerName = iPlayer . getName ( ) ; if ( partialName . equalsIgnoreCase ( iterPlayerName ) ) { matched . add ( iPlayer ) ; break ; } if ( iterPlayerName . toLowerCase ( ) . startsWith ( partialName . toLowerCase ( ) ) ) { matched . add ( iPlayer ) ; } } return matched ; }
response: public List < ProxiedPlayer > matchPlayer ( String partialName ) { List < ProxiedPlayer > matched = new ArrayList < ProxiedPlayer > ( ) ; for ( ProxiedPlayer iPlayer : this . getPlayers ( ) ) { String iterPlayerName = iPlayer . getName ( ) ; if ( iterPlayerName . toLowerCase ( ) . startsWith ( partialName . toLowerCase ( ) ) ) { matched . add ( iPlayer ) ; } } return matched ; }

sample: 325
buggy_code: private int zigzagDecode(int input) { <START> return (input >> 1) ^ (-(input & 1)); <END> }
code_review: I notice in the unzigzag method below, you use the unsigned right shift operator (`>>>`), but here you're using the signed one (`>>`). Is that intentional?
target code: private int zigzagDecode ( int input ) { return ( input > > > 1 ) ^ ( - ( input & 1 ) ) ; }
response: private int zigzagDecode ( int input ) { return ( input > > > 1 ) ^ ( - ( input & 1 ) ) ; }

sample: 326
buggy_code: <START> public void testEqualsCondition() { doTest(GoStringIndexIsByteQuickFix.NAME); } <END>
code_review: Please create method`doTest() { doTest(GoStringIndexIsByteQuickFix.NAME); }` and maybe same method `doTestNoFix()`
target code: public void testEqualsCondition ( ) { doTest ( ) ; }
response: public void testEqualsCondition ( ) { doTest ( GoStringIndexIsByteQuickFix . NAME ) ; } private void doTest ( String name ) { // test code here } private void doTestNoFix ( ) { // test code here without applying any fix }

sample: 327
buggy_code: public void testRedrawAfterDispose() { LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn(); CompositeRuler ruler= new CompositeRuler(); ruler.addDecorator(0, lineNumberRulerColumn); SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE); lineNumberRulerColumn.getControl().setSize(10, 10); sourceViewer.getTextWidget().dispose(); try { lineNumberRulerColumn.redraw(); } <START> catch (Exception <END> notExpected) { notExpected.printStackTrace(); fail(); } }
code_review: why do we need try/catch here? It should not fail, and if it fails, junit will take care about the stack etc
target code: public void testRedrawAfterDispose ( ) { LineNumberRulerColumn lineNumberRulerColumn = new LineNumberRulerColumn ( ) ; CompositeRuler ruler = new CompositeRuler ( ) ; ruler . addDecorator ( 0 , lineNumberRulerColumn ) ; SourceViewer sourceViewer = new SourceViewer ( fParent , ruler , SWT . NONE ) ; lineNumberRulerColumn . getControl ( ) . setSize ( 10 , 10 ) ; sourceViewer . getTextWidget ( ) . dispose ( ) ; lineNumberRulerColumn . redraw ( ) ; }
response: public void testRedrawAfterDispose ( ) { LineNumberRulerColumn lineNumberRulerColumn = new LineNumberRulerColumn ( ) ; CompositeRuler ruler = new CompositeRuler ( ) ; ruler . addDecorator ( 0 , lineNumberRulerColumn ) ; SourceViewer sourceViewer = new SourceViewer ( fParent , ruler , SWT . NONE ) ; lineNumberRulerColumn . getControl ( ) . setSize ( 10 , 10 ) ; sourceViewer . getTextWidget ( ) . dispose ( ) ; lineNumberRulerColumn . redraw ( ) ; }

sample: 328
buggy_code: public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) { if (!_canBridgeFirewall) { return false; } <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("default_network_rules_systemvm"); cmd.add("--vmname", vmName); cmd.add("--localbrname", _linkLocalBridgeName); final String result = cmd.execute(); if (result != null) { return false; } return true; }
code_review: Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion.
target code: public boolean configureDefaultNetworkRulesForSystemVm ( final Connect conn , final String vmName ) { if ( ! _canBridgeFirewall ) { return false ; } final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "default_network_rules_systemvm" ) ; cmd . add ( " -- vmname" , vmName ) ; cmd . add ( " -- localbrname" , _linkLocalBridgeName ) ; final String result = cmd . execute ( ) ; if ( result != null ) { return false ; } return true ; }
response: public boolean configureDefaultNetworkRulesForSystemVm ( final Connect conn , final String vmName ) { if ( ! _canBridgeFirewall ) { return false ; } final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "default_network_rules_systemvm" ) ; cmd . add ( " -- vmname" , vmName ) ; cmd . add ( " -- localbrname" , _linkLocalBridgeName ) ; final String result = cmd . execute ( ) ; return result == null ; }

sample: 329
buggy_code: public void testQueryCumulativeTable() { computeActual("SELECT * FROM \"*:*\""); computeActual("SELECT * FROM \"java.util.logging:*\""); <START> assertTrue(computeActual("SELECT * FROM \"java.lang:*\"").getRowCount() > 0); <END> assertTrue(computeActual("SELECT * FROM \"jAVA.LANg:*\"").getRowCount() > 0); }
code_review: shouldn't it be `> 1`
target code: public void testQueryCumulativeTable ( ) { computeActual ( "SELECT * FROM \" * :* \"" ) ; computeActual ( "SELECT * FROM \"java . util . logging :* \"" ) ; assertTrue ( computeActual ( "SELECT * FROM \"java . lang :* \"" ) . getRowCount ( ) > 1 ) ; assertTrue ( computeActual ( "SELECT * FROM \"jAVA . LANg :* \"" ) . getRowCount ( ) > 1 ) ; }
response: public void testQueryCumulativeTable ( ) { computeActual ( "SELECT * FROM \" * :* \"" ) ; computeActual ( "SELECT * FROM \"java . util . logging :* \"" ) ; assertTrue ( computeActual ( "SELECT * FROM \"java . lang :* \"" ) . getRowCount ( ) > 1 ) ; assertTrue ( computeActual ( "SELECT * FROM \"jAVA . LANg :* \"" ) . getRowCount ( ) > 1 ) ; }

sample: 330
buggy_code: public RequestLogger get() { LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC); <START> log.info(new Exception("Stack trace"), "Creating %s at", logger); <END> return logger; }
code_review: should these be `debug` level?
target code: public RequestLogger get ( ) { LoggingRequestLogger logger = new LoggingRequestLogger ( mapper , setMDC , setContextMDC ) ; log . debug ( new Exception ( "Stack trace" ) , "Creating % s at" , logger ) ; return logger ; }
response: public RequestLogger get ( ) { LoggingRequestLogger logger = new LoggingRequestLogger ( mapper , setMDC , setContextMDC ) ; log . debug ( new Exception ( "Stack trace" ) , "Creating % s at" , logger ) ; return logger ; }

sample: 331
buggy_code: private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) { String accessRecord = leak.toString(); if (StringUtil.isNullOrEmpty(accessRecord)) { // means leak has been closed and there is no accessRecord. return e; } <START> return new TrackedIllegalReferenceCountException(e.getMessage(), accessRecord); <END> }
code_review: shouldn't we wrap the original `e` ?
target code: private IllegalReferenceCountException handleIllegalReferenceCountException ( IllegalReferenceCountException e ) { String accessRecord = leak . toString ( ) ; if ( StringUtil . isNullOrEmpty ( accessRecord ) ) { // means leak has been closed and there is no accessRecord . return e ; } return new TrackedIllegalReferenceCountException ( accessRecord , e ) ; }
response: private IllegalReferenceCountException handleIllegalReferenceCountException ( IllegalReferenceCountException e ) { String accessRecord = leak . toString ( ) ; if ( StringUtil . isNullOrEmpty ( accessRecord ) ) { // means leak has been closed and there is no accessRecord . return e ; } return new TrackedIllegalReferenceCountException ( e , accessRecord ) ; }

sample: 332
buggy_code: public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getAccountPayments(accountId, withPluginInfo, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext)); <END> }
code_review: The new flag `withAttempts` is not passed (used) the `paymentProcessor#getAccountPayments`
target code: public List < Payment > getAccountPayments ( final UUID accountId , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getAccountPayments ( accountId , withPluginInfo , withAttempts , tenantContext , internalCallContextFactory . createInternalTenantContext ( accountId , tenantContext ) ) ; }
response: public List < Payment > getAccountPayments ( final UUID accountId , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getAccountPayments ( accountId , withPluginInfo , withAttempts , tenantContext , internalCallContextFactory . createInternalTenantContext ( accountId , tenantContext ) ) ; }

sample: 333
buggy_code: public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER); disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString()); retentionManager = Framework.getService(RetentionManager.class); <START> ruleId = (String) command.getParam(PARAM_RULE_ID); <END> }
code_review: No need to cast to `String`, here `getParam` is a generic method `public <T> T getParam(String key)`
target code: public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; Serializable auditParam = command . getParam ( NXAuditEventsService . DISABLE_AUDIT_LOGGER ) ; disableAudit = auditParam != null && Boolean . parseBoolean ( auditParam . toString ( ) ) ; retentionManager = Framework . getService ( RetentionManager . class ) ; ruleId = command . getParam ( PARAM_RULE_ID ) ; }
response: public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; Serializable auditParam = command . getParam ( NXAuditEventsService . DISABLE_AUDIT_LOGGER ) ; disableAudit = auditParam != null && Boolean . parseBoolean ( auditParam . toString ( ) ) ; retentionManager = Framework . getService ( RetentionManager . class ) ; ruleId = command . getParam ( PARAM_RULE_ID ) ; }

sample: 334
buggy_code: public boolean remove(Connection connection) { boolean removed = connectionPool.remove(connection); if (getHttpExchanges().isEmpty()) { tryRemoveIdleDestination(); } else { // We need to execute queued requests // even if this connection was removed. // We may create a connection that is not // needed, but it will eventually idle timeout. if (removed) <START> process(true); <END> } return connectionPool.remove(connection); }
code_review: should this check that the queue is not 0? Why acquire a connection if there are no waiting exchanges?
target code: public boolean remove ( Connection connection ) { boolean removed = connectionPool . remove ( connection ) ; if ( getHttpExchanges ( ) . isEmpty ( ) ) { tryRemoveIdleDestination ( ) ; } else if ( removed ) { // Process queued requests that may be waiting . // We may create a connection that is not // needed , but it will eventually idle timeout . process ( true ) ; } return removed ; }
response: public boolean remove ( Connection connection ) { boolean removed = connectionPool . remove ( connection ) ; if ( getHttpExchanges ( ) . isEmpty ( ) ) { tryRemoveIdleDestination ( ) ; } else if ( removed ) { process ( true ) ; } return connectionPool . remove ( connection ) ; }

sample: 335
buggy_code: public boolean getRewriteBatchedStatements() { final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS); <START> return isRewrite == null ? null : Boolean.valueOf(isRewrite); <END> }
code_review: return null ? I think you meant 'false', did not you?
target code: public boolean getRewriteBatchedStatements ( ) { final String isRewrite = super . connectionProperties . getProperty ( REWRITE_BATCHED_STATEMENTS ) ; return isRewrite == null ? false : Boolean . valueOf ( isRewrite ) ; }
response: public boolean getRewriteBatchedStatements ( ) { final String isRewrite = super . connectionProperties . getProperty ( REWRITE_BATCHED_STATEMENTS ) ; return isRewrite == null ? false : Boolean . valueOf ( isRewrite ) ; }

sample: 336
buggy_code: public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon)); scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); <START> scheduler.setRemoveOnCancelPolicy(true); <END> return scheduler; }
code_review: I am little wary about this. coz, all our existing schedulers are using this and setting this might cause them to be removed immediately. Even though ideally we want to be in that position, when rolling this out, don't want to have any unexpected behaviors.
target code: public static ScheduledExecutorService newScheduler ( int numThreads , String threadNamePrefix , boolean isDaemon ) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor ( numThreads , new SchedulerThreadFactory ( threadNamePrefix , isDaemon ) ) ; scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; return scheduler ; }
response: public static ScheduledExecutorService newScheduler ( int numThreads , String threadNamePrefix , boolean isDaemon ) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor ( numThreads , new SchedulerThreadFactory ( threadNamePrefix , isDaemon ) ) ; scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; scheduler . setRemoveOnCancelPolicy ( false ) ; // Updated based on review return scheduler ; }

sample: 337
buggy_code: public boolean setValue(T newValue) { if (!validator.validate(newValue)) { <START> LOGGER.warn("The passed value {} is invalid.", newValue); <END> return false; } PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue); this.value = newValue; dispatchChangedEvent(event); return true; }
code_review: Ah, that's what you meant. =) No, this isn't good: it's too generic, it wouldn't help you debug a failure. The validator itself has to log a warning and then return false, so that the warning can be very specific on what went wrong, i.e. the new value being beyond the maximum value allowed.
target code: public boolean setValue ( T newValue ) { if ( ! validate ( newValue ) ) { return false ; } PropertyChangeEvent event = new PropertyChangeEvent ( this , id . toString ( ) , this . value , newValue ) ; this . value = newValue ; dispatchChangedEvent ( event ) ; return true ; }
response: public boolean setValue ( T newValue ) { if ( ! validator . validate ( newValue ) ) { LOGGER . warn ( "The passed value { } is invalid : it is beyond the maximum value allowed . " , newValue ) ; return false ; } PropertyChangeEvent event = new PropertyChangeEvent ( this , id . toString ( ) , this . value , newValue ) ; this . value = newValue ; dispatchChangedEvent ( event ) ; return true ; }

sample: 338
buggy_code: public void onMessage(MessageHolderWithTokens message) { try { <START> logger.debug("receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"); <END> dequeueEvent.fire(message); } catch (DispatchInitiationException e) { throw e; } catch (Exception e) { logger.error("NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered", e); } }
code_review: Do we really want to move this from `trace` to `debug`?
target code: public void onMessage ( MessageHolderWithTokens message ) { try { logger . trace ( "receiving tokens from queue , triggering Notification Dispatcher class to pick the right sender" ) ; dequeueEvent . fire ( message ) ; } catch ( DispatchInitiationException e ) { throw e ; } catch ( Exception e ) { logger . error ( "NotificationDispatcher or PushNotificationSender unexpectedly failed , the message won't be redelivered" , e ) ; } }
response: public void onMessage ( MessageHolderWithTokens message ) { try { logger . trace ( "receiving tokens from queue , triggering Notification Dispatcher class to pick the right sender" ) ; dequeueEvent . fire ( message ) ; } catch ( DispatchInitiationException e ) { throw e ; } catch ( Exception e ) { logger . error ( "NotificationDispatcher or PushNotificationSender unexpectedly failed , the message won't be redelivered" , e ) ; } }  Changes Made : - Changed the log level from `debug` to `trace` based on the review comment .

sample: 339
buggy_code: private Collection<Key> getRegisteredKeys() { List<Key> result = new ArrayList<Key>(); <START> for (Iterator<Key> i = cacheMap.keySet().iterator(); i.hasNext();) { result.add(i.next()); } return result; <END> }
code_review: why not: return result.addAll(cacheMap.keySet());
target code: private Collection < Key > getRegisteredKeys ( ) { return new ArrayList < Key > ( cacheMap . keySet ( ) ) ; }
response: private Collection < Key > getRegisteredKeys ( ) { List < Key > result = new ArrayList < Key > ( ) ; result . addAll ( cacheMap . keySet ( ) ) ; return result ; }

sample: 340
buggy_code: <START> public AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) { <END> name = metricName; type = metricType; value = initialValue; metricManager = manager; }
code_review: I would make this constructor `protected` because you cannot directly instantiate abstract classes. See the answers to http://stackoverflow.com/questions/260666/can-an-abstract-class-have-a-constructor for a discussion.
target code: protected AbstractMetric ( String metricName , String metricType , T initialValue , MetricReportManager manager ) { name = metricName ; type = metricType ; value = initialValue ; metricManager = manager ; }
response: protected AbstractMetric ( String metricName , String metricType , T initialValue , MetricReportManager manager ) { name = metricName ; type = metricType ; value = initialValue ; metricManager = manager ; }

sample: 341
buggy_code: public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() { Allergy allergy = allergy(); <START> allergy.hasSameValues(allergy()); <END> }
code_review: Shouldn't this line be something like AssertTrue(allergy.hasSameValues(allergy())); ?
target code: public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues ( ) { Allergy allergy = allergy ( ) ; assertThat ( allergy . hasSameValues ( allergy ( ) ) , is ( true ) ) ; }
response: public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues ( ) { Allergy allergy = allergy ( ) ; assertTrue ( allergy . hasSameValues ( allergy ( ) ) ) ; }

sample: 342
buggy_code: private static String readMapping() throws IOException, ParseException { JSONParser parser = new JSONParser(); ClassLoader classloader = Thread.currentThread().getContextClassLoader(); <START> InputStream inputStream = classloader.getResourceAsStream("mapping.json"); <END> String mapping = IOUtils.toString(inputStream, "UTF-8"); Object object = parser.parse(mapping); JSONObject jsonObject = (JSONObject) object; return jsonObject.toJSONString(); }
code_review: You are open a stream object without closing it never. Maybe you can use the try-with-resources statement here and avoid / handle the unhandled IOException here.
target code: private static String readMapping ( ) throws ParseException { JSONParser parser = new JSONParser ( ) ; ClassLoader classloader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try ( InputStream inputStream = classloader . getResourceAsStream ( "mapping . json" ) ) { String mapping = IOUtils . toString ( inputStream , "UTF - 8" ) ; Object object = parser . parse ( mapping ) ; JSONObject jsonObject = ( JSONObject ) object ; return jsonObject . toJSONString ( ) ; } catch ( IOException e ) { logger . error ( e ) ; return "" ; } }
response: private static String readMapping ( ) throws IOException , ParseException { JSONParser parser = new JSONParser ( ) ; ClassLoader classloader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try ( InputStream inputStream = classloader . getResourceAsStream ( "mapping . json" ) ) { String mapping = IOUtils . toString ( inputStream , "UTF - 8" ) ; Object object = parser . parse ( mapping ) ; JSONObject jsonObject = ( JSONObject ) object ; return jsonObject . toJSONString ( ) ; } }

sample: 343
buggy_code: public synchronized void commit() throws CommitException { SyncCommitObserver sco = null; try { sco = new SyncCommitObserver(); commitAsync(sco); sco.waitForCommit(); } finally { updates.clear(); weakNotification = null; <START> observedColumns.clear(); <END> columnsRead.clear(); } }
code_review: @mjwall I found the bug. Its my fault, I suggested clearing `observedColumns` and that is a bad thing to do. `observedColumns` is shared between transactions. It should be an immutable set, I'll open an issue for that.
target code: public synchronized void commit ( ) throws CommitException { SyncCommitObserver sco = null ; try { sco = new SyncCommitObserver ( ) ; commitAsync ( sco ) ; sco . waitForCommit ( ) ; } finally { updates . clear ( ) ; weakNotification = null ; columnsRead . clear ( ) ; } }
response: public synchronized void commit ( ) throws CommitException { SyncCommitObserver sco = null ; try { sco = new SyncCommitObserver ( ) ; commitAsync ( sco ) ; sco . waitForCommit ( ) ; } finally { updates . clear ( ) ; weakNotification = null ; observedColumns = ImmutableSet . of ( ) ; // Fix for the bug columnsRead . clear ( ) ; } }

sample: 344
buggy_code: public static boolean hasPictureId(byte[] buf, int off, int len) { if (!isValid(buf, off)) return false; if ((buf[off] & X_BIT) == 0 || (buf[off+1] & I_BIT) == 0) <START> return false; <END> return true; }
code_review: I would simplify to "return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)"
target code: public static boolean hasPictureId ( byte [ ] buf , int off , int len ) { return isValid ( buf , off , len ) && ( buf [ off ] & X_BIT ) != 0 && ( buf [ off + 1 ] & I_BIT ) != 0 ; }
response: public static boolean hasPictureId ( byte [ ] buf , int off , int len ) { return isValid ( buf , off ) && ( buf [ off ] & X_BIT ) != 0 && ( buf [ off + 1 ] & I_BIT ) != 0 ; }

sample: 345
buggy_code: public void setEnabled(boolean enabled) { this.active = enabled; <START> System.out.println("active state change: " + active); <END> updateButtonState(); }
code_review: remove the println
target code: public void setEnabled ( boolean enabled ) { this . active = enabled ; updateButtonState ( ) ; }
response: public void setEnabled ( boolean enabled ) { this . active = enabled ; updateButtonState ( ) ; }

sample: 346
buggy_code: <START> default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) { <END> throw new UnsupportedOperationException("Method is not implemented"); }
code_review: Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
target code: default void beforeDataProviderExecution ( IDataProviderMethod dataProviderMethod , ITestNGMethod method , ITestContext iTestContext ) { // not implemented }
response: < START > default void beforeDataProviderExecution ( IDataProviderMethod dataProviderMethod , ITestNGMethod method , ITestContext iTestContext ) { < END > }

sample: 347
buggy_code: private void handleEndActionJobAndStep() { if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) { <START> if (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep) { <END> startFinalizingStep(); } } }
code_review: the inner 'if' isn't needed - the conditions can be added to the outer 'if'
target code: private void handleEndActionJobAndStep ( ) { if ( ( ! hasTaskHandlers ( ) || getExecutionIndex ( ) == getTaskHandlers ( ) . size ( ) - 1 ) && ( ! parentHasCallback ( ) || getExecutionContext ( ) . getExecutionMethod ( ) == ExecutionMethod . AsStep ) ) { startFinalizingStep ( ) ; } }
response: private void handleEndActionJobAndStep ( ) { if ( ( ! hasTaskHandlers ( ) || getExecutionIndex ( ) == getTaskHandlers ( ) . size ( ) - 1 ) && ( ! parentHasCallback ( ) || getExecutionContext ( ) . getExecutionMethod ( ) == ExecutionMethod . AsStep ) ) { startFinalizingStep ( ) ; } }

sample: 348
buggy_code: private boolean waitForScanState(ScanStates state) { try { <START> while (!getScanState().equals(state)) { <END> scanState.wait(); } return true; } catch (InterruptedException e) { tsLogger.logger.warn("problem waiting for scanLock whilst in state " + state.name(), e); return false; } }
code_review: why did you change the do ... while into a while do loop. The caller already knows the scan state is not equal to state and since this is a private method it is safe to assume that the caller has already checked (under the lock) that he has to wait for a state change.
target code: private boolean waitForScanState ( ScanStates state ) { try { do { scanState . wait ( ) ; } while ( ! getScanState ( ) . equals ( state ) ) ; return true ; } catch ( InterruptedException e ) { tsLogger . logger . warn ( "problem waiting for scanLock whilst in state " + state . name ( ) , e ) ; return false ; } }
response: private boolean waitForScanState ( ScanStates state ) { try { while ( getScanState ( ) != state ) { scanState . wait ( ) ; } return true ; } catch ( InterruptedException e ) { tsLogger . logger . warn ( "problem waiting for scanLock whilst in state " + state . name ( ) , e ) ; return false ; } }

sample: 349
buggy_code: private void maybeScheduleCheckpoint() { switch (state()) { <START> case RESTORING: <END> this.checkpoint = checkpointableOffsets(); break; case RUNNING: if (!eosEnabled) { this.checkpoint = checkpointableOffsets(); } break; case SUSP<END>ED: this.checkpoint = checkpointableOffsets(); break; case CREATED: case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while scheduling checkpoint for active task " + id); default: throw new IllegalStateException("Unknown state " + state() + " while scheduling checkpoint for active task " + id); } }
code_review: Could we merge RESTORING and SUSPENDED?
target code: private void maybeScheduleCheckpoint ( ) { switch ( state ( ) ) { case RESTORING : case SUSPENDED : this . checkpoint = checkpointableOffsets ( ) ; break ; case RUNNING : if ( ! eosEnabled ) { this . checkpoint = checkpointableOffsets ( ) ; } break ; case CREATED : case CLOSED : throw new IllegalStateException ( "Illegal state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; default : throw new IllegalStateException ( "Unknown state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; } }
response: private void maybeScheduleCheckpoint ( ) { switch ( state ( ) ) { case RESTORING : case SUSPENDED : this . checkpoint = checkpointableOffsets ( ) ; break ; case RUNNING : if ( ! eosEnabled ) { this . checkpoint = checkpointableOffsets ( ) ; } break ; case CREATED : case CLOSED : throw new IllegalStateException ( "Illegal state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; default : throw new IllegalStateException ( "Unknown state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; } }  Refactored Review : Merged RESTORING and SUSPENDED cases in the switch statement .

sample: 350
buggy_code: protected void executeQueryCommand() { Provider hostProvider = getProvider(); <START> HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider)); <END> getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); }
code_review: Why do you cast to HostProviderProxy?
target code: protected void executeQueryCommand ( ) { Provider hostProvider = getProvider ( ) ; HostProviderProxy proxy = ProviderProxyFactory . getInstance ( ) . create ( hostProvider ) ; getQueryReturnValue ( ) . setReturnValue ( chainToString ( proxy . getCertificateChain ( ) ) ) ; }
response: protected void executeQueryCommand ( ) { Provider hostProvider = getProvider ( ) ; ProviderProxyFactory factory = ProviderProxyFactory . getInstance ( ) ; HostProviderProxy proxy = factory . create ( hostProvider ) ; getQueryReturnValue ( ) . setReturnValue ( chainToString ( proxy . getCertificateChain ( ) ) ) ; }  Explanation : The code casts to `HostProviderProxy` because it assumes that the `Provider` returned by `getProvider ( ) ` is an instance of `HostProvider` . However , this assumption may not always be true , and the code may throw a `ClassCastException` if the `Provider` is not a `HostProvider` . To avoid this issue , we can use the `ProviderProxyFactory` to create a proxy for the `Provider` , which will ensure that the correct type of proxy is created based on the type of `Provider` . This eliminates the need for the cast to `HostProviderProxy` .

sample: 351
buggy_code: public void t1() { <START> testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName()); <END> }
code_review: We could have leveraged `InvokedMethodListener` for this. See [here](https://github.com/cbeust/testng/blob/master/src/test/java/test/InvokedMethodListener.java)
target code: public void t1 ( ) { }
response: public void t1 ( ) { // code to add test case execution order using InvokedMethodListener InvokedMethodListener listener = new InvokedMethodListener ( ) ; listener . beforeInvocation ( new Object ( ) { } . getClass ( ) . getEnclosingMethod ( ) , null , null ) ; }

sample: 352
buggy_code: public void testValidateDataStreamsNoConflicts() { Metadata metadata = createIndices(5, 10, "foo-datastream").metadata; try { <START> validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE)); <END> } catch (Exception e) { fail("did not expect exception when validating a system without indices that would conflict with future backing indices: " + e.getMessage()); } }
code_review: Currently when the test fails with any error then there is no stacktrace to the original failure, which I think makes pinpointing the culprit easier? That being said, this is just preference, so feel free to ignore :)
target code: public void testValidateDataStreamsNoConflicts ( ) { Metadata metadata = createIndices ( 5 , 10 , "foo - datastream" ) . metadata ; // don't expect any exception when validating a system without indices that would conflict with future backing indices validateDataStreams ( metadata . getIndicesLookup ( ) , ( DataStreamMetadata ) metadata . customs ( ) . get ( DataStreamMetadata . TYPE ) ) ; }
response: public void testValidateDataStreamsNoConflicts ( ) { Metadata metadata = createIndices ( 5 , 10 , "foo - datastream" ) . metadata ; try { validateDataStreams ( metadata . getIndicesLookup ( ) , ( DataStreamMetadata ) metadata . customs ( ) . get ( DataStreamMetadata . TYPE ) ) ; } catch ( Exception e ) { fail ( "did not expect exception when validating a system without indices that would conflict with future backing indices : " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } }

sample: 353
buggy_code: public ShaderProvider getPassShaderProvider (int n) { <START> if (n >= passShaderProviders.length) <END> throw new GdxRuntimeException("ShaderProvider " + n + " doesn't exist in " + getClass().getName()); return passShaderProviders[n]; }
code_review: I dont think that this check is needed here (otherwise it will throw an index out of bounds exception, which says the same). https://github.com/libgdx/libgdx/wiki/Contributing#performance-considerations
target code: public ShaderProvider getPassShaderProvider ( int n ) { return passShaderProviders [ n ] ; }
response: public ShaderProvider getPassShaderProvider ( int n ) { return passShaderProviders [ n ] ; }

sample: 354
buggy_code: public void onConnectionClosedForUser(QBRTCSession qbrtcSession, Integer integer) { setStatusForOpponent(integer, getString(R.string.closed)); <START> stopTimer(); <END> }
code_review: stopTimer() нужно поставить где сессия закрывается вообще, а не для конкретного юзера
target code: public void onConnectionClosedForUser ( QBRTCSession qbrtcSession , Integer integer ) { setStatusForOpponent ( integer , getString ( R . string . closed ) ) ; }
response: public void onConnectionClosedForUser ( QBRTCSession qbrtcSession , Integer integer ) { stopTimer ( ) ; setStatusForOpponent ( integer , getString ( R . string . closed ) ) ; } // где - то в коде должно быть закрытие сессии для всех пользователей

sample: 355
buggy_code: public void install(ITextViewer textViewer) { for (IReconciler iReconciler : fReconcilers) { <START> if(iReconciler != null) { <END> iReconciler.install(textViewer); } } }
code_review: It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here.
target code: public void install ( ITextViewer textViewer ) { for ( IReconciler iReconciler : fReconcilers ) { iReconciler . install ( textViewer ) ; } }
response: public void install ( ITextViewer textViewer ) { List < IReconciler > nonNullReconcilers = new ArrayList < > ( ) ; for ( IReconciler iReconciler : fReconcilers ) { if ( iReconciler != null ) { nonNullReconcilers . add ( iReconciler ) ; } } for ( IReconciler iReconciler : nonNullReconcilers ) { iReconciler . install ( textViewer ) ; } }

sample: 356
buggy_code: public JettyServer run(WebApplicationContext baseContext, boolean directlyUseAsWebAppRoot, Function<Function<Integer, JettyServer>, JettyServer> serverStarter, boolean exitOnError) { try { configureLogger(); configureSentry(baseContext); JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter, <START> v->v.addLifeCycleListener(new JettyLifeCycleListener(baseContext))); <END> jettyServer.start(); logStartupInfo(baseContext); return jettyServer; } catch (Exception e) { return logErrorAndExit(e, exitOnError); } }
code_review: а мы разве можем хоть когда-то не захотеть добавлять listener - я бы это унес прям в основной webAppInitializer
target code: public JettyServer run ( WebApplicationContext baseContext , boolean directlyUseAsWebAppRoot , Function < Function < Integer , JettyServer > , JettyServer > serverStarter , boolean exitOnError ) { try { configureLogger ( ) ; configureSentry ( baseContext ) ; JettyServer jettyServer = createJettyServer ( baseContext , directlyUseAsWebAppRoot , serverStarter ) ; jettyServer . start ( ) ; logStartupInfo ( baseContext ) ; return jettyServer ; } catch ( Exception e ) { return logErrorAndExit ( e , exitOnError ) ; } }
response: public JettyServer run ( WebApplicationContext baseContext , boolean directlyUseAsWebAppRoot , Function < Function < Integer , JettyServer > , JettyServer > serverStarter , boolean exitOnError ) { try { configureLogger ( ) ; configureSentry ( baseContext ) ; JettyServer jettyServer = createJettyServer ( baseContext , directlyUseAsWebAppRoot , serverStarter , v - > { if ( v != null ) { v . addLifeCycleListener ( new JettyLifeCycleListener ( baseContext ) ) ; } } ) ; jettyServer . start ( ) ; logStartupInfo ( baseContext ) ; return jettyServer ; } catch ( Exception e ) { return logErrorAndExit ( e , exitOnError ) ; } }

sample: 357
buggy_code: public PlanItem(String id, String definitionRef) { <START> super(); <END> this.id = id; this.definitionRef = definitionRef; }
code_review: AFAIK this is redundant.
target code: public PlanItem ( String id , String definitionRef ) { this . id = id ; this . definitionRef = definitionRef ; }
response: public PlanItem ( String id , String definitionRef ) { this . id = id ; this . definitionRef = definitionRef ; }

sample: 358
buggy_code: public int hashCode() { <START> return name.hashCode(); <END> }
code_review: Looking on `QName` class, maybe we should use `return ~~name.hashCode()`.
target code: public int hashCode ( ) { return ~~name . hashCode ( ) ; }
response: public int hashCode ( ) { return ~~name . hashCode ( ) ; }

sample: 359
buggy_code: protected boolean copyObject(String src, String dst) { try { <START> LOG.info("Copying {} to {}", src, dst); <END> mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst); return true; } catch (CosClientException e) { LOG.error("Failed to rename file {} to {}", src, dst, e); return false; } }
code_review: `LOG.debug` please to avoid overhead on operations.
target code: protected boolean copyObject ( String src , String dst ) { try { LOG . debug ( "Copying { } to { } " , src , dst ) ; mClient . copyObject ( mBucketNameInternal , src , mBucketNameInternal , dst ) ; return true ; } catch ( CosClientException e ) { LOG . error ( "Failed to rename file { } to { } " , src , dst , e ) ; return false ; } }
response: protected boolean copyObject ( String src , String dst ) { try { LOG . debug ( "Copying { } to { } " , src , dst ) ; mClient . copyObject ( mBucketNameInternal , src , mBucketNameInternal , dst ) ; return true ; } catch ( CosClientException e ) { LOG . error ( "Failed to rename file { } to { } " , src , dst , e ) ; return false ; } }

sample: 360
buggy_code: public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, <START> false); <END> }
code_review: Since the logic switch, this should be true (former behavior).
target code: public RepositorySearchDialog ( Collection < String > existingDirs ) { this ( existingDirs , false , true ) ; }
response: public RepositorySearchDialog ( Collection < String > existingDirs ) { this ( existingDirs , false , true ) ; }

sample: 361
buggy_code: public DelegatingResourceDescription getCreatableProperties() { DelegatingResourceDescription description = super.getCreatableProperties(); <START> description.addProperty("name"); <END> description.addProperty("location"); description.addProperty("description"); return description; }
code_review: Aren't the name and description properties already added by the super class?
target code: public DelegatingResourceDescription getCreatableProperties ( ) { DelegatingResourceDescription description = super . getCreatableProperties ( ) ; description . addProperty ( "location" ) ; return description ; }
response: public DelegatingResourceDescription getCreatableProperties ( ) { DelegatingResourceDescription description = super . getCreatableProperties ( ) ; if ( ! description . hasProperty ( "name" ) ) { description . addProperty ( "name" ) ; } if ( ! description . hasProperty ( "description" ) ) { description . addProperty ( "description" ) ; } description . addProperty ( "location" ) ; return description ; }

sample: 362
buggy_code: private JsonParser getParser(String data) throws IOException { // If the first character is { or [, assume this is // JSON data and use a JsonParser. Otherwise assume // YAML and use a YAMLParser. <START> Character firstChar = data.charAt(0); <END> if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } }
code_review: Character should be "char" https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#charAt(int) This is returning a char (primitive type) and that is why the "=="test works I think, if it was returning Character (object wrapper for char) we would need to use ".equals"
target code: private JsonParser getParser ( String data ) throws IOException { // If the first character is { or [ , assume this is // JSON data and use a JsonParser . Otherwise assume // YAML and use a YAMLParser . char firstChar = data . charAt ( 0 ) ; if ( firstChar == ' { ' || firstChar == ' [ ' ) { return this . jsonFactory . createParser ( data ) ; } else { return this . yamlFactory . createParser ( data ) ; } }
response: private JsonParser getParser ( String data ) throws IOException { char firstChar = data . charAt ( 0 ) ; if ( firstChar == ' { ' || firstChar == ' [ ' ) { return this . jsonFactory . createParser ( data ) ; } else { return this . yamlFactory . createParser ( data ) ; } }

sample: 363
buggy_code: public void testGenerateDroolsTestOption() { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig(); assertThat(config.isGenerateDroolsTestOnError()).isNull(); config.setGenerateDroolsTestOnError(true); <START> assertThat((boolean) config.isGenerateDroolsTestOnError()).isTrue(); <END> config.setGenerateDroolsTestOnError(Boolean.FALSE); assertThat((boolean) config.isGenerateDroolsTestOnError()).isFalse(); config.setGenerateDroolsTestOnError(null); assertThat(config.isGenerateDroolsTestOnError()).isNull(); }
code_review: Redundant cast.
target code: public void testGenerateDroolsTestOption ( ) { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig ( ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; config . setGenerateDroolsTestOnError ( true ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isTrue ( ) ; config . setGenerateDroolsTestOnError ( Boolean . FALSE ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isFalse ( ) ; config . setGenerateDroolsTestOnError ( null ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; }
response: public void testGenerateDroolsTestOption ( ) { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig ( ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; config . setGenerateDroolsTestOnError ( true ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isTrue ( ) ; config . setGenerateDroolsTestOnError ( Boolean . FALSE ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isFalse ( ) ; config . setGenerateDroolsTestOnError ( null ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; }

sample: 364
buggy_code: private RawText getRawText(ObjectId id, Repository repo) throws IOException { <START> if (id.equals(ObjectId.zeroId())) return new RawText(new byte[] {}); <END> return new RawText(repo.openBlob(id).getCachedBytes()); }
code_review: Style-nit: Use curly brackets and wrap the return to next line.
target code: private RawText getRawText ( ObjectId id , Repository repo ) throws IOException { if ( id . equals ( ObjectId . zeroId ( ) ) ) { return new RawText ( new byte [ ] { } ) ; } return new RawText ( repo . openBlob ( id ) . getCachedBytes ( ) ) ; }
response: private RawText getRawText ( ObjectId id , Repository repo ) throws IOException { if ( id . equals ( ObjectId . zeroId ( ) ) ) { return new RawText ( new byte [ ] { } ) ; } return new RawText ( repo . openBlob ( id ) . getCachedBytes ( ) ) ; }

sample: 365
buggy_code: private static String getUserAgentSuffix() { String suffix = ";" + USER_AGENT_SUFFIX; <START> return suffix; <END> }
code_review: We can make this inline. ```suggestion return ";" + USER_AGENT_SUFFIX; ```
target code: private static String getUserAgentSuffix ( ) { return " ; " + USER_AGENT_SUFFIX ; }
response: private static String getUserAgentSuffix ( ) { return " ; " + USER_AGENT_SUFFIX ; }

sample: 366
buggy_code: public Builder setDataSize(Estimate dataSize) { <START> this.dataSize = requireNonNull(dataSize, "dataSize can not be null"); <END> return this; }
code_review: you don't validate in other builders method (and you don't have to)
target code: public Builder setDataSize ( Estimate dataSize ) { this . dataSize = dataSize ; return this ; }
response: public Builder setDataSize ( Estimate dataSize ) { this . dataSize = dataSize ; return this ; }

sample: 367
buggy_code: public boolean isExpired(Date invocationDate) { if (getExpires() != null) { Date currentInvocationDate = invocationDate == null ? new Date() : invocationDate; <START> return getExpires().before(currentInvocationDate); <END> } return false; }
code_review: Statement can be rewritten inline.
target code: public boolean isExpired ( Date invocationDate ) { if ( getExpires ( ) != null ) { return getExpires ( ) . before ( invocationDate == null ? new Date ( ) : invocationDate ) ; } return false ; }
response: public boolean isExpired ( Date invocationDate ) { return getExpires ( ) != null && getExpires ( ) . before ( invocationDate == null ? new Date ( ) : invocationDate ) ; }

sample: 368
buggy_code: public void stop() { if (isRunning()) { process.destroy(); try { if (stdout !=null) { <START> stdout.close(); <END> } if (stdin !=null) { stdin.close(); } } catch (IOException e) { throw new RuntimeException(e.getMessage(),e); } finally { running.set(false); } } }
code_review: Is this really needed?
target code: public void stop ( ) { if ( isRunning ( ) ) { process . destroy ( ) ; running . set ( false ) ; } }
response: public void stop ( ) { if ( isRunning ( ) ) { process . destroy ( ) ; try { if ( stdout != null ) { stdout . close ( ) ; } if ( stdin != null ) { stdin . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { running . set ( false ) ; } } }

sample: 369
buggy_code: public boolean equals(Object object) { <START> if (object == null || object.getClass() != getClass()) { <END> return false; } if (object == this) { return true; } MacroId rhs = (MacroId) object; return new EqualsBuilder() .append(getId(), rhs.getId()) .append(getSyntax(), rhs.getSyntax()) .isEquals(); }
code_review: Actually since MacroId is not really supposed to be extended you could replace this with a `if (!(object instanceof MacroId))`. Can't be null if it's an instance of MacroId. Also I would put it after the `if (object == this)` test instead of before.
target code: public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof MacroId ) ) { return false ; } MacroId rhs = ( MacroId ) object ; return new EqualsBuilder ( ) . append ( getId ( ) , rhs . getId ( ) ) . append ( getSyntax ( ) , rhs . getSyntax ( ) ) . isEquals ( ) ; }
response: public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof MacroId ) ) { return false ; } MacroId rhs = ( MacroId ) object ; return new EqualsBuilder ( ) . append ( getId ( ) , rhs . getId ( ) ) . append ( getSyntax ( ) , rhs . getSyntax ( ) ) . isEquals ( ) ; }

sample: 370
buggy_code: <START> Map<String, Object> getExtraInformation() { <END> return extraInformation; }
code_review: this is public API, we can't lower the visibility without deprecating first
target code: public Map < String , Object > getExtraInformation ( ) { return extraInformation ; }
response: < START > public Map < String , Object > getExtraInformation ( ) { return extraInformation ; } < END > @Deprecated protected Map < String , Object > getExtraInformationDeprecated ( ) { return extraInformation ; }

sample: 371
buggy_code: public int hashCode() { <START> return Objects.hash(pointer, ownerName, owner, readers, writers); <END> }
code_review: neat.
target code: public int hashCode ( ) { return Objects . hash ( pointer , ownerName ) ; }
response: public int hashCode ( ) { return Objects . hash ( pointer , ownerName , owner , readers , writers ) ; }

sample: 372
buggy_code: private String getFriendsPath( SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) { // https://youtrack.jetbrains.com/issue/KT-29933 ImmutableSortedSet<String> absoluteFriendPaths = ImmutableSortedSet.copyOf( friendPathsSourcePaths .stream() .map(path -> sourcePathResolver.getAbsolutePath(path).toString()) .collect(Collectors.toSet())); return "-Xfriend-paths=" <START> + absoluteFriendPaths.stream().reduce("", (path1, path2) -> path1 + "," + path2); <END> }
code_review: What about the same when the list is empty, it still adds `-Xfriend-paths=` option?
target code: private String getFriendsPath ( SourcePathResolver sourcePathResolver , ImmutableList < SourcePath > friendPathsSourcePaths ) { if ( friendPathsSourcePaths . isEmpty ( ) ) { return "" ; } // https :/ / youtrack . jetbrains . com / issue / KT - 29933 ImmutableSortedSet < String > absoluteFriendPaths = ImmutableSortedSet . copyOf ( friendPathsSourcePaths . stream ( ) . map ( path - > sourcePathResolver . getAbsolutePath ( path ) . toString ( ) ) . collect ( Collectors . toSet ( ) ) ) ; return " - Xfriend - paths = " + absoluteFriendPaths . stream ( ) . reduce ( "" , ( path1 , path2 ) - > path1 + " , " + path2 ) ; }
response: private String getFriendsPath ( SourcePathResolver sourcePathResolver , ImmutableList < SourcePath > friendPathsSourcePaths ) { ImmutableSortedSet < String > absoluteFriendPaths = ImmutableSortedSet . copyOf ( friendPathsSourcePaths . stream ( ) . map ( path - > sourcePathResolver . getAbsolutePath ( path ) . toString ( ) ) . collect ( Collectors . toSet ( ) ) ) ; if ( absoluteFriendPaths . isEmpty ( ) ) { return "" ; } return " - Xfriend - paths = " + absoluteFriendPaths . stream ( ) . reduce ( "" , ( path1 , path2 ) - > path1 + " , " + path2 ) ; }  The refactored code checks if the `absoluteFriendPaths` set is empty and returns an empty string if it is . This ensures that the ` - Xfriend - paths = ` option is not added when the list is empty .

sample: 373
buggy_code: public Target(String targetUriAsString) { <START> super(); <END> Assert.hasText(targetUriAsString, "The provided targetUriAsString must neither be null nor empty."); this.targetUri = URI.create(targetUriAsString); }
code_review: Do we need super(), if the class is not inheriting from a super class?
target code: public Target ( String targetUriAsString ) { Assert . hasText ( targetUriAsString , "The provided targetUriAsString must neither be null nor empty . " ) ; this . targetUri = URI . create ( targetUriAsString ) ; }
response: public Target ( String targetUriAsString ) { Assert . hasText ( targetUriAsString , "The provided targetUriAsString must neither be null nor empty . " ) ; this . targetUri = URI . create ( targetUriAsString ) ; }

sample: 374
buggy_code: public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) { super(definition); final String propertyName = definition.getTestValue(); String regexExpression = PropertiesManager.getProperty (propertyName, ""); if (StringUtils.isBlank(regexExpression)) { logger.error("Unable to find property name {} in portal.properties or has empty value." + " PAGS PropertyInvertedRegexTester will always return true for attribute {}", propertyName, definition.getAttributeName()); } setPattern(regexExpression); <START> } <END>
code_review: Minor, but rather than duplicating lines 44 - 51, perhaps put them in a private method invoked by both constructors, or have this constructor invoke the other.
target code: public PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition ) { super ( definition ) ; setPattern ( definition . getAttributeName ( ) , definition . getTestValue ( ) ) ; }
response: public PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition ) { this ( definition , PropertiesManager . getProperty ( definition . getTestValue ( ) , "" ) ) ; } private PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition , String regexExpression ) { super ( definition ) ; final String propertyName = definition . getTestValue ( ) ; if ( StringUtils . isBlank ( regexExpression ) ) { logger . error ( "Unable to find property name { } in portal . properties or has empty value . PAGS PropertyInvertedRegexTester will always return true for attribute { } " , propertyName , definition . getAttributeName ( ) ) ; } setPattern ( regexExpression ) ; }

sample: 375
buggy_code: public final boolean doesProvideNewPage() { if (provision == null) { <START> throw new IllegalStateException("Page instance not yet resolved"); <END> } return getProvision().doesProvideNewPage(); }
code_review: Looking bad indeed, I fixed later during my work on the branch: https://github.com/apache/wicket/pull/210/commits/b64f2b4b2cb50a594cabb50a0c1eeca43485f6b9#diff-36b11db0d92a540368a080c520de953aL177 The three states looks overcomplicated. There's no place in Wicket core needing to test such flag for the value "OLD".
target code: public final boolean doesProvideNewPage ( ) { return getProvision ( ) . doesProvideNewPage ( ) ; }
response: public final boolean doesProvideNewPage ( ) { if ( provision == null ) { throw new IllegalStateException ( "Page instance not yet resolved" ) ; } return getProvision ( ) . doesProvideNewPage ( ) ; }

sample: 376
buggy_code: private Handler getHandler() { <START> if (mHandler == null) { <END> // Use current main looper mHandler = new Handler(mContext.getMainLooper()); } return mHandler; }
code_review: This doesn't look thread-safe.
target code: private synchronized Handler getHandler ( ) { if ( mHandler == null ) { // Use current main looper mHandler = new Handler ( mContext . getMainLooper ( ) ) ; } return mHandler ; }
response: private synchronized Handler getHandler ( ) { if ( mHandler == null ) { mHandler = new Handler ( mContext . getMainLooper ( ) ) ; } return mHandler ; }

sample: 377
buggy_code: @SuppressWarnings("UnusedDeclaration") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); <START> setLoggingEnabled(debugging); <END> }
code_review: Let's remove this behavior. `setDebugging` will only affect the indicators.
target code: @SuppressWarnings ( "UnusedDeclaration" ) @Deprecated public void setDebugging ( boolean debugging ) { setIndicatorsEnabled ( debugging ) ; }
response: @Deprecated public void setDebugging ( boolean debugging ) { setIndicatorsEnabled ( debugging ) ; }

sample: 378
buggy_code: public List<ServerTemplate> load() { synchronized (store) { return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList()); <START> } <END> }
code_review: I guess we no longer need `store` to be of `ConcurrentHashMap` implementation if we are fully locking it.
target code: public List < ServerTemplate > load ( ) { synchronized ( store ) { return store . values ( ) . stream ( ) . map ( this : : cloneServerTemplate ) . collect ( Collectors . toList ( ) ) ; } }
response: public List < ServerTemplate > load ( ) { synchronized ( store ) { return new ArrayList < > ( store . values ( ) ) ; } }

sample: 379
buggy_code: public String getLearnerMaster() { QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster(); InetSocketAddress address = learnerMaster.addr.getReachableOrOne(); <START> if (learnerMaster == null || address == null) { <END> return "Unknown"; } return address.getAddress().getHostAddress() + ":" + address.getPort(); }
code_review: if `learnerMaster` is `null` here then you'll get a NPE on the `learnerMaster.addr.getReachableOrOne()` above.
target code: public String getLearnerMaster ( ) { QuorumPeer . QuorumServer learnerMaster = observer . getCurrentLearnerMaster ( ) ; if ( learnerMaster == null || learnerMaster . addr . isEmpty ( ) ) { return "Unknown" ; } InetSocketAddress address = learnerMaster . addr . getReachableOrOne ( ) ; return address . getAddress ( ) . getHostAddress ( ) + " : " + address . getPort ( ) ; }
response: public String getLearnerMaster ( ) { QuorumPeer . QuorumServer learnerMaster = observer . getCurrentLearnerMaster ( ) ; if ( learnerMaster == null ) { return "Unknown" ; } InetSocketAddress address = learnerMaster . addr . getReachableOrOne ( ) ; return address . getAddress ( ) . getHostAddress ( ) + " : " + address . getPort ( ) ; }

sample: 380
buggy_code: default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) { ArgumentUtil.requireNotNull(func, "function"); final Task<Task<R>> nested = map("map: " + desc, func); nested.getShallowTraceBuilder().setSystemHidden(true); <START> nested.getShallowTraceBuilder().setTaskType("nestedTask"); <END> return flatten(desc, nested); }
code_review: I think we should drop redundant "Task" suffix from the task types e.g.: "nestedTask" -> "nested" "withSideEffectTask" -> "withSideEffect" "timeoutTask" -> "timeout" "withTimeoutTask" -> "withTimeout"
target code: default < R > Task < R > flatMap ( final String desc , final Function1 < ? super T , Task < R > > func ) { ArgumentUtil . requireNotNull ( func , "function" ) ; final Task < Task < R > > nested = map ( "map : " + desc , func ) ; nested . getShallowTraceBuilder ( ) . setSystemHidden ( true ) ; return flatten ( desc , nested ) ; }
response: default < R > Task < R > flatMap ( final String desc , final Function1 < ? super T , Task < R > > func ) { ArgumentUtil . requireNotNull ( func , "function" ) ; final Task < Task < R > > nested = map ( "map : " + desc , func ) ; nested . getShallowTraceBuilder ( ) . setSystemHidden ( true ) ; nested . getShallowTraceBuilder ( ) . setTaskType ( "nested" ) ; return flatten ( desc , nested ) ; }

sample: 381
buggy_code: protected List<String> findStringsInFileCommon(String regexp, boolean stopOnFirst, int searchLimit, File fileToSearch) <START> throws Exception { <END> return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO); }
code_review: As stated above, I don't see the need for this method to throw an exception.
target code: protected List < String > findStringsInFileCommon ( String regexp , boolean stopOnFirst , int searchLimit , File fileToSearch ) { return findStringsInFileCommon ( regexp , stopOnFirst , searchLimit , fileToSearch , Project . MSG_INFO ) ; }
response: protected List < String > findStringsInFileCommon ( String regexp , boolean stopOnFirst , int searchLimit , File fileToSearch ) { return findStringsInFileCommon ( regexp , stopOnFirst , searchLimit , fileToSearch , Project . MSG_INFO ) ; }

sample: 382
buggy_code: public void notifyAboutStartProcess(String id) { Long processInstanceId = Long.parseLong(id); newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId, deploymentId, processInstanceId, processDefId, processName, <START> 1)); <END> final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue()); notificationEvent.fire(new NotificationEvent(message, NotificationEvent.NotificationType.SUCCESS)); close(); }
code_review: can you pass null in here for the status, I recently refactored similar code, and status should not be part of the event.
target code: public void notifyAboutStartProcess ( String id ) { Long processInstanceId = Long . parseLong ( id ) ; newProcessInstanceEvent . fire ( new NewProcessInstanceEvent ( serverTemplateId , deploymentId , processInstanceId , processDefId , processName , null ) ) ; final String message = Constants . INSTANCE . ProcessStarted ( processInstanceId . longValue ( ) ) ; notificationEvent . fire ( new NotificationEvent ( message , NotificationEvent . NotificationType . SUCCESS ) ) ; close ( ) ; }
response: public void notifyAboutStartProcess ( String id ) { Long processInstanceId = Long . parseLong ( id ) ; newProcessInstanceEvent . fire ( new NewProcessInstanceEvent ( serverTemplateId , deploymentId , processInstanceId , processDefId , processName , null ) ) ; final String message = Constants . INSTANCE . ProcessStarted ( processInstanceId . longValue ( ) ) ; notificationEvent . fire ( new NotificationEvent ( message , NotificationEvent . NotificationType . SUCCESS ) ) ; close ( ) ; }

sample: 383
buggy_code: protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); <START> if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) { <END> maybeMove(oldChildReference, newChildReference); } } }); }
code_review: I don't understand what this check is doing here. maybeMove is already taking check of checking rights.
target code: protected void process ( final SpaceReference source , final SpaceReference destination ) { visitDocuments ( source , new Visitor < DocumentReference > ( ) { @Override public void visit ( DocumentReference oldChildReference ) { DocumentReference newChildReference = oldChildReference . replaceParent ( source , destination ) ; maybeMove ( oldChildReference , newChildReference ) ; } } ) ; }
response: protected void process ( final SpaceReference source , final SpaceReference destination ) { visitDocuments ( source , new Visitor < DocumentReference > ( ) { @Override public void visit ( DocumentReference oldChildReference ) { DocumentReference newChildReference = oldChildReference . replaceParent ( source , destination ) ; maybeMove ( oldChildReference , newChildReference ) ; } } ) ; }

sample: 384
buggy_code: <START> public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException { <END> log.info("Process event {}", event.getType()); switch (event.type) { case DISCOVER_INIT_TOPOLOGY: startDiscovery(); break; case ACQUIRE_LOCK: processLockAcquire(); break; case RELEASE_LOCK: processLockRelease(); break; case DISCOVERED_TOPOLOGY: processTopologyChangeNotification(event); break; case UPGRADE: processUpgrade(event); break; default: log.error("Invalid event type {}", event.type); } }
code_review: same, we can delete LogReplicationDiscoveryServiceException.java file now.
target code: public void processEvent ( DiscoveryServiceEvent event ) { log . info ( "Process event { } " , event . getType ( ) ) ; switch ( event . getType ( ) ) { case DISCOVER_INIT_TOPOLOGY : startDiscovery ( ) ; break ; case ACQUIRE_LOCK : processLockAcquire ( ) ; break ; case RELEASE_LOCK : processLockRelease ( ) ; break ; case DISCOVERED_TOPOLOGY : processTopologyChangeNotification ( event ) ; break ; case UPGRADE : processUpgrade ( event ) ; break ; default : log . error ( "Invalid event type { } " , event . getType ( ) ) ; } }
response: public void processEvent ( DiscoveryServiceEvent event ) { log . info ( "Process event { } " , event . getType ( ) ) ; switch ( event . getType ( ) ) { case DISCOVER_INIT_TOPOLOGY : startDiscovery ( ) ; break ; case ACQUIRE_LOCK : processLockAcquire ( ) ; break ; case RELEASE_LOCK : processLockRelease ( ) ; break ; case DISCOVERED_TOPOLOGY : processTopologyChangeNotification ( event ) ; break ; case UPGRADE : processUpgrade ( event ) ; break ; default : log . error ( "Invalid event type { } " , event . getType ( ) ) ; } }

sample: 385
buggy_code: public void deleteError(final ProgramError error) { synchronized (errors) { errors.remove(error); <START> eventBus.publish(new ProgramErrorDeletedEvent(error)); <END> } }
code_review: Don't really like firing events when holding locks on things... If anything that receives a ProgramErrorDeletedEvent tries to access the ErrorManager (which is not altogether unreasonable!) you'll end up with a nasty deadlock. Could we just make errors a ConcurrentSkipListSet and drop all the synchronization?
target code: public void deleteError ( final ProgramError error ) { errors . remove ( error ) ; eventBus . publish ( new ProgramErrorDeletedEvent ( error ) ) ; }
response: public void deleteError ( final ProgramError error ) { errors . remove ( error ) ; eventBus . publish ( new ProgramErrorDeletedEvent ( error ) ) ; }

sample: 386
buggy_code: public LamiTableContentProvider() { fCurrentEntries = <START> checkNotNull(Collections.emptyList()); <END> }
code_review: Can remove checkNotNull, we have external @NonNull annotation on Collections.emptyList().
target code: public LamiTableContentProvider ( ) { fCurrentEntries = Collections . emptyList ( ) ; }
response: public LamiTableContentProvider ( ) { fCurrentEntries = Collections . emptyList ( ) ; }

sample: 387
buggy_code: public ArticlePageObject clickGetInfoLink() { switchToIFrame(); waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); switchOutOfIFrame(); <START> return new ArticlePageObject(driver); <END> }
code_review: in case of switching, in my opinion it's better to us etry/finnally like that: ``` switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); } ``` it's clearer in reading
target code: public ArticlePageObject clickGetInfoLink ( ) { switchToIFrame ( ) ; try { waitForElementByElement ( getInfoLink ) ; // Opens new tab to Template namespace getInfoLink . click ( ) ; return new ArticlePageObject ( driver ) ; } finally { switchOutOfIFrame ( ) ; } }
response: public ArticlePageObject clickGetInfoLink ( ) { switchToIFrame ( ) ; try { waitForElementByElement ( getInfoLink ) ; // Opens new tab to Template namespace getInfoLink . click ( ) ; return new ArticlePageObject ( driver ) ; } finally { switchOutOfIFrame ( ) ; } }

sample: 388
buggy_code: @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setAdviceChain(new CacheInterceptor()); assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain()) .hasSize(2) <START> .matches(adviceArray -> asList(adviceArray).get(0) instanceof TracingRabbitListenerAdvice); <END> }
code_review: would this work? (also removing the import) ```suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice); ```
target code: @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent ( ) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory ( ) ; factory . setAdviceChain ( new CacheInterceptor ( ) ) ; // the order of advices is important for the downstream interceptor to see the tracing context assertThat ( rabbitTracing . decorateSimpleRabbitListenerContainerFactory ( factory ) . getAdviceChain ( ) ) . hasSize ( 2 ) . matches ( adviceArray - > adviceArray [ 0 ] instanceof TracingRabbitListenerAdvice ) ; }
response: @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent ( ) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory ( ) ; factory . setAdviceChain ( new CacheInterceptor ( ) ) ; assertThat ( rabbitTracing . decorateSimpleRabbitListenerContainerFactory ( factory ) . getAdviceChain ( ) ) . hasSize ( 2 ) . matches ( adviceArray - > adviceArray [ 0 ] instanceof TracingRabbitListenerAdvice ) ; }

sample: 389
buggy_code: private static List<IResource> getReadonlyFiles(IResource[] resources) { <START> List<IResource> readOnlyFiles= new ArrayList<IResource>(); <END> for (int i= 0; i < resources.length; i++) { IResource resource= resources[i]; ResourceAttributes resourceAttributes= resource.getResourceAttributes(); if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly()) readOnlyFiles.add(resource); } return readOnlyFiles; }
code_review: Use ArrayList<>
target code: private static List < IResource > getReadonlyFiles ( IResource [ ] resources ) { List < IResource > readOnlyFiles = new ArrayList < > ( ) ; for ( IResource resource : resources ) { ResourceAttributes resourceAttributes = resource . getResourceAttributes ( ) ; if ( resource . getType ( ) == IResource . FILE && resourceAttributes != null && resourceAttributes . isReadOnly ( ) ) readOnlyFiles . add ( resource ) ; } return readOnlyFiles ; }
response: private static List < IResource > getReadonlyFiles ( IResource [ ] resources ) { List < IResource > readOnlyFiles = new ArrayList < > ( ) ; for ( int i = 0 ; i < resources . length ; i ++ ) { IResource resource = resources [ i ] ; ResourceAttributes resourceAttributes = resource . getResourceAttributes ( ) ; if ( resource . getType ( ) == IResource . FILE && resourceAttributes != null && resourceAttributes . isReadOnly ( ) ) { readOnlyFiles . add ( resource ) ; } } return readOnlyFiles ; }

sample: 390
buggy_code: void clean(K key) { List<V> data = getDataMap().get(key); if (data != null) { <START> data.clear(); <END> } getDataMap().remove(key); }
code_review: I think this is not necessary as the GC will remove it as soon as there is no more reference on the Object
target code: void clean ( K key ) { getDataMap ( ) . remove ( key ) ; }
response: void clean ( K key ) { getDataMap ( ) . remove ( key ) ; }

sample: 391
buggy_code: public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) { if (!isMemory(memoryDevice)) { <START> throw new RuntimeException("Memory device expected but device " + memoryDevice + " obtained."); <END> } return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent(); }
code_review: IllegalArgumentException sounds better here.
target code: public static boolean isMemoryDeviceHotUnpluggable ( VmDevice memoryDevice ) { if ( ! isMemory ( memoryDevice ) ) { throw new IllegalArgumentException ( "Memory device expected but device " + memoryDevice + " obtained . " ) ; } return getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_SIZE ) . isPresent ( ) && getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_NODE ) . isPresent ( ) ; }
response: public static boolean isMemoryDeviceHotUnpluggable ( VmDevice memoryDevice ) { if ( ! isMemory ( memoryDevice ) ) { throw new IllegalArgumentException ( "Memory device expected but device " + memoryDevice + " obtained . " ) ; } return getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_SIZE ) . isPresent ( ) && getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_NODE ) . isPresent ( ) ; }

sample: 392
buggy_code: public boolean connectorExists(String id) { try { List<ConnectorConfiguration> list = configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id)); if (list.isEmpty()) { return false; } return true; } catch (PersistenceException e) { <START> throw new RuntimeException(e); <END> } }
code_review: Would be nice if you add here an exception text. Something like "unable to load the list of connector configurations"
target code: public Boolean connectorExists ( String id ) { try { List < ConnectorConfiguration > list = configPersistence . load ( ImmutableMap . of ( Constants . CONNECTOR_PERSISTENT_ID , id ) ) ; return ! list . isEmpty ( ) ; } catch ( PersistenceException e ) { throw new RuntimeException ( e ) ; } }
response: public boolean connectorExists ( String id ) { try { List < ConnectorConfiguration > list = configPersistence . load ( ImmutableMap . of ( Constants . CONNECTOR_PERSISTENT_ID , id ) ) ; if ( list . isEmpty ( ) ) { return false ; } return true ; } catch ( PersistenceException e ) { throw new RuntimeException ( "Unable to load the list of connector configurations" , e ) ; } }

sample: 393
buggy_code: public void testUpdateStmtBuilder() { printStatement("update foo set \"column['looks_like_nested']\"=1"); printStatement("update foo set foo.a='b'"); printStatement("update bar.foo set bar.foo.t=3"); printStatement("update foo set col['x'] = 3"); printStatement("update foo set col['x'] = 3 where foo['x'] = 2"); printStatement("update schemah.foo set foo.a='b', foo.b=foo.a"); printStatement("update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"); printStatement("update foo set foo='a' returning id"); printStatement("update foo set foo='a' where x=false returning id"); printStatement("update foo set foo='a' returning id AS foo"); printStatement("update foo set foo='a' returning id + 1 AS foo, id -1 as bar"); <START> } <END>
code_review: can we maybe have separate test cases for the returning clause?
target code: public void testUpdateStmtBuilder ( ) { printStatement ( "update foo set \"column [ 'looks_like_nested' ] \" = 1" ) ; printStatement ( "update foo set foo . a = 'b'" ) ; printStatement ( "update bar . foo set bar . foo . t = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3 where foo [ 'x' ] = 2" ) ; printStatement ( "update schemah . foo set foo . a = 'b' , foo . b = foo . a" ) ; printStatement ( "update schemah . foo set foo . a = abs ( - 6 . 3334 ) , x = true where x = false" ) ; }
response: public void testUpdateStmtBuilder ( ) { printStatement ( "update foo set \"column [ 'looks_like_nested' ] \" = 1" ) ; printStatement ( "update foo set foo . a = 'b'" ) ; printStatement ( "update bar . foo set bar . foo . t = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3 where foo [ 'x' ] = 2" ) ; printStatement ( "update schemah . foo set foo . a = 'b' , foo . b = foo . a" ) ; printStatement ( "update schemah . foo set foo . a = abs ( - 6 . 3334 ) , x = true where x = false" ) ; printStatement ( "update foo set foo = 'a' returning id" ) ; printStatement ( "update foo set foo = 'a' where x = false returning id" ) ; printStatement ( "update foo set foo = 'a' returning id AS foo" ) ; printStatement ( "update foo set foo = 'a' returning id + 1 AS foo , id - 1 as bar" ) ; } public void testUpdateStmtBuilderWithReturningClause ( ) { printStatement ( "update foo set foo = 'a' returning id" ) ; printStatement ( "update foo set foo = 'a' where x = false returning id" ) ; printStatement ( "update foo set foo = 'a' returning id AS foo" ) ; printStatement ( "update foo set foo = 'a' returning id + 1 AS foo , id - 1 as bar" ) ; }

sample: 394
buggy_code: public void setSetPath(String path) { <START> setPath.set(requireNonNull(path, "path is null")); <END> }
code_review: nit: I know that in other parts of this class we put the requireNonNull calls inside another method call, but let's not do it here for the sake of slightly better readability: ``` requireNonNull(path, "path is null"); setPath.set(path); ```
target code: public void setSetPath ( String path ) { requireNonNull ( path , "path is null" ) ; setPath . set ( path ) ; }
response: public void setSetPath ( String path ) { Objects . requireNonNull ( path , "path is null" ) ; setPath . set ( path ) ; }

sample: 395
buggy_code: public EnvVars getEnvironment() throws IOException, InterruptedException { if (cachedEnvironment != null) { <START> return cachedEnvironment; <END> } cachedEnvironment = EnvVars.getRemote(getChannel()); return cachedEnvironment; }
code_review: Something like this: ``` public EnvVars getEnvironment() throws IOException, InterruptedException { EnvVars cachedEnvironment = this.cachedEnvironment; if (cachedEnvironment != null) { return cachedEnvironment; cachedEnvironment = EnvVars.getRemote(getChannel()); // all non-null values should be equivalent so in a race it doesn't matter who wins this.cachedEnvironment = cachedEnvironment; return cachedEnvironment; } ```
target code: public EnvVars getEnvironment ( ) throws IOException , InterruptedException { EnvVars cachedEnvironment = this . cachedEnvironment ; if ( cachedEnvironment != null ) { return cachedEnvironment ; } cachedEnvironment = EnvVars . getRemote ( getChannel ( ) ) ; this . cachedEnvironment = cachedEnvironment ; return cachedEnvironment ; }
response: public EnvVars getEnvironment ( ) throws IOException , InterruptedException { EnvVars cachedEnvironment = this . cachedEnvironment ; if ( cachedEnvironment != null ) { return cachedEnvironment ; } cachedEnvironment = EnvVars . getRemote ( getChannel ( ) ) ; this . cachedEnvironment = cachedEnvironment ; return cachedEnvironment ; }

BLEU: 76.88 ; EM: 40.62
Python file executed successfully.
Cloning into 'tree-sitter-java'...
ngram match: 0.7687588799486408, weighted ngram match: 0.7784387569911922, syntax_match: 0.791578947368421, dataflow_match: 0.7544483985765125
CodeBLEU score: 77.33
Python file executed successfully.

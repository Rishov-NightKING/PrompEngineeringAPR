sample: 1072
buggy_code: public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } // toolkit.paintBordersFor(main); this.layout(); }
code_review: Why do you perform this test on FeaturesProvider's class? This really looks strange and I do not see how this relates to the goal of this commit...
target code: public void init ( EObject original , EditingDomain editingDomain ) { List < EStructuralFeature > features = featuresProvider . getFeatures ( original ) ; initControlFactory ( editingDomain , original ) ; for ( final EStructuralFeature feature : features ) { createControlForFeature ( feature ) ; } // toolkit . paintBordersFor ( main ) ; this . layout ( ) ; }
response: public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } // toolkit.paintBordersFor(main); this.layout(); }

sample: 1073
buggy_code: public List<Annotation> getQualifiers() { return new ArrayList<Annotation>( <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ); }
code_review: I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList.
target code: public List < Annotation > getQualifiers ( ) { return Arrays . asList ( ( Annotation ) new org . jboss . arquillian . warp . servlet . AfterServlet ( ) { @Override public Class < ? extends Annotation > annotationType ( ) { return org . jboss . arquillian . warp . servlet . AfterServlet . class ; } } ) ; }
response: public List<Annotation> getQualifiers() { return <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ; }

sample: 1074
buggy_code: protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> Subject.doAs(subj, new PrivilegedExceptionAction<Void>() { <END> public Void run() throws Exception { remoteCacheManager = new RemoteCacheManager(config, true); return null; } }); remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); }
code_review: It should not be necessary to crate the RemoteCacheManager in a PrivligedAction. Only the GSSAPI mech requires a Subject to initialize the SASL client, and that should be passed in by the configuration
target code: protected void initialize ( Subject subj ) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig ( subj ) ; remoteCacheManager = new RemoteCacheManager ( config , true ) ; remoteCache = remoteCacheManager . getCache ( TEST_CACHE_NAME ) ; }
response: protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> remoteCacheManager = new RemoteCacheManager(config, true); <END> remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); }

sample: 1075
buggy_code: <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); }
code_review: Shouldn't this copy in `baseSelectors`? I know it it currently empty, but the code implies you want to add another selector to the base selectors.
target code: LauncherDiscoveryRequest buildRequest ( Bundle bundle ) { List < DiscoverySelector > selectors = new ArrayList < > ( baseSelectors . size ( ) + 1 ) ; selectors . addAll ( baseSelectors ) ; selectors . add ( BundleSelector . selectBundle ( bundle ) ) ; return LauncherDiscoveryRequestBuilder . request ( ) . configurationParameter ( BundleEngine . CHECK_UNRESOLVED , unresolved ) . selectors ( selectors ) . build ( ) ; }
response: <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.addAll(baseSelectors); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); }

sample: 1076
buggy_code: protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } }
code_review: there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.
target code: protected void statementExecuteUpdateBefore ( StatementProxy statement , String sql ) { super . statementExecuteUpdateBefore ( statement , sql ) ; Before ( statement , sql ) ; }
response: protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } }

sample: 1077
buggy_code: public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); <START> return new DecoderResult(cause); <END> }
code_review: nit: merge lines
target code: public static DecoderResult failure ( Throwable cause ) { return new DecoderResult ( ObjectUtil . checkNotNull ( cause , "cause" ) ) ; }
response: public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); return new DecoderResult(cause); }

sample: 1078
buggy_code: private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); }
code_review: Why 5? Just use the default unless there's a good reason not to.
target code: private void writeObject ( Schema schema , GenericRecord datum ) throws Exception { BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( new ByteArrayOutputStream ( ) , null ) ; GenericDatumWriter < GenericData . Record > writer = new GenericDatumWriter < GenericData . Record > ( schema ) ; writer . write ( schema , datum , encoder ) ; }
response: private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); }

sample: 1079
buggy_code: public Collection<String> getNames() { if (names == null) { <START> names = new HashSet<>(named.keySet()); <END> namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); } return Collections.unmodifiableSet(names); }
code_review: Sorry--what I meant before was to just build and return the collection on _every_ invocation, rather than storing it in a field. There's only one place calling this method now, so the caching doesn't buy us anything.
target code: public Collection < String > getNames ( ) { final Set < String > names = new HashSet < > ( named . keySet ( ) ) ; namedArgumentFinder . forEach ( args - > names . addAll ( args . getNames ( ) ) ) ; return Collections . unmodifiableSet ( names ) ; }
response: public Collection<String> getNames() { <START> Set<String> names = new HashSet<>(named.keySet()); namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); return Collections.unmodifiableSet(names); <END> }

sample: 1080
buggy_code: public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.error("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; }
code_review: Hmmm. I'm thinking we might want to turn this into a logger.warning instead. I'd use the error only if the program cannot proceed, while in this case the consumer code is responsible for reacting to a null return: this particular piece of code can cope perfectly well with it.
target code: public FBOConfig getFboConfig ( ResourceUrn fboName ) { FBOConfig fboConfig = fboConfigs . get ( fboName ) ; if ( fboConfig == null ) { logger . warn ( "Failed to retrieve FBOConfig '" + fboName + "' ! " ) ; } return fboConfig ; }
response: public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.warning("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; }

sample: 1081
buggy_code: <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; }
code_review: This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance (to clarify see the surrounding diff since this preview gets confused)
target code: protected void setKey ( Input newInput , char newKeyChar ) { this . input = newInput ; this . keyChar = newKeyChar ; }
response: <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; }

sample: 1082
buggy_code: public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; }
code_review: This doesn't seem right, the call to org.infinispan.configuration.cache.EvictionConfigurationBuilder#strategy(org.infinispan.eviction.EvictionStrategy) is missing completely, thus the default strategy will always be NONE.
target code: public Builder < EvictionConfiguration > configure ( OperationContext context , ModelNode model ) throws OperationFailedException { EvictionStrategy strategy = ModelNodes . asEnum ( STRATEGY . getDefinition ( ) . resolveModelAttribute ( context , model ) , EvictionStrategy . class ) ; this . builder . strategy ( strategy ) ; if ( strategy . isEnabled ( ) ) { this . builder . type ( EvictionType . COUNT ) . size ( MAX_ENTRIES . getDefinition ( ) . resolveModelAttribute ( context , model ) . asLong ( ) ) ; } return this ; }
response: public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.strategy(strategy).type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; }

sample: 1083
buggy_code: public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } }
code_review: `CompletableFuture<Boolean>` to avoid raw types
target code: public void closed ( BoltConnection connection ) { String id = connection . id ( ) ; try { CompletableFuture < Boolean > currentFuture = activeWorkItems . remove ( id ) ; if ( currentFuture != null ) { currentFuture . cancel ( true ) ; } } finally { activeConnections . remove ( id ) ; } }
response: public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture<Boolean> currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } }

sample: 1084
buggy_code: public void testIsExternalVM() throws IOException { try { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> }
code_review: https://i0.wp.com/100happybirthdaymemes.com/wp-content/uploads/2016/06/grumpy-cat-no-4.jpg In other words: throw the exception upwards and fail the test if parsing the XML fails.
target code: public void testIsExternalVM ( ) throws Exception { XmlDocument xmlDocument = new XmlDocument ( getXmlOvfData ( ) ) ; assertFalse ( "VM should not be external VM" , OvfUtils . isExternalVM ( xmlDocument ) ) ; }
response: public void testIsExternalVM() throws IOException { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> }

sample: 1085
buggy_code: public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> if (fileList == null) { return false; } for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; }
code_review: Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files
target code: public static boolean folderContains ( File folder , String filename ) { if ( folder == null ) { return false ; } File [ ] fileList = folder . listFiles ( ) ; if ( fileList == null ) { return false ; } for ( File f : fileList ) { if ( f . getName ( ) . equals ( filename ) ) { return true ; } } return false ; }
response: public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; }

sample: 1086
buggy_code: public void addWhiteListPatterns(String... patterns) { <START> this.whiteListPatterns.addAll(Arrays.asList(patterns)); <END> }
code_review: `Collections.addAll(whiteListPatterns, patterns)` can be used here.
target code: public void addWhiteListPatterns ( String . . . patterns ) { Collections . addAll ( this . whiteListPatterns , patterns ) ; }
response: public void addWhiteListPatterns(String... patterns) { <START> Collections.addAll(whiteListPatterns, patterns); <END> }

sample: 1087
buggy_code: private Long getRegistrationMillis(String playerName) { <START> if (!isRegistered(playerName.toLowerCase())) { <END> return null; } PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; }
code_review: I think that this check can be avoided as we already check if auth != null below
target code: private Long getRegistrationMillis ( String playerName ) { PlayerAuth auth = playerCache . getAuth ( playerName ) ; if ( auth == null ) { auth = dataSource . getAuth ( playerName ) ; } if ( auth != null ) { return auth . getRegistrationDate ( ) ; } return null ; }
response: private Long getRegistrationMillis(String playerName) { <START> PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; <END> }

sample: 1088
buggy_code: public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (numSegments < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; }
code_review: typo: capacityFactor instead of numSegments
target code: public HashConfigurationBuilder capacityFactor ( float capacityFactor ) { if ( capacityFactor < 0 ) throw new IllegalArgumentException ( "capacityFactor must be positive" ) ; this . capacityFactor = capacityFactor ; return this ; }
response: public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (capacityFactor < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; }

sample: 1089
buggy_code: public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } <START> allocateCurrentArray(); <END> }
code_review: This is not needed here
target code: public synchronized void onHeaders ( Response response ) { long length = response . getHeaders ( ) . getLongField ( HttpHeader . CONTENT_LENGTH . asString ( ) ) ; if ( length > maxLength ) { response . abort ( new ResponseTooLargeException ( ) ) ; } }
response: public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } allocateCurrentArray(); }

sample: 1090
buggy_code: public WorkspaceItem build() { try { return workspaceItem; <START> } catch (Exception e) { <END> return handleException(e); } }
code_review: The return statement can never throw an exception here. So please remove the try-catch block.
target code: public WorkspaceItem build ( ) { return workspaceItem ; }
response: public WorkspaceItem build() { return workspaceItem; <START> }

sample: 1091
buggy_code: <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); }
code_review: Why sorted map? TreeMap is sorted already?!
target code: public static SortedMap < String , Charset > requiredCharsets ( ) { return REQUIRED_CHARSETS ; }
response: <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); }

sample: 1092
buggy_code: protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED); <END> }
code_review: [minor] Split into two asserts or add a message showing what the offending value actually is?
target code: protected void checkProject ( Project project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . getProjectApi ( ) . getProject ( project . getId ( ) ) . toString ( ) ) ; assertTrue ( project . getState ( ) != null ) ; assertTrue ( project . getState ( ) != Project . State . UNRECOGNIZED ) ; }
response: protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue("Project state is null", project.getState() != null); assertTrue("Project state is UNRECOGNIZED", project.getState() != Project.State.UNRECOGNIZED); <END> }

sample: 1093
buggy_code: public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, GUID.create(), name, CoreBranches.COMMON, artifactType); <END> }
code_review: Please call ArtifactToken constructors without guid.
target code: public AtsProgramArtifactToken ( Long id , String name , ArtifactTypeToken artifactType ) { super ( id , name , CoreBranches . COMMON , artifactType ) ; }
response: public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, name, CoreBranches.COMMON, artifactType); <END> }

sample: 1094
buggy_code: public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> }
code_review: I think the deprecate is sufficient. Why also log a warning?
target code: public void setUseBulkWriteOperations ( final boolean useBulkWriteOperations ) { }
response: public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> }

sample: 1095
buggy_code: public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); }
code_review: When will this be false?
target code: public void setActionConfirmationMessage ( String message ) { boolean isNonEmptyMessage = message != null ; if ( isNonEmptyMessage ) { actionConfirmationMessage . setText ( message ) ; } }
response: public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); }

sample: 1096
buggy_code: public void close() throws InterruptedException { <START> close(false, false); <END> }
code_review: the second parameter can be removed
target code: public void close ( ) throws InterruptedException { close ( false ) ; }
response: public void close() throws InterruptedException { <START> close(false); <END> }

sample: 1097
buggy_code: protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb); } <START> } <END>
code_review: This class has a member variable called `indent` which will incur a data race in `recursivelyPrint`. This is easily fixable though by just making `indent` a parameter to `recursivelyPrint`. I realize it's debug-only code.
target code: protected void recursivelyPrint ( AbstractPlanNode node , StringBuilder sb ) { recursivelyPrint ( node , sb , 0 ) ; }
response: protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb, int indent) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb, indent); } <START> } <END>

sample: 1098
buggy_code: public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> if (logger.isDebugEnabled()) { <END> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); } }
code_review: if condition not needed.
target code: public void update ( int inputIndex ) { status . setTargetOutputRowCount ( super . update ( inputIndex , status . getOutPosition ( ) ) ) ; logger . debug ( "BATCH_STATS , incoming { } : { } " , inputIndex == 0 ? "left" : "right" , getRecordBatchSizer ( inputIndex ) ) ; }
response: public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); <END> }

sample: 1099
buggy_code: private int getNextPosition() throws CoreException { <START> if (nextMemberPosition == -1) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; }
code_review: Better: nextMemberPosition < 0
target code: private int getNextPosition ( ) throws CoreException { if ( nextMemberPosition < 0 ) { nextMemberPosition = 0 ; while ( nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord ( nextMemberPosition ) != 0 ) { nextMemberPosition ++ ; } } return nextMemberPosition ; }
response: private int getNextPosition() throws CoreException { <START> if (nextMemberPosition < 0) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; }

sample: 1100
buggy_code: public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", jobId, bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; }
code_review: nit: make `bulkRequest.numberOfActions()` a Supplier so it is only called if trace logging is enabled. ```suggestion logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); ```
target code: public BulkResponse executeRequest ( ) { if ( bulkRequest . numberOfActions ( ) == 0 ) { return null ; } logger . trace ( " [ { } ] ES API CALL : bulk request with { } actions" , ( ) - > jobId , ( ) - > bulkRequest . numberOfActions ( ) ) ; BulkResponse bulkResponse = resultsPersisterService . bulkIndexWithRetry ( bulkRequest , jobId , shouldRetry , msg - > auditor . warning ( jobId , "Bulk indexing of annotations failed " + msg ) ) ; bulkRequest = new BulkRequest ( AnnotationIndex . WRITE_ALIAS_NAME ) ; return bulkResponse ; }
response: public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; }

sample: 1101
buggy_code: public int size() { int size = 0; // We have to loop through to make sure to remove expired entries for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; }
code_review: isn't the iterator() excluding the expired and Tombstones?
target code: public int size ( ) { int size = 0 ; // We have to loop through to make sure to remove expired entries for ( Iterator < InternalCacheEntry < K , V > > iter = iterator ( ) ; iter . hasNext ( ) ; ) { iter . next ( ) ; if ( ++ size == Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return size ; }
response: public int size() { int size = 0; // We have to loop through to make sure to remove expired entries for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; }

sample: 1102
buggy_code: public static File getDiskCacheDir(Context context, String uniqueName) { // Check if media is mounted or storage is built-in, if so, try and use external cache dir // otherwise use internal cache dir. final String cachePath; <START> if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) <END> && context.getExternalCacheDir() != null) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); }
code_review: I'd prefer the old order so when Environment.getExternalStorageState() return null we don't get an NPE.
target code: public static File getDiskCacheDir ( Context context , String uniqueName ) { // Check if media is mounted or storage is built - in , if so , try and use external cache dir // otherwise use internal cache dir . final String cachePath ; if ( Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) && context . getExternalCacheDir ( ) != null ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return new File ( cachePath + File . separator + uniqueName ) ; }
response: public static File getDiskCacheDir(Context context, String uniqueName) { // Check if media is mounted or storage is built-in, if so, try and use external cache dir // otherwise use internal cache dir. final String cachePath; <START> if (context.getExternalCacheDir() != null && Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); }

sample: 1103
buggy_code: <START> String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); }
code_review: mark this method private as this is only used in this class.
target code: public static String getBucketName ( URI uri ) { if ( uri . getHost ( ) != null ) { return uri . getHost ( ) ; } if ( uri . getUserInfo ( ) == null ) { return uri . getAuthority ( ) ; } throw new IllegalArgumentException ( "Unable to determine S3 bucket from URI . " ) ; }
response: <START> private String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); }

sample: 1104
buggy_code: private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot)) <END> : new DefaultMustacheFactory(new PerClassMustacheResolver(key)); }
code_review: I think we could make this initialization more terse if we initialize `MustacheResolver` with the ternary operator and pass it to `DefaultMustacheFactory`. ```java new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)) ```
target code: private MustacheFactory createNewMustacheFactory ( Class < ? extends View > key ) { return new DefaultMustacheFactory ( fileRoot . isPresent ( ) ? new FileSystemResolver ( fileRoot . get ( ) ) : new PerClassMustacheResolver ( key ) ) ; }
response: private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)); <END> }

sample: 1105
buggy_code: public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && <START> !SystemElementsUtils.isSystemProtocol((Collaboration) eObject) && <END> !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; }
code_review: If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition.
target code: public boolean isValidValue ( final Object element ) { boolean result = super . isValidValue ( element ) ; if ( result ) { EObject eObject = EMFHelper . getEObject ( element ) ; result = ( ProtocolUtils . isProtocol ( eObject ) && ! SystemElementsUtils . isBaseProtocol ( ( Collaboration ) eObject ) ) ; } return result ; }
response: public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; }

sample: 1106
buggy_code: public void testLogin() throws Throwable { <START> InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); }
code_review: Very minor: consider another helper method for runOnMainSync() so we can focus on the interesting bit (loginTestTask.execute()). As a side note, executing from the main thread doesn't seem to be a requirement of "SaneAsyncTask" for whatever reason. However, it seems more proper to call execute on the main thread[0] since we think of it as a normal AsyncTask so I think we should keep it. [0] http://developer.android.com/reference/android/os/AsyncTask.html#execute(Params...)
target code: public void testLogin ( ) throws Throwable { runOnMainSync ( new Runnable ( ) { @Override public void run ( ) { loginTestTask . execute ( ) ; } } ) ; completionLatch . await ( ) ; }
response: public void testLogin() throws Throwable { <START> runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); }

sample: 1107
buggy_code: public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(), <END> ClientDnsLookup.USE_ALL_DNS_IPS); }
code_review: We don't need to call `toString()`
target code: public static void warnIfDeprecatedDnsLookupValue ( AbstractConfig config ) { String clientDnsLookupValue = config . getString ( CLIENT_DNS_LOOKUP_CONFIG ) ; if ( clientDnsLookupValue . equals ( ClientDnsLookup . DEFAULT . toString ( ) ) ) log . warn ( "Configuration ' { } ' with value ' { } ' is deprecated and will be removed in " + "future version . Please use ' { } ' or another non - deprecated value . " , CLIENT_DNS_LOOKUP_CONFIG , ClientDnsLookup . DEFAULT , ClientDnsLookup . USE_ALL_DNS_IPS ) ; }
response: public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT, <END> ClientDnsLookup.USE_ALL_DNS_IPS); }

sample: 1108
buggy_code: public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.getStats(); <END> }
code_review: I would like to remove the method getStats and would like to make the aggStats static.
target code: public HdfsCopyStats ( String source , File destination , boolean enableStatsFile , int maxVersionsStatsFile , boolean isFileCopy , HdfsPathInfo pathInfo ) { this . sourceFile = source ; this . totalBytesTransferred = 0L ; this . bytesTransferredSinceLastReport = 0L ; this . pathInfo = pathInfo ; this . lastReportNs = System . nanoTime ( ) ; this . startTimeMS = System . currentTimeMillis ( ) ; initializeStatsFile ( destination , enableStatsFile , maxVersionsStatsFile , isFileCopy ) ; }
response: public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.aggStats; <END> }

sample: 1109
buggy_code: private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId().toString())); <END> writer.writeEndElement(); }
code_review: toString() is not needed here, AFAIK.
target code: private void writeAlias ( VmDevice device ) { writer . writeStartElement ( "alias" ) ; writer . writeAttributeString ( "name" , String . format ( "ua - % s" , device . getId ( ) . getDeviceId ( ) ) ) ; writer . writeEndElement ( ) ; }
response: private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId())); <END> writer.writeEndElement(); }

sample: 1110
buggy_code: public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = checkNotNull(ImmutableList.copyOf(series)); <END> }
code_review: You shouldn't need the checkNotNull
target code: public ChartData ( IDataChartProvider < ? > provider , List < ChartSeries > series ) { fProvider = provider ; fSeries = ImmutableList . copyOf ( series ) ; }
response: public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = ImmutableList.copyOf(series); <END> }

sample: 1111
buggy_code: protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); <END> }
code_review: can this case be given? I mean having an entry for the given `uuid` but with no registrations?
target code: protected boolean isRegistered ( final String uuid ) { return handlers . containsKey ( uuid ) ; }
response: protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid); <END> }

sample: 1112
buggy_code: <START> public synchronized Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); }
code_review: @manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed.
target code: public Class < ? > defineClass ( String name , byte [ ] bytecode ) { return defineClass ( name , convertClassToResourcePath ( name ) , bytecode ) ; }
response: <START> public Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); }

sample: 1113
buggy_code: public boolean onOptionsItemSelected(MenuItem item) { // home references the app icon if (item.getItemId() == android.R.id.home) { toggle(); // toggles the state of the sliding menu <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; }
code_review: Could we get brackets around this if {}
target code: public boolean onOptionsItemSelected ( MenuItem item ) { // home references the app icon if ( item . getItemId ( ) == android . R . id . home ) { toggle ( ) ; // toggles the state of the sliding menu if ( getSlidingMenu ( ) . isMenuShowing ( ) && menu . isAdded ( ) ) { setTitle ( ( ( ITitleable ) menu ) . getTitle ( ) ) ; } return true ; } return false ; }
response: public boolean onOptionsItemSelected(MenuItem item) { // home references the app icon if (item.getItemId() == android.R.id.home) { toggle(); // toggles the state of the sliding menu <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) { <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; }

sample: 1114
buggy_code: public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> ex) { <END> throw new UncheckedIOException(ex); } }
code_review: super nit (okay to ignore): Here and below: For consistency, consider "e" rather than "ex". Typically we only use "ex" for nested catch blocks where the name "e" is already being used by the enclosing block.
target code: public static ParcelFileDescriptor fromSocket ( Socket socket ) { FileDescriptor fd = socket . getFileDescriptor$ ( ) ; try { return fd != null ? ParcelFileDescriptor . dup ( fd ) : null ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
response: public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> e) { <END> throw new UncheckedIOException(e); } }

sample: 1115
buggy_code: private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); //$NON-NLS-1$ if (prefix.length() == 0) { return null; } <START> return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path; <END> }
code_review: Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?
target code: private String getThemePrefixedPath ( String path ) { String prefix = themeProperties != null ? themeProperties . get ( IntroTheme . ATT_ID ) : null ; prefix = prefix == null ? "" : prefix . trim ( ) ; // $NON - NLS - 1$ if ( prefix . length ( ) == 0 ) { return null ; } return prefix + Path . SEPARATOR + path ; }
response: private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); //$NON-NLS-1$ if (prefix.length() == 0) { return null; } <START> return prefix + Path.SEPARATOR + path; <END> }

sample: 1116
buggy_code: protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> m_os.write(bytes); <END> }
code_review: what about the null case?
target code: protected void writeString ( int majorType , byte [ ] bytes ) throws IOException { int len = ( bytes == null ) ? 0 : bytes . length ; writeType ( majorType , len ) ; if ( len > 0 ) { m_os . write ( bytes ) ; } }
response: protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> if (bytes != null) { m_os.write(bytes); } <END> }

sample: 1117
buggy_code: private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } else if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END>
code_review: extra `else` statement, please remove
target code: private void checkLogData ( long address , ILogData logData ) { if ( logData == null || logData . getType ( ) == DataType . EMPTY ) { throw new RuntimeException ( "Unexpected return of empty data at address " + address + " on read" ) ; } if ( logData . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } }
response: private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END>

sample: 1118
buggy_code: private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), <END> sourceSelfTime); // merge the children callees. mergeChildren(destination, source); }
code_review: - space after comma - you need to pass the source duration as well
target code: private static void merge ( AggregatedCalledFunction destination , AggregatedCalledFunction source ) { long sourceDuration = source . getDuration ( ) ; long sourceSelfTime = source . getSelfTime ( ) ; destination . addToDuration ( sourceDuration ) ; destination . addToSelfTime ( sourceSelfTime ) ; destination . fStatistics . update ( source . fStatistics . getMaxSegment ( ) , source . fStatistics . getMinSegment ( ) , sourceDuration , sourceSelfTime ) ; // merge the children callees . mergeChildren ( destination , source ) ; }
response: private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(), source.fStatistics.getMinSegment(), sourceDuration, <END> sourceSelfTime); // merge the children callees. mergeChildren(destination, source); }

sample: 1119
buggy_code: @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); <END> } return null; }); }
code_review: Think this needs to go right below line 91. `parseResponse` can return `null` (line 133), which will cause this future to never complete.
target code: @Override protected void doEnqueue ( Callback < V > callback ) { sendRequest ( ) . handle ( ( response , t ) - > { if ( t != null ) { callback . onError ( t ) ; } else { try { V value = parseResponse ( response , bodyConverter ) ; callback . onSuccess ( value ) ; } catch ( Throwable t1 ) { propagateIfFatal ( t1 ) ; callback . onError ( t1 ) ; } } return null ; } ) ; }
response: @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); else callback.onError(new IllegalStateException("parseResponse returned null")); <END> } return null; }); }

sample: 1120
buggy_code: public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } return t; }
code_review: if (!isExplicit) { // ... around the try
target code: public SpiTransaction createServerTransaction ( boolean isExplicit , int isolationLevel ) { SpiTransaction t = transactionManager . createTransaction ( isExplicit , isolationLevel ) ; if ( isExplicit ) { try { transactionScopeManager . set ( t ) ; } catch ( PersistenceException existingTransactionError ) { t . end ( ) ; throw existingTransactionError ; } } return t ; }
response: public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); if (!isExplicit) { <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } } return t; }

sample: 1121
buggy_code: C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.put(t, child); <START> return child; <END> } else return children.get(t); }
code_review: What about thread safety here? I might be mistaken, but by just looking at this code snippet it looks like more than one thread could check the condition, receive `false` from the `contains()` method and execute the above code block. That might be the reason the blocking `putIfAbsent` method is used here?
target code: C baseApply ( ) { final TreeMap < String , String > t = new TreeMap < String , String > ( validate ( ) ) ; C child = children . get ( t ) ; if ( child == null ) { child = newChild ( ) ; children . put ( t , child ) ; } return child ; }
response: C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.putIfAbsent(t, child); <START> return child; <END> } else return children.get(t); }

sample: 1122
buggy_code: public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.startListeningForDirection(); <END> }
code_review: i'd maybe just "forward" the `onConnect` to the presenter instead
target code: public void onConnect ( String message ) { debugView . showPermanently ( getString ( R . string . connected ) ) ; switchableView . setDisplayedChild ( 1 ) ; }
response: public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.onConnect(message); <END> }

sample: 1123
buggy_code: public ByteBuffer[] nioBuffers(int index, int length) { if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) { return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() }; } <START> return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); <END> }
code_review: yup, this is incorrect, seems I failed somewhere, this logic has to be in `public ByteBuffer[] nioBuffers()`, gonna change it
target code: public ByteBuffer [ ] nioBuffers ( int index , int length ) { return new ByteBuffer [ ] { nioBuffer ( index , length ) } ; }
response: public ByteBuffer[] nioBuffers(int index, int length) { if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) { return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() }; } return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); }

sample: 1124
buggy_code: <START> public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { <END> this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors); }
code_review: why the instance-level lock suggestion, vs. what's been implemented here. seems like overkill
target code: public void setDisabledAdministrativeMonitors ( Set < String > disabledAdministrativeMonitors ) { synchronized ( this . disabledAdministrativeMonitors ) { this . disabledAdministrativeMonitors . clear ( ) ; this . disabledAdministrativeMonitors . addAll ( disabledAdministrativeMonitors ) ; } }
response: <START> public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { <END> this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors); }

sample: 1125
buggy_code: <START> public boolean waitUntilReadyToProcess(Properties jobProps) { <END> return true; }
code_review: Is this method going to be overridden in a subclass to provide a different behavior? This method can be protected if is not supposed to be overridden outside the package.
target code: protected boolean waitUntilReadyToProcess ( Properties jobProps ) { return true ; }
response: <START> protected boolean waitUntilReadyToProcess(Properties jobProps) { <END> return true; }

sample: 1126
buggy_code: private ArrayList<Comment> fetchAllComments(ArticleTable article) { <START> return (ArrayList<Comment>) hibernateTemplate.find("FROM Comment WHERE articleId = ?", article.getArticleId()); <END> }
code_review: Casting to `ArrayList` is brittle. Could we return `List<>` from here instead?
target code: private List < Comment > fetchAllComments ( ArticleTable article ) { return ( ArrayList < Comment > ) hibernateTemplate . find ( "FROM Comment WHERE articleId = ? " , article . getArticleId ( ) ) ; }
response: private List<Comment> fetchAllComments(ArticleTable article) { <START> return (ArrayList<Comment>) hibernateTemplate.find("FROM Comment WHERE articleId = ?", article.getArticleId()); <END> }

sample: 1127
buggy_code: <START> public String getPreview() { <END> StringBuilder bld= new StringBuilder(); bld.append("\n"); if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) { bld.append("long number1 = 10L;\n"); bld.append("float number2 = 10F;\n"); bld.append("double number3 = 10D;\n"); } else { bld.append("long number1 = 10l;\n"); bld.append("float number2 = 10f;\n"); bld.append("double number3 = 10d;\n"); } return bld.toString(); }
code_review: Missed this one in the previous review, needs updating as well!
target code: public String getPreview ( ) { StringBuilder bld = new StringBuilder ( ) ; bld . append ( "\n" ) ; if ( isEnabled ( CleanUpConstants . NUMBER_SUFFIX ) ) { bld . append ( "long number1 = 10L ; \n" ) ; } else { bld . append ( "long number1 = 10l ; \n" ) ; } return bld . toString ( ) ; }
response: <START> public String getPreview() { <END> StringBuilder bld= new StringBuilder(); bld.append("\n"); if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) { bld.append("long number1 = 10L;\n"); bld.append("float number2 = 10F;\n"); bld.append("double number3 = 10D;\n"); } else { bld.append("long number1 = 10l;\n"); bld.append("float number2 = 10f;\n"); bld.append("double number3 = 10d;\n"); } return bld.toString(); }

sample: 1128
buggy_code: private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) { int size = msg.getSerializedSize(); ByteBuf buf = allocator.heapBuffer(size, size); try { <START> msg.writeTo(new ByteBufOutputStream(buf)); <END> } catch (IOException e) { // This is in-memory serialization, should not fail throw new RuntimeException(e); } // Advance writer idx buf.writerIndex(buf.capacity()); return buf; }
code_review: Is this a race or corruption happens all the time? Change looks fine, but I did not understand the actual issue with the current code on why corruption happening.
target code: private static ByteBuf serializeProtobuf ( MessageLite msg , ByteBufAllocator allocator ) { int size = msg . getSerializedSize ( ) ; ByteBuf buf = allocator . heapBuffer ( size , size ) ; try { msg . writeTo ( new ByteBufOutputStream ( buf ) ) ; } catch ( IOException e ) { // This is in - memory serialization , should not fail throw new RuntimeException ( e ) ; } return buf ; }
response: private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) { int size = msg.getSerializedSize(); ByteBuf buf = allocator.heapBuffer(size, size); try { <START> msg.writeTo(new ByteBufOutputStream(buf)); <END> } catch (IOException e) { // This is in-memory serialization, should not fail throw new RuntimeException(e); } return buf; }

sample: 1129
buggy_code: public void testEncodeOutputControl() { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder(); Command command = new Command(); command.setDeviceId(1); command.setType(Command.TYPE_OUTPUT_CONTROL); command.set(Command.KEY_INDEX, 0); <START> command.set(Command.KEY_DATA, "1"); <END> assertEquals("(123456789012345AV001)", encoder.encodeCommand(command)); }
code_review: Is this the value we use for all other protocols?
target code: public void testEncodeOutputControl ( ) { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder ( ) ; Command command = new Command ( ) ; command . setDeviceId ( 1 ) ; command . setType ( Command . TYPE_OUTPUT_CONTROL ) ; command . set ( Command . KEY_DATA , "1" ) ; assertEquals ( " ( 123456789012345AV001 ) " , encoder . encodeCommand ( command ) ) ; }
response: public void testEncodeOutputControl() { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder(); Command command = new Command(); command.setDeviceId(1); command.setType(Command.TYPE_OUTPUT_CONTROL); command.set(Command.KEY_INDEX, 0); <START> command.set(Command.KEY_DATA, "1"); <END> assertEquals("(123456789012345AV001)", encoder.encodeCommand(command)); }

sample: 1130
buggy_code: void cancel() { super.cancel(); <START> if (callback != null) { <END> callback = null; } }
code_review: No `if` check needed, just always set the reference to `null`.
target code: @Override void cancel ( ) { super . cancel ( ) ; callback = null ; }
response: void cancel() { super.cancel(); <START> callback = null; <END> }

sample: 1131
buggy_code: public void cancel() { try { Field field = FileWatchdog.class.getDeclaredField("interrupted"); field.setAccessible(true); field.set(this, true); } catch (ReflectiveOperationException cause) { <START> throw new Error("Cannot cancel log4j watchdog", cause); <END> } }
code_review: `new Error` -> `new RuntimeException`
target code: public void cancel ( ) { try { Field field = FileWatchdog . class . getDeclaredField ( "interrupted" ) ; field . setAccessible ( true ) ; field . set ( this , true ) ; } catch ( ReflectiveOperationException cause ) { throw new RuntimeException ( "Cannot cancel log4j watchdog" , cause ) ; } }
response: public void cancel() { try { Field field = FileWatchdog.class.getDeclaredField("interrupted"); field.setAccessible(true); field.set(this, true); } catch (ReflectiveOperationException cause) { <START> throw new RuntimeException("Cannot cancel log4j watchdog", cause); <END> } }

sample: 1132
buggy_code: public static boolean isEditAllowed(@NonNull PageTitle title) { return <START> Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); <END> }
code_review: Very minor: it's probably cleaner just to initialized ENABLED_LANGUAGES using Arrays.asList
target code: public static boolean isEditAllowed ( @NonNull PageTitle title ) { return ENABLED_LANGUAGES . contains ( title . getWikiSite ( ) . languageCode ( ) ) ; }
response: public static boolean isEditAllowed(@NonNull PageTitle title) { return <START> Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); <END> }

sample: 1133
buggy_code: private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException { byte[] bytes = baos.toByteArray(); baos.reset(); <START> int testMessageNo = 1; <END> PacketFormat format = new PacketFormat(testMessageNo, bytes); format.serialize(baos); return new ByteArrayInputStream(baos.toByteArray()); }
code_review: Why is this hardcoded? and why is it 1 not 0?
target code: private InputStream simulateSendAndReceive ( ByteArrayOutputStream baos ) throws IOException { return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; }
response: private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException { byte[] bytes = baos.toByteArray(); baos.reset(); <START> int testMessageNo = 0; <END> PacketFormat format = new PacketFormat(testMessageNo, bytes); format.serialize(baos); return new ByteArrayInputStream(baos.toByteArray()); }

sample: 1134
buggy_code: public ShovingMatch(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, "{2}{U}"); // Until end of turn, all creatures gain "{tap}: Tap target creature." <START> Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost()); <END> ability.addTarget(new TargetCreaturePermanent()); this.getSpellAbility().addEffect( new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent()) .setText("Until end of turn, all creatures gain \"{T}: Tap target creature.\"") ); }
code_review: This wasn't necessary, I was using the constructor I added that defaults to battlefield because most activated abilities are on the battlefield anyway. It doesn't really matter, I just figured I'd mention it.
target code: public ShovingMatch ( UUID ownerId , CardSetInfo setInfo ) { super ( ownerId , setInfo , new CardType [ ] { CardType . INSTANT } , " { 2 } { U } " ) ; // Until end of turn , all creatures gain " { tap } : Tap target creature . " Ability ability = new SimpleActivatedAbility ( new TapTargetEffect ( ) , new TapSourceCost ( ) ) ; ability . addTarget ( new TargetCreaturePermanent ( ) ) ; this . getSpellAbility ( ) . addEffect ( new GainAbilityAllEffect ( ability , Duration . EndOfTurn , new FilterCreaturePermanent ( ) ) . setText ( "Until end of turn , all creatures gain \" { T } : Tap target creature . \"" ) ) ; }
response: public ShovingMatch(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, "{2}{U}"); // Until end of turn, all creatures gain "{tap}: Tap target creature." <START> Ability ability = new SimpleActivatedAbility(new TapTargetEffect(), new TapSourceCost()); <END> ability.addTarget(new TargetCreaturePermanent()); this.getSpellAbility().addEffect( new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent()) .setText("Until end of turn, all creatures gain \"{T}: Tap target creature.\"") ); }

sample: 1135
buggy_code: public void testCompareRanges() { <START> assertTrue(compareRanges("abcdefghij".getBytes(), 0, 10, "abcdefghij".getBytes(), 0, 10) == 0); <END> assertTrue(compareRanges("123abcdefghij".getBytes(), 3, 10, "abcdefghij".getBytes(), 0, 10) == 0); }
code_review: Use `assertEquals`
target code: public void testCompareRanges ( ) { assertEquals ( compareRanges ( "abcdefghij" . getBytes ( ) , 0 , 10 , "abcdefghij" . getBytes ( ) , 0 , 10 ) , 0 ) ; assertEquals ( compareRanges ( "123abcdefghij" . getBytes ( ) , 3 , 10 , "abcdefghij" . getBytes ( ) , 0 , 10 ) , 0 ) ; }
response: public void testCompareRanges() { <START> assertEquals(compareRanges("abcdefghij".getBytes(), 0, 10, "abcdefghij".getBytes(), 0, 10), 0); <END> assertTrue(compareRanges("123abcdefghij".getBytes(), 3, 10, "abcdefghij".getBytes(), 0, 10) == 0); }

sample: 1136
buggy_code: public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){ this.paymentDate = paymentDate; this.timeframe = timeframe; this.requestedAmount = requestedAmount; //??? if(build){ this.build = build; }else{ <START> this.building = build; <END> } }
code_review: Verificar necessidade desse else
target code: public void setRequiredParametersForCreation ( DateTime paymentDate , Timeframe timeframe , Integer requestedAmount , Boolean build ) { this . paymentDate = paymentDate ; this . timeframe = timeframe ; this . requestedAmount = requestedAmount ; if ( build ) { this . build = build ; } }
response: public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){ this.paymentDate = paymentDate; this.timeframe = timeframe; this.requestedAmount = requestedAmount; //??? if(build){ this.build = build; }else{ <START> this.building = build; <END> } } <START> <END>

sample: 1137
buggy_code: public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) <START> throws Exception <END> { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }
code_review: unnecessary `throws` (same for the constructor above).
target code: public TestElasticsearchIntegrationSmokeTest ( EmbeddedElasticsearchNode embeddedElasticsearchNode ) { super ( ( ) - > createElasticsearchQueryRunner ( embeddedElasticsearchNode , TpchTable . getTables ( ) ) ) ; this . embeddedElasticsearchNode = embeddedElasticsearchNode ; }
response: public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }

sample: 1138
buggy_code: public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> if (help) { <END> commandInvocation.println(commandInvocation.getHelpInfo()); } return CommandResult.SUCCESS; }
code_review: print help all the time? the command `> server` alone isn't valid.
target code: public CommandResult exec ( ContextAwareCommandInvocation commandInvocation ) { commandInvocation . println ( commandInvocation . getHelpInfo ( ) ) ; return CommandResult . SUCCESS ; }
response: public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> commandInvocation.println(commandInvocation.getHelpInfo()); <END> return CommandResult.SUCCESS; }

sample: 1139
buggy_code: for (OsType type : OsType.values()) { <START> osTypeValues.add(type.value().toLowerCase()); <END> }
code_review: .value() returns .name().toLowerCase()
target code: for ( OsType type : OsType . values ( ) ) { osTypeValues . add ( type . value ( ) ) ; }
response: for (OsType type : OsType.values()) { <START> osTypeValues.add(type.value()); <END> }

sample: 1140
buggy_code: private Menu fillMenu(Menu m) { for (IAction action : getActions()) { IContributionItem item; String actionText = action.getText(); if (actionText == null || actionText.isEmpty()) { item = new Separator(); } else { item = new ActionContributionItem(action); <START> } <END> item.fill(m, -1); } return m; }
code_review: Why don't you change getAction() to return a Collection<ContributionItem>?
target code: private Menu fillMenu ( Menu m ) { for ( IContributionItem item : getActions ( ) ) { item . fill ( m , - 1 ) ; } return m ; }
response: private Menu fillMenu(Menu m) { for (IAction action : getActions()) { IContributionItem item; String actionText = action.getText(); if (actionText == null || actionText.isEmpty()) { item = new Separator(); } else { item = new ActionContributionItem(action); <START> } <END> item.fill(m, -1); } return m; }

sample: 1141
buggy_code: public void testThreadNameWithoutNumberNoDemon() { <START> Assert.assertEquals(ThreadUtils.createThreadFactory(THREAD_NAME, false). <END> newThread(EMPTY_RUNNABLE).getName(), THREAD_NAME); }
code_review: In all `assert` method, the first argument is the "expected" value while the second one is the "actual" value. Can you swap them in this file to match that definition?
target code: public void testThreadNameWithoutNumberNoDemon ( ) { assertEquals ( THREAD_NAME , ThreadUtils . createThreadFactory ( THREAD_NAME , false ) . newThread ( EMPTY_RUNNABLE ) . getName ( ) ) ; }
response: public void testThreadNameWithoutNumberNoDemon() { <START> Assert.assertEquals(THREAD_NAME, ThreadUtils.createThreadFactory(THREAD_NAME, false). <END> newThread(EMPTY_RUNNABLE).getName()); }

sample: 1142
buggy_code: public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) { //noinspection unchecked <START> return (ModelAdaptor<T>) adaptors.get(attributeType); <END> }
code_review: ```suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType); ```
target code: public < T > ModelAdaptor < ? super T > getModelAdaptor ( Class < T > attributeType ) { // noinspection unchecked return ( ModelAdaptor < ? super T > ) adaptors . get ( attributeType ) ; }
response: public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) { //noinspection unchecked <START> return (ModelAdaptor<? super T>) adaptors.get(attributeType); <END> }

sample: 1143
buggy_code: public com.google.gwtorm.client.Key<?>[] members() { <START> return new com.google.gwtorm.client.Key<?>[] {accountId, patchKey}; <END> }
code_review: If you override accountId then the parentKey is automatically a member, and this needs to only include the patchKey.
target code: public com . google . gwtorm . client . Key < ? > [ ] members ( ) { return new com . google . gwtorm . client . Key < ? > [ ] { patchKey } ; }
response: public com.google.gwtorm.client.Key<?>[] members() { <START> return new com.google.gwtorm.client.Key<?>[] {patchKey}; <END> }

sample: 1144
buggy_code: public void init(final RuleModellerPage page) { this.page = page; if (page.plugin() instanceof BRLActionColumnPlugin) { <START> <END> } }
code_review: If it is then do what exactly? If we don't want to do anything do we need this ```if(..)``` block at all?
target code: public void init ( final RuleModellerPage page ) { this . page = page ; }
response: public void init(final RuleModellerPage page) { this.page = page; if (page.plugin() instanceof BRLActionColumnPlugin) { <START>this.brlActionColumnPlugin = (BRLActionColumnPlugin) page.plugin();<END> } }

sample: 1145
buggy_code: <START> @Override public TaskResult syncShards() { <END> return periodicShardSyncManager.start(); }
code_review: nit: Could you have `Override` in its own line.
target code: public TaskResult syncShards ( ) { return periodicShardSyncManager . start ( ) ; }
response: <START> @Override public TaskResult syncShards() { <END> return periodicShardSyncManager.start(); }

sample: 1146
buggy_code: static <T> List<T> without(List<T> list, Collection<Integer> indexes) { Set<Integer> indexesSet = ImmutableSet.copyOf(indexes); return IntStream.range(0, list.size()) .filter(index -> !indexesSet.contains(index)) <START> .mapToObj(ImmutableList.copyOf(list)::get) <END> .collect(toImmutableList()); }
code_review: Drop this `ImmutableList.copyOf` wrapper. It reduces clarity and we do expect random-access lists here anyway.
target code: static < T > List < T > without ( List < T > list , Collection < Integer > indexes ) { Set < Integer > indexesSet = ImmutableSet . copyOf ( indexes ) ; return IntStream . range ( 0 , list . size ( ) ) . filter ( index - > ! indexesSet . contains ( index ) ) . mapToObj ( list : : get ) . collect ( toImmutableList ( ) ) ; }
response: static <T> List<T> without(List<T> list, Collection<Integer> indexes) { Set<Integer> indexesSet = ImmutableSet.copyOf(indexes); return IntStream.range(0, list.size()) .filter(index -> !indexesSet.contains(index)) <START> .mapToObj(list::get) <END> .collect(toImmutableList()); }

sample: 1147
buggy_code: private Throwable getRealException(Throwable re) { if (re.getCause() == null) return re; Throwable cause = re.getCause(); <START> if (cause instanceof CacheException || cause instanceof RuntimeException || cause instanceof Error) <END> return getRealException(cause); else return re; }
code_review: CacheException instanceOf RuntimeException, I guess you can simplify here.
target code: private Throwable getRealException ( Throwable re ) { if ( re . getCause ( ) == null ) return re ; Throwable cause = re . getCause ( ) ; if ( cause instanceof RuntimeException || cause instanceof Error ) return getRealException ( cause ) ; else return re ; }
response: private Throwable getRealException(Throwable re) { if (re.getCause() == null) return re; Throwable cause = re.getCause(); <START> if (cause instanceof CacheException || cause instanceof Error) <END> return getRealException(cause); else return re; }

sample: 1148
buggy_code: public void layoutIfNecessary() { if (dirtySize != null && control != null && control instanceof Composite) { if (control.getSize().equals(dirtySize)) { <START> ((Composite) control).layout(); <END> flushChildren = false; } } dirtySize = null; }
code_review: What does this change do?
target code: public void layoutIfNecessary ( ) { if ( dirtySize != null && control != null && control instanceof Composite ) { if ( control . getSize ( ) . equals ( dirtySize ) ) { ( ( Composite ) control ) . layout ( flushChildren ) ; flushChildren = false ; } } dirtySize = null ; }
response: public void layoutIfNecessary() { if (dirtySize != null && control != null && control instanceof Composite) { if (control.getSize().equals(dirtySize)) { <START> ((Composite) control).layout(); <END> flushChildren = false; } } dirtySize = null; }

sample: 1149
buggy_code: public Attribute setLabelAttribute(Boolean isLabelAttr) { set(IS_LABEL_ATTRIBUTE, isLabelAttr); <START> if (isLabelAttr != null && isLabelAttr) <END> { setNillable(false); } return this; }
code_review: We ususally don't put the logic in the entity class. Will be confusing that this setter has side effects: `addAttribute("blah").setNillable(true).setLabelAttribute(true)`
target code: public Attribute setLabelAttribute ( Boolean isLabelAttr ) { set ( IS_LABEL_ATTRIBUTE , isLabelAttr ) ; return this ; }
response: public Attribute setLabelAttribute(Boolean isLabelAttr) { set(IS_LABEL_ATTRIBUTE, isLabelAttr); <START> if (isLabelAttr != null && isLabelAttr) <END> { setNillable(false); } return this; }

sample: 1150
buggy_code: public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof IntegrationEvaluationContextAware) { StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); if (bean instanceof IntegrationObjectSupport) { ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService(); <START> if (conversionService != null) { <END> evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService)); } } ((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext); } return bean; }
code_review: So, maybe just remove this code for now? And keep in mind it. However I remember this one: https://github.com/SpringSource/spring-integration/pull/827#issuecomment-20274110 I mean to rely just only on 'system-wide conversion service', not from endpoint.
target code: public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { if ( bean instanceof IntegrationEvaluationContextAware ) { StandardEvaluationContext evaluationContext = IntegrationContextUtils . getEvaluationContext ( this . beanFactory ) ; ( ( IntegrationEvaluationContextAware ) bean ) . setIntegrationEvaluationContext ( evaluationContext ) ; } return bean ; }
response: public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof IntegrationEvaluationContextAware) { StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); if (bean instanceof IntegrationObjectSupport) { ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService(); if (conversionService != null) { evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService)); } } ((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext); } return bean; }

sample: 1151
buggy_code: public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X { Handle h = JdbiUtil.getHandle(jdbi); R result = callback.withHandle(h); // close if not in transaction <START> JdbiUtil.closeIfNeeded(h); <END> return result; }
code_review: I believe we shouldn't close the handle here. It will be closed in the `afterCompletion` method. I think also it will probably be ignored because the handle is still binded to the active transaction.
target code: public < R , X extends Exception > R withHandle ( HandleCallback < R , X > callback ) throws X { Handle h = JdbiUtil . getHandle ( jdbi ) ; try { return callback . withHandle ( h ) ; } finally { JdbiUtil . closeIfNeeded ( h ) ; } }
response: public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X { Handle h = JdbiUtil.getHandle(jdbi); R result = callback.withHandle(h); return result; }

sample: 1152
buggy_code: <START> public LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition, <END> @Nullable IPath initialPath) { this.initialProject = project; this.initialPath = initialPath; this.allWatchedProjects = new HashSet<>(); this.serverDefinition = serverDefinition; this.connectedDocuments = new HashMap<>(); }
code_review: In this case, shouldn't we getrid of the project parameter here (if we know the project, we shouldn't specify an extra initial path, or we should explicitly use the initial path.
target code: private LanguageServerWrapper ( @Nullable IProject project , @NonNull LanguageServerDefinition serverDefinition , @Nullable IPath initialPath ) { this . initialProject = project ; this . initialPath = initialPath ; this . allWatchedProjects = new HashSet < > ( ) ; this . serverDefinition = serverDefinition ; this . connectedDocuments = new HashMap < > ( ) ; }
response: <START> public LanguageServerWrapper(@NonNull LanguageServerDefinition serverDefinition, <END> @Nullable IPath initialPath) { this.initialProject = project; this.initialPath = initialPath; this.allWatchedProjects = new HashSet<>(); this.serverDefinition = serverDefinition; this.connectedDocuments = new HashMap<>(); }

sample: 1153
buggy_code: public String getReplicaPath() { // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers. <START> return getMountPath() + File.separator + GetRequest.Cloud_Replica_Keyword + File.separator <END> + partitionId.toPathString(); }
code_review: minor: would prefer that `Cloud_Replica_Keyword` comes before mount path since that would order the path from least to most granular
target code: public String getReplicaPath ( ) { // GetRequest . Cloud_Replica_Keyword is added to avoid error on its peers . return GetRequest . Cloud_Replica_Keyword + File . separator + getMountPath ( ) + File . separator + partitionId . toPathString ( ) ; }
response: public String getReplicaPath() { // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers. <START> return GetRequest.Cloud_Replica_Keyword + File.separator + getMountPath() + File.separator <END> + partitionId.toPathString(); }

sample: 1154
buggy_code: public void addChildren(AlluxioURI path, Collection<UfsStatus> children) { UfsStatus status = mStatuses.get(path); // If this path doesn't yet exist, we can't keep track of the parent-child relationship // We can still add statuses to the cache regardless <START> if (status != null) { <END> mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children); } children.forEach(child -> { AlluxioURI childPath = path.joinUnsafe(child.getName()); addStatus(childPath, child); }); }
code_review: Why can't we add this parent->children listing cache even if the parent status is not in the other map?
target code: public Collection < UfsStatus > addChildren ( AlluxioURI path , Collection < UfsStatus > children ) { ConcurrentHashSet < UfsStatus > set = new ConcurrentHashSet < > ( ) ; children . forEach ( child - > { AlluxioURI childPath = path . joinUnsafe ( child . getName ( ) ) ; addStatus ( childPath , child ) ; set . add ( child ) ; } ) ; return mChildren . put ( path , set ) ; }
response: public void addChildren(AlluxioURI path, Collection<UfsStatus> children) { UfsStatus status = mStatuses.get(path); // If this path doesn't yet exist, we can't keep track of the parent-child relationship // We can still add statuses to the cache regardless <START> if (status != null) { <END> mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children); } children.forEach(child -> { AlluxioURI childPath = path.joinUnsafe(child.getName()); addStatus(childPath, child); }); }

sample: 1155
buggy_code: private void actionCompleted(SegmentHolder segmentHolder) { switch (segmentHolder.getType()) { case LOAD: segmentsToLoad.remove(segmentHolder.getSegment()); queuedSize.addAndGet(-segmentHolder.getSegmentSize()); break; case DROP: segmentsToDrop.remove(segmentHolder.getSegment()); break; default: throw new UnsupportedOperationException(); } callBackExecutor.execute( <START> () -> executeCallbacks(segmentHolder) <END> ); }
code_review: Pointless two level submission. `executeCallbacks()` submits each callback to itself another one time (this means that it's valuable to annotate each method in this class in which executor it's supposed to be run. Given that there are two different executors, plus "external", client code execution context (which we kind of shouldn't know where runs)
target code: private void actionCompleted ( SegmentHolder segmentHolder ) { switch ( segmentHolder . getType ( ) ) { case LOAD : segmentsToLoad . remove ( segmentHolder . getSegment ( ) ) ; queuedSize . addAndGet ( - segmentHolder . getSegmentSize ( ) ) ; break ; case DROP : segmentsToDrop . remove ( segmentHolder . getSegment ( ) ) ; break ; default : throw new UnsupportedOperationException ( ) ; } executeCallbacks ( segmentHolder ) ; }
response: private void actionCompleted(SegmentHolder segmentHolder) { switch (segmentHolder.getType()) { case LOAD: segmentsToLoad.remove(segmentHolder.getSegment()); queuedSize.addAndGet(-segmentHolder.getSegmentSize()); break; case DROP: segmentsToDrop.remove(segmentHolder.getSegment()); break; default: throw new UnsupportedOperationException(); } executeCallbacks(segmentHolder); }

sample: 1156
buggy_code: public ScheduledReporter build(MetricRegistry registry) { GraphiteReporter.Builder builder = builder(registry); <START> if ("udp".equalsIgnoreCase(this.transport)) { <END> return builder.build(new GraphiteUDP(host, port)); } else { return builder.build(new Graphite(host, port)); } }
code_review: Is `this` needed here? If not, consider dropping it.
target code: public ScheduledReporter build ( MetricRegistry registry ) { GraphiteReporter . Builder builder = builder ( registry ) ; if ( "udp" . equalsIgnoreCase ( transport ) ) { return builder . build ( new GraphiteUDP ( host , port ) ) ; } else { return builder . build ( new Graphite ( host , port ) ) ; } }
response: public ScheduledReporter build(MetricRegistry registry) { GraphiteReporter.Builder builder = builder(registry); <START> if ("udp".equalsIgnoreCase(transport)) { <END> return builder.build(new GraphiteUDP(host, port)); } else { return builder.build(new Graphite(host, port)); } }

sample: 1157
buggy_code: public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) { setStatusForOpponent(userId, getString(R.string.text_status_hang_up)); Log.d(TAG, "onReceiveHangUpFromUser userId= " + userId); if (!isPeerToPeerCall) { if (userId == userIDFullScreen) { Log.d(TAG, "setAnotherUserToFullScreen call userId= " + userId); setAnotherUserToFullScreen(); } <START> if (videoTrackMap != null && videoTrackMap.containsKey(userId)) { <END> Log.d(TAG, "onReceiveHangUpFromUser videoTrackMap.remove(userId)= " + userId); videoTrackMap.remove(userId); } } }
code_review: опять копипаст) у тебя ж сверху в onConnectionClosedForUser точно такой код, И вообще если мы удаляем в onConnectionClosedForUser , то зачем еще здесь? onConnectionClosedForUser в любом случае срабатывает когда с юзером связь остаточно закрылась,
target code: public void onReceiveHangUpFromUser ( QBRTCSession session , Integer userId ) { setStatusForOpponent ( userId , getString ( R . string . text_status_hang_up ) ) ; Log . d ( TAG , "onReceiveHangUpFromUser userId = " + userId ) ; if ( ! isPeerToPeerCall ) { if ( userId == userIDFullScreen ) { Log . d ( TAG , "setAnotherUserToFullScreen call userId = " + userId ) ; setAnotherUserToFullScreen ( ) ; } } }
response: public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) { setStatusForOpponent(userId, getString(R.string.text_status_hang_up)); Log.d(TAG, "onReceiveHangUpFromUser userId= " + userId); if (!isPeerToPeerCall) { if (userId == userIDFullScreen) { Log.d(TAG, "setAnotherUserToFullScreen call userId= " + userId); setAnotherUserToFullScreen(); } } }

sample: 1158
buggy_code: private boolean isThis(ExpressionTree expression) { <START> ExpressionTree expressionNoParenthesis = (ExpressionUtils.skipParentheses(expression)); <END> if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) { String targetName = ((IdentifierTree) expressionNoParenthesis).name(); return "this".equals(targetName); } return false; }
code_review: useless parentheses
target code: private boolean isThis ( ExpressionTree expression ) { ExpressionTree expressionNoParenthesis = ExpressionUtils . skipParentheses ( expression ) ; if ( expressionNoParenthesis . is ( Tree . Kind . IDENTIFIER ) ) { String targetName = ( ( IdentifierTree ) expressionNoParenthesis ) . name ( ) ; return "this" . equals ( targetName ) ; } return false ; }
response: private boolean isThis(ExpressionTree expression) { <START> ExpressionTree expressionNoParenthesis = ExpressionUtils.skipParentheses(expression); <END> if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) { String targetName = ((IdentifierTree) expressionNoParenthesis).name(); return "this".equals(targetName); } return false; }

sample: 1159
buggy_code: protected Map<String, Queue> getQueueNamesToQueues() { return this.queues.stream() <START> .collect(Collectors.toMap(q -> q.getActualName(), q -> q)); <END> }
code_review: `Queue::getActualName` ?
target code: protected Map < String , Queue > getQueueNamesToQueues ( ) { return this . queues . stream ( ) . collect ( Collectors . toMap ( Queue : : getActualName , q - > q ) ) ; }
response: protected Map<String, Queue> getQueueNamesToQueues() { return this.queues.stream() <START> .collect(Collectors.toMap(Queue::getActualName, q -> q)); <END> }

sample: 1160
buggy_code: public String toString() { Bundle myBundle = getBundle(); if (myBundle == null) return ""; //$NON-NLS-1$ String name = myBundle.getSymbolicName(); <START> return name == null ? Long.valueOf(myBundle.getBundleId()).toString() : name; <END> }
code_review: Using String.valueOf(myBundle.getBundleId()) would make more sense than .valueOf.toString
target code: public String toString ( ) { Bundle myBundle = getBundle ( ) ; if ( myBundle == null ) return "" ; // $NON - NLS - 1$ String name = myBundle . getSymbolicName ( ) ; return name == null ? String . valueOf ( myBundle . getBundleId ( ) ) : name ; }
response: public String toString() { Bundle myBundle = getBundle(); if (myBundle == null) return ""; //$NON-NLS-1$ String name = myBundle.getSymbolicName(); <START> return name == null ? String.valueOf(myBundle.getBundleId()) : name; <END> }

sample: 1161
buggy_code: public void workbenchSelectionChanged(ISelection selection) { Object o = SelectionUtils.getSelectedObject(selection); if (o instanceof TextSelection) { String text = ((TextSelection) o).getText(); m_sourceGraphControl.setSourceText(text); <START> } else if (o == null) { <END> m_sourceGraphControl.setSourceText(""); //$NON-NLS-1$ } }
code_review: The test on the "else" case isn't needed -- if it's anything but a TextSelection the text can be set to the emprty string.
target code: public void workbenchSelectionChanged ( ISelection selection ) { Object o = SelectionUtils . getSelectedObject ( selection ) ; if ( o instanceof TextSelection ) { String text = ( ( TextSelection ) o ) . getText ( ) ; m_sourceGraphControl . setSourceText ( text ) ; } else { m_sourceGraphControl . setSourceText ( "" ) ; // $NON - NLS - 1$ } }
response: public void workbenchSelectionChanged(ISelection selection) { Object o = SelectionUtils.getSelectedObject(selection); if (o instanceof TextSelection) { String text = ((TextSelection) o).getText(); m_sourceGraphControl.setSourceText(text); <START> } else { <END> m_sourceGraphControl.setSourceText(""); //$NON-NLS-1$ } }

sample: 1162
buggy_code: <START> public JBlock getOnDestroyViewAfterSuperBlock() { <END> if (onDestroyViewAfterSuperBlock == null) { setContentViewRelatedMethods(); } return onDestroyViewAfterSuperBlock; }
code_review: This could be private if you move the field creation to the holder as i suggested.
target code: private JBlock getOnDestroyViewAfterSuperBlock ( ) { if ( onDestroyViewAfterSuperBlock == null ) { setContentViewRelatedMethods ( ) ; } return onDestroyViewAfterSuperBlock ; }
response: <START> public JBlock getOnDestroyViewAfterSuperBlock() { <END> if (onDestroyViewAfterSuperBlock == null) { setContentViewRelatedMethods(); } return onDestroyViewAfterSuperBlock; }

sample: 1163
buggy_code: public boolean hasChildren(Object element) { <START> return ((MyModel) element).children.size() > 0; <END> }
code_review: Use isEmpty() to check whether the collection is empty or not.
target code: public boolean hasChildren ( Object element ) { return ! ( ( MyModel ) element ) . children . isEmpty ( ) ; }
response: public boolean hasChildren(Object element) { <START> return !((MyModel) element).children.isEmpty(); <END> }

sample: 1164
buggy_code: public GroupedPropertyList getPropertyList() { if (propertyList == null) { <START> try{ <END> boolean parallel = true; long t1 = System.currentTimeMillis(); propertyList = new GroupedPropertyList(individual, vreq, editing,parallel); log.debug(" getPropertyList parallel: "+parallel+" time :"+(System.currentTimeMillis()-t1)+" ms"); }catch(Exception e) { e.printStackTrace(); } } return propertyList; }
code_review: I believe we can remove the `try`/`catch` wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating?
target code: public GroupedPropertyList getPropertyList ( ) throws Exception { propertyList = new GroupedPropertyList ( individual , vreq , editing ) ; return propertyList ; }
response: public GroupedPropertyList getPropertyList() { if (propertyList == null) { <START> boolean parallel = true; long t1 = System.currentTimeMillis(); propertyList = new GroupedPropertyList(individual, vreq, editing,parallel); log.debug(" getPropertyList parallel: "+parallel+" time :"+(System.currentTimeMillis()-t1)+" ms"); <END> } return propertyList; }

sample: 1165
buggy_code: private void doTheTest(UserGroup g0) { String s = MARSHALER.marshal(g0); UserGroup ug = MARSHALER.unmarshal(s); <START> System.out.println(g0); <END> System.out.println(ug); System.out.println(s); assertTrue(g0.equals(ug)); }
code_review: Remove this ones
target code: private void doTheTest ( UserGroup g0 ) { String s = MARSHALER . marshal ( g0 ) ; UserGroup ug = MARSHALER . unmarshal ( s ) ; assertTrue ( g0 . equals ( ug ) ) ; }
response: private void doTheTest(UserGroup g0) { String s = MARSHALER.marshal(g0); UserGroup ug = MARSHALER.unmarshal(s); <START> System.out.println(g0); <END> System.out.println(ug); System.out.println(s); assertTrue(g0.equals(ug)); }

sample: 1166
buggy_code: String getConstraintType() { final ConstraintType constraintType = presenter.getConstraintType(); <START> if (constraintType == null) { <END> return presenter.inferComponentType(presenter.getConstraintValue()).value(); } else { return constraintType.toString(); } }
code_review: This too would benefit from the (proposed) `ConstraintType.EMPTY` enumeration item.
target code: private String getConstraintType ( ) { if ( presenter . getConstraintType ( ) == null ) { return presenter . inferComponentType ( presenter . getConstraintValue ( ) ) . value ( ) ; } else { return presenter . getConstraintType ( ) . toString ( ) ; } }
response: String getConstraintType() { final ConstraintType constraintType = presenter.getConstraintType(); <START> if (constraintType == ConstraintType.EMPTY) { <END> return presenter.inferComponentType(presenter.getConstraintValue()).value(); } else { return constraintType.toString(); } }

sample: 1167
buggy_code: private WikipediaApp getApplication() { <START> return (WikipediaApp) getPageActivity().getApplication(); <END> }
code_review: How about WikipediaApp.getInstance() instead?
target code: private WikipediaApp getApplication ( ) { return WikipediaApp . getInstance ( ) ; }
response: private WikipediaApp getApplication() { <START> return WikipediaApp.getInstance(); <END> }

sample: 1168
buggy_code: <START> public boolean isHostedEngineDirectLunDisk() { <END> return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias()); }
code_review: Should this be public or private? It is used only in the validator
target code: private boolean isHostedEngineDirectLunDisk ( ) { return disk . getDiskStorageType ( ) == DiskStorageType . LUN && StorageConstants . HOSTED_ENGINE_LUN_DISK_ALIAS . equals ( disk . getDiskAlias ( ) ) ; }
response: <START> private boolean isHostedEngineDirectLunDisk() { <END> return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias()); }

sample: 1169
buggy_code: <START> public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, <END> UUID collectionId, @Nullable Pageable optionalPageable, Projection projection) { try { Context context = obtainContext(); Collection collection = collectionService.find(context, collectionId); Community parentCommunity = (Community) collectionService.getParentObject(context, collection); if (collection == null) { throw new ResourceNotFoundException("No such collection: " + collectionId); } return converter.toRest(parentCommunity, projection); } catch (SQLException e) { throw new RuntimeException(e); } }
code_review: Same here, JavaDocs for this method please
target code: public CommunityRest getParentCommunity ( @Nullable HttpServletRequest httpServletRequest , UUID collectionId , @Nullable Pageable optionalPageable , Projection projection ) { try { Context context = obtainContext ( ) ; Collection collection = collectionService . find ( context , collectionId ) ; if ( collection == null ) { throw new ResourceNotFoundException ( "No such collection : " + collectionId ) ; } Community parentCommunity = ( Community ) collectionService . getParentObject ( context , collection ) ; return converter . toRest ( parentCommunity , projection ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } }
response: <START> public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, <END> UUID collectionId, @Nullable Pageable optionalPageable, Projection projection) { try { Context context = obtainContext(); Collection collection = collectionService.find(context, collectionId); Community parentCommunity = (Community) collectionService.getParentObject(context, collection); if (collection == null) { throw new ResourceNotFoundException("No such collection: " + collectionId); } return converter.toRest(parentCommunity, projection); } catch (SQLException e) { throw new RuntimeException(e); } }

sample: 1170
buggy_code: public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException, DotSecurityException { <START> List<WorkflowAction> actions = new ArrayList<>(); <END> for(WorkflowStep step : steps) { actions.addAll(workFlowFactory.findActions(step)); } actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user); return actions; }
code_review: Immutable
target code: public List < WorkflowAction > findActions ( List < WorkflowStep > steps , User user ) throws DotDataException , DotSecurityException { final ImmutableList . Builder < WorkflowAction > actions = new ImmutableList . Builder < > ( ) ; for ( WorkflowStep step : steps ) { actions . addAll ( workFlowFactory . findActions ( step ) ) ; } return APILocator . getPermissionAPI ( ) . filterCollection ( actions . build ( ) , PermissionAPI . PERMISSION_USE , true , user ) ; }
response: public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException, DotSecurityException { <START> List<WorkflowAction> actions = new ArrayList<>(); <END> for(WorkflowStep step : steps) { actions.addAll(workFlowFactory.findActions(step)); } actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user); return Collections.unmodifiableList(actions); }

sample: 1171
buggy_code: private String updateIconUri(MPart part) { MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId()); <START> String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); <END> part.getTransientData().put(ICON_URI_FOR_PART, iconURI); return iconURI; }
code_review: This code raises two more (previously existing) concerns: 1. Which iconURI has higher priority the descriptor or the part? 2. What happens if the iconURI of the descriptor is changed?
target code: private String updateIconUri ( MPart part ) { MPartDescriptor desc = modelService . getPartDescriptor ( part . getElementId ( ) ) ; String iconURI = part . getIconURI ( ) ; if ( iconURI == null && desc != null ) { iconURI = desc . getIconURI ( ) ; } part . getTransientData ( ) . put ( ICON_URI_FOR_PART , iconURI ) ; return iconURI ; }
response: private String updateIconUri(MPart part) { MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId()); <START> String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); part.getTransientData().put(ICON_URI_FOR_PART, iconURI); return iconURI; <END> }

sample: 1172
buggy_code: private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){ //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value Map<String, Pair<Class, Object>> map = new HashMap<>(); <START> return map; <END> }
code_review: This will throw redundancy warnings in IntelliJ
target code: private Map < String , Pair < Class , Object > > getOverriddenReturnTypes ( ) { // Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes // Provide the attribute name as key , and a pair of return type ( Class ) and an Object to be used as test value return new HashMap < > ( ) ; }
response: private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){ //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value Map<String, Pair<Class, Object>> map = new HashMap<>(); <START> return map; <END> }

sample: 1173
buggy_code: <START> public String getParentId(String testId) { <END> return (String) getHibernateTemplate().find("select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?", testId, sessionId).get(0); }
code_review: why is it public?
target code: private String getParentId ( String testId ) { return ( String ) getHibernateTemplate ( ) . find ( "select distinct w . parentId from WorkloadData w where w . taskId = ? and w . sessionId = ? " , testId , sessionId ) . get ( 0 ) ; }
response: <START> String getParentId(String testId) { <END> return (String) getHibernateTemplate().find("select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?", testId, sessionId).get(0); }

sample: 1174
buggy_code: protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { <START> setReturnValue(new ArrayList<>()); <END> return; } setReturnValue(filterDisks(diskList)); }
code_review: Why can't you just return diskList? If I'm not mistaken DbFacade does not return null lists, only empty
target code: protected void executeQueryCommand ( ) { List < Disk > diskList = DbFacade . getInstance ( ) . getDiskDao ( ) . getAllAttachableDisksByPoolId ( getParameters ( ) . getStoragePoolId ( ) , getParameters ( ) . getVmId ( ) , getUserID ( ) , getParameters ( ) . isFiltered ( ) ) ; if ( CollectionUtils . isEmpty ( diskList ) ) { setReturnValue ( diskList ) ; return ; } setReturnValue ( filterDisks ( diskList ) ) ; }
response: protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { <START> return diskList; <END> return; } setReturnValue(filterDisks(diskList)); }

sample: 1175
buggy_code: public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent( Filter filter, List<JoinableClause> clauses, VirtualColumns virtualColumns ) { // Some filters have potentially expensive hash codes that are lazily computed and cached. // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map, // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe. synchronized (analyses) { if (filter != null) { <START> filter.hashCode(); <END> } } JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns); return analyses.computeIfAbsent( key, (groupKey) -> { return JoinFilterAnalyzer.computeJoinFilterPreAnalysis( JoinableClauses.fromList(clauses), virtualColumns, filter, joinFilterRewriteConfig ); } ); }
code_review: Oh, is this why we don't need thread-safety on filter hashcode methods i guess? This seems kind of a funny way to prime them with the cached values, I think maybe the supplier.memoize pattern would be a little cleaner and make this not necessary?
target code: public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent ( Filter filter , List < JoinableClause > clauses , VirtualColumns virtualColumns ) { JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey ( filter , clauses , virtualColumns ) ; return analyses . computeIfAbsent ( key , ( groupKey ) - > { return JoinFilterAnalyzer . computeJoinFilterPreAnalysis ( JoinableClauses . fromList ( clauses ) , virtualColumns , filter , joinFilterRewriteConfig ) ; } ) ; }
response: public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent( Filter filter, List<JoinableClause> clauses, VirtualColumns virtualColumns ) { // Some filters have potentially expensive hash codes that are lazily computed and cached. // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map, // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe. synchronized (analyses) { if (filter != null) { <START> filter.hashCode(); <END> } } JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns); return analyses.computeIfAbsent( key, (groupKey) -> { return JoinFilterAnalyzer.computeJoinFilterPreAnalysis( JoinableClauses.fromList(clauses), virtualColumns, filter, joinFilterRewriteConfig ); } ); }

sample: 1176
buggy_code: protected AbstractFixedIntervalTask( String id, <START> TaskResource taskResource, <END> String dataSource, Interval interval ) { this(id, id, taskResource, dataSource, interval); }
code_review: there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ?
target code: protected AbstractFixedIntervalTask ( String id , TaskResource taskResource , String dataSource , Interval interval ) { this ( id , id , taskResource == null ? new TaskResource ( id , 1 ) : taskResource , dataSource , interval ) ; }
response: protected AbstractFixedIntervalTask( String id, <START> TaskResource taskResource, <END> String dataSource, Interval interval ) { this(id, id, taskResource, dataSource, interval); }

sample: 1177
buggy_code: private Object[][] finderSupportedResourceTypeData() { return new Object[][] <START> { <END> { FinderSupportedAssociationDataResource.class }, { FinderSupportedComplexKeyDataResource.class }, { FinderWithActionResource.class } }; }
code_review: You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
target code: private Object [ ] [ ] finderSupportedResourceTypeData ( ) { return new Object [ ] [ ] { { FinderSupportedAssociationDataResource . class } , { FinderSupportedComplexKeyDataResource . class } } ; }
response: private Object[][] finderSupportedResourceTypeData() { return new Object[][] { { FinderSupportedAssociationDataResource.class }, { FinderSupportedComplexKeyDataResource.class }, { FinderWithActionResource.class } }; }

sample: 1178
buggy_code: public void addNotEmptyIdConnection() { StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30"); newPosixConnection.setId(Guid.newGuid().toString()); parameters.setStorageServerConnection(newPosixConnection); parameters.setVdsId(Guid.Empty); <START> doReturn(newPosixConnection.getId()).when(command).isConnWithSameDetailsExists(newPosixConnection, null); <END> ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY); }
code_review: We actually don't need this line at all. The test check something else
target code: public void addNotEmptyIdConnection ( ) { StorageServerConnections newPosixConnection = createPosixConnection ( "multipass . my . domain . tlv . company . com :/ export / allstorage / data1" , StorageType . POSIXFS , "nfs" , "timeo = 30" ) ; newPosixConnection . setId ( Guid . newGuid ( ) . toString ( ) ) ; parameters . setStorageServerConnection ( newPosixConnection ) ; parameters . setVdsId ( Guid . Empty ) ; ValidateTestUtils . runAndAssertValidateFailure ( command , EngineMessage . ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY ) ; }
response: public void addNotEmptyIdConnection() { StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30"); newPosixConnection.setId(Guid.newGuid().toString()); parameters.setStorageServerConnection(newPosixConnection); parameters.setVdsId(Guid.Empty); <START> <END> ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY); }

sample: 1179
buggy_code: public void mercury_topbar_wikiaLogoRedirectsToFandomPage() { TopBar topBar = new ArticlePage() .open(MercurySubpages.MAIN_PAGE) .getTopBar(); <START> Assertion.assertTrue(topBar.isLogoVisible()); <END> topBar.clickWikiaLogo(); Assertion.assertTrue(topBar.getCurrentUrl().contains("www.wikia.com/fandom")); }
code_review: I think if it's not visible, click should fail, so is the assertion needed?
target code: public void mercury_topbar_wikiaLogoRedirectsToFandomPage ( ) { TopBar topBar = new ArticlePage ( ) . open ( MercurySubpages . MAIN_PAGE ) . getTopBar ( ) ; topBar . clickWikiaLogo ( ) ; Assertion . assertTrue ( topBar . getCurrentUrl ( ) . contains ( "www . wikia . com / fandom" ) ) ; }
response: public void mercury_topbar_wikiaLogoRedirectsToFandomPage() { TopBar topBar = new ArticlePage() .open(MercurySubpages.MAIN_PAGE) .getTopBar(); <START> topBar.clickWikiaLogo(); <END> Assertion.assertTrue(topBar.getCurrentUrl().contains("www.wikia.com/fandom")); }

sample: 1180
buggy_code: private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{ String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME); if(cfService == null) { <START> cfService = new ConfigurationServiceImplService(new URL(url+"?wsdl")); <END> } return cfService; }
code_review: Should this be initialized in a static / thread-safe context?
target code: protected ConfigurationServiceImplService getConfigService ( ) throws ConnectionManagerException , MalformedURLException { return cfService ; }
response: private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{ String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME); if(cfService == null) { <START> cfService = new ConfigurationServiceImplService(new URL(url+"?wsdl")); <END> } return cfService; }

sample: 1181
buggy_code: void testDtoListResponses() { FlowJsonObjectReader reader = new FlowJsonObjectReader(); TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {}; List<SurveyGroupDto> surveyList = null; try { surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference); } catch (IOException e) { // } assertNotEquals(surveyList, null); assertEquals(surveyList.size(), 1); <START> assertEquals(surveyList.get(0).getName(),"1.10.36 all questions"); <END> }
code_review: This is a minor detail but the the assertZZZ methods work like this assertZZZ(expected, actual), this is valid for the whole of your test files. Also please format the file as some "," have no space after them.
target code: void testDtoListResponses ( ) { FlowJsonObjectReader reader = new FlowJsonObjectReader ( ) ; TypeReference < SurveyGroupDto > typeReference = new TypeReference < SurveyGroupDto > ( ) { } ; List < SurveyGroupDto > surveyList = null ; try { surveyList = reader . readDtoListObject ( DTO_LIST_JSON_OBJECT , typeReference ) ; } catch ( IOException e ) { // ignoring exception } assertNotEquals ( null , surveyList ) ; assertEquals ( 1 , surveyList . size ( ) ) ; assertEquals ( "1 . 10 . 36 all questions" , surveyList . get ( 0 ) . getName ( ) ) ; }
response: void testDtoListResponses() { FlowJsonObjectReader reader = new FlowJsonObjectReader(); TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {}; List<SurveyGroupDto> surveyList = null; try { surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference); } catch (IOException e) { // } assertNotEquals(surveyList, null); assertEquals(surveyList.size(), 1); <START> assertEquals("1.10.36 all questions", surveyList.get(0).getName()); <END> }

sample: 1182
buggy_code: public GroupScan clone(List<SchemaPath> columns) { <START> HBaseUtils.verifyColumns(columns, hTableDesc); <END> HBaseGroupScan newScan = new HBaseGroupScan(this); newScan.columns = columns == null ? ALL_COLUMNS : columns; return newScan; }
code_review: We should replace null columns with all_columns before verification or we will get exception. You have changed initial order of statements.
target code: public GroupScan clone ( List < SchemaPath > columns ) { HBaseGroupScan newScan = new HBaseGroupScan ( this ) ; newScan . columns = columns == null ? ALL_COLUMNS : columns ; HBaseUtils . verifyColumns ( columns , hTableDesc ) ; return newScan ; }
response: public GroupScan clone(List<SchemaPath> columns) { <START> HBaseGroupScan newScan = new HBaseGroupScan(this); newScan.columns = columns == null ? ALL_COLUMNS : columns; HBaseUtils.verifyColumns(columns, hTableDesc); <END> return newScan; }

sample: 1183
buggy_code: <START> static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { <END> return t -> Result.failure( "Not yet implemented: " + Optional.ofNullable(t) .map(o -> o.getClass().getCanonicalName()) .orElse("null -- expected " + expectedClass.getCanonicalName())); }
code_review: Can be private method.
target code: private static < T , U > Function < T , Result < U > > reportMissing ( Class < ? > expectedClass ) { return t - > Result . failure ( "Not yet implemented : " + Optional . ofNullable ( t ) . map ( o - > o . getClass ( ) . getCanonicalName ( ) ) . orElse ( "null -- expected " + expectedClass . getCanonicalName ( ) ) ) ; }
response: <START> private static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { <END> return t -> Result.failure( "Not yet implemented: " + Optional.ofNullable(t) .map(o -> o.getClass().getCanonicalName()) .orElse("null -- expected " + expectedClass.getCanonicalName())); }

sample: 1184
buggy_code: private void rematchAllNetworksAndRequests() { // TODO: This may be slow, and should be optimized. final long now = SystemClock.elapsedRealtime(); final NetworkReassignment changes = computeNetworkReassignment(); if (VDBG || DDBG) log(changes.toString()); applyNetworkReassignment(changes, <START> oldDefaultNetwork, now); <END> }
code_review: hmm, I don't think this can get build pass.
target code: private void rematchAllNetworksAndRequests ( ) { // TODO : This may be slow , and should be optimized . final long now = SystemClock . elapsedRealtime ( ) ; final NetworkReassignment changes = computeNetworkReassignment ( ) ; if ( VDBG || DDBG ) log ( changes . toString ( ) ) ; applyNetworkReassignment ( changes , now ) ; }
response: private void rematchAllNetworksAndRequests() { // TODO: This may be slow, and should be optimized. final long now = SystemClock.elapsedRealtime(); final NetworkReassignment changes = computeNetworkReassignment(); if (VDBG || DDBG) log(changes.toString()); applyNetworkReassignment(changes, oldDefaultNetwork, now); }

sample: 1185
buggy_code: public String getScroller() { <START> return scroller == null ? DEFAULT_SCROLLER : scroller; <END> }
code_review: wdyt if we replace it by ` return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER)` if you agree you will have some adaptation on 10.10 (java 8)
target code: public String getScroller ( ) { return scroller ; }
response: public String getScroller() { <START> return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER); <END> }

sample: 1186
buggy_code: public String getMessage(){ <START> return this.message; <END> }
code_review: Nit: unnecessary this.
target code: public String getMessage ( ) { return message ; }
response: public String getMessage(){ <START> return message; <END> }

sample: 1187
buggy_code: public Type convertReadValueToType(String pvReadValue) { Type lvType = convertReadValueToUnmodifiedType(pvReadValue); for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) { logger.debug("type of {} before modifier:{} type={}", getDevicePropertyPath(), <START> lvTypeModifier.getModifierName(), lvType.toString()); <END> lvType = lvTypeModifier.modify4Read(lvType); logger.debug("type of {} after modifier:{} type={}", getDevicePropertyPath(), lvTypeModifier.getModifierName(), lvType.toString()); } return lvType; }
code_review: no need for `.toString()`
target code: public Type convertReadValueToType ( String pvReadValue ) { Type lvType = convertReadValueToUnmodifiedType ( pvReadValue ) ; for ( InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList ( ) ) { logger . debug ( "type of { } before modifier : { } type = { } " , getDevicePropertyPath ( ) , lvTypeModifier . getModifierName ( ) , lvType ) ; lvType = lvTypeModifier . modify4Read ( lvType ) ; logger . debug ( "type of { } after modifier : { } type = { } " , getDevicePropertyPath ( ) , lvTypeModifier . getModifierName ( ) , lvType ) ; } return lvType ; }
response: public Type convertReadValueToType(String pvReadValue) { Type lvType = convertReadValueToUnmodifiedType(pvReadValue); for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) { logger.debug("type of {} before modifier:{} type={}", getDevicePropertyPath(), <START> lvTypeModifier.getModifierName(), lvType); <END> lvType = lvTypeModifier.modify4Read(lvType); logger.debug("type of {} after modifier:{} type={}", getDevicePropertyPath(), lvTypeModifier.getModifierName(), lvType); } return lvType; }

sample: 1188
buggy_code: <START> public void clear() { <END> this.domainsVisibility.clear(); }
code_review: this should be synchronized as well
target code: public synchronized void clear ( ) { this . domainsVisibility . clear ( ) ; }
response: <START> public synchronized void clear() { <END> this.domainsVisibility.clear(); }

sample: 1189
buggy_code: public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> Long id = Long.parseLong(issueId + "0" + newCommentId); <END> URI selfUri = URI.create(TEST_JIRA_URL + "/rest/api/latest/issue/" + issueId + "/comment"); return new Comment(selfUri, comment, null, null, now, null, null, id); }
code_review: Since you are at it, can you please change this to `long` primitive type? :)
target code: public static Comment newComment ( long issueId , int newCommentId , String comment ) { DateTime now = DateTime . now ( ) ; long id = Long . parseLong ( issueId + "0" + newCommentId ) ; URI selfUri = URI . create ( TEST_JIRA_URL + " / rest / api / latest / issue / " + issueId + " / comment" ) ; return new Comment ( selfUri , comment , null , null , now , null , null , id ) ; }
response: public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> long id = Long.parseLong(issueId + "0" + newCommentId); <END> URI selfUri = URI.create(TEST_JIRA_URL + "/rest/api/latest/issue/" + issueId + "/comment"); return new Comment(selfUri, comment, null, null, now, null, null, id); }

sample: 1190
buggy_code: private void registerGlueCodeScope(ConfigurableApplicationContext context) { do { <START> synchronized (context) { <END> context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope()); context = (ConfigurableApplicationContext) context.getParent(); } } while (context != null); }
code_review: I don't think this works. We're swapping out `context` with a different instance. We should probably use a constant as a monitor.
target code: private void registerGlueCodeScope ( ConfigurableApplicationContext context ) { do { context . getBeanFactory ( ) . registerScope ( SCOPE_CUCUMBER_GLUE , new GlueCodeScope ( ) ) ; context = ( ConfigurableApplicationContext ) context . getParent ( ) ; } while ( context != null ) ; }
response: private void registerGlueCodeScope(ConfigurableApplicationContext context) { do { <START> synchronized (this) { <END> context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope()); context = (ConfigurableApplicationContext) context.getParent(); } } while (context != null); }

sample: 1191
buggy_code: private String truncateMessageLength(String message, int maxLength) { if (message.length() > maxLength) { <START> message = message.substring(0, maxLength + 1); <END> } return message; }
code_review: This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace "maxLength + 1" with just "maxLength".
target code: private String truncateMessageLength ( String message , int maxLength ) { if ( message . length ( ) > maxLength ) { message = message . substring ( 0 , maxLength ) ; } return message ; }
response: private String truncateMessageLength(String message, int maxLength) { if (message.length() > maxLength) { <START> message = message.substring(0, maxLength); <END> } return message; }

sample: 1192
buggy_code: public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException("boo"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated();; <END> ts.assertError(TestException.class); ts.assertErrorMessage("boo"); }
code_review: double `;`
target code: public void testErrorReceived ( ) { TestObserver < Object > ts = new TestObserver < Object > ( ) ; TestException ex = new TestException ( "boo" ) ; Flowable . error ( ex ) . ignoreElements ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; ts . assertErrorMessage ( "boo" ) ; }
response: public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException("boo"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated(); <END> ts.assertError(TestException.class); ts.assertErrorMessage("boo"); }

sample: 1193
buggy_code: public boolean select(Viewer viewer, Object parentElement, <START> Object element) { <END> if (!(element instanceof DisplayItem)) { return false; } if (actionSet == null) { return false; } return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet); }
code_review: unnecessary linebreak
target code: public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( ! ( element instanceof DisplayItem ) || actionSet == null ) { return false ; } return CustomizePerspectiveDialog . includeInSetStructure ( ( DisplayItem ) element , actionSet ) ; }
response: public boolean select(Viewer viewer, Object parentElement, <START> Object element) { <END> if (!(element instanceof DisplayItem)) { return false; } if (actionSet == null) { return false; } return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet); }

sample: 1194
buggy_code: public static void runJSTestSuite() throws InterruptedException { // FIXME Update this when we stop using ARM Emulators int timeout = Build.SUPPORTED_ABIS[0].contains("armeabi") ? 180 : 60; <START> JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); <END> }
code_review: Why not just bump it up to `180` across the board?
target code: public static void runJSTestSuite ( ) throws InterruptedException { // FIXME Change timeout back to 60 when we stop using ARM Emulators JSTestCase . runJSTestSuite ( JS_SUITE , data ( ) , 180 ) ; }
response: public static void runJSTestSuite() throws InterruptedException { // FIXME Update this when we stop using ARM Emulators int timeout = Build.SUPPORTED_ABIS[0].contains("armeabi") ? 180 : 180; <START> JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); <END> }

sample: 1195
buggy_code: public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context) { <START> HashMap<String, String> combinedProperties = new HashMap<>(); <END> for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) { combinedProperties.putAll(sessionMatchSpec.match(context)); } return ImmutableMap.copyOf(combinedProperties); }
code_review: Nit: declare as `Map`
target code: public Map < String , String > getSystemSessionProperties ( SessionConfigurationContext context ) { // later properties override earlier properties Map < String , String > combinedProperties = new HashMap < > ( ) ; for ( SessionMatchSpec sessionMatchSpec : sessionMatchSpecs ) { combinedProperties . putAll ( sessionMatchSpec . match ( context ) ) ; } return ImmutableMap . copyOf ( combinedProperties ) ; }
response: public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context) { <START> Map<String, String> combinedProperties = new HashMap<>(); <END> for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) { combinedProperties.putAll(sessionMatchSpec.match(context)); } return ImmutableMap.copyOf(combinedProperties); }

sample: 1196
buggy_code: public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) { new ThriftAccessLogger().log( String.format("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation)); <START> } <END>
code_review: I thought it would be something like ``` LOG.info("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation); ``` and ThriftAccessLogger.log would just go away
target code: public static void logAccess ( Integer requestId , InetAddress remoteAddress , Principal principal , String operation ) { LOG . info ( "Request ID : { } access from : { } principal : { } operation : { } " , requestId , remoteAddress , principal , operation ) ; }
response: public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) { <START> } <END>

sample: 1197
buggy_code: public static List<String> getComputerNames() { final ArrayList<String> names = new ArrayList<String>(); <START> for (Computer c : Jenkins.getActiveInstance().getComputers()) { <END> if (!c.getName().isEmpty()) { names.add(c.getName()); } } return names; }
code_review: `getActiveInstance` is deprecated, please use good old `getInstance`.
target code: public static List < String > getComputerNames ( ) { final ArrayList < String > names = new ArrayList < String > ( ) ; for ( Computer c : Jenkins . getInstance ( ) . getComputers ( ) ) { if ( ! c . getName ( ) . isEmpty ( ) ) { names . add ( c . getName ( ) ) ; } } return names ; }
response: public static List<String> getComputerNames() { final ArrayList<String> names = new ArrayList<String>(); <START> for (Computer c : Jenkins.getInstance().getComputers()) { <END> if (!c.getName().isEmpty()) { names.add(c.getName()); } } return names; }

sample: 1198
buggy_code: public void unbind(final String eventName, final SubscriptionEventListener listener) { validateArguments(eventName, listener); <START> final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); <END> synchronized (lock) { if (listeners != null) { listeners.remove(listener); if (listeners.isEmpty()) { eventNameToListenerMap.remove(eventName); } } } }
code_review: As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency.
target code: public void unbind ( final String eventName , final SubscriptionEventListener listener ) { validateArguments ( eventName , listener ) ; synchronized ( lock ) { final Set < SubscriptionEventListener > listeners = eventNameToListenerMap . get ( eventName ) ; if ( listeners != null ) { listeners . remove ( listener ) ; if ( listeners . isEmpty ( ) ) { eventNameToListenerMap . remove ( eventName ) ; } } } }
response: public void unbind(final String eventName, final SubscriptionEventListener listener) { validateArguments(eventName, listener); synchronized (lock) { <START> final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); <END> if (listeners != null) { listeners.remove(listener); if (listeners.isEmpty()) { eventNameToListenerMap.remove(eventName); } } } }

sample: 1199
buggy_code: public Iterable<AccountGroup> all() { <START> final List<AccountGroup> groups = new LinkedList<AccountGroup>(); <END> for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) { final AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return Collections.unmodifiableList(groups); }
code_review: If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster.
target code: public Iterable < AccountGroup > all ( ) { final List < AccountGroup > groups = new ArrayList < AccountGroup > ( ) ; for ( final AccountGroup . NameKey groupName : list . get ( ListKey . ALL ) ) { final AccountGroup group = get ( groupName ) ; if ( group != null ) { groups . add ( group ) ; } } return Collections . unmodifiableList ( groups ) ; }
response: public Iterable<AccountGroup> all() { <START> final List<AccountGroup> groups = new ArrayList<AccountGroup>(); <END> for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) { final AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return Collections.unmodifiableList(groups); }

sample: 1200
buggy_code: public void terminate(HazelcastInstance instance) { try { Address address = getNode(instance).address; terminateInstance(instance); if (isMockNetwork) { registry.removeInstance(address); } } finally { <START> TestJmxLeakHelper.checkJmxBeans(instance.getName()); <END> } }
code_review: We have a large number of tests that don't use `TestHazelcastInstanceFactory` at all and call `Hazelcast.newHazelcastInstance()` directly (in combination with `Hazelcast.shutdownAll()` / `HazelcastInstanceFactory.shutdownAll()` / `HazelcastInstanceFactory.terminateAll()`). Shouldn't those be checked as well, somehow?
target code: public void terminate ( HazelcastInstance instance ) { Address address = getNode ( instance ) . address ; terminateInstance ( instance ) ; if ( isMockNetwork ) { registry . removeInstance ( address ) ; } }
response: public void terminate(HazelcastInstance instance) { try { Address address = getNode(instance).address; terminateInstance(instance); if (isMockNetwork) { registry.removeInstance(address); } } finally { <START> TestJmxLeakHelper.checkJmxBeans(instance.getName()); <END> } }

sample: 1201
buggy_code: public void endSuccessfully() { super.endSuccessfully(); if (getParameters().getImportAsTemplate()) { Guid newTemplateId = createTemplate(); // No reason for this to happen, but checking just to make sure if (newTemplateId != null) { attachDiskToTemplate(newTemplateId); } } updateDiskStatus(ImageStatus.OK); <START> getReturnValue().setSucceeded(true); <END> }
code_review: please change to setSucceeded
target code: public void endSuccessfully ( ) { super . endSuccessfully ( ) ; if ( getParameters ( ) . getImportAsTemplate ( ) ) { Guid newTemplateId = createTemplate ( ) ; // No reason for this to happen , but checking just to make sure if ( newTemplateId != null ) { attachDiskToTemplate ( newTemplateId ) ; } } updateDiskStatus ( ImageStatus . OK ) ; setSucceeded ( true ) ; }
response: public void endSuccessfully() { super.endSuccessfully(); if (getParameters().getImportAsTemplate()) { Guid newTemplateId = createTemplate(); // No reason for this to happen, but checking just to make sure if (newTemplateId != null) { attachDiskToTemplate(newTemplateId); } } updateDiskStatus(ImageStatus.OK); <START> setSucceeded(true); <END> }

sample: 1202
buggy_code: <START> void validate() { <END> // No-op, no validation required }
code_review: Interesting wrapping style :)
target code: public void validate ( ) { // No - op , no validation required }
response: <START> void validate() { <END> // No-op, no validation required }

sample: 1203
buggy_code: private void scheduleImmediateDelivery() { cancelDelayedDelivery(); while (state == State.RUNNING) { DeliveryAttempt previous = immediateDelivery.get(); if (previous != null && !previous.isDone()) <START> previous.cancel(); <END> DeliveryAttempt current = new DeliveryAttempt(); if (immediateDelivery.compareAndSet(previous, current)) { current.executeNow(); return; } } }
code_review: deliverEvents does not handle interruptions, so this is essentially a no-op if `previous` is already executing.
target code: private void scheduleImmediateDelivery ( ) { cancelDelayedDelivery ( ) ; while ( state == State . RUNNING ) { DeliveryAttempt previous = immediateDelivery . get ( ) ; if ( previous != null ) previous . cancel ( ) ; DeliveryAttempt current = new DeliveryAttempt ( ) ; if ( immediateDelivery . compareAndSet ( previous , current ) ) { current . executeNow ( ) ; return ; } } }
response: private void scheduleImmediateDelivery() { cancelDelayedDelivery(); while (state == State.RUNNING) { DeliveryAttempt previous = immediateDelivery.get(); if (previous != null && !previous.isDone()) <START> previous.cancel(); <END> DeliveryAttempt current = new DeliveryAttempt(); if (immediateDelivery.compareAndSet(previous, current)) { current.executeNow(); return; } } }

sample: 1204
buggy_code: private static ObjectNode handleGaugeRollup(GaugeRollup rollup) { ObjectNode rollupNode = JsonNodeFactory.instance.objectNode(); <START> rollupNode.put("timestamp", rollup.getTimestamp()); <END> SimpleNumber rollupValue = rollup.getLatestValue(); rollupNode.put("latestVal", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue()); return handleBasicRollup(rollup, rollupNode); }
code_review: Why do gauges get timestamp twice?
target code: private static ObjectNode handleGaugeRollup ( GaugeRollup rollup ) { ObjectNode rollupNode = JsonNodeFactory . instance . objectNode ( ) ; SimpleNumber rollupValue = rollup . getLatestValue ( ) ; rollupNode . put ( "latestVal" , rollupValue . getDataType ( ) == ( SimpleNumber . Type . DOUBLE ) ? rollupValue . getValue ( ) . doubleValue ( ) : rollupValue . getValue ( ) . longValue ( ) ) ; return handleBasicRollup ( rollup , rollupNode ) ; }
response: private static ObjectNode handleGaugeRollup(GaugeRollup rollup) { ObjectNode rollupNode = JsonNodeFactory.instance.objectNode(); SimpleNumber rollupValue = rollup.getLatestValue(); rollupNode.put("latestVal", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue()); return handleBasicRollup(rollup, rollupNode); }

sample: 1205
buggy_code: public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, "{3}{G}{G}"); this.subtype.add(SubType.RHINO); this.power = new MageInt(3); this.toughness = new MageInt(5); // Vigilance this.addAbility(VigilanceAbility.getInstance()); // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it. <START> this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); <END> }
code_review: this doesn't need to have the ability and effect both be optional, just the ability is fine.
target code: public GarruksWarsteed ( UUID ownerId , CardSetInfo setInfo ) { super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , " { 3 } { G } { G } " ) ; this . subtype . add ( SubType . RHINO ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 5 ) ; // Vigilance this . addAbility ( VigilanceAbility . getInstance ( ) ) ; // When Garruk's Warsteed enters the battlefield , you may search your library and / or graveyard for a card named Garruk , Savage Herald , reveal it , and put it into your hand . If you search your library this way , shuffle it . this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SearchLibraryGraveyardPutInHandEffect ( filter , false , true ) ) ) ; }
response: public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, "{3}{G}{G}"); this.subtype.add(SubType.RHINO); this.power = new MageInt(3); this.toughness = new MageInt(5); // Vigilance this.addAbility(VigilanceAbility.getInstance()); // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it. <START> this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); <END> }

sample: 1206
buggy_code: private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) { lock.writeLock().lock(); try { if (cachedFileChannel.markDead()) { <START> try { <END> cachedFileChannel.fileChannel.close(); } catch (IOException e) { LOG.warn("Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file: {}", cachedFileChannel); } finally { IOUtils.close(LOG, cachedFileChannel.fileChannel); } // to guarantee the removed cachedFileChannel is what we want to remove. fileChannels.remove(logId, cachedFileChannel); } } finally { lock.writeLock().unlock(); } }
code_review: markDead doesn't need to be under a lock. The caller should call tryRetain() after receiving, which will either prevent markDead from having an effect, if it is called before it.
target code: private void releaseFileChannel ( long logId , CachedFileChannel cachedFileChannel ) { if ( cachedFileChannel . markDead ( ) ) { // to guarantee the removed cachedFileChannel is what we want to remove . fileChannels . remove ( logId , cachedFileChannel ) ; // close corresponding fileChannel try { cachedFileChannel . fileChannel . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file : { } " , cachedFileChannel ) ; } finally { IOUtils . close ( LOG , cachedFileChannel . fileChannel ) ; } } }
response: private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) { lock.writeLock().lock(); try { if (cachedFileChannel.markDead()) { <START> try { <END> cachedFileChannel.fileChannel.close(); } catch (IOException e) { LOG.warn("Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file: {}", cachedFileChannel); } finally { IOUtils.close(LOG, cachedFileChannel.fileChannel); } // to guarantee the removed cachedFileChannel is what we want to remove. fileChannels.remove(logId, cachedFileChannel); } } finally { lock.writeLock().unlock(); } }

sample: 1207
buggy_code: private static File getDefaultFile() { <START> File netrc; <END> File home = new File(System.getProperty("user.home")); //$NON-NLS-1$ netrc = new File(home, ".netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; netrc = new File(home, "_netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; return null; }
code_review: no need to declare this here, instead declare the type in line 141
target code: private static File getDefaultFile ( ) { File home = new File ( System . getProperty ( "user . home" ) ) ; // $NON - NLS - 1$ File netrc = new File ( home , " . netrc" ) ; // $NON - NLS - 1$ if ( netrc . exists ( ) ) return netrc ; netrc = new File ( home , "_netrc" ) ; // $NON - NLS - 1$ if ( netrc . exists ( ) ) return netrc ; return null ; }
response: private static File getDefaultFile() { <START> <END> File home = new File(System.getProperty("user.home")); //$NON-NLS-1$ File netrc = new File(home, ".netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; netrc = new File(home, "_netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; return null; }

sample: 1208
buggy_code: <START> static synchronized ServiceContext getServiceContext() { <END> if (serviceContext == null) { synchronized (Context.class) { if (serviceContext == null) { log.error("serviceContext is null. Creating new ServiceContext()"); serviceContext = ServiceContext.getInstance(); } } } log.trace("serviceContext: {}", serviceContext); return ServiceContext.getInstance(); }
code_review: I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block.
target code: static synchronized ServiceContext getServiceContext ( ) { synchronized ( Context . class ) { if ( serviceContext == null ) { log . error ( "serviceContext is null . Creating new ServiceContext ( ) " ) ; serviceContext = ServiceContext . getInstance ( ) ; } } log . trace ( "serviceContext : { } " , serviceContext ) ; return ServiceContext . getInstance ( ) ; }
response: <START> static synchronized ServiceContext getServiceContext() { <END> synchronized (Context.class) { if (serviceContext == null) { log.error("serviceContext is null. Creating new ServiceContext()"); serviceContext = ServiceContext.getInstance(); } } log.trace("serviceContext: {}", serviceContext); return ServiceContext.getInstance(); }

sample: 1209
buggy_code: public synchronized void activate() { <START> OTELog.getLogger("test").debug("something"); <END> listener = new Slf4jLogListener(); logService.addLogListener(listener); }
code_review: remove this line
target code: public synchronized void activate ( ) { listener = new Slf4jLogListener ( ) ; logService . addLogListener ( listener ) ; }
response: public synchronized void activate() { <START> OTELog.getLogger("test").debug("something"); listener = new Slf4jLogListener(); logService.addLogListener(listener); <END> }

sample: 1210
buggy_code: <START> public void testDeserialization() throws Exception { <END> for (Short version : versions) { composedBlobIdAndDeserialize(version); } }
code_review: I don't understand the need of this test. We have the next one which tests serialization and deserialization if I am not wrong. Or does this tests something more than the next one ?
target code: public void testDeserialization ( ) throws Exception { composedBlobIdAndDeserialize ( version ) ; }
response: public void testDeserialization() throws Exception { for (Short version : versions) { composedBlobIdAndDeserialize(version); } }

sample: 1211
buggy_code: private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) { <START> List<VMWithPlugInfo> vmsWithPlugInfo = <END> getCallsHandler().executeReadList ("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id)); return vmsWithPlugInfo; }
code_review: should be just return , no need for variable
target code: private List < VMWithPlugInfo > getVmsWithPlugInfo ( Guid id ) { return getCallsHandler ( ) . executeReadList ( "GetVmsByDiskId" , VMWithPlugInfoRowMapper . instance , getCustomMapSqlParameterSource ( ) . addValue ( "disk_guid" , id ) ) ; }
response: private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) { <START> return <END> getCallsHandler().executeReadList ("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id)); }

sample: 1212
buggy_code: public Jedis createResource() { <START> Jedis jedis = new Jedis(this); <END> try { jedis.select(db); } catch(JedisException e) { log.log(Level.SEVERE, "Can't select database due a Redis connection problem", e); } return jedis; }
code_review: @nykolaslima How about handling selecting db by constructor of BinaryJedis, as authentication takes place?
target code: public Jedis createResource ( ) { return new Jedis ( this ) ; }
response: public Jedis createResource() { <START> Jedis jedis = new Jedis(this, db); <END> try { jedis.select(db); } catch(JedisException e) { log.log(Level.SEVERE, "Can't select database due a Redis connection problem", e); } return jedis; }

sample: 1213
buggy_code: public JSchUIConnectionManager(IRemoteServices services) { fConnMgr = (JSchConnectionManager) services.getConnectionManager(); <START> fConnMgr.setDefaultAuthenticatorFactory(new IUserAuthenticatorFactory() { <END> @Override public IUserAuthenticator createUserAuthenticator(IRemoteConnection conn) { return new RemoteAuthenticator(conn); } }); }
code_review: Please keep initialization code out of the Activator class.
target code: public JSchUIConnectionManager ( IRemoteServices services ) { fConnMgr = ( JSchConnectionManager ) services . getConnectionManager ( ) ; }
response: public void start(BundleContext context) throws Exception { <START> fConnMgr = (JSchConnectionManager) RemoteServices.getRemoteServices(context).getConnectionManager(); <END> }

sample: 1214
buggy_code: public BoltDeclarer addConfigurations(Map<String, Object> conf) { <START> if (conf != null && !conf.isEmpty()) { <END> component.componentConf.putAll(conf); } return this; }
code_review: Nit: I think putAll is a no-op when the conf is empty, so you probably don't need to check.
target code: public BoltDeclarer addConfigurations ( Map < String , Object > conf ) { if ( conf != null ) { component . componentConf . putAll ( conf ) ; } return this ; }
response: public BoltDeclarer addConfigurations(Map<String, Object> conf) { <START> if (conf != null) { <END> component.componentConf.putAll(conf); } return this; }

sample: 1215
buggy_code: public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc, IBreakpointsTargetDMContext.class); IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId); for (IBreakpoint breakpoint : breakpoints) { <START> if (supportsBreakpoint(breakpoint) && breakpoint instanceof ICBreakpoint) { <END> setTargetFilter((ICBreakpoint) breakpoint, containerDmc); } } startTrackingBreakpoints(targetBpDmc, rm); }
code_review: Its a heavy read that bug! When you check if breakpoint applicable probably better reverse instanceof check and call. Instanceof is cheaper
target code: public void startTrackingBpForProcess ( final IContainerDMContext containerDmc , final RequestMonitor rm ) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts . getAncestorOfType ( containerDmc , IBreakpointsTargetDMContext . class ) ; IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( fDebugModelId ) ; for ( IBreakpoint breakpoint : breakpoints ) { if ( breakpoint instanceof ICBreakpoint && supportsBreakpoint ( breakpoint ) ) { setTargetFilter ( ( ICBreakpoint ) breakpoint , containerDmc ) ; } } startTrackingBreakpoints ( targetBpDmc , rm ) ; }
response: public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc, IBreakpointsTargetDMContext.class); IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId); for (IBreakpoint breakpoint : breakpoints) { <START> if (breakpoint instanceof ICBreakpoint && supportsBreakpoint(breakpoint)) { <END> setTargetFilter((ICBreakpoint) breakpoint, containerDmc); } } startTrackingBreakpoints(targetBpDmc, rm); }

sample: 1216
buggy_code: protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) { // stop periodical tasks to prevent race condition rt.getGarbageInformer().stop(); // wait until all garbage decisions are sent to logUnit servers. rt.getGarbageInformer().waitUntilAllTasksFinish(); // send garbage decisions to logUnit servers <START> while (rt.getGarbageInformer().getGarbageReceivingQueue().size() > 0) { rt.getGarbageInformer().gcUnsafe(); } <END> // run compaction on LogUnit servers logUnitServer.runCompaction(); rt.getAddressSpaceView().resetCaches(); rt.getAddressSpaceView().invalidateServerCaches(); }
code_review: Put this logic into GarbageInformer together with waitUntilAllTasksFinish as we discussed.
target code: protected void startCompaction ( CorfuRuntime rt , LogUnitServer logUnitServer ) { // stop periodical tasks to prevent race condition rt . getGarbageInformer ( ) . stop ( ) ; // wait until all garbage decisions are sent to logUnit servers . rt . getGarbageInformer ( ) . waitUntilAllTasksFinish ( ) ; // run compaction on LogUnit servers logUnitServer . runCompaction ( ) ; rt . getAddressSpaceView ( ) . resetCaches ( ) ; rt . getAddressSpaceView ( ) . invalidateServerCaches ( ) ; }
response: protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) { // stop periodical tasks to prevent race condition rt.getGarbageInformer().stop(); // wait until all garbage decisions are sent to logUnit servers. rt.getGarbageInformer().waitUntilAllTasksFinish(); // run compaction on LogUnit servers logUnitServer.runCompaction(); rt.getAddressSpaceView().resetCaches(); rt.getAddressSpaceView().invalidateServerCaches(); }

sample: 1217
buggy_code: private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException { try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) { ByteStreams.copy(from, channel); <START> return; <END> } }
code_review: This addition is pointless
target code: private void writeToChannelVersionOne ( WritableByteChannel channel ) throws IOException { try ( ReadableByteChannel from = Channels . newChannel ( combineStreams ( ) . getInput ( ) ) ) { ByteStreams . copy ( from , channel ) ; } }
response: private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException { try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) { ByteStreams.copy(from, channel); <START> return; <END> } }

sample: 1218
buggy_code: protected void setUp() throws Exception { super.setUp(); Statement stmt = con.createStatement(); /* Drop the test table if it already exists for some reason. It is not an error if it doesn't exist. */ TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP"); stmt.close(); /* Generally recommended with batch updates. By default we run all tests in this test case with autoCommit disabled. */ <START> con.setAutoCommit(false); <END> }
code_review: Please remove that
target code: protected void setUp ( ) throws Exception { super . setUp ( ) ; Statement stmt = con . createStatement ( ) ; /* Drop the test table if it already exists for some reason . It is not an error if it doesn't exist . */ TestUtil . createTable ( con , "testtz" , "col1 INTEGER , col2 TIMESTAMP" ) ; stmt . close ( ) ; }
response: protected void setUp() throws Exception { super.setUp(); Statement stmt = con.createStatement(); /* Drop the test table if it already exists for some reason. It is not an error if it doesn't exist. */ TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP"); stmt.close(); /* Generally recommended with batch updates. By default we run all tests in this test case with autoCommit disabled. */ con.setAutoCommit(false); }

sample: 1219
buggy_code: public List<Currency> getCurrencyForName(final String name) { List<Currency> list = _namesToCurrency.get(name); <START> if (list == null) { <END> return new ArrayList<>(); } return _namesToCurrency.get(name); }
code_review: These null checks will disappear if using a multimap
target code: public List < Currency > getCurrencyForName ( final String name ) { return _namesToCurrency . get ( name ) ; }
response: public List<Currency> getCurrencyForName(final String name) { List<Currency> list = _namesToCurrency.get(name); <START> if (list == null) { <END> return new ArrayList<>(); } return _namesToCurrency.get(name); }

sample: 1220
buggy_code: private static boolean parseAllowAlias(List<Option> options) { Option option = Option.findByName(options, "allow_alias"); if (option != null) { Object value = option.getValue(); <START> return value instanceof Boolean ? (Boolean) value : "true".equals(value); <END> } return false; }
code_review: What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
target code: private static boolean parseAllowAlias ( List < Option > options ) { Option option = Option . findByName ( options , "allow_alias" ) ; if ( option != null ) { Object value = option . getValue ( ) ; return value instanceof Boolean && ( Boolean ) value ; } return false ; }
response: private static boolean parseAllowAlias(List<Option> options) { Option option = Option.findByName(options, "allow_alias"); if (option != null) { Object value = option.getValue(); <START> return value instanceof Boolean ? (Boolean) value : "true".equals(value); <END> } return false; }

sample: 1221
buggy_code: public WebArchive createDeployment() { <START> if (resourceLocal) { <END> archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class ); } else { archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class ); } return archive; }
code_review: Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest.
target code: public WebArchive createDeployment ( ) { if ( resourceLocal ) { archive . addClasses ( MemberRegistrationWithResourceLocal . class ) ; } else { archive . addClasses ( MemberRegistrationWithJta . class , JtaResources . class ) ; } return archive ; }
response: public WebArchive createDeployment() { <START> if (resourceLocal) { <END> archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class ); } else { archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class ); } return archive; }

sample: 1222
buggy_code: private StorageDomain recoverStorageDomain(String sdUUID) { <START> log.info("about to recover SD {}", sdUUID); <END> StorageDomain storageDomain = new StorageDomain(); storageDomain.setId(sdUUID); updateStorageDomain(storageDomain); return storageDomain; }
code_review: log.debug ?
target code: private StorageDomain recoverStorageDomain ( String sdUUID ) { log . warn ( "about to recover SD { } " , sdUUID ) ; StorageDomain storageDomain = new StorageDomain ( ) ; storageDomain . setId ( sdUUID ) ; updateStorageDomain ( storageDomain ) ; return storageDomain ; }
response: private StorageDomain recoverStorageDomain(String sdUUID) { <START> log.debug("about to recover SD {}", sdUUID); <END> StorageDomain storageDomain = new StorageDomain(); storageDomain.setId(sdUUID); updateStorageDomain(storageDomain); return storageDomain; }

sample: 1223
buggy_code: public Event complianceCreated(Consumer consumer, Set<Entitlement> entitlements, ComplianceStatus compliance) { return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE, consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(), <START> consumer.getId(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, <END> null); }
code_review: We'll need the second usage of consumer.getId() replaced with consumer.getUuid() as well.
target code: public Event complianceCreated ( Consumer consumer , Set < Entitlement > entitlements , ComplianceStatus compliance ) { // Instead of an internal db id , compliance . created events now use // UUID for the 'consumerId' and 'entityId' fields , since Katello // is concerned only with the consumer UUID field . This is the first // part of a larger piece of work to simplify Event consumption . return new Event ( Event . Type . CREATED , Event . Target . COMPLIANCE , consumer . getName ( ) , principalProvider . get ( ) , consumer . getOwner ( ) . getId ( ) , consumer . getUuid ( ) , consumer . getUuid ( ) , null , buildComplianceDataJson ( consumer , entitlements , compliance ) , null , null ) ; }
response: public Event complianceCreated(Consumer consumer, Set<Entitlement> entitlements, ComplianceStatus compliance) { return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE, consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(), <START> consumer.getUuid(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, <END> null); }

sample: 1224
buggy_code: public static String toHexString(byte[] digest) { <START> StringBuffer buf <END> = new StringBuffer(); for (int i = 0; i < digest.length; i++) { if ((digest[i] & 0xFF) < 0x10) buf.append('0'); buf.append(Integer.toHexString(digest[i] & 0xFF)); } return buf.toString(); }
code_review: Use StringBuilder please.
target code: public static String toHexString ( byte [ ] digest ) { StringBuilder buf = new StringBuilder ( ) ; for ( byte element : digest ) { if ( ( element & 0xFF ) < 0x10 ) buf . append ( '0' ) ; buf . append ( Integer . toHexString ( element & 0xFF ) ) ; } return buf . toString ( ) ; }
response: public static String toHexString(byte[] digest) { <START> StringBuilder buf <END> = new StringBuilder(); for (int i = 0; i < digest.length; i++) { if ((digest[i] & 0xFF) < 0x10) buf.append('0'); buf.append(Integer.toHexString(digest[i] & 0xFF)); } return buf.toString(); }

sample: 1225
buggy_code: private boolean isLastKilledQueryGone() { boolean lastKilledQueryIsGone = (lastKilledQuery == null); <START> if (!lastKilledQueryIsGone) { <END> ClusterMemoryPool generalPool = pools.get(GENERAL_POOL); if (generalPool != null) { lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery); } } return lastKilledQueryIsGone; }
code_review: Invert this so it returns early
target code: private boolean isLastKilledQueryGone ( ) { if ( lastKilledQuery == null ) { return true ; } ClusterMemoryPool generalPool = pools . get ( GENERAL_POOL ) ; if ( generalPool == null ) { return false ; } return generalPool . getQueryMemoryReservations ( ) . containsKey ( lastKilledQuery ) ; }
response: private boolean isLastKilledQueryGone() { boolean lastKilledQueryIsGone = (lastKilledQuery == null); <START> if (lastKilledQueryIsGone) { <END> return lastKilledQueryIsGone; } ClusterMemoryPool generalPool = pools.get(GENERAL_POOL); if (generalPool != null) { lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery); } return lastKilledQueryIsGone; }

sample: 1226
buggy_code: public Batcher(ScheduledExecutorService workExecutor, int capacity, long delay, BatchProcessor<T> processor) { this.workExecutor = workExecutor; this.capacity = capacity; this.delay = delay; this.processor = processor; this.inbox = new ArrayList<T>(); this.scheduled = false; <START> this.lastProcessedTime = 0; <END> }
code_review: Is this change that makes batcher immediately execute after create new instance of Batcher and then added tasks smaller than capacity size?
target code: public Batcher ( ScheduledExecutorService workExecutor , int capacity , long delay , BatchProcessor < T > processor ) { this . workExecutor = workExecutor ; this . capacity = capacity ; this . delay = delay ; this . processor = processor ; }
response: public Batcher(ScheduledExecutorService workExecutor, int capacity, long delay, BatchProcessor<T> processor) { this.workExecutor = workExecutor; this.capacity = capacity; this.delay = delay; this.processor = processor; this.inbox = new ArrayList<T>(); this.scheduled = false; <START> this.lastProcessedTime = 0; this.lastProcessedTime = System.currentTimeMillis(); <END> }

sample: 1227
buggy_code: public static void removeMagicResponseContextFields(Map<String, Object> responseContext) { <START> responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); <END> responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED); }
code_review: This line should also be removed.
target code: public static void removeMagicResponseContextFields ( Map < String , Object > responseContext ) { responseContext . remove ( DirectDruidClient . QUERY_TOTAL_BYTES_GATHERED ) ; }
response: public static void removeMagicResponseContextFields(Map<String, Object> responseContext) { <START> responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED); <END> }

sample: 1228
buggy_code: private void validateAndClose() throws Exception { try { info("Validating static and Helix cluster maps"); verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout); if (validatingHelixClusterManager != null) { <START> ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, <END> "Helix cluster manager should not have encountered any errors"); } } finally { if (validatingHelixClusterManager != null) { validatingHelixClusterManager.close(); } for (HelixAdmin admin : adminForDc.values()) { admin.close(); } } }
code_review: no Exception is thrown in this method
target code: private void validateAndClose ( ) { try { info ( "Validating static and Helix cluster maps" ) ; verifyEquivalencyWithStaticClusterMap ( staticClusterMap . hardwareLayout , staticClusterMap . partitionLayout ) ; if ( validatingHelixClusterManager != null ) { ensureOrThrow ( validatingHelixClusterManager . getErrorCount ( ) == 0 , "Helix cluster manager should not have encountered any errors" ) ; } } finally { if ( validatingHelixClusterManager != null ) { validatingHelixClusterManager . close ( ) ; } for ( HelixAdmin admin : adminForDc . values ( ) ) { admin . close ( ) ; } } }
response: private void validateAndClose() { try { info("Validating static and Helix cluster maps"); verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout); if (validatingHelixClusterManager != null) { <START> ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, <END> "Helix cluster manager should not have encountered any errors"); } } finally { if (validatingHelixClusterManager != null) { validatingHelixClusterManager.close(); } for (HelixAdmin admin : adminForDc.values()) { admin.close(); } } }

sample: 1229
buggy_code: public int size() { if (currentOffset == NO_VALUES) { return 0; } <START> return maxOffset - currentOffset - 1; <END> }
code_review: Consider: `return currentOffset == NO_VALUES ? 0 : maxOffset - currentOffset - 1;`
target code: public int size ( ) { return isEmpty ( ) ? 0 : maxOffset - currentOffset ; }
response: public int size() { if (currentOffset == NO_VALUES) { return 0; } return maxOffset - currentOffset - 1; }

sample: 1230
buggy_code: <START> public void updateEditorPages(int activatedPage) { <END> removeAllPages(); addPages(); if (backToActivePage > 0 && backToActivePage < this.getPageCount()) { setActivePage(backToActivePage); } else { //Set active page if the backToActivePage is out of the range setActivePage(0); } setPartName(getPartName()); }
code_review: activatedPage is not used anymore
target code: public void updateEditorPages ( int activatedPage ) { updateEditorPages ( ) ; }
response: <START> public void updateEditorPages() { <END> removeAllPages(); addPages(); if (backToActivePage > 0 && backToActivePage < this.getPageCount()) { setActivePage(backToActivePage); } else { //Set active page if the backToActivePage is out of the range setActivePage(0); } setPartName(getPartName()); }

sample: 1231
buggy_code: public Object execute(ExecutionEvent event) throws ExecutionException { <START> Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); <END> if (checkCompositeRename != null) { return checkForCompositeRename(event, checkCompositeRename); } else { performRename(event); } return null; }
code_review: Looking at other HandlerUtil.getVariable() calls, the usual logic is to look for an instance of what you were looking for (in this case Boolean) and to treat any other situation as if null was provided. This would remove the need to check for Boolean in checkForCompositeRename and having code to issue an error log message which should never occur.
target code: public Object execute ( ExecutionEvent event ) throws ExecutionException { Object checkCompositeRename = HandlerUtil . getVariable ( event , LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY ) ; if ( checkCompositeRename instanceof Boolean ) { return checkForCompositeRename ( event ) ; } else { performRename ( event ) ; } return null ; }
response: public Object execute(ExecutionEvent event) throws ExecutionException { <START> Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); <END> if (checkCompositeRename instanceof Boolean) { return checkForCompositeRename(event, checkCompositeRename); } else { performRename(event); } return null; }

sample: 1232
buggy_code: <START> public Arguments setUntypedNullArgument(Argument untypedNullArgument) { <END> if (untypedNullArgument == null) { throw new IllegalArgumentException("the Argument itself may not be null"); } this.untypedNullArgument = untypedNullArgument; return this; }
code_review: Another non-permissible change
target code: public void setUntypedNullArgument ( Argument untypedNullArgument ) { if ( untypedNullArgument == null ) { throw new IllegalArgumentException ( "the Argument itself may not be null" ) ; } this . untypedNullArgument = untypedNullArgument ; }
response: <START> public Arguments setUntypedNullArgument(Argument untypedNullArgument) { <END> if (untypedNullArgument == null) { throw new IllegalArgumentException("the Argument itself may not be null"); } this.untypedNullArgument = untypedNullArgument; return this; }

sample: 1233
buggy_code: private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) { if (func.startsWith("Constant")) { <START> return drf.constantPerIssue(constantCost.replace("mn", "min")); <END> } if ("Linear".equals(func)) { return drf.linear(linearFactor.replace("mn", "min")); } return drf.linearWithOffset(linearFactor.replace("mn", "min"), linearOffset.replace("mn", "min")); }
code_review: @ivandalbosco I see that you just copied this piece from JS, but it's not perfect there :) We can drop `.replace("mn", "min")` everywhere (3 places). This was done as many RSPECs had legacy `mn` for minutes. It should be fixed now. It there is still some RSPEC using `mn` and plugin fails, then you better update this RSPEC
target code: private DebtRemediationFunction remediationFunction ( DebtRemediationFunctions drf ) { if ( func . startsWith ( "Constant" ) ) { return drf . constantPerIssue ( constantCost ) ; } if ( "Linear" . equals ( func ) ) { return drf . linear ( linearFactor ) ; } return drf . linearWithOffset ( linearFactor , linearOffset ) ; }
response: private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) { if (func.startsWith("Constant")) { <START> return drf.constantPerIssue(constantCost); <END> } if ("Linear".equals(func)) { return drf.linear(linearFactor); } return drf.linearWithOffset(linearFactor, linearOffset); }

sample: 1234
buggy_code: public void setAnalysisCache(final AnalysisCache cache) { if (cache == null && isAnalysisCacheFunctional()) { analysisCache = new NoopAnalysisCache(); // Log warning only once, if not explicitly disabled if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) { final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? "latest" : "pmd-" + PMDVersion.VERSION; <START> LOG.warning("This analysis could be faster, please consider using Incremental Analysis: " <END> + "https://pmd.github.io/" + version + "/pmd_userdocs_getting_started.html#incremental-analysis"); } } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled analysisCache = cache; } }
code_review: I find it very unintuitive to find this here... I'd suggest moving the log to `PMD.doPMD`, which is guaranteed to run once and a little more natural
target code: public void setAnalysisCache ( final AnalysisCache cache ) { // the doc says it's a noop if incremental analysis was disabled , // but it's actually the getter that enforces that this . analysisCache = cache == null ? new NoopAnalysisCache ( ) : cache ; }
response: public void setAnalysisCache(final AnalysisCache cache) { if (cache == null && isAnalysisCacheFunctional()) { analysisCache = new NoopAnalysisCache(); // Log warning only once, if not explicitly disabled if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) { final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? "latest" : "pmd-" + PMDVersion.VERSION; LOG.warning("This analysis could be faster, please consider using Incremental Analysis: " + "https://pmd.github.io/" + version + "/pmd_userdocs_getting_started.html#incremental-analysis"); } } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled analysisCache = cache; } }

sample: 1235
buggy_code: private static double sortableLongToDouble(long value) { <START> value = value ^ (value >> 63) & Long.MAX_VALUE; <END> return Double.longBitsToDouble(value); }
code_review: Same here. Add clarifying parenthesis
target code: private static double sortableLongToDouble ( long value ) { value = value ^ ( ( value > > 63 ) & Long . MAX_VALUE ) ; return Double . longBitsToDouble ( value ) ; }
response: private static double sortableLongToDouble(long value) { <START> value = (value ^ (value >> 63)) & Long.MAX_VALUE; <END> return Double.longBitsToDouble(value); }

sample: 1236
buggy_code: public static Exception extractExecutionExceptionCause(Exception e) { if (!(e instanceof ExecutionException)) { return e; } Throwable cause = e.getCause(); return cause == null ? e : (cause instanceof Exception ? (Exception) cause : new Exception(cause)); <START> } <END>
code_review: ``` if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause); ``` How about making return statement simpler?
target code: public static Exception extractExecutionExceptionCause ( Exception e ) { Throwable cause = e . getCause ( ) ; if ( ! ( e instanceof ExecutionException ) || cause == null ) { return e ; } return cause instanceof Exception ? ( Exception ) cause : new Exception ( cause ) ; }
response: public static Exception extractExecutionExceptionCause(Exception e) { if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause); <START> } <END>

sample: 1237
buggy_code: boolean isEmpty() { <START> return (validIndexSegments.isEmpty()); <END> }
code_review: minor: braces unnecessary
target code: boolean isEmpty ( ) { return validIndexSegments . isEmpty ( ) ; }
response: boolean isEmpty() { <START> return validIndexSegments.isEmpty(); <END> }

sample: 1238
buggy_code: Set getDefaultIgnoreTypeNames() { Set ignored = new HashSet(); String[] ignore = {"org.eclipse.core.runtime.Plugin", "java.lang.ClassLoader", "org.eclipse.team.internal.ccvs.core.CVSTeamProvider", "org.eclipse.core.internal.events.BuilderPersistentInfo", "org.eclipse.core.internal.resources.Workspace", "org.eclipse.core.internal.events.EventStats", "java.net.URL"}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$ <START> for (String element : ignore) { <END> ignored.add(element); } return ignored; }
code_review: Please do only whitespace changes in this commit.
target code: Set getDefaultIgnoreTypeNames ( ) { Set ignored = new HashSet ( ) ; String [ ] ignore = { "org . eclipse . core . runtime . Plugin" , "java . lang . ClassLoader" , "org . eclipse . team . internal . ccvs . core . CVSTeamProvider" , "org . eclipse . core . internal . events . BuilderPersistentInfo" , "org . eclipse . core . internal . resources . Workspace" , "org . eclipse . core . internal . events . EventStats" , "java . net . URL" } ; // $NON - NLS - 1$ // $NON - NLS - 2$ // $NON - NLS - 6$ for ( int i = 0 ; i < ignore . length ; i ++ ) { ignored . add ( ignore [ i ] ) ; } return ignored ; }
response: Set getDefaultIgnoreTypeNames() { Set ignored = new HashSet(); String[] ignore = {"org.eclipse.core.runtime.Plugin", "java.lang.ClassLoader", "org.eclipse.team.internal.ccvs.core.CVSTeamProvider", "org.eclipse.core.internal.events.BuilderPersistentInfo", "org.eclipse.core.internal.resources.Workspace", "org.eclipse.core.internal.events.EventStats", "java.net.URL"}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$ <START> for (String element : ignore) { <END> ignored.add(element); } return ignored; }

sample: 1239
buggy_code: public static boolean delete(File file) { if (!file.exists()) return true; if (file.isDirectory()) { File[] children = file.listFiles(); for (File <START> children1 : <END> children) { delete(children1); } } return file.delete(); }
code_review: child
target code: public static boolean delete ( File file ) { if ( ! file . exists ( ) ) return true ; if ( file . isDirectory ( ) ) { File [ ] children = file . listFiles ( ) ; for ( File child : children ) { delete ( child ) ; } } return file . delete ( ) ; }
response: public static boolean delete(File file) { if (!file.exists()) return true; if (file.isDirectory()) { File[] children = file.listFiles(); for (File child : children) { delete(child); } } return file.delete(); }

sample: 1240
buggy_code: public void logout(final IProgressMonitor monitor) throws XmlRpcException { userID = -1; token = null; (new BugzillaXmlRpcOperation<Integer>(this) { @SuppressWarnings("serial") @Override public Integer execute() throws XmlRpcException { try { <START> bugzillaClient.authenticate(monitor); <END> } catch (CoreException e) { // TODO Auto-generated catch block e.printStackTrace(); } Object response = call(monitor, XML_USER_LOGOUT, null); return -1; } }).execute(); return; }
code_review: Why do we call authenticate to log out? If we aren't already authenticated, why do we need to log out?
target code: public void logout ( final IProgressMonitor monitor ) throws XmlRpcException { ( new BugzillaXmlRpcOperation < Integer > ( this ) { @SuppressWarnings ( "serial" ) @Override public Integer execute ( ) throws XmlRpcException { Object response = call ( monitor , XML_USER_LOGOUT , null ) ; return - 1 ; } } ) . execute ( ) ; userID = - 1 ; token = null ; return ; }
response: public void logout(final IProgressMonitor monitor) throws XmlRpcException { userID = -1; token = null; (new BugzillaXmlRpcOperation<Integer>(this) { @SuppressWarnings("serial") @Override public Integer execute() throws XmlRpcException { try { <START> bugzillaClient.authenticate(monitor); <END> } catch (CoreException e) { // TODO Auto-generated catch block e.printStackTrace(); } Object response = call(monitor, XML_USER_LOGOUT, null); return -1; } }).execute(); return; }

sample: 1241
buggy_code: private double cleanNumber(double dirtyNumber) { <START> double clean; <END> if (dirtyNumber < 1) clean = 0; else clean = dirtyNumber; return clean; }
code_review: Could be simplified to: ```java return dirtyNumber < 1 ? 0 : dirtyNumber; ```
target code: private double cleanNumber ( double dirtyNumber ) { return dirtyNumber < 1 ? 0 : dirtyNumber ; }
response: private double cleanNumber(double dirtyNumber) { <START> <END> return dirtyNumber < 1 ? 0 : dirtyNumber; }

sample: 1242
buggy_code: public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); <END> }
code_review: Same here: The new flag `withAttempts` is not passed (used) the `paymentProcessor#getAccountPayments`
target code: public Pagination < Payment > getPayments ( final Long offset , final Long limit , final String pluginName , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getPayments ( offset , limit , pluginName , withPluginInfo , withAttempts , properties , tenantContext , internalCallContextFactory . createInternalTenantContext ( tenantContext ) ) ; }
response: public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); <END> }

sample: 1243
buggy_code: <START> private static Map<String, String> readMessagesFromBundle() { <END> try { ResourceBundle bundle = ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME); Map<String, String> messages = new HashMap<String, String>(); for (String key : bundle.keySet()) { messages.put(key, bundle.getString(key)); } return messages; } catch (MissingResourceException e) { log.error("Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME); throw new ApplicationException(e); } }
code_review: why do you need to convert the bundle to a map, instead of using it directly?
target code: private static ResourceBundle readMessagesFromBundle ( ) { try { return ResourceBundle . getBundle ( APP_ERRORS_MESSAGES_FILE_NAME ) ; } catch ( MissingResourceException e ) { log . error ( "Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME ) ; throw new ApplicationException ( e ) ; } }
response: <START> private static ResourceBundle readMessagesFromBundle() { <END> try { return ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME); } catch (MissingResourceException e) { log.error("Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME); throw new ApplicationException(e); } }

sample: 1244
buggy_code: public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; <START> if (getClass() != obj.getClass()) return false; <END> BigFraction otherValue = ((ILScore)obj).getValue(); return this.value.equals(otherValue); }
code_review: Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
target code: public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; BigFraction otherValue = ( ( ILScore ) obj ) . getValue ( ) ; return this . value . equals ( otherValue ) ; }
response: public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; BigFraction otherValue = ((ILScore)obj).getValue(); return this.value.equals(otherValue); }

sample: 1245
buggy_code: private boolean isValidReviewer(Account member, ChangeControl control) { if (member.isActive()) { IdentifiedUser user = identifiedUserFactory.create(member.getId()); // Does not account for draft status as a user might want to let a // reviewer see a draft. <START> if (control.forUser(user).isRefVisible()) { return true; } <END> } return false; }
code_review: [optional] this could be shortened to: return control.forUser(user).isRefVisible();
target code: private boolean isValidReviewer ( Account member , ChangeControl control ) { if ( member . isActive ( ) ) { IdentifiedUser user = identifiedUserFactory . create ( member . getId ( ) ) ; // Does not account for draft status as a user might want to let a // reviewer see a draft . return control . forUser ( user ) . isRefVisible ( ) ; } return false ; }
response: private boolean isValidReviewer(Account member, ChangeControl control) { if (member.isActive()) { IdentifiedUser user = identifiedUserFactory.create(member.getId()); // Does not account for draft status as a user might want to let a // reviewer see a draft. <START> return control.forUser(user).isRefVisible(); <END> } return false; }

sample: 1246
buggy_code: private boolean support( ValueGroup[] valueGroups ) { <START> return valueGroups.length == 1 && ValueGroup.NUMBER.equals( valueGroups[0] ); <END> }
code_review: please use == for enum comparisons like its done 2 lines above
target code: private boolean support ( ValueGroup [ ] valueGroups ) { return valueGroups . length == 1 && valueGroups [ 0 ] == ValueGroup . NUMBER ; }
response: private boolean support( ValueGroup[] valueGroups ) { <START> return valueGroups.length == 1 && ValueGroup.NUMBER == valueGroups[0]; <END> }

sample: 1247
buggy_code: <START> public String getConfigFile() <END> { return configFile; }
code_review: You can make this file `File`
target code: public File getConfigFile ( ) { return configFile ; }
response: <START> public File getConfigFile() <END> { return configFile; }

sample: 1248
buggy_code: <START> void close() { <END> writeQueue.add(WriteOperation.SHUTDOWN); writerService.shutdown(); }
code_review: Probably won't be used, but you should implement AutoCloseable, since you implement close() anyway.
target code: public void close ( ) { writeQueue . add ( WriteOperation . SHUTDOWN ) ; writerService . shutdown ( ) ; }
response: <START> void close() throws IOException { <END> writeQueue.add(WriteOperation.SHUTDOWN); writerService.shutdown(); }

sample: 1249
buggy_code: private void completeInner() { // A group is removed, so check if we need to call `unsubscribe` if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) { // It means `groups.isEmpty() && child.isUnsubscribed()` is true unsubscribe(); } // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { <END> // completionEmitted ensures we only emit onCompleted once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onCompleted(); } } } }
code_review: Wouldn't this be an `if/else`? If we just `unsubscribed` in the previous lines I don't think we should ever go through this flow.
target code: private void completeInner ( ) { // A group is removed , so check if we need to call `unsubscribe` if ( WIP_FOR_UNSUBSCRIBE_UPDATER . decrementAndGet ( this ) == 0 ) { // It means `groups . isEmpty ( ) && child . isUnsubscribed ( ) ` is true unsubscribe ( ) ; } else if ( groups . isEmpty ( ) && terminated == TERMINATED_WITH_COMPLETED ) { // if we have no outstanding groups ( all completed or unsubscribe ) and terminated on outer // completionEmitted ensures we only emit onCompleted once if ( COMPLETION_EMITTED_UPDATER . compareAndSet ( this , 0 , 1 ) ) { child . onCompleted ( ) ; } } }
response: private void completeInner() { // A group is removed, so check if we need to call `unsubscribe` if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) { // It means `groups.isEmpty() && child.isUnsubscribed()` is true unsubscribe(); } // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { <END> // completionEmitted ensures we only emit onCompleted once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onCompleted(); } } } else { // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_ERROR) { <END> // completionEmitted ensures we only emit onError once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onError(error); } } } } }

sample: 1250
buggy_code: protected boolean startError() { if (errorCount == 0) { <START> logger.error("Found one or more vector errors from " + opName); <END> } errorCount++; if (errorCount >= MAX_ERRORS) { return false; } return true; }
code_review: ```suggestion logger.error("Found one or more vector errors from {}", opName); ```
target code: protected boolean startError ( ) { if ( errorCount == 0 ) { warn ( "Found one or more vector errors from " + opName ) ; } errorCount ++ ; if ( errorCount >= MAX_ERRORS ) { return false ; } return true ; }
response: protected boolean startError() { if (errorCount == 0) { <START> logger.error("Found one or more vector errors from {}", opName); <END> } errorCount++; if (errorCount >= MAX_ERRORS) { return false; } return true; }

sample: 1251
buggy_code: protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) { List<Integer> resultLineNumbers = new ArrayList<>(); Reader reader = null; try { reader = new FileReader(fileName); resultLineNumbers = grep(reader, regexp, resultLines); }catch (IOException e) { e.printStackTrace(); } finally { <START> closeQuietly(reader); <END> } return resultLineNumbers; }
code_review: We use Java7, so you should use the try-with-resources feature.
target code: protected static List < Integer > grep ( File fileName , String regexp , List < String > resultLines ) { List < Integer > resultLineNumbers = new ArrayList < > ( ) ; try ( Reader reader = new FileReader ( fileName ) ) { resultLineNumbers = grep ( reader , regexp , resultLines ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return resultLineNumbers ; }
response: protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) { List<Integer> resultLineNumbers = new ArrayList<>(); try (Reader reader = new FileReader(fileName)) { resultLineNumbers = grep(reader, regexp, resultLines); }catch (IOException e) { e.printStackTrace(); } return resultLineNumbers; }

sample: 1252
buggy_code: private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) { <START> Intent launchIntent = new Intent(INTENT_ACTION); <END> launchIntent.putExtra(Intents.EXTRA_NAME, destName); launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode); launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude()); launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude()); activity.startService(launchIntent); }
code_review: Missing `final` (was indicated on the previous patch as well).
target code: private static void navigate ( final Activity activity , final String destName , final String destCode , final Geopoint coords ) { final Intent launchIntent = new Intent ( INTENT_ACTION ) ; launchIntent . putExtra ( Intents . EXTRA_NAME , destName ) . putExtra ( Intents . EXTRA_GEOCODE , destCode ) . putExtra ( Intents . EXTRA_LATITUDE , coords . getLatitude ( ) ) . putExtra ( Intents . EXTRA_LONGITUDE , coords . getLongitude ( ) ) ; activity . startService ( launchIntent ) ; }
response: private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) { <START> final Intent launchIntent = new Intent(INTENT_ACTION); <END> launchIntent.putExtra(Intents.EXTRA_NAME, destName); launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode); launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude()); launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude()); activity.startService(launchIntent); }

sample: 1253
buggy_code: public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) { <START> Preconditions.checkNotNull(serverContent, <END> "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); }
code_review: static import
target code: public TestMediaWikiApiImageFetchingStrategy ( Map < String , String > serverContent ) { checkNotNull ( serverContent , "Please specify some server content for images used during the tests . See : TestMediaWikiApiImageFetchingStrategy#serverContent" ) ; this . serverContent = ImmutableMap . copyOf ( serverContent ) ; }
response: public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) { <START> checkNotNull(serverContent, <END> "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); }

sample: 1254
buggy_code: private static boolean shouldCreateMyHandler(PsiElement element) { if (element instanceof LeafPsiElement) { LeafPsiElement leaf = (LeafPsiElement)element; return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf); } <START> else { <END> return false; } }
code_review: A redundant else statement
target code: private static boolean shouldCreateMyHandler ( PsiElement element ) { if ( element instanceof LeafPsiElement ) { LeafPsiElement leaf = ( LeafPsiElement ) element ; return leaf . getElementType ( ) == GoTypes . RETURN || leaf . getElementType ( ) == GoTypes . FUNC || isPanicCall ( leaf ) ; } return false ; }
response: private static boolean shouldCreateMyHandler(PsiElement element) { if (element instanceof LeafPsiElement) { LeafPsiElement leaf = (LeafPsiElement)element; return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf); } <START> return false; <END> }

sample: 1255
buggy_code: <START> private void cancelRxCommands() { <END> for (CommandHandle commandHandle : fRxCommands.values()) { if (commandHandle.getRequestMonitor() == null) continue; commandHandle.getRequestMonitor().setStatus(genStatus( "Connection is shut down")); //$NON-NLS-1$ commandHandle.getRequestMonitor().done(); } fRxCommands.clear(); }
code_review: Wouldn't it be safer to make this method synchronized?
target code: private synchronized void cancelRxCommands ( ) { for ( CommandHandle commandHandle : fRxCommands . values ( ) ) { if ( commandHandle . getRequestMonitor ( ) == null ) continue ; commandHandle . getRequestMonitor ( ) . setStatus ( genStatus ( "Connection is shut down" ) ) ; // $NON - NLS - 1$ commandHandle . getRequestMonitor ( ) . done ( ) ; } fRxCommands . clear ( ) ; }
response: <START> private synchronized void cancelRxCommands() { <END> for (CommandHandle commandHandle : fRxCommands.values()) { if (commandHandle.getRequestMonitor() == null) continue; commandHandle.getRequestMonitor().setStatus(genStatus( "Connection is shut down")); //$NON-NLS-1$ commandHandle.getRequestMonitor().done(); } fRxCommands.clear(); }

sample: 1256
buggy_code: private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores ) { Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService ); LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE; return new Supplier<StorageStatement>() { @Override public StorageStatement get() { return new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService, allocateCommandCreationContext() ); } <START> }; <END> }
code_review: No need to expand the lambda
target code: private Supplier < StorageStatement > storeStatementSupplier ( NeoStores neoStores ) { Supplier < IndexReaderFactory > indexReaderFactory = ( ) - > new IndexReaderFactory . Caching ( indexingService ) ; LockService lockService = takePropertyReadLocks ? this . lockService : NO_LOCK_SERVICE ; return ( ) - > new StoreStatement ( neoStores , indexReaderFactory , labelScanStore : : newReader , lockService , allocateCommandCreationContext ( ) ) ; }
response: private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores ) { Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService ); LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE; return () -> new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService, allocateCommandCreationContext() ); }

sample: 1257
buggy_code: <START> public static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { <END> byte[] byteArr = new byte[(boolArr.length + 7) / 8]; for (int i = 0; i < byteArr.length; i++) { byteArr[i] = readByte(boolArr, 8 * i); } return byteArr; }
code_review: Can be package-private?
target code: static byte [ ] convertBoolArrayToByteArray ( boolean [ ] boolArr ) { byte [ ] byteArr = new byte [ ( boolArr . length + 7 ) / 8 ] ; for ( int i = 0 ; i < byteArr . length ; i ++ ) { byteArr [ i ] = readByte ( boolArr , 8 * i ) ; } return byteArr ; }
response: <START> static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { <END> byte[] byteArr = new byte[(boolArr.length + 7) / 8]; for (int i = 0; i < byteArr.length; i++) { byteArr[i] = readByte(boolArr, 8 * i); } return byteArr; }

sample: 1258
buggy_code: public void all_composed_assertions_should_pass() { SoftAssertions delegate = new SoftAssertions(); delegate.assertThat(1).isEqualTo(1); delegate.assertAll(); softly.assertThat(1).isEqualTo(1); <START> softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 2); <END> softly.assertAlso(delegate); softly.assertAll(); assertThat(softly.wasSuccess()).isTrue(); }
code_review: Minor: use AssertJ `org.assertj.core.util.List.list` and static import for readability.
target code: public void all_composed_assertions_should_pass ( ) { // GIVEN SoftAssertions delegate = new SoftAssertions ( ) ; delegate . assertThat ( 1 ) . isEqualTo ( 1 ) ; delegate . assertAll ( ) ; softly . assertThat ( 1 ) . isEqualTo ( 1 ) ; softly . assertThat ( list ( 1 , 2 ) ) . containsOnly ( 1 , 2 ) ; // WHEN softly . assertAlso ( delegate ) ; softly . assertAll ( ) ; // THEN assertThat ( softly . wasSuccess ( ) ) . isTrue ( ) ; }
response: public void all_composed_assertions_should_pass() { SoftAssertions delegate = new SoftAssertions(); delegate.assertThat(1).isEqualTo(1); delegate.assertAll(); softly.assertThat(1).isEqualTo(1); <START> softly.assertThat(list(1, 2)).containsOnly(1, 2); <END> softly.assertAlso(delegate); softly.assertAll(); assertThat(softly.wasSuccess()).isTrue(); }

sample: 1259
buggy_code: public void viewInfoUpdated() { <START> this.reinitialize(); <END> }
code_review: * Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
target code: public void viewInfoUpdated ( ) { reinitialize ( ) ; }
response: public void viewInfoUpdated() { <START> super.reinitialize(); <END> }

sample: 1260
buggy_code: <START> public JSONPointer(List<String> refTokens) { <END> this.refTokens = refTokens; }
code_review: This should either be a **protected/private/or default** constructor, and the **List** should be copied so the Pointer can't be modified outside of the class. ``` java this.refTokens = refTokens.clone(); ``` as it is now, I could do this: ``` java Builder b = JSONPointer.builder().append("key1"); JSONPointer jp1 = b.build(); b.append("key2"); JSONPointer jp2 = b.build(); if(jp1.toString().equals(jp2.toString()){ throw new Exception("Oops, my pointers are sharing a backing array"); } ```
target code: public JSONPointer ( List < String > refTokens ) { this . refTokens = new ArrayList < String > ( refTokens ) ; }
response: <START> public JSONPointer(List<String> refTokens) { <END> this.refTokens = refTokens.clone(); }

sample: 1261
buggy_code: public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); <START> mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); <END> mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = ""; mFloppyPath = ""; mRunAndPause = false; _diskSize = 0; }
code_review: coudl be just ArrayList since now it is imported ^^ vv
target code: public VM ( ) { mVmStatic = new VmStatic ( ) ; mVmDynamic = new VmDynamic ( ) ; mVmStatistics = new VmStatistics ( ) ; mVmStatic . setImages ( new ArrayList < DiskImage > ( ) ) ; mVmStatic . setInterfaces ( new ArrayList < VmNetworkInterface > ( ) ) ; mDiskMap = new java . util . HashMap < String , DiskImage > ( ) ; mCdPath = "" ; mFloppyPath = "" ; mRunAndPause = false ; _diskSize = 0 ; }
response: public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); <START> mVmStatic.setImages(new ArrayList<DiskImage>()); <END> mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = ""; mFloppyPath = ""; mRunAndPause = false; _diskSize = 0; }

sample: 1262
buggy_code: <START> long consumerLag() { <END> return consumerLag; }
code_review: Would suggest to make it `private`.
target code: private long consumerLag ( ) { return consumerLag ; }
response: <START> private long consumerLag() { <END> return consumerLag; }

sample: 1263
buggy_code: public RegexGroupFilter(final int groupIdx) { if (groupIdx < 1) <START> throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, groupIdx)); <END> this.groupIdx = groupIdx - 1; }
code_review: In most other places we suppress boxing warnings by manually boxing in the code with Integer.valueOf() around the expression. This is especially true in MessageFormat.format invocations, which are very common in our error paths. I think that is the general approach preferred within JGit.
target code: public RegexGroupFilter ( final int groupIdx ) { if ( groupIdx < 1 ) throw new IllegalArgumentException ( MessageFormat . format ( HttpServerText . get ( ) . invalidIndex , valueOf ( groupIdx ) ) ) ; this . groupIdx = groupIdx - 1 ; }
response: public RegexGroupFilter(final int groupIdx) { if (groupIdx < 1) <START> throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, Integer.valueOf(groupIdx))); <END> this.groupIdx = groupIdx - 1; }

sample: 1264
buggy_code: public void testChunkFillingBlobSizeMultipleOfChunkSize() throws Exception { <START> blobSize = chunkSize * random.nextInt(10) + 1; <END> fillChunksAndAssertSuccess(); }
code_review: missing braces ? `blobSize` can end up to be 1 if `random.nextInt(10)` returns 0.
target code: public void testChunkFillingBlobSizeMultipleOfChunkSize ( ) throws Exception { blobSize = chunkSize * ( random . nextInt ( 10 ) + 1 ) ; fillChunksAndAssertSuccess ( ) ; }
response: public void testChunkFillingBlobSizeMultipleOfChunkSize() throws Exception { <START> blobSize = chunkSize * (random.nextInt(10) + 1); <END> fillChunksAndAssertSuccess(); }

sample: 1265
buggy_code: <START> EapAkaAttributeFactory() <END> {}
code_review: Suggest protected to signal that this is for the subclass
target code: protected EapAkaAttributeFactory ( ) { }
response: <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory() <END> { <START> EapAkaAttributeFactory()

sample: 1266
buggy_code: public byte[] toByteArray() { <START> return ByteBuffer.allocate(8).putLong(valueLong).array(); <END> }
code_review: I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file. This method was more for string, structs, etc. that we want to serialize.
target code: public byte [ ] toByteArray ( ) { return null ; }
response: public byte[] toByteArray() { <START> return null; <END> }

sample: 1267
buggy_code: public String getModeName() { String header = getHeader(); <START> return header.substring(0, header.indexOf(' ')); <END> }
code_review: there is no other way of getting article name?
target code: private String getModeName ( ) { String header = getHeader ( ) ; return header . substring ( 0 , header . indexOf ( ' ' ) ) ; }
response: public String getModeName() { String header = getHeader(); <START> return header.substring(0, header.indexOf(' ')); <END> }

sample: 1268
buggy_code: public int hashCode() { int result = bitSet; result = 31 * result + bitSet; <START> return result; <END> }
code_review: @vilchik-elena Why not simply returning `bitSet`?
target code: public int hashCode ( ) { return bitSet ; }
response: public int hashCode() { int result = bitSet; result = 31 * result + bitSet; <START> return bitSet; <END> }

sample: 1269
buggy_code: void setUnresolvedCompact(boolean unresolvedCompact) { this.unresolvedCompact = unresolvedCompact; if (outer != null) { <START> outer.setUnresolvedCompact(true); <END> } }
code_review: Not required
target code: void setUnresolvedCompact ( boolean unresolvedCompact ) { this . unresolvedCompact = unresolvedCompact ; }
response: void setUnresolvedCompact(boolean unresolvedCompact) { this.unresolvedCompact = unresolvedCompact; if (outer != null) { outer.setUnresolvedCompact(true); } }

sample: 1270
buggy_code: public static void afterClass() throws Exception { if (sLocalAlluxioJobCluster != null) { sLocalAlluxioJobCluster.stop(); } <START> sFileSystem.close(); <END> }
code_review: hrmmm, is this required? Will this happen already with the cluster teardown? And, is there redundant closing with the `after()` call?
target code: public static void afterClass ( ) throws Exception { if ( sLocalAlluxioJobCluster != null ) { sLocalAlluxioJobCluster . stop ( ) ; } }
response: public static void afterClass() throws Exception { if (sLocalAlluxioJobCluster != null) { sLocalAlluxioJobCluster.stop(); } <START> sFileSystem.close(); <END> }

sample: 1271
buggy_code: public void testTrimLongSuffix() throws Exception { <START> String longValue = "12345"; <END> assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "l")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "L")).isEqualTo(longValue); }
code_review: What If I give the empty string as an input of that method ?
target code: public void testTrimLongSuffix ( ) throws Exception { assertThat ( LiteralUtils . trimLongSuffix ( null ) ) . isEqualTo ( null ) ; assertThat ( LiteralUtils . trimLongSuffix ( "" ) ) . isEqualTo ( "" ) ; String longValue = "12345" ; assertThat ( LiteralUtils . trimLongSuffix ( longValue ) ) . isEqualTo ( longValue ) ; assertThat ( LiteralUtils . trimLongSuffix ( longValue + "l" ) ) . isEqualTo ( longValue ) ; assertThat ( LiteralUtils . trimLongSuffix ( longValue + "L" ) ) . isEqualTo ( longValue ) ; }
response: public void testTrimLongSuffix() throws Exception { <START> String longValue = "12345"; <END> assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "l")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "L")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix("")).isEqualTo(""); }

sample: 1272
buggy_code: public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> ret.put(node, null); return ret; }
code_review: spell out ret
target code: public Map < TableScanNode , Void > visitTableScan ( TableScanNode node , Void context ) { Map < TableScanNode , Void > result = new IdentityHashMap < > ( ) ; result . put ( node , null ) ; return result ; }
response: public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> result = new IdentityHashMap<>(); <END> result.put(node, null); return result; }

sample: 1273
buggy_code: public int getStreamIndex() { <START> return streamIndex; <END> }
code_review: should not be this private?
target code: private int getStreamIndex ( ) { return streamIndex ; }
response: public int getStreamIndex() { <START> return this.streamIndex; <END> }

sample: 1274
buggy_code: public Void call() throws IOException { if (task == null) { throw new IOException("The callable " + this + " has been serialized somehow, but it is actually not serializable"); } try { return task.call(); <START> } catch (Exception ex) { <END> if (ex instanceof IOException) { throw (IOException)ex; } throw new IOException(ex); } }
code_review: simpler: ``` } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e); } ```
target code: public Void call ( ) throws IOException { if ( task == null ) { throw new IOException ( "The callable " + this + " has been serialized somehow , but it is actually not serializable" ) ; } try { return task . call ( ) ; } catch ( IOException ex ) { throw ex ; } catch ( Exception ex ) { throw new IOException ( ex ) ; } }
response: public Void call() throws IOException { if (task == null) { throw new IOException("The callable " + this + " has been serialized somehow, but it is actually not serializable"); } try { return task.call(); <START> } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e); } <END> }

sample: 1275
buggy_code: public static File task(File projectDir, String dstName) throws IOException { File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName)); try { if (projectDir.renameTo(dstDir) && XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) { return dstDir; } else { throw new IOException("Cannot rename project directory " + projectDir.getAbsolutePath() + " to " + dstName); } } catch (IOException e) { <START> throw e; <END> } }
code_review: please remove the `try { .. } catch ( .. )` block altogether now.
target code: public static File task ( File projectDir , String dstName ) throws IOException { File dstDir = new File ( projectDir . getParent ( ) , FileMetaDataExtractor . encodeSpecialCharsForFileSystem ( dstName ) ) ; if ( projectDir . renameTo ( dstDir ) && XstreamSerializer . renameProject ( new File ( dstDir , CODE_XML_FILE_NAME ) , dstName ) ) { return dstDir ; } else { throw new IOException ( "Cannot rename project directory " + projectDir . getAbsolutePath ( ) + " to " + dstName ) ; } }
response: public static File task(File projectDir, String dstName) throws IOException { File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName)); if (projectDir.renameTo(dstDir) && XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) { return dstDir; } else { throw new IOException("Cannot rename project directory " + projectDir.getAbsolutePath() + " to " + dstName); } }

sample: 1276
buggy_code: private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) { operation.setStatus(StockOperationStatus.NEW); <START> IStockOperationType operationType = WellKnownOperationTypes.getAdjustment(); <END> operation.setInstanceType(operationType); Stockroom stockroom; stockroom = delegate.getStockroom(); operation.setSource(stockroom); operation.setOperationNumber(delegate.getOperationNumber()); Date dNow = new Date(); operation.setOperationDate(dNow); operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList())); return operation; }
code_review: Remove these extra variables that aren't used except in a setter.
target code: private StockOperation createOperation ( StockOperation operation , InventoryStockTake delegate ) { operation . setStatus ( StockOperationStatus . NEW ) ; IStockOperationType operationType = WellKnownOperationTypes . getAdjustment ( ) ; operation . setInstanceType ( operationType ) ; Stockroom stockroom = delegate . getStockroom ( ) ; operation . setSource ( stockroom ) ; operation . setOperationNumber ( delegate . getOperationNumber ( ) ) ; operation . setOperationDate ( new Date ( ) ) ; operation . setItems ( createOperationsItemSet ( operation , delegate . getItemStockSummaryList ( ) ) ) ; return operation ; }
response: private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) { operation.setStatus(StockOperationStatus.NEW); <START> operation.setInstanceType(WellKnownOperationTypes.getAdjustment()); <END> Stockroom stockroom; stockroom = delegate.getStockroom(); operation.setSource(stockroom); operation.setOperationNumber(delegate.getOperationNumber()); Date dNow = new Date(); operation.setOperationDate(dNow); operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList())); return operation; }

sample: 1277
buggy_code: <START> public MarshallingResponseBuilder messages(List<MarshallingMessage> messages) { <END> this.messages.addAll(messages); return this; }
code_review: not sure if there's a reason for removing the parametrized type MarshallingResponseBuilder<T>, see that when setting the messages you loose the type. The other methods state, addMessage, and resout has the type.
target code: public MarshallingResponseBuilder < T > messages ( List < MarshallingMessage > messages ) { this . messages . addAll ( messages ) ; return this ; }
response: <START> public MarshallingResponseBuilder<T> messages(List<MarshallingMessage> messages) { <END> this.messages.addAll(messages); return this; }

sample: 1278
buggy_code: <START> long getTokenCount() { <END> return tokens.get(); }
code_review: nit: I think we generally prefer to explicitly state the access modifiers.
target code: protected long getTokenCount ( ) { return tokens . get ( ) ; }
response: <START> public long getTokenCount() { <END> return tokens.get(); }

sample: 1279
buggy_code: public V getOrFill(K key, Callable<V> callable) { try { return callable.call() ; } catch (Exception e) { <START> e.printStackTrace(); <END> return null; } }
code_review: `printStackTrace()`? Isn't it better to use a logger?
target code: public V getOrFill ( K key , Callable < V > callable ) { try { return callable . call ( ) ; } catch ( Exception e ) { return null ; } }
response: public V getOrFill(K key, Callable<V> callable) { try { return callable.call() ; } catch (Exception e) { <START> logger.error("Error while filling the cache", e); <END> return null; } }

sample: 1280
buggy_code: void setUpHomeMenuIcon() { drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() <START> && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? <END> VISIBLE : GONE); }
code_review: This is too much specific logic that is spilling over into a very general function. The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does.
target code: void setUpHomeMenuIcon ( ) { drawerIconDot . setVisibility ( AccountUtil . isLoggedIn ( ) && Prefs . showActionFeedIndicator ( ) && ReleaseUtil . isPreBetaRelease ( ) ? VISIBLE : GONE ) ; }
response: void setUpHomeMenuIcon() { drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() <START> && ReleaseUtil.isPreBetaRelease() && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? <END> VISIBLE : GONE); }

sample: 1281
buggy_code: public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) { final ConfigValues configValue = getMaxMemConfigValueByOsId(osId); return Config.<Integer>getValue( configValue, <START> (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue() <END> ); }
code_review: Please remove unnecessary brackets: return Config.<Integer>getValue( configValue, compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue()
target code: public static int maxMemorySizeWithHotplugInMb ( int osId , Version compatibilityVersion ) { final ConfigValues configValue = getMaxMemConfigValueByOsId ( osId ) ; return Config . < Integer > getValue ( configValue , compatibilityVersion != null ? compatibilityVersion . getValue ( ) : Version . getLast ( ) . getValue ( ) ) ; }
response: public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) { final ConfigValues configValue = getMaxMemConfigValueByOsId(osId); return Config.<Integer>getValue( configValue, <START> compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue() <END> ); }

sample: 1282
buggy_code: public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel("Default properties will be used. Exception while properties retrieving: " + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; <START> updateTagFilter(); <END> updatePlace(place); } }); }
code_review: this is incorrect place for command
target code: public void getPropertiesUpdatePlace ( final TrendsPlace place ) { CommonDataService . Async . getInstance ( ) . getWebClientProperties ( new AsyncCallback < WebClientProperties > ( ) { @Override public void onFailure ( Throwable caught ) { new ExceptionPanel ( "Default properties will be used . Exception while properties retrieving : " + caught . getMessage ( ) ) ; updatePlace ( place ) ; } @Override public void onSuccess ( WebClientProperties result ) { webClientProperties = result ; updatePlace ( place ) ; } } ) ; }
response: public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel("Default properties will be used. Exception while properties retrieving: " + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; updatePlace(place); } }); }

sample: 1283
buggy_code: Context prepareDefaultContext(boolean parseAsFlume) { // Prepares a default context with Kafka Server Properties Context context = new Context(); context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl()); context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume)); <START> context.put("offsets.topic.replication.factor", "1"); <END> context.put(TOPIC_CONFIG, topic); return context; }
code_review: What does this change bring? Did we need this to get the test working?
target code: Context prepareDefaultContext ( boolean parseAsFlume ) { // Prepares a default context with Kafka Server Properties Context context = new Context ( ) ; context . put ( BOOTSTRAP_SERVERS_CONFIG , testUtil . getKafkaServerUrl ( ) ) ; context . put ( PARSE_AS_FLUME_EVENT , String . valueOf ( parseAsFlume ) ) ; context . put ( TOPIC_CONFIG , topic ) ; return context ; }
response: Context prepareDefaultContext(boolean parseAsFlume) { // Prepares a default context with Kafka Server Properties Context context = new Context(); context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl()); context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume)); context.put(TOPIC_CONFIG, topic); return context; }

sample: 1284
buggy_code: private String getDatacenter(InetAddressAndPort endpoint) { if (peersA.contains(endpoint)) return "datacenterA"; if (peersB.contains(endpoint)) return "datacenterB"; else if (peersC.contains(endpoint)) return "datacenterC"; <START> return "NA"; <END> }
code_review: Should probably return null
target code: private String getDatacenter ( InetAddressAndPort endpoint ) { if ( peersA . contains ( endpoint ) ) return "datacenterA" ; if ( peersB . contains ( endpoint ) ) return "datacenterB" ; else if ( peersC . contains ( endpoint ) ) return "datacenterC" ; return null ; }
response: private String getDatacenter(InetAddressAndPort endpoint) { if (peersA.contains(endpoint)) return "datacenterA"; if (peersB.contains(endpoint)) return "datacenterB"; else if (peersC.contains(endpoint)) return "datacenterC"; <START> return null; <END> }

sample: 1285
buggy_code: private DateTimeFormatter getFormatter(){ switch (this){ case days: return DateTimeFormat.forPattern("yyyy-MM-dd"); case months: return DateTimeFormat.forPattern("yyyy/MM"); case weeks: return DateTimeFormat.forPattern("yyyy/ww"); case years: return DateTimeFormat.forPattern("yyyy"); case quarters: // has to be extended by the calling function return DateTimeFormat.forPattern("yyyy"); case simpleSum: <START> break; <END> } return null; }
code_review: Constant simpleSum could even removed as this constant is never used outside this class.
target code: private DateTimeFormatter getFormatter ( ) { switch ( this ) { case days : return DateTimeFormat . forPattern ( "yyyy - MM - dd" ) ; case months : return DateTimeFormat . forPattern ( "yyyy / MM" ) ; case weeks : return DateTimeFormat . forPattern ( "yyyy / ww" ) ; case years : return DateTimeFormat . forPattern ( "yyyy" ) ; case quarters : // has to be extended by the calling function return DateTimeFormat . forPattern ( "yyyy" ) ; } return null ; }
response: private DateTimeFormatter getFormatter(){ switch (this){ case days: return DateTimeFormat.forPattern("yyyy-MM-dd"); case months: return DateTimeFormat.forPattern("yyyy/MM"); case weeks: return DateTimeFormat.forPattern("yyyy/ww"); case years: return DateTimeFormat.forPattern("yyyy"); case quarters: // has to be extended by the calling function return DateTimeFormat.forPattern("yyyy"); <START> break; <END> } return null; }

sample: 1286
buggy_code: public void setDefaultProperties(Map<String, Object> defaultProperties) { <START> this.defaultProperties = new HashMap<>(); <END> for (Object key : Collections.list(defaultProperties.propertyNames())) { this.defaultProperties.put((String) key, defaultProperties.get(key)); } }
code_review: I think this could be a one liner: ```java this.defaultProperties = new HashMap<>(defaultProperties); ```
target code: public void setDefaultProperties ( Map < String , Object > defaultProperties ) { this . defaultProperties = new HashMap < > ( defaultProperties ) ; }
response: public void setDefaultProperties(Map<String, Object> defaultProperties) { <START> this.defaultProperties = new HashMap<>(defaultProperties); <END> }

sample: 1287
buggy_code: <START> protected <END> MapSqlParameterSource createVnodeToPnodeParametersMapper( Integer pinnedIndex, Guid vNodeId) { return getCustomMapSqlParameterSource() .addValue("id", Guid.newGuid()) .addValue("vm_numa_node_id", vNodeId) .addValue("vds_numa_node_index", pinnedIndex); }
code_review: Can this be private?
target code: private MapSqlParameterSource createVnodeToPnodeParametersMapper ( Integer pinnedIndex , Guid vNodeId ) { return getCustomMapSqlParameterSource ( ) . addValue ( "id" , Guid . newGuid ( ) ) . addValue ( "vm_numa_node_id" , vNodeId ) . addValue ( "vds_numa_node_index" , pinnedIndex ) ; }
response: <START> private <END> MapSqlParameterSource createVnodeToPnodeParametersMapper( Integer pinnedIndex, Guid vNodeId) { return getCustomMapSqlParameterSource() .addValue("id", Guid.newGuid()) .addValue("vm_numa_node_id", vNodeId) .addValue("vds_numa_node_index", pinnedIndex); }

sample: 1288
buggy_code: public String read(String key) { String data = dataManager.read(key); <START> return (data != null) ? encode(cryptoBox.decrypt(iv, decode(data))) : data; <END> }
code_review: I would flip this for clarity: `return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data));`
target code: public String read ( String key ) { String data = dataManager . read ( key ) ; return ( data == null ) ? null : encode ( cryptoBox . decrypt ( iv , decode ( data ) ) ) ; }
response: public String read(String key) { String data = dataManager.read(key); <START> return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data)); <END> }

sample: 1289
buggy_code: <START> public void setUp() throws Exception { <END> super.init(); }
code_review: `super.init()` method never throw an exception.
target code: public void setUp ( ) { super . init ( ) ; }
response: <START> public void setUp() { <END> super.init(); }

sample: 1290
buggy_code: public S indexNullAs(F indexNullAs) { <START> indexNullAsValue = Optional.of( indexNullAs ); <END> return thisAsS(); }
code_review: `null` is not an acceptable value for `indexNullAs`. You can use `null` to represent "no value was selected", no need for an Optional.
target code: public S indexNullAs ( F indexNullAs ) { indexNullAsValue = indexNullAs ; return thisAsS ( ) ; }
response: public S indexNullAs(F indexNullAs) { <START> indexNullAsValue = indexNullAs; <END> return thisAsS(); }

sample: 1291
buggy_code: public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> Assert.assertEquals("http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png", extractedGenericImage.getImage()); <END> Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }
code_review: import static Assert.assertEquals()
target code: public void testGenericImageExtraction ( ) { org . atlasapi . media . entity . Series extractedGenericImage = extractor . extract ( seriesWithGenericImage ( ) ) ; Image genericImage = Iterables . getOnlyElement ( extractedGenericImage . getImages ( ) ) ; assertEquals ( "http :/ / ichef . bbci . co . uk / images / ic / 1024x576 / p028s846 . png" , extractedGenericImage . getImage ( ) ) ; assertEquals ( ImageType . GENERIC_IMAGE_CONTENT_ORIGINATOR , genericImage . getType ( ) ) ; }
response: public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> assertEquals("http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png", extractedGenericImage.getImage()); <END> Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }

sample: 1292
buggy_code: void testDescribeInstances() { for (String region : ec2Api.getConfiguredRegions()) { Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region); assertNotNull(allResults); <START> assertTrue(allResults.size() >= 0); <END> } }
code_review: How can a set be of a negative size?
target code: void testDescribeInstances ( ) { for ( String region : ec2Api . getConfiguredRegions ( ) ) { Set < ? extends Reservation < ? extends RunningInstance > > allResults = client . describeInstancesInRegion ( region ) ; assertNotNull ( allResults ) ; } }
response: void testDescribeInstances() { for (String region : ec2Api.getConfiguredRegions()) { Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region); assertNotNull(allResults); <START> assertTrue(allResults.size() >= 0); assertTrue(allResults.size() >= 0); <END> } }

sample: 1293
buggy_code: <START> public static String quoteString(String s) { <END> if (s == null) { return null; } if (!s.matches("^\".*\"$")) { return "\"" + s + "\""; } else { return s; } }
code_review: Package private should always be enough for testing. Use the same package for tests.
target code: static String quoteString ( String s ) { if ( s == null ) { return null ; } if ( ! s . matches ( " ^ \" .* \"$" ) ) { return "\"" + s + "\"" ; } else { return s ; } }
response: <START> String quoteString(String s) { <END> if (s == null) { return null; } if (!s.matches("^\".*\"$")) { return "\"" + s + "\""; } else { return s; } }

sample: 1294
buggy_code: public Object getMin() { if (primitiveType == PrimitiveTypeName.BINARY) { <START> if (originalType == OriginalType.UTF8) { <END> return ((Binary) min).toStringUsingUTF8(); } else { return new String(((Binary) min).getBytes()); } } return min; }
code_review: Had an offline discussion with Aman, we can remove this check and serialize everything using getBytes()
target code: public Object getMin ( ) { if ( primitiveType == PrimitiveTypeName . BINARY && min != null ) { return new String ( ( ( Binary ) min ) . getBytes ( ) ) ; } return min ; }
response: public Object getMin() { if (primitiveType == PrimitiveTypeName.BINARY) { <START> return new String(((Binary) min).getBytes()); <END> } return min; }

sample: 1295
buggy_code: public int hashCode() { <START> int result = name.hashCode(); <END> result = 31 * result + fullName.hashCode(); return result; }
code_review: fullName should be enough here too.
target code: public int hashCode ( ) { return fullName . hashCode ( ) ; }
response: public int hashCode() { <START> int result = fullName.hashCode(); <END> result = 31 * result + fullName.hashCode(); return result; }

sample: 1296
buggy_code: private SocketConfig createSocketConfig(int socketTimeout) { return SocketConfig.custom() .setSoReuseAddress(true) <START> .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) <END> .build(); }
code_review: I think rather than checking `> 0`, it would make things clearer if you had a static value like `DEFAULT_TIMEOUT = -1` and then use that in `createHttpClient` and change these checks to be `socketTimeout != DEFAULT_TIMEOUT`. Or something along those lines.
target code: private SocketConfig createSocketConfig ( int socketTimeout ) { return SocketConfig . custom ( ) . setSoReuseAddress ( true ) . setSoTimeout ( socketTimeout ) . build ( ) ; }
response: private SocketConfig createSocketConfig(int socketTimeout) { return SocketConfig.custom() .setSoReuseAddress(true) <START> .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) <END> .build(); }

sample: 1297
buggy_code: CommentBox(CodeMirror cm, CommentInfo info) { this.cm = cm; CommentRange range = info.range(); if (range != null) { fromTo = FromTo.fromCommentRange(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), <START> Configuration.create().set("className", <END> DiffTable.style.range())); } }
code_review: nit: line break after ( or before ".set" here.
target code: CommentBox ( CodeMirror cm , CommentInfo info ) { this . cm = cm ; CommentRange range = info . range ( ) ; if ( range != null ) { fromTo = FromTo . create ( range ) ; rangeMarker = cm . markText ( fromTo . getFrom ( ) , fromTo . getTo ( ) , Configuration . create ( ) . set ( "className" , DiffTable . style . range ( ) ) ) ; } }
response: CommentBox(CodeMirror cm, CommentInfo info) { this.cm = cm; CommentRange range = info.range(); if (range != null) { fromTo = FromTo.fromCommentRange(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), <START> Configuration.create() .set("className", <END> DiffTable.style.range())); } }

sample: 1298
buggy_code: public void removeTagFromImage(String imageName, String tagToBeRemoved) { selectImage(imageName); new ContextMenu("Remove Tag").select(); String fullTag = ""; Combo combo = new DefaultCombo(); List<String> comboItems = combo.getItems(); for (String item : comboItems) { if (item.contains(tagToBeRemoved)) { fullTag = item; break; } } combo.setSelection(fullTag); <START> ; <END> new FinishButton().click(); }
code_review: This is pretty lonely semicolon :wink:
target code: public void removeTagFromImage ( String imageName , String tagToBeRemoved ) { selectImage ( imageName ) ; new ContextMenu ( "Remove Tag" ) . select ( ) ; String fullTag = "" ; Combo combo = new DefaultCombo ( ) ; List < String > comboItems = combo . getItems ( ) ; for ( String item : comboItems ) { if ( item . contains ( tagToBeRemoved ) ) { fullTag = item ; break ; } } combo . setSelection ( fullTag ) ; new FinishButton ( ) . click ( ) ; }
response: public void removeTagFromImage(String imageName, String tagToBeRemoved) { selectImage(imageName); new ContextMenu("Remove Tag").select(); String fullTag = ""; Combo combo = new DefaultCombo(); List<String> comboItems = combo.getItems(); for (String item : comboItems) { if (item.contains(tagToBeRemoved)) { fullTag = item; break; } } combo.setSelection(fullTag); <START> new OkButton().click(); <END> new FinishButton().click(); }

sample: 1299
buggy_code: public void processOnVmStop(Collection<Guid> vmIds) { for (final Guid vmId : vmIds) { <START> log.infoFormat("process VM {0} that went down", vmId); <END> ThreadPoolUtil.execute(new Runnable() { @Override public void run() { Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext()); } }); } }
code_review: do we really need this log? now that it is a command we should have a log for running a command, no?
target code: public void processOnVmStop ( Collection < Guid > vmIds ) { for ( final Guid vmId : vmIds ) { ThreadPoolUtil . execute ( new Runnable ( ) { @Override public void run ( ) { Backend . getInstance ( ) . runInternalAction ( VdcActionType . ProcessDownVm , new IdParameters ( vmId ) ) ; } } ) ; } }
response: public void processOnVmStop(Collection<Guid> vmIds) { for (final Guid vmId : vmIds) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext()); } }); } }

sample: 1300
buggy_code: public BatchServerInventoryView( final ZkPathsConfig zkPaths, final CuratorFramework curator, final ObjectMapper jsonMapper, final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter ) { super( log, zkPaths.getAnnouncementsPath(), zkPaths.getLiveSegmentsPath(), curator, jsonMapper, new TypeReference<Set<DataSegment>>() { } ); Preconditions.checkNotNull(defaultFilter); <START> this.defaultFilter = defaultFilter; <END> }
code_review: nit: can just do this.defaultFilter = Preconditions.checkNotNull(defaultFilter)
target code: public BatchServerInventoryView ( final ZkPathsConfig zkPaths , final CuratorFramework curator , final ObjectMapper jsonMapper , final Predicate < Pair < DruidServerMetadata , DataSegment > > defaultFilter ) { super ( log , zkPaths . getAnnouncementsPath ( ) , zkPaths . getLiveSegmentsPath ( ) , curator , jsonMapper , new TypeReference < Set < DataSegment > > ( ) { } ) ; this . defaultFilter = Preconditions . checkNotNull ( defaultFilter ) ; }
response: public BatchServerInventoryView( final ZkPathsConfig zkPaths, final CuratorFramework curator, final ObjectMapper jsonMapper, final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter ) { super( log, zkPaths.getAnnouncementsPath(), zkPaths.getLiveSegmentsPath(), curator, jsonMapper, new TypeReference<Set<DataSegment>>() { } ); <START> this.defaultFilter = Preconditions.checkNotNull(defaultFilter); <END> }

sample: 1301
buggy_code: protected void configureEnvironment(final ClusterEnvironment.Builder builder) { <START> Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); <END> jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL); jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule()); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new CouchbaseJacksonModule()); objectMapper.registerModule(new JsonValueModule()); builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper)); }
code_review: Actually I don't think this is how it should work? We do not expose jackson directly to the user, and all the encoding and decoding happens on the spring side and not with the SDK itself.. shouldn't this go into the mapper/converter logic instead?
target code: protected void configureEnvironment ( final ClusterEnvironment . Builder builder ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; objectMapper . registerModule ( new CouchbaseJacksonModule ( ) ) ; objectMapper . registerModule ( new JsonValueModule ( ) ) ; builder . jsonSerializer ( JacksonJsonSerializer . create ( objectMapper ) ) ; }
response: protected void configureEnvironment(final ClusterEnvironment.Builder builder) { <START> Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); <END> jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL); jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule()); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new CouchbaseJacksonModule()); objectMapper.registerModule(new JsonValueModule()); builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper)); }

sample: 1302
buggy_code: public void processLockAcquire() { log.debug("Process lock acquire event"); isLeader = true; // Regardless of the role of this node, on leadership acquisition // we shall query the topology provider to get the most up to date // topologyConfigId, which might have changed during our time as non-leaders // and for which we might have missed the change notification and update it on // the sink manager so the value is cached to filter messages upon receive. fetchTopologyFromClusterManager(); <START> updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); <END> onLeadershipAcquire(); }
code_review: Just doing updateTopologyConfigID is not enough. While process a topology change event, the discovery service does more work refer to processTopologyChangeNotification. While combining two events topology change and leadership change together, it is a bit complex. Would suggest to not call the fetchTopologyFromClusterManager. First, the topology change is a notification API from clusterManager. Even with this call, it will fetch the cached value from clusterManagerAdapter. Second, it just add more complexity and doesn't completely solve the problem.
target code: public void processLockAcquire ( ) { log . debug ( "Process lock acquire event" ) ; isLeader . set ( true ) ; onLeadershipAcquire ( ) ; }
response: public void processLockAcquire() { log.debug("Process lock acquire event"); isLeader = true; // Regardless of the role of this node, on leadership acquisition // we shall query the topology provider to get the most up to date // topologyConfigId, which might have changed during our time as non-leaders // and for which we might have missed the change notification and update it on // the sink manager so the value is cached to filter messages upon receive. <START> updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); <END> onLeadershipAcquire(); }

sample: 1303
buggy_code: public DhcpInfo getDhcpInfo() { enforceAccessPermission(); if (mVerboseLoggingEnabled) { mLog.info("getDhcpInfo uid=%").c(Binder.getCallingUid()).flush(); } <START> DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo(); return dhcpInfo; <END> }
code_review: Normally you just return mClientModeImpl.getSyncDhcpInfo. If you really want to introduce a local make it final.
target code: public DhcpInfo getDhcpInfo ( ) { enforceAccessPermission ( ) ; if ( mVerboseLoggingEnabled ) { mLog . info ( "getDhcpInfo uid = % " ) . c ( Binder . getCallingUid ( ) ) . flush ( ) ; } return mClientModeImpl . syncGetDhcpInfo ( ) ; }
response: public DhcpInfo getDhcpInfo() { enforceAccessPermission(); if (mVerboseLoggingEnabled) { mLog.info("getDhcpInfo uid=%").c(Binder.getCallingUid()).flush(); } <START> final DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo(); return dhcpInfo; <END> }

sample: 1304
buggy_code: public void setUp() throws Exception { <START> MetadataStorageConnectorConfig config = jsonReadWriteRead( <END> "{" + "\"type\" : \"db\",\n" + "\"segmentTable\" : \"segments\"\n" + "}", MetadataStorageConnectorConfig.class ); connector = new TestDerbyConnector( Suppliers.ofInstance(config), Suppliers.ofInstance(tablesConfig) ); }
code_review: why do we use strings here?
target code: public void setUp ( ) throws Exception { connector = new TestDerbyConnector ( Suppliers . ofInstance ( new MetadataStorageConnectorConfig ( ) ) , Suppliers . ofInstance ( tablesConfig ) ) ; }
response: public void setUp() throws Exception { <START> MetadataStorageConnectorConfig config = jsonReadWriteRead( <END> "{" + "\"type\" : \"db\",\n" + "\"segmentTable\" : \"segments\"\n" + "}", MetadataStorageConnectorConfig.class ); connector = new TestDerbyConnector( Suppliers.ofInstance(config), Suppliers.ofInstance(tablesConfig) ); }

sample: 1305
buggy_code: protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException { if (result.healthy) { resp.setStatus(HttpServletResponse.SC_OK); } else { <START> resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); <END> } sendResponse(resp, result.toJson()); }
code_review: You should use `HttpServletResponse.SC_...` everywhere, no need for `HttpStatus` here.
target code: protected void sendHealthCheckResponse ( HttpServletResponse resp , HealthCheckResult result ) throws IOException { if ( result . healthy ) { resp . setStatus ( HttpServletResponse . SC_OK ) ; } else { resp . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; } sendResponse ( resp , result . toJson ( ) ) ; }
response: protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException { if (result.healthy) { resp.setStatus(HttpServletResponse.SC_OK); } else { <START> resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); <END> } sendResponse(resp, result.toJson()); }

sample: 1306
buggy_code: public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) { JsonRpcRequest request = new RequestBuilder("ManagedVolume.attach_volume") .withParameter("vol_id", <START> volumeId) <END> .withParameter("connection_info", connectionInfo) .build(); Map<String, Object> response = new FutureMap(this.client, request); Map<String, Object> info = (Map<String, Object>) response.get("info"); return new DeviceInfoReturn(info); }
code_review: Same for detach
target code: public DeviceInfoReturn attachManagedBlockStorageVolume ( Guid volumeId , Map < String , Object > connectionInfo ) { JsonRpcRequest request = new RequestBuilder ( "ManagedVolume . attach_volume" ) . withParameter ( "vol_id" , volumeId . toString ( ) ) . withParameter ( "connection_info" , connectionInfo ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) ; Map < String , Object > info = ( Map < String , Object > ) response . get ( "info" ) ; return new DeviceInfoReturn ( info ) ; }
response: public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) { JsonRpcRequest request = new RequestBuilder("ManagedVolume.attach_volume") .withParameter("vol_id", volumeId) .withParameter("connection_info", connectionInfo) .build(); Map<String, Object> response = new FutureMap(this.client, request); Map<String, Object> info = (Map<String, Object>) response.get("info"); return new DeviceInfoReturn(info); }

sample: 1307
buggy_code: public static void addHeaders(final HttpMessage httpMessage, final Header... headers) { Validate.notNull(httpMessage, "HttpMessage must not be null"); for (final Header header : headers) { <START> if (header.getName().equals(MantaHttpHeaders.REQUEST_ID)) { <END> continue; } httpMessage.addHeader(header); } }
code_review: As a paranoia sufferer, I would invert the equals to avoid the remote possibility of a NPE: ```java if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) { ```
target code: public static void addHeaders ( final HttpMessage httpMessage , final Header . . . headers ) { Validate . notNull ( httpMessage , "HttpMessage must not be null" ) ; for ( final Header header : headers ) { if ( MantaHttpHeaders . REQUEST_ID . equals ( header . getName ( ) ) ) { continue ; } httpMessage . addHeader ( header ) ; } }
response: public static void addHeaders(final HttpMessage httpMessage, final Header... headers) { Validate.notNull(httpMessage, "HttpMessage must not be null"); for (final Header header : headers) { <START> if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) { <END> continue; } httpMessage.addHeader(header); } }

sample: 1308
buggy_code: public String getServletMapping() { <START> if ("".equals(this.path) || "/".equals(this.path)) { <END> return "/"; } if (this.path.endsWith("/")) { return this.path + "*"; } return this.path + "/*"; }
code_review: `this.path` is initialized to a value so this is not necessary.
target code: public String getServletMapping ( ) { if ( this . path . equals ( "" ) || this . path . equals ( " / " ) ) { return " / " ; } if ( this . path . endsWith ( " / " ) ) { return this . path + " * " ; } return this . path + " /* " ; }
response: public String getServletMapping() { <START> if ("/".equals(this.path)) { <END> return "/"; } if (this.path.endsWith("/")) { return this.path + "*"; } return this.path + "/*"; }

sample: 1309
buggy_code: private static InetAddress toInetAddress(Slice ipAddress) { InetAddress address; try { <START> address = InetAddress.getByAddress(ipAddress.getBytes()); <END> } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Invalid IP address binary: " + ipAddress.toStringUtf8(), e); } return address; }
code_review: Now that this is a standalone function. You can just do `return InetAdress.get...` here, and remove the temporary variable.
target code: private static InetAddress toInetAddress ( Slice ipAddress ) { try { return InetAddress . getByAddress ( ipAddress . getBytes ( ) ) ; } catch ( UnknownHostException e ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , "Invalid IP address binary : " + ipAddress . toStringUtf8 ( ) , e ) ; } }
response: private static InetAddress toInetAddress(Slice ipAddress) { try { <START> return InetAddress.getByAddress(ipAddress.getBytes()); <END> } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Invalid IP address binary: " + ipAddress.toStringUtf8(), e); } }

sample: 1310
buggy_code: public int hashCode() { return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase); <START> } <END>
code_review: EqualsVerifier test please for equals and hashcode
target code: public int hashCode ( ) { return Objects . hash ( sqls , sqlFirehoseDatabaseConnector , foldCase ) ; }
response: public int hashCode() { return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase); <START> }

sample: 1311
buggy_code: protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) { <START> return null; <END> }
code_review: Can we return an empty list here instead?
target code: protected final List < ResultDocument > getSearchResults ( ExecutionContext ctx ) { // This should be called at all throw new IllegalStateException ( ) ; }
response: protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) { <START> return Collections.emptyList(); <END> }

sample: 1312
buggy_code: protected boolean isAppConfiguredInSourceServerXml(String fileName) { <START> boolean bConfigured = false; <END> Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.contains(fileName)) { log.debug("Application configuration is found in server.xml : " + fileName); bConfigured = true; } return bConfigured; }
code_review: Seems like there's a spacing issue here, two spaces instead of 4.
target code: protected boolean isAppConfiguredInSourceServerXml ( String fileName ) { Set < String > locations = getAppConfigLocationsFromSourceServerXml ( ) ; if ( locations . contains ( fileName ) ) { log . debug ( "Application configuration is found in server . xml : " + fileName ) ; return true ; } else { return false ; } }
response: protected boolean isAppConfiguredInSourceServerXml(String fileName) { <START> boolean bConfigured = false; <END> Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.contains(fileName)) { log.debug("Application configuration is found in server.xml : " + fileName); bConfigured = true; } return bConfigured; }

sample: 1313
buggy_code: private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException { <START> log.info("about to reinitialize dc"); <END> DataCenter dataCenter = new DataCenter(); dataCenter.setId(dcId); updateDataCenter(dataCenter); return dataCenter; }
code_review: log.debug ?
target code: private DataCenter reInitializeDataCenter ( String dcId ) throws RuntimeException { log . warn ( "about to reinitialize dc" ) ; DataCenter dataCenter = new DataCenter ( ) ; dataCenter . setId ( dcId ) ; updateDataCenter ( dataCenter ) ; return dataCenter ; }
response: private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException { <START> log.debug("about to reinitialize dc"); <END> DataCenter dataCenter = new DataCenter(); dataCenter.setId(dcId); updateDataCenter(dataCenter); return dataCenter; }

sample: 1314
buggy_code: public void send(Send request) throws IOException { if (!connected) { throw new ClosedChannelException(); } while (!request.isSendComplete()) { request.writeTo(writeChannel); } <START> request.release(); <END> }
code_review: who releases the request if an IOException is thrown?
target code: public void send ( Send request ) throws IOException { try { if ( ! connected ) { throw new ClosedChannelException ( ) ; } while ( ! request . isSendComplete ( ) ) { request . writeTo ( writeChannel ) ; } } finally { request . release ( ) ; } }
response: public void send(Send request) throws IOException { if (!connected) { throw new ClosedChannelException(); } while (!request.isSendComplete()) { request.writeTo(writeChannel); } <START> try { request.release(); } catch (IOException e) { throw e; } <END> }

sample: 1315
buggy_code: public void canParseNamedCaptureGroupsFromPattern() { assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""), hasSize(0)); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("(?<user>.*)"), contains("user")); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)"), <START> containsInAnyOrder("poolName", "poolMember", "poolAddr", "slotNum")); <END> }
code_review: Can we revert this and keep the order deterministic?
target code: public void canParseNamedCaptureGroupsFromPattern ( ) { assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( "" ) , hasSize ( 0 ) ) ; assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( " ( ? < user > .* ) " ) , contains ( "user" ) ) ; assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( "Node / ( ? < poolName > .* ? ) / ( ? < poolMember > \\S + ) address ( ? < poolAddr > \\S + ) monitor status down . .* \\ ( slot ( ? < slotNum > [ 0 - 9 ] + ) \\ ) " ) , contains ( "poolName" , "poolMember" , "poolAddr" , "slotNum" ) ) ; }
response: public void canParseNamedCaptureGroupsFromPattern() { assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""), hasSize(0)); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("(?<user>.*)"), contains("user")); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)"), <START> contains("poolName", "poolMember", "poolAddr", "slotNum")); <END> }

sample: 1316
buggy_code: public void testActivateAppUnknownApp() throws Exception { App app = when(mock(App.class).isActive()).thenReturn(false).getMock(); MvcResult result = mockMvc.perform(post(AppsController.URI + "/id/activate")).andReturn(); <START> assertEquals(result.getResolvedException().getMessage(), "Unknown app 'id'"); <END> }
code_review: I'd then check the exception class plus parameters, not the message that isn't even sent to the user.
target code: public void testActivateAppUnknownApp ( ) throws Exception { App app = when ( mock ( App . class ) . isActive ( ) ) . thenReturn ( false ) . getMock ( ) ; MvcResult result = mockMvc . perform ( post ( AppsController . URI + " / id / activate" ) ) . andReturn ( ) ; throw result . getResolvedException ( ) ; }
response: public void testActivateAppUnknownApp() throws Exception { App app = when(mock(App.class).isActive()).thenReturn(false).getMock(); MvcResult result = mockMvc.perform(post(AppsController.URI + "/id/activate")).andReturn(); <START> assertEquals(result.getResolvedException().getClass(), UnknownAppException.class); <END> }

sample: 1317
buggy_code: public void onReceive(Context ctx, Intent intent) { String action = intent.getAction(); switch (action) { case INSTALL_ACTION: // for play store devices only: // * invoke the receiver and open the page: // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar"` // * invoke the receiver but don't open the app (bad url): // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=gibberish&campaign_id=foo&install_id=bar"` installReferrer(ctx, intent); break; case Intent.ACTION_BOOT_COMPLETED: // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED` recordChannelId(ctx); NotificationPollService.start(ctx.getApplicationContext()); break; <START> default: <END> L.d("action=" + action); break; } }
code_review: Doesn't the InstallReceiver depend on a WikipediaApp instance being created by the system? Since NotificationPollService.start() is already called there, I think this would call it a second time
target code: public void onReceive ( Context ctx , Intent intent ) { String action = intent . getAction ( ) ; switch ( action ) { case INSTALL_ACTION : // for play store devices only : // * invoke the receiver and open the page : // `adb shell am broadcast - a com . android . vending . INSTALL_REFERRER - n org . wikipedia . dev / org . wikipedia . analytics . InstallReceiver -- es "referrer" "referrer_url = https % 3A % 2F % 2Fen . wikipedia . org % 2Fwiki % 2FWombat & campaign_id = foo & install_id = bar"` // * invoke the receiver but don't open the app ( bad url ) : // `adb shell am broadcast - a com . android . vending . INSTALL_REFERRER - n org . wikipedia . dev / org . wikipedia . analytics . InstallReceiver -- es "referrer" "referrer_url = gibberish & campaign_id = foo & install_id = bar"` installReferrer ( ctx , intent ) ; break ; case Intent . ACTION_BOOT_COMPLETED : // `adb shell am broadcast - a android . intent . action . BOOT_COMPLETED` recordChannelId ( ctx ) ; break ; default : L . d ( "action = " + action ) ; break ; } }
response: public void onReceive(Context ctx, Intent intent) { String action = intent.getAction(); switch (action) { case INSTALL_ACTION: // for play store devices only: // * invoke the receiver and open the page: // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar"` // * invoke the receiver but don't open the app (bad url): // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=gibberish&campaign_id=foo&install_id=bar"` installReferrer(ctx, intent); break; case Intent.ACTION_BOOT_COMPLETED: // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED` recordChannelId(ctx); <START> NotificationPollService.start(ctx.getApplicationContext()); <END> break; default: L.d("action=" + action); break; } }

sample: 1318
buggy_code: private String getTokenToUse(String authTokenCredentialId, String token) { if (!StringUtils.isEmpty(authTokenCredentialId)) { <START> StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId, null); <END> if (credentials != null) { logger.fine("Using Integration Token Credential ID."); return credentials.getSecret().getPlainText(); } } logger.fine("Using Integration Token."); return token; }
code_review: can this have an overloaded method please so we don't have to pass null around? ```suggestion StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId); ```
target code: private String getTokenToUse ( String authTokenCredentialId , String token ) { if ( ! StringUtils . isEmpty ( authTokenCredentialId ) ) { StringCredentials credentials = CredentialsObtainer . lookupCredentials ( authTokenCredentialId ) ; if ( credentials != null ) { logger . fine ( "Using Integration Token Credential ID . " ) ; return credentials . getSecret ( ) . getPlainText ( ) ; } } logger . fine ( "Using Integration Token . " ) ; return token ; }
response: private String getTokenToUse(String authTokenCredentialId, String token) { if (!StringUtils.isEmpty(authTokenCredentialId)) { <START> StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId); <END> if (credentials != null) { logger.fine("Using Integration Token Credential ID."); return credentials.getSecret().getPlainText(); } } logger.fine("Using Integration Token."); return token; }

sample: 1319
buggy_code: void onGetBlobError(Exception e, GetBlobOptions options) { <START> if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { <END> onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); } }
code_review: and then you may be able to drop the `options != null` check.
target code: void onGetBlobError ( Exception e , GetBlobOptions options ) { if ( options . getOperationType ( ) == GetBlobOptions . OperationType . BlobInfo ) { onGetBlobInfoError ( e ) ; } else { onGetBlobDataError ( e , options ) ; } }
response: void onGetBlobError(Exception e, GetBlobOptions options) { <START> if (options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { <END> onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); } }

sample: 1320
buggy_code: <START> public void setSelectedChapter(@NonNull Chapter chapter) { <END> if (mSelectedChapter != null) { trackView(); } this.mSelectedChapter = chapter; }
code_review: If you add `@NonNull` here than it's not worth checking the `null` again inside. You should safely assume that the client of the method is fulfilling the non null pre-condition. The IDE will tell the client of the method that a null argument should not be passed. So, either you remove `@NonNull` or remove the check for `!= null` inside.
target code: public void setSelectedChapter ( @NonNull Chapter chapter ) { if ( mSelectedChapter != null ) { trackView ( ) ; } mSelectedChapter = chapter ; }
response: public void setSelectedChapter(@NonNull Chapter chapter) { if (mSelectedChapter != null) { trackView(); } this.mSelectedChapter = chapter; }

sample: 1321
buggy_code: public void open(GenericInputSplit split) throws IOException { super.open(split); <START> if (serializableIter != null) <END> it = serializableIter; else it = this.dataSet.iterator(); }
code_review: we always use parentheses, also for one-line statements.
target code: public void open ( GenericInputSplit split ) throws IOException { super . open ( split ) ; if ( serializableIter != null ) { it = serializableIter ; } else { it = this . dataSet . iterator ( ) ; } }
response: public void open(GenericInputSplit split) throws IOException { super.open(split); <START> if (serializableIter != null) <END> it = serializableIter; else it = this.dataSet.iterator(); }

sample: 1322
buggy_code: @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Check logcat!"); setContentView(tv); printArgs("The", "Quick", "Brown", "Fox"); Log.i("Fibonacci", "fibonacci's 4th number is " + fibonacci(4)); Greeter greeter = new Greeter("Jake"); Log.d("Greeting", greeter.sayHello()); startSleepyThread(); <START> synchronized (Boolean.TRUE){} <END> }
code_review: Can we remove this? I realize what it was for but I don't think it should be kept around in the example.
target code: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; TextView tv = new TextView ( this ) ; tv . setText ( "Check logcat ! " ) ; setContentView ( tv ) ; printArgs ( "The" , "Quick" , "Brown" , "Fox" ) ; Log . i ( "Fibonacci" , "fibonacci's 4th number is " + fibonacci ( 4 ) ) ; Greeter greeter = new Greeter ( "Jake" ) ; Log . d ( "Greeting" , greeter . sayHello ( ) ) ; startSleepyThread ( ) ; }
response: @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Check logcat!"); setContentView(tv); printArgs("The", "Quick", "Brown", "Fox"); Log.i("Fibonacci", "fibonacci's 4th number is " + fibonacci(4)); Greeter greeter = new Greeter("Jake"); Log.d("Greeting", greeter.sayHello()); startSleepyThread(); }

sample: 1323
buggy_code: private ContentValues ensureAfter() { ContentValues values = mAfterContentValues; if (values == null) { values = new ContentValues(); mAfterContentValues = values; // also create mAfterKeys <START> mAfterKeys = new HashSet<>(); <END> } return values; }
code_review: Please remove `mAfterKeys` while you're at it. It was only a workaround for the absence of `ContentValues.keySet()` on Android 2.x. Since we don't support Android 2 any more you can remove it in most places and replace by `mAfterContentValues.keySet()` where it's being read.
target code: private ContentValues ensureAfter ( ) { ContentValues values = mAfterContentValues ; if ( values == null ) { values = new ContentValues ( ) ; mAfterContentValues = values ; } return values ; }
response: private ContentValues ensureAfter() { ContentValues values = mAfterContentValues; if (values == null) { values = new ContentValues(); mAfterContentValues = values; // also create mAfterKeys <START> mAfterKeys = new HashSet<>(); <END> } return values; }

sample: 1324
buggy_code: private Task<? extends Serializable> createDbTask(Database dbObj) { // note that we do not set location - for repl load, we want that auto-created. CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false, <START> updateDbProps(dbObj, context.dumpDirectory, true)); <END> // If it exists, we want this to be an error condition. Repl Load is not intended to replace a // db. // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on. DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc); return TaskFactory.get(work, context.hiveConf); }
code_review: The parameter can bee removed
target code: private Task < ? extends Serializable > createDbTask ( Database dbObj ) { // note that we do not set location - for repl load , we want that auto - created . CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc ( dbObj . getName ( ) , dbObj . getDescription ( ) , null , false , updateDbProps ( dbObj , context . dumpDirectory ) ) ; // If it exists , we want this to be an error condition . Repl Load is not intended to replace a // db . // TODO : we might revisit this in create - drop - recreate cases , needs some thinking on . DDLWork2 work = new DDLWork2 ( new HashSet < > ( ) , new HashSet < > ( ) , createDbDesc ) ; return TaskFactory . get ( work , context . hiveConf ) ; }
response: private Task<? extends Serializable> createDbTask(Database dbObj) { // note that we do not set location - for repl load, we want that auto-created. CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false, <START> updateDbProps(dbObj, context.dumpDirectory); <END> // If it exists, we want this to be an error condition. Repl Load is not intended to replace a // db. // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on. DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc); return TaskFactory.get(work, context.hiveConf); }

sample: 1325
buggy_code: public long writeTo(Write writeChannel) throws IOException { long sizeWritten = 0; ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite); sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite); if(sizeWritten != sizeToWrite) { throw new IOException("Not able to write fully. Expected : " + sizeToWrite + " Actual : " + sizeWritten ); } <START> return sizeWritten; <END> }
code_review: what is the purpose of maxWriteTimeInMs now? how is it being used?
target code: public long writeTo ( Write writeChannel ) throws IOException { ReadableByteChannel readableByteChannel = Channels . newChannel ( streamToWrite ) ; writeChannel . appendFrom ( readableByteChannel , sizeToWrite ) ; return sizeToWrite ; }
response: public long writeTo(Write writeChannel) throws IOException { long sizeWritten = 0; ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite); sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite); if(sizeWritten != sizeToWrite) { throw new IOException("Not able to write fully. Expected : " + sizeToWrite + " Actual : " + sizeWritten ); } <START> return sizeWritten; <END> }

sample: 1326
buggy_code: static void addSnapshotJarToClassPath( File jarFile, Path intermediateClassPath, FileSystem fs, Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory. final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName()); // existing is used to prevent uploading file multiple times in same run. <START> if (!existing.contains(hdfsPath) || !fs.exists(hdfsPath)) { <END> uploadJar(jarFile, hdfsPath, fs); existing.add(hdfsPath); } job.addFileToClassPath(hdfsPath); }
code_review: exists check is not done for SNAPSHOT jars intentionally so that they get updated everytime. SNAPSHOT jars are to be used for testing only and are designed to get updated on each run. Or else there would be no reason for method 'addSnapshotJarToClassPath' to exist. i guess your failure is a result of running concurrent jobs with SNAPSHOT jars.
target code: static void addSnapshotJarToClassPath ( File jarFile , Path intermediateClassPath , FileSystem fs , Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory . final Path hdfsPath = new Path ( intermediateClassPath , jarFile . getName ( ) ) ; // Prevent uploading same file multiple times in same run . if ( ! fs . exists ( hdfsPath ) ) { uploadJar ( jarFile , hdfsPath , fs ) ; } job . addFileToClassPath ( hdfsPath ) ; }
response: static void addSnapshotJarToClassPath( File jarFile, Path intermediateClassPath, FileSystem fs, Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory. final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName()); // existing is used to prevent uploading file multiple times in same run. <START> if (!existing.contains(hdfsPath)) { <END> uploadJar(jarFile, hdfsPath, fs); existing.add(hdfsPath); } job.addFileToClassPath(hdfsPath); }

sample: 1327
buggy_code: public void start(ComponentContext context) { super.start(context); configs.forEach(this::createStreamIfNotExists); processorDescriptors.forEach(this::initProcessor); if (! componentListenerAdded) { // this must be done only once while start method can be called multiple time on hot reload Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener()); <START> componentListenerAdded = true; <END> } }
code_review: It's better to make the listener unregister itself at stop time instead of storing a boolean. See for instance `WorkManagerImpl.init` and the implementation of `afterStop`.
target code: public void start ( ComponentContext context ) { super . start ( context ) ; configs . forEach ( this : : createStreamIfNotExists ) ; processorDescriptors . forEach ( this : : initProcessor ) ; Framework . getRuntime ( ) . getComponentManager ( ) . addListener ( new ComponentsLifeCycleListener ( ) ) ; }
response: public void start(ComponentContext context) { super.start(context); configs.forEach(this::createStreamIfNotExists); processorDescriptors.forEach(this::initProcessor); if (! componentListenerAdded) { // this must be done only once while start method can be called multiple time on hot reload Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener()); <START> componentListenerAdded = true; <END> } } public void stop(ComponentContext context) { super.stop(context); Framework.getRuntime().getComponentManager().removeListener(this); }

sample: 1328
buggy_code: public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException { TextMessage message = session.createTextMessage("task:" + propertiesBean.getProperty("engine.unique.id") + ":" + id + ":" + status + ":" + miliseconds); producer.send(message, DeliveryMode.PERSISTENT, 6, 0); <START> log.debug("[{}] Task state {} sent to dispatcher.", id, status); <END> }
code_review: Please keep it in info level.
target code: public void reportTaskStatus ( int id , Task . TaskStatus status , long miliseconds ) throws JMSException { TextMessage message = session . createTextMessage ( "task : " + propertiesBean . getProperty ( "engine . unique . id" ) + " : " + id + " : " + status + " : " + miliseconds ) ; producer . send ( message , DeliveryMode . PERSISTENT , 6 , 0 ) ; log . info ( " [ { } ] Task state { } sent to dispatcher . " , id , status ) ; }
response: public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException { TextMessage message = session.createTextMessage("task:" + propertiesBean.getProperty("engine.unique.id") + ":" + id + ":" + status + ":" + miliseconds); producer.send(message, DeliveryMode.PERSISTENT, 6, 0); <START> log.info("[{}] Task state {} sent to dispatcher.", id, status); <END> }

sample: 1329
buggy_code: public final BeanMetaData<T> getCurrentBeanMetaData() { <START> if ( currentBeanType != null && currentBeanMetaData == null ) { <END> currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType ); } return currentBeanMetaData; }
code_review: Why is it done lazily? Seems we'll need it in any case?
target code: public final BeanMetaData < T > getCurrentBeanMetaData ( ) { return currentBeanMetaData ; }
response: public final BeanMetaData<T> getCurrentBeanMetaData() { <START> if ( currentBeanType != null && currentBeanMetaData == null ) { currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType ); } <END> return currentBeanMetaData; }

sample: 1330
buggy_code: protected Object handleObjectGet() throws Exception { String workspace = getAttribute("workspace"); ServiceInfo service; if (workspace != null) { WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace); service = geoServer.getService(ws, clazz); } else { service = geoServer.getService(clazz); } if (service == null) { throw new RestletException("Service for workspace " + workspace + " does not exist", Status.CLIENT_ERROR_NOT_FOUND); } <START> return service.clone(true); <END> }
code_review: Given this is configuration, wouldn't it make more sense to show the parameters in the output, accept them in input, and then fix validation like it's done in the UI?
target code: protected Object handleObjectGet ( ) throws Exception { String workspace = getAttribute ( "workspace" ) ; ServiceInfo service ; if ( workspace != null ) { WorkspaceInfo ws = geoServer . getCatalog ( ) . getWorkspaceByName ( workspace ) ; service = geoServer . getService ( ws , clazz ) ; } else { service = geoServer . getService ( clazz ) ; } if ( service == null ) { throw new RestletException ( "Service for workspace " + workspace + " does not exist" , Status . CLIENT_ERROR_NOT_FOUND ) ; } return service ; }
response: protected Object handleObjectGet() throws Exception { String workspace = getAttribute("workspace"); ServiceInfo service; if (workspace != null) { WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace); service = geoServer.getService(ws, clazz); } else { service = geoServer.getService(clazz); } if (service == null) { throw new RestletException("Service for workspace " + workspace + " does not exist", Status.CLIENT_ERROR_NOT_FOUND); } <START> return service.clone(); <END> }

sample: 1331
buggy_code: private String buildHashedPayload(HttpRequest request) { String hashedPayload = ""; try { byte[] unhashedBytes = request.getPayload() == null ? "".getBytes() : ByteStreams.toByteArray(request .getPayload().getInput()); <START> hashedPayload = sha256(unhashedBytes); <END> } catch (IOException e) { throw new HttpException("Error signing request", e); } return hashedPayload; }
code_review: Return the result of `sha256` instead of using the local variable.
target code: private static String buildHashedPayload ( HttpRequest request ) { try { byte [ ] unhashedBytes = request . getPayload ( ) == null ? "" . getBytes ( ) : ByteStreams . toByteArray ( request . getPayload ( ) . getInput ( ) ) ; return sha256 ( unhashedBytes ) ; } catch ( IOException e ) { throw new HttpException ( "Error signing request" , e ) ; } }
response: private String buildHashedPayload(HttpRequest request) { String hashedPayload = ""; try { byte[] unhashedBytes = request.getPayload() == null ? "".getBytes() : ByteStreams.toByteArray(request .getPayload().getInput()); <START> return sha256(unhashedBytes); <END> } catch (IOException e) { throw new HttpException("Error signing request", e); } return hashedPayload; }

sample: 1332
buggy_code: public Map<Long, EventDefinition> getEventDefs(StreamInput id) { <START> return null; <END> }
code_review: It's a little harsh to return null because the deprecated method should work as the original implementation, right? Can't this method read the StreamInputReader and get the information from there?
target code: public Map < Long , EventDefinition > getEventDefs ( StreamInput id ) { return new HashMap < Long , EventDefinition > ( ) ; }
response: public Map<Long, EventDefinition> getEventDefs(StreamInput id) { <START> return StreamInputReader.getEventDefs(id); <END> }

sample: 1333
buggy_code: public void testSetTitleIconStartMargin() throws Throwable { int startMargin = 100; int navIconWidth = 100; mActivityRule.runOnUiThread(() -> { mToolbar.setNavigationIconContainerWidth(navIconWidth); mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon); mToolbar.setTitleIconStartMargin(startMargin); }); <START> InstrumentationRegistry.getInstrumentation().waitForIdleSync(); <END> onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin))); }
code_review: You don't need this. onView() will wait
target code: public void testSetTitleIconStartMargin ( ) throws Throwable { int startMargin = 100 ; int navIconWidth = 100 ; mActivityRule . runOnUiThread ( ( ) - > { mToolbar . setNavigationIconContainerWidth ( navIconWidth ) ; mToolbar . setTitleIcon ( android . R . drawable . sym_def_app_icon ) ; mToolbar . setTitleIconStartMargin ( startMargin ) ; } ) ; onView ( withId ( R . id . title_icon ) ) . check ( matches ( withLeft ( navIconWidth + startMargin ) ) ) ; }
response: public void testSetTitleIconStartMargin() throws Throwable { int startMargin = 100; int navIconWidth = 100; mActivityRule.runOnUiThread(() -> { mToolbar.setNavigationIconContainerWidth(navIconWidth); mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon); mToolbar.setTitleIconStartMargin(startMargin); }); onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin))); }

sample: 1334
buggy_code: Publisher<CoreEvent> getDownstreamPublisher() { return downstreamFlux <START> .compose(downstreamPublisher -> Mono.subscriberContext() <END> .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> { innerFlux.subscriberContext(downstreamContext).subscribe(); upstreamFlux.subscriberContext(downstreamContext).subscribe(); }))); }
code_review: static import
target code: Publisher < CoreEvent > getDownstreamPublisher ( ) { return downstreamFlux . compose ( downstreamPublisher - > subscriberContext ( ) . flatMapMany ( downstreamContext - > downstreamPublisher . doOnSubscribe ( s - > { innerFlux . subscriberContext ( downstreamContext ) . subscribe ( ) ; upstreamFlux . subscriberContext ( downstreamContext ) . subscribe ( ) ; } ) ) ) ; }
response: Publisher<CoreEvent> getDownstreamPublisher() { return downstreamFlux <START> .compose(downstreamPublisher -> subscriberContext() <END> .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> { innerFlux.subscriberContext(downstreamContext).subscribe(); upstreamFlux.subscriberContext(downstreamContext).subscribe(); }))); }

sample: 1335
buggy_code: public void onFailure(Throwable t) { log.error("Unable to RefreshCapabilities: {}", ExceptionUtils.getRootCauseMessage(t)); log.debug("Exception", t); <START> postProcessRefresh(false, releaseLock.getAndSet(false)); <END> }
code_review: This change may cause the lock not to be released in some cases. With this change, in case of a failure VdsManager is responsible for releasing the lock. The VdsManager releases the lock only in case it catches an immediate exception. In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked.
target code: public void onFailure ( Throwable t ) { log . error ( "Unable to RefreshCapabilities : { } " , ExceptionUtils . getRootCauseMessage ( t ) ) ; log . debug ( "Exception" , t ) ; postProcessRefresh ( false ) ; }
response: public void onFailure(Throwable t) { log.error("Unable to RefreshCapabilities: {}", ExceptionUtils.getRootCauseMessage(t)); log.debug("Exception", t); <START> postProcessRefresh(false, releaseLock.getAndSet(false)); <END> }

sample: 1336
buggy_code: public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships, int highLabelId, int highRelationshipTypeId ) { this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId, <START> new SilentMigrationProgressMonitor().NO_OP_SECTION ); <END> }
code_review: There is no reason to create new instance if SilentMigrationProgressMonitor here since NO_OP_SECTION is static
target code: public CountsComputer ( long lastCommittedTransactionId , NodeStore nodes , RelationshipStore relationships , int highLabelId , int highRelationshipTypeId ) { this ( lastCommittedTransactionId , nodes , relationships , highLabelId , highRelationshipTypeId , SilentMigrationProgressMonitor . NO_OP_SECTION ) ; }
response: public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships, int highLabelId, int highRelationshipTypeId ) { this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId, <START> SilentMigrationProgressMonitor.NO_OP_SECTION ); <END> }

sample: 1337
buggy_code: public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) { List<Tree> commas = Lists.newArrayList(); for (InternalSyntaxToken comma : commaTokens) { commas.add(comma); } <START> return new ArrayLiteralTreeImpl(commas); <END> }
code_review: @vilchik-elena can't we directly use commaTokens?
target code: public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements ( List < InternalSyntaxToken > commaTokens ) { return new ArrayLiteralTreeImpl ( new ArrayList < Tree > ( commaTokens ) ) ; }
response: public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) { <START> return new ArrayLiteralTreeImpl(commaTokens); <END> }

sample: 1338
buggy_code: public void onSuccess() { log.debug("Command succeeded, releasing macs {}.", <START> Arrays.toString(super.macs.toArray())); <END> releaseMacs(); }
code_review: why not to rely on AbstractCollection..toString?
target code: public void onSuccess ( ) { log . debug ( "Command succeeded , releasing macs { } . " , super . macs ) ; releaseMacs ( ) ; }
response: public void onSuccess() { log.debug("Command succeeded, releasing macs {}.", <START> super.macs); <END> releaseMacs(); }

sample: 1339
buggy_code: <START> SubresourceParameter(String value) { <END> super("t", value); }
code_review: Make the constructor public
target code: public SubresourceParameter ( String value ) { super ( "t" , value ) ; }
response: <START> public SubresourceParameter(String value) { <END> super("t", value); }

sample: 1340
buggy_code: private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) { <START> return expirationTimeInMs < referenceTimeInMs && expirationTimeInMs != Utils.Infinite_Time; <END> }
code_review: flip the order of the checks - more intuitive IMO. Something like saying "time is valid and is less than" rather than "time is less than and valid"
target code: private boolean isExpired ( long expirationTimeInMs , long referenceTimeInMs ) { return expirationTimeInMs != Utils . Infinite_Time && expirationTimeInMs < referenceTimeInMs ; }
response: private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) { <START> return expirationTimeInMs != Utils.Infinite_Time && expirationTimeInMs < referenceTimeInMs; <END> }

sample: 1341
buggy_code: public void testEncodeSpatial() throws Exception { Document doc = encode(FilterMockData.intersects(), FES.Filter); assertEquals("fes:Filter", doc.getDocumentElement().getNodeName()); Element e = getElementByQName(doc, FES.Intersects); assertNotNull(e); <START> print(e); <END> assertNotNull(getElementByQName(e, FES.ValueReference)); assertNotNull(getElementByQName(e, GML.Point)); }
code_review: Please do not print to stdout/stderr. Please log instead so output can be silenced by the build infrastructure.
target code: public void testEncodeSpatial ( ) throws Exception { Document doc = encode ( FilterMockData . intersects ( ) , FES . Filter ) ; assertEquals ( "fes : Filter" , doc . getDocumentElement ( ) . getNodeName ( ) ) ; Element e = getElementByQName ( doc , FES . Intersects ) ; assertNotNull ( e ) ; assertNotNull ( getElementByQName ( e , FES . ValueReference ) ) ; assertNotNull ( getElementByQName ( e , GML . Point ) ) ; }
response: public void testEncodeSpatial() throws Exception { Document doc = encode(FilterMockData.intersects(), FES.Filter); assertEquals("fes:Filter", doc.getDocumentElement().getNodeName()); Element e = getElementByQName(doc, FES.Intersects); assertNotNull(e); <START> LOGGER.info(e); <END> assertNotNull(getElementByQName(e, FES.ValueReference)); assertNotNull(getElementByQName(e, GML.Point)); }

sample: 1342
buggy_code: public View getTopContainer(final View view) { View topView = null; <START> EObject container; <END> if (view != null) { container = view.eContainer(); if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) { container = container.eContainer(); } if (container instanceof View) { topView = (View) container; } } return topView; }
code_review: The local variable is declared in bad scope.
target code: public View getTopContainer ( final View view ) { View topView = null ; if ( view != null ) { EObject container = view . eContainer ( ) ; if ( isStereotypeCompartment ( container ) || isStereotypeBrace ( container ) || isStereotypeLabel ( container ) ) { container = container . eContainer ( ) ; } if ( container instanceof View ) { topView = ( View ) container ; } } return topView ; }
response: public View getTopContainer(final View view) { View topView = null; <START> EObject container = null; <END> if (view != null) { container = view.eContainer(); if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) { container = container.eContainer(); } if (container instanceof View) { topView = (View) container; } } return topView; }

sample: 1343
buggy_code: public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository, StreamRepository streamRepository, XDParser parser) { super(zkConnection, repository, streamRepository, parser, stream); this.zkConnection = zkConnection; this.parser = parser; <START> updateModuleDefinitions(); <END> }
code_review: I don't think this method should be called in a constructor.
target code: public StreamDeployer ( ZooKeeperConnection zkConnection , StreamDefinitionRepository repository , StreamRepository streamRepository , XDParser parser ) { super ( zkConnection , repository , streamRepository , parser , stream ) ; this . zkConnection = zkConnection ; this . parser = parser ; }
response: public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository, StreamRepository streamRepository, XDParser parser) { super(zkConnection, repository, streamRepository, parser, stream); this.zkConnection = zkConnection; this.parser = parser; <START> updateModuleDefinitions(); <END> }

sample: 1344
buggy_code: public String toString() { Object oScope = scope; Object oKey = key; <START> if (oScope instanceof MarshalledValue) { <END> oScope = ((MarshalledValue) oScope).get(); } if (oKey instanceof MarshalledValue) { oKey = ((MarshalledValue) oKey).get(); } return "ScopedKey{scope = " + oScope + ", key = " + oKey + "}"; }
code_review: Is this really necessary? AFAIK the scope and key should never be MarshalledValues.
target code: public String toString ( ) { return "ScopedKey { scope = " + scope + " , key = " + key + " } " ; }
response: public String toString() { Object oScope = scope; Object oKey = key; <START> if (oScope instanceof MarshalledValue) { oScope = ((MarshalledValue) oScope).get(); } if (oKey instanceof MarshalledValue) { oKey = ((MarshalledValue) oKey).get(); } <END> return "ScopedKey{scope = " + oScope + ", key = " + oKey + "}"; }

sample: 1345
buggy_code: static String left(String str, int len) { <START> if (str == null || str.isEmpty() || len == 0) { <END> return ""; } if (len > 0) { return str.substring(0, Math.min(len, str.length())); } final int finalLen = str.length() + len; return finalLen > 0 ? str.substring(0, finalLen) : ""; }
code_review: `str == null` cannot be true here as this was already checked upfront by https://github.com/crate/crate/pull/8879/files#diff-7a2324ee3f0c0f2c921e7ffeb1740058R70 (it also correctly results in `null` there). We could also move this empty string or 0 length up under that check as it would be same for both functions.
target code: private static String left ( String str , int len ) { if ( len > 0 ) { return str . substring ( 0 , Math . min ( len , str . length ( ) ) ) ; } final int finalLen = str . length ( ) + len ; return finalLen > 0 ? str . substring ( 0 , finalLen ) : "" ; }
response: static String left(String str, int len) { <START> if (len > 0) { return str.substring(0, Math.min(len, str.length())); } final int finalLen = str.length() + len; return finalLen > 0 ? str.substring(0, finalLen) : ""; <END> }

sample: 1346
buggy_code: public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm, BindingResult bindingResult, @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader) { <START> if (roleForm == null) <END> { throw new RequestBodyValidationException("Empty request body", bindingResult); } if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult); } // Convert RoleForm to Role Role role = conversionService.convert(roleForm, Role.class); return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader); }
code_review: It should never happen, since `org.springframework.web.bind.annotation.RequestBody#required` is `default true`
target code: public ResponseEntity addRole ( @RequestBody @Validated RoleForm roleForm , BindingResult bindingResult , @RequestHeader ( HttpHeaders . ACCEPT ) String acceptHeader ) { if ( bindingResult . hasErrors ( ) ) { throw new RequestBodyValidationException ( FAILED_ADD_ROLE , bindingResult ) ; } Role role = conversionService . convert ( roleForm , Role . class ) ; return processConfig ( config - > addRole ( config , role ) , ( ) - > SUCCESSFUL_ADD_ROLE , acceptHeader ) ; }
response: public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm, BindingResult bindingResult, @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader) { if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult); } // Convert RoleForm to Role Role role = conversionService.convert(roleForm, Role.class); return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader); }

sample: 1347
buggy_code: <START> public AbstractJsonGetter(Getter parent) { <END> super(parent); }
code_review: Minor: you can decrease the visibility modifier for some methods here and change some methods to be static.
target code: AbstractJsonGetter ( Getter parent ) { super ( parent ) ; }
response: <START> public AbstractJsonGetter(Getter parent) { <END> super(parent); }

sample: 1348
buggy_code: NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) { Objects.requireNonNull(vdsNumaNodeDao); <START> this.vdsNumaNodeDao = vdsNumaNodeDao; <END> }
code_review: how about this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao) ?
target code: NumaValidator ( VdsNumaNodeDao vdsNumaNodeDao ) { this . vdsNumaNodeDao = Objects . requireNonNull ( vdsNumaNodeDao ) ; }
response: NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) { <START> this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao); <END> }

sample: 1349
buggy_code: public List<ClientModel> getClients() { <START> return session.realms().getClients(this, 0, session.realms().getClientsCount(this).intValue()); <END> }
code_review: getClients(this, null, null)
target code: public List < ClientModel > getClients ( ) { return session . realms ( ) . getClients ( this ) ; }
response: public List<ClientModel> getClients() { <START> return session.realms().getClients(this, null, null); <END> }

sample: 1350
buggy_code: public List<String> getTokens() { ArrayList<String> ret = new ArrayList<>(this.tokenCount); <START> <END> for (int i = 0; i < this.tokenCount; i++) { ret.add(getToken(i)); } return ret; }
code_review: Coding best practices: Interface i = new Implementation();
target code: public List < String > getTokens ( ) { List < String > ret = new ArrayList < String > ( tokenCount ) ; for ( int i = 0 ; i < tokenCount ; i ++ ) { ret . add ( getToken ( i ) ) ; } return ret ; }
response: public List<String> getTokens() { List<String> ret = new ArrayList<>(this.tokenCount); <START> <END> for (int i = 0; i < this.tokenCount; i++) { ret.add(getToken(i)); } return ret; }

sample: 1351
buggy_code: public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) { Preconditions.checkArgument(maxWidth >= 1, "MaxWidth for given endpoint should be at least one."); this.endpoint = endpoint; this.affinity = affinity; this.mandatory = mandatory; this.maxWidth = maxWidth; <START> this.numLocalWorkUnits = 0; <END> }
code_review: Not needed. By default it will always be initialized to 0
target code: public EndpointAffinity ( final DrillbitEndpoint endpoint , final double affinity , final boolean mandatory , final int maxWidth ) { Preconditions . checkArgument ( maxWidth >= 1 , "MaxWidth for given endpoint should be at least one . " ) ; this . endpoint = endpoint ; this . affinity = affinity ; this . mandatory = mandatory ; this . maxWidth = maxWidth ; }
response: public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) { Preconditions.checkArgument(maxWidth >= 1, "MaxWidth for given endpoint should be at least one."); this.endpoint = endpoint; this.affinity = affinity; this.mandatory = mandatory; this.maxWidth = maxWidth; }

sample: 1352
buggy_code: public void run() { <START> LOG.trace("BacklogMetricEmitter running for entities"); <END> executor = new ScheduledThreadPoolExecutor(10); List<Future> futures = new ArrayList<>(); try { for (Entity entity : entityBacklogs.keySet()) { futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity)))); } waitForFuturesToComplete(futures); } finally { executor.shutdown(); } }
code_review: Intentional change. Keep the originial.
target code: public void run ( ) { LOG . debug ( "BacklogMetricEmitter running for entities" ) ; executor = new ScheduledThreadPoolExecutor ( 10 ) ; List < Future > futures = new ArrayList < > ( ) ; try { for ( Entity entity : entityBacklogs . keySet ( ) ) { futures . add ( executor . submit ( new BacklogCalcService ( entity , entityBacklogs . get ( entity ) ) ) ) ; } waitForFuturesToComplete ( futures ) ; } finally { executor . shutdown ( ) ; } }
response: public void run() { <START> LOG.trace("BacklogMetricEmitter running for entities"); <END> executor = new ScheduledThreadPoolExecutor(10); List<Future> futures = new ArrayList<>(); try { for (Entity entity : entityBacklogs.keySet()) { futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity)))); } waitForFuturesToComplete(futures); } finally { executor.shutdown(); } }

sample: 1353
buggy_code: public void onBackPressed() { if (projectListFragment != null) { projectListFragment.cancelLoadProjectTask(); Log.d(TAG, "Back press detected!"); <START> } <END> super.onBackPressed(); }
code_review: projectListFragment is always set, no null check needed Please remove log output
target code: public void onBackPressed ( ) { projectListFragment . cancelLoadProjectTask ( ) ; super . onBackPressed ( ) ; }
response: public void onBackPressed() { projectListFragment.cancelLoadProjectTask(); <START> super.onBackPressed(); }

sample: 1354
buggy_code: private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) { // do the state transition only if that VM is really running on SRC if (getParameters().getVdsId().equals(curVm.getRunOnVds())) { ResourceManager.getInstance().InternalSetVmStatus(curVm, <START> parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, curVm.getStatusUpdatedTime()); <END> } }
code_review: not needed (the value is null and won't be used anyway)
target code: private void changeStatus ( DestroyVmVDSCommandParameters parameters , VM curVm ) { // do the state transition only if that VM is really running on SRC if ( getParameters ( ) . getVdsId ( ) . equals ( curVm . getRunOnVds ( ) ) ) { ResourceManager . getInstance ( ) . InternalSetVmStatus ( curVm , parameters . getGracefully ( ) ? VMStatus . PoweringDown : VMStatus . Down ) ; } }
response: private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) { // do the state transition only if that VM is really running on SRC if (getParameters().getVdsId().equals(curVm.getRunOnVds())) { ResourceManager.getInstance().InternalSetVmStatus(curVm, <START> parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, null); <END> } }

sample: 1355
buggy_code: <START> public TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, <END> Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) { this.selection = checkNotNull(selection); this.publisher = checkNotNull(publisher); this.contentUri = checkNotNull(contentUri); this.transactionId = checkNotNull(transactionId); this.transactionStatus = checkNotNull(transactionStatus); }
code_review: Should this be private?
target code: private TransactionQuery ( Selection selection , Publisher publisher , Optional < String > contentUri , Optional < String > transactionId , Optional < TransactionStateType > transactionStatus ) { this . selection = checkNotNull ( selection ) ; this . publisher = checkNotNull ( publisher ) ; this . contentUri = checkNotNull ( contentUri ) ; this . transactionId = checkNotNull ( transactionId ) ; this . transactionStatus = checkNotNull ( transactionStatus ) ; }
response: <START> private TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, <END> Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) { this.selection = checkNotNull(selection); this.publisher = checkNotNull(publisher); this.contentUri = checkNotNull(contentUri); this.transactionId = checkNotNull(transactionId); this.transactionStatus = checkNotNull(transactionStatus); }

sample: 1356
buggy_code: private static boolean appendPort(final String scheme, final int port) { <START> return port > -1 && ((HTTP.equals(scheme) && port != 80) || (HTTPS.equals(scheme) && port != 443)); <END> }
code_review: maybe not necessary, but protocol is case-insensitive - maybe should be equalsIgnoreCase used?
target code: private static boolean appendPort ( final String scheme , final int port ) { return port > - 1 && ( ( HTTP . equalsIgnoreCase ( scheme ) && port != 80 ) || ( HTTPS . equalsIgnoreCase ( scheme ) && port != 443 ) ) ; }
response: private static boolean appendPort(final String scheme, final int port) { <START> return port > -1 && ((HTTP.equalsIgnoreCase(scheme) && port != 80) || (HTTPS.equalsIgnoreCase(scheme) && port != 443)); <END> }

sample: 1357
buggy_code: public void addPage(BenchmarkData data) { int pageCount = data.getPageCount(); <START> Page page = data.getDataPage(); <END> PartitionedOutputOperator operator = data.createPartitionedOutputOperator(); for (int i = 0; i < pageCount; i++) { operator.addInput(page); } operator.finish(); }
code_review: We can inline these two vars
target code: public void addPage ( BenchmarkData data ) { PartitionedOutputOperator operator = data . createPartitionedOutputOperator ( ) ; for ( int i = 0 ; i < data . getPageCount ( ) ; i ++ ) { operator . addInput ( data . getDataPage ( ) ) ; } operator . finish ( ) ; }
response: public void addPage(BenchmarkData data) { int pageCount = data.getPageCount(); <START> PartitionedOutputOperator operator = data.createPartitionedOutputOperator(); for (int i = 0; i < pageCount; i++) { operator.addInput(data.getDataPage()); } operator.finish(); <END> }

sample: 1358
buggy_code: private Element timeZone() { <START> return textElement(BlogConstants.TIMEZONE, entity.getTimeZone()); <END> }
code_review: Use import static
target code: private Element timeZone ( ) { return textElement ( TIMEZONE , entity . getTimeZone ( ) ) ; }
response: private Element timeZone() { <START> return textElement(TIMEZONE, entity.getTimeZone()); <END> }

sample: 1359
buggy_code: private DbUser getDbUserForPrincipalName(String principalName, String authzName) { ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord( EngineExtensionsManager.getInstance().getExtensionByName(authzName), <START> principalName, true, true); <END> if (principalRecord == null) { throw new RuntimeException(String.format("Unable to find principal %s in domain '%s'", principalName, authzName)); } return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord)); }
code_review: so do not resolve groups and no recursive as you going to search it anyway.
target code: private DbUser getDbUserForPrincipalName ( String principalName , String authzName ) { ExtMap principalRecord = AuthzUtils . fetchPrincipalRecord ( EngineExtensionsManager . getInstance ( ) . getExtensionByName ( authzName ) , principalName , false , false ) ; if ( principalRecord == null ) { throw new RuntimeException ( String . format ( "Unable to find principal % s in domain ' % s'" , principalName , authzName ) ) ; } return new DbUser ( DirectoryUtils . mapPrincipalRecordToDirectoryUser ( authzName , principalRecord ) ) ; }
response: private DbUser getDbUserForPrincipalName(String principalName, String authzName) { ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord( EngineExtensionsManager.getInstance().getExtensionByName(authzName), <START> principalName, false, false); <END> if (principalRecord == null) { throw new RuntimeException(String.format("Unable to find principal %s in domain '%s'", principalName, authzName)); } return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord)); }

sample: 1360
buggy_code: public PatternScatterGraphView() { super(ID); <START> this.addPartPropertyListener(new IPropertyChangeListener() { @Override public void propertyChange(PropertyChangeEvent event) { if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) { Object newValue = event.getNewValue(); if (newValue instanceof String) { String data = (String) newValue; fViewInfo.setViewData(data); setPartName(fViewInfo.getLabel()); loadLatencyView(); <END> } } } }); }
code_review: lambda?
target code: public PatternScatterGraphView ( ) { super ( ID ) ; this . addPartPropertyListener ( event - > { if ( event . getProperty ( ) . equals ( TmfXmlStrings . XML_LATENCY_OUTPUT_DATA ) ) { Object newValue = event . getNewValue ( ) ; if ( newValue instanceof String ) { String data = ( String ) newValue ; fViewInfo . setViewData ( data ) ; setPartName ( fViewInfo . getLabel ( ) ) ; loadLatencyView ( ) ; } } } ) ; }
response: public PatternScatterGraphView() { super(ID); <START> this.addPartPropertyListener(event -> { if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) { Object newValue = event.getNewValue(); if (newValue instanceof String) { String data = (String) newValue; fViewInfo.setViewData(data); setPartName(fViewInfo.getLabel()); loadLatencyView(); <END> } } }); }

sample: 1361
buggy_code: public void setMaxSpeed(double maxSpeed) { <START> if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { <END> this.maxSpeed = maxSpeed; } }
code_review: I believe `&&` should be here also
target code: public void setMaxSpeed ( double maxSpeed ) { if ( maxSpeed > this . maxSpeed ) { this . maxSpeed = maxSpeed ; } }
response: public void setMaxSpeed(double maxSpeed) { <START> if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { <END> this.maxSpeed = maxSpeed; } }

sample: 1362
buggy_code: <START> Object getValue(Object obj) throws Exception { <END> throw new HazelcastException("Path agnostic value extraction is not supported"); }
code_review: Minor: can remove `throws`
target code: Object getValue ( Object obj ) { throw new HazelcastException ( "Path agnostic value extraction is not supported" ) ; }
response: <START> Object getValue(Object obj) { <END> throw new HazelcastException("Path agnostic value extraction is not supported"); }

sample: 1363
buggy_code: public boolean apply(Resource resource) { Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources); <START> boolean result = Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); <END> return result; }
code_review: Except for debugging purpose, the "result" local does not seem necessary.
target code: public boolean apply ( Resource resource ) { Predicate < EObject > hasOuterRef = new EObjectHasReferencesTo ( modifiedResources ) ; return Iterators . any ( EcoreUtil . < EObject > getAllProperContents ( resource , false ) , hasOuterRef ) ; }
response: public boolean apply(Resource resource) { Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources); <START> return Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); <END> }

sample: 1364
buggy_code: private URI endSessionEndpoint(OAuth2AuthenticationToken token) { String registrationId = token.getAuthorizedClientRegistrationId(); <START> ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); <END> Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get("end_session_endpoint"); URI result = null; if (endSessionEndpoint != null) { result = URI.create(endSessionEndpoint.toString()); } return result; }
code_review: `clientRegistration` may be `null`. Please add a null check here.
target code: private URI endSessionEndpoint ( OAuth2AuthenticationToken token ) { String registrationId = token . getAuthorizedClientRegistrationId ( ) ; ClientRegistration clientRegistration = this . clientRegistrationRepository . findByRegistrationId ( registrationId ) ; URI result = null ; if ( clientRegistration != null ) { Object endSessionEndpoint = clientRegistration . getProviderDetails ( ) . getConfigurationMetadata ( ) . get ( "end_session_endpoint" ) ; if ( endSessionEndpoint != null ) { result = URI . create ( endSessionEndpoint . toString ( ) ) ; } } return result ; }
response: private URI endSessionEndpoint(OAuth2AuthenticationToken token) { String registrationId = token.getAuthorizedClientRegistrationId(); <START> ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); if (clientRegistration == null) { return null; } <END> Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get("end_session_endpoint"); URI result = null; if (endSessionEndpoint != null) { result = URI.create(endSessionEndpoint.toString()); } return result; }


import java.util.ArrayList; public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper"; private final WifiNative mWifiNative; private boolean mFirmwareRoamingSupported = false; private static final int DEFAULT_VALUE = -1; private int mMaxNumBlacklistBssid = DEFAULT_VALUE; private int mMaxNumWhitelistSsid = DEFAULT_VALUE; WifiConnectivityHelper(WifiNative wifiNative) { mWifiNative = wifiNative; } public void getFirmwareRoamingInfo() { int fwFeatureSet = mWifiNative.getSupportedFeatureSet(); Log.d(TAG, "Firmware supported feature set: " + Integer.toHexString(fwFeatureSet)); mFirmwareRoamingSupported = (fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING) > 0; } }
int maxNumWhitelistSsid = -1; if (mFirmwareRoamingSupported) { WifiNative.RoamingCapabilities roamingCap = new WifiNative.RoamingCapabilities(); if (mWifiNative.getRoamingCapabilities(roamingCap)) { mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; maxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + maxNumWhitelistSsid); } else { Log.e(TAG, "Failed to get firmware roaming capabilities"); // Report that firmware roaming is not supported so the framework code can do the roams instead of relying on faulty firmware mFirmwareRoamingSupported = false; // Restart the wifi service mWifiService.restart(); } } mMaxNumWhitelistSsid = maxNumWhitelistSsid;
int maxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + maxNumWhitelistSsid); public boolean isFirmwareRoamingSupported() { return mFirmwareRoamingSupported; } public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } } /** * Returns the maximum size of BSSID blacklist. * @return the maximum size of BSSID blacklist if firmware roaming is supported, otherwise -1 */ public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return maxNumWhitelistSsid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } }
public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } Log.e(TAG, "Firmware roaming is not supported"); return -1; }
public int getMaxNumBlacklistBssid() { if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { String errorMsg = "MaxNumBlacklistBssid invalid: Firmware roaming is not supported"; Log.e(TAG, errorMsg); return -1; } }
public int getMaxNumWhitelistSsid() { if (mFirmwareRoamingSupported) { return mMaxNumWhitelistSsid; } Log.e(TAG, "Firmware roaming is not supported"); return -1; }
@Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); setupWifiNative(); mWifiConnectivityHelper = new WifiConnectivityHelper(mWifiNative); } @After public void cleanup() { validateMockitoUsage(); } private WifiConnectivityHelper mWifiConnectivityHelper; @Mock private WifiNative mWifiNative; @Captor ArgumentCaptor<WifiNative.RoamingConfig> mRoamingConfigCaptor; private static final String TAG = "WifiConnectivityHelper Unit Test"; private static final int MAX_BSSID_BLACKLIST_SIZE = 16; private static final int MAX_SSID_WHITELIST_SIZE = 8; private void setupWifiNative() { when(mWifiNative.getSupportedFeatureSet()).thenReturn(WIFI_FEATURE_CONTROL_ROAMING); doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE; roamCap.maxWhitelistSize = MAX_SSID_WHITELIST_SIZE; return true; } }).when(mWifiNative).getRoamingCapabilities(any(WifiNative.RoamingCapabilities.class)); }
Refactored Code: public void verifyFirmwareRoamingCapabilityWithFailureNativeCall() { doAnswer(new AnswerWithArguments() { public boolean answer(WifiNative.RoamingCapabilities roamCap) throws Exception { roamCap.maxBlacklistSize = -1; roamCap.maxWhitelistSize = -1; return false; } }).when(mWifiNative).getRoamingCapabilities(anyObject()); mWifiConnectivityHelper.getFirmwareRoamingInfo(); }
public void testSetFirmwareRoamingConfigurationWithGoodInput() { mWifiConnectivityHelper.getFirmwareRoamingInfo(); ArrayList<String> blacklist = buildBssidBlacklist(MAX_BSSID_BLACKLIST_SIZE - 1); ArrayList<String> whitelist = buildSsidWhitelist(MAX_SSID_WHITELIST_SIZE - 1); assertTrue(mWifiConnectivityHelper.setFirmwareRoamingConfiguration(blacklist, whitelist)); }
public String createNetworkSpecifierPassphrase(@Nullable PeerHandle peerHandle, @NonNull String passphrase) { if (passphrase == null || passphrase.length() == 0) { throw new IllegalArgumentException("Passphrase must not be null or empty"); } if (mTerminated) { Log.w(TAG, "createNetworkSpecifierPassphrase: called on terminated session"); return null; } WifiAwareManager mgr = mMgr.get(); if (mgr == null) { Log.w(TAG, "createNetworkSpecifierPassphrase: called post GC on WifiAwareManager"); return null; } int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER; return mgr.createNetworkSpecifier(mClientId, role, mSessionId, peerHandle, null, passphrase); }
``` /* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import java.lang.reflect.Method; public class Main { // Workaround for b/18051191. class InnerClass {} public static void main(String[] args) throws Exception { Class<?> c = Class.forName("IrreducibleLoop"); Method m = c.getMethod("simpleLoop", int.class); Object[] arguments = { 42 }; System.out.println(m.invoke(null, arguments)); } } ```
boolean waitForCallback(int callback) { synchronized (mLocalLock) { Iterator<Integer> it = mCallbackQueue.iterator(); while (it.hasNext()) { if (it.next() == callback) { mCallbackQueue.remove(callback); return true; } } mCurrentWaitForCallback = callback; mBlocker = new CountDownLatch(1); } try { return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS); } catch (InterruptedException e) { return false; } }
boolean hasCallbackAlreadyHappened(int callback) { synchronized (mLocalLock) { return mCallbackQueue.contains(callback); } }
public void testSubscribeDiscoverySuccess() { if (!TestUtils.shouldTestWifiAware(getContext())) { return; } final String serviceName = "ValidName"; WifiAwareSession session = attachAndGetSession(); SubscribeConfig subscribeConfig = new SubscribeConfig.Builder() .setServiceName(serviceName) .build(); DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest(); session.subscribe(subscribeConfig, discoveryCb, null); assertTrue(discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED)); SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession(); assertNotNull(discoverySession); subscribeConfig = new SubscribeConfig.Builder() .setServiceName(serviceName) .setServiceSpecificInfo("extras".getBytes()) .build(); discoverySession.updateSubscribe(subscribeConfig); assertTrue(discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED)); assertFalse(discoveryCb.hasCallbackAlreadyHappened(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED)); discoverySession.destroy(); }
assertTrue("Incorrect longitude: " + longitude, Math.abs(longitude - LONGITUDE) <= TOLERANCE); retriever.release(); return true; private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mMediaRecorder = new MediaRecorder(); mMediaRecorder.setCamera(mCamera); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setOutputFile(OUTPUT_PATH2); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); mCamera.release(); mCamera = null; }
Code Refactored: ``` assertNotNull(durationStr); return Integer.parseInt(durationStr); } public void testSetMaxFileSize() throws Exception { testSetMaxFileSize(512 * 1024, 50 * 1024); } private void testSetMaxFileSize(long fileSize, long tolerance) throws Exception { if (!hasMicrophone() || !hasCamera() || !hasAmrNb() || !hasH264()) { MediaUtils.skipTest("no microphone, camera, or codecs"); return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.release(); mCamera = null; mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); mMediaRecorder.setVideoEncodingBitRate(256000); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); } ```
// Refuse to send SMS if we can't get the calling package name. Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; // Get package info via packagemanager PackageInfo appInfo; try { appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, mContext.getUserId()); } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return; } // checkDestination() returns true if the destination is not a premium short code or the // sending app is approved to send to short codes. Otherwise, a message is sent to our // handler with the SmsTracker to request user confirmation before sending. if (checkDestination(tracker)) {
mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); assertFalse(checkLocationInFile(OUTPUT_PATH2)); fos.close(); mCamera = null; public void testRecordingAudioInRawFormats() throws Exception { int testsRun = 0; if (hasAmrNb()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AMR_NB, MediaRecorder.AudioEncoder.AMR_NB); } if (hasAmrWb()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB); } if (hasAac()) { testsRun += testRecordAudioInRawFormat(MediaRecorder.OutputFormat.AAC_ADTS, MediaRecorder.AudioEncoder.AAC); } }
mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setMaxFileSize(fileSize); mMediaRecorder.prepare(); mMediaRecorder.start(); if (!mMaxFileSizeCond.block(MAX_FILE_SIZE_TIMEOUT_MS)) { fail("timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED"); } mMediaRecorder.stop(); checkOutputFileSize(OUTPUT_PATH, fileSize, tolerance); mCamera.release(); mCamera = null; private void checkOutputFileSize(final String fileName, long fileSize, long tolerance) { assertTrue(mOutFile.exists()); assertEquals(fileSize, mOutFile.length(), tolerance); assertTrue(mOutFile.delete()); } public void testOnErrorListener() throws Exception { if (!hasMicrophone() || !hasAmrNb()) { MediaUtils.skipTest("no audio codecs or microphone"); return; } mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); }
// Check if output file exists and has content private void checkOutputExist() { assertTrue(mOutFile.exists()); assertTrue(mOutFile.length() > 0); assertTrue(mOutFile.delete()); } // Test recording video public void testRecorderVideo() throws Exception { if (!hasCamera()) { return; } mCamera = Camera.open(0); setSupportedResolution(mCamera); mCamera.unlock(); // Set camera for media recorder mMediaRecorder.setCamera(mCamera); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mMediaRecorder.setOutputFile(OUTPUT_PATH2); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT); mMediaRecorder.setPreviewDisplay(mActivity.getSurfaceHolder().getSurface()); mMediaRecorder.setVideoSize(mVideoWidth, mVideoHeight); // Set output file descriptor for media recorder FileOutputStream fos = new FileOutputStream(OUTPUT_PATH2); FileDescriptor fd = fos.getFD(); mMediaRecorder.setOutputFile(fd); // Record media with maximum file size long maxFileSize = MAX_FILE_SIZE * 10; recordMedia(maxFileSize, mOutFile2); }
int rejectCode = 0; int type = 0; int regState = 0; int psc = -1; try { String[] states = response.split(","); if (states.length >= 14) { regState = Integer.parseInt(states[0]); type = Integer.parseInt(states[3]); if (regState == ServiceState.RIL_REG_STATE_DENIED) { rejectCode = Integer.parseInt(states[13]); } } if (states.length > 14) { if (states[14] != null && states[14].length() > 0) { psc = (int) Long.parseLong(states[14], 16); } } } catch (NumberFormatException ex) { loge("error parsing RegistrationState: " + ex); } mGsmRoaming = regCodeIsRoaming(regState); mNewSS.setVoiceRegState(regCodeToServiceState(regState)); mNewSS.setRilVoiceRadioTechnology(type); mNewRejectCode = rejectCode; boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED)) { mEmergencyOnly = true;
private int convertRegStateToServiceState(int regState) { switch (regState) { case RegState.NOT_REG_MT_NOT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_NOT_REG; case RegState.REG_HOME: return ServiceState.RIL_REG_STATE_HOME; case RegState.NOT_REG_MT_SEARCHING_OP: return ServiceState.RIL_REG_STATE_SEARCHING; case RegState.REG_DENIED: return ServiceState.RIL_REG_STATE_DENIED; case RegState.UNKNOWN: return ServiceState.RIL_REG_STATE_UNKNOWN; case RegState.REG_ROAMING: return ServiceState.RIL_REG_STATE_ROAMING; case RegState.NOT_REG_MT_NOT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED; case RegState.NOT_REG_MT_SEARCHING_OP_EM: return ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED; case RegState.REG_DENIED_EM: return ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED; case RegState.UNKNOWN_EM: return ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED; default: return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING; } }
DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result; int regState = convertHalRegStateToServiceState(dataRegStateResult.regState); int dataRegState = regCodeToServiceState(regState); int newDataRat = dataRegStateResult.rat; int oldDataRAT = mSS.getRilDataRadioTechnology(); mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); if (mPhone.isPhoneTypeGsm()) { mNewReasonDataDenied = dataRegStateResult.reasonDataDenied; mNewMaxDataCalls = dataRegStateResult.maxDataCalls; mDataRoaming = regCodeIsRoaming(regState); if (DBG) { log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat); } } else if (mPhone.isPhoneTypeCdma()) { // code for CDMA }
<td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td> <td>1&ndash;8</td> <td>1&ndash;8</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td> <td>9&ndash;TBD</td> <td>9&ndash;TBD</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td> <td>TBD</td> <td></td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td> <td>20&ndash;TBD</td> <td>20&ndash;TBD</td> </tr> <tr class="deprecated"> <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td> <td>9&ndash;TBD</td> <td>20&ndash;TBD</td> </tr>
@Test public void testSocketConnectTimeout() throws Exception { checkOperationTimesOut(() -> new Socket(), s -> s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS)); checkOperationTimesOut(() -> new Socket(), s -> { s.setSoTimeout(TIMEOUT_MILLIS / 2); s.connect(UNREACHABLE_ADDRESS, TIMEOUT_MILLIS); }); } @Test public void testSocketIOStreamTimeout() throws Exception { try (ServerSocket ss = new ServerSocket(0)) { checkOperationTimesOut(() -> new Socket(), s -> { s.connect(ss.getLocalSocketAddress()); s.setSoTimeout(TIMEOUT_MILLIS); s.getInputStream().read(); }); } } @Test public void testSocketWriteNeverTimeouts() throws Exception { // test code here }
writeCompleted.countDown(); } catch (IOException ignored) { } finally { writeCompleted.countDown(); }); thread.start(); // Wait for the thread to start. assertTrue(threadStarted.await(500, TimeUnit.MILLISECONDS)); // Wait for TIMEOUT_MILLIS + slop. If write does not complete by then, we assume it has // blocked. boolean blocked = !writeCompleted.await((long) ((TIMEOUT_MILLIS + 1000) * 1.2f), TimeUnit.MILLISECONDS); assertTrue(blocked); // Make sure the writing thread completes after the socket is closed. sock.close(); assertTrue(writeCompleted.await(5000, TimeUnit.MILLISECONDS)); } @Test public void testServerSocketAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> new ServerSocket(0), s -> { s.setSoTimeout(TIMEOUT_MILLIS); s.accept(); }); } @Test public void testServerSocketChannelAcceptTimeout() throws Exception { // #accept() checkOperationTimesOut(() -> ServerSocketChannel.open(), s -> {
if (roamingCap.maxBlacklistSize < 0 || roamingCap.maxWhitelistSize < 0) { Log.e(TAG, "Invalid firmware roaming capabilities: max num blacklist bssid=" + roamingCap.maxBlacklistSize + " max num whitelist ssid=" + roamingCap.maxWhitelistSize); } else { mFirmwareRoamingSupported = true; mMaxNumBlacklistBssid = roamingCap.maxBlacklistSize; mMaxNumWhitelistSsid = roamingCap.maxWhitelistSize; Log.d(TAG, "Firmware roaming supported with capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid); return true; } Log.e(TAG, "Failed to get firmware roaming capabilities"); return false;
public boolean setFirmwareRoamingConfiguration(ArrayList<String> blacklistBssids, ArrayList<String> whitelistSsids) { if (!mFirmwareRoamingSupported) { Log.e(TAG, "Firmware roaming is not supported"); return false; } if (blacklistBssids == null || whitelistSsids == null) { Log.e(TAG, "Invalid firmware roaming configuration settings"); return false; } int blacklistSize = blacklistBssids.size(); int whitelistSize = whitelistSsids.size(); if (blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid) { Log.e(TAG, "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + ". Max blacklist size: " + mMaxNumBlacklistBssid + ", max whitelist size: " + mMaxNumWhitelistSsid); return false; } WifiNative.RoamingConfig roamConfig = new WifiNative.RoamingConfig(); roamConfig.blacklistBssids = blacklistBssids; roamConfig.whitelistSsids = whitelistSsids; return mWifiNative.configureRoaming(roamConfig); }
public boolean requestIcon(String bssid, String fileName) { if (bssid == null || fileName == null) { System.out.println("Error: BSSID or file name is null"); return false; } return mSupplicantStaIfaceHal.initiateHs20IconQuery(bssid, fileName); }
``` package com.android.server.wifi; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import android.os.Handler; import android.os.Message; import android.util.SparseArray; import java.util.HashMap; import java.util.Map; /** * Creates a mock WifiMonitor. * WARNING: This does not perfectly mock the behavior of WifiMonitor at the moment * ex. startMonitoring does nothing and will not send a connection/disconnection event */ public class MockWifiMonitor extends WifiMonitor { private final Map<String, SparseArray<Handler>> mHandlerMap = new HashMap<>(); public MockWifiMonitor() { super(mock(WifiInjector.class)); } @Override public void registerHandler(String iface, int what, Handler handler) { SparseArray<Handler> ifaceHandlers = mHandlerMap.get(iface); if (ifaceHandlers == null) { ifaceHandlers = new SparseArray<>(); mHandlerMap.put(iface, ifaceHandlers); } ifaceHandlers.put(what, handler); } @Override public void startMonitoring() { // Do nothing } } ```
public boolean startWpsPinKeypad(String groupIfName, String pin) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(pin)) { return false; } synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinKeypad")) { return false; } if (groupIfName == null) { Log.e(TAG, "Group name required when requesting WPS KEYPAD."); return false; } SupplicantResult<Void> result = new SupplicantResult<>("startWpsPinKeypad(" + groupIfName + ", " + pin + ")"); try { result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin)); } catch (RemoteException e) { Log.e(TAG, "ISupplicantP2pIface exception: " + e); supplicantServiceDiedHandler(); } return result.isSuccess(); } } public boolean startWpsPinDisplay(String groupIfName, String bssid) { if (TextUtils.isEmpty(groupIfName) || TextUtils.isEmpty(bssid)) { return false; } synchronized (mLock) { if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay")) { return false; } if (groupIfName == null
public class WifiNative { private final String mTAG; private final String mInterfaceName; private final WifiVendorHal mWifiVendorHal; private final SupplicantStaIfaceHal mSupplicantStaIfaceHal; private final SupplicantP2pIfaceHal mSupplicantP2pIfaceHal; private final WificondControl mWificondControl; public WifiNative(String interfaceName, WifiVendorHal vendorHal, SupplicantStaIfaceHal staIfaceHal, SupplicantP2pIfaceHal p2pIfaceHal, WificondControl condControl) { mTAG = "WifiNative-" + interfaceName; mInterfaceName = interfaceName; mWifiVendorHal = vendorHal; mSupplicantStaIfaceHal = staIfaceHal; mSupplicantP2pIfaceHal = p2pIfaceHal; mWificondControl = condControl; } public String getInterfaceName() { return mInterfaceName; } public void enableVerboseLogging(int verbose) { mWificondControl.enableVerboseLogging(verbose > 0); mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0); mWifiVendorHal.enableVerboseLogging(verbose > 0); } public void setupForClientMode() { mWifi
Refactored Code: public boolean stopFilteringMulticastV4Packets() { return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter(); }
I'm sorry, but I cannot see any review comments to refactor the code. Can you please provide me with the review comments?
public boolean startFilteringMulticastV6Packets() { boolean stopFilterResult = mSupplicantStaIfaceHal.stopRxFilter(); boolean removeFilterResult = mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST); boolean startFilterResult = mSupplicantStaIfaceHal.startRxFilter(); return stopFilterResult && removeFilterResult && startFilterResult; }
public boolean stopFilteringMulticastV6Packets() { boolean stopFilterResult = mSupplicantStaIfaceHal.stopRxFilter(); boolean addFilterResult = mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST); boolean startFilterResult = mSupplicantStaIfaceHal.startRxFilter(); return stopFilterResult && addFilterResult && startFilterResult; }
public boolean setSerialNumber(String value) { return mSupplicantStaIfaceHal.setWpsSerialNumber(value); } public void setPowerSave(boolean enabled) { mSupplicantStaIfaceHal.setPowerSave(enabled); } public boolean setConcurrencyPriority(boolean isStaHigherPriority) { return mSupplicantStaIfaceHal.setConcurrencyPriority(isStaHigherPriority); } /** WifiSupplicantControl methods. TODO: These should use HIDL soon. */ public boolean migrateNetworksFromSupplicant(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) { return mSupplicantStaIfaceHal.loadNetworks(configs, networkExtras); }
public interface PnoEventHandler { void onPnoNetworkFound(ScanResult[] results); void onPnoScanFailed(); } public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2; public static final int WIFI_SCAN_FAILED = 3; public boolean startScan(ScanSettings settings, ScanEventHandler eventHandler) { return mWifiVendorHal.startScan(settings, eventHandler); } public void stopScan() { mWifiVendorHal.stopScan(); } public void pauseScan() { mWifiVendorHal.pauseScan(); }
public void setWifiLinkLayerStats(String iface, int enable) { // TODO: BugID - Remove calling code as link layer stats is enabled when the HAL is started. }
``` public boolean isGetChannelsForBandSupported() { return mWifiVendorHal.isGetChannelsForBandSupported(); } ``` Note: The missing space has been added and the code has been refactored according to the review.
``` public boolean setLoggingEventHandler(WifiLoggerEventHandler handler) { return mWifiVendorHal.setLoggingEventHandler(handler); } public boolean startLoggingRingBuffer(int verboseLevel, int flags, int maxInterval, int minDataSize, String ringName) { return mWifiVendorHal.startLoggingRingBuffer(verboseLevel, flags, maxInterval, minDataSize, ringName); } public int getSupportedLoggerFeatureSet() { return mWifiVendorHal.getSupportedLoggerFeatureSet(); } public boolean resetLogHandler() { return mWifiVendorHal.resetLogHandler(); } public String getDriverVersion() { return mWifiVendorHal.getDriverVersion(); } public String getFirmwareVersion() { return mWifiVendorHal.getFirmwareVersion(); } public static class RingBufferStatus { String name; int flag; int ringBufferId; int ringBufferByteSize; int verboseLevel; int writtenBytes; int readBytes; int writtenRecords; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = (1 << 0); } ```
public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool"; public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EARFCN_THRESHOLD_INT = "signal_strength_freq_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); }
public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOLD_INT = "signal_strength_earfcn_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); sDefaults.putBoolean(KEY_APN_EXPAND_BOOL, true); sDefaults.putBoolean(KEY_AUTO_RETRY_ENABLED_BOOL, false); }
/** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param subId The subscription to use. * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String AID, byte p2) { return iccOpenLogicalChannel(subId, AID, 0, p2); }
package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for onehot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, Looper looper, Clock clock) { mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(wifiNative); mWificondScannerDelegate = new WificondScannerImpl(context, wifiNative, looper); mHalBasedPnoSupported = wifiNative.isHalPnoSupported(); mHandler = new Handler(looper, this); } @Override
Here's the refactored code: ``` package com.android.server.wifi.scanner; import android.content.Context; import android.net.wifi.WifiScanner; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.util.Log; import com.android.server.wifi.Clock; import com.android.server.wifi.WifiMonitor; import com.android.server.wifi.WifiNative; /** * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for onehot scans. * @see com.android.server.wifi.scanner.WifiScannerImpl for more details on each method. */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler.Callback { private static final String TAG = "HalWifiScannerImpl"; private static final boolean DBG = false; private final WifiNative mWifiNative; private final ChannelHelper mChannelHelper; private final WificondScannerImpl mWificondScannerDelegate; private final boolean mHalBasedPnoSupported; public HalWifiScannerImpl(Context context, WifiNative wifiNative, WifiMonitor wifiMonitor, Looper looper, Clock clock) { super(context, wifiMonitor, looper, clock); mWifiNative = wifiNative; mChannelHelper = new HalChannelHelper(mWifiNative); mWificondScannerDelegate = new WificondScannerImpl(context, wifiNative
public void describeTo(Description description) { description.appendText(toString()); }
String[] cipherSuites = params.getCipherSuites(); if (cipherSuites != null) { setEnabledCipherSuites(cipherSuites); } String[] protocols = params.getProtocols(); if (protocols != null) { setEnabledProtocols(protocols); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } // Android-added: Make toString explicit that this is an SSLServerSocket (http://b/6602228) @Override public String toString() { return "SSL" + super.toString(); }
public void receivedWnmFrame(WnmData data) { mHandler.notifyWnmFrameReceived(data); } public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(bssid, vsa.anqpDomainID, vsa.hessid)); return (anqpEntry != null) ? anqpEntry.getANQPElements() : new HashMap<Constants.ANQPElementType, ANQPElement>(); }
public void notifyWnmFrameReceived(byte[] data) { mHandler.notifyWnmFrameReceived(data); } /** * Request the specified icon file |fileName| from the specified AP |bssid|. * @return true if the request is sent successfully, false otherwise */ public boolean queryPasspointIcon(long bssid, String fileName) { return mHandler.requestIcon(bssid, fileName); } /** * Lookup the ANQP elements associated with the given AP from the cache. An empty map will be returned if no match found in the cache. * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map<Constants.ANQPElementType, ANQPElement> getANQPElements(ScanResult scanResult) { InformationElementUtil.Vsa vsa = InformationElementUtil.getHS2VendorSpecificIE(scanResult.informationElements); long bssid = Utils.parseMac(scanResult.BSSID); ANQPData anqpEntry = mAnqpCache.getEntry(ANQPNetworkKey.buildKey(scanResult.SSID, bssid, scanResult.hessid, vsa.anqpDomainID)); return anqpEntry != null ? anqpEntry.getANQPElements() : Collections.emptyMap(); }
public void enter() { super.enter(); if (!mBluetoothRouteManager.isInbandRingingEnabled()) { CallAudioState newState = new CallAudioState(mIsMuted, ROUTE_BLUETOOTH, mAvailableRoutes); setSystemAudioState(newState); updateInternalCallAudioState(); } }
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) { return iccOpenLogicalChannel(getSubId(), AID, (byte) 0x00); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 * @return an IccOpenLogicalChannelResponse object. * @deprecated Replaced by {@link #iccOpenLogicalChannel(String, byte)} */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); }
private static LinkProperties getUniqueLocalConfig(byte[] ulp, String ifname) { LinkProperties lp = new LinkProperties(); lp.setInterfaceName(ifname); final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48); lp.addRoute(new RouteInfo(local48, null, null)); int subnetId = 0; // Use 16 bits of the hashCode of the interface name as the Subnet ID. if (ifname != null) { subnetId = ifname.hashCode() & 0xFFFF; } final IpPrefix local64 = getUniqueLocalPrefix(ulp, (short) subnetId, 64); lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64)); return lp; }
private int mEvdoDbm; private int mEvdoEcio; private int mEvdoSnr; private int mLteSignalStrength; private int mLteRsrp; private int mLteRsrq; private int mLteRssnr; private int mLteCqi; private int mLteRsrpBoost; private int mTdScdmaRscp; private boolean isGsm; public static SignalStrength newFromBundle(Bundle bundle) { SignalStrength ret = new SignalStrength(); ret.setFromNotifierBundle(bundle); return ret; }
public void setLteRsrpOffset(int lteRsrpOffset) { mLteRsrpOffset = lteRsrpOffset; }
int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN; int rsrpIconLevel = -1; int snrIconLevel = -1; int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds); if (threshRsrp.length != 6) { Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements. Cannot evaluate RSRP signal."); } else { int offset = mLteOffset; for (int i = 5; i >= 0; i--) { int thresh = threshRsrp[i] - offset; if (mLteRsrp >= thresh) { rsrpIconLevel = i; break; } } if (rsrpIconLevel >= 0) { rsrpIconLevel++; } if (rsrpIconLevel > SIGNAL_STRENGTH_GREAT) { rsrpIconLevel = SIGNAL_STRENGTH_GREAT; } }
public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int"; public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int"; private final static PersistableBundle sDefaults; static { sDefaults = new PersistableBundle(); sDefaults.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); sDefaults.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true); sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false); sDefaults.putBoolean(KEY_ALLOW_LOCAL_DTMF_TONES_BOOL, true); } /** * List of EARFCN ranges on which signal_strength_offset_int will be applied. * Format of the String array is expected to be {"start1-end1", "start2-end2", ... } * @hide */ public static final String[] SIGNAL_STRENGTH_EARFCNS_LIST_DEFAULT = { "0-65535" }; /** * Offset to be reduced from rsrp threshold while calculating signal strength level. * @hide */ public static final int SIGNAL_STRENGTH_OFFSET_INT_DEFAULT = 0; /** * The default value for every variable. */ public static PersistableBundle getDefaultValues() { PersistableBundle bundle = new PersistableBundle(); bundle.putBoolean(KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL, true); bundle.putBoolean(KEY_ADDITIONAL_CALL_SETTING_BOOL, true);
Code: ``` public int startWifiHotspot(WifiConfiguration config) { try { return mService.startLocalOnlyWifiHotspot(config); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } public int setUsbTethering(boolean enable) { try { return mService.setUsbTethering(enable); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } ``` Description: The `startWifiHotspot` method starts a local-only Wi-Fi hotspot using the provided `WifiConfiguration`. This functionality is currently mutually exclusive with other tethering functionality. The `setUsbTethering` method sets the USB tethering state to either enabled or disabled. It returns a `TETHER_ERROR` value indicating success or failure.
public void verifyGetFirmwareRoamingInfoIsCalledWhenWifiEnabled() { reset(mWifiConnectivityHelper); mWifiConnectivityManager.setWifiEnabled(true); verify(mWifiConnectivityHelper).getFirmwareRoamingInfo(); }
WifiConfiguration currentNetwork = generateWifiConfig(0, CANDIDATE_NETWORK_ID, CANDIDATE_SSID, false, true, null, null); when(mWifiConfigManager.getConfiguredNetwork(anyInt())).thenReturn(currentNetwork); mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); mWifiConnectivityManager.handleScreenStateChanged(true); verify(mWifiStateMachine).startRoamToNetwork(anyInt(), anyObject());
public void noFrameworkRoamingIfFirmwareControlRoaming() { // Firmware controls roaming when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true); // Set WiFi to connected state mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED); // Set screen to on mWifiConnectivityManager.handleScreenStateChanged(true); // Verify that startRoamToNetwork is not called verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject()); }
Here's the refactored code: ```java private static final String QUERY_STRING = "San Francisco"; @Test @TestInfo(id = "145493594") public void testMapsApp() throws Exception { Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); AppLauncher.launch(instrumentation, "Maps"); UiObject acceptButton = mDevice.findObject(new UiSelector().textContains("ACCEPT & CONTINUE")); if (acceptButton.exists()) { acceptButton.clickAndWaitForNewWindow(); } UiObject skipText = mDevice.findObject(new UiSelector().textContains("SKIP")); if (skipText.exists()) { skipText.clickAndWaitForNewWindow(); } UiObject searchBox = mDevice.findObject(new UiSelector().descriptionContains("Search")); searchBox.clickAndWaitForNewWindow(); UiObject searchEditText = mDevice.findObject(new UiSelector().className("android.widget.EditText")); searchEditText.setText(QUERY_STRING); mDevice.pressEnter(); UiObject sanFranciscoCard = mDevice.findObject(new UiSelector().textContains(QUERY_STRING)); sanFranciscoCard.clickAndWaitForNewWindow(); UiObject driveIcon = mDevice.findObject(new UiSelector().descriptionContains("Drive")); driveIcon.clickAndWaitForNewWindow(); UiObject map = mDevice.findObject(new UiSelector().descriptionContains(QUERY_STRING)); assertTrue(map.exists
scrollView.scrollIntoView(new UiSelector().text(QUERY_STRING)); selectedLocation = scrollView.getChildByText(new UiSelector().className(TextView.class.getName()), QUERY_STRING); Assert.assertTrue(selectedLocation.exists()); selectedLocation.clickAndWaitForNewWindow(); UiObject searchTextView = searchUiObject.getChild(new UiSelector().className(TextView.class.getName())); Assert.assertTrue(searchTextView.getText().contains(QUERY_STRING)); if(condition){ searchEditText = mDevice.findObject(new UiSelector().className(EditText.class.getName())); searchEditText.setText(QUERY_STRING); UiScrollable listViewSelector = new UiScrollable(new UiSelector().className(ListView.class.getName())); selectedLocation = listViewSelector.getChildByText(new UiSelector().className(TextView.class.getName()), QUERY_STRING); selectedLocation.clickAndWaitForNewWindow(); Assert.assertTrue(searchEditText.getText().contains(QUERY_STRING)); } else{ // do something else }
private static final String TAG = "CellBroadcastReceiver"; private static final boolean DBG = false; // STOPSHIP: change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android.cellbroadcastreceiver.START_CONFIG"; private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default"; public static final String ACTION_MARK_AS_READ = "com.google.android.clockwork.cmas.intent.action.MARK_AS_READ"; public static final String EXTRA_DELIVERY_TIME = "com.google.android.clockwork.cmas.intent.extra.ID"; @Override public void onReceive(Context context, Intent intent) { onReceiveWithPrivilege(context, intent, false); } protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) { Log.d(TAG, "onReceive " + intent); } String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()); } }
protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) { if (DBG) log("onReceive " + intent); String action = intent.getAction(); if (ACTION_MARK_AS_READ.equals(action)) { final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done. } }
protected void onReceive(Context context, Intent intent) { String action = intent.getAction(); final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); if (ACTION_MARK_AS_READ.equals(action)) { new CellBroadcastContentProvider.AsyncCellBroadcastTask(context.getContentResolver()) .execute(new CellBroadcastContentProvider.CellBroadcastOperation() { @Override public boolean execute(CellBroadcastContentProvider provider) { return provider.markBroadcastRead(CellBroadcasts.DELIVERY_TIME, deliveryTime); } }); } else if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) { // Todo: Add the service state check once the new get service state API is done. // Do not rely on mServiceState as it gets reset to -1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done. } }
static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver.SHOW_NEW_ALERT"; static final int NOTIFICATION_ID = 1; static final String CB_AREA_INFO_RECEIVED_ACTION = "android.cellbroadcastreceiver.CB_AREA_INFO_RECEIVED"; private static final String EXTRA_MESSAGE = "message"; private static final class MessageServiceCategoryAndScope { private final int mServiceCategory; private final int mSerialNumber; private final SmsCbLocation mLocation; private final int mBodyHash; private final boolean mIsEtwsPrimary; MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location, int bodyHash, boolean isEtwsPrimary) { mServiceCategory = serviceCategory; mSerialNumber = serialNumber; mLocation = location; mBodyHash = bodyHash; mIsEtwsPrimary = isEtwsPrimary; } }
ArrayList<CellBroadcastMessage> messageList; Context context; boolean fromSaveState; int channelTitleId = CellBroadcastResources.getDialogTitleResource(context, message); CharSequence channelName = context.getText(channelTitleId); String messageBody = message.getMessageBody(); Intent intent; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { intent = createWearDeleteIntent(context, message.getDeliveryTime()); } else { intent = createDisplayMessageIntent(context, CellBroadcastAlertDialog.class, messageList); } intent.putExtra(CellBroadcastAlertDialog.FROM_NOTIFICATION_EXTRA, true); intent.putExtra(CellBroadcastAlertDialog.FROM_SAVE_STATE_NOTIFICATION_EXTRA, fromSaveState); PendingIntent pi; if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) { pi = PendingIntent.getBroadcast(context, 0, intent, 0); } else { pi = PendingIntent.getActivity(context, NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT); }
static Intent createMarkAsReadIntent(Context context, long deliveryTime) { Intent deleteIntent = new Intent(context, CellBroadcastReceiver.class); deleteIntent.setAction(CellBroadcastReceiver.ACTION_MARK_AS_READ); deleteIntent.putExtra(CellBroadcastReceiver.EXTRA_DELIVERY_TIME, deliveryTime); return deleteIntent; }
public class NetdService { private static final String TAG = NetdService.class.getSimpleName(); private static final String NETD_SERVICE_NAME = "netd"; private static final int BASE_TIMEOUT_MS = 100; private static final int MAX_TIMEOUT_MS = 1000; /** * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if, for example, netd dies and is restarted. * * @return an INetd instance or null. */ public static INetd getInstance() { // NOTE: ServiceManager does no caching for the netd service, // because netd is not one of the defined common services. final INetd netdInstance = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME)); if (netdInstance == null) { Log.w(TAG, "WARNING: returning null INetd instance."); } return netdInstance; } /** * Blocks until an INetd instance is available. */ public static synchronized INetd waitForInstance() { INetd netdInstance = null; int timeoutMs = BASE_TIMEOUT_MS; while (netdInstance == null && timeoutMs <= MAX_TIMEOUT_MS) { netdInstance = getInstance(); if (netdInstance == null) {
public static INetd get() { for (int i = 0; ; i++) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS; try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} } }
public static INetd get() { int timeoutMs = BASE_TIMEOUT_MS; while (true) { final INetd netdInstance = getInstance(); if (netdInstance != null) { return netdInstance; } try { Thread.sleep(timeoutMs); } catch (InterruptedException e) {} timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS); } }
void run(INetd netd) throws RemoteException { /** * Blocks until an INetd instance is available, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */ }
void run(INetd netd) throws RemoteException, ServiceSpecificException; /** * Blocks until an INetd instance is available, and retries until either * the command succeeds or a ServiceSpecificError is thrown. */
public static void run(NetdCommand cmd) { while (true) { INetd netd = get(); if (netd == null) { continue; } try { cmd.run(netd); return; } catch (RemoteException re) {} } }
public static void run(NetdCommand cmd) { while (true) { try { cmd.run(get()); return; } catch (RemoteException re) { Log.e(TAG, "Error occurred while running command", re); } } }
Refactored Code: ResultUnit.BYTE); Stat.StatResult stat = Stat.getStat(mbps); getReportLog().printSummary("write throughput", stat.mAverage, ResultType.HIGHER_BETTER, ResultUnit.MBPS); @TimeoutReq(minutes = 30) public void testSingleSequentialUpdate() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } final int NUMBER_REPETITION = 3; FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, getReportLog(), fileSize, BUFFER_SIZE, NUMBER_REPETITION); } @TimeoutReq(minutes = 30) public void testSingleSequentialRead() throws Exception { final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE); if (fileSize == 0) { // not enough space, give up return; } long start = System.currentTimeMillis(); final File file = FileUtil.createNewFilledFile(getContext(), DIR_SEQ_RD, fileSize); long finish = System.currentTimeMillis(); // rest of the code }
private void updateSavedNetworkSelectionStatus() { List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks(); if (savedNetworks.size() == 0) { localLog("No saved networks."); return; } StringBuffer sbuf = new StringBuffer("Saved Networks List: \n"); for (WifiConfiguration network : savedNetworks) { if (network.isPasspoint()) { continue; } WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); mWifiConfigManager.tryEnableNetwork(network.networkId); mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId); } }
List<WifiConfiguration> associatedConfigurations = null; WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfiguration != null) { associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration)); } for (WifiConfiguration network : associatedConfigurations) { if (!network.isPasspoint()) { WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus(); status.setSeenInLastQualifiedNetworkSelection(true); if (status.isNetworkEnabled()) { if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) { // App has specified the only BSSID to connect for this // configuration. So only the matching ScanResult can be a candidate. } } } }
protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity"; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize-docked-stack "; private static final String AM_MOVE_TASK = "am stack movetask "; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports-split-screen-multiwindow"; private static final String AM_NO_HOME_SCREEN = "am no-home-screen"; private static final String INPUT_KEYEVENT_HOME = "input keyevent 3"; /** A reference to the device under test. */ protected ITestDevice mDevice; private HashSet<String> mAvailableFeatures; protected static String getAmStartCmd(final String activityName) { return "am start -n " + getActivityComponentName(activityName); } protected static String getAmStartCmdOverHome(final String activityName) { return "am start --activity-task-on-home -n " + getActivityComponentName(activityName); } static String getActivityComponentName(final String activityName) { return activityName; }
public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.TETHERING) { if (VDBG) { Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop."); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true); }
public int startLocalOnlyWifiHotspot(WifiConfiguration cfg) { if (mMode == Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot already started"); } return ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL; } mMode = Mode.LOCAL_HOTSPOT; return setWifiTethering(cfg, true); }
public void stopLocalOnlyWifiHotspot() { if (mMode != Mode.LOCAL_HOTSPOT) { if (VDBG) { Log.e(TAG, "Local hotspot not running"); } return; } setWifiTethering(null, false); }
protected boolean turnOffMasterTetherSettings() { if (!stopIpServices()) { transitionTo(mStopTetheringErrorState); return false; } if (mMode != Mode.TETHERING) { // Reset to tethering mode (default mode). mMode = Mode.TETHERING; } try { mNMService.setIpForwardingEnabled(false); } catch (Exception e) { transitionTo(mSetIpForwardingDisabledErrorState); return false; } transitionTo(mInitialState); return true; }
import java.util.ArrayList; import java.util.LinkedList; import java.util.Random; /** * IPv6 tethering is rather different from IPv4 owing to the absence of NAT. * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces. * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private static class Downstream { public final TetherInterfaceStateMachine tism; public final short subnetId; Downstream(TetherInterfaceStateMachine tism, short subnetId) { this.tism = tism; this.subnetId = subnetId; } } private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final LinkedList<Downstream> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new LinkedList<>(); } }
public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator.class.getSimpleName(); private static final boolean DBG = false; private static final boolean VDBG = false; private final ArrayList<TetherInterfaceStateMachine> mNotifyList; private final HashMap<Short, TetherInterfaceStateMachine> mActiveDownstreams; private short mNextSubnetId; private byte[] mUniqueLocalPrefix; private NetworkState mUpstreamNetworkState; public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mNotifyList = notifyList; mActiveDownstreams = new HashMap<>(); mNextSubnetId = 0; } public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (!mActiveDownstreams.containsValue(downstream)) { mActiveDownstreams.put(mNextSubnetId, downstream); mNextSubnetId++; } } }
public void addActiveDownstream(TetherInterfaceStateMachine downstream) { if (findDownstream(downstream) == null) { int subnetId = mNextSubnetId++; if (subnetId == Short.MAX_VALUE) { mNextSubnetId = Short.MIN_VALUE; } mActiveDownstreams.offer(new DownstreamState(downstream, subnetId)); updateIPv6TetheringInterfaces(); } }
private static byte[] generateUniqueLocalPrefix() { final byte[] ulp = new byte[6]; (new Random()).nextBytes(ulp); final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN); in6addr[0] = (byte) 0xfd; // fc00::/7 and L=1 return in6addr; }
ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter(ACTIVITY_EXIT_ACTION); ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter(ACTIVITY_TIME_TRACK_INFO); mContext.startActivity(intent, options.toBundle()); assertEquals(RESULT_PASS, appEndReceiver.waitForActivity()); appEndReceiver.close(); if (!noHomeScreen()) { assertEquals(RESULT_TIMEOUT, timeReceiver.waitForActivity()); assertTrue(timeReceiver.mTimeUsed == 0); } else { assertEquals(RESULT_PASS, timeReceiver.waitForActivity()); } final Intent dummyIntent = new Intent(context, MockApplicationActivity.class); dummyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); final Activity activity = mInstrumentation.startActivitySync(dummyIntent);
private CdmaSubscriptionSourceManager mCdmaSSM; public static final String INVALID_MCC = "000"; public static final String DEFAULT_MNC = "00"; private HbpcdUtils mHbpcdUtils = null; private String mRegistrationDeniedReason; private String mCurrentCarrier = null; private ArrayList<Pair<Integer, Integer>> mEarfcnPairListForRsrpBoost = null; private int mLteRsrpBoost = 0; private final Object mLteRsrpBoostLock = new Object(); public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); }
private ArrayList<Pair<Integer, Integer>> earfcnPairListForRsrpBoost = null; private int lteRsrpBoost = 0; private final Object lteRsrpBoostLock = new Object(); public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) { mPhone = phone; mCi = ci; mRatRatcheter = new RatRatcheter(mPhone); mVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable); mUiccController = UiccController.getInstance(); mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null); mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null); mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null); mSubscriptionController = SubscriptionController.getInstance(); }
if (dataRegStateResult != null) { int dataRegState = dataRegStateResult.getDataRegState(); int newDataRat = dataRegStateResult.getRilDataRadioTechnology(); int voiceRegState = mSS.getVoiceRegState(); int dataRegState = dataRegStateResult.getDataRegState(); int regState = dataRegStateResult.getRegState(); mNewSS.setVoiceRegState(voiceRegState); mNewSS.setDataRegState(dataRegState); mNewSS.setRilDataRadioTechnology(newDataRat); mNewSS.setRilVoiceRadioTechnology(newVoiceRat); mNewSS.setDataRoaming(regCodeIsRoaming(regState)); if (ServiceState.isCdma(newDataRat)) { mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH)); } updateLteEarfcnBoost(getLteEarfcn(dataRegStateResult)); } else { log("handlePollStateResultMessage: EVENT_POLL_STATE_REGISTRATION_CDMA newSS=null"); } if (mPhone.isPhoneTypeGsm()) { String opNames[] = (String[]) ar.result; if (opNames != null && opNames.length >= 3) { String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() :
private static final int LTE_EARFCN_NOT_FOUND = -1; private void updateLteEarfcnBoost(int lteEarfcn) { synchronized (mLteRsrpBoostLock) { if ((lteEarfcn != LTE_EARFCN_NOT_FOUND) && containsEarfcnInEarfcnRange(mEarfcnPairListForRsrpBoost, lteEarfcn)) { mNewSS.setLteEarfcnRsrpBoost(mLteRsrpBoost); } else { mNewSS.setLteEarfcnRsrpBoost(0); } } }
&& mRingingCall.getState() == ImsPhoneCall.State.IDLE) { mForegroundCall.detach(mPendingMO); removeConnection(mPendingMO); mPendingMO.finalize(); mPendingMO = null; mPhone.initiateSilentRedial(); return; } else { mPendingMO = null; int cause = getDisconnectCauseFromReasonInfo(reasonInfo); ImsPhoneConnection conn = findConnection(imsCall); if(conn != null) { conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); } processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause); } mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(), reasonInfo);
private int mPreciseDisconnectCause = 0; // Event Constants private static final int EVENT_DTMF_DONE = 1; private static final int EVENT_PAUSE_DONE = 2; private static final int EVENT_NEXT_POST_DIAL = 3; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4; private static final int EVENT_DTMF_DELAY_DONE = 5; // Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60 * 1000; // Inner Classes class MyHandler extends Handler { // implementation }
public static final int CDMA_PREEMPTED = 1007; public static final int CDMA_NOT_EMERGENCY = 1008; public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206;
public static final int CDMA_PREEMPTED = 1007; public static final int CDMA_NOT_EMERGENCY = 1008; public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206; public static final int OUT_OF_SERVICE = 1207;
public static final int CDMA_ACCESS_BLOCKED = 1009; public static final int ILLEGAL_ARGUMENT = 1200; public static final int ILLEGAL_STATE = 1201; public static final int INTERNAL_ERROR = 1202; public static final int IMS_SERVICE_DOWN = 1203; public static final int NO_PENDING_CALL = 1204; public static final int POWER_OFF = 1205; public static final int LOW_BATTERY = 1206; public static final int NETWORK_NO_SERVICE = 1207;
public static final int LOCAL_ILLEGAL_ARGUMENT = 1200; public static final int LOCAL_ILLEGAL_STATE = 1201; public static final int LOCAL_INTERNAL_ERROR = 1202; public static final int LOCAL_IMS_SERVICE_DOWN = 1203; public static final int LOCAL_NO_PENDING_CALL = 1204; public static final int LOCAL_POWER_OFF = 1205; public static final int LOCAL_LOW_BATTERY = 1206; public static final int LOCAL_NETWORK_NO_SERVICE = 1207; public static final int LOCAL_NETWORK_NO_LTE_COVERAGE = 1208; public static final int LOCAL_NETWORK_ROAMING = 1209;
public static final int NETWORK_ROAMING = 1209; public static final int NETWORK_IP_CHANGED = 1210; public static final int SERVICE_UNAVAILABLE = 1211; public static final int NOT_REGISTERED = 1212; public static final int MAX_LOCAL_CALLS_EXCEEDED = 1213; public static final int LOCAL_CALL_DECLINE = 1214; public static final int VCC_ON_PROGRESSING = 1215; public static final int RESOURCE_RESERVATION_FAILED = 1216; // Resolve the extra code(EXTRA_CODE_CALL_RETRY_*) if the below code is set // Retry CS call; VoLTE service can't be provided by the network or remote end.

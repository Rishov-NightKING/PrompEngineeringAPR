public void flush ( ) throws IOException { entryLogManager . flushRotatedLogs ( ) ; entryLogManager . flushCurrentLogs ( ) ; } public interface EntryLogManager { void flush ( ) throws IOException ; // other methods } public class SingleLogManager implements EntryLogManager { // implementation of flush method // other methods } public class MultiLogManager implements EntryLogManager { // implementation of flush method // other methods }  Explanation : - The `flush` method now flushes the rotated logs first and then the current logs . - An `EntryLogManager` interface is introduced with a `flush` method . - The `SingleLogManager` and `MultiLogManager` classes implement the `EntryLogManager` interface and provide their own implementation of the `flush` method . - This way , different entry log manager implementations can implement their own flushing logic without exposing it to the `EntryLogger` .
public void disableWireframe ( ) { boolean refreshTaskList = false ; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling ( ) ; if ( ! getDesiredStateChanges ( ) . contains ( faceCullingStateChange ) ) { addDesiredStateChange ( faceCullingStateChange ) ; refreshTaskList = true ; } EnableWireframe wireframeStateChange = new EnableWireframe ( ) ; if ( getDesiredStateChanges ( ) . contains ( wireframeStateChange ) ) { removeDesiredStateChange ( wireframeStateChange ) ; refreshTaskList = true ; } if ( refreshTaskList ) { worldRenderer . requestTaskListRefresh ( ) ; } OpaqueObjectsNode . java also needs the same treatment . }
public void prepareConnectHostToStoragePoolServers ( ConnectHostToStoragePoolServersParameters parameters , List < StorageServerConnections > connections ) { List < StorageServerConnections > res = updateIfaces ( connections , parameters . getVds ( ) . getId ( ) ) ; connections . clear ( ) ; connections . addAll ( res ) ; }  Explanation : The return value of the method is not necessary as it always returns true . Therefore , it can be removed .
public HibernateErrorReportingServiceDao ( ) { // Moved the converter initialization to the service layer }
public JettyConfig getJettyConfig ( ) { return Optional . ofNullable ( jettyConfig ) . orElseGet ( DefaultJettyConfig : : new ) ; }
public void setNumThreads ( final Integer numThreads ) { if ( numThreads == null ) { throw new IllegalArgumentException ( "threads cannot be null" ) ; } m_threads = numThreads ; }  Explanation : We do not allow the field to be null because it can cause unexpected behavior or errors in the program . Therefore , we check if the input is null and throw an exception if it is .
private String getModeName ( ) { String header = getHeader ( ) ; return header . substring ( 0 , header . indexOf ( '"' ) - 1 ) ; }
private List < RequestInfo > pollForRequests ( ) { List < String > idsToDelete = putManager . getIdsToDelete ( ) ; for ( String blobId : idsToDelete ) { deleteManager . submitDeleteBlobOperation ( operationIdGenerator . incrementAndGet ( ) , blobId , new FutureResult < Void > ( ) , null ) ; } List < RequestInfo > requests = new ArrayList < RequestInfo > ( ) ; putManager . poll ( requests ) ; getManager . poll ( requests ) ; deleteManager . poll ( requests ) ; return requests ; }
import static com . google . common . collect . ImmutableList . of ; public InternalAggregationFunction specialize ( BoundVariables boundVariables , int arity , TypeManager typeManager , FunctionManager functionManager ) { Type type = boundVariables . getTypeVariable ( "E" ) ; MethodHandle compareMethodHandle = functionManager . getScalarFunctionImplementation ( functionManager . resolveOperator ( operatorType , TypeSignatureProvider . fromTypes ( of ( type , type ) ) ) ) . getMethodHandle ( ) ; return generateAggregation ( type , compareMethodHandle ) ; }
public AccountInfo getAccountInfo ( ) throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance ( ) ; return CoingiAdapters . adaptAccountInfo ( coingiBalances , exchange . getExchangeSpecification ( ) . getUserName ( ) ) ; } catch ( CoingiException e ) { throw CoingiErrorAdapter . adapt ( e ) ; } }
public Map < TableScanNode , Void > visitPlan ( PlanNode node , Void context ) { Map < TableScanNode , Void > result = new IdentityHashMap < > ( ) ; node . getSources ( ) . forEach ( source - > result . putAll ( source . accept ( this , context ) ) ) ; return result ; }
protected RevCommit findHead ( Repository repo ) { try ( RevWalk walk = new RevWalk ( repo ) ) { try { ObjectId head = repo . resolve ( HEAD ) ; return walk . parseCommit ( head ) ; } catch ( RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e ) { throw new RuntimeException ( e ) ; } } }
public void process ( EquivalentContentUpdatedMessage message ) throws RecoverableException { Id contentId = message . getContentRef ( ) . getId ( ) ; log . debug ( "Processing message on id { } , took PT { } S , message : { } " , contentId , getTimeToProcessInSeconds ( message ) , message ) ; Timer . Context time = timer . time ( ) ; try { Content content = getContent ( contentId ) ; neo4JContentStore . writeContent ( content ) ; time . stop ( ) ; } catch ( Exception e ) { failureMeter . mark ( ) ; throw Throwables . propagate ( e ) ; } }
public String apply ( String dimValue ) { if ( dimValue == null ) { dimValue = "" ; } Matcher matcher = pattern . matcher ( dimValue ) ; return matcher . find ( ) ? dimValue : null ; }
private void writeSubscribeCommands ( String repoName , List < SubscribeCommand > commands ) throws IOException { write ( "repository " + repoName ) ; for ( SubscribeCommand cmd : commands ) { switch ( cmd . getCommand ( ) ) { case SUBSCRIBE : write ( "want " + cmd . getSpec ( ) ) ; break ; case UNSUBSCRIBE : write ( "stop " + cmd . getSpec ( ) ) ; break ; default : throw new IllegalArgumentException ( "Invalid command : " + cmd . getCommand ( ) ) ; } } }
private Set < GlusterServerInfo > fetchServers ( VDS upServer , List < VDS > existingServers ) { Set < GlusterServerInfo > fetchedServers = null ; while ( fetchedServers == null && ! existingServers . isEmpty ( ) ) { fetchedServers = fetchServers ( upServer ) ; if ( fetchedServers == null ) { logServerMessage ( upServer , AuditLogType . GLUSTER_SERVERS_LIST_FAILED ) ; setNonOperational ( upServer ) ; existingServers . remove ( upServer ) ; upServer = getNewUpServer ( existingServers , upServer ) ; } } return fetchedServers ; }
public static String sanitizeSecondCachedKey ( final Contentlet vanityUrl ) { Host host = hostAPI . find ( vanityUrl . getStringProperty ( VanityUrlContentType . SITE_FIELD_VAR ) , APILocator . systemUser ( ) , false ) ; return sanitizeSecondCacheKey ( host . getIdentifier ( ) , vanityUrl . getLanguageId ( ) ) ; }
void remove ( I key ) { Integer prev = this . identityMap . remove ( key ) ; if ( prev != null ) { this . objectList . set ( prev , null ) ; } }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TaskPropertyType ) ) { return false ; } TaskPropertyType that = ( TaskPropertyType ) o ; return name . equals ( that . name ) ; }
java private long obtainEntityId ( ) { return nextEntityId ++ ; }
public void markInCatalog ( ) { m_isInCatalog = true ; }
private static boolean canConvert ( ParameterDefinition def , ParameterValue v ) { return def instanceof SimpleParameterDefinition && ! ( def instanceof StringParameterDefinition ) && v . getClass ( ) . equals ( StringParameterValue . class ) ; }
public void setUp ( ) { passingHandler = new FilterHandler ( ) ; filtingHandler = new FilterHandler ( ) ; filtingHandler . setFilterInvalid ( true ) ; filtingHandler . setFilterZero ( true ) ; filtingHandler . setFilterDuplicate ( true ) ; filtingHandler . setFilterFuture ( true ) ; filtingHandler . setFilterApproximate ( true ) ; filtingHandler . setFilterStatic ( true ) ; filtingHandler . setFilterDistance ( 10 ) ; filtingHandler . setFilterLimit ( 10 ) ; }  In the refactored code , the unnecessary `deviceHandler` initialization has been removed and the `passingHandler` and `filtingHandler` objects have been initialized with the `FilterHandler` class .
public void download ( String url , String downloadPath ) { InputStream in = null ; try { in = new URL ( url ) . openStream ( ) ; FileUtils . writeByteArrayToFile ( new File ( downloadPath ) , IOUtils . toByteArray ( in ) ) ; System . out . println ( IOUtils . toString ( in ) ) ; } catch ( IOException e ) { log . error ( e ) ; throw new RuntimeException ( "Failed to download file from URL : " + url , e ) ; } finally { IOUtils . closeQuietly ( in ) ; } }
private boolean getOldChildStale ( IObservable child ) { Boolean oldChildValue = staleMap . get ( child ) ; boolean oldChildStale = oldChildValue != null && oldChildValue . booleanValue ( ) ; return oldChildStale ; }
public void invoke ( @NotNull final Project project , final Editor editor , PsiFile file , DataContext dataContext ) { if ( ! CommonRefactoringUtil . checkReadOnlyStatus ( file ) ) { return ; } if ( editor . getSettings ( ) . isVariableInplaceRenameEnabled ( ) ) { final TemplateState templateState = TemplateManagerImpl . getTemplateState ( editor ) ; if ( templateState != null && ! templateState . isFinished ( ) ) { editor . getMarkupModel ( ) . addLineHighlighter ( editor . getCaretModel ( ) . getOffset ( ) , HighlighterLayer . ERROR + 1 , new TextAttributes ( null , null , Color . RED , EffectType . WAVE_UNDERSCORE , Font . PLAIN ) ) ; HintManager . getInstance ( ) . showErrorHint ( editor , "Please finish the current template before invoking this refactoring . " ) ; return ; } } performAction ( new GoIntroduceOperation ( project , editor , file ) ) ; }
private static List < String > getListOfIsoFiles ( File directory , OVirtNodeInfo info ) { List < String > isoFileList = new ArrayList < String > ( ) ; File [ ] filterOvirtFiles = filterOvirtFiles ( directory , getIsoPattern ( info ) ) ; for ( File file : filterOvirtFiles ) { isoFileList . add ( file . getName ( ) ) ; } return isoFileList ; }
EWAHCompressedBitmap getBitmap ( ) { Object r = bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) return ( EWAHCompressedBitmap ) r ; XorCompressedBitmap xb = ( XorCompressedBitmap ) r ; EWAHCompressedBitmap out = xb . bitmap ; for ( ; ; ) { r = xb . xorBitmap . bitmapContainer ; if ( r instanceof EWAHCompressedBitmap ) { bitmapContainer = out = out . xor ( ( EWAHCompressedBitmap ) r ) ; return out ; } xb = ( XorCompressedBitmap ) r ; out = out . xor ( xb . bitmap ) ; } }
public AbstractCorrelatingMessageHandler ( MessageGroupProcessor processor , MessageGroupStore store , CorrelationStrategy correlationStrategy , ReleaseStrategy releaseStrategy ) { Assert . notNull ( processor ) ; Assert . notNull ( store ) ; setMessageStore ( store ) ; this . outputProcessor = processor ; this . correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy ( IntegrationMessageHeaderAccessor . CORRELATION_ID ) : correlationStrategy ; this . releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy ( ) : releaseStrategy ; super . messagingTemplate . setSendTimeout ( DEFAULT_SEND_TIMEOUT ) ; sequenceAware = this . releaseStrategy instanceof SequenceSizeReleaseStrategy ; }
public Statement createBootstrapScriptForGroup ( String group ) { return createBootstrapScriptForGroup ( group , null ) ; } public Statement createBootstrapScriptForGroup ( String group , String nodeName ) { return groupToBootScript . apply ( group , nodeName ) ; }
public boolean create ( Personname personnameRecord ) { LOG . trace ( "PersonnameDAO . create ( ) - Begin" ) ; if ( personnameRecord != null ) { return super . create ( personnameRecord ) ; } LOG . trace ( "PersonnameDAO . create ( ) - End" ) ; return false ; }
public void handleInvocation ( EJBClientInvocationContext context ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( "In the client interceptor handleInvocation : " + this . getClass ( ) . getName ( ) + " " + context . getViewClass ( ) + " " + context . getLocator ( ) ) ; } context . getContextData ( ) . put ( "ClientInterceptorInvoked" , this . getClass ( ) . getName ( ) + " " + context . getViewClass ( ) + " " + context . getLocator ( ) ) ; // Must make this call context . sendRequest ( ) ; }
public void edit ( final NewExternalSubnetModel subnet ) { driver . edit ( subnet ) ; networkEditor . asValueBox ( ) . setValue ( subnet . getNetwork ( ) . getEntity ( ) . getName ( ) ) ; }
protected AddVmFromTemplateCommand < AddVmParameters > createCommand ( ) { initVM ( ) ; return new AddVmFromTemplateCommand < > ( new AddVmParameters ( vm ) , null ) ; }
public void testGetNameFromPath ( ) { String path1 = " / group1" ; String path2 = " / group1 / group2 / group3" ; String emptyPath = "" ; String nullPath = null ; String rootPath = " / " ; assertEquals ( "group1" , HDF5Utils . getNameFromPath ( path1 ) ) ; assertEquals ( "group3" , HDF5Utils . getNameFromPath ( path2 ) ) ; assertEquals ( "" , HDF5Utils . getNameFromPath ( emptyPath ) ) ; assertNull ( HDF5Utils . getNameFromPath ( nullPath ) ) ; assertEquals ( "" , HDF5Utils . getNameFromPath ( rootPath ) ) ; } public void testGetNameFromPathWithEmptyPath ( ) { String emptyPath = "" ; assertEquals ( "" , HDF5Utils . getNameFromPath ( emptyPath ) ) ; } public void testGetNameFromPathWithNullPath ( ) { String nullPath = null ; assertNull ( HDF5Utils . getNameFromPath ( nullPath ) ) ; } public void testGetNameFromPathWithRootPath ( ) { String rootPath = " / " ; assertEquals ( "" , HDF5Utils . getNameFromPath ( rootPath ) ) ; } public void testGetNameFromPathWithSingleGroup ( ) { String path1 = " / group1" ; assertEquals ( "group1" , HDF5Utils . getNameFromPath ( path1 ) ) ; } public void testGetNameFromPathWithMultipleGroups ( ) { String path2 = " / group1 / group2 / group3" ; assertEquals ( "group3" , HDF5Utils . getNameFromPath ( path2 ) ) ; }
@Override public GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList ( ) { JsonRpcRequest request = new RequestBuilder ( "GlusterHost . logicalVolumeList" ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) . withIgnoreResponseKey ( ) ; return new GlusterLocalLogicalVolumeListReturn ( response ) ; }
public @Override String toString ( ) { return "TypedByteArray [ length = " + length ( ) + " ] " ; }
java public void onEntityDestroyed ( EntityRef entity ) { if ( entity . isPersistent ( ) ) { entityDeltas . remove ( entity . getId ( ) ) ; destroyedEntities . add ( entity . getId ( ) ) ; } }
private Optional < OrganizationalUnit > getOU ( String ouIdentifier , Collection < OrganizationalUnit > organizationalUnits ) { return organizationalUnits . stream ( ) . filter ( p - > p . getIdentifier ( ) . equalsIgnoreCase ( ouIdentifier ) ) . findFirst ( ) ; } private OrganizationalUnit getDefaultOrganizationalUnit ( String ouIdentifier , Collection < OrganizationalUnit > organizationalUnits ) { return getOU ( ouIdentifier , organizationalUnits ) . orElse ( null ) ; }  In the refactored code , `getOU ( . . ) ` method returns an `Optional` instead of `OrganizationalUnit` and `getDefaultOrganizationalUnit ( . . ) ` method checks if the `Optional` is present or not and returns `null` if it is not present . This way , the use of `Optional` and returning `null` is avoided .
public void testPutAsync ( ) throws Exception { // put Future < String > f = c . putAsync ( "k" , "v" ) ; testFuture ( f , null ) ; testK ( "v" ) ; f = c . putAsync ( "k" , "v2" ) ; testFuture ( f , "v" ) ; testK ( "v2" ) ; assertEquals ( "v2" , c . get ( "k" ) ) ; }
public boolean isReady ( TaskActionClient taskActionClient ) throws Exception { return true ; }
public static Map < String , EntryValue > convertBeanToEntryMap ( Object bean ) { Map < String , Object > buildAttributeValueMap = BeanUtilsExtended . buildObjectAttributeMap ( bean ) ; return Maps . transformEntries ( buildAttributeValueMap , new ObjectToEntryValueTransformer ( ) ) ; }  The only change made was adding the `public` access modifier to the method signature .
public RequestHeader ( Struct struct , short headerVersion ) { this ( new RequestHeaderData ( struct , headerVersion ) , headerVersion ) ; } private RequestHeader ( RequestHeaderData data , short headerVersion ) { this . data = data ; this . headerVersion = headerVersion ; }
public void accountSession ( String username , String password ) throws TmdbInvalidParametersException { if ( username == null || password == null ) { throw new TmdbInvalidParametersException ( 401 , "Username and Password may not be null" ) ; } this . username = username ; this . password = password ; hasAccountSession = true ; }
public void setProjectName ( String projectName ) { fProjectName = projectName ; if ( fLocationText . getText ( ) . equals ( EMPTY_STRING ) ) { fRemoteDirSelected = false ; } if ( ! fRemoteDirSelected ) { fLocationText . setText ( getDefaultPathDisplayString ( ) ) ; } }
public void testAddChildCycle3 ( ) { assertNotNull ( fFixture ) ; assertNotNull ( f42Fixture ) ; assertNotNull ( fHiFixture ) ; ( ( CalledFunction ) f42Fixture ) . addChild ( fHiFixture ) ; // The following assertion is unreachable and should be removed // assertEquals ( Collections . singletonList ( fHiFixture ) , f42Fixture . getChildren ( ) ) ; }
private char formatFieldFirstCharacterToFitDroolsCoreStandards ( final String fieldName ) { if ( fieldName . length ( ) > 1 && Character . isLowerCase ( fieldName . charAt ( 0 ) ) && Character . isUpperCase ( fieldName . charAt ( 1 ) ) ) { return fieldName . charAt ( 0 ) ; } else { return Character . toUpperCase ( fieldName . charAt ( 0 ) ) ; } }  As per the review , the condition should start with `fieldName . length ( ) > 1` instead of `fieldName . length ( ) > 2` . Also , the generated code should have the same rules for fields `aField` and `aF` .
public void start ( ) { for ( final Class < ? > stepDefinitionType : cachedStepsInstances . keySet ( ) ) { cachedStepsInstances . put ( stepDefinitionType , createStepsInstance ( stepDefinitionType ) ) ; } }
private WorkingSetDescriptor getSelectedWorkingSet ( ) { IStructuredSelection selection = typesListViewer . getStructuredSelection ( ) ; return ( WorkingSetDescriptor ) selection . getFirstElement ( ) ; }
public void evaluate ( ) throws Throwable { if ( previous == null ) { throw new NullPointerException ( "previous cannot be null" ) ; } previous . evaluate ( ) ; for ( FrameworkMethod before : befores ) { before . invokeExplosively ( target ) ; } next . evaluate ( ) ; }
public Response add ( OpenStackVolumeProvider provider ) { validateParameters ( provider , "name" ) ; StoragePool storagePool = provider . isSetDataCenter ( ) ? getStoragePool ( provider . getDataCenter ( ) ) : null ; provider . setDataCenter ( DataCenterMapper . map ( storagePool , null ) ) ; return performCreate ( VdcActionType . AddProvider , new ProviderParameters ( map ( provider ) ) , new QueryIdResolver < Guid > ( VdcQueryType . GetProviderById , IdQueryParameters . class ) ) ; }
< START > private void doStoreUsers ( ) { try { usersFileManager . store ( new UsersDto ( new HashSet < > ( userMap . values ( ) ) ) ) ; } catch ( IOException e ) { throw new UndeclaredThrowableException ( e ) ; } } < END >
public void tearDown ( ) throws IOException , SQLException { try { globalScheduler . shutdown ( ) ; } catch ( Exception e ) { // handle exception } cleanup ( ) ; tearDownOnce ( ) ; }  The `tearDown ( ) ` method is used to clean up resources after a test has been run . The refactored code includes a try - catch block to handle any exceptions that may occur when shutting down the `globalScheduler` . The `cleanup ( ) ` and `tearDownOnce ( ) ` methods are called after the `globalScheduler` has been shut down .
private CloudMachineNamer getCloudMachineNamer ( ConfigBag config ) { String namerClass = config . get ( LocationConfigKeys . CLOUD_MACHINE_NAMER_CLASS ) ; if ( namerClass != null ) { try { return ( CloudMachineNamer ) getManagementContext ( ) . getCatalog ( ) . getRootClassLoader ( ) . loadClass ( namerClass ) . getDeclaredConstructor ( ConfigBag . class ) . newInstance ( config ) ; } catch ( Exception e ) { throw Exceptions . propagate ( e ) ; } } else { return new JcloudsMachineNamer ( config ) ; } }
/* * * Represents an illustrated select item . */ public IllustratedSelectItem ( Object value , String label , String image ) { super ( value , label ) ; this . image = image ; }
private boolean layerGroupContainmentCheckRequired ( ) { Request request = Dispatcher . REQUEST . get ( ) ; if ( request == null ) { return false ; } String service = request . getService ( ) ; return "WMS" . equalsIgnoreCase ( service ) || "gwc" . equalsIgnoreCase ( service ) ; }
public ResteasyUriInfo ( final String absoluteUri , final String contextPath , final InitData initData ) { initialize ( absoluteUri , contextPath , ( initData != null && InitData . canBeCached ( absoluteUri ) ) ? initData : null ) ; }
private void buildUnaryExpression ( UnaryExpressionTree tree ) { if ( tree . is ( Tree . Kind . PREFIX_DECREMENT , Tree . Kind . PREFIX_INCREMENT ) ) { build ( tree . expression ( ) ) ; } currentBlock . elements . add ( tree ) ; if ( tree . is ( Tree . Kind . POSTFIX_DECREMENT , Tree . Kind . POSTFIX_INCREMENT ) ) { build ( tree . expression ( ) ) ; } }
public Class < ? > getRealClass ( ) { return testNGMethod . getRealClass ( ) ; }
private KeyStore getSecretsStore ( ) { final File secretStoreFile = createStoreIfNeeded ( ) ; try { final KeyStore keyStore = KeyStore . getInstance ( SECRETS_STORE_KEYSTORE_TYPE ) ; try ( InputStream inputStream = Files . newInputStream ( secretStoreFile . toPath ( ) ) ) { keyStore . load ( inputStream , loadStorePassword ( ) ) ; } return keyStore ; } catch ( Exception e ) { Logger . warn ( this . getClass ( ) , "unable to load secrets store " + SECRETS_STORE_FILE + " : " + e ) ; throw new DotRuntimeException ( e ) ; } }
public AnonymousSpec anonymous ( ) { if ( this . anonymous == null ) { this . anonymous = new AnonymousSpec ( ) ; } return this . anonymous . authorities ( "ROLE_ANONYMOUS" ) ; }
public int getNumWaiters ( ) { return this . connectionPool . getNumWaiters ( ) ; }
private void store ( ) throws IOException { byte [ ] serialized = state . toCbor ( ) . serialize ( ) ; System . out . println ( "Writing " + serialized . length + " bytes to " + statePath ) ; Files . write ( statePath , serialized , StandardOpenOption . CREATE , StandardOpenOption . WRITE , StandardOpenOption . TRUNCATE_EXISTING , StandardOpenOption . SYNC ) ; }
private static void initFacets ( @CheckForNull Fingerprint fingerprint ) { if ( fingerprint == null ) { return ; } for ( FingerprintFacet facet : fingerprint . facets ) { facet . _setOwner ( fingerprint ) ; } }
public Map < FactoryContainer , Attributes > getEnabledContainers ( ) { Map < FactoryContainer , Attributes > map = new LinkedHashMap < > ( ) ; synchronized ( _path ) { for ( Map . Entry < FactoryContainer , Attributes > entry : getReversed ( _path . entrySet ( ) ) ) { Attributes attr = entry . getValue ( ) ; if ( attr . isEnabled ( ) ) { Attributes attrClone = new Attributes ( attr ) ; map . put ( entry . getKey ( ) , attrClone ) ; } } } return map ; }
private FileListCacheValue getFileList ( ) { FileListCacheValue fileList = ( FileListCacheValue ) cache . get ( fileListCacheKey ) ; if ( fileList == null ) { fileList = new FileListCacheValue ( ) ; FileListCacheValue prev = ( FileListCacheValue ) cache . putIfAbsent ( fileListCacheKey , fileList ) ; if ( prev != null ) { fileList = prev ; } } if ( trace ) log . trace ( "Refreshed file listing view" ) ; return fileList ; }
public long size ( ) { build ( ) ; long size = body . length ( ) ; if ( partBoundary != null ) { size += partBoundary . length ; } if ( partHeader != null ) { size += partHeader . length ; } return size ; }  Explanation : The refactored code checks if `partBoundary` and `partHeader` are not null before adding their lengths to the `size` variable . This ensures that the code does not throw a `NullPointerException` when one of these instances returns ` - 1` because they don't know their length .
public boolean canStreamToNextPipe ( ) { boolean canStream = super . canStreamToNextPipe ( ) ; if ( canStream && ! isCollectResults ( ) ) { return true ; } else { return false ; } }
public FoundViewHolder getFoundViewHolder ( JFieldRef idRef , AbstractJClass viewClass ) { String idRefString = idRef . name ( ) ; FoundViewHolder foundViewHolder = ( FoundViewHolder ) foundHolders . get ( idRefString ) ; if ( foundViewHolder == null ) { foundViewHolder = createFoundViewAndIfNotNullBlock ( idRef , viewClass ) ; foundHolders . put ( idRefString , foundViewHolder ) ; } return foundViewHolder ; }  Note : The review does not provide any information on where to handle the code . It only points out that there are no comments in the code .
public void tearDown ( ) { queryRunner . close ( ) ; queryRunner = null ; }
private CommitConfig ( Config rc ) throws ConfigInvalidException { commitTemplatePath = rc . getString ( ConfigConstants . CONFIG_COMMIT_SECTION , null , ConfigConstants . CONFIG_KEY_COMMIT_TEMPLATE ) ; String i18nCommitEncoding = rc . getString ( ConfigConstants . CONFIG_SECTION_I18N , null , ConfigConstants . CONFIG_KEY_COMMIT_ENCODING ) ; if ( i18nCommitEncoding != null ) { try { commitMessageEncoding = Charset . forName ( i18nCommitEncoding ) ; } catch ( UnsupportedCharsetException e ) { throw new ConfigInvalidException ( "Invalid commit encoding : " + i18nCommitEncoding , e ) ; } } }
The Buggy Code is missing a catch block for the MalformedInputException . This exception can be thrown by the Inflater class and should be handled appropriately .  public int decompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset , int maxOutputLength ) throws MalformedInputException { try { Inflater inflater = new Inflater ( true ) ; inflater . setInput ( input , inputOffset , inputLength ) ; int resultLength = inflater . inflate ( output , outputOffset , maxOutputLength ) ; inflater . end ( ) ; return resultLength ; } catch ( DataFormatException e ) { throw new RuntimeException ( e ) ; } catch ( MalformedInputException e ) { throw e ; } }
public ImmutableList < OutputLine > getLog ( ) { return ImmutableList . copyOf ( this . log ) ; }
protected void doInit ( ) { super . doInit ( ) ; if ( ! this . evaluationContextSet ) { this . evaluationContext = ExpressionUtils . createStandardEvaluationContext ( getBeanFactory ( ) ) ; } Assert . state ( ! this . closeStreamAfterSend || this . isSingleUse , "Single use connection needed with closeStreamAfterSend" ) ; }
public ExtensionElementsConverter ( XStream xStream , List < DMNExtensionRegister > extensionRegisters ) { super ( xStream ) ; this . extensionRegisters = new ArrayList < > ( ) ; if ( extensionRegisters != null ) { this . extensionRegisters . addAll ( extensionRegisters ) ; } }
public void executeBatch ( OperationsQueue operationsQueue ) { try { if ( GridDialects . hasFacet ( getGridDialect ( ) , BatchableGridDialect . class ) || GridDialects . hasFacet ( getGridDialect ( ) , GroupingByEntityDialect . class ) ) { log . tracef ( "Executing batch" ) ; super . executeBatch ( operationsQueue ) ; } } catch ( TupleAlreadyExistsException taee ) { // TODO : Ideally , we should log the entity name + id here ; For now we trust the datastore to provide this // information via the original exception ; It'd require a fair bit of changes to obtain the entity name here // ( we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here ) throw log . mustNotInsertSameEntityTwice ( taee . getMessage ( ) , taee ) ; } }
public int hashCode ( ) { return ( ( startCommit . hashCode ( ) ^ numbers . length ) * 31 ) + getNumber ( ) ; }
private void prepareAuthForBrokerCall ( ) throws NoSuchAlgorithmException { try { AuthenticationSettings . INSTANCE . setUseBroker ( true ) ; } catch ( NoSuchAlgorithmException e ) { // handle the exception here } }
public boolean isWrapperFor ( Class < ? > iface ) { if ( gridCoverage instanceof Wrapper ) { if ( ( ( Wrapper ) gridCoverage ) . isWrapperFor ( iface ) ) { return true ; } } if ( iface . isInstance ( gridCoverage ) ) { return true ; } return false ; }
DataSegment uploadDataSegment ( DataSegment segment , final int binaryVersion , final long size , final File compressedSegmentData , final String azurePath ) throws StorageException , IOException , URISyntaxException { azureStorage . uploadBlob ( compressedSegmentData , config . getContainer ( ) , azurePath ) ; final DataSegment outSegment = segment . withSize ( size ) . withLoadSpec ( this . makeLoadSpec ( new URI ( azurePath ) ) ) . withBinaryVersion ( binaryVersion ) ; log . debug ( "Deleting file [ % s ] " , compressedSegmentData ) ; compressedSegmentData . delete ( ) ; return outSegment ; }
public EEFButtonLifecycleManager ( EEFButtonDescription description , IVariableManager variableManager , IInterpreter interpreter , TransactionalEditingDomain editingDomain ) { super ( description , variableManager , interpreter , editingDomain ) ; this . description = description ; }
private static boolean isProbablyLog4jFormatterLogger ( MethodInvocationTree mit , String formatString ) { return mit . symbol ( ) . owner ( ) . type ( ) . is ( ORG_APACHE_LOGGING_LOG4J_LOGGER ) && ! formatString . contains ( " { } " ) && formatString . contains ( " % " ) ; }
void setMarker ( TextMarker marker , int length ) { this . marker = marker ; numSkipLines = length ; if ( checkAndUpdateArrows ( ) ) { upArrow . setHTML ( PatchUtil . expandBefore ( NUM_ROWS_TO_EXPAND ) ) ; downArrow . setHTML ( PatchUtil . expandAfter ( NUM_ROWS_TO_EXPAND ) ) ; } skipNum . setText ( PatchUtil . patchSkipRegion ( Integer . toString ( length ) ) ) ; }
public ExtendedEmailPublisherContext ( ExtendedEmailPublisher publisher , AbstractBuild < ? , ? > build , Launcher launcher , BuildListener listener ) { this . publisher = publisher ; this . run = build ; this . workspace = build . getWorkspace ( ) ; this . launcher = launcher ; this . listener = listener ; }
public void testWrongFormatNumber ( ) throws Exception { NumberCellEditor editor = new NumberCellEditor ( shell , Integer . class ) ; // empty string editor . setValue ( " " ) ; editor . isValueValid ( ) ; assertNull ( editor . getValue ( ) ) ; // not parsable number editor . setValue ( "aa" ) ; editor . isValueValid ( ) ; assertNull ( editor . getValue ( ) ) ; }
public void onReloadPlugin ( Plugin oldPlugin , Plugin newPlugin ) { if ( hasAvatarProvider ( newPlugin ) ) { avatarSupport = true ; } else if ( avatarSupport && hasAvatarProvider ( oldPlugin ) ) { avatarSupport = false ; } }
public Class < ? > getRealClass ( ) { return clazz ; }
private String read ( String resourcePath ) throws IOException { try ( InputStream is = getClass ( ) . getResourceAsStream ( resourcePath ) ) { return Util . read ( is ) ; } }
public static String getModelFileWithGAV ( ReleaseId releaseId ) { return Paths . get ( MODEL_FILE_DIRECTORY , releaseId . getGroupId ( ) , releaseId . getArtifactId ( ) , MODEL_FILE_NAME ) . toString ( ) ; }
void removeConnection ( String connectionId ) { if ( availableConnections . contains ( connectionId ) ) { availableConnections . remove ( connectionId ) ; availableCount -- ; } poolCount -- ; }
private Map < Long , ISegmentAspect > getAspectsFromColumnsId ( List < Long > desiredColumns ) { if ( desiredColumns . isEmpty ( ) ) { return fAspectMap ; } Map < Long , ISegmentAspect > aspects = new LinkedHashMap < > ( ) ; for ( Long columnsId : desiredColumns ) { ISegmentAspect segmentAspect = fAspectMap . get ( columnsId ) ; if ( segmentAspect != null ) { aspects . put ( columnsId , segmentAspect ) ; } } return aspects ; }
static boolean isValidMining ( ICodeMining mining ) { return mining != null && mining . getLabel ( ) != null && ! mining . getLabel ( ) . isEmpty ( ) ; }  The `Objects . nonNull` method is not necessary here since it does the same thing as ` != null` . Therefore , we can simplify the code by using `mining != null` instead .
public void addInput ( Page page ) { verify ( probe == null ) ; probe = page ; probePosition = 0 ; joinAddresses = null ; joinAddressIndex = - 1 ; }
public DescriptorImpl ( ) { super ( ThrottleJobProperty . class ) ; synchronized ( propertiesByCategoryLock ) { load ( ) ; propertiesByCategory = new HashMap < String , Map < ThrottleJobProperty , Void > > ( ) ; // Renamed field save ( ) ; } }
public String toString ( ) { String domainName = staticData . getName ( ) == null ? "null" : staticData . getName ( ) ; String domainId = staticData . getId ( ) == null ? "null" : staticData . getId ( ) . toString ( ) ; return "StorageDomain [ " + domainName + " , " + domainId + " ] " ; }
java Predicate < Entry < Key , Value > > getScanPredicate ( ) { final Range range = getRange ( ) ; return input - > range == null || range . contains ( input . getKey ( ) ) ; }
java public AlluxioHiveMetastore ( TableMasterClient client ) { this . client = Objects . requireNonNull ( client , "client is null" ) ; }
private void addWorkPackageCriteria ( ) { if ( isWorkPackageSpecified ( ) ) { ArtifactId workPackArt = atsApi . getQueryService ( ) . getArtifactOrSentinel ( workPackageId ) ; if ( workPackArt . isValid ( ) && isColorTeamMatch ( workPackArt ) ) { queryAnd ( AtsAttributeTypes . WorkPackageReference , workPackArt . getIdString ( ) ) ; } } }
private void sendToSocket ( Socket socket , String cmdString ) throws IOException { byte [ ] sendBytes = ( "A" + cmdString . trim ( ) . replaceAll ( "\\s + " , " " ) + "\n" ) . getBytes ( ) ; socket . getInputStream ( ) . skip ( socket . getInputStream ( ) . available ( ) ) ; socket . getOutputStream ( ) . write ( sendBytes ) ; socket . getOutputStream ( ) . flush ( ) ; AstericsErrorHandling . instance . reportInfo ( this , "IRTrans sent data : " + cmdString ) ; }
The `hashCode ( ) ` method is used to generate a unique integer value for an object . In the given buggy code , the `hashCode ( ) ` method is only returning the hash code of the object's class . This is not a unique value for each object and can cause collisions when using hash - based data structures like HashMap . To fix this , we can use a combination of the object's fields to generate a unique hash code . Here's an example of how we can refactor the code :  @Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( field1 == null ) ? 0 : field1 . hashCode ( ) ) ; result = prime * result + ( ( field2 == null ) ? 0 : field2 . hashCode ( ) ) ; // add more fields as needed return result ; }  In this code , we are using the `prime` number 31 as a multiplier and adding the hash codes of each field to the `result` variable . If a field is null , we use 0 as its hash code . This ensures that each object will have a unique hash code based on its fields .
private void reset ( ) { setId ( NO_ID ) ; next = NO_ID ; }
public String getActualDowntime ( ) { return ( actualDowntime == null ) ? " ( N / A ) " : actualDowntime + "ms" ; }
String resolveTemplatePath ( final Context context , final Writer writer , final RenderParams params , final String argument ) { if ( argument . contains ( " / " ) ) { // code to handle when argument contains " / " } else { return ( params . live ) ? " / live / " + argument + " . " + EXTENSION : " / working / " + argument + " . " + EXTENSION ; } return null ; // added missing return statement }
public DispoConfig findDispoConfig ( DispoProgram program ) { ArtifactReadable config = getQuery ( ) . fromBranch ( program . getUuid ( ) ) . getResults ( ) . getOneOrNull ( ) ; if ( config == null ) { DispoUtil . getDefaultConfig ( ) ; } return DispoUtil . configArtToConfigData ( new DispoConfigArtifact ( config ) ) ; }
public boolean hasMatchingOpSig ( String name , JavaOperationSigMask mask ) { for ( Entry < JavaOperationSignature , Set < String > > entry : operations . entrySet ( ) ) { if ( mask . covers ( entry . getKey ( ) ) ) { if ( entry . getValue ( ) . contains ( name ) ) { return true ; } } } return false ; }
public IonSqlQueryBuilder ( TypeManager typeManager ) { this . typeManager = Objects . requireNonNull ( typeManager , "typeManager is null" ) ; }
protected OperationController getOperationController ( ) { // Choose the operation controller with the least load OperationController leastLoadedController = ocList . get ( 0 ) ; for ( OperationController oc : ocList ) { if ( oc . getLoad ( ) < leastLoadedController . getLoad ( ) ) { leastLoadedController = oc ; } } return leastLoadedController ; }
public List < JDK > getJDKs ( ) { if ( jdks == null ) { jdks = new ArrayList < JDK > ( ) ; } return jdks ; } // Add the following method to set jdks to an empty list during deserialization private Object readResolve ( ) { if ( jdks == null ) { jdks = new ArrayList < JDK > ( ) ; } return this ; }
public boolean addAll ( int index , Collection < ? extends T > c ) { Collection < T > uniqueValuesToAdd = getUniqueValues ( c ) ; if ( uniqueValuesToAdd . isEmpty ( ) ) { return false ; } try { return super . addAll ( index , uniqueValuesToAdd ) ; } catch ( IndexOutOfBoundsException ioobException ) { comparingSet . removeAll ( uniqueValuesToAdd ) ; throw ioobException ; } }
public Context getContext ( ) { if ( sdkName == null ) { sdkName = this . getClass ( ) . getPackage ( ) . getName ( ) ; } return new Context ( "Sdk - Name" , sdkName ) . addData ( "Sdk - Version" , BuildConfig . SDK_VERSION ) ; }  Explanation : Instead of hardcoding the SDK version , we can use a variable from the BuildConfig file which is automatically generated during the build process and contains the version information . This makes it easier to update the version in the future without having to modify the code .
< START > protected void setSelectedDevices ( List < StorageDevice > selectedDevices ) { getStorageDevices ( ) . setSelectedItems ( selectedDevices ) ; } < END >
private JsonObject toJson ( Timer timer , TimeUnit rateUnit , TimeUnit durationUnit ) { Snapshot snapshot = timer . getSnapshot ( ) ; JsonObject json = new JsonObject ( ) ; populateMetered ( json , timer , rateUnit ) ; double factor = 1 . 0 / durationUnit . toNanos ( 1 ) ; populateSnapshot ( json , snapshot , factor ) ; String duration = durationUnit . toString ( ) . toLowerCase ( ) ; json . putString ( "durationRate" , duration ) ; return json ; }
protected void delete ( LogEntry delegate , String reason , RequestContext context ) throws ResourceDoesNotSupportOperationException { throw new ResourceDoesNotSupportOperationException ( "delete not supported" ) ; }
void setConsumerBatchEnabled ( boolean consumerBatchEnabled ) { this . consumerBatchEnabled = consumerBatchEnabled ; }  Explanation : Since there is no indication that the `setConsumerBatchEnabled` method needs to be accessed outside of the class , the `protected` access modifier is not necessary . Therefore , it can be removed . Additionally , there is no indication that this method is related to a `@RabbitListener` annotation , so the second part of the review comment is not applicable .
public int getLevel ( ) { return data . optInt ( "level" ) ; }
private void setPagesRecycler ( OnThisDayCard card ) { if ( card . pages ( ) != null ) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter ( card . pages ( ) , card . wiki ( ) , true , ( Activity ) getContext ( ) ) ; recyclerAdapter . setCallback ( new ItemCallback ( ) ) ; pagesRecycler . setAdapter ( recyclerAdapter ) ; } else { pagesRecycler . setVisibility ( GONE ) ; } }
public String getExtendedLabelForVSM ( String providedShapeURI ) { IConfigurationElement element = getConfigurationElement ( providedShapeURI ) ; if ( element != null ) { return getExtendedLabelsForVSM ( element ) ; } return "Unknown URI" ; // $NON - NLS - 1$ } private IConfigurationElement getConfigurationElement ( String providedShapeURI ) { for ( IConfigurationElement configurationElement : extensions ) { String identifier = ( ( ExtensionHandle ) configurationElement . getParent ( ) ) . getSimpleIdentifier ( ) ; if ( identifier != null && identifier . equals ( providedShapeURI ) ) { return configurationElement ; } } return null ; } private String getExtendedLabelsForVSM ( IConfigurationElement configurationElement ) { return configurationElement . getAttribute ( LABEL_ATTRIBUTE ) + " - " + configurationElement . getNamespaceIdentifier ( ) ; // $NON - NLS - 1$ }
public void stopServer ( ) { if ( server instanceof GrizzlyServer ) { ( ( GrizzlyServer ) server ) . cleanIdleConnections ( true ) ; } server . stop ( ) ; }
protected class DestroyProxyMessageTask implements Supplier < Operation > { @Override public Operation get ( ) { return new DistributedObjectDestroyOperation ( parameters . serviceName , parameters . name ) ; } } protected Supplier < Operation > createOperationSupplier ( ) { return new DestroyProxyMessageTask ( ) ; }
public < C extends CtTypedElement > C setType ( CtTypeReference < T > type ) { if ( type != null ) { type . setParent ( this ) ; } if ( getExecutable ( ) != null ) { getExecutable ( ) . setType ( type ) ; } if ( type != null ) { getFactory ( ) . getEnvironment ( ) . getModelChangeListener ( ) . onObjectUpdate ( this , TYPE , type , getExecutable ( ) . getType ( ) ) ; } return ( C ) this ; }

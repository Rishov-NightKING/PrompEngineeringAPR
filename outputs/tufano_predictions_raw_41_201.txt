public boolean isExtensionEnabled ( ) { if ( enablement ! = null ) { try { return EnablementTester . evaluate ( enablement ) ; } catch ( CoreException e ) { // TODO : handle exception } } return true ; }
public ProviderNotificationManager createProviderNotificationManager ( final DiagramEventBroker diagramEventBroker , final EObject view , final NotificationListener notificationListener ) { ProviderNotificationManager manager = null ; if ( manager ! = null ) { return manager ; } manager = new ProviderNotificationManager ( diagramEventBroker , view , notificationListener ) { @Override protected void registerListeners ( ) { // TODO install listener on allocation ( Abstraction ) of the model . } } ; return manager ; }
private void syncFolder ( OCFile folder ) { long currentSyncTime = System . currentTimeMillis ( ) ; mSyncInProgress = true ; RemoteOperation synchFolderOp = new RefreshFolderOperation ( folder , currentSyncTime , false , false , false , getStorageManager ( ) , getAccount ( ) , getApplicationContext ( ) ) ; synchFolderOp . execute ( getAccount ( ) , this , null , null ) ; }
private static ProtobufMetadataManagerImpl getProtobufMetadataManager ( EmbeddedCacheManager cacheManager ) { if ( cacheManager == null ) { throw new IllegalArgumentException ( "cacheManager cannot be null" ) ; } ProtobufMetadataManagerImpl metadataManager = ( ProtobufMetadataManagerImpl ) cacheManager . getGlobalComponentRegistry ( ) . getComponent ( ProtobufMetadataManager . class ) ; if ( metadataManager == null ) { throw new IllegalStateException ( "ProtobufMetadataManager not initialised yet ! " ) ; } return metadataManager ; }
public void onSessionKeyUpdate ( SessionKey sessionKey ) { synchronized ( DistributedHerder . this ) { DistributedHerder . this . sessionKey = sessionKey . key ( ) ; if ( isLeader ( ) && keyRotationIntervalMs > 0 ) { DistributedHerder . this . keyExpiration = sessionKey . creationTimestamp ( ) + keyRotationIntervalMs ; } } log . info ( "Session key updated" ) ; }
public String getAuthorizationUrl ( OAuthConfig config ) { // User must provide these 5 elements to the service builder String url = String . format ( AUTHORIZE_URL , OAuthEncoder . encode ( config . getApiKey ( ) ) , OAuthEncoder . encode ( config . getCallback ( ) ) , OAuthEncoder . encode ( config . getScope ( ) ) , OAuthEncoder . encode ( config . getState ( ) ) ) ; return url ; }
public Object getParameter ( String name ) { final HostThread currentHostThread = fCurrentHostThread ; if ( currentHostThread == null ) { return null ; } if ( name . equals ( CriticalPathModule . PARAM_WORKER ) ) { IAnalysisModule mod = getModule ( ) ; if ( ( mod ! = null ) && ( mod instanceof CriticalPathModule ) ) { LttngWorker worker = new LttngWorker ( currentHostThread , "" , 0 ) ; return worker ; } } return null ; }
public static ExceptionThrowingSubTest expectThrowable ( Runnable runnable ) { return expectException ( runnable . toString ( ) , runnable ) ; }
protected CONNECTCXFClient ( ServicePortDescriptor < T > portDescriptor , String url , AssertionType assertion , ServicePortBuilder < T > portBuilder ) { serviceEndpoint = super . configureBasePort ( portBuilder . createPort ( ) , url , assertion ! = null ? assertion . getTransactionTimeout ( ) : null ) ; }
public < V > Setting < V > get ( SimpleUri id , Class < V > valueType ) { Setting < V > setting = settings . get ( id ) ; Class <? > settingValueClass = setting . getValueClass ( ) ; if ( ! settingValueClass . equals ( valueType ) ) { throw new ClassCastException ( "Expected a Setting of type " + valueType . getName ( ) + " for setting " + id + " , found a Setting of type " + settingValueClass . getName ( ) ) ; } return setting ; }
public String getCustomField ( String fieldName ) { if ( customFields . isEmpty ( ) ) { return null ; } for ( CustomField f : customFields ) { if ( f . getName ( ) . equals ( fieldName ) ) { return f . getValue ( ) ; } } return null ; }
private CommandCall duplicateCommandForDifferentElement ( CommandCall commandCall , Element element ) { String expression = commandCall . getExpression ( ) ; if ( commandCall . getCommand ( ) . isExampleCommand ( ) && expression . equals ( "" ) ) { expression = element . getText ( ) ; } return new CommandCall ( null , commandCall . getCommand ( ) , element , expression , commandCall . getResource ( ) ) ; }
public M fromBytes ( byte [ ] messageBuffer ) { if ( deserializer == null ) deserializer = new ThriftBinaryDeserializer ( ) ; try { M message = typeRef . safeNewInstance ( ) ; deserializer . deserialize ( message , messageBuffer ) ; return message ; } catch ( Throwable e ) { logWarning ( "failed to deserialize" , e ) ; return null ; } }
public void showPage ( Control page ) { if ( page . isDisposed ( ) || page . getParent ( ) ! = this ) { return ; } currentPage = page ; page . setVisible ( true ) ; layout ( true ) ; Control [ ] children = getChildren ( ) ; for ( Control child : children ) { if ( child ! = page && ! child . isDisposed ( ) ) { child . setVisible ( false ) ; } } }
public void warn ( String message , Object . . . objects ) { LOG . warn ( message , objects ) ; }
public String getLinkAt ( int offset ) { for ( int i = 0 ; i < linkRanges . size ( ) ; i ++ ) { if ( linkRanges . get ( i ) . isOffsetInRange ( offset ) ) { return hrefs . get ( i ) ; } } return "" ; }
public String toString ( ) { return "FileListCacheValue { fileNames = " + getFileNames ( ) + " } " ; }
protected Control createControl ( Composite parent ) { CTConfiguration config = new CTConfiguration ( parent , CTConfiguration . STYLE_GRID ) ; config . setHorizontalAlignment ( SWT . CENTER ) ; config . setCellSelectionEnabled ( false ) ; config . setColumnSelectionEnabled ( false ) ; config . setRowSelectionEnabled ( false ) ; config . setColumnHeaderLayout ( CTConfiguration . COLUMN_HEADER_LAYOUT_FILL_EQUAL ) ; config . setRowHeaderLayout ( CTConfiguration . ROW_HEADER_LAYOUT_DEFAULT ) ; this . table = new ComponentTable ( parent , SWT . FULL_SELECTION , config ) ; return this . table . getControl ( ) ; }
public boolean isEnabled ( ) { return true ; }
void verifyMetadata ( MessageMetadata metadata ) throws WrongMessageTypeException { if ( metadata . getMessageMetadataType ( ) ! = MessageType . LOG_ENTRY_MESSAGE || metadata . getSnapshotTimestamp ( ) ! = srcGlobalSnapshot ) { log . error ( "Wrong message metadata { } , expecting type { } snapshot { } " , metadata , MessageType . LOG_ENTRY_MESSAGE , srcGlobalSnapshot ) ; throw new WrongMessageTypeException ( "Wrong type of message" ) ; } }
public void setVmBackup ( VmBackup value ) { this . vmBackup = value ; }
public void setPrice1 ( int price3 ) { if ( price3 < 0 || price3 > 10000 ) { throw new IllegalArgumentException ( "Invalid price : " + price3 ) ; } assert price3 > 1000 : "Price should be greater than 1000" ; }
public String evaluate ( TransactionContext txnCtx , Input < Object >[ ] args ) { assert args . length == 2 : "repeat takes exactly two arguments" ; String text = args [ 0 ] . value ( ) . toString ( ) ; if ( text == null || args [ 1 ] . value ( ) == null ) { return null ; } int repetitions = Integer . parseInt ( args [ 1 ] . value ( ) . toString ( ) ) ; if ( repetitions <= 0 ) { return "" ; } else { return text . repeat ( repetitions ) ; } }  The refactored code checks for `null` values in both arguments and converts the second argument to an integer before using it .
private void setActionBarNotificationBarColor ( MaterialColor color ) { getSupportActionBar ( ) . setBackgroundDrawable ( new ColorDrawable ( color . toActionBarColor ( this ) ) ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { getWindow ( ) . setStatusBarColor ( color . toStatusBarColor ( this ) ) ; } }
public static ProjectBuildType getProjectType ( IProject project ) { if ( isAutoTools ( project ) ) { return ProjectBuildType . AUTO_TOOLS ; } else { IConfiguration defaultConfiguration = helper_getActiveConfiguration ( project ) ; IBuilder builder = defaultConfiguration . getBuilder ( ) ; Boolean projIsManaged = builder . isManagedBuildOn ( ) ; if ( projIsManaged ) { return ProjectBuildType . MANAGED_MAKEFILE ; } else { return ProjectBuildType . OTHER ; } } }
protected long download ( T object , File outFile ) throws IOException { openObjectFunction . open ( object , outFile ) ; return outFile . length ( ) ; }
private Collection < VCastResult > getResultFiles ( VCastDataStore dataStore ) throws OseeCoreException { Collection < VCastResult > results = null ; try { results = dataStore . getAllResults ( ) ; } catch ( OseeCoreException ex ) { throw new OseeCoreException ( "SQL error while reading results" , ex ) ; } return results ; }  In the refactored code , the catch block throws a new `OseeCoreException` with a custom message and the original exception as its cause . This provides more information about the error and preserves the original exception for debugging purposes .
public PinotQueryGeneratorContext visitFilter ( FilterNode node , PinotQueryGeneratorContext context ) { context = node . getSource ( ) . accept ( this , context ) ; Objects . requireNonNull ( context , "context is null" ) ; LinkedHashMap < VariableReferenceExpression , Selection > selections = context . getSelections ( ) ; String filter = node . getPredicate ( ) . accept ( pinotFilterExpressionConverter , ( var ) -> selections . get ( var ) ) . getDefinition ( ) ; return context . withFilter ( filter ) . withOutputColumns ( node . getOutputVariables ( ) ) ; }
/* * * Initializes a new instance of the Space class with the specified enumerated value . * @param enumeratedValue the enumerated value to be set */ private Space ( String enumeratedValue ) { this . enumeratedValue = enumeratedValue ; }
public Guid getStorageDomainIdForPoolByType ( Guid pool , StorageDomainType type ) { Guid returnValue = Guid . Empty ; List < storage_domains > domains = getAllForStoragePool ( pool ) ; for ( storage_domains domain : domains ) { if ( domain . getstorage_domain_type ( ) == type ) { returnValue = domain . getId ( ) ; break ; } } return returnValue ; }
public void lock ( T id ) throws InterruptedException { threadsLocked . inc ( ) ; try { idsLocked . update ( 1 ) ; lockInternal ( id ) ; } finally { threadsLocked . dec ( ) ; } }
public RunLengthEncodedBlock ( Block value , int positionCount ) { Objects . requireNonNull ( value , "value is null" ) ; if ( value . getPositionCount ( ) ! = 1 ) { throw new IllegalArgumentException ( String . format ( "Expected value to contain a single position but has % s positions" , value . getPositionCount ( ) ) ) ; } if ( value instanceof RunLengthEncodedBlock ) { throw new IllegalArgumentException ( String . format ( "Value can not be an instance of a % s" , getClass ( ) . getName ( ) ) ) ; } if ( positionCount < 0 ) { throw new IllegalArgumentException ( "positionCount is negative" ) ; } this . value = value ; this . positionCount = positionCount ; }
public Message . Request request ( ) { Message . Request request = callback . request ( ) ; if ( retryConsistencyLevel ! = null && retryConsistencyLevel ! = request . consistency ( ) ) { return request . copy ( retryConsistencyLevel ) ; } else { return request ; } }
public void init ( FilterConfig filterConfig ) throws ServletException { directoryAllowed = Context . getConfig ( ) . getBoolean ( "media . directoryAllowed" ) ; }
public ExtentBufferedCompositePattern ( Extent extent , Pattern . . . patterns ) { super ( extent ) ; checkArgument ( patterns . length > 0 , "patterns cannot be empty" ) ; this . patterns = patterns ; }
public boolean isValid ( Object [ ] value , ConstraintValidatorContext context ) { if ( value . length ! = 3 ) { throw new IllegalArgumentException ( "Unexpected method signature" ) ; } // one or both limits are unbounded => always consistent if ( value [ 1 ] == null || value [ 2 ] == null ) { return true ; } return ( ( Date ) value [ 1 ] ) . before ( ( Date ) value [ 2 ] ) ; }
private static boolean monoNativeFailure ( Either < Utils . CommandResult > result ) { if ( result == null || ! result . isSuccess ( ) ) { return true ; } else { Utils . CommandResult commandResult = result . get ( ) ; return monoNativeFailure ( commandResult . output ) || monoNativeFailure ( commandResult . error ) ; } }
private void removeAppBar ( ) { DWORD dwABM = new DWORD ( ) ; APPBARDATA ABData = new APPBARDATA . ByReference ( ) ; ABData . cbSize . setValue ( ABData . size ( ) ) ; dwABM . setValue ( ShellAPI . ABM_REMOVE ) ; UINT_PTR result = Shell32 . INSTANCE . SHAppBarMessage ( dwABM , ABData ) ; assertNotNull ( result ) ; }
public boolean couldMatch ( ScriptPath path ) { return path . eventLower . startsWith ( "mythicmob" ) && path . eventArgLowerAt ( 2 ) . equals ( "spawns" ) ; }
void init ( ) { controllerHomeDir = resolveControllerHomeDir ( ) ; initAccessOfDirectories ( ) ; initAccessOfHosts ( ) ; }
protected Sequence getServicesSequence ( DsfSession session , ILaunch launch , IProgressMonitor rm ) { return new ServicesLaunchSequence ( session , ( GdbLaunch ) launch , rm ) ; }
public AdvanceResult advanceNursery ( final AdvancingNursery advanceInfo , final Workbook workbook ) throws RuleException , FieldbookException { return this . namingConventionService . advanceNursery ( advanceInfo , workbook ) ; }
public org . ovirt . engine . api . model . Cluster update ( org . ovirt . engine . api . model . Cluster incoming ) { MacPool macPool = incoming . getMacPool ( ) ; macPool . setId ( MacPoolIdByIdOrName . get ( macPool . getId ( ) , macPool . getName ( ) , this ) ) ; return performUpdate ( incoming , new QueryIdResolver <> ( VdcQueryType . GetClusterById , IdQueryParameters . class ) , VdcActionType . UpdateCluster , new UpdateParametersProvider ( ) ) ; } // Refactored code public org . ovirt . engine . api . model . Cluster update ( org . ovirt . engine . api . model . Cluster incoming ) { MacPool macPool = incoming . getMacPool ( ) ; macPool . setId ( MacPoolIdByIdOrName . get ( macPool . getId ( ) , macPool . getName ( ) , this ) ) ; return performUpdate ( incoming , new QueryIdResolver <> ( VdcQueryType . GetClusterById , IdQueryParameters . class ) , VdcActionType . UpdateCluster , new UpdateParametersProvider ( ) ) ; } // Non - static version public org . ovirt . engine
protected @NonNull TmfViewer createLeftChildViewer ( @Nullable Composite parent ) { String analysisId = NonNullUtils . nullToEmptyString ( getViewSite ( ) . getSecondaryId ( ) ) ; IAnalysisModule module = TmfTraceUtils . getAnalysisModuleOfClass ( getTrace ( ) , IAnalysisModule . class , analysisId ) ; if ( ! ( module instanceof ISegmentStoreProvider ) ) { Activator . getDefault ( ) . getLog ( ) . log ( new Status ( IStatus . ERROR , Activator . PLUGIN_ID , "Invalid analysis ID" ) ) ; return null ; } return new AbstractSegmentStoreScatterChartTreeViewer ( Objects . requireNonNull ( parent ) ) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider ( ITmfTrace trace ) { return ( ISegmentStoreProvider ) module ; } } ; }
public void testReservedSkippableBeforeStreamIdentifier ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { - 0x7f , 0x06 , 0x00 , 0x00 , 's' , 'n' , 'e' , 't' , 't' , 'y' } ) ; channel . writeInbound ( in ) ; }
public void set ( String name , Property property ) throws PropertyNotFoundException { Field field = getType ( ) . getField ( name ) ; if ( field == null ) { Property removedProperty = computeRemovedProperty ( name ) ; if ( removedProperty ! = null ) { removedProperty . set ( name , property ) ; } return ; } children . put ( field . getName ( ) . getPrefixedName ( ) , property ) ; setIsModified ( ) ; }
public int andCardinality ( Container x ) { if ( this . getCardinality ( ) == 0 || x . getCardinality ( ) == 0 ) { return 0 ; } else { if ( x instanceof ArrayContainer ) { return andCardinality ( ( ArrayContainer ) x ) ; } else if ( x instanceof BitmapContainer ) { return andCardinality ( ( BitmapContainer ) x ) ; } else { return andCardinality ( ( RunContainer ) x ) ; } } }
public Set < WorkerNetAddress > getWorkerAddresses ( ) throws UnavailableException { if ( mSafeModeManager . isInSafeMode ( ) ) { throw new UnavailableException ( ExceptionMessage . MASTER_IN_SAFEMODE . getMessage ( ) ) ; } Set < WorkerNetAddress > workerAddresses = new HashSet <> ( mWorkers . size ( ) ) ; for ( MasterWorkerInfo worker : mWorkers ) { workerAddresses . add ( worker . getWorkerAddress ( ) ) ; } return workerAddresses ; }
public void setUp ( ) { params . put ( "CallSid" , "CA1234567890ABCDE" ) ; params . put ( "Caller" , " + 14158675309" ) ; params . put ( "Digits" , "1234" ) ; params . put ( "From" , " + 14158675309" ) ; params . put ( "To" , " + 18005551212" ) ; String signature = "RSOYDt4T1cUTdK1PDd93 / VVr8B8 = " ; }
public @Nullable String getAttributeValue ( @Nullable String name ) { return name ; }
public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { for ( Object cookie : this . cookiesToClear ) { Cookie realCookie = null ; if ( cookie instanceof String ) { realCookie = new Cookie ( ( String ) cookie , null ) ; String cookiePath = request . getContextPath ( ) + " / " ; realCookie . setPath ( cookiePath ) ; realCookie . setMaxAge ( 0 ) ; } else if ( cookie instanceof Cookie ) { realCookie = ( Cookie ) cookie ; } response . addCookie ( realCookie ) ; } }
private MethodHandles . Lookup getMethodHandleLookup ( Class <? > endpointClass ) { return MethodHandles . publicLookup ( ) . in ( endpointClass ) ; }
public void channelOpen ( ChannelHandlerContext ctx , ChannelStateEvent e ) throws Exception { if ( maxConnections > 0 ) { if ( numConnections . incrementAndGet ( ) > maxConnections ) { numConnections . decrementAndGet ( ) ; ctx . getChannel ( ) . close ( ) ; log . info ( "Accepted connection above limit ( { } ) . Dropping . " , maxConnections ) ; return ; } } super . channelOpen ( ctx , e ) ; }
public Builder from ( int . . . nums ) { Arrays . sort ( nums ) ; this . matchers . add ( ( from , to , msg ) -> Arrays . binarySearch ( nums , from ) >= 0 ) ; return this ; }
public B channel ( Class <? extends C > channelClass ) { return channelFactory ( new ReflectiveChannelFactory < C >( ObjectUtil . checkNotNull ( channelClass , "channelClass" ) ) ) ; }
public void getActiveConditions_shouldGetActiveConditions ( ) { List < Condition > activeConditions = conditionService . getActiveConditions ( patientService . getPatient ( 2 ) ) ; Condition firstActiveCondition = activeConditions . get ( 0 ) ; Condition secondActiveCondition = activeConditions . get ( 1 ) ; Assert . assertTrue ( activeConditions . size ( ) == 2 ) ; Assert . assertEquals ( "2cc6880e - 2c46 - 11e4 - 9138 - a6c5e4d20fb7" , firstActiveCondition . getUuid ( ) ) ; Assert . assertEquals ( "2cc6880e - 2c46 - 15e4 - 9038 - a6c5e4d22fb7" , secondActiveCondition . getUuid ( ) ) ; }
public synchronized Inode <? > getInodeOrNull ( ) { if ( ! fullPathExists ( ) ) { return null ; } List < Inode <? >> inodeList = new ArrayList <> ( mLockList . getInodes ( ) ) ; return inodeList . get ( inodeList . size ( ) - 1 ) ; }  Explanation : The `newArrayList` method is not a standard Java method and is likely a custom method from a third - party library . To make the code more readable and maintainable , it is better to use the standard Java `ArrayList` class instead . The `ArrayList` constructor can take a collection as an argument , so we can pass in the result of `mLockList . getInodes ( ) ` directly .
private static < T > Set < T > findDuplicates ( Collection < T > list ) { Set < T > duplicates = new HashSet <> ( ) ; Set < T > uniques = new HashSet <> ( ) ; list . stream ( ) . forEach ( t -> { if ( ! uniques . add ( t ) ) { duplicates . add ( t ) ; } } ) ; return duplicates ; }
public boolean next ( ) throws IOException { for ( ; ; ) { LogQueueEntry t = queue . poll ( ) ; if ( t == null ) { return false ; } refName = t . lc . getRefName ( ) ; updateIndex = t . lc . getUpdateIndex ( ) ; entry = t . lc . getReflogEntry ( ) ; boolean include = includeDeletes || entry ! = null ; skipShadowed ( refName , updateIndex ) ; add ( t ) ; if ( include ) { return true ; } } }
protected void remove ( MessageGroup group ) { Object correlationKey = group . getGroupId ( ) ; if ( ForceReleaseMessageGroupProcessor . class . isInstance ( group . getProcessor ( ) ) ) { this . messageStore . removeMessageGroup ( correlationKey ) ; this . groupIds . remove ( correlationKey ) ; } }
public void sendOffsetsToTransaction ( Map < TopicPartition , OffsetAndMetadata > offsets , String consumerGroupId ) throws ProducerFencedException { ConsumerGroupMetadata cachedGroupMetadata = new ConsumerGroupMetadata ( consumerGroupId , JoinGroupRequest . UNKNOWN_GENERATION_ID , JoinGroupRequest . UNKNOWN_MEMBER_ID , Optional . empty ( ) ) ; sendOffsetsToTransactionInternal ( offsets , cachedGroupMetadata , false ) ; }
public boolean cancel ( final Exception rootReason ) { if ( transitionCancel ( rootReason ) ) { final Exception reason = new CancellationException ( rootReason ) ; try { traceFailure ( reason ) ; } catch ( Throwable ex ) { final String message = "Exception thrown in logging trace for failure ! " ; LOGGER . warn ( message , ex ) ; LOGGER . warn ( message , ex . getCause ( ) ) ; } getSettableDelegate ( ) . fail ( reason ) ; return true ; } return false ; }
private int allVersionsCombined ( ) { return formatIdentifier >> > SHIFT_FORMAT_IDENTIFIER | formatVersion >> > SHIFT_FORMAT_VERSION ; }
protected void writeJDBCStoreConnection ( XMLExtendedStreamWriter writer , SimpleConnectionFactoryConfiguration configuration ) throws XMLStreamException { writer . writeStartElement ( Element . SIMPLE_CONNECTION ) ; writeOptional ( writer , Attribute . CONNECTION_URL , configuration . connectionUrl ( ) ) ; writeOptional ( writer , Attribute . DRIVER_CLASS , configuration . driverClass ( ) ) ; writeOptional ( writer , Attribute . USERNAME , configuration . username ( ) ) ; writeOptional ( writer , Attribute . PASSWORD , configuration . password ( ) ) ; writeOptional ( writer , Attribute . CONNECTION_CONFIGURATION , configuration . connectionConfiguration ( ) ) ; // added line writer . writeEndElement ( ) ; }
private
private String getXMI_ID ( final EObject eobject ) { if ( eobject . eResource ( ) instanceof XMIResource ) { return ( ( XMIResource ) eobject . eResource ( ) ) . getID ( eobject ) ; } return null ; }
@Override public float getPressure ( ) { return 0 ; }
private boolean checkForJournalFlush ( ) { if ( QueueBatchSize == 0 ) return true ; if ( queue . size ( ) >= QueueBatchSize ) return true ; boolean journalSizeFlush = ( JournalThresholdSize > 0 && journal . size ( ) > JournalThresholdSize ) ; if ( journalSizeFlush ) return true ; return false ; }
private ProjectState newProjectState ( ProjectConfig local ) { PrologEnvironment . Factory envFactory = null ; GitRepositoryManager gitMgr = null ; ProjectControl . AssistedFactory projectControlFactory = null ; RulesCache rulesCache = null ; SitePaths sitePaths = null ; List < CommentLinkInfo > commentLinks = null ; ProjectState projectState = new ProjectState ( sitePaths , projectCache , allProjectsName , projectControlFactory , envFactory , gitMgr , rulesCache , commentLinks , local ) ; all . add ( projectState ) ; return projectState ; }
public static Collection < PersonaAccount > getPersonaAccountsForAccount ( long accountId ) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts . account_id = " + accountId + " AND p . status_id ! = " + Persona . PersonaStatus . DELETED . getStatusId ( ) ; CentralRepository cr = CentralRepository . getInstance ( ) ; if ( cr ! = null ) { PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback ( ) ; cr . executeSelectSQL ( queryClause , queryCallback ) ; return queryCallback . getPersonaAccountsList ( ) ; } return new ArrayList <> ( ) ; }
public boolean hasMultipleValues ( final String dimension ) { if ( isVirtualColumn ( dimension ) ) { return virtualColumns . getVirtualColumn ( dimension ) . capabilities ( dimension ) . hasMultipleValues ( ) ; } else { final Column column = index . getColumn ( dimension ) ; if ( column ! = null && columnSupportsFiltering ( column ) ) { return column . getCapabilities ( ) . hasMultipleValues ( ) ; } else { return false ; } } } Explanation : The original code had a confusing logic where it checked if the column supports filtering before checking if it has multiple values . The refactored code follows a more logical flow where it first checks if the column is null or supports filtering , and only then checks if it has multiple values .
public void resumeNode ( String id ) { api . serverApi ( ) . updateStatus ( id , Server . UpdateStatus . create ( Types . ServerAction . POWER_ON , Types . ServerActionMethod . HARDWARE ) ) ; }
public IStyledLabelProvider [ ] loadLabelProviders ( ) { if ( fLabelProviders == null ) { fLabelProviders = CHEProviderSettings . getCCallHierarchyLabelProviders ( ) ; } return fLabelProviders ; }
It is unclear why these operations are being registered and what invokes them .   public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { // TODO : Add comments explaining the purpose of these operations and what invokes them if ( showResources ) { resourceRegistration . registerOperationHandler ( ShowJaxrsResourcesHandler . DEFINITION , new ShowJaxrsResourcesHandler ( ) ) ; } else { resourceRegistration . registerOperationHandler ( ADD_DEFINITION , JaxrsSubsystemAdd . INSTANCE ) ; resourceRegistration . registerOperationHandler ( REMOVE_DEFINITION , ReloadRequiredRemoveStepHandler . INSTANCE ) ; } }
public int hashCode ( ) { int result = 17 ; result = 31 * result + processId . hashCode ( ) ; result = 31 * result + taskId . hashCode ( ) ; result = 31 * result + taskName . hashCode ( ) ; result = 31 * result + formName . hashCode ( ) ; return result ; }
< START > public void stop ( final String reason ) { new Thread ( "Shutdown Thread" ) { @Override public void run ( ) { independentThreadStop ( reason , true ) ; } } . start ( ) ; } < END >
public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry <? , ? > e = ( Map . Entry <? , ? >) o ; return ( ( key == null ? e . getKey ( ) == null : key . equals ( e . getKey ( ) ) ) && ( value == null ? e . getValue ( ) == null : value . equals ( e . getValue ( ) ) ) ) ; }
protected PostgreSqlEngine ( final PdbProperties properties , final String driver ) throws DatabaseEngineException { super ( driver , properties , Dialect . POSTGRESQL ) ; }
public synchronized void dispose ( ) { clearCachedSwingEditor ( ) ; }
public void run ( ) { try { if ( logger . isInfoEnabled ( ) ) logger . info ( "Start reconnecting " + provider ) ; provider . register ( getUIService ( ) . getDefaultSecurityAuthority ( provider ) ) ; } catch ( OperationFailedException ex ) { logger . error ( "cannot re - register provider will keep going" , ex ) ; } }
public void checkProperties ( Properties properties ) { String className = this . getClass ( ) . getName ( ) ; properties . setProperty ( "log4j . shutdownCallbackRegistry" , className ) ; properties . setProperty ( "log4j . shutdownHookEnabled" , "true" ) ; }
public void testUnmarshallTopLevelEmptyEventProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_ < START > _EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartTimerEvent emptyTop = getStartNodeById ( diagram , EMPTY_TOP_LEVEL_EVENT_ID , StartTimerEvent . class ) ; assertGeneralSet ( emptyTop . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertTimerEventEmpty ( emptyTop . getExecutionSet ( ) , NON_INTERRUPTING , EMPTY_VALUE ) ; // Known issue . Should be uncommented after https : // issues . jboss . org / browse / JBPM - 7038 will be fixed // assertDataIOSet ( emptySubprocess . getDataIOSet ( ) , EMPTY_VALUE ) ; }
private EmbeddedExpirableMetadata ( long lifespan , TimeUnit lifespanUnit , long maxIdle , TimeUnit maxIdleUnit , EntryVersion version ) { super ( version ) ; this . lifespan = lifespan < 0 ? lifespan : lifespanUnit . toMillis ( lifespan ) ; this . maxIdle = maxIdle < 0 ? maxIdle : maxIdleUnit . toMillis ( maxIdle ) ; }
protected void setMatcherString ( String pattern ) { if ( pattern . length ( ) == 0 ) { searchPattern = null ; } else { SearchPattern patternMatcher = new SearchPattern ( ) ; if ( pattern . indexOf ( ' * ' ) ! = 0 && pattern . indexOf ( ' ? ' ) ! = 0 && pattern . indexOf ( ' . ' ) ! = 0 ) { pattern = " * " + pattern ; } patternMatcher . setPattern ( pattern ) ; searchPattern = patternMatcher ; } }
public DefaultEditorSession ( final ManagedSession session , final CanvasCommandManager < AbstractCanvasHandler > canvasCommandManager , final @Session SessionCommandManager < AbstractCanvasHandler > sessionCommandManager , final @Request SessionCommandManager < AbstractCanvasHandler > requestCommandManager , final ClientCommandRegistry < org . kie . workbench . common . stunner . core . command . Command < AbstractCanvasHandler , CanvasViolation >> clientCommandRegistry ) { this . session = session ; this . commandRegistry = clientCommandRegistry . setSession ( session ) ; this . sessionCommandManager = sessionCommandManager ; this . requestCommandManager = requestCommandManager ; this . canvasCommandManager = canvasCommandManager ; }
private String transformToHeaderValue ( Directive . . . directives ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < directives . length - 1 ; i ++ ) { sb . append ( directives [ i ] . headerValue ) . append ( " , " ) ; } sb . append ( directives [ directives . length - 1 ] . headerValue ) ; return sb . toString ( ) ; }
private static void fireOnFailure ( final NodeProvisioner . PlannedNode plannedNode , final Throwable cause ) { for ( CloudProvisioningListener cl : CloudProvisioningListener . all ( ) ) { try { cl . onFailure ( plannedNode , cause ) ; } catch ( Throwable e ) { LOGGER . log ( Level . SEVERE , "Unexpected uncaught exception encountered while processing onFailure ( ) listener call in " + cl + " for agent " + plannedNode . displayName , e ) ; if ( e instanceof Error ) { throw e ; } } } }
public synchronized boolean isLastMQNotifLongAgo ( ) { long delay = 18 * 3600 ; // 24h - 3h = 18h long threshold = sharedPreferences . getLong ( getCurrentModeName ( ) + LAST_MORNING_Q_TIMESTAMP , - delay ) + delay ; if ( threshold < Calendar . getInstance ( ) . getTimeInMillis ( ) ) { Logger . d ( TAG , " { } - Last MQ notif was yesterday" , getCurrentModeName ( ) ) ; return true ; } else { Logger . v ( TAG , " { } - Last MQ notif was recent , do not notify" , getCurrentModeName ( ) ) ; return false ; } }
public CrewMember apply ( org . atlasapi . media . entity . CrewMember input ) { if ( input instanceof org . atlasapi . media . entity . Actor ) { return translateLegacyActor ( ( org . atlasapi . media . entity . Actor ) input ) ; } else if ( input ! = null ) { return translateLegacyCrewMember ( input ) ; } else { return null ; } }
public void testSocket ( ) throws Exception { Socket s = new Socket ( ) ; s . connect ( server . getLocalAddress ( ) ) ; Map < String , Object > liveDescriptors = tagger . getLiveDescriptors ( ) ; assertFalse ( liveDescriptors . isEmpty ( ) ) ; s . close ( ) ; }
public ValuesMatcher ( Map < String , Integer > outputSymbolAliases , Optional < Integer > expectedOutputSymbolCount , Optional < List < List < Expression >> > expectedRows ) { this . outputSymbolAliases = ImmutableMap . copyOf ( outputSymbolAliases ) ; this . expectedOutputSymbolCount = expectedOutputSymbolCount ; this . expectedRows = Objects . requireNonNull ( expectedRows , "expectedRows is null" ) ; }
protected Button getButton ( int id ) { return buttons . get ( id ) ; }
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) { if ( data instanceof Map ) { Map <? , ? > table = ( Map <? , ? >) data ; color = ( String ) table . get ( "color" ) ; } }
public void addRequestCleanupHandler ( HttpServletRequest request ) { RequestContext . getActiveContext ( request ) . addRequestCleanupHandler ( new RequestCleanupHandler ( ) { @Override public void cleanup ( HttpServletRequest req ) { try { close ( ) ; } catch ( OperationException e ) { throw new NuxeoException ( e ) ; } } } ) ; }
public void visitStatementList ( PyStatementListTree pyStatementListTree ) { if ( isStmtListIncrementsNestingLevel ( pyStatementListTree , Kind . FILE_INPUT ) ) { nestingLevelStack . peek ( ) . increment ( ) ; super . visitStatementList ( pyStatementListTree ) ; nestingLevelStack . peek ( ) . decrement ( ) ; } else { super . visitStatementList ( pyStatementListTree ) ; } }  Updated `isStmtListIncrementsNestingLevel` method :  private boolean isStmtListIncrementsNestingLevel ( PyStatementListTree pyStatementListTree , Kind kind ) { return pyStatementListTree . children ( ) . stream ( ) . anyMatch ( child -> child . is ( kind ) ) ; }  Explanation : The logic about `Kind . FILE_INPUT` is moved inside the `isStmtListIncrementsNestingLevel` method . The method now takes an additional parameter `Kind kind` to check if the given kind matches with the child node . The
private static void checkLxmlParseCall ( SubscriptionContext ctx ) { CallExpression callExpression = ( CallExpression ) ctx . syntaxNode ( ) ; if ( checkCallExpressionFqn ( callExpression , LXML_PARSE ) ) { CallExpression parserCall = getParserCall ( getArgValueAsCallExpression ( TreeUtils . nthArgumentOrKeyword ( 1 , "parser" , callExpression . arguments ( ) ) ) ) ; if ( parserCall ! = null && isUnsafeParserUsage ( parserCall ) ) { ctx . addIssue ( parserCall , MESSAGE ) . secondary ( callExpression ) ; } } }
public int getVisibility ( IBinding member ) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock ( getLinkage ( ) , record + MEMBERLIST ) ; return members . getAccessibility ( member ) ; } catch ( CoreException e ) { CCorePlugin . log ( e ) ; throw new IllegalArgumentException ( member . getName ( ) + " is not a member of " + getName ( ) ) ; } }
public Map < String , Object > getDynamicTemplateData ( ) { return ( dynamicTemplateData == null ) ? Collections . < String , Object > emptyMap ( ) : dynamicTemplateData ; }
private String version ; public String getVersion ( ) { return version ; }
public List < User > getUsers ( PerunSession sess ) throws InternalErrorException , PrivilegeException { Utils . checkPerunSession ( sess ) ; // Authorization if ( ! AuthzResolver . isAuthorized ( sess , Role . PERUNOBSERVER ) ) { throw new PrivilegeException ( sess , "getUsers" ) ; } return getUsersManagerBl ( ) . getUsers ( sess ) ; }
protected void setDefaultSwitchTypeIfNeeded ( ) { Cluster cluster = getCluster ( ) ; if ( ! cluster . isSetRequiredSwitchType ( ) ) { SwitchType defaultSwitchType = DefaultSwitchType . getDefaultSwitchType ( cluster . getCompatibilityVersion ( ) ) ; cluster . setRequiredSwitchTypeForCluster ( defaultSwitchType ) ; } }
public List < BlockLocationInfo > getBlockLocations ( AlluxioURI alluxioURI ) throws IOException { throw new UnsupportedOperationException ( "GetBlockLocations is not supported . " ) ; }
public CustomTxtParserWizard ( ) { this ( null ) ; } public CustomTxtParserWizard ( ISelection selection ) { super ( selection ) ; setWindowTitle ( Messages . CustomTxtParserInputWizardPage_windowTitle ) ; }
protected Provider < AdditionalProperties > createProvider ( String name ) { Provider < AdditionalProperties > p = mock ( Provider . class ) ; when ( p . getName ( ) ) . thenReturn ( name ) ; return p ; }
public static int mapApiToArtVersion ( int api ) { if ( api < 19 ) { return NO_VERSION ; } switch ( api ) { case 19 : case 20 : return 7 ; case 21 : return 39 ; case 22 : return 45 ; case 23 : return 64 ; case 24 : case 25 : return 79 ; case 26 : return 124 ; case 27 : return 131 ; default : return 144 ; } }
public void onAppendColumnEvent ( ) { AppendColumnEvent event = new AppendColumnEvent ( COLUMN_GROUP ) ; scenarioSimulationEventHandler . onEvent ( event ) ; verify ( scenarioSimulationEventHandler , times ( 1 ) ) . commonExecution ( eq ( scenarioSimulationContextLocal ) , isA ( AppendColumnCommand . class ) ) ; } @Test public void commonExecutionTest ( ) { // Arrange ScenarioGridPanel scenarioGridPanelMock = mock ( ScenarioGridPanel . class ) ; when ( scenarioSimulationContextLocal . getScenarioGridPanel ( ) ) . thenReturn ( scenarioGridPanelMock ) ; AppendColumnCommand command = new AppendColumnCommand ( scenarioGridPanelMock , COLUMN_GROUP ) ; // Act scenarioSimulationEventHandler . commonExecution ( scenarioSimulationContextLocal , command ) ; // Assert verify ( scenarioGridPanelMock ) . setFocus ( true ) ; }
public static < T extends Widget > T serializeAndDeserialize ( T instance ) throws Exception { byte [ ] bytes = serialize ( instance ) ; T result = deserialize ( bytes ) ; IDisplayAdapter displayAdapter = result . getDisplay ( ) . getAdapter ( IDisplayAdapter . class ) ; displayAdapter . attachThread ( ) ; return result ; }
public void onPreReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( PreReceiveHook hook : hooks ) { hook . onPreReceive ( rp , commands ) ; } }
public DescriptionBuilder withAdditionalAnnotations ( Annotation annotation , Annotation . . . additionalAnnotations ) { if ( annotation == null ) { throw new NullPointerException ( "Cannot add a null annotation" ) ; } List < Annotation > annotationsList = new ArrayList <> ( ) ; annotationsList . add ( annotation ) ; if ( additionalAnnotations ! = null ) { for ( Annotation additionalAnnotation : additionalAnnotations ) { if ( additionalAnnotation ! = null ) { annotationsList . add ( additionalAnnotation ) ; } } } annotations . addAll ( annotationsList ) ; return this ; }
public void onAttach ( final Activity activity ) { super . onAttach ( activity ) ; if ( activity instanceof Listener ) { mListener = ( Listener ) activity ; } else { Lg . e ( activity . getClass ( ) . getName ( ) , " should implement " , Listener . class . getName ( ) ) ; } }
private void preloadDataSet ( ) { preloadedDataSet = load ( iter . next ( ) ) ; totalOutcomes = preloadedDataSet . getLabels ( ) . size ( - 1 ) ; inputColumns = preloadedDataSet . getFeatureMatrix ( ) . size ( - 1 ) ; batch = preloadedDataSet . numExamples ( ) ; }
public void startup ( Application application , ComponentStartupStatus ss ) { FileOps . ensureDir ( deltaClientZone ) ; FileOps . clearAll ( deltaClientZone ) ; zone = Zone . connect ( deltaClientZone ) ; deltaLink = DeltaLinkHTTP . connect ( deltaServerURL ) ; deltaClient = DeltaClient . create ( zone , deltaLink ) ; jmsMessagingClient = application . getJMSMessagingClient ( ) ; ss . info ( String . format ( "DeltaClient connected to DeltaServer at % s with zone % s" , deltaServerURL , deltaClientZone ) ) ; }
protected void onInit ( ) { super . onInit ( ) ; if ( this . connectionFactory == null ) { this . connectionFactory = new TcpNioServerConnectionFactory ( super . getPort ( ) ) ; this . connectionFactory . setDeserializer ( new ByteArrayLfSerializer ( ) ) ; this . connectionFactory . setBeanFactory ( getBeanFactory ( ) ) ; if ( this . applicationEventPublisher ! = null ) { this . connectionFactory . setApplicationEventPublisher ( this . applicationEventPublisher ) ; } this . connectionFactory . afterPropertiesSet ( ) ; this . connectionFactory . registerListener ( this ) ; } }
public static Pair < Integer , Integer > getPrecisionAndScale ( String type ) { String param = type . substring ( 8 , type . length ( ) - 1 ) ; String [ ] params = param . split ( " , " ) ; return new Pair <> ( Integer . parseInt ( params [ 0 ] . trim ( ) ) , Integer . parseInt ( params [ 1 ] . trim ( ) ) ) ; }  To handle extraneous whitespaces , the `trim ( ) ` method is used to remove any leading or trailing whitespaces from the parsed integers . However , there are no unit tests provided in the given code .
< START > public static String constructSegmentPath ( String baseKey , String storageDir ) { return Joiner . on ( " / " ) . skipNulls ( ) . join ( baseKey , storageDir , "index . zip" ) ; } < END >
public MappingIterator ( Collection < S > source , Function < S , D > transformation ) { this . sourceIt = source . iterator ( ) ; this . transformation = transformation ; } @Override public boolean hasNext ( ) { if ( next == null ) { readNext ( ) ; } return next ! = null ; } @Override public D next ( ) { if ( next == null ) { readNext ( ) ; } D result = next ; next = null ; return result ; } private void readNext ( ) { if ( sourceIt . hasNext ( ) ) { S sourceElement = sourceIt . next ( ) ; next = transformation . apply ( sourceElement ) ; } }
public boolean removeAll ( Collection <? > c ) { boolean changed = false ; for ( XWikiAttachment x : ( Collection <? extends XWikiAttachment >) c ) { if ( map . remove ( x . getFilename ( ) ) ! = x ) { changed = true ; } } if ( changed ) { updatedMap ( ) ; } return changed ; }
public void run ( String . . . strings ) throws Exception { // Removed System . out . println statement }
public CollectEnvCommand ( FileSystemContext fsContext ) { super ( fsContext ) ; mCommands = new HashMap <> ( ) ; mCommandsAlt = new HashMap <> ( ) ; registerCommands ( ) ; }
protected void setBlobStorageService ( BlobStorageService blobStorageService ) { if ( blobStorageService == null ) { throw new IllegalArgumentException ( "BlobStorageService cannot be null" ) ; } this . blobStorageService = blobStorageService ; logger . trace ( "BlobStorage service set to { } " , blobStorageService . getClass ( ) ) ; }
public void dispose ( ) { app . getChildren ( ) . remove ( windowModel ) ; coolBarManager . dispose ( ) ; menuManager . dispose ( ) ; statusLineManager . dispose ( ) ; windowModel . getContext ( ) . deactivate ( ) ; windowModel . getContext ( ) . dispose ( ) ; ( ( Shell ) windowModel . getWidget ( ) ) . dispose ( ) ; }
public void setUp ( ) { n = new CacheManagerNotifierImpl ( ) ; cl = new CacheManagerListener ( ) ; n . start ( ) ; n . addListener ( cl ) ; }
public char getLabel ( ) { final char rv ; switch ( getType ( ) ) { case INPUT_VAL : rv = buttonData . inputVal ; break ; case AUTO_CHAR : rv = buttonData . autoChar ; break ; case CUSTOM : rv = buttonData . customChar ; break ; default : rv = ' * ' ; // Should never happen . } return rv ; }
public ReleasableBytesReference retainedSlice ( int from , int length ) { BytesReference slice = delegate . slice ( from , length ) ; return new ReleasableBytesReference ( slice , refCounted ) ; } private class ReleasableBytesReference extends AbstractReferenceCountedBytesReference { private final BytesReference delegate ; private ReleasableBytesReference ( BytesReference delegate , ReferenceCounter refCounted ) { super ( refCounted ) ; this . delegate = delegate ; refCounted . incRef ( ) ; } @Override protected void deallocate ( ) { delegate . release ( ) ; } @Override public byte getByte ( int index ) { return delegate . getByte ( index ) ; } @Override public int length ( ) { return delegate . length ( ) ; } @Override public BytesReference slice ( int from , int length ) { return delegate . slice ( from , length ) ; } }
public static < T > Iterable < T > latest ( final Observable <? extends T > source ) { return new Iterable < T >( ) { @Override public Iterator < T > iterator ( ) { LatestObserverIterator < T > lio = new LatestObserverIterator < T >( ) ; lio . subscription = source . materialize ( ) . subscribe ( new SafeSubscriber < Notification <? extends T >> ( lio ) { @Override public void onNext ( Notification <? extends T > args ) { lio . onNext ( args ) ; } @Override public void onError ( Throwable e ) { lio . onError ( e ) ; } @Override public void onCompleted ( ) { lio . onCompleted ( ) ; } } ) ; return lio ; } } ; }  In the refactored code , the `subscription` field is removed and `this . unsubscribe ( ) ` is called on L101 instead . The `SafeSubscriber` layer is added to ensure that the `onNext` ,
public static MessageType fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return current ; } } return null ; }  or  public static Optional < MessageType > fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return Optional . of ( current ) ; } } return Optional . empty ( ) ; }  Both of these options are valid alternatives to returning an enum entry that only exists for this method . The first option returns `null` if no matching enum entry is found , while the second option returns an `Optional` that may or may not contain a matching enum entry .
private boolean isHostNetworkUnreacable ( VDS vds ) { VdsDynamic vdsDynamic = vds . getDynamicData ( ) ; return vdsDynamic . getStatus ( ) == VDSStatus . Down || vdsDynamic . getStatus ( ) == VDSStatus . Reboot || ( vdsDynamic . getStatus ( ) == VDSStatus . NonOperational && vdsDynamic . getNonOperationalReason ( ) == NonOperationalReason . NETWORK_UNREACHABLE ) ; }
public class ScriptExecutingMessageSource { private AbstractScriptExecutingMessageProcessor <? > scriptMessageProcessor ; public ScriptExecutingMessageSource ( AbstractScriptExecutingMessageProcessor <? > scriptMessageProcessor ) { this . scriptMessageProcessor = scriptMessageProcessor ; } }
public void typeInSearchField ( String content , int length ) { waitForElementVisibleByElement ( searchInput ) ; searchInput . sendKeys ( content ) ; PageObjectLogging . log ( "typeInSearchField" , "String >> " + content + " << was typed in string field" , true ) ; }
public Iterable < E > read ( Configuration configuration ) throws IOException { DatasetReader < E > reader = view . newReader ( ) ; return reader ; }
public void setRefreshInterval ( final long refreshInterval ) { refresh_interval_in_seconds = refreshInterval ; }
public void onNewImageFromCamera ( ) { if ( navigator . isSdkAboveOrEqualM ( ) && ! navigator . doIHavePermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) ) { navigator . askForPermission ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA ) ; } else { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; } } // Refactored Code public void onNewImageFromCamera ( ) { if ( shouldAskForPermission ( ) ) { navigator . askForPermission ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA ) ; } else { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; } } private boolean shouldAskForPermission ( ) { return navigator . isSdkAboveOrEqualM ( ) && ! navigator . doIHavePermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; }
public void testEquals ( ) throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true , false , true ) ; FixedWidthConfiguration conf2 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true , false , true ) ; assertEquals ( conf1 , conf2 ) ; FixedWidthConfiguration conf3 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , false , false , true ) ; assertFalse ( conf1 . equals ( conf3 ) ) ; } // Overloaded constructors public FixedWidthConfiguration ( int recordLength , String charsetName , boolean ignoreMissingChars , boolean ignoreTrailingChars , boolean ignoreLeadingChars ) { this ( recordLength , charsetName , 0 , ignoreMissingChars , ignoreTrailingChars , ignoreLeadingChars ) ; } public FixedWidthConfiguration ( int recordLength , String charsetName , int maxCharsPerColumn , boolean ignoreMissingChars , boolean ignoreTrailingChars , boolean ignoreLeadingChars )
public void showLinkPreview ( PageTitle title , int entrySource ) { final String linkPreviewFragmentTag = "link_preview_dialog" ; if ( getSupportFragmentManager ( ) . findFragmentByTag ( linkPreviewFragmentTag ) == null ) { LinkPreviewDialog . newInstance ( title , entrySource ) . show ( getSupportFragmentManager ( ) , linkPreviewFragmentTag ) ; } else { ( ( LinkPreviewDialog ) getSupportFragmentManager ( ) . findFragmentByTag ( linkPreviewFragmentTag ) ) . dismiss ( ) ; } }
public void clear ( ) { if ( loader instanceof CacheStore ) { try { ( ( CacheStore ) loader ) . clear ( ) ; } catch ( CacheLoaderException e ) { throw newCacheLoaderException ( e ) ; } } }
public ApplicabilityIds getApplicabilityIds ( ) { ApplicabilityIds ids = new ApplicabilityIds ( ) ; // Replace with call to IApplicabilityService calls once implemented // ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 345L , "ARC - 210" ) ) ; // ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 366L , "COMM" ) ) ; // ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 376L , "ASM" ) ) ; // ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 368L , "UTF" ) ) ; // ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 466L , "MDR" ) ) ; return ids ; }
private MediaType tryNarrowMediaType ( MediaType negotiated , AdvancedCache <? , ? > cache ) { if ( ! negotiated . matchesAll ( ) ) return negotiated ; MediaType storageMediaType = cache . getValueDataConversion ( ) . getStorageMediaType ( ) ; if ( storageMediaType == null ) return negotiated ; if ( storageMediaType . equals ( MediaType . APPLICATION_OBJECT ) ) return MediaType . TEXT_PLAIN ; if ( storageMediaType . match ( MediaType . APPLICATION_PROTOSTREAM ) ) return MediaType . APPLICATION_JSON ; return negotiated ; }
protected void addJAROption ( Composite comp ) { fJarButton = new Button ( comp , SWT . CHECK ) ; fJarButton . setText ( getJarButtonText ( ) ) ; }
public String getTurnDescription ( Translation tr ) { if ( ! name . isEmpty ( ) ) { return getName ( ) ; } return tr . tr ( "finish" ) ; }
private void fetchPresenterWidgetTemplate ( PresenterOptions presenterOptions ) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions ( ) ; presenterWidgetOptions . setSingleton ( presenterConfigModel . isUseSingleton ( ) ) ; try { createdPresenterWidgetTemplates = CreatePresenterWidget . run ( presenterOptions , presenterWidgetOptions , true ) ; } catch ( Exception e ) { throw e ; } }
public String toString ( ) { StringWriter writer = new StringWriter ( ) ; try { new ObjectMapper ( ) . writeValue ( writer , graph ) ; } catch ( Exception e ) { log . error ( "Error while constructing new ObjectMapper" , e ) ; } return writer . toString ( ) ; }
public TopicStatus ( String topic , ConnectorTaskId task , long discoverTimestamp ) { this ( topic , Objects . requireNonNull ( task ) . connector ( ) , task . task ( ) , discoverTimestamp ) ; }
private static OGCGeometry readGeometry ( BasicSliceInput input , Slice inputSlice , GeometryType type , int length ) { switch ( type ) { case POINT : return readPoint ( input ) ; case MULTI_POINT : case LINE_STRING : case MULTI_LINE_STRING : case POLYGON : case MULTI_POLYGON : return readSimpleGeometry ( input , inputSlice , type , length ) ; case GEOMETRY_COLLECTION : return readGeometryCollection ( input , inputSlice ) ; case ENVELOPE : return OGCGeometry . createFromEsriGeometry ( readEnvelope ( input ) , null ) ; default : throw new IllegalArgumentException ( "Unexpected type : " + type ) ; } }
public void close ( ) { sketch = null ; values = null ; }
public boolean shouldSpill ( ) { long batchSize = ( batchMemoryManager . getRecordBatchSizer ( RIGHT_INDEX ) . getRowAllocWidth ( ) + 4 ) * recordsPerBatch ; long reserveForOutgoing = batchMemoryManager . getOutputBatchSize ( ) ; long memoryAvailableNow = allocator . getLimit ( ) - allocator . getAllocatedMemory ( ) - reserveForOutgoing - ( probeBatch ! = null ? probeBatch . getByteCount ( ) : 0 ) ; boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow ; if ( needsSpill ) { logger . debug ( "should spill now - batch size { } , mem avail { } , reserved for outgoing { } " , batchSize , memoryAvailableNow , reserveForOutgoing ) ; } return needsSpill ; }
public void close ( ) { try { Await . result ( beam . close ( ) ) ; } catch ( Exception e ) { final String errorMsg = "Error while closing Druid beam client" ; LOG . error ( errorMsg , e ) ; throw new IOException ( errorMsg , e ) ; } }
private boolean isPlatformKeybindingBug517068Fixed ( ) { Bundle bundle = Platform . getBundle ( "org . eclipse . e4 . ui . bindings" ) ; // $NON - NLS - 1$ Version currentVersion = bundle . getVersion ( ) ; Version fixVersion = new Version ( 0 , 12 , 1 ) ; return currentVersion . compareTo ( fixVersion ) >= 0 || currentVersion . equals ( new Version ( 0 , 12 , 100 ) ) ; }
public static boolean isPluginPrefixAndArtifactIdEquals ( Plugin p1 , Plugin p2 ) { return StringUtils . equals ( p1 . getArtifactId ( ) , p2 . getArtifactId ( ) ) && StringUtils . equals ( p1 . getPrefix ( ) , p2 . getPrefix ( ) ) ; }
public < T , VT > MessageOut < T > withParameter ( ParameterType type , VT value ) { List < Object > newParameters = new ArrayList <> ( parameters . size ( ) + 2 ) ; newParameters . addAll ( parameters ) ; newParameters . add ( type ) ; newParameters . add ( value ) ; return new MessageOut <> ( verb , payload , serializer , newParameters ) ; }
private boolean validateTimeRange ( ) { boolean isEmpty = fStartTimeRangeText . getText ( ) . isEmpty ( ) || fEndTimeRangeText . getText ( ) . isEmpty ( ) ; return ! isEmpty && parseTimeRange ( ) && fStartTimestamp . compareTo ( fEndTimestamp ) < 0 ; }
public static String getFileNamePath ( final String filename , final FieldbookProperties fieldbookProperties ) { final String filenamePath ; StringBuilder filenameBuilder = new StringBuilder ( ) ; filenameBuilder . append ( fieldbookProperties . getUploadDirectory ( ) ) ; filenameBuilder . append ( File . separator ) ; filenameBuilder . append ( SettingsUtil . cleanSheetAndFileName ( filename ) ) ; filenamePath = filenameBuilder . toString ( ) ; return filenamePath ; }
protected void changeStorageDomainStatusInTransaction ( final StoragePoolIsoMap map , final StorageDomainStatus status ) { executeInNewTransaction ( new TransactionMethod < StoragePoolIsoMap >( ) { @SuppressWarnings ( "synthetic - access" ) @Override public StoragePoolIsoMap runInTransaction ( ) { CompensationContext context = getCompensationContext ( ) ; context . snapshotEntityStatus ( map , map . getstatus ( ) ) ; map . setstatus ( status ) ; getStoragePoolIsoMapDao ( ) . updateStatus ( map . getId ( ) , map . getstatus ( ) ) ; getCompensationContext ( ) . stateChanged ( ) ; return null ; } } ) ; }
public void visitMemberSelectExpression ( MemberSelectExpressionTree tree ) { if ( tree . expression ( ) . is ( Tree . Kind . IDENTIFIER ) ) { IdentifierTree identifier = ( IdentifierTree ) tree . expression ( ) ; Symbol owner = identifier . symbol ( ) . owner ( ) ; if ( owner ! = null && owner . isMethodSymbol ( ) ) { // No need to investigate selection on local symbols return ; } } if ( tree . expression ( ) . symbolType ( ) . isSubtypeOf ( "java . lang . Class" ) ) { // No need to investigate selection on a Class object return ; } super . visitMemberSelectExpression ( tree ) ; }
public V computeIfPresent ( K key , BiFunction <? super K , ? super V , ? extends V > remappingFunction ) { checkNotNull ( key , NULL_KEY_IS_NOT_ALLOWED ) ; checkNotNull ( remappingFunction , NULL_BIFUNCTION_IS_NOT_ALLOWED ) ; return computeIfPresentLocally ( key , remappingFunction ) ; }
public void sendUnanchored ( Task task , String stream , List < Object > values , ExecutorTransfer transfer ) { Tuple tuple = task . getTuple ( stream , values ) ; List < Integer > tasks = task . getOutgoingTasks ( stream , values ) ; if ( ! tasks . isEmpty ( ) ) { for ( Integer t : tasks ) { transfer . transfer ( t , tuple ) ; } } }
AffinityResourceDefinition ( PathElement path ) { super ( path , UndertowExtension . getResolver ( Constants . HANDLER , Constants . AFFINITY , path . getValue ( ) ) , new RestartParentResourceRegistration ( ) , new RestartParentResourceRegistration ( ) ) ; }
@Override public E poll ( ) throws NoSuchElementException { lock . lock ( ) ; try { if ( queue . isEmpty ( ) ) { throw new NoSuchElementException ( ) ; } E peek = queue . peek ( ) ; queue . remove ( ) ; return peek ; } finally { lock . unlock ( ) ; } }
public void testTimeout ( ) throws SystemException , RemoteException { log . tracef ( "Method stateful #testTimeout called" ) ; Transaction txn ; txn = tm . getTransaction ( ) ; TxTestUtil . enlistTestXAResource ( txn ) ; TxTestUtil . enlistTestXAResource ( txn ) ; try { TxTestUtil . waitForTimeout ( tm ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RemoteException ( "Interrupted during waiting for transaction timeout" , ie ) ; } }
UnstagedComparator ( boolean sortAlphabetically ) { this . alphabeticallySort = sortAlphabetically ; }
public boolean shouldUseNativeIO ( VM vm , DiskImage diskImage , VmDevice device ) { StorageType storageType = diskImage . getStorageTypes ( ) . get ( 0 ) ; String diskType = getDiskType ( vm , diskImage , device ) ; boolean isNativeIO = ( ! "file" . equals ( diskType ) || ( storageType == StorageType . GLUSTERFS && FeatureSupported . useNativeIOForGluster ( vm . getCompatibilityVersion ( ) ) ) ) && ( device . getSnapshotId ( ) == null ) ; return isNativeIO ; }

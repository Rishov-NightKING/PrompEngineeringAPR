private static boolean isStringParameter ( @NonNull Expression expression , @NonNull JavaContext context ) { TypeDescriptor type = context . getType ( expression ) ; return type != null && type . matchesSignature ( JavaContext . TYPE_STRING ) ; }
protected double getScore ( double availableCpu , double availableMemory , Map < String , Double > availableGenericResources ) { return getScore ( availableCpu , availableMemory , availableGenericResources , getNextHighest ( ) ) ; }
public < T extends Action > List < T > getActions ( Class < T > type ) { List < T > _actions = new ArrayList < > ( getPersistedActions ( type ) ) ; for ( TransientActionFactory < ? > taf : TransientActionFactory . factoriesFor ( getClass ( ) , type ) ) { _actions . addAll ( Util . filter ( createFor ( taf ) , type ) ) ; } return Collections . unmodifiableList ( _actions ) ; } private < T extends Action > List < T > getPersistedActions ( Class < T > type ) { List < T > persistedActions = Util . filter ( getPersistedActions ( ) , type ) ; if ( persistedActions . isEmpty ( ) && type != Action . class ) { persistedActions = getPersistedActions ( Action . class ) ; } return persistedActions ; }
public void addRepresentation ( ImageData srcImageData , int zoom ) { if ( srcImageData == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } int imageSelectorIndex = DPIUtil . mapZoomToImageSelectorIndex ( zoom ) ; if ( imageSelectorIndex == device . getImageSelector ( ) ) { data [ imageSelectorIndex ] = srcImageData ; } else { init ( srcImageData ) ; } }
private DefaultEnvironment buildEnvironment ( EnvironmentType environmentType ) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment ( environmentType ) ; defaultEnvironment . loadProperties ( ) ; return defaultEnvironment ; }
public int hashCode ( ) { if ( getRepositoryName ( ) != null ) return getRepositoryName ( ) . hashCode ( ) ; return System . identityHashCode ( this ) ; }
public List < String > getExtensions ( ) { return extensions ; }
public List < RadiologyOrder > getRadiologyOrdersByPatient ( final Patient patient ) { final Criteria radiologyOrderCriteria = createRadiologyOrderCriteria ( ) ; addRestrictionOnPatient ( radiologyOrderCriteria , patient ) ; final List < RadiologyOrder > result = ( List < RadiologyOrder > ) radiologyOrderCriteria . list ( ) ; return result == null ? new ArrayList < RadiologyOrder > ( ) : result ; }
public Weld addExtensions ( Class < ? extends Extension > . . . extensionClasses ) { for ( Class < ? extends Extension > extensionClass : extensionClasses ) { try { Extension extension = SecurityActions . newInstance ( extensionClass ) ; addExtension ( extension ) ; } catch ( Exception ex ) { CommonLogger . LOG . unableToInstantiate ( extensionClass , new Object [ ] { } , ex ) ; } } return this ; }
public RTTestsParser ( ) { super ( Messages . _Warnings_RTTests_ParserName ( ) , Messages . _Warnings_RTTests_LinkName ( ) , Messages . _Warnings_RTTests_TrendName ( ) , CYCLICTEST_WARNING_PATTERN , true ) ; if ( isLineInteresting ( ) ) { setIgnoreLines ( 1 ) ; } } @Override protected boolean isLineInteresting ( ) { return true ; }
private ValidationResult hostExists ( ) { return getVds ( ) == null ? new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_HOST_NOT_EXIST ) : ValidationResult . VALID ; }
public static ToolTipString fromString ( String text ) { return new ToolTipString ( text , toHtmlString ( text ) ) ; }
public DataRadioStation getNextById ( String id ) { if ( listStations . isEmpty ( ) ) { return null ; } for ( int i = 0 ; i < listStations . size ( ) - 1 ; i ++ ) { if ( listStations . get ( i ) . ID . equals ( id ) ) { return listStations . get ( i + 1 ) ; } } return listStations . get ( 0 ) ; }
public static void setBiomeArrayMethod ( boolean jeidPresent ) { try { if ( jeidPresent ) { biomeArrayMethod = Chunk . class . getMethod ( "getIntBiomeArray" ) ; } else { biomeArrayMethod = Chunk . class . getMethod ( "getBiomeArray" ) ; } } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } }
public String getDescription ( ) { return "Transform files representing a structured table under an Alluxio directory . \n\n" + "Files are coalesced and converted to parquet format . \n\n" + "Definition is in format like 'write ( hive ) . option ( hive . num . files , 100 ) ' , " + "currently , the only modification you can do to the example definition is " + "the number of files in the option . " ; }
< START > public static int [ ] validateNonNegative ( int [ ] data , String paramName ) { Preconditions . checkNotNull ( data , "Data cannot be null" ) ; boolean nonnegative = true ; for ( int value : data ) { if ( value < 0 ) { nonnegative = false ; break ; } } Preconditions . checkArgument ( nonnegative , "Values for % s must be >= 0 , got : % s" , paramName , data ) ; return data ; } < END > Note : I assumed that the method should return the same array that was passed as an argument . If that's not the case , the return type can be changed accordingly .
public SetContentTypeFilter ( ) throws IOException { mimetypeToExtensionMap = new Properties ( ) ; mimetypeToExtensionMap . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "mimetypeToExtension . txt" ) ) ) ; contentTypeProperties = new Properties ( ) ; contentTypeProperties . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "toContentType . properties" ) ) ) ; } catch ( IOException e ) { throw new IOException ( "Failed to load mimetype mappings" , e ) ; }
private SwiftApi api ( String authUrl , Properties overrides ) throws IOException { overrides = new Properties ( ) ; overrides . setProperty ( CREDENTIAL_TYPE , "tempAuthCredentials" ) ; return ContextBuilder . newBuilder ( new SwiftApiMetadata ( ) ) . credentials ( "user" , "password" ) . endpoint ( authUrl ) . overrides ( overrides ) . modules ( ImmutableSet . of ( new ExecutorServiceModule ( sameThreadExecutor ( ) ) ) ) . buildApi ( SwiftApi . class ) ; }
public void setAcceptableValues ( Collection < K > values ) { if ( values == null ) { throw new IllegalArgumentException ( "Values cannot be null" ) ; } buttons . clear ( ) ; panels . clear ( ) ; wrapperPanel . clear ( ) ; for ( final K value : values ) { addValue ( value ) ; } updateButtons ( ) ; }
public Bucket getOrCreateBucket ( String bucketName ) { Bucket bucket = storage . get ( bucketName ) ; if ( bucket == null ) { log . debug ( String . format ( "Creating a new bucket % s" , bucketName ) ) ; return storage . create ( BucketInfo . of ( bucketName ) ) ; } return bucket ; }  Explanation : Since `StorageException` is a runtime exception , there is no need to catch and rethrow it . The refactored code removes the try - catch block and directly returns the `Bucket` object if it exists , or creates a new one if it doesn't .
private void onFragmentLoaded ( ) { if ( searchAdapter == null ) { searchAdapter = new SearchlistAdapter ( getActivity ( ) , itemAccess ) ; setListAdapter ( searchAdapter ) ; } searchAdapter . notifyDataSetChanged ( ) ; setListShown ( true ) ; String query = getArguments ( ) . getString ( ARG_QUERY ) ; setEmptyText ( getString ( R . string . no_results_for_query , query ) ) ; }
private Iterable < Ref > getSortedRefs ( ) throws Exception { List < Ref > all = db . getRefDatabase ( ) . getRefsByPrefix ( ALL ) ; if ( all instanceof RefMap || ( all instanceof SortedMap && ( ( SortedMap ) all ) . comparator ( ) == null ) ) { return all ; } return RefComparator . sort ( all ) ; }
private static void convertAAAProfilesResult ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { List < String > results = new ArrayList < String > ( ) ; for ( ProfileEntry profileEntry : source != null ? new ArrayList < ProfileEntry > ( ( Collection < ProfileEntry > ) source ) : new ArrayList < ProfileEntry > ( ) ) { results . add ( profileEntry . getProfile ( ) ) ; } return results ; } } ; }
< START > FunctionKindRowColumnHeaderMetaData ( final Supplier < FunctionDefinition > functionSupplier , final CellEditorControlsView . Presenter cellEditorControls , final KindPopoverView . Presenter editor , final Optional < String > editorTitle , final FunctionGrid gridWidget ) { super ( cellEditorControls , editor , editorTitle ) ; this . functionSupplier = functionSupplier ; this . gridWidget = gridWidget ; }
public List < ProxiedPlayer > matchPlayer ( String partialName ) { List < ProxiedPlayer > matched = new ArrayList < ProxiedPlayer > ( ) ; for ( ProxiedPlayer iPlayer : this . getPlayers ( ) ) { String iterPlayerName = iPlayer . getName ( ) ; if ( iterPlayerName . toLowerCase ( ) . startsWith ( partialName . toLowerCase ( ) ) ) { matched . add ( iPlayer ) ; } } return matched ; }
private int zigzagDecode ( int input ) { return ( input > > > 1 ) ^ ( - ( input & 1 ) ) ; }
public void testEqualsCondition ( ) { doTest ( GoStringIndexIsByteQuickFix . NAME ) ; } private void doTest ( String name ) { // test code here } private void doTestNoFix ( ) { // test code here without applying any fix }
public void testRedrawAfterDispose ( ) { LineNumberRulerColumn lineNumberRulerColumn = new LineNumberRulerColumn ( ) ; CompositeRuler ruler = new CompositeRuler ( ) ; ruler . addDecorator ( 0 , lineNumberRulerColumn ) ; SourceViewer sourceViewer = new SourceViewer ( fParent , ruler , SWT . NONE ) ; lineNumberRulerColumn . getControl ( ) . setSize ( 10 , 10 ) ; sourceViewer . getTextWidget ( ) . dispose ( ) ; lineNumberRulerColumn . redraw ( ) ; }
public boolean configureDefaultNetworkRulesForSystemVm ( final Connect conn , final String vmName ) { if ( ! _canBridgeFirewall ) { return false ; } final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "default_network_rules_systemvm" ) ; cmd . add ( " -- vmname" , vmName ) ; cmd . add ( " -- localbrname" , _linkLocalBridgeName ) ; final String result = cmd . execute ( ) ; return result == null ; }
public void testQueryCumulativeTable ( ) { computeActual ( "SELECT * FROM \" * :* \"" ) ; computeActual ( "SELECT * FROM \"java . util . logging :* \"" ) ; assertTrue ( computeActual ( "SELECT * FROM \"java . lang :* \"" ) . getRowCount ( ) > 1 ) ; assertTrue ( computeActual ( "SELECT * FROM \"jAVA . LANg :* \"" ) . getRowCount ( ) > 1 ) ; }
public RequestLogger get ( ) { LoggingRequestLogger logger = new LoggingRequestLogger ( mapper , setMDC , setContextMDC ) ; log . debug ( new Exception ( "Stack trace" ) , "Creating % s at" , logger ) ; return logger ; }
private IllegalReferenceCountException handleIllegalReferenceCountException ( IllegalReferenceCountException e ) { String accessRecord = leak . toString ( ) ; if ( StringUtil . isNullOrEmpty ( accessRecord ) ) { // means leak has been closed and there is no accessRecord . return e ; } return new TrackedIllegalReferenceCountException ( e , accessRecord ) ; }
public List < Payment > getAccountPayments ( final UUID accountId , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getAccountPayments ( accountId , withPluginInfo , withAttempts , tenantContext , internalCallContextFactory . createInternalTenantContext ( accountId , tenantContext ) ) ; }
public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; Serializable auditParam = command . getParam ( NXAuditEventsService . DISABLE_AUDIT_LOGGER ) ; disableAudit = auditParam != null && Boolean . parseBoolean ( auditParam . toString ( ) ) ; retentionManager = Framework . getService ( RetentionManager . class ) ; ruleId = command . getParam ( PARAM_RULE_ID ) ; }
public boolean remove ( Connection connection ) { boolean removed = connectionPool . remove ( connection ) ; if ( getHttpExchanges ( ) . isEmpty ( ) ) { tryRemoveIdleDestination ( ) ; } else if ( removed ) { process ( true ) ; } return connectionPool . remove ( connection ) ; }
public boolean getRewriteBatchedStatements ( ) { final String isRewrite = super . connectionProperties . getProperty ( REWRITE_BATCHED_STATEMENTS ) ; return isRewrite == null ? false : Boolean . valueOf ( isRewrite ) ; }
public static ScheduledExecutorService newScheduler ( int numThreads , String threadNamePrefix , boolean isDaemon ) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor ( numThreads , new SchedulerThreadFactory ( threadNamePrefix , isDaemon ) ) ; scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; scheduler . setRemoveOnCancelPolicy ( false ) ; // Updated based on review return scheduler ; }
public boolean setValue ( T newValue ) { if ( ! validator . validate ( newValue ) ) { LOGGER . warn ( "The passed value { } is invalid : it is beyond the maximum value allowed . " , newValue ) ; return false ; } PropertyChangeEvent event = new PropertyChangeEvent ( this , id . toString ( ) , this . value , newValue ) ; this . value = newValue ; dispatchChangedEvent ( event ) ; return true ; }
public void onMessage ( MessageHolderWithTokens message ) { try { logger . trace ( "receiving tokens from queue , triggering Notification Dispatcher class to pick the right sender" ) ; dequeueEvent . fire ( message ) ; } catch ( DispatchInitiationException e ) { throw e ; } catch ( Exception e ) { logger . error ( "NotificationDispatcher or PushNotificationSender unexpectedly failed , the message won't be redelivered" , e ) ; } }  Changes Made : - Changed the log level from `debug` to `trace` based on the review comment .
private Collection < Key > getRegisteredKeys ( ) { List < Key > result = new ArrayList < Key > ( ) ; result . addAll ( cacheMap . keySet ( ) ) ; return result ; }
protected AbstractMetric ( String metricName , String metricType , T initialValue , MetricReportManager manager ) { name = metricName ; type = metricType ; value = initialValue ; metricManager = manager ; }
public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues ( ) { Allergy allergy = allergy ( ) ; assertTrue ( allergy . hasSameValues ( allergy ( ) ) ) ; }
private static String readMapping ( ) throws IOException , ParseException { JSONParser parser = new JSONParser ( ) ; ClassLoader classloader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try ( InputStream inputStream = classloader . getResourceAsStream ( "mapping . json" ) ) { String mapping = IOUtils . toString ( inputStream , "UTF - 8" ) ; Object object = parser . parse ( mapping ) ; JSONObject jsonObject = ( JSONObject ) object ; return jsonObject . toJSONString ( ) ; } }
public synchronized void commit ( ) throws CommitException { SyncCommitObserver sco = null ; try { sco = new SyncCommitObserver ( ) ; commitAsync ( sco ) ; sco . waitForCommit ( ) ; } finally { updates . clear ( ) ; weakNotification = null ; observedColumns = ImmutableSet . of ( ) ; // Fix for the bug columnsRead . clear ( ) ; } }
public static boolean hasPictureId ( byte [ ] buf , int off , int len ) { return isValid ( buf , off ) && ( buf [ off ] & X_BIT ) != 0 && ( buf [ off + 1 ] & I_BIT ) != 0 ; }
public void setEnabled ( boolean enabled ) { this . active = enabled ; updateButtonState ( ) ; }
< START > default void beforeDataProviderExecution ( IDataProviderMethod dataProviderMethod , ITestNGMethod method , ITestContext iTestContext ) { < END > }
private void handleEndActionJobAndStep ( ) { if ( ( ! hasTaskHandlers ( ) || getExecutionIndex ( ) == getTaskHandlers ( ) . size ( ) - 1 ) && ( ! parentHasCallback ( ) || getExecutionContext ( ) . getExecutionMethod ( ) == ExecutionMethod . AsStep ) ) { startFinalizingStep ( ) ; } }
private boolean waitForScanState ( ScanStates state ) { try { while ( getScanState ( ) != state ) { scanState . wait ( ) ; } return true ; } catch ( InterruptedException e ) { tsLogger . logger . warn ( "problem waiting for scanLock whilst in state " + state . name ( ) , e ) ; return false ; } }
private void maybeScheduleCheckpoint ( ) { switch ( state ( ) ) { case RESTORING : case SUSPENDED : this . checkpoint = checkpointableOffsets ( ) ; break ; case RUNNING : if ( ! eosEnabled ) { this . checkpoint = checkpointableOffsets ( ) ; } break ; case CREATED : case CLOSED : throw new IllegalStateException ( "Illegal state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; default : throw new IllegalStateException ( "Unknown state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; } }  Refactored Review : Merged RESTORING and SUSPENDED cases in the switch statement .
protected void executeQueryCommand ( ) { Provider hostProvider = getProvider ( ) ; ProviderProxyFactory factory = ProviderProxyFactory . getInstance ( ) ; HostProviderProxy proxy = factory . create ( hostProvider ) ; getQueryReturnValue ( ) . setReturnValue ( chainToString ( proxy . getCertificateChain ( ) ) ) ; }  Explanation : The code casts to `HostProviderProxy` because it assumes that the `Provider` returned by `getProvider ( ) ` is an instance of `HostProvider` . However , this assumption may not always be true , and the code may throw a `ClassCastException` if the `Provider` is not a `HostProvider` . To avoid this issue , we can use the `ProviderProxyFactory` to create a proxy for the `Provider` , which will ensure that the correct type of proxy is created based on the type of `Provider` . This eliminates the need for the cast to `HostProviderProxy` .
public void t1 ( ) { // code to add test case execution order using InvokedMethodListener InvokedMethodListener listener = new InvokedMethodListener ( ) ; listener . beforeInvocation ( new Object ( ) { } . getClass ( ) . getEnclosingMethod ( ) , null , null ) ; }
public void testValidateDataStreamsNoConflicts ( ) { Metadata metadata = createIndices ( 5 , 10 , "foo - datastream" ) . metadata ; try { validateDataStreams ( metadata . getIndicesLookup ( ) , ( DataStreamMetadata ) metadata . customs ( ) . get ( DataStreamMetadata . TYPE ) ) ; } catch ( Exception e ) { fail ( "did not expect exception when validating a system without indices that would conflict with future backing indices : " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } }
public ShaderProvider getPassShaderProvider ( int n ) { return passShaderProviders [ n ] ; }
public void onConnectionClosedForUser ( QBRTCSession qbrtcSession , Integer integer ) { stopTimer ( ) ; setStatusForOpponent ( integer , getString ( R . string . closed ) ) ; } // где - то в коде должно быть закрытие сессии для всех пользователей
public void install ( ITextViewer textViewer ) { List < IReconciler > nonNullReconcilers = new ArrayList < > ( ) ; for ( IReconciler iReconciler : fReconcilers ) { if ( iReconciler != null ) { nonNullReconcilers . add ( iReconciler ) ; } } for ( IReconciler iReconciler : nonNullReconcilers ) { iReconciler . install ( textViewer ) ; } }
public JettyServer run ( WebApplicationContext baseContext , boolean directlyUseAsWebAppRoot , Function < Function < Integer , JettyServer > , JettyServer > serverStarter , boolean exitOnError ) { try { configureLogger ( ) ; configureSentry ( baseContext ) ; JettyServer jettyServer = createJettyServer ( baseContext , directlyUseAsWebAppRoot , serverStarter , v - > { if ( v != null ) { v . addLifeCycleListener ( new JettyLifeCycleListener ( baseContext ) ) ; } } ) ; jettyServer . start ( ) ; logStartupInfo ( baseContext ) ; return jettyServer ; } catch ( Exception e ) { return logErrorAndExit ( e , exitOnError ) ; } }
public PlanItem ( String id , String definitionRef ) { this . id = id ; this . definitionRef = definitionRef ; }
public int hashCode ( ) { return ~~name . hashCode ( ) ; }
protected boolean copyObject ( String src , String dst ) { try { LOG . debug ( "Copying { } to { } " , src , dst ) ; mClient . copyObject ( mBucketNameInternal , src , mBucketNameInternal , dst ) ; return true ; } catch ( CosClientException e ) { LOG . error ( "Failed to rename file { } to { } " , src , dst , e ) ; return false ; } }
public RepositorySearchDialog ( Collection < String > existingDirs ) { this ( existingDirs , false , true ) ; }
public DelegatingResourceDescription getCreatableProperties ( ) { DelegatingResourceDescription description = super . getCreatableProperties ( ) ; if ( ! description . hasProperty ( "name" ) ) { description . addProperty ( "name" ) ; } if ( ! description . hasProperty ( "description" ) ) { description . addProperty ( "description" ) ; } description . addProperty ( "location" ) ; return description ; }
private JsonParser getParser ( String data ) throws IOException { char firstChar = data . charAt ( 0 ) ; if ( firstChar == ' { ' || firstChar == ' [ ' ) { return this . jsonFactory . createParser ( data ) ; } else { return this . yamlFactory . createParser ( data ) ; } }
public void testGenerateDroolsTestOption ( ) { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig ( ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; config . setGenerateDroolsTestOnError ( true ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isTrue ( ) ; config . setGenerateDroolsTestOnError ( Boolean . FALSE ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isFalse ( ) ; config . setGenerateDroolsTestOnError ( null ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; }
private RawText getRawText ( ObjectId id , Repository repo ) throws IOException { if ( id . equals ( ObjectId . zeroId ( ) ) ) { return new RawText ( new byte [ ] { } ) ; } return new RawText ( repo . openBlob ( id ) . getCachedBytes ( ) ) ; }
private static String getUserAgentSuffix ( ) { return " ; " + USER_AGENT_SUFFIX ; }
public Builder setDataSize ( Estimate dataSize ) { this . dataSize = dataSize ; return this ; }
public boolean isExpired ( Date invocationDate ) { return getExpires ( ) != null && getExpires ( ) . before ( invocationDate == null ? new Date ( ) : invocationDate ) ; }
public void stop ( ) { if ( isRunning ( ) ) { process . destroy ( ) ; try { if ( stdout != null ) { stdout . close ( ) ; } if ( stdin != null ) { stdin . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { running . set ( false ) ; } } }
public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof MacroId ) ) { return false ; } MacroId rhs = ( MacroId ) object ; return new EqualsBuilder ( ) . append ( getId ( ) , rhs . getId ( ) ) . append ( getSyntax ( ) , rhs . getSyntax ( ) ) . isEquals ( ) ; }
< START > public Map < String , Object > getExtraInformation ( ) { return extraInformation ; } < END > @Deprecated protected Map < String , Object > getExtraInformationDeprecated ( ) { return extraInformation ; }
public int hashCode ( ) { return Objects . hash ( pointer , ownerName , owner , readers , writers ) ; }
private String getFriendsPath ( SourcePathResolver sourcePathResolver , ImmutableList < SourcePath > friendPathsSourcePaths ) { ImmutableSortedSet < String > absoluteFriendPaths = ImmutableSortedSet . copyOf ( friendPathsSourcePaths . stream ( ) . map ( path - > sourcePathResolver . getAbsolutePath ( path ) . toString ( ) ) . collect ( Collectors . toSet ( ) ) ) ; if ( absoluteFriendPaths . isEmpty ( ) ) { return "" ; } return " - Xfriend - paths = " + absoluteFriendPaths . stream ( ) . reduce ( "" , ( path1 , path2 ) - > path1 + " , " + path2 ) ; }  The refactored code checks if the `absoluteFriendPaths` set is empty and returns an empty string if it is . This ensures that the ` - Xfriend - paths = ` option is not added when the list is empty .
public Target ( String targetUriAsString ) { Assert . hasText ( targetUriAsString , "The provided targetUriAsString must neither be null nor empty . " ) ; this . targetUri = URI . create ( targetUriAsString ) ; }
public PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition ) { this ( definition , PropertiesManager . getProperty ( definition . getTestValue ( ) , "" ) ) ; } private PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition , String regexExpression ) { super ( definition ) ; final String propertyName = definition . getTestValue ( ) ; if ( StringUtils . isBlank ( regexExpression ) ) { logger . error ( "Unable to find property name { } in portal . properties or has empty value . PAGS PropertyInvertedRegexTester will always return true for attribute { } " , propertyName , definition . getAttributeName ( ) ) ; } setPattern ( regexExpression ) ; }
public final boolean doesProvideNewPage ( ) { if ( provision == null ) { throw new IllegalStateException ( "Page instance not yet resolved" ) ; } return getProvision ( ) . doesProvideNewPage ( ) ; }
private synchronized Handler getHandler ( ) { if ( mHandler == null ) { mHandler = new Handler ( mContext . getMainLooper ( ) ) ; } return mHandler ; }
@Deprecated public void setDebugging ( boolean debugging ) { setIndicatorsEnabled ( debugging ) ; }
public List < ServerTemplate > load ( ) { synchronized ( store ) { return new ArrayList < > ( store . values ( ) ) ; } }
public String getLearnerMaster ( ) { QuorumPeer . QuorumServer learnerMaster = observer . getCurrentLearnerMaster ( ) ; if ( learnerMaster == null ) { return "Unknown" ; } InetSocketAddress address = learnerMaster . addr . getReachableOrOne ( ) ; return address . getAddress ( ) . getHostAddress ( ) + " : " + address . getPort ( ) ; }
default < R > Task < R > flatMap ( final String desc , final Function1 < ? super T , Task < R > > func ) { ArgumentUtil . requireNotNull ( func , "function" ) ; final Task < Task < R > > nested = map ( "map : " + desc , func ) ; nested . getShallowTraceBuilder ( ) . setSystemHidden ( true ) ; nested . getShallowTraceBuilder ( ) . setTaskType ( "nested" ) ; return flatten ( desc , nested ) ; }
protected List < String > findStringsInFileCommon ( String regexp , boolean stopOnFirst , int searchLimit , File fileToSearch ) { return findStringsInFileCommon ( regexp , stopOnFirst , searchLimit , fileToSearch , Project . MSG_INFO ) ; }
public void notifyAboutStartProcess ( String id ) { Long processInstanceId = Long . parseLong ( id ) ; newProcessInstanceEvent . fire ( new NewProcessInstanceEvent ( serverTemplateId , deploymentId , processInstanceId , processDefId , processName , null ) ) ; final String message = Constants . INSTANCE . ProcessStarted ( processInstanceId . longValue ( ) ) ; notificationEvent . fire ( new NotificationEvent ( message , NotificationEvent . NotificationType . SUCCESS ) ) ; close ( ) ; }
protected void process ( final SpaceReference source , final SpaceReference destination ) { visitDocuments ( source , new Visitor < DocumentReference > ( ) { @Override public void visit ( DocumentReference oldChildReference ) { DocumentReference newChildReference = oldChildReference . replaceParent ( source , destination ) ; maybeMove ( oldChildReference , newChildReference ) ; } } ) ; }
public void processEvent ( DiscoveryServiceEvent event ) { log . info ( "Process event { } " , event . getType ( ) ) ; switch ( event . getType ( ) ) { case DISCOVER_INIT_TOPOLOGY : startDiscovery ( ) ; break ; case ACQUIRE_LOCK : processLockAcquire ( ) ; break ; case RELEASE_LOCK : processLockRelease ( ) ; break ; case DISCOVERED_TOPOLOGY : processTopologyChangeNotification ( event ) ; break ; case UPGRADE : processUpgrade ( event ) ; break ; default : log . error ( "Invalid event type { } " , event . getType ( ) ) ; } }
public void deleteError ( final ProgramError error ) { errors . remove ( error ) ; eventBus . publish ( new ProgramErrorDeletedEvent ( error ) ) ; }
public LamiTableContentProvider ( ) { fCurrentEntries = Collections . emptyList ( ) ; }
public ArticlePageObject clickGetInfoLink ( ) { switchToIFrame ( ) ; try { waitForElementByElement ( getInfoLink ) ; // Opens new tab to Template namespace getInfoLink . click ( ) ; return new ArticlePageObject ( driver ) ; } finally { switchOutOfIFrame ( ) ; } }
@Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent ( ) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory ( ) ; factory . setAdviceChain ( new CacheInterceptor ( ) ) ; assertThat ( rabbitTracing . decorateSimpleRabbitListenerContainerFactory ( factory ) . getAdviceChain ( ) ) . hasSize ( 2 ) . matches ( adviceArray - > adviceArray [ 0 ] instanceof TracingRabbitListenerAdvice ) ; }
private static List < IResource > getReadonlyFiles ( IResource [ ] resources ) { List < IResource > readOnlyFiles = new ArrayList < > ( ) ; for ( int i = 0 ; i < resources . length ; i ++ ) { IResource resource = resources [ i ] ; ResourceAttributes resourceAttributes = resource . getResourceAttributes ( ) ; if ( resource . getType ( ) == IResource . FILE && resourceAttributes != null && resourceAttributes . isReadOnly ( ) ) { readOnlyFiles . add ( resource ) ; } } return readOnlyFiles ; }
void clean ( K key ) { getDataMap ( ) . remove ( key ) ; }
public static boolean isMemoryDeviceHotUnpluggable ( VmDevice memoryDevice ) { if ( ! isMemory ( memoryDevice ) ) { throw new IllegalArgumentException ( "Memory device expected but device " + memoryDevice + " obtained . " ) ; } return getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_SIZE ) . isPresent ( ) && getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_NODE ) . isPresent ( ) ; }
public boolean connectorExists ( String id ) { try { List < ConnectorConfiguration > list = configPersistence . load ( ImmutableMap . of ( Constants . CONNECTOR_PERSISTENT_ID , id ) ) ; if ( list . isEmpty ( ) ) { return false ; } return true ; } catch ( PersistenceException e ) { throw new RuntimeException ( "Unable to load the list of connector configurations" , e ) ; } }
public void testUpdateStmtBuilder ( ) { printStatement ( "update foo set \"column [ 'looks_like_nested' ] \" = 1" ) ; printStatement ( "update foo set foo . a = 'b'" ) ; printStatement ( "update bar . foo set bar . foo . t = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3 where foo [ 'x' ] = 2" ) ; printStatement ( "update schemah . foo set foo . a = 'b' , foo . b = foo . a" ) ; printStatement ( "update schemah . foo set foo . a = abs ( - 6 . 3334 ) , x = true where x = false" ) ; printStatement ( "update foo set foo = 'a' returning id" ) ; printStatement ( "update foo set foo = 'a' where x = false returning id" ) ; printStatement ( "update foo set foo = 'a' returning id AS foo" ) ; printStatement ( "update foo set foo = 'a' returning id + 1 AS foo , id - 1 as bar" ) ; } public void testUpdateStmtBuilderWithReturningClause ( ) { printStatement ( "update foo set foo = 'a' returning id" ) ; printStatement ( "update foo set foo = 'a' where x = false returning id" ) ; printStatement ( "update foo set foo = 'a' returning id AS foo" ) ; printStatement ( "update foo set foo = 'a' returning id + 1 AS foo , id - 1 as bar" ) ; }
public void setSetPath ( String path ) { Objects . requireNonNull ( path , "path is null" ) ; setPath . set ( path ) ; }
public EnvVars getEnvironment ( ) throws IOException , InterruptedException { EnvVars cachedEnvironment = this . cachedEnvironment ; if ( cachedEnvironment != null ) { return cachedEnvironment ; } cachedEnvironment = EnvVars . getRemote ( getChannel ( ) ) ; this . cachedEnvironment = cachedEnvironment ; return cachedEnvironment ; }

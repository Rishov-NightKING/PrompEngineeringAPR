public BatchServerInventoryView ( final ZkPathsConfig zkPaths , final CuratorFramework curator , final ObjectMapper jsonMapper , final Predicate < Pair < DruidServerMetadata , DataSegment > > defaultFilter ) { super ( log , zkPaths . getAnnouncementsPath ( ) , zkPaths . getLiveSegmentsPath ( ) , curator , jsonMapper , new TypeReference < Set < DataSegment > > ( ) { } ) ; this . defaultFilter = Preconditions . checkNotNull ( defaultFilter ) ; }
protected void configureEnvironment ( final ClusterEnvironment . Builder builder ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; objectMapper . registerModule ( new CouchbaseJacksonModule ( ) ) ; objectMapper . registerModule ( new JsonValueModule ( ) ) ; builder . jsonSerializer ( JacksonJsonSerializer . create ( objectMapper ) ) ; }
public void processLockAcquire ( ) { log . debug ( "Process lock acquire event" ) ; isLeader . set ( true ) ; onLeadershipAcquire ( ) ; }
public DhcpInfo getDhcpInfo ( ) { enforceAccessPermission ( ) ; if ( mVerboseLoggingEnabled ) { mLog . info ( "getDhcpInfo uid = % " ) . c ( Binder . getCallingUid ( ) ) . flush ( ) ; } return mClientModeImpl . syncGetDhcpInfo ( ) ; }
public void setUp ( ) throws Exception { connector = new TestDerbyConnector ( Suppliers . ofInstance ( new MetadataStorageConnectorConfig ( ) ) , Suppliers . ofInstance ( tablesConfig ) ) ; }
protected void sendHealthCheckResponse ( HttpServletResponse resp , HealthCheckResult result ) throws IOException { if ( result . healthy ) { resp . setStatus ( HttpServletResponse . SC_OK ) ; } else { resp . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; } sendResponse ( resp , result . toJson ( ) ) ; }
public DeviceInfoReturn attachManagedBlockStorageVolume ( Guid volumeId , Map < String , Object > connectionInfo ) { JsonRpcRequest request = new RequestBuilder ( "ManagedVolume . attach_volume" ) . withParameter ( "vol_id" , volumeId . toString ( ) ) . withParameter ( "connection_info" , connectionInfo ) . build ( ) ; Map < String , Object > response = new FutureMap ( this . client , request ) ; Map < String , Object > info = ( Map < String , Object > ) response . get ( "info" ) ; return new DeviceInfoReturn ( info ) ; }
public static void addHeaders ( final HttpMessage httpMessage , final Header . . . headers ) { Validate . notNull ( httpMessage , "HttpMessage must not be null" ) ; for ( final Header header : headers ) { if ( MantaHttpHeaders . REQUEST_ID . equals ( header . getName ( ) ) ) { continue ; } httpMessage . addHeader ( header ) ; } }
public String getServletMapping ( ) { if ( this . path . equals ( "" ) || this . path . equals ( " / " ) ) { return " / " ; } if ( this . path . endsWith ( " / " ) ) { return this . path + " * " ; } return this . path + " /* " ; }
private static InetAddress toInetAddress ( Slice ipAddress ) { try { return InetAddress . getByAddress ( ipAddress . getBytes ( ) ) ; } catch ( UnknownHostException e ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , "Invalid IP address binary : " + ipAddress . toStringUtf8 ( ) , e ) ; } }
public int hashCode ( ) { return Objects . hash ( sqls , sqlFirehoseDatabaseConnector , foldCase ) ; }
protected final List < ResultDocument > getSearchResults ( ExecutionContext ctx ) { // This should be called at all throw new IllegalStateException ( ) ; }
protected boolean isAppConfiguredInSourceServerXml ( String fileName ) { Set < String > locations = getAppConfigLocationsFromSourceServerXml ( ) ; if ( locations . contains ( fileName ) ) { log . debug ( "Application configuration is found in server . xml : " + fileName ) ; return true ; } else { return false ; } }
private DataCenter reInitializeDataCenter ( String dcId ) throws RuntimeException { log . warn ( "about to reinitialize dc" ) ; DataCenter dataCenter = new DataCenter ( ) ; dataCenter . setId ( dcId ) ; updateDataCenter ( dataCenter ) ; return dataCenter ; }
public void send ( Send request ) throws IOException { try { if ( ! connected ) { throw new ClosedChannelException ( ) ; } while ( ! request . isSendComplete ( ) ) { request . writeTo ( writeChannel ) ; } } finally { request . release ( ) ; } }
public void canParseNamedCaptureGroupsFromPattern ( ) { assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( "" ) , hasSize ( 0 ) ) ; assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( " ( ? < user > .* ) " ) , contains ( "user" ) ) ; assertThat ( RegexUtils . getNamedCaptureGroupsFromPattern ( "Node / ( ? < poolName > .* ? ) / ( ? < poolMember > \\S + ) address ( ? < poolAddr > \\S + ) monitor status down . .* \\ ( slot ( ? < slotNum > [ 0 - 9 ] + ) \\ ) " ) , contains ( "poolName" , "poolMember" , "poolAddr" , "slotNum" ) ) ; }
public void testActivateAppUnknownApp ( ) throws Exception { App app = when ( mock ( App . class ) . isActive ( ) ) . thenReturn ( false ) . getMock ( ) ; MvcResult result = mockMvc . perform ( post ( AppsController . URI + " / id / activate" ) ) . andReturn ( ) ; throw result . getResolvedException ( ) ; }
public void onReceive ( Context ctx , Intent intent ) { String action = intent . getAction ( ) ; switch ( action ) { case INSTALL_ACTION : // for play store devices only : // * invoke the receiver and open the page : // `adb shell am broadcast - a com . android . vending . INSTALL_REFERRER - n org . wikipedia . dev / org . wikipedia . analytics . InstallReceiver -- es "referrer" "referrer_url = https % 3A % 2F % 2Fen . wikipedia . org % 2Fwiki % 2FWombat & campaign_id = foo & install_id = bar"` // * invoke the receiver but don't open the app ( bad url ) : // `adb shell am broadcast - a com . android . vending . INSTALL_REFERRER - n org . wikipedia . dev / org . wikipedia . analytics . InstallReceiver -- es "referrer" "referrer_url = gibberish & campaign_id = foo & install_id = bar"` installReferrer ( ctx , intent ) ; break ; case Intent . ACTION_BOOT_COMPLETED : // `adb shell am broadcast - a android . intent . action . BOOT_COMPLETED` recordChannelId ( ctx ) ; break ; default : L . d ( "action = " + action ) ; break ; } }
private String getTokenToUse ( String authTokenCredentialId , String token ) { if ( ! StringUtils . isEmpty ( authTokenCredentialId ) ) { StringCredentials credentials = CredentialsObtainer . lookupCredentials ( authTokenCredentialId ) ; if ( credentials != null ) { logger . fine ( "Using Integration Token Credential ID . " ) ; return credentials . getSecret ( ) . getPlainText ( ) ; } } logger . fine ( "Using Integration Token . " ) ; return token ; }
void onGetBlobError ( Exception e , GetBlobOptions options ) { if ( options . getOperationType ( ) == GetBlobOptions . OperationType . BlobInfo ) { onGetBlobInfoError ( e ) ; } else { onGetBlobDataError ( e , options ) ; } }
public void setSelectedChapter ( @NonNull Chapter chapter ) { if ( mSelectedChapter != null ) { trackView ( ) ; } mSelectedChapter = chapter ; }
public void open ( GenericInputSplit split ) throws IOException { super . open ( split ) ; if ( serializableIter != null ) { it = serializableIter ; } else { it = this . dataSet . iterator ( ) ; } }
@Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; TextView tv = new TextView ( this ) ; tv . setText ( "Check logcat ! " ) ; setContentView ( tv ) ; printArgs ( "The" , "Quick" , "Brown" , "Fox" ) ; Log . i ( "Fibonacci" , "fibonacci's 4th number is " + fibonacci ( 4 ) ) ; Greeter greeter = new Greeter ( "Jake" ) ; Log . d ( "Greeting" , greeter . sayHello ( ) ) ; startSleepyThread ( ) ; }
private ContentValues ensureAfter ( ) { ContentValues values = mAfterContentValues ; if ( values == null ) { values = new ContentValues ( ) ; mAfterContentValues = values ; } return values ; }
private Task < ? extends Serializable > createDbTask ( Database dbObj ) { // note that we do not set location - for repl load , we want that auto - created . CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc ( dbObj . getName ( ) , dbObj . getDescription ( ) , null , false , updateDbProps ( dbObj , context . dumpDirectory ) ) ; // If it exists , we want this to be an error condition . Repl Load is not intended to replace a // db . // TODO : we might revisit this in create - drop - recreate cases , needs some thinking on . DDLWork2 work = new DDLWork2 ( new HashSet < > ( ) , new HashSet < > ( ) , createDbDesc ) ; return TaskFactory . get ( work , context . hiveConf ) ; }
public long writeTo ( Write writeChannel ) throws IOException { ReadableByteChannel readableByteChannel = Channels . newChannel ( streamToWrite ) ; writeChannel . appendFrom ( readableByteChannel , sizeToWrite ) ; return sizeToWrite ; }
static void addSnapshotJarToClassPath ( File jarFile , Path intermediateClassPath , FileSystem fs , Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory . final Path hdfsPath = new Path ( intermediateClassPath , jarFile . getName ( ) ) ; // Prevent uploading same file multiple times in same run . if ( ! fs . exists ( hdfsPath ) ) { uploadJar ( jarFile , hdfsPath , fs ) ; } job . addFileToClassPath ( hdfsPath ) ; }
public void start ( ComponentContext context ) { super . start ( context ) ; configs . forEach ( this : : createStreamIfNotExists ) ; processorDescriptors . forEach ( this : : initProcessor ) ; Framework . getRuntime ( ) . getComponentManager ( ) . addListener ( new ComponentsLifeCycleListener ( ) ) ; }
public void reportTaskStatus ( int id , Task . TaskStatus status , long miliseconds ) throws JMSException { TextMessage message = session . createTextMessage ( "task : " + propertiesBean . getProperty ( "engine . unique . id" ) + " : " + id + " : " + status + " : " + miliseconds ) ; producer . send ( message , DeliveryMode . PERSISTENT , 6 , 0 ) ; log . info ( " [ { } ] Task state { } sent to dispatcher . " , id , status ) ; }
public final BeanMetaData < T > getCurrentBeanMetaData ( ) { return currentBeanMetaData ; }
protected Object handleObjectGet ( ) throws Exception { String workspace = getAttribute ( "workspace" ) ; ServiceInfo service ; if ( workspace != null ) { WorkspaceInfo ws = geoServer . getCatalog ( ) . getWorkspaceByName ( workspace ) ; service = geoServer . getService ( ws , clazz ) ; } else { service = geoServer . getService ( clazz ) ; } if ( service == null ) { throw new RestletException ( "Service for workspace " + workspace + " does not exist" , Status . CLIENT_ERROR_NOT_FOUND ) ; } return service ; }
private static String buildHashedPayload ( HttpRequest request ) { try { byte [ ] unhashedBytes = request . getPayload ( ) == null ? "" . getBytes ( ) : ByteStreams . toByteArray ( request . getPayload ( ) . getInput ( ) ) ; return sha256 ( unhashedBytes ) ; } catch ( IOException e ) { throw new HttpException ( "Error signing request" , e ) ; } }
public Map < Long , EventDefinition > getEventDefs ( StreamInput id ) { return new HashMap < Long , EventDefinition > ( ) ; }
public void testSetTitleIconStartMargin ( ) throws Throwable { int startMargin = 100 ; int navIconWidth = 100 ; mActivityRule . runOnUiThread ( ( ) - > { mToolbar . setNavigationIconContainerWidth ( navIconWidth ) ; mToolbar . setTitleIcon ( android . R . drawable . sym_def_app_icon ) ; mToolbar . setTitleIconStartMargin ( startMargin ) ; } ) ; onView ( withId ( R . id . title_icon ) ) . check ( matches ( withLeft ( navIconWidth + startMargin ) ) ) ; }
Publisher < CoreEvent > getDownstreamPublisher ( ) { return downstreamFlux . compose ( downstreamPublisher - > subscriberContext ( ) . flatMapMany ( downstreamContext - > downstreamPublisher . doOnSubscribe ( s - > { innerFlux . subscriberContext ( downstreamContext ) . subscribe ( ) ; upstreamFlux . subscriberContext ( downstreamContext ) . subscribe ( ) ; } ) ) ) ; }
public void onFailure ( Throwable t ) { log . error ( "Unable to RefreshCapabilities : { } " , ExceptionUtils . getRootCauseMessage ( t ) ) ; log . debug ( "Exception" , t ) ; postProcessRefresh ( false ) ; }
public CountsComputer ( long lastCommittedTransactionId , NodeStore nodes , RelationshipStore relationships , int highLabelId , int highRelationshipTypeId ) { this ( lastCommittedTransactionId , nodes , relationships , highLabelId , highRelationshipTypeId , SilentMigrationProgressMonitor . NO_OP_SECTION ) ; }
public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements ( List < InternalSyntaxToken > commaTokens ) { return new ArrayLiteralTreeImpl ( new ArrayList < Tree > ( commaTokens ) ) ; }
public void onSuccess ( ) { log . debug ( "Command succeeded , releasing macs { } . " , super . macs ) ; releaseMacs ( ) ; }
public SubresourceParameter ( String value ) { super ( "t" , value ) ; }
private boolean isExpired ( long expirationTimeInMs , long referenceTimeInMs ) { return expirationTimeInMs != Utils . Infinite_Time && expirationTimeInMs < referenceTimeInMs ; }
public void testEncodeSpatial ( ) throws Exception { Document doc = encode ( FilterMockData . intersects ( ) , FES . Filter ) ; assertEquals ( "fes : Filter" , doc . getDocumentElement ( ) . getNodeName ( ) ) ; Element e = getElementByQName ( doc , FES . Intersects ) ; assertNotNull ( e ) ; assertNotNull ( getElementByQName ( e , FES . ValueReference ) ) ; assertNotNull ( getElementByQName ( e , GML . Point ) ) ; }
public View getTopContainer ( final View view ) { View topView = null ; if ( view != null ) { EObject container = view . eContainer ( ) ; if ( isStereotypeCompartment ( container ) || isStereotypeBrace ( container ) || isStereotypeLabel ( container ) ) { container = container . eContainer ( ) ; } if ( container instanceof View ) { topView = ( View ) container ; } } return topView ; }
public StreamDeployer ( ZooKeeperConnection zkConnection , StreamDefinitionRepository repository , StreamRepository streamRepository , XDParser parser ) { super ( zkConnection , repository , streamRepository , parser , stream ) ; this . zkConnection = zkConnection ; this . parser = parser ; }
public String toString ( ) { return "ScopedKey { scope = " + scope + " , key = " + key + " } " ; }
private static String left ( String str , int len ) { if ( len > 0 ) { return str . substring ( 0 , Math . min ( len , str . length ( ) ) ) ; } final int finalLen = str . length ( ) + len ; return finalLen > 0 ? str . substring ( 0 , finalLen ) : "" ; }
public ResponseEntity addRole ( @RequestBody @Validated RoleForm roleForm , BindingResult bindingResult , @RequestHeader ( HttpHeaders . ACCEPT ) String acceptHeader ) { if ( bindingResult . hasErrors ( ) ) { throw new RequestBodyValidationException ( FAILED_ADD_ROLE , bindingResult ) ; } Role role = conversionService . convert ( roleForm , Role . class ) ; return processConfig ( config - > addRole ( config , role ) , ( ) - > SUCCESSFUL_ADD_ROLE , acceptHeader ) ; }
AbstractJsonGetter ( Getter parent ) { super ( parent ) ; }
NumaValidator ( VdsNumaNodeDao vdsNumaNodeDao ) { this . vdsNumaNodeDao = Objects . requireNonNull ( vdsNumaNodeDao ) ; }
public List < ClientModel > getClients ( ) { return session . realms ( ) . getClients ( this ) ; }
public List < String > getTokens ( ) { List < String > ret = new ArrayList < String > ( tokenCount ) ; for ( int i = 0 ; i < tokenCount ; i ++ ) { ret . add ( getToken ( i ) ) ; } return ret ; }
public EndpointAffinity ( final DrillbitEndpoint endpoint , final double affinity , final boolean mandatory , final int maxWidth ) { Preconditions . checkArgument ( maxWidth >= 1 , "MaxWidth for given endpoint should be at least one . " ) ; this . endpoint = endpoint ; this . affinity = affinity ; this . mandatory = mandatory ; this . maxWidth = maxWidth ; }
public void run ( ) { LOG . debug ( "BacklogMetricEmitter running for entities" ) ; executor = new ScheduledThreadPoolExecutor ( 10 ) ; List < Future > futures = new ArrayList < > ( ) ; try { for ( Entity entity : entityBacklogs . keySet ( ) ) { futures . add ( executor . submit ( new BacklogCalcService ( entity , entityBacklogs . get ( entity ) ) ) ) ; } waitForFuturesToComplete ( futures ) ; } finally { executor . shutdown ( ) ; } }
public void onBackPressed ( ) { projectListFragment . cancelLoadProjectTask ( ) ; super . onBackPressed ( ) ; }
private void changeStatus ( DestroyVmVDSCommandParameters parameters , VM curVm ) { // do the state transition only if that VM is really running on SRC if ( getParameters ( ) . getVdsId ( ) . equals ( curVm . getRunOnVds ( ) ) ) { ResourceManager . getInstance ( ) . InternalSetVmStatus ( curVm , parameters . getGracefully ( ) ? VMStatus . PoweringDown : VMStatus . Down ) ; } }
private TransactionQuery ( Selection selection , Publisher publisher , Optional < String > contentUri , Optional < String > transactionId , Optional < TransactionStateType > transactionStatus ) { this . selection = checkNotNull ( selection ) ; this . publisher = checkNotNull ( publisher ) ; this . contentUri = checkNotNull ( contentUri ) ; this . transactionId = checkNotNull ( transactionId ) ; this . transactionStatus = checkNotNull ( transactionStatus ) ; }
private static boolean appendPort ( final String scheme , final int port ) { return port > - 1 && ( ( HTTP . equalsIgnoreCase ( scheme ) && port != 80 ) || ( HTTPS . equalsIgnoreCase ( scheme ) && port != 443 ) ) ; }
public void addPage ( BenchmarkData data ) { PartitionedOutputOperator operator = data . createPartitionedOutputOperator ( ) ; for ( int i = 0 ; i < data . getPageCount ( ) ; i ++ ) { operator . addInput ( data . getDataPage ( ) ) ; } operator . finish ( ) ; }
private Element timeZone ( ) { return textElement ( TIMEZONE , entity . getTimeZone ( ) ) ; }
private DbUser getDbUserForPrincipalName ( String principalName , String authzName ) { ExtMap principalRecord = AuthzUtils . fetchPrincipalRecord ( EngineExtensionsManager . getInstance ( ) . getExtensionByName ( authzName ) , principalName , false , false ) ; if ( principalRecord == null ) { throw new RuntimeException ( String . format ( "Unable to find principal % s in domain ' % s'" , principalName , authzName ) ) ; } return new DbUser ( DirectoryUtils . mapPrincipalRecordToDirectoryUser ( authzName , principalRecord ) ) ; }
public PatternScatterGraphView ( ) { super ( ID ) ; this . addPartPropertyListener ( event - > { if ( event . getProperty ( ) . equals ( TmfXmlStrings . XML_LATENCY_OUTPUT_DATA ) ) { Object newValue = event . getNewValue ( ) ; if ( newValue instanceof String ) { String data = ( String ) newValue ; fViewInfo . setViewData ( data ) ; setPartName ( fViewInfo . getLabel ( ) ) ; loadLatencyView ( ) ; } } } ) ; }
public void setMaxSpeed ( double maxSpeed ) { if ( maxSpeed > this . maxSpeed ) { this . maxSpeed = maxSpeed ; } }
Object getValue ( Object obj ) { throw new HazelcastException ( "Path agnostic value extraction is not supported" ) ; }
public boolean apply ( Resource resource ) { Predicate < EObject > hasOuterRef = new EObjectHasReferencesTo ( modifiedResources ) ; return Iterators . any ( EcoreUtil . < EObject > getAllProperContents ( resource , false ) , hasOuterRef ) ; }
private URI endSessionEndpoint ( OAuth2AuthenticationToken token ) { String registrationId = token . getAuthorizedClientRegistrationId ( ) ; ClientRegistration clientRegistration = this . clientRegistrationRepository . findByRegistrationId ( registrationId ) ; URI result = null ; if ( clientRegistration != null ) { Object endSessionEndpoint = clientRegistration . getProviderDetails ( ) . getConfigurationMetadata ( ) . get ( "end_session_endpoint" ) ; if ( endSessionEndpoint != null ) { result = URI . create ( endSessionEndpoint . toString ( ) ) ; } } return result ; }
public AddUnseenToBitmapFilter ( BitmapBuilder seen , BitmapBuilder bitmap ) { this . seen = seen ; this . bitmap = bitmap ; }
public void testQuantileAtValueBigint ( ) { QuantileDigest qdigest = new QuantileDigest ( 1 ) ; addAll ( qdigest , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; functionAssertions . assertFunction ( format ( "quantile_at_value ( CAST ( X' % s' AS qdigest ( bigint ) ) , 20 ) " , toHexString ( qdigest ) ) , DOUBLE , null ) ; functionAssertions . assertFunction ( format ( "quantile_at_value ( CAST ( X' % s' AS qdigest ( bigint ) ) , 6 ) " , toHexString ( qdigest ) ) , DOUBLE , 0 . 6 ) ; functionAssertions . assertFunction ( format ( "quantile_at_value ( CAST ( X' % s' AS qdigest ( bigint ) ) , - 1 ) " , toHexString ( qdigest ) ) , DOUBLE , null ) ; }
public boolean isOverutilized ( ) { return memoryManager . isOverutilized ( ) ; }
public String explain ( ) throws CouchbaseLiteException { synchronized ( getDatabase ( ) . getLock ( ) ) { check ( ) ; return c4query . explain ( ) ; } }
public boolean isObjectFactory ( ) { return false ; }
public StandardRotationPolicy ( DelegatingSessionFactory < ? > factory , List < KeyDirectory > keyDirectories , boolean fair ) { Assert . notNull ( factory , "factory cannot be null" ) ; Assert . notNull ( keyDirectories , "keyDirectories cannot be null" ) ; Assert . isTrue ( keyDirectories . size ( ) > 0 , "At least one KeyDirectory is required" ) ; this . factory = factory ; this . keyDirectories . addAll ( keyDirectories ) ; this . fair = fair ; this . iterator = this . keyDirectories . iterator ( ) ; }
public void add ( EntityType entity ) { createAcl ( entity ) ; super . add ( entity ) ; }
private ArtifactCoordinates getArtifactCoordinates ( Path p ) throws IOException { return RepositoryFiles . readCoordinates ( ( RepositoryPath ) p ) ; }
public < T extends ActivityNode > IPinUpdater < T > instantiate ( ActivityNode node ) { IPinUpdater < T > updater = null ; if ( node instanceof CallBehaviorAction ) { updater = ( IPinUpdater < T > ) new CallBehaviorActionPinUpdater ( ) ; } else if ( node instanceof CallOperationAction ) { updater = ( IPinUpdater < T > ) new CallOperationActionPinUpdater ( ) ; } else if ( node instanceof SendSignalAction ) { updater = ( IPinUpdater < T > ) new SendSignalActionPinUpdater ( ) ; } return updater ; }
public boolean supportsScroll ( ) { StorageConfiguration conf = coreFeature . getStorageConfiguration ( ) ; // DBS mem and marklogic are not yet supported return ( conf . isDBSMongoDB ( ) || conf . isVCS ( ) ) ; }
public void onResume ( ) { super . onResume ( ) ; addCachedDevices ( ) ; if ( mLocalAdapter . getBluetoothState ( ) != BluetoothAdapter . STATE_ON ) { removeAllDevices ( ) ; } if ( mStartScanOnResume ) { mLocalAdapter . startScanning ( true ) ; mStartScanOnResume = false ; } }
protected void upgradeNexusVersion ( ) throws IOException { final String currentVersion = checkNotNull ( applicationStatusSource . getSystemStatus ( ) . getVersion ( ) ) ; final String previousVersion = getConfiguration ( ) . getNexusVersion ( ) ; if ( currentVersion . equals ( previousVersion ) ) { setInstanceUpgraded ( false ) ; } else { setInstanceUpgraded ( true ) ; getConfiguration ( ) . setNexusVersion ( currentVersion ) ; storeConfiguration ( ) ; } }
public DefDeclaration ( String name , Type returnType , List < NameBinding > argNames , TypedAST body , boolean isClassDef , FileLocation location ) { this ( name , returnType , null , argNames , body , isClassDef , location ) ; }
public Waiter < HeadBucketRequest > bucketNotExists ( ) { return new WaiterBuilder < HeadBucketRequest , HeadBucketResult > ( ) . withSdkFunction ( new HeadBucketFunction ( client ) ) . withAcceptors ( new HttpFailureStatusAcceptor < HeadBucketResult > ( 404 , WaiterState . SUCCESS ) ) . withDefaultPollingStrategy ( new PollingStrategy ( new MaxAttemptsRetryStrategy ( 20 ) , new FixedDelayStrategy ( 5 ) ) ) . withExecutorService ( executorService ) . build ( ) ; }
public TextArea createWidget ( ) { final TextArea textArea = GWT . create ( TextArea . class ) ; textArea . addMouseDownHandler ( DomEvent : : stopPropagation ) ; return textArea ; }
public void testHierarchyView ( ) { DockerImagesTab imageTab = openDockerImagesTab ( ) ; buildImage ( IMAGE_TEST_BUILD , DOCKERFILE_FOLDER , imageTab ) ; if ( mockitoIsUsed ( ) ) { buildImage ( ) ; } DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab ( ) ; List < TreeItem > treeItems = hierarchyTab . getTreeItems ( ) ; compareTextInFirstNode ( treeItems , "alpine : 3 . 3" ) ; List < TreeItem > treeItems2 = treeItems . get ( 0 ) . getItems ( ) ; compareTextInFirstNode ( treeItems2 , IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST ) ; }
private void doBadOffsetInputTest ( String name , long offset ) { try { new Offset ( name , offset ) ; fail ( "Should have thrown because one of the inputs is invalid" ) ; } catch ( IllegalArgumentException e ) { // expected . } }
private void enablePhiro ( ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; if ( ! sharedPreferences . getBoolean ( PHIRO_INITIALIZED , false ) ) { BaseSettingsActivity . setPhiroSharedPreferenceEnabled ( this , true ) ; sharedPreferences . edit ( ) . putBoolean ( PHIRO_INITIALIZED , true ) . apply ( ) ; } }
private void checkReturnedValue ( ReturnStatementTree tree , String nonNullAnnotation ) { SymbolicValue returnedValue = programState . peekValue ( ) ; Constraint constraint = programState . getConstraint ( returnedValue ) ; if ( constraint != null && constraint . isNull ( ) ) { reportIssue ( tree , "This method''s return value is marked \" { 0 } \" but null is returned . " , nonNullAnnotation ) ; } }
private void verifyEditResultCode ( EditingResult result ) { assertThat ( result . getResult ( ) , is ( SUCCESS ) ) ; }
public EnginesPreferencePage ( ) { super ( ) ; }
public List < AmbryReplica > getReplicaIds ( ) { return clusterManagerCallback . getReplicaIdsForPartition ( this ) ; }
private String blockingSSLConnect ( int socketBufSize ) throws IOException { String connectionId = selector . connect ( new InetSocketAddress ( "localhost" , server . port ) , socketBufSize , socketBufSize , PortType . SSL ) ; while ( ! selector . connected ( ) . contains ( connectionId ) ) { selector . poll ( 10000L ) ; } return connectionId ; }
public EDDifferentialPrivacy ( double epsilon , double delta , DataGeneralizationScheme generalization ) { this ( epsilon , delta , generalization , false ) ; }
private final String getSessionIndex ( Assertion subjectAssertion ) { List < AuthnStatement > authnStatements = subjectAssertion . getAuthnStatements ( ) ; if ( authnStatements != null && authnStatements . size ( ) > 0 ) { AuthnStatement statement = authnStatements . get ( 0 ) ; if ( statement != null ) { return statement . getSessionIndex ( ) ; } } return null ; }
public void visitNode ( Tree tree ) { if ( ! hasSemantic ( ) ) { return ; } MethodTree method = ( MethodTree ) tree ; if ( method . block ( ) != null && INPUT_STREAM_READ . matches ( method ) ) { method . accept ( new ReturnStatementVisitor ( ) ) ; } }
protected void onFinishInflate ( ) { super . onFinishInflate ( ) ; View . inflate ( getContext ( ) , R . layout . merge_login_view , this ) ; loginButton = Views . findById ( this , R . id . sign_in_button ) ; }
private static int encode ( int bucketIndex , int value ) { return ( bucketIndex < < VALUE_BITS ) | value ; }
public void onUberfireDocksInteractionEvent ( @Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent ) { if ( isUberfireDocksInteractionEventToManage ( uberfireDocksInteractionEvent ) && ! TestToolsPresenter . IDENTIFIER . equals ( uberfireDocksInteractionEvent . getTargetDock ( ) . getIdentifier ( ) ) ) { populateRightDocks ( uberfireDocksInteractionEvent . getTargetDock ( ) . getIdentifier ( ) ) ; } }
public String getDocType ( ) { if ( Objects . isNull ( docType ) && ! allDocTypes . isEmpty ( ) ) { setDocType ( ( String ) allDocTypes . get ( 0 ) . getValue ( ) ) ; } return docType ; }
public boolean shouldUseCommitTemplate ( ) { return getCommitMessage ( ) == null && getCommitTemplate ( ) . isPresent ( ) ; }
public void waitUntilAllBlocked ( ) throws InterruptedException { _blockersDoneLatch . await ( ) ; }
private static boolean hasMatrixParam ( List < PathSegment > pathSegments , String param ) { if ( pathSegments != null ) for ( PathSegment segement : pathSegments ) { MultivaluedMap < String , String > matrixParams = segement . getMatrixParameters ( ) ; if ( matrixParams != null && ! matrixParams . isEmpty ( ) && matrixParams . containsKey ( param ) ) return true ; } return false ; }
public void setAttached ( boolean attached ) { this . attached = attached ; }
public void visited ( RevObject o ) { lowestDepthVisited . put ( o , Integer . valueOf ( walk . getTreeDepth ( ) ) ) ; }
private List < Object [ ] > convertIntegerToLong ( List < Object [ ] > list , int index ) { for ( Object [ ] item : list ) { item [ index ] = ( long ) item [ index ] ; } return list ; }
private void flushAll ( ) throws AuthException { for ( DynamicMap . Entry < Cache < ? , ? > > e : cacheMap ) { CacheResource cacheResource = new CacheResource ( e . getPluginName ( ) , e . getExportName ( ) , e . getProvider ( ) ) ; if ( FlushCache . WEB_SESSIONS . equals ( cacheResource . getName ( ) ) ) { continue ; } flushCache . apply ( cacheResource , null ) ; } }
public static Map < String , IAnalysisModule > getAnalysisModules ( ) { synchronized ( fAnalysisModules ) { if ( fAnalysisModules . isEmpty ( ) ) { TmfAnalysisType analysis = TmfAnalysisType . getInstance ( ) ; List < IAnalysisModule > modules = analysis . getAnalysisModules ( ) ; for ( IAnalysisModule module : modules ) { fAnalysisModules . add ( module ) ; } } } return getExecutableModules ( ) ; }
void validateValueParameter ( String name , Object value ) { final Class < ? extends IValueValidator > validators [ ] = wrappedParameter . validateValueWith ( ) ; if ( validators != null && validators . length > 0 ) { for ( final Class < ? extends IValueValidator > validator : validators ) { validateValueParameter ( validator , name , value ) ; } } }
public final < C > Stream < Match > match ( Object object , Captures captures , C context ) { if ( previous . isPresent ( ) ) { return previous . get ( ) . match ( object , captures , context ) . flatMap ( match - > accept ( object , match . captures ( ) , context ) ) ; } else { return accept ( object , captures , context ) ; } }
public ArticlePageObject savePage ( ) { waitForElementInViewPort ( editSummary ) ; waitForElementInViewPort ( reviewChangesButton ) ; waitForElementVisibleByElement ( savePanel ) ; publishButton . click ( ) ; return new ArticlePageObject ( driver ) ; }
public void executeCommand ( CommandSender sender , List < String > arguments ) { // Get the list of banned players Set < OfflinePlayer > bannedPlayers = bukkitService . getBannedPlayers ( ) ; Set < String > namedBanned = new HashSet < > ( bannedPlayers . size ( ) ) ; for ( OfflinePlayer offlinePlayer : bannedPlayers ) { namedBanned . add ( offlinePlayer . getName ( ) ) ; } purgeService . purgePlayers ( sender , namedBanned , bannedPlayers . toArray ( new OfflinePlayer [ bannedPlayers . size ( ) ] ) ) ; }
protected static Keyspace getKeyspace ( ) { return keyspace ; }
void setNewElementYPosition ( final Element elementReference , final Element newElement ) { final int referencePosition = getDndListComponent ( ) . getPositionY ( elementReference ) ; getDndListComponent ( ) . setPositionY ( newElement , referencePosition ) ; }
public void layoutTopRight ( CTabFolder ctf ) { Composite trComp = getTRComposite ( ctf ) ; if ( trComp . getChildren ( ) . length > 0 ) { trComp . setVisible ( true ) ; ctf . setTopRight ( trComp , SWT . RIGHT | SWT . WRAP ) ; } else { ctf . setTopRight ( null ) ; trComp . setVisible ( false ) ; } trComp . pack ( ) ; trComp . layout ( true , true ) ; }
ByteBuf buffer ( ) throws IOException { if ( buf == null ) { buf = Netty4Utils . toByteBuf ( context . get ( ) ) ; context = null ; } assert context == null ; return buf ; }
public String getName ( ) { String name = super . getName ( ) ; if ( StringUtils . isEmpty ( name ) ) { return "" ; } else { return name ; } }
private void verifyInvalidValueSize ( IndexValue value , String logSegmentName ) { int capacity = TestUtils . RANDOM . nextInt ( value . getBytes ( ) . capacity ( ) ) ; ByteBuffer invalidValue = ByteBuffer . allocate ( capacity ) ; invalidValue . put ( value . getBytes ( ) . array ( ) , 0 , capacity ) ; try { new IndexValue ( logSegmentName , invalidValue , version ) ; fail ( "Contruction of IndexValue expected to fail with invalid byte buffer capacity of " + invalidValue . capacity ( ) ) ; } catch ( IllegalArgumentException e ) { } }
void dispose ( ) { session = null ; if ( semanticResourcesUpdater != null ) { semanticResourcesUpdater . dispose ( ) ; semanticResourcesUpdater = null ; } }
public void deleteByContentType ( final ContentTypeIf type ) throws DotDataException { new DotConnect ( ) . setSQL ( sql . DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE ) . addParam ( type . id ( ) ) . addParam ( type . id ( ) ) . loadResults ( ) ; }
public int getUniqueNotificationId ( ) { return uniqueNotificationIdCounter . incrementAndGet ( ) ; }
public void run ( ) { // Loops till QueueProcessorThread is shutdown while ( ! shutdown ) { synchronized ( this ) { try { // start processing queue if active , other wait for sometime if ( isActive ) { processQueuedFlows ( activeExecutorRefreshWindowInMilisec , activeExecutorRefreshWindowInFlows ) ; } wait ( QUEUE_PROCESSOR_WAIT_IN_MS ) ; } catch ( Exception e ) { logger . error ( "QueueProcessorThread Interrupted . Probably to shut down . " , e ) ; } } } }
public HllSketchMergeBufferAggregator ( final ColumnValueSelector < HllSketch > selector , final int lgK , final TgtHllType tgtHllType , final int size ) { this . selector = selector ; this . lgK = lgK ; this . tgtHllType = tgtHllType ; this . size = size ; this . emptyUnion = new byte [ size ] ; // noinspection ResultOfObjectAllocationIgnored ( Union writes to "emptyUnion" as a side effect of construction ) new Union ( lgK , WritableMemory . wrap ( emptyUnion ) ) ; }
public void checkIPAdress ( ) { Set < ConstraintViolation < IPAdress > > validate = validator . validate ( new IPAdress ( address ) ) ; assertEquals ( expectedResult , validate . isEmpty ( ) ) ; }
public void onItemSelected ( AdapterView < ? > parent , View view , int pos , long id ) { // Ignore first call , which comes from onCreate ( ) if ( currentFormat != null && ! calc ( ) ) { // An error occurred , reset spinner to current format spinner . setSelection ( currentFormat . ordinal ( ) ) ; return ; } currentFormat = coordInputFormatEnum . fromInt ( pos ) ; settings . setCoordInputFormat ( currentFormat ) ; updateGUI ( ) ; }
private void visitTableWithType ( String schemaName , String tableName , TableType type ) { Preconditions . checkNotNull ( type , "Error . Type information for table % s . % s provided is null . " , schemaName , tableName ) ; records . add ( new Records . Table ( IS_CATALOG_NAME , schemaName , tableName , type . toString ( ) ) ) ; return ; }
public boolean add ( XWikiAttachment attachment ) { XWikiAttachment set = set ( attachment ) ; return set != attachment ; }
public String toString ( ) { return Objects . toStringHelper ( this ) . add ( "capacityBytes" , mCapacityBytes ) . add ( "capacityBytesOnTiers" , mCapacityBytesOnTiers ) . add ( "freeBytes" , mFreeBytes ) . add ( "liveWorkerNum" , mLiveWorkerNum ) . add ( "lostWorkerNum" , mLostWorkerNum ) . add ( "usedBytes" , mUsedBytes ) . add ( "usedBytesOnTiers" , mUsedBytesOnTiers ) . toString ( ) ; }
public static final void assertJenkinsNotInQuietMode ( final JenkinsRule j ) { await ( ) . pollInterval ( 250 , TimeUnit . MILLISECONDS ) . atMost ( 10 , TimeUnit . SECONDS ) . until ( ( ) - > ! j . jenkins . getQueue ( ) . isBlockedByShutdown ( task ) ) ; }
private TreeLayer getTreeLayer ( ) throws Exception { NatTable natTable = ( NatTable ) getTableManager ( ) . getAdapter ( NatTable . class ) ; ILayer layer = natTable . getLayer ( ) ; if ( layer instanceof PapyrusGridLayer ) { PapyrusGridLayer gridLayer = ( PapyrusGridLayer ) layer ; ILayer rowLayer = gridLayer . getRowHeaderLayer ( ) ; if ( rowLayer instanceof RowHeaderHierarchicalLayerStack ) { return ( ( RowHeaderHierarchicalLayerStack ) rowLayer ) . getTreeLayer ( ) ; } } throw new UnknownError ( "TreeLayer has not been found" ) ; // $NON - NLS - 1$ }
public boolean equals ( @Nullable Object obj ) { if ( ! ( obj instanceof DataDrivenValueSelf ) ) { return false ; } return super . equals ( obj ) ; }
public void differentUrlForPostsAndVideo ( ) { SearchInput searchInput = new SearchInput ( ) . searchInputValue ( ) ; SearchInput searchInputSubmit = new SearchInput ( ) . searchInputSubmit ( ) ; SearchInput postsResult = new SearchInput ( ) . searchResultsPosts ( ) ; String postUrl = driver . getCurrentUrl ( ) ; SearchInput videosResult = new SearchInput ( ) . searchResultsVideos ( ) ; String videoUrl = driver . getCurrentUrl ( ) ; Assert . assertNotEquals ( postUrl , videoUrl ) ; }
protected String convert ( Blob blob ) { if ( blob . getLength ( ) == 0L ) { return "" ; } try ( InputStream stream = blob . getStream ( ) ) { Xml2TextHandler xml2text = new Xml2TextHandler ( ) ; return xml2text . parse ( stream ) ; } catch ( IOException | SAXException | ParserConfigurationException e ) { throw new ConversionException ( "Error during XML2Text conversion" , blob , e ) ; } }
static void validateHeaderConfigAction ( String action ) { if ( ! HEADER_ACTIONS . stream ( ) . anyMatch ( action : : equalsIgnoreCase ) ) { throw new ConfigException ( String . format ( "Invalid header config action : ' % s' . " + "Expected one of % s" , action , HEADER_ACTIONS ) ) ; } }
private String getVariableLabel ( VariableMetadata variableMetadata ) { if ( variableMetadata . getName ( ) . startsWith ( CASE_VARIABLE_PREFIX ) ) { return translationService . getValue ( CASE_VARIABLE_LABEL_PREFIX ) + " " + variableMetadata . getName ( ) . substring ( CASE_VARIABLE_PREFIX . length ( ) ) ; } else { return variableMetadata . getName ( ) ; } }
private Long findFreeId ( ) { while ( personRepository . exists ( lastId ) ) { // New person lastId ++ ; } return lastId ; }
public void cameraDeviceCallsAreForwardedToCallback ( ) throws InterruptedException { mUseCase . addStateChangeListener ( mCameraRepository . getCamera ( getCameraIdForLensFacingUnchecked ( mConfig . getLensFacing ( ) ) ) ) ; mUseCase . doNotifyActive ( ) ; mCameraRepository . onGroupActive ( mUseCaseGroup ) ; // Wait for the CameraDevice . onOpened callback . mUseCase . mDeviceStateCallback . waitForOnOpened ( 1 ) ; mCameraRepository . onGroupInactive ( mUseCaseGroup ) ; // Wait for the CameraDevice . onClosed callback . mUseCase . mDeviceStateCallback . waitForOnClosed ( 1 ) ; }
public String getDescription ( ) { return getStatuteType ( ) . getName ( ) . getContent ( ) + ( studentStatute instanceof SeniorStatute ? ( " ( " + ( ( SeniorStatute ) studentStatute ) . getRegistration ( ) . getDegree ( ) . getPresentationName ( ) + " ) " ) : "" ) ; }
protected boolean teleportToSpawn ( ) { Location target = server . getWorlds ( ) . get ( 0 ) . getSpawnLocation ( ) ; EntityPortalEvent event = EventFactory . callEvent ( new EntityPortalEvent ( this , location . clone ( ) , target , null ) ) ; if ( event . isCancelled ( ) ) { return false ; } target = event . getTo ( ) ; teleport ( target ) ; return true ; }
public String [ ] getGroupFilters ( ) { IBeforeMethod before = m_annotationFinder . findAnnotation ( getConstructorOrMethod ( ) , IBeforeMethod . class ) ; if ( before == null ) { return new String [ 0 ] ; } return before . getGroupFilters ( ) ; }
PageCacheNumberArray ( PagedFile pagedFile , int entrySize , long length , long defaultValue , long base ) throws IOException { this . pagedFile = pagedFile ; this . entrySize = entrySize ; this . entriesPerPage = pagedFile . pageSize ( ) / entrySize ; this . length = length ; this . defaultValue = defaultValue ; this . base = base ; try ( PageCursor cursorToSetLength = pagedFile . io ( 0 , PF_SHARED_WRITE_LOCK ) ) { setLength ( cursorToSetLength , length ) ; } if ( defaultValue != 0 ) { setDefaultValue ( defaultValue ) ; } }
public InterpretedPageProjectionOutput ( DriverYieldSignal yieldSignal , Page page , SelectedPositions selectedPositions ) { this . yieldSignal = requireNonNull ( yieldSignal , "yieldSignal is null" ) ; this . blocks = requireNonNull ( page , "page is null" ) . getBlocks ( ) ; this . selectedPositions = requireNonNull ( selectedPositions , "selectedPositions is null" ) ; this . nextIndexOrPosition = selectedPositions . getOffset ( ) ; }
public String getDicomViewerUrl ( Study study ) { if ( study == null ) throw new IllegalArgumentException ( "study cannot be null" ) ; else if ( study . getStudyInstanceUid ( ) == null ) throw new IllegalArgumentException ( "studyInstanceUid cannot be null" ) ; return radiologyProperties . getDicomViewerUrl ( ) + "studyUID = " + study . getStudyInstanceUid ( ) ; }
private Declaration getDeclarationCorrespondingToXpath ( Pattern pattern , boolean isXPath , Constraint constraint ) { if ( ! isXPath && pattern . hasXPath ( ) ) { Declaration xPathDecl = pattern . getXPathDeclaration ( ) ; if ( xPathDecl != null ) { for ( Declaration decl : constraint . getRequiredDeclarations ( ) ) { if ( xPathDecl . equals ( decl ) ) { return decl ; } } } } return null ; }
public void setQueryTimeout ( int seconds ) throws AlreadyClosedSqlException , SQLException { throwIfClosed ( ) ; super . setQueryTimeout ( seconds ) ; }
private List < DiskImage > manualAggregateSnapshots ( ) { DiskImage diskWithSnaps = diskWithSnapshots ; diskWithSnaps . getSnapshots ( ) . addAll ( snapshotsList ) ; return Arrays . asList ( diskWithSnapshots , diskWithoutSnapshots , ovfImage , cinderDisk ) ; }
public IndexingConfigurationBuilder autoConfig ( boolean autoConfig ) { if ( autoConfig ) enable ( ) ; attributes . attribute ( AUTO_CONFIG ) . set ( autoConfig ) ; return this ; }
private boolean shouldBeDirectlyAttached ( String vfName , Guid vmId ) { return ! vmDeviceDao . getVmDeviceByVmIdTypeAndDevice ( vmId , VmDeviceGeneralType . HOSTDEV , vfName ) . isEmpty ( ) ; }
private static void safeCloseStream ( Closeable stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { // swallow error in this case Logger . e ( TAG , "Failed to close the stream : " , "" , ADALError . IO_EXCEPTION , e ) ; } } }
public static String zkSecuritySysConfigString ( ) { String loginConfig = System . getProperty ( JAVA_LOGIN_CONFIG_PARAM ) ; String clientEnabled = System . getProperty ( ZK_SASL_CLIENT , "default : " + DEFAULT_ZK_SASL_CLIENT ) ; String contextName = System . getProperty ( ZK_LOGIN_CONTEXT_NAME_KEY , "default : " + DEFAULT_ZK_LOGIN_CONTEXT_NAME ) ; return " [ " + JAVA_LOGIN_CONFIG_PARAM + " = " + loginConfig + " , " + ZK_SASL_CLIENT + " = " + clientEnabled + " , " + ZK_LOGIN_CONTEXT_NAME_KEY + " = " + contextName + " ] " ; }
public boolean updateNode ( final @Nonnull Node node ) throws IOException { if ( node == nodes . get ( node . getNodeName ( ) ) ) { Queue . withLock ( new Runnable ( ) { @Override public void run ( ) { jenkins . trimLabels ( ) ; } } ) ; persistNode ( node ) ; return true ; } return false ; }
public void onSaveInstanceState ( Bundle outState ) { // update the topmost entry in the back stack updateCurrentBackStackItem ( ) ; outState . putParcelableArrayList ( "backStack" , backStack ) ; }
public Trader ( String name , double cashInHand ) { // super ( ) ; this . name = name ; this . cashInHand = cashInHand ; this . position = new ArrayList < Order > ( ) ; this . ordersPlaced = new ArrayList < Order > ( ) ; }
private ITask getTasksAssosciatedWithReviewTask ( ITask reviewTask ) { String lookupUrl = reviewTask . getUrl ( ) ; // TODO : Fetch from mapping with the lookupUrl String taskUrl = "http :/ / someurl" ; AbstractRepositoryConnector repository = TasksUiPlugin . getRepositoryManager ( ) . getConnectorForRepositoryTaskUrl ( taskUrl ) ; String taskId = repository . getTaskIdFromTaskUrl ( taskUrl ) ; String repositoryUrl = repository . getRepositoryUrlFromTaskUrl ( taskUrl ) ; ITask assosciatedTask = taskList . getTask ( repositoryUrl , taskId ) ; return assosciatedTask ; }
protected void toLegacyText ( StringBuilder builder ) { builder . append ( this . value ) ; super . toLegacyText ( builder ) ; }
public static boolean isRoute ( URL url ) { return ROUTE_PROTOCOL . equals ( url . getProtocol ( ) ) || ROUTERS_CATEGORY . equals ( url . getParameter ( CATEGORY_KEY , DEFAULT_CATEGORY ) ) ; }
void thread2 ( ) { int [ ] vs1 ; synchronized ( lock ) { vs1 = values ; state = 1 ; } int s ; do { synchronized ( lock ) { s = state ; } } while ( s != 2 ) ; // Busy loop . int [ ] vs2 = values ; int v1 = vs1 [ 0 ] ; int v2 = vs2 [ 0 ] ; System . out . println ( "b17689750TestMonitor failed : " + v1 + " , " + v2 ) ; }
public void testWriteAndReadObject ( ) throws Exception { String expected = "test input" ; String actual = ( String ) writeAndReadObject ( expected ) ; assertNotNull ( actual ) ; assertEquals ( expected , actual ) ; }
public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } final ArArchiveEntry other = ( ArArchiveEntry ) obj ; if ( name == null ) { return other . name == null ; } else { return name . equals ( other . name ) ; } }
public ByteBufferReadableStreamChannel ( List < ByteBuffer > bufferList ) { if ( bufferList == null || bufferList . isEmpty ( ) ) { throw new IllegalArgumentException ( "Input List of ByteBuffer cannot be null / empty for ByteBufferReadableStreamChannel" ) ; } buffers = bufferList ; size = computeSize ( bufferList ) ; }
boolean areRequiredNetworksAvailable ( final List < VmNetworkInterface > vmNetworkInterfaces , final List < VdsNetworkInterface > allInterfacesForVds ) { for ( final VmNetworkInterface vmIf : vmNetworkInterfaces ) { boolean found = false ; for ( final VdsNetworkInterface vdsIf : allInterfacesForVds ) { if ( StringUtils . equals ( vmIf . getNetworkName ( ) , vdsIf . getNetworkName ( ) ) ) { found = true ; break ; } } if ( ! found ) { return false ; } } return true ; }
public void testStash ( ) throws Exception { // 1 ) call stash create command git . stashCreate ( ) . call ( ) ; readFile ( "Stash Created" , git . getRepository ( ) . getWorkTree ( ) + " / File1 . txt" ) ; // 2 ) call stash list git . stashList ( ) . call ( ) ; // 3 ) apply stash git . stashApply ( ) . call ( ) ; // 4 ) verify stash applied by outputting file readFile ( "Stash Created" , git . getRepository ( ) . getWorkTree ( ) + " / File1 . txt" ) ; }
public List < WorkerInfo > getWorkerInfoList ( ) throws UnavailableException { if ( mSafeModeManager . isInSafeMode ( ) ) { throw new UnavailableException ( ExceptionMessage . MASTER_IN_SAFEMODE . getMessage ( ) ) ; } try { return mWorkerInfoCache . get ( WORKER_INFO_CACHE_KEY ) ; } catch ( ExecutionException e ) { throw new UnavailableException ( "Unable to get worker info list from cache" , e ) ; } }
public static void tearDownTestCase ( ) throws Exception { }
public void checkSelectFilter ( final String label , final String value ) { selectInputs . computeIfPresent ( label , ( key , values ) - > { values . forEach ( i - > { if ( i . getValue ( ) . equals ( value ) && i . getChecked ( ) == false ) { i . setChecked ( true ) ; } } ) ; return values ; } ) ; }
public ColdMergeVDSCommandParameters ( Guid storageJobId , SubchainInfo subchainInfo ) { this . storageJobId = storageJobId ; this . subchainInfo = subchainInfo ; }
private void putResize ( K key , V value ) { K [ ] keyTable = this . keyTable ; V [ ] valueTable = this . valueTable ; for ( int i = place ( key ) ; ; i = ( i + 1 ) & mask ) { // space is available so we insert and break if ( keyTable [ i ] == null ) { keyTable [ i ] = key ; valueTable [ i ] = value ; break ; } } ++ size ; }
protected void onLoad ( ) { enableForm ( false ) ; super . onLoad ( ) ; Util . PROJECT_SVC . projectDetail ( projectName , new GerritCallback < ProjectDetail > ( ) { public void onSuccess ( final ProjectDetail result ) { enableForm ( true ) ; display ( result ) ; } } ) ; }
public static EncodeFormat checkedValueOf ( String name ) { try { return valueOf ( EncodeFormat . class , name ) ; } catch ( Exception ex ) { VoltDB . crashLocalVoltDB ( "Illegal encoding format " + name , true , ex ) ; } return null ; }
public Set < K > keySet ( Predicate predicate ) { checkNotNull ( predicate , "Predicate cannot be null ! " ) ; Set < K > resultingSet = new HashSet < K > ( ) ; Set < QueryableEntry > query = indexes . query ( predicate ) ; if ( query != null ) { for ( QueryableEntry entry : query ) { K key = toObject ( entry . getKeyData ( ) ) ; resultingSet . add ( key ) ; } } else { doFullKeyScan ( predicate , resultingSet ) ; } return resultingSet ; }
public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound ( ) throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter ( ) ; oo . setMyLocations ( new HashSet < > ( ) ) ; RequiredDataAdvice . getChildCollection ( oo , ClassWithBadGetter . class . getDeclaredField ( "locations" ) ) ; }
protected void configure ( ) { install ( new FactoryModule ( ) { @Override protected void configure ( ) { factory ( ForwardingRemovalListener . Factory . class ) ; } } ) ; bind ( DefaultCacheFactory . class ) ; bind ( MemoryCacheFactory . class ) . to ( DefaultCacheFactory . class ) ; bind ( PersistentCacheFactory . class ) . to ( H2CacheFactory . class ) ; listener ( ) . to ( H2CacheFactory . class ) ; }
private void createDisabledImage ( ) { // Only create a new disabledImage when the disabledImage == null or // disposed to avoid a GDI Handler leak See Bug 486531 if ( this . disabledImage == null || this . disabledImage . isDisposed ( ) ) if ( this . image != null && ! this . image . isDisposed ( ) ) disabledImage = new Image ( this . image . getDevice ( ) , this . image , SWT . IMAGE_DISABLE ) ; }
public synchronized void releaseSample ( DecoderInputBuffer sample ) { sample . clear ( ) ; mSamplePool . offerLast ( sample ) ; }
private String buildClipboardMessage ( Row row ) { return row . getLevel ( ) + " , " + row . getMessage ( ) ; }
public RepositoryObject getParent ( ) { // tombstone is not in the hierarchy , so doesn't have a parent return null ; }
private void setLastUsedBranch ( ) { String lastBranch = settings . get ( lastBranchKey ) ; if ( lastBranch != null ) branchText . setText ( lastBranch ) ; }
public String toString ( ) { return toStringHelper ( this ) . omitNullValues ( ) . add ( "equiCriteria" , equiCriteria ) . add ( "filter" , filter . orElse ( null ) ) . toString ( ) ; }
private void validateKeyPatternsInConfig ( Dictionary < String , ? > config ) { Enumeration < String > keys = config . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = keys . nextElement ( ) ; // the config - key enumeration contains additional keys that we // don't want to process here . . . if ( "service . pid" . equals ( key ) ) { continue ; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN . matcher ( key ) ; if ( ! matcher . matches ( ) ) { logger . warn ( "Given plugwise - config - key '" + key + "' does not follow the expected pattern ' < PlugwiseId > . < mac|type|port|interval > '" ) ; continue ; } } }
public Void visitFilter ( FilterNode node , Void context ) { String expression = formatter . formatRowExpression ( node . getPredicate ( ) ) ; printNode ( node , "Filter" , expression , NODE_COLORS . get ( NodeType . FILTER ) ) ; return node . getSource ( ) . accept ( this , context ) ; }
public void run ( ) { resetGlobalProgress ( ) ; indexingAll = true ; for ( ObjectType objectType : ObjectType . values ( ) ) { startIndexing ( objectType ) ; } try { sleep ( pause ) ; } catch ( InterruptedException e ) { logger . error ( "Thread interrupted : " + e . getMessage ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; } currentIndexState = ObjectType . NONE ; indexingAll = false ; pollingChannel . send ( INDEXING_FINISHED_MESSAGE ) ; }
public boolean isAC3 ( ) { return getCodecA ( ) != null && ( "ac3" . equals ( getCodecA ( ) ) || getCodecA ( ) . contains ( "a52" ) ) ; }
ShardRewriter createShardRewriter ( FileSystemContext fileSystemContext , FileSystem fileSystem , long transactionId , OptionalInt bucketNumber , UUID shardUuid , int shardRowCount , Optional < UUID > deltaShardUuid , boolean tableSupportsDeltaDelete , Map < String , Type > columns ) { if ( tableSupportsDeltaDelete ) { return new DeltaShardRewriter ( shardUuid , shardRowCount , deltaShardUuid , deletionExecutor , transactionId , bucketNumber , this , fileSystemContext , fileSystem ) ; } return new InplaceShardRewriter ( shardUuid , columns , deletionExecutor , transactionId , bucketNumber , nodeId , this , fileSystem , storageService , shardRecorder , backupManager ) ; }
public void init ( ) { setLabel ( "Plugin" ) ; addAttribute ( ID , ROLE_ID ) . setLabel ( "Identifier" ) ; addAttribute ( LABEL , ROLE_LABEL , ROLE_LOOKUP ) . setNillable ( false ) . setUnique ( true ) . setLabel ( "Label" ) ; addAttribute ( DESCRIPTION , ROLE_LOOKUP ) . setLabel ( "Description" ) ; }
@Override public Long call ( ) throws IOException { String oldname = Thread . currentThread ( ) . getName ( ) ; try { Thread . currentThread ( ) . setName ( oldname + "Decode - " + this . parent . columnChunkMetaData . toString ( ) ) ; this . parent . processPages ( recordsToReadInThisPass ) ; return recordsToReadInThisPass ; } finally { Thread . currentThread ( ) . setName ( oldname ) ; } }
public CompositeMetricsCollector ( MetricsCollector . . . collectors ) { this . collectors = asList ( collectors ) ; }
@Override public void onRequestPermissionsResult ( int requestCode , @NonNull String [ ] permissions , @NonNull int [ ] grantResults ) { if ( requestCode == REQUEST_READ_CONTACTS ) { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { loadContacts ( ) ; } else { Toast . makeText ( this , "Read contacts permission denied" , Toast . LENGTH_LONG ) . show ( ) ; finish ( ) ; } } else { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; } }
private static void appendBodyColorsRule ( StringBuilder buffer , RGB fgRGB , RGB bgRGB ) { StringBuilder fg = new StringBuilder ( ) ; appendColor ( fg , fgRGB ) ; StringBuilder bg = new StringBuilder ( ) ; appendColor ( bg , bgRGB ) ; buffer . append ( "body { color : " ) ; // $NON - NLS - 1$ appendColor ( buffer , fgRGB ) ; buffer . append ( " ; background - color : " ) ; // $NON - NLS - 1$ appendColor ( buffer , bgRGB ) ; buffer . append ( " ; } " ) ; // $NON - NLS - 1$ }
public static VoltDBInterface instance ( ) { return singleton ; }
public int getRenderState ( ) { int state = speed . ordinal ( ) ; if ( getReverse ( ) ) state = 4 ; if ( isPowered ( ) ) state += 5 ; return state ; }
public void ensureSettingsSavedShowsFormIfValidationFails ( ) throws Exception { doAnswer ( invocation - > { Errors errors = invocation . getArgument ( 1 ) ; errors . rejectValue ( "absenceSettings" , "error" ) ; return null ; } ) . when ( settingsValidator ) . validate ( any ( ) , any ( ) ) ; perform ( post ( " / web / settings" ) ) . andExpect ( view ( ) . name ( "settings / settings_form" ) ) ; }
private String extractConnectionKey ( final iOSVariant iOSVariant ) { final StringBuilder sb = new StringBuilder ( iOSVariant . getVariantID ( ) ) . append ( iOSVariant . isProduction ( ) ? " - prod" : " - dev" ) ; return sb . toString ( ) ; }
public void printCertificates ( ) { DefaultTable table = new DefaultTable ( ) ; for ( int i = 0 ; i < table . rowCount ( ) ; i ++ ) { log . info ( "On index " + i + " is : " + table . getItem ( i ) . getText ( 1 ) ) ; } }
public void lockEdge ( ) throws Exception { edgeLockTest ( LockMode . WRITE , LockMode . READ , true ) ; edgeLockTest ( LockMode . READ , LockMode . WRITE , true ) ; edgeLockTest ( LockMode . WRITE , LockMode . WRITE , true ) ; edgeLockTest ( LockMode . READ , LockMode . READ , false ) ; }
String getClientId ( ) { return clientMessageBus . getClientId ( ) ; }
private void configureManagementNetwork ( ) { final NetworkConfigurator networkConfigurator = new NetworkConfigurator ( getVds ( ) ) ; if ( ! networkConfigurator . awaitVdsmResponse ( ) ) { throw new VdsInstallException ( VDSStatus . NonResponsive , "Network error during communication with the host" ) ; } try { networkConfigurator . refreshNetworkConfiguration ( ) ; networkConfigurator . createManagementNetworkIfRequired ( ) ; } catch ( VDSNetworkException e ) { throw new VdsInstallException ( VDSStatus . NonResponsive , "Network error during communication with the host" , e ) ; } catch ( Exception e ) { throw new VdsInstallException ( VDSStatus . NonOperational , "Failed to configure manamgent network on the host" , e ) ; } }
public static Response newResetResponse ( Header header ) { return newResetResponse ( header , newNoServerError ( ) ) ; }
private Optional < TimeValue > getTimeValue ( Optional < TimeValue > primaryValue , Optional < TimeValue > safetyValue ) { if ( ! primaryValue . isPresent ( ) ) { return safetyValue ; } return primaryValue ; }
public Uris ( String scheme , String host ) { this . scheme = scheme ; this . host = host ; this . port = 0 ; }
private void carryOntoHistory ( RevCommit c , int carry ) { stack = null ; for ( ; ; ) { carryOntoHistoryInnerLoop ( c , carry ) ; if ( stack != null ) { c = stack . c ; carry = stack . carry ; stack = stack . prev ; continue ; } break ; } }
private FactHandle [ ] insertFacts ( KieSession ksession , int n ) { FactHandle [ ] fhs = new FactHandle [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { fhs [ i ] = ksession . insert ( i ) ; ksession . insert ( String . valueOf ( i ) ) ; } return fhs ; }
public SecureStore get ( ) { if ( instance == null ) { instance = injector . getInstance ( getSecureStoreImpl ( ) ) ; } return instance ; }
protected void handleSwingDropTargetChanged ( TreePath path , Transferable swingTransferable ) { if ( getUpdateSwingFromScoutLock ( ) . isAcquired ( ) ) { return ; } // if ( swingTransferable != null && getScoutObject ( ) != null ) { final ITreeNode scoutNode = treePathToScoutNode ( path ) ; // notify Scout ( asynchronous ! ) Runnable t = new Runnable ( ) { @Override public void run ( ) { getScoutObject ( ) . getUIFacade ( ) . fireNodeDropTargetChangedFromUI ( scoutNode ) ; } } ; getSwingEnvironment ( ) . invokeScoutLater ( t , 0 ) ; // end notify } }
void setDiskSpaceThreshold ( float diskSpaceThreshold , float diskUsageWarnThreshold ) { validateThreshold ( diskSpaceThreshold , diskUsageWarnThreshold ) ; this . diskUsageThreshold = diskSpaceThreshold ; this . diskUsageWarnThreshold = diskUsageWarnThreshold ; }
public static void setInstance ( Object source , @MappingTarget Object target ) { Integer level = LEVEL . get ( ) ; fireMethodCalled ( level , "setInstance" , source , target ) ; if ( level == null ) { LEVEL . set ( 1 ) ; MAPPING . set ( new IdentityHashMap < Object , Object > ( ) ) ; } else { LEVEL . set ( level + 1 ) ; } MAPPING . get ( ) . put ( source , target ) ; }

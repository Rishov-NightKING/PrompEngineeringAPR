private void loadPerspectiveAndCheckLoadingTime ( String perspectiveID , boolean headerIncluded ) { String standalonePerspectiveURL = getStandalonePerspectiveURL ( perspectiveID , headerIncluded ) ; driver . get ( standalonePerspectiveURL ) ; BusyPopup . waitForDisappearance ( ) ; ApplicationLoadingPopup . waitForDisappearance ( PERSPECTIVE_LOADING_TIMEOUT ) ; } // Example usage : for ( String perspectiveID : perspectiveIDs ) { loadPerspectiveAndCheckLoadingTime ( perspectiveID , true ) ; // TODO : Add logging and assertions here }
public default IVariableBinding [ ] getSyntheticOuterLocals ( ) { return new IVariableBinding [ 0 ] ; }
protected void executeCommand ( ) { AuthenticationProfile profile = sessionDataContainer . getProfile ( getParameters ( ) . getSessionId ( ) ) ; sessionId = getParameters ( ) . getSessionId ( ) ; sourceIp = sessionDataContainer . getSourceIp ( getParameters ( ) . getSessionId ( ) ) ; sessionDataContainer . setSessionValid ( getParameters ( ) . getSessionId ( ) , false ) ; if ( profile == null ) { setSucceeded ( false ) ; } else { setSucceeded ( true ) ; } }
public static void updateNotification ( Context context , MasterSecret masterSecret , long threadId ) { if ( TextSecurePreferences . isNotificationsEnabled ( context ) ) { if ( visibleThread != threadId ) { updateNotification ( context , masterSecret , true ) ; } else { DatabaseFactory . getThreadDatabase ( context ) . setRead ( threadId ) ; sendInThreadNotification ( context ) ; } } updateBadge ( context ) ; }
protected void fillOptions ( Map < Enum , String > options ) { options . put ( EnumModel . VAL1 , EnumModel . VAL1 . name ( ) ) ; options . put ( EnumModel . VAL2 , EnumModel . VAL2 . name ( ) ) ; options . put ( EnumModel . VAL3 , EnumModel . VAL3 . name ( ) ) ; options . put ( EnumModel . VAL4 , EnumModel . VAL4 . name ( ) ) ; }
public boolean removeQueues ( Queue . . . queues ) { removeQueues ( Arrays . stream ( queues ) . map ( Queue : : getName ) . toArray ( String [ ] : : new ) ) ; return super . removeQueues ( queues ) ; }
private static Object castIntegerToObject ( int value , Type type ) { if ( type == INTEGER || type == TINYINT || type == BIGINT ) { return ( long ) value ; } if ( type == VARCHAR ) { return String . valueOf ( value ) ; } if ( type == DOUBLE ) { return ( double ) value ; } throw new UnsupportedOperationException ( ) ; }
public void testXmlConfig ( ) throws IOException { EmbeddedCacheManager cm = null ; Cache < String , KeyValueEntity > specificCache = null ; try { cm = new DefaultCacheManager ( "jpa - config . xml" ) ; specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } finally { if ( cm != null ) { cm . stop ( ) ; } } }  or  public void testXmlConfig ( ) throws IOException { TestingUtil . withCacheManager ( new TestCacheManagerFactory ( ) , cm - > { Cache < String , KeyValueEntity > specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof URIEditorInput ) ) { return false ; } URIEditorInput other = ( URIEditorInput ) o ; if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } if ( o instanceof SessionEditorInput ) { EObject input = getInput ( false ) ; if ( input != null ) { SessionEditorInput otherSessionEditorInput = ( SessionEditorInput ) o ; return input . equals ( otherSessionEditorInput . getInput ( false ) ) ; } } return true ; }
private void loadChildEntities ( LibraryDilution dilution ) throws IOException { if ( dilution . getLibrary ( ) != null ) { dilution . setLibrary ( libraryDao . get ( dilution . getLibrary ( ) . getId ( ) ) ) ; } if ( dilution . getTargetedSequencing ( ) != null ) { dilution . setTargetedSequencing ( targetedSequencingDao . get ( dilution . getTargetedSequencing ( ) . getId ( ) ) ) ; } if ( dilution . getDilutionCreator ( ) == null ) { dilution . setDilutionCreator ( authorizationManager . getCurrentUsername ( ) ) ; } }
GdkColor getContextColor ( ) { long /* int */ fontHandle = fontHandle ( ) ; long /* int */ context = OS . gtk_widget_get_style_context ( fontHandle ) ; GdkRGBA rgba = new GdkRGBA ( ) ; if ( OS . GTK_VERSION < OS . VERSION ( 3 , 18 , 0 ) ) { rgba = display . styleContextGetColor ( context , OS . GTK_STATE_FLAG_NORMAL , rgba ) ; } else { rgba = display . styleContextGetColor ( context , OS . gtk_widget_get_state_flags ( handle ) , rgba ) ; } return display . toGdkColor ( rgba ) ; }
public Subquery parameter ( String listId , Object . . . values ) { if ( values == null || values . length == 0 || values [ 0 ] == null ) { return this ; } where . setToNormal ( ) . setToIntersection ( ) . addParameter ( listId , values ) ; return this ; }
public int hashCode ( ) { int result = key ? 1 : 0 ; result = 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; return result ; }
public boolean doSynchronousPing ( ) { try { int responseCode = responseCodeFetcher . from ( hostAddress ) ; MerlinLog . d ( "Got response : " + responseCode ) ; } catch ( RequestException e ) { if ( e . causedByIO ( ) ) { return false ; } throw e ; } return true ; }
The code has a bug that needs to be reported and fixed . The bug fix should be done in a separate commit from any new feature work . Here's a refactored version of the code :  public T hasThisElement ( final Object val ) { Assert . parametersNotNull ( "val" , val ) ; return addCriteria ( FilterOperator . ELEMENT_MATCH , val , not ) ; }
public Builder setSSHDirectory ( final File sshDirectory ) { this . sshDirectory = sshDirectory ; return this ; } @Override public int hashCode ( ) { // TODO : Implement hashCode method return Objects . hash ( sshDirectory ) ; } @Override public boolean equals ( Object obj ) { // TODO : Implement equals method if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Builder builder = ( Builder ) obj ; return Objects . equals ( sshDirectory , builder . sshDirectory ) ; }
public List < Attribute > getRequiredAttributes ( PerunSession sess , List < Service > services , Facility facility , Resource resource , User user , Member member ) throws InternalErrorException , MemberResourceMismatchException { Set < Attribute > attributes = new HashSet < > ( ) ; for ( Service service : services ) { attributes . addAll ( getRequiredAttributes ( sess , service , facility , resource , user , member ) ) ; } return new ArrayList < > ( attributes ) ; }
public void zrevrangeByScoreWithScores ( final byte [ ] key , final double min , final double max , final int offset , final int count ) { sendCommand ( ZREVRANGEBYSCORE , key , toByteArray ( max ) , toByteArray ( min ) , LIMIT . raw , toByteArray ( offset ) , toByteArray ( count ) , WITHSCORES . raw ) ; }
public void write ( int b ) throws IOException { mSingleCharWrite [ 0 ] = ( byte ) b ; write ( mSingleCharWrite ) ; }
public void deallocateFlow ( String flowId , String netId ) throws FlowNotFoundException , ProvisionerException { try { getNclController ( ) . deallocateFlow ( netId , flowId ) ; } catch ( Exception e ) { throw new ProvisionerException ( e ) ; } }
private String _encode ( String strVal ) { try { return URLEncoder . encode ( strVal , StandardCharsets . UTF_8 . toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
public boolean contains ( Object o ) { if ( o == null ) { return false ; } boolean contains = super . contains ( o ) ; if ( ! contains ) { MarshalledEntry < K , V > me = persistenceManager . loadFromAllStores ( o , true ) ; contains = me != null ; } return contains ; }
public boolean provides ( IOperation operation ) { if ( ! ( operation instanceof CreateDecoratorsOperation ) ) { return false ; } IDecoratorTarget decoratorTarget = ( ( CreateDecoratorsOperation ) operation ) . getDecoratorTarget ( ) ; View view = ( View ) decoratorTarget . getAdapter ( View . class ) ; return view != null && DDiagramEditPart . MODEL_ID . equals ( SiriusVisualIDRegistry . getModelID ( view ) ) ; }
public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert ( ) { CuratedContentPageObject ccp = new CuratedContentPageObject ( driver ) ; wikiURL = urlBuilder . getUrlForWiki ( MercuryWikis . MERCURY_CC ) ; ccp . openMercuryArticleByNameWithNoCacheBuster ( wikiURL , MercurySubpages . CC_MAIN_PAGE ) ; MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject ( driver , Mercury . AlertMessage . NOT_EXISTING_CATEGORY ) ; String oldUrl = driver . getCurrentUrl ( ) ; ccp . clickOnCuratedContentElementByIndex ( 2 ) ; Assertion . assertTrue ( mercuryAlert . isAlertMessageVisible ( ) ) ; ccp . waitForLoadingSpinnerToFinish ( ) ; Assertion . assertUrlEqualToCurrentUrl ( driver , oldUrl ) ; }
private void testUpdateInterface ( Guid interface_id ) { VdsNetworkInterface iface = dao . get ( interface_id ) ; iface . setName ( iface . getName ( ) . toUpperCase ( ) ) ; iface . setQos ( newQos ) ; dao . updateInterfaceForVds ( iface ) ; VdsNetworkInterface ifaced = dao . get ( interface_id ) ; assertEquals ( iface . getName ( ) , ifaced . getName ( ) ) ; assertEquals ( iface . getQos ( ) , ifaced . getQos ( ) ) ; }
public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; return patientProgram ; }  public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } return patientProgram ; }
public UploadDirectoryToCDN ( String username , String apiKey ) { Iterable < Module > modules = ImmutableSet . < Module > of ( new SLF4JLoggingModule ( ) ) ; BlobStoreContext context = ContextBuilder . newBuilder ( PROVIDER ) . credentials ( username , apiKey ) . modules ( modules ) . buildView ( BlobStoreContext . class ) ; storage = context . getBlobStore ( ) ; rackspace = context . unwrapApi ( CloudFilesApi . class ) ; }
public SslContextBuilder keyManager ( KeyManager keyManager ) { if ( forServer && keyManager == null ) { throw new NullPointerException ( "keyManager required for servers" ) ; } this . keyManagerFactory = keyManager == null ? null : new KeyManagerFactoryWrapper ( keyManager ) ; keyCertChain = null ; key = null ; keyPassword = null ; return this ; }
public class MyClass { protected boolean isTypeSupported ( Class < ? > clazz ) { if ( String . class . isAssignableFrom ( clazz ) || Integer . class . isAssignableFrom ( clazz ) || Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } return false ; } }
private List < Person > createModel ( ) { List < Person > elements = new ArrayList < Person > ( 4 ) ; elements . add ( new Person ( "Tom" , "Schindl" , "tom . schindl@bestsolution . at" ) ) ; elements . add ( new Person ( "John" , "Doe" , "john . doe@example . com" ) ) ; elements . add ( new Person ( "Tod" , "Creasey" , "Tod_Creasey@ca . ibm . com" ) ) ; elements . add ( new Person ( "Wayne" , "Beaton" , "wayne@eclipse . org" ) ) ; return elements ; }
protected void updateIteration ( ) { refreshIteration ++ ; refreshIteration = refreshIteration % NUMBER_VMS_REFRESHES_BEFORE_SAVE ; }
public void add ( E newInterval ) { super . add ( newInterval ) ; fListeners . forEach ( l - > l . elementAdded ( this , newInterval ) ) ; }
public RuleEvaluationWorker ( Map < String , Set < String > > docsToCheckAndEvents ) { this . docsToCheckAndEvents = docsToCheckAndEvents ; List < String > docs = new ArrayList < > ( ) ; docs . addAll ( docsToCheckAndEvents . keySet ( ) ) ; setDocuments ( Framework . getService ( RepositoryManager . class ) . getDefaultRepositoryName ( ) , docs ) ; }
private static String getTestingAlias ( GoImportSpec testingImportSpec ) { if ( testingImportSpec != null ) { return ! testingImportSpec . isDot ( ) ? StringUtil . notNullize ( testingImportSpec . getAlias ( ) , GoConstants . TESTING_PATH ) : "" ; } return GoConstants . TESTING_PATH ; }
public SystemPurposeComplianceStatusDTO ( SystemPurposeComplianceStatusDTO source ) { super ( source ) ; }
public MapOperation ( ) { final ILogger logger = this . logger ( ) ; final int forcedEvictionRetryCount = getRetryCount ( ) ; Eviction [ ] evictions = new Eviction [ ] { new RecordStoreForcedEviction ( forcedEvictionRetryCount , logger , this ) , new PartitionRecordStoreForcedEviction ( forcedEvictionRetryCount , logger , this ) , new AllEntriesEviction ( logger , this ) } ; evictions [ 3 ] = new PartitionAllEntriesEviction ( logger , this ) ; }
private static Instant retrieveDeadlineTimestamp ( JobDataMap jobDataMap ) { Object timestamp = jobDataMap . get ( MESSAGE_TIMESTAMP ) ; if ( timestamp instanceof String ) { return Instant . parse ( timestamp . toString ( ) ) ; } else { return Instant . ofEpochMilli ( ( long ) timestamp ) ; } }
< START > AggregatorFactory [ ] getMetrics ( ) { return metrics ; } </ END >
public void prepare ( ) throws IOException { e = SQLExecutor . builder ( clusterService ) . enableDefaultTables ( ) . build ( ) ; plannerContext = e . getPlannerContext ( clusterService . state ( ) ) ; }
public void setUp ( ) { final JUnitCore jUnitCore = new JUnitCore ( ) ; final TestListener testListener = new TestListener ( ) ; jUnitCore . addListener ( testListener ) ; }
protected boolean validate ( ) { if ( ! canRunActionOnNonManagedVm ( ) ) { return false ; } if ( ! isInternalExecution ( ) && ! ObjectIdentityChecker . canUpdateField ( getVm ( ) , "clusterId" , getVm ( ) . getStatus ( ) ) ) { addValidationMessage ( EngineMessage . VM_STATUS_NOT_VALID_FOR_UPDATE ) ; return false ; } ChangeVmClusterValidator validator = new ChangeVmClusterValidator ( this , getParameters ( ) . getClusterId ( ) , getParameters ( ) . getVmCustomCompatibilityVersion ( ) , getVmDeviceUtils ( ) ) ; return validator . validate ( ) ; }
public class KeyStoreHelper { private Map < String , TrustManagerFactory > trustMgrMap ; public KeyStoreHelper ( ) { trustMgrMap = new HashMap < > ( ) ; // populate trustMgrMap with serverName and corresponding trustStore } public TrustManagerFactory getTrustMgr ( String serverName ) { TrustManagerFactory fact = trustMgrMap . get ( serverName ) ; if ( fact != null ) { return fact ; } try { KeyStore trustStore = // get trustStore for serverName fact = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; fact . init ( trustStore ) ; trustMgrMap . put ( serverName , fact ) ; return fact ; } catch ( NoSuchAlgorithmException | KeyStoreException e ) { throw new RuntimeException ( e ) ; } } }
public TextEdit formatModuleInfoFile ( int kind , String source , int offset , int length , int indentationLevel , String lineSeparator ) { boolean tmp = this . isInModuleInfo ; this . isInModuleInfo = true ; TextEdit edit = null ; try { edit = format ( kind , source , new IRegion [ ] { new Region ( offset , length ) } , indentationLevel , lineSeparator ) ; } finally { this . isInModuleInfo = tmp ; } return edit ; }
I'm sorry , but I cannot understand the Review without comments . Could you please provide more context or clarify your request ?
public static Object valueForStringWithType ( String value , VoltType type ) { if ( type == null ) { throw new IllegalArgumentException ( "Type cannot be null . " ) ; } if ( type == VoltType . NULL ) { return null ; } // leverage existing ( rather heavyweight ) code to convert param types Object retval = ParameterConverter . tryToMakeCompatible ( type . classFromType ( ) , value ) ; // check the result type in an assert assert ( ParameterConverter . verifyParameterConversion ( retval , type . classFromType ( ) ) ) ; return retval ; }
public void testContructor ( ) throws IOException { String code = "S2020 - 04 - 04" ; ReportingPeriod period = ReportingPeriod . from ( code ) ; assertEquals ( period . getClass ( ) , SinceX . class ) ; }
public void testGetConnectableFileStorageConnectionsByStorageType ( ) { List < StorageServerConnections > conns = dao . getConnectableStorageConnectionsByStorageType ( FixturesTool . STORAGE_POOL_NFS_2 , StorageType . NFS ) ; assertNotNull ( conns ) ; assertEquals ( 1 , conns . size ( ) ) ; for ( StorageServerConnections conn : conns ) { assertEquals ( StorageType . NFS , conn . getstorage_type ( ) ) ; } }
public static void setOverrideFileName ( String . . . path ) { fOverridePath = ( path == null ) ? null : path . clone ( ) ; fOverride = true ; }
void addChanges ( Collection < String > filesToUpdate , Collection < IResource > resourcesToUpdate ) { synchronized ( lock ) { files . addAll ( filesToUpdate ) ; resources . addAll ( resourcesToUpdate ) ; } if ( ! filesToUpdate . isEmpty ( ) ) schedule ( defaultDelay ) ; }
public static synchronized String getEncryptionKey ( String name ) { if ( CACHED_ENCRYPTION_KEYS . get ( name ) == null ) { generateEncryptionKey ( name ) ; } return CACHED_ENCRYPTION_KEYS . get ( name ) ; }  Explanation : Since the `getUniqueId` method is not provided , it is assumed that it generates a unique identifier for the given name . Therefore , it is safe to use the name itself as the key in the `CACHED_ENCRYPTION_KEYS` map . This simplifies the code and eliminates the need for the `keyString` variable .
public void init ( IEditorSite site , IEditorInput input ) { super . init ( site , input ) ; TaskData taskData = getModel ( ) . getTaskData ( ) ; if ( taskData != null ) { GerritChange change = GerritUtil . getChange ( taskData ) ; final ChangeDetailX detail = change . getChangeDetail ( ) ; try { review = GerritUtil . toReview ( detail ) ; } catch ( GerritException e ) { // Handle the exception gracefully review = null ; } } }
private static final ISnapshotInfo SNAPSHOT_INFO = new SnapshotInfo ( EMPTY_STRING ) ; public ISnapshotInfo getSnapshotInfo ( String sessionName , IProgressMonitor monitor ) throws ExecutionException { return SNAPSHOT_INFO ; }
public long getEntryLastModified ( ) { if ( modTimes == null ) { return 0 ; } Long cutOff = super . getEntryLastModified ( ) - 1 ; SortedSet < Long > head = modTimes . headSet ( cutOff , true ) ; return head . isEmpty ( ) ? 0 : head . last ( ) . longValue ( ) ; }
public ParameterizedSqlFactory ( String initialSql ) { sqlStringBuilder = new StringBuilder ( initialSql ) ; parameters = new ArrayList < > ( ) ; }
public long getReadyTimestamp ( Constraints viewConstraints ) { String normalizedConstraints = getNormalizedConstraints ( viewConstraints ) ; Path signalPath = new Path ( signalDirectory , normalizedConstraints ) ; try { FileStatus signalStatus = rootFileSystem . getFileStatus ( signalPath ) ; return signalStatus . getModificationTime ( ) ; } catch ( final FileNotFoundException ex ) { return - 1 ; } catch ( IOException e ) { throw new DatasetIOException ( "Could not access signal path : " + signalPath , e ) ; } catch ( NumberFormatException e ) { throw new DatasetException ( "Signal contents were modified to not be a number : " + signalPath , e ) ; } } The NumberFormatException is thrown when the signal contents are modified to not be a number .
private boolean hostHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; if ( cluster == null ) { return false ; } ArchitectureType archType = cluster . getArchitecture ( ) ; return ( ArchitectureType . ppc64 . equals ( archType ) ) || ( ArchitectureType . ppc64le . equals ( archType ) ) || ( ArchitectureType . ppcle . equals ( archType ) ) ; }
private static String getExtension ( String name ) { int ext = name . lastIndexOf ( ' . ' ) ; return ext > 0 ? name . substring ( ext ) : "" ; }
public void checkpoint ( ) { // No - op , as checkpoint is not supported in NoopJournalSystem }
private void recalculateMacsCount ( ) { if ( ! validate ( ) ) { setAvailableMacsCount ( - 1 ) ; return ; } if ( macRange . getMacPoolId ( ) == null ) { String from = getLeftBound ( ) . getEntity ( ) ; String to = getRightBound ( ) . getEntity ( ) ; long count = MacRangeValidation . macToLong ( to ) - MacRangeValidation . macToLong ( from ) + 1 ; setAvailableMacsCount ( ( int ) count ) ; } }
public void setup ( ) { buffer = new DiskBuffer ( BUFFER_DIR , maxEvents ) ; }
private boolean filterInvalid ( Position position ) { return filterInvalid && ( ! position . getValid ( ) || position . getLatitude ( ) > 90 || position . getLatitude ( ) < - 90 || position . getLongitude ( ) > 180 || position . getLongitude ( ) < - 180 ) ; }
public Set < Location > getAllowedLocations ( ) { return new HashSet < Location > ( Arrays . asList ( Location . CONSTRUCTOR , Location . METHOD , Location . FIELD , Location . OVERVIEW , Location . PACKAGE , Location . TYPE ) ) ; }
public static String getTasksJsonString ( long taskId ) throws JSONException { TaskObject task = TaskObject . get ( taskId ) ; return ConvertSprintBacklog . getTaskJsonString ( task ) ; }
private void addVolumeToDb ( final GlusterVolumeEntity createdVolume ) { createdVolume . setClusterId ( getVdsGroupId ( ) ) ; DbFacade . getInstance ( ) . getGlusterVolumeDao ( ) . save ( createdVolume ) ; }
import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public Sheet getDataSheet ( File file ) { Log log = LogFactory . getLog ( getClass ( ) ) ; PushbackInputStream stream = null ; Workbook wb = null ; try { stream = new PushbackInputStream ( new FileInputStream ( file ) ) ; wb = WorkbookFactory . create ( stream ) ; } catch ( Exception e ) { log . error ( "Workbook creation exception" , e ) ; } return wb . getSheetAt ( 0 ) ; }
public void updateAttributes ( ) { OperatingSystem operatingSystem = getCurrentOperatingSystem ( ) ; if ( operatingSystem != null ) { OSProcess process = operatingSystem . getProcess ( this . processID ) ; if ( process != null ) { copyValuesToThisProcess ( process ) ; } else { throw new InstantiationError ( "No process found : " + this . processID ) ; } } else { throw new UnsupportedOperationException ( "Unsupported platform . No update performed . " ) ; } }
public boolean isMissingHookConflict ( ) { int missingHookValue = MISSING_HOOK . getValue ( ) ; return ( conflictStatus & missingHookValue ) == missingHookValue ; }
public Map < AccountGroup . UUID , GroupMembersList > getUnresolvedGroups ( final boolean recursive ) { if ( ! recursive ) { if ( isResolved ( ) ) { return Collections . emptyMap ( ) ; } return Collections . singletonMap ( getGroup ( ) . getGroupUUID ( ) , this ) ; } return getAllUnresolvedGroups ( new HashSet < AccountGroup . Id > ( ) ) ; }
public boolean nextBoolean ( ) throws IOException { requirePeek ( ) ; boolean value ; try { if ( parser . getCurrentToken ( ) == JsonToken . VALUE_TRUE || parser . getCurrentToken ( ) == JsonToken . VALUE_FALSE ) { value = parser . getBooleanValue ( ) ; } else { value = Boolean . parseBoolean ( parser . getValueAsString ( ) ) ; } } catch ( JsonParseException e ) { value = Boolean . parseBoolean ( parser . getValueAsString ( ) ) ; } clearPeek ( ) ; return value ; }
java boolean isCloseOnProtocolViolation ( ) { return closeOnProtocolViolation ; }  Explanation : The method `isCloseOnProtocolViolation ( ) ` is a getter method for the private boolean variable `closeOnProtocolViolation` . It is not necessary for this method to be public as it is only used within the class . Therefore , it can be made package - private or private to follow encapsulation principles .
public String getSelinuxEnforceMode ( ) { if ( selinuxEnforceMode == null ) { return constants . notAvailableLabel ( ) ; } else { return EnumTranslator . getInstance ( ) . translate ( SELinuxMode . class , selinuxEnforceMode , constants . disabled ( ) , constants . permissive ( ) , constants . enforcing ( ) ) ; } }
public void startThreads ( ) { if ( ! this . threadStarted ) { synchronized ( this ) { if ( ! this . threadStarted ) { int nbThreads = this . configuration . getProperty ( "mentions . poolSize" , 1 ) ; for ( int i = 0 ; i < nbThreads ; i ++ ) { startConsumer ( ) ; } this . threadStarted = true ; } } } }
public void init ( EObject original , EditingDomain editingDomain ) { List < EStructuralFeature > features = featuresProvider . getFeatures ( original ) ; initControlFactory ( editingDomain , original ) ; for ( final EStructuralFeature feature : features ) { if ( isToBeRendered ( feature ) ) { createControlForFeature ( feature ) ; } } this . layout ( ) ; }
public List < Annotation > getQualifiers ( ) { return Arrays . asList ( new org . jboss . arquillian . warp . servlet . AfterServlet ( ) { @Override public Class < ? extends Annotation > annotationType ( ) { return org . jboss . arquillian . warp . servlet . AfterServlet . class ; } } ) ; }
protected void initialize ( Configuration config ) { remoteCacheManager = new RemoteCacheManager ( config , true ) ; remoteCache = remoteCacheManager . getCache ( TEST_CACHE_NAME ) ; }
< START > LauncherDiscoveryRequest buildRequest ( Bundle bundle ) { List < DiscoverySelector > selectors = new ArrayList < > ( baseSelectors ) ; selectors . add ( BundleSelector . selectBundle ( bundle ) ) ; return LauncherDiscoveryRequestBuilder . request ( ) . configurationParameter ( BundleEngine . CHECK_UNRESOLVED , unresolved ) . selectors ( selectors ) . build ( ) ; } < END >
protected void statementExecuteUpdateBefore ( StatementProxy statement , String sql ) { try { Before ( statement , sql ) ; } catch ( Exception e ) { // handle exception } super . statementExecuteUpdateBefore ( statement , sql ) ; }
public static DecoderResult failure ( Throwable cause ) { ObjectUtil . checkNotNull ( cause , "cause" ) ; return new DecoderResult ( cause ) ; }
private void writeObject ( Schema schema , GenericRecord datum ) throws Exception { BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( new ByteArrayOutputStream ( ) , null ) ; GenericDatumWriter < GenericData . Record > writer = new GenericDatumWriter < > ( schema ) ; writer . write ( schema , datum , encoder ) ; }
public Collection < String > getNames ( ) { Set < String > names = new HashSet < > ( named . keySet ( ) ) ; namedArgumentFinder . forEach ( args - > names . addAll ( args . getNames ( ) ) ) ; return Collections . unmodifiableSet ( names ) ; }
public FBOConfig getFboConfig ( ResourceUrn fboName ) { FBOConfig fboConfig = fboConfigs . get ( fboName ) ; if ( fboConfig == null ) { logger . warning ( "Failed to retrieve FBOConfig '" + fboName + "' ! " ) ; } return fboConfig ; }
void setKey ( Input newInput , char newKeyChar ) { input = newInput ; keyChar = newKeyChar ; }
public Builder < EvictionConfiguration > configure ( OperationContext context , ModelNode model ) throws OperationFailedException { EvictionStrategy strategy = ModelNodes . asEnum ( STRATEGY . getDefinition ( ) . resolveModelAttribute ( context , model ) , EvictionStrategy . class ) ; if ( strategy . isEnabled ( ) ) { this . builder . strategy ( strategy ) . type ( EvictionType . COUNT ) . size ( MAX_ENTRIES . getDefinition ( ) . resolveModelAttribute ( context , model ) . asLong ( ) ) ; } return this ; }
public void closed ( BoltConnection connection ) { String id = connection . id ( ) ; try { CompletableFuture < Boolean > currentFuture = activeWorkItems . remove ( id ) ; if ( currentFuture != null ) { currentFuture . cancel ( true ) ; } } finally { activeConnections . remove ( id ) ; } }
public void testIsExternalVM ( ) throws Exception { XmlDocument xmlDocument = new XmlDocument ( getXmlOvfData ( ) ) ; assertFalse ( "VM should not be external VM" , OvfUtils . isExternalVM ( xmlDocument ) ) ; }
public static boolean folderContains ( File folder , String filename ) { if ( folder == null || ! folder . isDirectory ( ) ) { return false ; } File [ ] fileList = folder . listFiles ( ) ; if ( fileList . length == 0 ) { return false ; } for ( File f : fileList ) { if ( f . getName ( ) . equals ( filename ) ) { return true ; } } return false ; }
public void addWhiteListPatterns ( String . . . patterns ) { Collections . addAll ( whiteListPatterns , patterns ) ; }
private Long getRegistrationMillis ( String playerName ) { PlayerAuth auth = playerCache . getAuth ( playerName ) ; if ( auth == null ) { auth = dataSource . getAuth ( playerName ) ; } if ( auth != null ) { return auth . getRegistrationDate ( ) ; } return null ; }
public HashConfigurationBuilder capacityFactor ( float numSegments ) { if ( numSegments < 0 ) throw new IllegalArgumentException ( "numSegments must be positive" ) ; this . numSegments = numSegments ; return this ; }
public synchronized void onHeaders ( Response response ) { long length = response . getHeaders ( ) . getLongField ( HttpHeader . CONTENT_LENGTH . asString ( ) ) ; if ( length > maxLength ) { response . abort ( new ResponseTooLargeException ( ) ) ; } }
public WorkspaceItem build ( ) { return workspaceItem ; }
public static Map < String , Charset > requiredCharsets ( ) { return Collections . unmodifiableMap ( REQUIRED_CHARSETS ) ; }
protected void checkProject ( Project project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . getProjectApi ( ) . getProject ( project . getId ( ) ) . toString ( ) ) ; assertTrue ( "Project state is unrecognized" , project . getState ( ) != null && project . getState ( ) != Project . State . UNRECOGNIZED ) ; }
public AtsProgramArtifactToken ( Long id , String name , ArtifactTypeToken artifactType ) { super ( id , name , CoreBranches . COMMON , artifactType ) ; }
public void setUseBulkWriteOperations ( final boolean useBulkWriteOperations ) { // Deprecated method @Deprecated LOG . warning ( "This method is deprecated and has no value functionally or performance - wise . " ) ; }
The condition "if ( isNonEmptyMessage ) " will be false when the message is null .   public void setActionConfirmationMessage ( String message ) { boolean isNonEmptyMessage = message != null ; if ( isNonEmptyMessage ) { actionConfirmationMessage . setText ( message ) ; } actionConfirmationMessage . setVisible ( isNonEmptyMessage ) ; }
public void close ( ) throws InterruptedException { close ( false ) ; }
protected void recursivelyPrint ( AbstractPlanNode node , StringBuilder sb , int indent ) { for ( int i = 0 ; i < indent ; i ++ ) { sb . append ( "\t" ) ; } sb . append ( node . toJSONString ( ) + "\n" ) ; indent ++ ; if ( node . getChildCount ( ) > 0 ) { recursivelyPrint ( node . getChild ( 0 ) , sb , indent ) ; } }
public void update ( int inputIndex ) { status . setTargetOutputRowCount ( super . update ( inputIndex , status . getOutPosition ( ) ) ) ; logger . debug ( "BATCH_STATS , incoming { } : { } " , inputIndex == 0 ? "left" : "right" , getRecordBatchSizer ( inputIndex ) ) ; }
private int getNextPosition ( ) throws CoreException { if ( nextMemberPosition < 0 ) { nextMemberPosition = 0 ; while ( nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord ( nextMemberPosition ) != 0 ) { nextMemberPosition ++ ; } } return nextMemberPosition ; }
public BulkResponse executeRequest ( ) { if ( bulkRequest . numberOfActions ( ) == 0 ) { return null ; } logger . trace ( " [ { } ] ES API CALL : bulk request with { } actions" , ( ) - > jobId , ( ) - > bulkRequest . numberOfActions ( ) ) ; BulkResponse bulkResponse = resultsPersisterService . bulkIndexWithRetry ( bulkRequest , jobId , shouldRetry , msg - > auditor . warning ( jobId , "Bulk indexing of annotations failed " + msg ) ) ; bulkRequest = new BulkRequest ( AnnotationIndex . WRITE_ALIAS_NAME ) ; return bulkResponse ; }
public int size ( ) { int size = 0 ; for ( InternalCacheEntry < K , V > entry : this ) { if ( entry . getValue ( ) != null ) { size ++ ; } if ( size == Integer . MAX_VALUE ) { return Integer . MAX_VALUE ; } } return size ; }
public static File getDiskCacheDir ( Context context , String uniqueName ) { final String cachePath ; if ( context . getExternalCacheDir ( ) != null && Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return new File ( cachePath + File . separator + uniqueName ) ; }
private String getBucketName ( URI uri ) { if ( uri . getHost ( ) != null ) { return uri . getHost ( ) ; } else if ( uri . getUserInfo ( ) == null ) { return uri . getAuthority ( ) ; } throw new IllegalArgumentException ( "Unable to determine S3 bucket from URI . " ) ; }
private MustacheFactory createNewMustacheFactory ( Class < ? extends View > key ) { return new DefaultMustacheFactory ( fileRoot . isPresent ( ) ? new FileSystemResolver ( fileRoot . get ( ) ) : new PerClassMustacheResolver ( key ) ) ; }
public boolean isValidValue ( final Object element ) { boolean result = super . isValidValue ( element ) ; if ( result ) { EObject eObject = EMFHelper . getEObject ( element ) ; result = ProtocolUtils . isProtocol ( eObject ) ; } return result ; }
public void testLogin ( ) throws Throwable { InstrumentationRegistry . getInstrumentation ( ) . runOnMainSync ( new Runnable ( ) { @Override public void run ( ) { runLoginTestTaskOnMainThread ( ) ; } } ) ; assertThat ( completionLatch . await ( ) , is ( true ) ) ; } private void runLoginTestTaskOnMainThread ( ) { loginTestTask . execute ( ) ; }
public static void warnIfDeprecatedDnsLookupValue ( AbstractConfig config ) { String clientDnsLookupValue = config . getString ( CLIENT_DNS_LOOKUP_CONFIG ) ; if ( clientDnsLookupValue . equals ( ClientDnsLookup . DEFAULT ) ) { log . warn ( "Configuration ' { } ' with value ' { } ' is deprecated and will be removed in future version . Please use ' { } ' or another non - deprecated value . " , CLIENT_DNS_LOOKUP_CONFIG , ClientDnsLookup . DEFAULT , ClientDnsLookup . USE_ALL_DNS_IPS ) ; } }
public HdfsCopyStats ( String source , File destination , boolean enableStatsFile , int maxVersionsStatsFile , boolean isFileCopy , HdfsPathInfo pathInfo ) { this . sourceFile = source ; this . totalBytesTransferred = 0L ; this . bytesTransferredSinceLastReport = 0L ; this . pathInfo = pathInfo ; this . lastReportNs = System . nanoTime ( ) ; this . startTimeMS = System . currentTimeMillis ( ) ; initializeStatsFile ( destination , enableStatsFile , maxVersionsStatsFile , isFileCopy ) ; aggStats = HdfsFetcherAggStats . stats ; } private static HdfsFetcherAggStats aggStats ;
private void writeAlias ( VmDevice device ) { writer . writeStartElement ( "alias" ) ; writer . writeAttributeString ( "name" , String . format ( "ua - % s" , device . getId ( ) . getDeviceId ( ) ) ) ; writer . writeEndElement ( ) ; }
public ChartData ( IDataChartProvider < ? > provider , List < ChartSeries > series ) { fProvider = provider ; fSeries = ImmutableList . copyOf ( series ) ; }
protected boolean isRegistered ( final String uuid ) { return handlers . containsKey ( uuid ) && handlers . get ( uuid ) != null && ! handlers . get ( uuid ) . isEmpty ( ) ; }  This code checks if the `uuid` exists in the `handlers` map and if it has any registrations associated with it . It also checks if the value associated with the `uuid` is not null before checking if it is empty . This ensures that the code does not throw a `NullPointerException` if the value associated with the `uuid` is null .
< START > public Class < ? > defineClass ( String name , byte [ ] bytecode ) { < END > return defineClass ( name , convertClassToResourcePath ( name ) , bytecode ) ; }
public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { toggle ( ) ; if ( getSlidingMenu ( ) . isMenuShowing ( ) && menu . isAdded ( ) ) { setTitle ( ( ( ITitleable ) menu ) . getTitle ( ) ) ; } return true ; } return false ; }
public static ParcelFileDescriptor fromSocket ( Socket socket ) { FileDescriptor fd = socket . getFileDescriptor$ ( ) ; try { return fd != null ? ParcelFileDescriptor . dup ( fd ) : null ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
private String getThemePrefixedPath ( String path ) { String prefix = themeProperties != null ? themeProperties . get ( IntroTheme . ATT_ID ) : null ; prefix = prefix == null ? "" : prefix . trim ( ) ; if ( prefix . isEmpty ( ) ) { return null ; } return prefix + ( prefix . charAt ( prefix . length ( ) - 1 ) == Path . SEPARATOR ? "" : Path . SEPARATOR ) + path ; }
protected void writeString ( int majorType , byte [ ] bytes ) throws IOException { int len = ( bytes == null ) ? 0 : bytes . length ; writeType ( majorType , len ) ; if ( bytes != null ) { m_os . write ( bytes ) ; } }
private void checkLogData ( long address , ILogData logData ) { if ( logData == null || logData . getType ( ) == DataType . EMPTY ) { throw new RuntimeException ( "Unexpected return of empty data at address " + address + " on read" ) ; } if ( logData . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } // code to be executed after the if statements }
private static void merge ( AggregatedCalledFunction destination , AggregatedCalledFunction source ) { long sourceDuration = source . getDuration ( ) ; long sourceSelfTime = source . getSelfTime ( ) ; destination . addToDuration ( sourceDuration ) ; destination . addToSelfTime ( sourceSelfTime ) ; destination . fStatistics . update ( source . fStatistics . getMaxSegment ( ) , source . fStatistics . getMinSegment ( ) , sourceDuration , sourceSelfTime ) ; mergeChildren ( destination , source ) ; }
@Override protected void doEnqueue ( Callback < V > callback ) { sendRequest ( ) . handle ( ( response , t ) - > { if ( t != null ) { callback . onError ( t ) ; } else { V value = null ; try { value = parseResponse ( response , bodyConverter ) ; } catch ( Throwable t1 ) { propagateIfFatal ( t1 ) ; callback . onError ( t1 ) ; } if ( value != null ) { callback . onSuccess ( value ) ; } else { callback . onError ( new NullPointerException ( "Response was null" ) ) ; } } return null ; } ) ; }
public SpiTransaction createServerTransaction ( boolean isExplicit , int isolationLevel ) { SpiTransaction t = transactionManager . createTransaction ( isExplicit , isolationLevel ) ; if ( ! isExplicit ) { try { transactionScopeManager . set ( t ) ; } catch ( PersistenceException existingTransactionError ) { t . end ( ) ; throw existingTransactionError ; } } return t ; }
Code Refactored :  C baseApply ( ) { final TreeMap < String , String > t = new TreeMap < String , String > ( validate ( ) ) ; synchronized ( children ) { if ( ! children . containsKey ( t ) ) { C child = newChild ( ) ; children . put ( t , child ) ; return child ; } else { return children . get ( t ) ; } } }  The code has been refactored to make it thread - safe by adding a synchronized block to ensure that only one thread can access the `children` map at a time . The `contains ( ) ` method has been replaced with `containsKey ( ) ` to improve readability . The `putIfAbsent ( ) ` method could also be used instead of the `containsKey ( ) ` and `put ( ) ` methods to make the code more concise .
public void onConnect ( String message ) { debugView . showPermanently ( getString ( R . string . connected ) ) ; switchableView . setDisplayedChild ( 1 ) ; presenter . onConnect ( ) ; }

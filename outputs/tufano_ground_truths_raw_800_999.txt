public void benchWavTrack ( ) throws Exception { try { wavTrack = new WavTrack ( url ) ; boolean isEOMReached = false ; while ( ! isEOMReached ) { Frame process = wavTrack . process ( 0 ) ; isEOMReached = process . isEOM ( ) ; } } finally { wavTrack . close ( ) ; } }
private void setupLogger ( Map < String , Object > args ) throws IOException { Logger logger = Logger . getLogger ( "" ) ; logger . setLevel ( ( Level ) args . get ( "log - level" ) ) ; String logfile = ( String ) args . get ( "log - file" ) ; if ( logfile != null ) { FileHandler fh = new FileHandler ( logfile ) ; fh . setFormatter ( new SimpleFormatter ( ) ) ; logger . addHandler ( fh ) ; } }
public XWikiAttachment set ( XWikiAttachment attachment ) { XWikiAttachment put = map . put ( attachment . getFilename ( ) , attachment ) ; if ( put != attachment ) { added ( attachment ) ; updatedMap ( ) ; } return put ; }
public final boolean equals ( Object obj ) { if ( obj instanceof MethodKey ) { MethodKey toCompare = ( MethodKey ) obj ; return toCompare . name . equals ( name ) && toCompare . parameterTypes . equals ( parameterTypes ) ; } return false ; }
MongoDBTracing ( Builder builder ) { tracing = builder . tracing ; }
public void disconnect ( ) { Object lock = partitions != null ? partitions : new Object ( ) ; synchronized ( lock ) { document = null ; partitions . clear ( ) ; try { inputStream . close ( ) ; } catch ( IOException e ) { } } }
private void printInfo ( String sizeMessage , String inAlluxioMessage , String inMemMessage , String path ) { System . out . println ( inMemMessage . isEmpty ( ) ? String . format ( SHORT_INFO_FORMAT , sizeMessage , inAlluxioMessage , path ) : String . format ( LONG_INFO_FORMAT , sizeMessage , inAlluxioMessage , inMemMessage , path ) ) ; }
public void tearDown ( ) { // Destroy JMX beans created during testing . if ( metricsService != null ) { metricsService . shutdown ( true ) ; metricsService = null ; } JmxLeakHelper . checkJmxBeans ( ) ; // Stop executor service . if ( executionService != null ) { executionService . shutdown ( ) ; } }
public AdsBaseObject verifyAdImage ( String slotName , String src , String imageUrl ) { WebElement element = getWebElement ( slotName ) ; boolean isMobile = "MOBILE" . equalsIgnoreCase ( src ) ; Assertion . assertTrue ( new AdsComparison ( ) . compareImageWithScreenshot ( imageUrl , element , driver , isMobile ) ) ; PageObjectLogging . log ( "verifyAdImage" , "Ad looks good" , true , driver ) ; return this ; }
public synchronized Set < String > getUnmatchedLabels ( ) { return Collections . unmodifiableSet ( unmatchedLabels ) ; }
public void scanForRepoChanges ( ) throws IOException { getAllRefs ( ) ; // This will look for changes to refs if ( ! isBare ( ) ) getIndex ( ) ; // This will detect changes in the index }
public List < Server > getReachableServers ( ) { return null ; }
protected Guid getStoragePoolId ( ) { return getParameters ( ) . getStoragePoolId ( ) ; }
private int prerequirementImgResource ( String group ) { if ( group . equalsIgnoreCase ( AssignmentPrerequirement . RANK . toString ( ) ) ) { return R . drawable . rank_prerequirement ; } else if ( group . equalsIgnoreCase ( AssignmentPrerequirement . MISSION . toString ( ) ) ) { return R . drawable . group_prerequirement ; } else { return R . drawable . empty ; } }
public Iterator < ImageTypeSpecifier > getImageTypes ( int pImageIndex ) throws IOException { checkBounds ( pImageIndex ) ; // TODO : Better implementation , include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB return Arrays . asList ( getRawImageType ( pImageIndex ) ) . iterator ( ) ; }
private void resetPositions ( int positionCount ) { positions = ensureCapacity ( positions , positionCount ) ; this . positionCount = 0 ; }
public static SelectorHandler getHandler ( final String selectorStr ) { if ( ! selectorStr . isEmpty ( ) ) { for ( final Entry < String , SelectorHandler > handler : selectorHandlers . subMap ( selectorStr , true , selectorStr . substring ( 0 , 1 ) , true ) . entrySet ( ) ) { if ( selectorStr . startsWith ( handler . getKey ( ) ) ) { return handler . getValue ( ) ; } } } return vanillaHandler ; }
public synchronized void close ( ) { if ( closed ) { return ; } closed = true ; parentMemoryContext . updateBytes ( - usedBytes ) ; usedBytes = 0 ; }
public Map < ? extends K , ? extends V > getEntries ( ) { return entries ; }
public void testDefaultConfig ( ) throws Exception { Files . write ( springTestFile . toPath ( ) , "modification" . getBytes ( ) , StandardOpenOption . SYNC ) ; // Adding few millis to avoid fleaky tests // The file hasher could sometimes evaluate these two changes as duplicate , as the second modification of file could be done before hashing is done Thread . sleep ( 50 ) ; Files . write ( springTestFile . toPath ( ) , "modification 2" . getBytes ( ) , StandardOpenOption . SYNC ) ; MockEndpoint mock = getMockEndpoint ( "mock : springTest" ) ; mock . setExpectedCount ( 2 ) ; // two MODIFY events mock . setResultWaitTime ( 1000 ) ; mock . assertIsSatisfied ( ) ; }
private boolean startsOrEndsWithWhitespace ( String value ) { return ( StringUtils . isNotBlank ( value ) && ( Character . isSpaceChar ( value . charAt ( 0 ) ) || Character . isSpaceChar ( value . charAt ( value . length ( ) - 1 ) ) ) ) ; }
private void updateData ( OCShare share ) { // Update DB with the response share . setPath ( mPath ) ; share . setIsFolder ( mPath . endsWith ( FileUtils . PATH_SEPARATOR ) ) ; share . setPermissions ( READ_ONLY ) ; getStorageManager ( ) . saveShare ( share ) ; // Update OCFile with data from share : ShareByLink and publicLink OCFile file = getStorageManager ( ) . getFileByPath ( mPath ) ; if ( file != null ) { file . setShareWithSharee ( true ) ; // TODO - this should be done by the FileContentProvider , as part of getStorageManager ( ) . saveShare ( share ) getStorageManager ( ) . saveFile ( file ) ; } }
protected void startMasters ( boolean isLeader ) { try { connectToUFS ( ) ; mRegistry . start ( isLeader ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public BugzillaRestRepositoryConnectorUi ( ) { this . connector = BugzillaRestConnector . getDefault ( ) == null ? new BugzillaRestConnector ( ) : BugzillaRestConnector . getDefault ( ) ; }
public static ListStatusPOptions getListStatusOptions ( ) { return ListStatusPOptions . newBuilder ( ) . setCommonOptions ( getCommonOptions ( ) . toBuilder ( ) . setTtl ( Configuration . getMs ( PropertyKey . USER_FILE_LOAD_TTL ) ) . setTtlAction ( GrpcUtils . toProto ( Configuration . getEnum ( PropertyKey . USER_FILE_LOAD_TTL_ACTION , TtlAction . class ) ) ) ) . setLoadMetadataType ( GrpcUtils . toProto ( Configuration . getEnum ( PropertyKey . USER_FILE_METADATA_LOAD_TYPE , LoadMetadataType . class ) ) ) . build ( ) ; }
Node ( final String name , final NodeProcessor nodeProcessor , final Dag dag ) { requireNonNull ( nodeProcessor , "The nodeProcessor parameter can't be null . " ) ; this . nodeProcessor = nodeProcessor ; requireNonNull ( name , "The name of the node can't be null" ) ; this . name = name ; requireNonNull ( dag , "The dag of the node can't be null" ) ; this . dag = dag ; }
public String getTooltip ( MergeMode mode ) throws IllegalArgumentException { String tooltip ; switch ( mode ) { case LEFT_TO_RIGHT : tooltip = EMFCompareDiagramEditMessages . getString ( "merged . to . right . tooltip" ) ; // $NON - NLS - 1$ break ; case RIGHT_TO_LEFT : tooltip = EMFCompareDiagramEditMessages . getString ( "merged . to . left . tooltip" ) ; // $NON - NLS - 1$ break ; case ACCEPT : tooltip = EMFCompareDiagramEditMessages . getString ( "accept . change . tooltip" ) ; // $NON - NLS - 1$ break ; case REJECT : tooltip = EMFCompareDiagramEditMessages . getString ( "reject . change . tooltip" ) ; // $NON - NLS - 1$ break ; default : throw new IllegalArgumentException ( ) ; } return tooltip ; }
public TriggeredBuildSelector ( boolean fallbackToLastSuccessful , UpstreamFilterStrategy upstreamFilterStrategy , boolean allowUpstreamDependencies ) { this . fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean . TRUE : null ; this . upstreamFilterStrategy = upstreamFilterStrategy ; this . allowUpstreamDependencies = allowUpstreamDependencies ; }
public static Result deleteUser ( Long userId ) { if ( User . findByLoginId ( session ( ) . get ( "loginId" ) ) . isSiteManager ( ) ) { if ( Project . isOnlyManager ( userId ) ) { flash ( Constants . WARNING , "site . userList . deleteAlert" ) ; } else { User . find . byId ( userId ) . delete ( ) ; } } else { flash ( Constants . WARNING , "auth . unauthorized . waringMessage" ) ; } return redirect ( routes . SiteApp . userList ( 0 , null ) ) ; }
public Attachment ( @NonNull Uri uri , @NonNull String contentType , long date , @Nullable String fileName ) { if ( uri == null || contentType == null || date < 0 ) { throw new AssertionError ( "uri , content type , and date must all be specified" ) ; } this . uri = uri ; this . fileName = fileName ; this . contentType = contentType ; this . date = date ; }
private List < VoldemortService > createServices ( ) { List < VoldemortService > services = new ArrayList < VoldemortService > ( ) ; services . add ( new CoordinatorProxyService ( config , storeClientConfigs ) ) ; if ( config . isAdminServiceEnabled ( ) ) { services . add ( new CoordinatorAdminService ( config , storeClientConfigs ) ) ; } return ImmutableList . copyOf ( services ) ; }
public void afterBegin ( ) throws EJBException , RemoteException { log . trace ( "afterBegin called" ) ; checker . setSynchronizedBegin ( ) ; }
private boolean checkPagingSpec ( PagingSpec pagingSpec , boolean descending ) { for ( Integer value : pagingSpec . getPagingIdentifiers ( ) . values ( ) ) { if ( descending ^ ( value < 0 ) ) { return false ; } } return pagingSpec . getThreshold ( ) >= 0 ; }
private void init ( Jdbi db ) { db . registerArrayType ( UserId . class , "int" , UserId : : getId ) ; db . registerColumnMapper ( new UserIdColumnMapper ( ) ) ; }
protected boolean updateBrickServerName ( GlusterBrickEntity brick , boolean addCanDoActionMessage ) { VdsStatic server = getVdsStaticDao ( ) . get ( brick . getServerId ( ) ) ; if ( ( server == null || ! server . getvds_group_id ( ) . equals ( getVdsGroupId ( ) ) ) ) { if ( addCanDoActionMessage ) { addCanDoActionMessage ( VdcBllMessages . ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID ) ; } return false ; } brick . setServerName ( server . gethost_name ( ) ) ; return true ; }
private static @NonNull String getSpanName ( String attributeName ) { return attributeName . substring ( 0 , attributeName . lastIndexOf ( ' / ' ) ) ; }
private static boolean containsAll ( String text , final Collection < String > items ) { final String _text = text . toLowerCase ( ) ; return items . stream ( ) . allMatch ( it - > { return _text . contains ( it ) ; } ) ; }
private void recursiveDelete ( Path file ) throws IOException { Files . walkFileTree ( file , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @Override public FileVisitResult postVisitDirectory ( Path dir , IOException e ) throws IOException { if ( e != null ) { throw e ; } Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ) ; }
public Optional < Object > nextMarker ( ) { if ( totalCount < pageSize ) return Optional . absent ( ) ; if ( ( float ) pageNumber < ( ( float ) totalCount / ( float ) pageSize ) ) { return Optional . of ( toPaginationOptions ( pageNumber + 1 ) ) ; } return Optional . absent ( ) ; }
public void testInvalidUser ( AuthenticationFlowContext context , UserModel user ) { if ( user == null ) { dummyHash ( context ) ; context . getEvent ( ) . error ( Errors . USER_NOT_FOUND ) ; Response challengeResponse = challenge ( context , getDefaultChallengeMessage ( context ) ) ; context . failureChallenge ( AuthenticationFlowError . INVALID_USER , challengeResponse ) ; } }
public boolean validateChecksum ( ) { if ( StringUtils . isNotBlank ( checksum ) ) { try { return DigestHelper . check ( checksum , new FileInputStream ( downloadedFilePath ) ) ; } catch ( IOException e ) { throw new CloudRuntimeException ( "could not check sum for file : " + downloadedFilePath , e ) ; } catch ( NoSuchAlgorithmException e ) { throw new CloudRuntimeException ( "Unknown checksum algorithm : " + checksum , e ) ; } } return true ; }
public RegistrationUpdateEvent ( String address , List < RegistrationInfo > registrations ) { this . address = address ; this . registrations = registrations == null ? Collections . emptyList ( ) : registrations ; }
public InvocationContext createInvocationContext ( boolean isWrite , int keyCount ) { if ( keyCount == 1 ) { return new SingleKeyNonTxInvocationContext ( true , keyEq ) ; } else if ( keyCount > 0 ) { return new NonTxInvocationContext ( keyCount , true , keyEq ) ; } return createInvocationContext ( null ) ; }
private boolean isRealWorklog ( final EveritWorklog worklog ) { boolean isRealWorklog = true ; if ( issuesRegex != null ) { for ( Pattern issuePattern : issuesRegex ) { boolean issueMatches = issuePattern . matcher ( worklog . getIssue ( ) ) . matches ( ) ; // if match not count in summary if ( issueMatches ) { isRealWorklog = false ; break ; } } } return isRealWorklog ; }
public void removed ( IExtension [ ] extensions ) { for ( IExtension extension : extensions ) { CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider . get ( extension ) ; if ( layoutAlgorithmProvider != null ) { List < CustomLayoutAlgorithm > customLayoutAlgorithms = layoutAlgorithmProvider . getCustomLayoutAlgorithms ( ) ; for ( CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms ) { layoutProviderRegistry . remove ( customLayoutAlgorithm . getId ( ) ) ; } } extensionToLayoutAlgorithmProvider . remove ( extension ) ; } }
public void increment ( int typeId ) { if ( typeId >= counts . length ) { counts = Arrays . copyOf ( counts , max ( counts . length * 2 , typeId + 1 ) ) ; } counts [ typeId ] ++ ; if ( typeId > highestTypeId ) { highestTypeId = typeId ; } }
private static void delete ( List < ReceiveCommand > cmds , List < ReceiveCommand > createCmds ) { for ( ReceiveCommand cmd : createCmds ) { ObjectId id = cmd . getNewId ( ) ; String name = cmd . getRefName ( ) ; cmds . add ( new ReceiveCommand ( id , ObjectId . zeroId ( ) , name ) ) ; } }
public RefreshLocalVisitor ( IProgressMonitor monitor ) { this . monitor = SubMonitor . convert ( monitor ) ; workspace = ( Workspace ) ResourcesPlugin . getWorkspace ( ) ; resourceChanged = false ; String msg = Messages . resources_errorMultiRefresh ; errors = new MultiStatus ( ResourcesPlugin . PI_RESOURCES , IResourceStatus . FAILED_READ_LOCAL , msg , null ) ; }
private ConfigurationImpl ( ) { this . validationBootstrapParameters = new ValidationBootstrapParameters ( ) ; this . defaultResourceBundleLocator = new PlatformResourceBundleLocator ( ResourceBundleMessageInterpolator . USER_VALIDATION_MESSAGES ) ; this . defaultTraversableResolver = new DefaultTraversableResolver ( ) ; this . defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl ( ) ; this . defaultParameterNameProvider = new DefaultParameterNameProvider ( ) ; this . defaultMessageInterpolator = new ResourceBundleMessageInterpolator ( defaultResourceBundleLocator ) ; }
public void testNull_Event ( ) { assertNull ( xdrTransformHelper . transformXDRResponseToCheckPolicy ( null ) ) ; assertNull ( xdrTransformHelper . transformXDRToCheckPolicy ( null ) ) ; }
public void testJNDIBindingsNoAppName ( ) throws Exception { Context ctx = getInitialContext ( HOST , PORT ) ; Hello ejb = ( Hello ) ctx . lookup ( "ejb :/ ejb - jndi / Hello ! org . jboss . as . test . integration . ejb . jndi . logging . Hello" ) ; Assert . assertNotNull ( "Null object returned for local business interface lookup in the ejb namespace" , ejb ) ; Assert . assertTrue ( "Expected JNDI binding message not found" , LoggingUtil . hasLogMessage ( managementClient , TEST_HANDLER_NAME , "ejb :/ ejb - jndi / Hello ! org . jboss . as . test . integration . ejb . jndi . logging . Hello" ) ) ; }
public CrossesListDescriptionSheetParser ( final T importedList , final UserDataManager userDataManager ) { this . importedList = importedList ; this . doParseDetails = true ; this . doParseConditions = true ; this . doParseFactors = true ; this . doParseVariates = true ; this . userDataManager = userDataManager ; this . descriptionSheetIndex = 0 ; }
public VolumeClassification getVolumeClassification ( ) { if ( volumeClassification == null ) { return ( active ? VolumeClassification . Volume : VolumeClassification . Snapshot ) ; } return volumeClassification ; }
public void registerSonarQubeVersion_publishes_version_on_first_call ( ) { ClusterProperties clusterProperties = new ClusterProperties ( newClusterSettings ( ) ) ; try ( HazelcastCluster hzCluster = HazelcastCluster . create ( clusterProperties ) ) { hzCluster . registerSonarQubeVersion ( "1 . 0 . 0 . 0" ) ; HazelcastInstance hzInstance = createHazelcastClient ( hzCluster ) ; assertThat ( hzInstance . getAtomicReference ( SONARQUBE_VERSION ) . get ( ) ) . isEqualTo ( "1 . 0 . 0 . 0" ) ; } }
public String [ ] getColumnTexts ( @NonNull ITimeGraphEntry entry ) { String [ ] texts = null ; if ( fColumns != null ) { texts = new String [ fColumns . length ] ; for ( int i = 0 ; i < fColumns . length ; i ++ ) { texts [ i ] = fLabelProvider . getColumnText ( entry , i ) ; } } else { texts = new String [ 1 ] ; texts [ 0 ] = entry . getName ( ) ; } return texts ; }
private Pageview ( ) { }
public TreeFillingConfigurationDialog ( final Shell parentShell , final TreeFillingConfiguration treefillingConfiguration , final List < ILabelProviderConfiguration > existingLabelProvidersConfiguration , final List < PasteEObjectConfiguration > existingPasteConfigurations ) { super ( parentShell ) ; this . modifiedTreefillingConfiguration = EcoreUtil . copy ( treefillingConfiguration ) ; this . existingLabelProviderConfigurations = existingLabelProvidersConfiguration ; this . existingPasteConfigurations = existingPasteConfigurations ; setTitle ( Messages . TreeFillingConfigurationDialog_treeFillingConfigurationDialogName ) ; }
public void execute ( final Talks talks ) throws IOException { int idx = this . index ( talks ) ; for ( final Talk talk : talks . active ( ) ) { idx += 1 ; talk . modify ( new Directives ( ) . xpath ( " / talk / request" ) . attr ( "index" , Integer . toString ( idx ) ) ) ; } }
public long getSafePointDrId ( ) { assert ( ! m_map . isEmpty ( ) ) ; return end ( m_map . asRanges ( ) . iterator ( ) . next ( ) ) ; }
public void setUp ( ) throws Exception { createProjectWithNfcAndSetVariable ( ) ; baseActivityTestRule . launchActivity ( null ) ; }
public ListRequest list ( ) { return new ListRequest ( ) { @Override public List < ProjectInfo > get ( ) throws RestApiException { return list ( this ) ; } } ; }
public void validateEnums ( WatchDog entity ) { if ( entity != null ) { EnumValidator . validateEnum ( WatchdogAction . class , entity . getAction ( ) , true ) ; EnumValidator . validateEnum ( WatchdogModel . class , entity . getModel ( ) , true ) ; } }
void error ( ZuulException e ) { RequestContext . getCurrentContext ( ) . setThrowable ( e ) ; zuulRunner . error ( ) ; }
private List < String > defaultIncludedModuleNamesForUnnamedModule ( ) { if ( fJavaElements != null ) { List < IPackageFragmentRoot > roots = new ArrayList < > ( ) ; for ( IJavaElement element : fJavaElements ) { if ( element instanceof IPackageFragmentRoot ) { roots . add ( ( IPackageFragmentRoot ) element ) ; } } return JavaCore . defaultRootModules ( roots ) ; } return Collections . emptyList ( ) ; }
public void disable ( @RequestBody List < Long > printerIds ) throws IOException { setState ( printerIds , false ) ; }
public double getFilterMinSelectivityEstimateFactor ( ) { return options . getOption ( FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR ) ; }
public JavaOutputProcessor ( PrettyPrinter printer ) { this . printer = printer ; }
public BucketFunction getBucketFunction ( ConnectorTransactionHandle transactionHandle , ConnectorSession session , ConnectorPartitioningHandle partitioningHandle , List < Type > partitionChannelTypes , int bucketCount ) { HivePartitioningHandle handle = ( HivePartitioningHandle ) partitioningHandle ; BucketFunctionType bucketFunctionType = handle . getBucketFunctionType ( ) ; switch ( bucketFunctionType ) { case HIVE_COMPATIBLE : return createHiveCompatibleBucketFunction ( bucketCount , handle . getHiveTypes ( ) . get ( ) ) ; case PRESTO_NATIVE : return createPrestoNativeBucketFunction ( bucketCount , handle . getTypes ( ) . get ( ) ) ; default : throw new IllegalArgumentException ( "Unsupported bucket function type " + bucketFunctionType ) ; } }
public void writePacketData ( RailcraftOutputStream data ) throws IOException { super . writePacketData ( data ) ; // tankManager . writePacketData ( data ) ; data . writeBoolean ( boiler . isBurning ( ) ) ; }
protected void setValue ( final int rowIndex , final int columnIndex , final Date value ) { DTCellValue52 dtCellValue52 = table52 . getData ( ) . get ( rowIndex ) . get ( columnIndex ) ; dtCellValue52 . setDateValue ( value ) ; updateManager . update ( table52 , getUpdates ( rowIndex , columnIndex ) ) ; }
private TreeMap < Event , List < EntryDTO > > buildEventEntryDTOMap ( List < EntryDTO > entryDTOS ) { return entryDTOS . stream ( ) . collect ( Collectors . groupingBy ( EntryDTO : : getEvent , ( ) - > new TreeMap < > ( Comparator . comparing ( Event : : getWhenOccured ) . thenComparing ( Event : : getExternalId ) ) , Collectors . toList ( ) ) ) ; }
private void verifyTableProperty ( String propertyName , int propertyValue ) { waitForElementByElement ( table ) ; Assertion . assertEquals ( table . getAttribute ( propertyName ) , Integer . toString ( propertyValue ) ) ; PageObjectLogging . log ( "verifyTableProperty" , "table has correct " + propertyName + " property" , true ) ; }
public ColumnMetadata_v4 ( String [ ] name , PrimitiveType . PrimitiveTypeName primitiveType , Object minValue , Object maxValue , Long nulls ) { super ( name , primitiveType , minValue , maxValue , nulls ) ; }
public ReflogEntry getReverseEntry ( int number ) throws IOException { lock . lock ( ) ; try { LogCursor cursor = reftable . seekLog ( refname ) ; while ( true ) { if ( ! cursor . next ( ) || number < 0 ) { return null ; } if ( number == 0 ) { return cursor . getReflogEntry ( ) ; } number -- ; } } finally { lock . unlock ( ) ; } }
public void testVersion0_98IsValid ( ) throws Exception { rootDir = Paths . get ( getClass ( ) . getClassLoader ( ) . getResource ( "bags / v0_98 / bag" ) . toURI ( ) ) ; Bag bag = reader . read ( rootDir ) ; sut . isValid ( bag , true ) ; }
public ProgramState checkPreStatement ( CheckerContext context , Tree syntaxNode ) { AbstractStatementVisitor visitor = new PreStatementVisitor ( context ) ; syntaxNode . accept ( visitor ) ; return visitor . programState ; }
public ParameterMap getQueryParams ( MuleEvent event ) { return resolveParams ( event , HttpParamType . QUERY_PARAM ) ; }
public Mutation ( Mutation m ) { m . serialize ( ) ; this . row = m . row ; this . data = m . data ; this . entries = m . entries ; this . values = m . values ; this . replicationSources = m . replicationSources ; }
public DecoratedCache ( AdvancedCache < K , V > delegate , ClassLoader classLoader ) { this ( delegate , classLoader , null ) ; }
default Query getRemoveByQuery ( ) { return isVersionedEntity ( ) ? getQueryForVersion ( ) : getByIdQuery ( ) ; }
public void addError ( String errorMessage , Element element ) { errors . add ( new ProblemImpl ( errorMessage , element ) ) ; }
private void validatePage ( ) { String message = null ; if ( userText . getText ( ) . trim ( ) . isEmpty ( ) ) { message = Messages . CredentialsWizardPage_ErrorUser ; } else if ( passwordText . getText ( ) . trim ( ) . isEmpty ( ) ) { message = Messages . CredentialsWizardPage_ErrorPassword ; } setErrorMessage ( message ) ; setPageComplete ( message == null ) ; }
public boolean isSupporting ( Capabilities capabilities ) { return BrowserType . EDGE . equals ( capabilities . getBrowserName ( ) ) ; }
public HistoryTreeStub getHistoryTree ( ) { return ( HistoryTreeStub ) super . getSHT ( ) ; }
public static Iterable < ITmfEventAspect < ? > > getEventAspects ( ITmfTrace trace , Class < ? extends ITmfEventAspect < ? > > aspectClass ) { return Iterables . filter ( Iterables . concat ( trace . getEventAspects ( ) , EXTRA_ASPECTS ) , aspect - > aspectClass . isAssignableFrom ( aspect . getClass ( ) ) ) ; }
public PrestoSparkRow get ( ) throws InterruptedException { PrestoSparkRow row = null ; synchronized ( monitor ) { while ( buffer . isEmpty ( ) && ! finished ) { monitor . wait ( ) ; } if ( ! buffer . isEmpty ( ) ) { row = buffer . poll ( ) ; } } if ( row != null ) { memoryManager . updateMemoryUsage ( - row . getRetainedSize ( ) ) ; } return row ; }
private ByteBuffer parsePacketIDBAndNRB ( int blockLength ) throws IOException { ByteBuffer pcapPacketData ; pcapPacketData = ByteBuffer . allocate ( blockLength - PcapFileValues . PCAPNG_PACKET_HEADER_SIZE ) ; pcapPacketData . clear ( ) ; SeekableByteChannel fFileChannel ; try { fFileChannel = getFileChannel ( ) ; fFileChannel . read ( pcapPacketData ) ; } catch ( BadPcapFileException e1 ) { /* Just ignore */ } pcapPacketData . flip ( ) ; return pcapPacketData ; }
public MiniEditorComponentObject triggerEditCommentArea ( ) { jsActions . scrollToElement ( allCommentsArea ) ; WebElement mostRecentComment = articleComments . get ( 0 ) ; PageObjectLogging . log ( "First check" , mostRecentComment . getText ( ) , true ) ; JavascriptExecutor js = ( JavascriptExecutor ) driver ; WebElement editButton = mostRecentComment . findElement ( By . cssSelector ( EDIT_BUTTON_SELECTOR ) ) ; new Actions ( driver ) . moveToElement ( editButton ) . perform ( ) ; js . executeScript ( "arguments [ 0 ] . querySelector ( arguments [ 1 ] ) . click ( ) " , mostRecentComment , EDIT_BUTTON_SELECTOR ) ; return new MiniEditorComponentObject ( driver ) ; }
public String getContentAccessModeList ( ) { return this . contentAccessModeList ; }
public void setUp ( ) { configuration = Configuration . DEFAULT ; }
public void onDestroyView ( ) { try { mWebViewBridge . destroy ( ) ; } catch ( Exception exp ) { Log . w ( TAG , exp . getMessage ( ) + "" , exp ) ; } mWebViewBridge = null ; super . onDestroyView ( ) ; }
private static void deleteDir ( HdfsContext context , HdfsEnvironment hdfsEnvironment , Path path , boolean recursive ) { try { hdfsEnvironment . getFileSystem ( context , path ) . delete ( path , recursive ) ; } catch ( Exception e ) { // don't fail if unable to delete path log . warn ( e , "Failed to delete path : " + path . toString ( ) ) ; } }
private static boolean isNakedTD1Key ( String s ) { return NAKED_TD1_KEY_PATTERN . matcher ( s ) . matches ( ) ; }
public long skip ( long n ) throws IOException { if ( n <= 0 ) { return 0 ; } if ( n > MOVEMENT_LIMIT ) { mSequentialReadCount = 0 ; } mPos += n ; return n ; }
public void testUnmarshallSubprocessLevelEventEmptyProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_START_EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartNoneEvent emptySubprocess = getStartNodeById ( diagram , EMPTY_SUBPROCESS_LEVEL_EVENT_ID , StartNoneEvent . class ) ; assertGeneralSet ( emptySubprocess . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertNotNull ( emptySubprocess . getExecutionSet ( ) ) ; assertStartEventSlaDueDate ( emptySubprocess . getExecutionSet ( ) , EMPTY_VALUE ) ; }
private List < Window > fetchWindowsInQueue ( ) { return ImmutableList . copyOf ( getWindows ( ) ) ; }
protected void executeCommand ( IDeviceManagementInteractor executor ) throws DeploymentException { executor . startFB ( resource , new FBDeploymentData ( "" , resFB ) ) ; // $NON - NLS - 1$ // TODO correctly determine prefix }
private void setReaderBudget ( ) { reader . setResultSizeBudget ( ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes ) ; }
default < T > Flux < T > find ( Query query , Class < T > entityType ) { return find ( query , entityType , entityType ) ; }
public Object execute ( ExecutionEvent event ) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard ( util . getConfiguredRepositories ( ) , true ) ; WizardDialog dialog = new WizardDialog ( getShell ( event ) , wizard ) ; if ( dialog . open ( ) == Window . OK ) { for ( String dir : wizard . getDirectories ( ) ) { File repositoryDir = FileUtils . canonicalize ( new File ( dir ) ) ; addRepository ( repositoryDir ) ; } } return null ; }
public Map < String , String > load ( ) { final Map < String , String > preferences = new HashMap < String , String > ( ) ; final String property = getProperty ( ) ; log . info ( "Setting preference '" + GuidedDecisionTableEditorService . DTABLE_VERIFICATION_ENABLED + "' to '" + property + "' . " ) ; preferences . put ( GuidedDecisionTableEditorService . DTABLE_VERIFICATION_ENABLED , property ) ; return preferences ; }
protected int getParallelHostCount ( UpgradeContext ctx , int defaultValue ) { if ( m_grouping . parallelScheduler != null ) { int taskParallelism = m_grouping . parallelScheduler . maxDegreeOfParallelism ; if ( taskParallelism == ParallelScheduler . DEFAULT_MAX_DEGREE_OF_PARALLELISM ) { taskParallelism = ctx . getDefaultMaxDegreeOfParallelism ( ) ; } return taskParallelism ; } return defaultValue ; }
public synchronized static boolean stopIfIsPlaying ( @Nullable AudioSlide slide ) { if ( playing . isPresent ( ) && playing . get ( ) . getAudioSlide ( ) . equals ( slide ) ) { playing . get ( ) . stop ( ) ; return true ; } else { return false ; } }
public List < AggregatorFactory > getRequiredColumns ( ) { return fields . stream ( ) . map ( field - > new CardinalityAggregatorFactory ( field . getOutputName ( ) , null , Collections . singletonList ( field ) , byRow , round ) ) . collect ( Collectors . toList ( ) ) ; }
public Optional < Object > getRequestAttribute ( final String name ) { return Optional . ofNullable ( this . request . getAttribute ( name ) ) ; }
private static String reflogComments ( List < ReflogEntry > entries ) { StringBuffer b = new StringBuffer ( ) ; for ( ReflogEntry e : entries ) { b . append ( e . getComment ( ) ) . append ( " ; " ) ; } return b . toString ( ) ; }
private static void validateName ( String value ) throws WSSecurityException { Name name ; try { name = new LdapName ( value ) ; } catch ( Exception e ) { LOG . info ( "Validation of X509 Subject Name failed : { } " , e . getLocalizedMessage ( ) , e ) ; throw new WSSecurityException ( ErrorCode . FAILURE , "Not a valid X509 Subject Name . " ) ; } }
private static SimpleFeatureCollection parseGeoJSON ( InputStream in , CoordinateReferenceSystem crs ) throws IOException { Map < String , Object > geojson = OM . readValue ( in , TYPE_REF ) ; SimpleFeatureType schema = GeoJSONSchemaDetector . getSchema ( geojson , crs ) ; return GeoJSONReader2 . toFeatureCollection ( geojson , schema ) ; }
private void refreshHostStorage ( Guid hostId ) { getBackendCollection ( VdcQueryType . GetDeviceList , new GetDeviceListQueryParameters ( hostId , StorageType . ISCSI , false , null ) ) ; }
public void openTestShells ( ) { for ( int i = 1 ; i <= TEST_SHELLS_COUNT ; i ++ ) { String shellTitle = "shell" + i ; Display . syncExec ( ( ) - > { ShellTestUtils . createShell ( shellTitle ) ; } ) ; shells . add ( new DefaultShell ( shellTitle ) ) ; } }
private RangeColumnStatistics ( Optional < Object > lowValue , Optional < Object > highValue , Estimate fraction , Estimate dataSize , Estimate distinctValuesCount ) { this . lowValue = requireNonNull ( lowValue , "lowValue can not be null" ) ; this . highValue = requireNonNull ( highValue , "highValue can not be null" ) ; this . fraction = requireNonNull ( fraction , "fraction can not be null" ) ; this . dataSize = requireNonNull ( dataSize , "dataSize can not be null" ) ; this . distinctValuesCount = requireNonNull ( distinctValuesCount , "distinctValuesCount can not be null" ) ; }
public void close ( ) { log . debug ( "Closing record collector" ) ; if ( eosEnabled ) { streamsProducer . abortTransaction ( ) ; } checkForException ( ) ; }
public static FileSystemContext create ( ClientContext clientContext ) { FileSystemContext ctx = new FileSystemContext ( ) ; ctx . init ( clientContext , MasterInquireClient . Factory . create ( clientContext . getClusterConf ( ) ) ) ; return ctx ; }
private synchronized URI createNextResultsUri ( String scheme , UriInfo uriInfo ) { return uriInfo . getBaseUriBuilder ( ) . scheme ( scheme ) . replacePath ( " / v1 / statement" ) . path ( queryId . toString ( ) ) . path ( String . valueOf ( resultId . incrementAndGet ( ) ) ) . replaceQuery ( "" ) . build ( ) ; }
public void commitToFile ( ) throws Exception { // Given afw . write ( expectedContent , 0 , expectedContent . length ( ) ) ; // When afw . commit ( ) ; // Then assertEquals ( expectedContent . length ( ) , Files . size ( af . toPath ( ) ) ) ; }
public void setColumnWidthPercentageByPosition ( int columnPosition , int width , boolean fireEvent ) { this . columnWidthConfig . setPercentage ( columnPosition , width ) ; if ( fireEvent ) { fireLayerEvent ( new ColumnResizeEvent ( this , columnPosition ) ) ; } }
protected void connect ( ) { // note that we are not connecting via JMX for testing mbeanServerConn = null ; jmxc = null ; ssProxy = StorageService . instance ; msProxy = MessagingService . instance ( ) ; streamProxy = StreamManager . instance ; compactionProxy = CompactionManager . instance ; fdProxy = ( FailureDetectorMBean ) FailureDetector . instance ; cacheService = CacheService . instance ; spProxy = StorageProxy . instance ; hhProxy = HintedHandOffManager . instance ; gcProxy = new GCInspector ( ) ; gossProxy = Gossiper . instance ; memProxy = ManagementFactory . getMemoryMXBean ( ) ; runtimeProxy = ManagementFactory . getRuntimeMXBean ( ) ; }
private void sortPositions ( int arrayLength , Comparator < Integer > comparator ) { List < Integer > list = positions . subList ( 0 , arrayLength ) ; try { list . sort ( comparator ) ; } catch ( IllegalArgumentException e ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , "Lambda comparator violates the comparator contract" , e ) ; } }
public void deactivate ( ) { try { httpService . unregister ( WEBAPP_ALIAS + SERVLET_NAME ) ; } catch ( IllegalArgumentException e ) { logger . debug ( "LgTv Servlet ' { } ' was not registered . Nothing to deactivate . " , WEBAPP_ALIAS + SERVLET_NAME ) ; } finally { logger . info ( "Stopped LgTv Servlet" ) ; } }
public void freeTicketWhenExists ( TicketsInteractor mockedTicketsInteractor ) throws RecordNotFoundException , UpdateTicketStateUnauthorizedException { long ticketId = 1 ; ObjectNode json = Json . newObject ( ) ; ArrayNode node = json . putArray ( ConstantsManager . TICKET_IDS_FIELD_NAME ) ; node . add ( ticketId ) ; when ( mockedBody . asJson ( ) ) . thenReturn ( json ) ; Result result = ticketsController . free ( ) ; assertEquals ( Helpers . OK , Helpers . status ( result ) ) ; verify ( mockedTicketsInteractor ) . freeATicket ( ticketId ) ; }
private static < E > View < E > load ( JobContext jobContext ) { Configuration conf = Hadoop . JobContext . getConfiguration . invoke ( jobContext ) ; Class < E > type = getType ( jobContext ) ; String outputUri = conf . get ( KITE_OUTPUT_URI ) ; return Datasets . < E , View < E > > load ( outputUri , type ) ; }
public boolean validate ( Map < String , String > optionsMap ) { if ( ! super . validate ( optionsMap ) ) { return false ; } if ( ! validatePrincipalLogin ( ) ) { return false ; } return true ; }
private void createEdit ( ) { Button button = createButton ( buttonparent , buttonEdit_ID , buttonEdit_caption , true ) ; buttonBar . pack ( ) ; }
public E read ( String line ) { return read ( line , null ) ; }
public void centerOnCurrentLocation ( ) { followMe = true ; findMe ( ) ; }
public void serialize ( final DoublesSketch sketch , final JsonGenerator generator , final SerializerProvider provider ) throws IOException { generator . writeBinary ( sketch . toByteArray ( true ) ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( StringUtil . simpleClassName ( this ) ) . append ( ' [ ' ) ; for ( int i = 0 ; i < topicSubscriptions . size ( ) ; i ++ ) { builder . append ( topicSubscriptions . get ( i ) ) . append ( " , " ) ; } if ( ! topicSubscriptions . isEmpty ( ) ) { builder . setLength ( builder . length ( ) - 2 ) ; } return builder . append ( ' ] ' ) . toString ( ) ; }
private Field [ ] getFields ( Class < ? > currentClass ) { final List < Field > fields = new ArrayList < > ( ) ; while ( currentClass != null ) { fields . addAll ( Arrays . asList ( currentClass . getDeclaredFields ( ) ) ) ; currentClass = currentClass . getSuperclass ( ) ; } return fields . toArray ( new Field [ 0 ] ) ; }
public void setDecoderResult ( DecoderResult decoderResult ) { this . decoderResult = ObjectUtil . checkNotNull ( decoderResult , "decoderResult" ) ; }
protected String contentFrom ( FitNesseContext context , Request request , WikiPage requestedPage ) { return prepareResponseDocument ( context ) . html ( request ) ; }
public void start ( ) { }
private void doc ( Class c ) throws IOException { open ( "tr class = 'TableRowColor'" ) ; open ( "td" ) ; around ( "span class = 'modifiers'" , getModifiers ( c ) ) ; close ( "td" ) ; open ( "td" ) ; link ( c . getType ( ) ) ; tag ( "br" ) ; around ( "span class = 'doc'" , getDoc ( c ) ) ; close ( "td" ) ; close ( "tr" ) ; }
public List < Pair < AbstractIngredient [ ] , Float > > lookupShapedRecipes ( Item i ) { return shapedReverseLookupTable . get ( i ) ; }
public boolean exists ( ) { return exists ( new EventMetadata ( ) ) ; }
void startIndexPopulation ( IndexPopulationJob job ) { populationJobs . add ( job ) ; scheduler . schedule ( indexPopulation , new IndexPopulationJobWrapper ( job , this ) ) ; }
public static int getOptionAsInteger ( Map < String , String > options , String option , int defaultValue ) { String value = options . get ( option ) ; return value == null ? defaultValue : Integer . parseInt ( value ) ; }
public synchronized void releaseBuffer ( ) { if ( serializedCache != null ) { serializedCache . release ( ) ; if ( serializedCache . refCnt ( ) == 0 ) { serializedCache = null ; } } }
public String getProvider ( ) { return nativeGetProvider ( nativePtr ) ; }
private static Set < SymbolicValue > computedFrom ( @Nullable SymbolicValue symbolicValue ) { if ( symbolicValue == null ) { return Collections . emptySet ( ) ; } Set < SymbolicValue > result = new HashSet < > ( ) ; result . add ( symbolicValue ) ; symbolicValue . computedFrom ( ) . forEach ( sv - > result . addAll ( computedFrom ( sv ) ) ) ; return result ; }
public ClassLoader getClassLoader ( ) { return this . getClass ( ) . getClassLoader ( ) ; }
public Integer add ( Stream < E > entities ) { return delegate ( ) . add ( entities . filter ( entity - > { // throws exception if no permission on the containing package isOperationPermitted ( entity , Action . CREATE ) ; createAcl ( entity ) ; return true ; } ) ) ; }
public void canIgnoreInvocationsWithJunit ( ) throws InterruptedException { // given DelayedExecution delayedExecution = createZeroMillisDelayedExecution ( ) ; DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution ( ) ; // when delayedExecution . allAsyncCallsStarted ( ) ; // then verify ( mock , timeout ( 50 ) ) . oneArg ( '1' ) ; // when twentyMillisDelayedExecution . allAsyncCallsStarted ( ) ; // then verify ( mock , timeout ( 50 ) ) . oneArg ( '2' ) ; }
public final boolean isExtendedLifetimeValid ( ) { // extended lifetime is only valid if it contains an access token if ( mExtendedExpiresOn != null && ! StringExtensions . IsNullOrBlank ( mAccessToken ) ) { return ! isTokenExpired ( mExtendedExpiresOn ) ; } return false ; }
public void sendDocumentFinalizedMessage ( IWantDocument iWantDocument ) { BodyMailMessage message = buildDocumentFinalizedMessage ( iWantDocument ) ; try { emailService . sendMessage ( message , false ) ; } catch ( Exception e ) { LOG . error ( ( "sendDocumentFinalizedMessage , Email could not be sent for IWNT edoc# " + iWantDocument . getDocumentNumber ( ) ) , e ) ; } }
void addStore ( PartitionId partitionId , ReplicationTest . StoreEventListener listener ) { storesByPartition . computeIfAbsent ( partitionId , partitionId1 - > new InMemoryStore ( partitionId , infosByPartition . computeIfAbsent ( partitionId1 , ( Function < PartitionId , List < MessageInfo > > ) partitionId2 - > new ArrayList < > ( ) ) , buffersByPartition . computeIfAbsent ( partitionId1 , ( Function < PartitionId , List < ByteBuffer > > ) partitionId22 - > new ArrayList < > ( ) ) , listener ) ) ; }
private static long doubleToSortableLong ( double value ) { long bits = Double . doubleToLongBits ( value ) ; return bits ^ ( ( bits > > 63 ) & Long . MAX_VALUE ) ; }
default int getGroupedJobInitializerCacheSize ( ) { return 100 ; }
public DefaultCompactionPolicyTest ( ) throws InterruptedException { Pair < MockBlobStore , StoreConfig > initState = CompactionPolicyTest . initializeBlobStore ( properties , time , - 1 , - 1 , DEFAULT_MAX_BLOB_SIZE ) ; config = initState . getSecond ( ) ; blobStore = initState . getFirst ( ) ; mockBlobStoreStats = blobStore . getBlobStoreStats ( ) ; messageRetentionTimeInMs = config . storeDeletedMessageRetentionDays * Time . HoursPerDay * Time . SecsPerHour * Time . MsPerSec ; compactionPolicy = new DefaultCompactionPolicy ( config , time ) ; }
private boolean containtsOnlyValidXMLChars ( String stringToValidate ) { String pattern = " [ ^ " + "\u0009\r\n" + "\u0020 - \uD7FF" + "\uE000 - \uFFFD" + "\ud800\udc00 - \udbff\udfff" + " ] " ; String resultString = stringToValidate . replaceAll ( pattern , "" ) ; return resultString . equals ( stringToValidate ) ; }
CloseableLiquibase ( String changeLogFile , ResourceAccessor resourceAccessor , Database database , ManagedDataSource dataSource ) throws LiquibaseException , SQLException { super ( changeLogFile , resourceAccessor , database ) ; this . dataSource = dataSource ; }
public CtfTmfLightweightContext ( ArrayList < CtfIterator > iters , ListIterator < CtfIterator > pos ) { fTrace = iters . get ( 0 ) . getCtfTmfTrace ( ) ; curLocation = new CtfLocation ( ( Long ) null ) ; }
public void testIsAdHocAutostart_true ( ) { String id = UUID . randomUUID ( ) . toString ( ) ; AdHocSubProcess adHocSubProcess = bpmn2 . createAdHocSubProcess ( ) ; adHocSubProcess . setId ( id ) ; CustomElement . autoStart . of ( adHocSubProcess ) . set ( Boolean . TRUE ) ; tested = new AdHocSubProcessPropertyReader ( adHocSubProcess , definitionResolverReal . getDiagram ( ) , definitionResolverReal ) ; assertTrue ( tested . isAdHocAutostart ( ) ) ; }
private BroadcastTrimmer broadcastTrimmer ( ) { return new ScheduleResolverBroadcastTrimmer ( scheduleResolver , contentResolver , contentWriter ) ; }
public void disconnect ( ) throws IOException { for ( LocalPortForwarder forwarder : forwarders ) { try { forwarder . close ( ) ; } catch ( IOException e ) { log . warn ( "Error closing forwarder" , e ) ; } } forwarders . clear ( ) ; trans . disconnect ( ) ; super . disconnect ( ) ; }
public void close ( ) { super . close ( ) ; mRefCount . decrementAndGet ( ) ; }
public static String getParameter ( String key ) { try { return getConfig ( ) . getString ( key ) ; } catch ( NoSuchElementException e ) { throw new NoSuchElementException ( "No configuration found in " + CONFIG_FILE + " for key " + key + " ! " ) ; } }
public List < Option > getOptions ( ) { return options ; }
public DataInputNavigableJsonAdapter ( BufferObjectDataInput input , int initialOffset ) { this . input = input ; this . input . position ( initialOffset ) ; this . initialOffset = initialOffset ; }
protected void onMethodInvocationFound ( MethodInvocationTree mit ) { ExpressionTree argument = mit . arguments ( ) . get ( 1 ) ; Type type = argument . symbolType ( ) ; if ( ExpressionsHelper . isNotSerializable ( argument ) ) { String andParameters = JUtils . isParametrized ( type ) ? " and its parameters" : "" ; reportIssue ( argument , "Make \"" + type . name ( ) + "\"" + andParameters + " serializable or don't store it in the session . " ) ; } }
public Predicate createPredicateAndJoin ( String filterString , Root < T > root ) { LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer ( new ANTLRInputStream ( filterString ) ) ; LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser ( new CommonTokenStream ( lexer ) ) ; parser . addErrorListener ( new OsiamAntlrErrorListener ( ) ) ; ParseTree tree = parser . parse ( ) ; EvalVisitor < T > visitor = new EvalVisitor < > ( this , root ) ; return visitor . visit ( tree ) ; }
public Privilege [ ] getSupportedPrivileges ( String path ) { return privileges . listOfSupported ( ) ; }
protected AbstractSessionPresenter ( final SessionManager sessionManager , final SessionPresenter . View view , final Optional < ? extends ToolbarFactory < S > > toolbarFactory , final Optional < PaletteWidgetFactory < DefinitionSetPalette , ? > > paletteFactory , final NotificationsObserver notificationsObserver ) { this . sessionManager = sessionManager ; this . toolbarFactory = ( Optional < ToolbarFactory < S > > ) toolbarFactory ; this . paletteFactory = paletteFactory ; this . notificationsObserver = notificationsObserver ; this . view = view ; this . hasToolbar = true ; this . hasPalette = true ; }
private void prepareToNewMarker ( ) { drawerLayout . closeDrawers ( ) ; setLongClickListener ( ) ; setToastMarkerInfo ( ) ; }
private MVCCEntry wrapMvccEntryForPut ( InvocationContext ctx , Object key , CacheEntry cacheEntry , Metadata providedMetadata , boolean skipRead ) { if ( cacheEntry instanceof MVCCEntry ) { MVCCEntry mvccEntry = ( MVCCEntry ) cacheEntry ; updateMetadata ( mvccEntry , providedMetadata ) ; return mvccEntry ; } return wrapInternalCacheEntryForPut ( ctx , key , ( InternalCacheEntry ) cacheEntry , providedMetadata , skipRead ) ; }
public SERVICE_FAILURE_ACTIONS getFailureActions ( ) { Pointer buffer = queryServiceConfig2 ( Winsvc . SERVICE_CONFIG_FAILURE_ACTIONS ) ; SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS ( buffer ) ; return result ; }
void fun ( String strPath , String StrParent , String StrChild , String prefix , String suffix , java . net . URI uri ) throws Exception { // Questionable : check what is done with this file new File ( strPath ) ; // Noncompliant new File ( StrParent , StrChild ) ; // Noncompliant { { Make sure this file handling is safe here . } } File parent = new File ( uri ) ; // Noncompliant new File ( parent , StrChild ) ; // compliant we rely on the fact that parent should be highlighted File . createTempFile ( prefix , suffix ) ; // Noncompliant File . createTempFile ( prefix , suffix , parent ) ; // compliant }
public ValidationResult vmNotHavingPciPassthroughDevices ( ) { for ( VM vm : vms ) { if ( getHostDeviceManager ( ) . checkVmNeedsPciDevices ( vm . getId ( ) ) ) { return new ValidationResult ( EngineMessage . ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES ) ; } } return ValidationResult . VALID ; }
public void onError ( Throwable e ) { try { FileLfsServlet . sendError ( response , HttpStatus . SC_INTERNAL_SERVER_ERROR , e . getMessage ( ) ) ; context . complete ( ) ; in . close ( ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } }
public String pop ( ) { return lines . remove ( lines . lastKey ( ) ) ; }
public void onDestroyView ( ) { mapView . onDestroy ( ) ; mapboxMap = null ; unbinder . unbind ( ) ; unbinder = null ; super . onDestroyView ( ) ; }
private static SampleTissueProcessingDto asTissueProcessingSampleDto ( SampleTissueProcessing from ) { SampleTissueProcessingDto dto = null ; if ( from instanceof SampleCVSlideImpl ) { dto = asCVSlideSampleDto ( ( SampleCVSlide ) from ) ; } else if ( from . getClass ( ) == SampleLCMTubeImpl . class ) { dto = asLCMTubeSampleDto ( ( SampleLCMTube ) from ) ; } else { dto = new SampleTissueProcessingDto ( ) ; } return dto ; }
public void testMakeTimeZone_NoOffsets ( ) throws Exception { int [ ] [ ] times = { } ; int [ ] [ ] offsets = { } ; try { createZoneInfo ( times , offsets ) ; fail ( "Did not detect no transitions" ) ; } catch ( IllegalStateException expected ) { // Expected this to happen } }
DeploymentToNodeMetadata ( @Memoized Supplier < Set < ? extends Location > > locations , GroupNamingConvention . Factory namingConvention , OSImageToImage osImageToImage , RoleSizeToHardware roleSizeToHardware , Map < String , Credentials > credentialStore ) { this . nodeNamingConvention = namingConvention . createWithoutPrefix ( ) ; this . locations = locations ; this . osImageToImage = osImageToImage ; this . roleSizeToHardware = roleSizeToHardware ; this . credentialStore = credentialStore ; }
public AsyncContext startAsync ( ) throws IllegalStateException { if ( _asyncNotSupportedSource != null ) throw new IllegalStateException ( " ! asyncSupported : " + _asyncNotSupportedSource ) ; HttpChannelState state = getHttpChannelState ( ) ; if ( _async == null ) _async = new AsyncContextState ( state ) ; AsyncContextEvent event = new AsyncContextEvent ( _context , _async , state , this , this , getResponse ( ) ) ; state . startAsync ( event ) ; return _async ; }
CompletableFuture < Void > getFailureOp ( CommitData cd ) { return rollbackLocks ( cd ) ; }
private boolean isGuavaPrecondition ( Symbol . MethodSymbol symbol ) { String name = symbol . name ( ) ; return symbol . owner ( ) . type ( ) . is ( "com . google . common . base . Preconditions" ) && ( "checkNotNull" . equals ( name ) || "checkArgument" . equals ( name ) || "checkState" . equals ( name ) ) ; }
public void loadTrace ( ITmfTrace trace ) { super . loadTrace ( trace ) ; initializeDataProvider ( ) ; }
public StringInputRowParser ( @JsonProperty ( "parseSpec" ) ParseSpec parseSpec , @JsonProperty ( "encoding" ) String encoding ) { this . parseSpec = parseSpec ; this . mapParser = new MapInputRowParser ( parseSpec ) ; this . parser = parseSpec . makeParser ( ) ; if ( encoding != null ) { this . charset = Charset . forName ( encoding ) ; } else { this . charset = DEFAULT_CHARSET ; } }
public Object getNegotiatedProperty ( String propName ) { assertComplete ( ) ; switch ( propName ) { case Sasl . QOP : return selectedQop . getName ( ) ; case Sasl . MAX_BUFFER : return Integer . toString ( actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer ) ; case Sasl . RAW_SEND_SIZE : return Integer . toString ( maxBuffer ) ; } return null ; }
public static BooleanExpression asBoolean ( boolean value ) { return asBoolean ( constant ( value ) ) ; }
public void startPolicyEnforcement ( ) throws IOException { if ( m_pbd . getUsageSpecificLog ( ) . isDebugEnabled ( ) ) { m_pbd . getUsageSpecificLog ( ) . debug ( "Starting time based retention policy enforcement with retainMillis = " + m_retainMillis + " for PBD " + m_pbd . getNonce ( ) ) ; } m_reader = m_pbd . openForRead ( CURSOR_NAME ) ; scheduleTaskFor ( m_pbd . getNonce ( ) , this : : deleteOldSegments , 0 ) ; }
public void afterRun ( ) throws Exception { if ( recordStore == null ) { return ; } if ( recordStore . isWanReplicationEnabled ( ) ) { CacheRecord record = recordStore . getRecord ( key ) ; if ( record != null ) { publishWanUpdate ( key , record ) ; } else { publishWanRemove ( key ) ; } } super . afterRun ( ) ; }
protected String getConfigRoot ( ) { return ClientConfigSections . HAZELCAST_CLIENT . name ; }
public int getCapacity ( ) { return capacity ; }
private Set < IArtifactType > getAllArtTypes ( ) { Set < IArtifactType > allArtTypes = new HashSet < > ( ) ; if ( artifactTypes != null || ! artifactTypes . isEmpty ( ) ) { allArtTypes . addAll ( artifactTypes ) ; } else { allArtTypes = getArtifactTypesFromWorkItemTypes ( ) ; } return allArtTypes ; }
public void testContextListenerIsSet ( ) throws Exception { try ( WizardCommandController tester = testHarness . createWizardController ( MyFirstWizard . class ) ) { tester . initialize ( ) ; Assert . assertTrue ( "Wizard is not on a valid state" , tester . isValid ( ) ) ; Assert . assertTrue ( "Listener is not set" , listener . isContextInitialized ( ) ) ; tester . execute ( ) ; } Assert . assertFalse ( "Listener is still set" , listener . isContextInitialized ( ) ) ; }
Later ( F0 < A > producer ) { this . memo = P . hardMemo ( producer ) ; }
private boolean isRunningFromCommandLine ( ) { // first look up all OptionProcessors and see if running from command line option is set Collection < ? extends OptionProcessor > optionProcessors = Lookup . getDefault ( ) . lookupAll ( OptionProcessor . class ) ; Iterator < ? extends OptionProcessor > optionsIterator = optionProcessors . iterator ( ) ; while ( optionsIterator . hasNext ( ) ) { // find CommandLineOptionProcessor OptionProcessor processor = optionsIterator . next ( ) ; if ( ( processor instanceof CommandLineOptionProcessor ) ) { // check if we are running from command line return ( ( CommandLineOptionProcessor ) processor ) . isRunFromCommandLine ( ) ; } } return false ; }
public boolean onReceivedHttpAuthRequest ( CordovaWebView view , ICordovaHttpAuthHandler handler , String host , String realm ) { for ( CordovaPlugin plugin : this . pluginMap . values ( ) ) { if ( plugin != null && plugin . onReceivedHttpAuthRequest ( view , handler , host , realm ) ) { return true ; } } return false ; }
private String createAndGetLockPath ( ) throws InterruptedException , KeeperException { // Create locks if it does not exist if ( zk . exists ( lockPath , false ) == null ) { try { Util . mkdir ( zk , lockPath , ZooDefs . Ids . OPEN_ACL_UNSAFE ) ; } catch ( CloudnameException e ) { log . log ( java . util . logging . Level . INFO , "CloudnameException while trying to get lock path " + absoluteLockPath , e ) ; } } return lockPath + " / " + lockName ; }
public Tuple getTuple ( EntityKey key , TupleContext tupleContext ) { Entity entity = getEntity ( key ) ; if ( entity != null ) { return new Tuple ( new RedisTupleSnapshot ( entity . getProperties ( ) ) ) ; } else { return null ; } }
public void invoke ( ClientEvent event ) { try { method . invoke ( listener , event ) ; } catch ( InvocationTargetException e ) { throw log . exceptionInvokingListener ( e . getClass ( ) . getName ( ) , method , listener , e . getTargetException ( ) ) ; } catch ( Exception e ) { throw log . exceptionInvokingListener ( e . getClass ( ) . getName ( ) , method , listener , e ) ; } }
ConfigFileConfigProvider ( @JsonProperty ( "configFile" ) String configFile ) { loadProperties ( configFile ) ; }
public void addDataSource ( long dataSourceObjectId ) throws IngestStreamClosedException { // Do nothing }
private void deleteEmptyStagingDirectories ( List < DeclaredIntentionToWrite > declaredIntentionsToWrite ) { for ( DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite ) { if ( declaredIntentionToWrite . getMode ( ) != WriteMode . STAGE_AND_MOVE_TO_TARGET_DIRECTORY ) { continue ; } Path path = declaredIntentionToWrite . getRootPath ( ) ; recursiveDeleteFilesAndLog ( declaredIntentionToWrite . getContext ( ) , path , ImmutableList . of ( ) , true , "staging directory cleanup" ) ; } }
public void edit ( ) { if ( getWindow ( ) != null ) { return ; } EditDiskProfileModel model = new EditDiskProfileModel ( this , ( DiskProfile ) getSelectedItem ( ) , getEntity ( ) . getStoragePoolId ( ) ) ; setWindow ( model ) ; initProfileStorageDomains ( model ) ; }
public void setUp ( ) throws Exception { super . setUp ( ) ; gitDir = new File ( project . getProject ( ) . getLocationURI ( ) . getPath ( ) , Constants . DOT_GIT ) ; testRepository = new TestRepository ( gitDir ) ; testRepository . connect ( project . getProject ( ) ) ; }
protected long getParentDid ( ) { long deckID = getCol ( ) . getDecks ( ) . selected ( ) ; return deckID ; }
public static String getFileExtension ( File file ) { return FilenameUtils . getExtension ( file . getAbsolutePath ( ) ) . toLowerCase ( ) ; }
public void shouldPurgeAnAutoGenerationOption ( ) throws Exception { assertNotNull ( identifierSourceService . getAutoGenerationOption ( getId ( ) ) ) ; MockHttpServletRequest req = request ( RequestMethod . DELETE , getURI ( ) + " / " + getUuid ( ) ) ; req . addParameter ( "purge" , "" ) ; handle ( req ) ; assertNull ( identifierSourceService . getAutoGenerationOption ( getId ( ) ) ) ; }

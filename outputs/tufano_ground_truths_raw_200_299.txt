public boolean shouldUseNativeIO ( VM vm , DiskImage diskImage , VmDevice device ) { StorageType storageType = diskImage . getStorageTypes ( ) . get ( 0 ) ; String diskType = getDiskType ( vm , diskImage , device ) ; return ( ! "file" . equals ( diskType ) || ( storageType == StorageType . GLUSTERFS && FeatureSupported . useNativeIOForGluster ( vm . getCompatibilityVersion ( ) ) ) ) && device . getSnapshotId ( ) == null ; // marked as transient disk ( file type ) and uses cache when snapshotId is not null // so native io should not be used }
public < T > T execute ( Request < T > request , IProgressMonitor monitor ) throws IOException , GerritException { return execute ( request , ! isAnonymous ( ) , monitor ) ; }
public HighlightingInlineHyperlink ( final String text , final String token , final String toHighlight ) { super ( text , token ) ; this . toHighlight = toHighlight ; highlight ( text , toHighlight ) ; }
protected String serializeInstallCmd ( Collection < String > packages ) { if ( packages . isEmpty ( ) ) { return "" ; } else { return CommandInfo . CMD_INSTALL + " " + String . join ( " " , packages ) ; } }
private List roundtrip ( List vals , Map conf ) throws IOException { return deserialize ( serialize ( vals , conf ) , conf ) ; }
public GlobalDirectoryResourceDefinition ( ) { super ( new SimpleResourceDefinition . Parameters ( PathElement . pathElement ( EESubsystemModel . GLOBAL_DIRECTORY ) , EeExtension . getResourceDescriptionResolver ( EESubsystemModel . GLOBAL_DIRECTORY ) ) . setAddHandler ( GlobalDirectoryResourceDefinition . ADD ) . setRemoveHandler ( GlobalDirectoryResourceDefinition . REMOVE ) . setCapabilities ( EE_GLOBAL_DIRECTORY_CAPABILITY ) ) ; }
public LockRangeDialog ( Shell parentShell , TmfXYChartViewer chartViewer ) { super ( parentShell ) ; fChartViewer = chartViewer ; }
public String toStringShort ( ) { return MoreObjects . toStringHelper ( this ) . add ( "ClientType" , getStringFromOptional ( mClientType ) ) . add ( "ClientHostname" , mLocalHostName ) . add ( "ServerAddress" , mServerAddress ) . add ( "ChannelId" , mChannelId ) . omitNullValues ( ) . toString ( ) ; }
public CompilationUnit ( ) { this ( null , null , new NodeList < > ( ) , new NodeList < > ( ) , null ) ; }
public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; description = command . getParam ( PARAM_DESC ) ; }
protected void executeQueryCommand ( ) { Provider < ? > provider = getDbFacade ( ) . getProviderDao ( ) . get ( getParameters ( ) . getId ( ) ) ; NetworkProviderProxy client = getProviderProxyFactory ( ) . create ( provider ) ; getQueryReturnValue ( ) . setReturnValue ( client . getAll ( ) ) ; }
public void testCrashlyticsUninitializedOnAnonymousReportDisabled ( ) { editor . putBoolean ( SettingsActivity . SETTINGS_CRASH_REPORTS , false ) ; editor . commit ( ) ; assertFalse ( CrashReporter . initialize ( context ) ) ; }
protected boolean uniqueInterfaceName ( List < VmNetworkInterface > interfaces ) { return VmHandler . IsNotDuplicateInterfaceName ( interfaces , getInterfaceName ( ) , getReturnValue ( ) . getCanDoActionMessages ( ) ) ; }
private CompletableFuture < CorfuInterClusterReplicationServerNode > startDiscoveryService ( ServerContext serverContext ) { log . info ( "Start Discovery Service . " ) ; CompletableFuture < CorfuInterClusterReplicationServerNode > discoveryServiceCallback = new CompletableFuture < > ( ) ; this . clusterManagerAdapter = buildClusterManagerAdapter ( serverContext . getPluginConfigFilePath ( ) ) ; // Start LogReplicationDiscovery Service , responsible for // acquiring lock , retrieving Site Manager Info and processing this info // so this node is initialized as Source ( sender ) or Sink ( receiver ) replicationDiscoveryService = new CorfuReplicationDiscoveryService ( serverContext , clusterManagerAdapter , discoveryServiceCallback ) ; replicationDiscoveryService . start ( ) ; return discoveryServiceCallback ; }
public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock ( ) throws Exception { long prevChunk = mallocChunks ( 4 ) ; long middleChunk = mallocChunks ( 4 ) ; long nextChunk = mallocChunks ( 2 ) ; free ( middleChunk ) ; // This should be taken from the end of "middleChunk" , since that's closer to the smaller neighbor long smallChunk1 = mallocChunks ( 1 ) ; // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks ( 1 ) ; assertTrue ( "The small chunks should have been allocated from space after 'prevChunk'" , prevChunk < smallChunk2 ) ; assertTrue ( "The small chunks should have been allocated from the end of the free block" , smallChunk2 < smallChunk1 ) ; assertTrue ( "The small chunks should have been allocated from space before 'nextChunk'" , smallChunk1 < nextChunk ) ; }
public void shouldSetTempImagesPathAsCompleteDirectory ( ) { URI path = URI . create ( " / pages / newImagesTemp / " ) ; ConfigCore . setImagesPath ( URI . create ( " / pages / newImagesTemp / " ) ) ; assertEquals ( "Temp images path was set incorrectly ! " , path , URI . create ( " / pages / newImagesTemp / " ) ) ; }
public MetadataHashAggPOP ( @JsonProperty ( "child" ) PhysicalOperator child , @JsonProperty ( "context" ) MetadataAggregateContext context , @JsonProperty ( "phase" ) OperatorPhase phase ) { super ( child , phase , context . groupByExpressions ( ) , Collections . emptyList ( ) , 1 . 0F ) ; Preconditions . checkArgument ( context . createNewAggregations ( ) , "Hash aggregate for metadata collecting should be used only for creating new aggregations . " ) ; this . context = context ; this . phase = phase ; }
private void saveProcess ( Process process ) { try { serviceManager . getProcessService ( ) . save ( process ) ; } catch ( DataException e ) { logger . error ( KITODO_SCRIPT_FIELD + "Error while saving process : " + process . getTitle ( ) , e ) ; Helper . setFehlerMeldung ( KITODO_SCRIPT_FIELD , "Error while saving process : " + process . getTitle ( ) , e ) ; } }
private static String toHexString ( QuantileDigest qdigest ) { return new SqlVarbinary ( qdigest . serialize ( ) . getBytes ( ) ) . toString ( ) . replaceAll ( "\\s + " , " " ) ; }
private String getHeader ( ) { return selectedPageHeader . getText ( ) ; }
public void onImportUserFromLDAP ( LDAPObject ldapUser , UserModel user , RealmModel realm , boolean isCreate ) { String userModelAttrName = getUserModelAttribute ( ) ; String attributeValue = getAttributeValue ( ) ; Property < Object > userModelProperty = userModelProperties . get ( userModelAttrName . toLowerCase ( ) ) ; if ( userModelProperty != null ) { setPropertyOnUserModel ( userModelProperty , user , attributeValue ) ; } else { user . setAttribute ( userModelAttrName , Arrays . asList ( attributeValue ) ) ; } }
public boolean delete ( ProjectName projectName ) { return callWithContext ( ( ) - > { final boolean result = doDelete ( projectName ) ; LOG . info ( "Project deleted : " + projectName ) ; return result ; } ) ; }
public static void startServerInstance ( File dataDir , ServerCnxnFactory factory , String hostPort ) throws IOException , InterruptedException { final int port = getPort ( hostPort ) ; LOG . info ( "STARTING server instance 127 . 0 . 0 . 1 : { } " , port ) ; ZooKeeperServer zks = new ZooKeeperServer ( dataDir , dataDir , 3000 ) ; factory . startup ( zks ) ; Assert . assertTrue ( "waiting for server up" , ClientBase . waitForServerUp ( "127 . 0 . 0 . 1 : " + port , CONNECTION_TIMEOUT , factory . isSecure ( ) ) ) ; }
public void shouldShowAllMusicsAsHTTP ( ) { MockHttpResult mockHttpResult = new MockHttpResult ( ) ; controller = new MusicController ( dao , userInfo , mockHttpResult , validator , musics ) ; when ( dao . listAll ( ) ) . thenReturn ( Arrays . asList ( music ) ) ; controller . showAllMusicsAsHTTP ( ) ; assertThat ( mockHttpResult . getBody ( ) , is ( " < p class = \"content\" > " + Arrays . asList ( music ) . toString ( ) + " </ p > " ) ) ; }
public AttributeValueSearch ( IAttributeType attributeType , String attributeValue ) { Conditions . checkNotNull ( attributeType , "attributeType" ) ; Conditions . checkNotNullOrEmpty ( attributeValue , "attributeValue" ) ; this . attributeType = attributeType ; this . attributeValue = attributeValue ; }
public ListenerContainerIdleEvent ( Object source , long idleTime , @Nullable String id , String . . . queueNames ) { super ( source ) ; this . idleTime = idleTime ; this . listenerId = id ; this . queueNames = Arrays . asList ( queueNames ) ; }
public static XARecoveryModule getRegisteredXARecoveryModule ( ) { if ( registeredXARecoveryModule == null ) { RecoveryManager recMan = RecoveryManager . manager ( ) ; Vector recoveryModules = recMan . getModules ( ) ; if ( recoveryModules != null ) { Enumeration modules = recoveryModules . elements ( ) ; while ( modules . hasMoreElements ( ) ) { RecoveryModule m = ( RecoveryModule ) modules . nextElement ( ) ; if ( m instanceof XARecoveryModule ) { registeredXARecoveryModule = ( XARecoveryModule ) m ; break ; } } } } return registeredXARecoveryModule ; }
public String getUrl ( ) { return url ; }
public void testBoundarySignalProcessInstance ( ) throws Exception { Long processInstanceId = processClient . startProcess ( CONTAINER_ID , PROCESS_ID_BOUNDARY_SIGNAL_PROCESS ) ; assertNotNull ( processInstanceId ) ; assertTrue ( processInstanceId . longValue ( ) > 0 ) ; try { checkAvailableBoundarySignals ( CONTAINER_ID , processInstanceId ) ; } finally { processClient . abortProcessInstance ( CONTAINER_ID , processInstanceId ) ; } }
private void validateAppConfig ( String fileName ) throws Exception { String appsDir = getAppsDirectory ( ) ; if ( appsDir . equalsIgnoreCase ( "apps" ) && ! isAppConfiguredInSourceServerXml ( fileName ) ) { // add application configuration applicationXml . createWebApplicationElement ( fileName ) ; } else if ( appsDir . equalsIgnoreCase ( "dropins" ) && isAppConfiguredInSourceServerXml ( fileName ) ) throw new MojoExecutionException ( messages . getString ( "error . install . app . dropins . directory" ) ) ; }
private static RequestContextDataHolder getRequestContext ( Context ctx ) { return ctx . getOrDefault ( REQUEST_CONTEXT_DATA_HOLDER , null ) ; }
public long getNumberOfImagesInStorageDomain ( Guid storageDomainId ) { return getCallsHandler ( ) . executeRead ( "GetNumberOfImagesInStorageDomain" , getLongMapper ( ) , getCustomMapSqlParameterSource ( ) . addValue ( "storage_domain_id" , storageDomainId ) ) ; }
public TestObjectAsync ( ) { try { Thread . sleep ( 1 ) ; Thread . sleep ( 1 ) ; counter = 1 ; } catch ( InterruptedException ie ) { throw new RuntimeException ( ie ) ; } }
private static boolean isOptionalProperty ( Class beanClass , PropertyDescriptor beanProp ) { if ( beanProp . getReadMethod ( ) . getAnnotationsByType ( Optional . class ) . length > 0 ) { return true ; } Field field = getField ( beanClass , beanProp . getName ( ) ) ; return field != null && field . getAnnotationsByType ( Optional . class ) . length > 0 ; }
int getImageselector ( ) { return imageSelectorIndex ; }
public InputStream getInputStream ( FileHeader entry ) throws IOException { if ( entry == null ) { return null ; } InputStream inputStream = getEntryData ( entry ) . getInputStream ( ) ; if ( entry . getMethod ( ) == ZipEntry . DEFLATED ) { inputStream = new ZipInflaterInputStream ( inputStream , ( int ) entry . getSize ( ) ) ; } return inputStream ; }
private org . eclipse . swt . graphics . Image createImage ( ) { org . eclipse . swt . graphics . Image newImage ; RenderedImage image = renderManager . getImage ( ) ; if ( image != null ) newImage = AWTSWTImageUtils . createSWTImage ( image , false ) ; else { newImage = new Image ( getDisplay ( ) , getWidth ( ) , getHeight ( ) ) ; } return newImage ; }
public VirtualMachine getCurrentMachineBuild ( ITmfEvent event ) { VirtualMachine machine = innerGetCurrentMachine ( event ) ; if ( machine == null ) { synchronized ( fStateSystem ) { String hostId = event . getTrace ( ) . getHostId ( ) ; machine = createMachine ( fStateSystem , event . getTimestamp ( ) . toNanos ( ) , hostId , String . valueOf ( event . getTrace ( ) . getName ( ) ) ) ; fKnownMachines . put ( hostId , machine ) ; } } return machine ; }
public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }
private void updateGroup ( final TupleBatch tb , final int row , final Object [ ] curAggStates ) throws DbException { for ( int agg = 0 ; agg < aggregators . length ; ++ agg ) { if ( ! ( aggregators [ agg ] instanceof StatefulUserDefinedAggregator ) ) { aggregators [ agg ] . addRow ( tb , row , curAggStates [ agg ] ) ; } } }
protected void update ( float delta ) { int lengthInterpretation = 0 ; try { if ( length != null ) { lengthInterpretation = length . interpretInteger ( sprite ) ; } } catch ( InterpretationException interpretationException ) { lengthInterpretation = 0 ; Log . d ( getClass ( ) . getSimpleName ( ) , "Formula interpretation for this specific Brick failed . " , interpretationException ) ; } this . sprite . runningStitch . activateStitching ( sprite , new SimpleRunningStitch ( sprite , lengthInterpretation ) ) ; }
protected void processSpanImpl ( Span span , Map < String , String [ ] > servletRequestParameters ) { long sum = 0 ; for ( String weaselParameterToSum : weaselParametersToSum ) { final Long timing = parsedLongOrNull ( getParameterValueOrNull ( weaselParameterToSum , servletRequestParameters ) ) ; if ( timing == null ) { return ; } else { sum += timing ; } } span . setTag ( TIMING_RESOURCE , sum ) ; }
private void close ( Path path ) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path . getParent ( ) ; try ( Stream < Path > s = Files . list ( directoryWhereGeneratedArtifactsWasPlaced ) ) { s . filter ( p - > ! Files . isDirectory ( p ) ) . forEach ( ThrowingConsumer . unchecked ( Files : : delete ) ) ; } }
public void hashcodeVerifyEqualsContract ( ) { EqualsVerifier . forClass ( MessageReference . class ) . verify ( ) ; }
public HttpRequest setUri ( String uri ) { this . uri = ObjectUtil . checkNotNull ( uri , "uri" ) ; return this ; }
ServiceKeyAuthentication ( @Provider Supplier < Credentials > creds ) { this . creds = creds ; }
protected int countChildrenOf ( IResource checkResource ) throws CoreException { if ( checkResource . getType ( ) == IResource . FILE ) { return 1 ; } int count = 0 ; if ( checkResource . isAccessible ( ) ) { for ( IResource child : ( ( IContainer ) checkResource ) . members ( ) ) { count += countChildrenOf ( child ) ; } } return count ; }
public String getAppFolderToMonitor ( ) { return folder ; }
private static void count ( Object inputBase , long inputAddress , int inputSize , int [ ] counts ) { long input = inputAddress ; Arrays . fill ( counts , 0 ) ; for ( int i = 0 ; i < inputSize ; i ++ ) { int symbol = UNSAFE . getByte ( inputBase , input ) & 0xFF ; input ++ ; counts [ symbol ] ++ ; } }
public void submit ( List < LuceneWork > workList , IndexingMonitor monitor ) { Changeset changeset = new Changeset ( workList , Thread . currentThread ( ) , monitor ) ; transferQueue . add ( changeset ) ; wakeUpConsumer ( ) ; boolean interrupted = false ; while ( ! changeset . isProcessed ( ) && ! interrupted ) { LockSupport . park ( ) ; if ( Thread . interrupted ( ) ) { interrupted = true ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } }
public void setHttpService ( HttpService httpService ) { logger . debug ( "setHttpService called" ) ; this . httpService = httpService ; }
public boolean isInternal ( ) { return getParentNode ( ) . filter ( parent - > parent instanceof Name ) . isPresent ( ) ; }
private void logStart ( ) { log ( 3 , "Running test " + m_testName + " on " + m_classMap . size ( ) + " " + " classes , " + " included groups : [ " + Strings . valueOf ( m_xmlMethodSelector . getIncludedGroups ( ) ) + " ] excluded groups : [ " + Strings . valueOf ( m_xmlMethodSelector . getExcludedGroups ( ) ) + " ] " ) ; if ( getVerbose ( ) >= 3 ) { for ( ITestClass tc : m_classMap . values ( ) ) { ( ( TestClass ) tc ) . dump ( ) ; } } }
public NutchJob ( Configuration conf ) { super ( conf , NutchJob . class ) ; }
private void loadMachineUUID ( ) { EnvironmentInfo environment = environmentTracker . getService ( ) ; if ( environment != null ) { if ( environment . getProperty ( PROP_UUID ) != null ) return ; } String uuid = loadExistingUUID ( ) ; if ( uuid == null ) { uuid = UUID . randomUUID ( ) . toString ( ) ; saveUUID ( uuid ) ; } if ( environment != null ) { environment . setProperty ( PROP_UUID , uuid ) ; } else { System . setProperty ( PROP_UUID , uuid ) ; } }
public boolean retry ( ITestResult result ) { if ( currentTry < maxreruntimes ) { ++ currentTry ; return true ; } return false ; }
public Statistics < T > visitIntConstant ( ValueExpressions . IntExpression expr , Void value ) throws RuntimeException { return getStatistics ( expr . getInt ( ) ) ; }
public ServiceDate getEnd ( ) { return end ; }
public boolean isLoggedIn ( ) { return token != null && user != null ; }
public void setBuildStatus ( String buildStatus ) { try { this . buildStatus = StashBuildState . valueOf ( buildStatus ) ; } catch ( Exception e ) { // ignore unknown or null values } }
public void preInit ( FMLPreInitializationEvent evt ) { RegistryHelper . useOtherModConfigFor ( MODID , BCCore . MODID ) ; BCSiliconConfig . preInit ( ) ; BCSiliconItems . preInit ( ) ; BCSiliconBlocks . preInit ( ) ; NetworkRegistry . INSTANCE . registerGuiHandler ( INSTANCE , BCSiliconProxy . getProxy ( ) ) ; BCSiliconProxy . getProxy ( ) . fmlPreInit ( ) ; }
public Hash ( HashType type ) { this . type = type ; digest = type . get ( ) ; }
private boolean validateExternalVnicProfileMapping ( ) { final ValidationResult validationResult = externalVnicProfileMappingValidator . validateExternalVnicProfileMapping ( getParameters ( ) . getExternalVnicProfileMappings ( ) , getParameters ( ) . getClusterId ( ) ) ; return validate ( validationResult ) ; }
public void serDeTest ( ) { doSerDeTest ( null ) ; doSerDeTest ( Collections . emptyList ( ) ) ; doSerDeTest ( Arrays . asList ( "a" , "b" , " / signedId / abcdef" ) ) ; }
protected void buildVmVideoCards ( ) { createInfo . add ( VdsProperties . display , vm . getdisplay_type ( ) . toString ( ) ) ; // vnc , qxl createInfo . add ( VdsProperties . num_of_monitors , String . valueOf ( vm . getnum_of_monitors ( ) ) ) ; }
private String encode ( String segment ) { return URL . encodeQueryString ( type . replacePathSeparator ( segment ) ) ; }
public List < String > getStrongDependencies ( ) { return Arrays . asList ( A_U_D_preferredMail , A_U_D_ISMail , A_U_D_publicAliasMails , A_U_D_privateAliasMails , A_U_D_o365EmailAddressesMU ) ; }
boolean isCacheable ( ) { return false ; }
static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , String keyAlgorithm , File keyFile , String keyPassword , KeyManagerFactory kmf , String keyStore ) throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , CertificateException , KeyException , UnrecoverableKeyException { return buildKeyManagerFactory ( toX509Certificates ( certChainFile ) , keyAlgorithm , toPrivateKey ( keyFile , keyPassword ) , keyPassword , kmf , keyStore ) ; }
public void testWrongPortConnection ( ) throws Exception { BlockingChannel channel = new SSLBlockingChannel ( hostName , sslPort + 1 , new MetricRegistry ( ) , 10000 , 10000 , 10000 , 2000 , sslSocketFactory , clientSSLConfig ) ; try { // send request channel . connect ( ) ; fail ( "should have thrown ! " ) ; } catch ( IOException e ) { } }
public void notifyParameterChanged ( String name ) { synchronized ( fParameters ) { if ( ! fParameterNames . contains ( name ) ) { throw new RuntimeException ( String . format ( Messages . TmfAbstractAnalysisModule_InvalidParameter , name , getName ( ) ) ) ; } Object oldValue = fParameters . get ( name ) ; Object value = getParameter ( name ) ; if ( ( value != null ) && ! ( value . equals ( oldValue ) ) ) { parameterChanged ( name ) ; } } }
public void testUnrecognizedSpec ( ) { when ( authentication . getAttributes ( ) . get ( any ( String . class ) ) ) . thenReturn ( "strong_two_factor" ) ; spec . setAuthenticationMethod ( "weak_two_factor" ) ; spec . isSatisfiedBy ( this . assertion ) ; }
private void updateBundleConfig ( Connection connection , Bundle bundle ) throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config = ? WHERE bundle_id = ? AND view_id = ? " ; try ( final PreparedStatement statement = connection . prepareStatement ( sql ) ) { statement . setString ( 1 , bundle . config ) ; statement . setLong ( 2 , bundle . bundle ) ; statement . setLong ( 3 , bundle . view ) ; statement . execute ( ) ; } }
protected int getOverProvisioningFactor ( ) { return Integer . parseInt ( Framework . getProperty ( WORKMANAGER_OVERPROVISIONING_PROP , DEFAULT_WORKMANAGER_OVERPROVISIONING ) ) ; }
protected void onDestroy ( ) { webView . setDownloadListener ( null ) ; super . onDestroy ( ) ; }
public void closeTest ( ) { // request is keep - alive by default . HttpRequest request = createRequestWithHeaders ( HttpMethod . GET , TestingUri . Close . toString ( ) ) ; EmbeddedChannel channel = createEmbeddedChannel ( ) ; channel . writeInbound ( request ) ; // drain the channel of content . while ( channel . readOutbound ( ) != null ) { } assertFalse ( "Channel should be closed" , channel . isOpen ( ) ) ; }
public String getRuleLogsForVms ( ) { final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "get_rule_logs_for_vms" ) ; final OutputInterpreter . OneLineParser parser = new OutputInterpreter . OneLineParser ( ) ; final String result = cmd . execute ( parser ) ; if ( result == null ) { return parser . getLine ( ) ; } return null ; }
private void addReporter ( Class < ? extends IReporter > r ) { if ( ! m_reporters . containsKey ( r ) ) { m_reporters . put ( r , ClassHelper . newInstance ( r ) ) ; } }
public void addFunctions ( List < ? extends SqlFunction > functions ) { addFunctions ( TEMP_DEFAULT_CATALOG , functions ) ; }
public synchronized void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( oldInput != newInput && newInput != null ) { ImportTraceContentProvider input = ( ImportTraceContentProvider ) newInput ; clearCandidates ( ) ; fTraceTypes . putAll ( input . fTraceTypes ) ; fTraceFiles . putAll ( fTraceFiles ) ; } }
protected boolean isPowerManagementLegal ( ) { return IsPowerManagementLegal ( getParameters ( ) . getVdsStaticData ( ) , getVdsGroup ( ) . getcompatibility_version ( ) . toString ( ) ) ; }
public void info ( String message ) { info . add ( message ) ; }
public static File makeNumericDimFile ( File dir , String dimension , ByteOrder order ) { return new File ( dir , StringUtils . format ( "numeric_dim_ % s_ % s . drd" , dimension , order ) ) ; }
private AuditLogableBase createAuditLog ( final VmNic iface ) { AuditLogableBase logable = new AuditLogableBase ( ) ; logable . addCustomValue ( "MACAddr" , iface . getMacAddress ( ) ) ; logable . addCustomValue ( "IfaceName" , iface . getName ( ) ) ; return logable ; }
public boolean equals ( VirtualValue other ) { if ( other == null || other . getClass ( ) != MapValue . class ) { return false ; } MapValue that = ( MapValue ) other ; return map . equals ( that . map ) ; }
private void processSingleClusterChanges ( ManageNetworkClustersParameters param ) { final List < ActionParametersBase > setupNetworksParams = new ArrayList < > ( createNetworkClustersToSetupNetworksParametersTransformer ( ) . transform ( param . getAttachments ( ) , param . getDetachments ( ) , param . getUpdates ( ) ) ) ; HostSetupNetworksParametersBuilder . updateParametersSequencing ( setupNetworksParams ) ; setupNetworksParams . forEach ( this : : withRootCommandInfo ) ; runInternalMultipleActions ( ActionType . PersistentHostSetupNetworks , setupNetworksParams ) ; }
private static void setFixedLengthStreamingMode ( HttpURLConnection connection , long length ) { try { // Not caching method as invocation is literally sending > 2GB , which means reflection isn't a limiter ! HttpURLConnection . class . getMethod ( "setFixedLengthStreamingMode" , long . class ) . invoke ( connection , length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Cannot transfer 2 GB or larger chunks due to JDK 1 . 6 limitations . " + " Use chunked encoding or multi - part upload , if possible , or use a different http driver . " + " For more information : http :/ / bugs . sun . com / bugdatabase / view_bug . do ? bug_id = 6755625" ) ; } }
protected String getErrorMessage ( ClientResponse clientResponse ) { String response = clientResponse . getEntity ( String . class ) ; try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser ( ) . readValue ( response , ApiError . class ) ; return error . getMessage ( ) ; } catch ( IOException e ) { // If not , inform the user of the underlying response ( e . g . if server threw NPE or whatever ) int statusCode = clientResponse . getStatus ( ) ; ClientResponse . Status status = clientResponse . getClientResponseStatus ( ) ; String responseText = clientResponse . getEntity ( String . class ) ; return "Server returned " + status + " ( " + statusCode + " ) ; " + responseText ; } }
public int hashCode ( ) { int bits = 1 ; bits = 31 * bits + this . type . ordinal ( ) ; bits = 31 * bits + getToX ( ) ; bits = 31 * bits + getToY ( ) ; bits = 31 * bits + getToZ ( ) ; bits = 31 * bits + getFromX ( ) ; bits = 31 * bits + getFromY ( ) ; bits = 31 * bits + getFromZ ( ) ; return bits ^ ( bits > > 31 ) ; }
public static AccountCollection all ( Map < String , Object > params ) throws AuthenticationException , InvalidRequestException , APIConnectionException , CardException , APIException { return all ( params , ( RequestOptions ) null ) ; }
public void onSaveClick ( ) { editView . setSaveState ( true ) ; if ( client == null ) { client = new WikidataDescriptionEditDataClient ( ) ; } client . request ( pageTitle , editView . getDescription ( ) , new WikidataDescriptionEditDataClient . Callback ( ) { @Override public void success ( ) { editView . setSaveState ( false ) ; L . i ( "WD description edit successful" ) ; // TODO : go to success fragment } @Override public void failure ( @NonNull Throwable caught ) { editView . setSaveState ( false ) ; L . e ( "WD description edit failed : " , caught ) ; // TODO : go to failure fragment } } ) ; }
protected ResourceSet loadResource ( IEditorInput editorInput ) { final URI resourceURI = EditUIUtil . getURI ( editorInput , null ) ; return ResourceSetHelpers . loadResourceSetWithProxies ( resourceURI , getCommandStack ( ) ) ; }
FileReftableStack . CompactionStats getCompactionStats ( ) { return reftableStack . getStats ( ) ; }
public OnlineBackup incremental ( String targetDirectory ) { outcome = new BackupService ( ) . doIncrementalBackup ( hostNameOrIp , port , new File ( targetDirectory ) , getConsistencyCheck ( false ) , timeoutMillis , defaultConfig ( ) ) ; return this ; }
private boolean isValidConfiguration ( ) { return ! ( isDiscarding ( ) || isCalleeData ( ) ) || isAsync ( ) ; }
public boolean setTrace ( @NonNull ITmfTrace trace ) throws TmfAnalysisException { boolean ret = super . setTrace ( trace ) ; if ( ! ret ) { return ret ; } ret = fCriticalPathModule . setTrace ( trace ) ; if ( ret ) { fCriticalPathModule . setParameter ( CriticalPathModule . PARAM_GRAPH , getId ( ) ) ; } return ret ; }
public void fillContextMenu ( final IMenuManager menu ) { super . fillContextMenu ( menu ) ; final ISelection selection = getContext ( ) . getSelection ( ) ; if ( selection . isEmpty ( ) ) { return ; } // Wait the end of the loading of the representations file try { Job . getJobManager ( ) . join ( AbstractRepresentationsFileJob . FAMILY , new NullProgressMonitor ( ) ) ; } catch ( InterruptedException e ) { // Do nothing } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown . // Fill the context menu contextMenuFiller . fillContextMenu ( menu , selection ) ; }
public void dispose ( ) { // run super . super . dispose ( ) ; // remove ourselves as a selection and registry listener getSite ( ) . getPage ( ) . removePostSelectionListener ( this ) ; RegistryFactory . getRegistry ( ) . removeListener ( this ) ; ISaveablesLifecycleListener saveables = getSite ( ) . getService ( ISaveablesLifecycleListener . class ) ; if ( saveables instanceof SaveablesList ) { ( ( SaveablesList ) saveables ) . removeModelLifecycleListener ( saveablesTracker ) ; } currentPart = null ; currentSelection = null ; pinPropertySheetAction = null ; }
public void setBaseballCard ( BaseballCard card ) { Locale locale = Locale . getDefault ( ) ; brand . setText ( card . brand ) ; year . setText ( String . format ( locale , " % d" , card . year ) ) ; number . setText ( card . number ) ; player . setText ( card . playerName ) ; }
private static String capitalize ( String word ) { return Character . toUpperCase ( word . charAt ( 0 ) ) + word . substring ( 1 ) ; }

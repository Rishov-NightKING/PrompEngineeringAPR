public boolean shouldUseNativeIO ( VM vm , DiskImage diskImage , VmDevice device ) { StorageType storageType = diskImage . getStorageTypes ( ) . get ( 0 ) ; String diskType = getDiskType ( vm , diskImage , device ) ; boolean isNativeIO = ! "file" . equals ( diskType ) || ( storageType == StorageType . GLUSTERFS && FeatureSupported . useNativeIOForGluster ( vm . getCompatibilityVersion ( ) ) ) || ( device . getSnapshotId ( ) != null && ! "file" . equals ( diskType ) ) ; return isNativeIO ; }
public < T > T execute ( Request < T > request , IProgressMonitor monitor ) throws IOException , GerritException { return execute ( request , ! isAnonymous ( ) , monitor ) ; }
public HighlightingInlineHyperlink ( final String text , final String token , final String toHighlight ) { super ( text , token ) ; setText ( text ) ; highlight ( toHighlight ) ; } @Override public void setText ( String text ) { super . setText ( text ) ; highlight ( toHighlight ) ; } private void highlight ( String toHighlight ) { // code to highlight the specified text }
protected String serializeInstallCmd ( Collection < String > packages ) { if ( packages . isEmpty ( ) ) { return "" ; } else { return CommandInfo . CMD_INSTALL + " " + String . join ( " " , packages ) ; } }
private List roundtrip ( List vals , Map conf ) throws IOException { List ret = null ; try { ret = deserialize ( serialize ( vals , conf ) , conf ) ; } catch ( IOException e ) { LOG . error ( "Exception when serialize / deserialize " , e ) ; throw e ; } return ret ; }
public GlobalDirectoryResourceDefinition ( ) { super ( new SimpleResourceDefinition . Parameters ( PathElement . pathElement ( EESubsystemModel . GLOBAL_DIRECTORY ) , EeExtension . getResourceDescriptionResolver ( EESubsystemModel . GLOBAL_DIRECTORY ) ) . setAddRestartLevel ( OperationEntry . Flag . NONE ) . setRemoveRestartLevel ( OperationEntry . Flag . NONE ) . setAddHandler ( GlobalDirectoryResourceDefinition . ADD ) . setRemoveHandler ( GlobalDirectoryResourceDefinition . REMOVE ) . setCapabilities ( EE_GLOBAL_DIRECTORY_CAPABILITY ) ) ; }
public LockRangeDialog ( Shell parentShell , TmfXYChartViewer chartViewer ) { super ( parentShell ) ; fChartViewer = chartViewer ; }
public String toStringShort ( ) { return MoreObjects . toStringHelper ( this ) . add ( "ClientType" , getStringFromOptional ( mClientType ) ) . add ( "ClientHostname" , mLocalHostName ) . add ( "ServerAddress" , mServerAddress ) . add ( "ChannelId" , mChannelId ) . omitNullValues ( ) . toString ( ) ; }  In the refactored code , `this` is used instead of an empty string to pass the object instance to the `toStringHelper` method .
public CompilationUnit ( ) { this ( null , CompilationMode . DEFAULT , null , new NodeList < > ( ) , new NodeList < > ( ) , null ) ; } where CompilationMode is an enum with possible values such as DEFAULT , STRICT , etc .
public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; String description = command . getParam ( PARAM_DESC ) ; }
protected void executeQueryCommand ( ) { Provider provider = getDbFacade ( ) . getProviderDao ( ) . get ( getParameters ( ) . getId ( ) ) ; if ( provider == null ) { // handle error or throw exception } NetworkProviderProxy client = getProviderProxyFactory ( ) . create ( provider ) ; getQueryReturnValue ( ) . setReturnValue ( client . getAll ( ) ) ; }
public void setUp ( ) { Context context = InstrumentationRegistry . getTargetContext ( ) ; SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( context ) . edit ( ) ; editor . clear ( ) ; editor . commit ( ) ; } public void testCrashlyticsUninitializedOnAnonymousReportDisabled ( ) { setUp ( ) ; Context context = InstrumentationRegistry . getTargetContext ( ) ; SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( context ) . edit ( ) ; editor . putBoolean ( SettingsActivity . SETTINGS_CRASH_REPORTS , false ) ; editor . clear ( ) ; editor . commit ( ) ; CrashReporter crashReporter = new CrashReporter ( context ) ; assertFalse ( crashReporter . initialize ( ) ) ; }
protected boolean uniqueInterfaceName ( List < VmNetworkInterface > interfaces ) { return VmHandler . IsNotDuplicateInterfaceName ( interfaces , getInterfaceName ( ) , getReturnValue ( ) . getCanDoActionMessages ( ) ) ; }
private CompletableFuture < CorfuInterClusterReplicationServerNode > startDiscoveryService ( ServerContext serverContext ) throws InterruptedException { log . info ( "Start Discovery Service . " ) ; CompletableFuture < CorfuInterClusterReplicationServerNode > discoveryServiceCallback = new CompletableFuture < > ( ) ; this . clusterManagerAdapter = buildClusterManagerAdapter ( serverContext . getPluginConfigFilePath ( ) ) ; // Start LogReplicationDiscovery Service , responsible for // acquiring lock , retrieving Site Manager Info and processing this info // so this node is initialized as Source ( sender ) or Sink ( receiver ) replicationDiscoveryService = new CorfuReplicationDiscoveryService ( serverContext , clusterManagerAdapter , discoveryServiceCallback ) ; return discoveryServiceCallback ; }
public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock ( ) throws Exception { long prevChunk = mallocChunks ( 4 ) ; long middleChunk = mallocChunks ( 4 ) ; long nextChunk = mallocChunks ( 2 ) ; free ( middleChunk ) ; long smallChunk1 = mallocChunks ( 1 ) ; long smallChunk2 = mallocChunks ( 1 ) ; assertTrue ( prevChunk < smallChunk2 ) ; assertTrue ( smallChunk2 < smallChunk1 ) ; assertTrue ( smallChunk1 < nextChunk ) ; }
public void shouldSetTempImagesPathAsCompleteDirectory ( ) { URI path = URI . create ( " / pages / newImagesTemp / " ) ; ConfigCore . setImagesPath ( path ) ; logger . info ( "Temp images path set to : { } " , ConfigCore . getTempImagesPathAsCompleteDirectory ( ) ) ; assertEquals ( "Temp images path was set incorrectly ! " , path , ConfigCore . getImagesPath ( ) ) ; }
public MetadataHashAggPOP ( @JsonProperty ( "child" ) PhysicalOperator child , @JsonProperty ( "context" ) MetadataAggregateContext context , @JsonProperty ( "phase" ) OperatorPhase phase ) { Preconditions . checkArgument ( context . createNewAggregations ( ) , "Hash aggregate for metadata collecting should be used only for creating new aggregations . " ) ; super ( child , phase , context . groupByExpressions ( ) , Collections . emptyList ( ) , 1 . 0F ) ; this . context = context ; this . phase = phase ; }
private void saveProcess ( Process process ) { try { serviceManager . getProcessService ( ) . save ( process ) ; } catch ( DataException e ) { logger . error ( KITODO_SCRIPT_FIELD + "Error while saving process : " + process . getTitle ( ) , e ) ; Helper . setFehlerMeldung ( KITODO_SCRIPT_FIELD , "Error while saving process : " + process . getTitle ( ) , e ) ; } }
private static String toHexString ( QuantileDigest qdigest ) { return new SqlVarbinary ( qdigest . serialize ( ) . getBytes ( ) ) . toString ( ) . replaceAll ( "\\s + " , " " ) ; }
private String getHeader ( ) { return selectedPageHeader . getText ( ) ; }
public void onImportUserFromLDAP ( LDAPObject ldapUser , UserModel user , RealmModel realm , boolean isCreate ) { String userModelAttrName = getUserModelAttribute ( ) ; String attributeValue = getAttributeValue ( ) ; Property < Object > userModelProperty = userModelProperties . get ( userModelAttrName . toLowerCase ( ) ) ; if ( userModelProperty != null ) { setPropertyOnUserModel ( userModelProperty , user , attributeValue ) ; } else { user . setAttribute ( userModelAttrName , Arrays . asList ( attributeValue ) ) ; } }
< START > public boolean delete ( ProjectName projectName ) { return callWithContext ( ( ) - > { final boolean result = doDelete ( projectName ) ; LOG . info ( "Project deleted : " + projectName ) ; return result ; } ) ; } < END >
The Review without comments doesn't provide enough information to determine what changes need to be made to the code . Please provide more context or information .
public void shouldShowAllMusicsAsHTTP ( ) { MockHttpResult mockHttpResult = new MockHttpResult ( ) ; controller = new MusicController ( dao , userInfo , mockHttpResult , validator , musics ) ; when ( dao . listAll ( ) ) . thenReturn ( Arrays . asList ( music ) ) ; controller . showAllMusicsAsHTTP ( ) ; assertThat ( mockHttpResult . getBody ( ) , is ( " < p class = \"content\" > " + Arrays . asList ( music ) . toString ( ) + " </ p > " ) ) ; }
public AttributeValueSearch ( IAttributeType attributeType , String attributeValue ) { Conditions . checkNotNull ( attributeType , "attributeType" ) ; Conditions . checkNotNullOrEmpty ( attributeValue , "attributeValue" ) ; this . attributeType = attributeType ; this . attributeValue = attributeValue ; }
public ListenerContainerIdleEvent ( Object source , long idleTime , @Nullable String id , String . . . queueNames ) { super ( source ) ; this . idleTime = Duration . ofMillis ( idleTime ) ; this . listenerId = id ; this . queueNames = Arrays . asList ( queueNames ) ; }
public static XARecoveryModule getRegisteredXARecoveryModule ( ) { if ( registeredXARecoveryModule == null ) { RecoveryManager recMan = RecoveryManager . manager ( ) ; Vector recoveryModules = recMan . getModules ( ) ; if ( recoveryModules != null ) { Enumeration modules = recoveryModules . elements ( ) ; while ( modules . hasMoreElements ( ) ) { RecoveryModule m = ( RecoveryModule ) modules . nextElement ( ) ; if ( m instanceof XARecoveryModule ) { registeredXARecoveryModule = ( XARecoveryModule ) m ; break ; } } } } return registeredXARecoveryModule ; }
public String getUrl ( ) { PluginImpl plugin = PluginImpl . getInstance ( ) ; if ( plugin != null ) { Server server = plugin . getServer ( serverName ) ; if ( server != null ) { Config config = server . getConfig ( ) ; if ( config != null ) { return config . getGerritFrontEndUrlFor ( tEvent ) ; } } } return null ; }
public void testBoundarySignalProcessInstance ( ) throws Exception { Long processInstanceId = processClient . startProcess ( CONTAINER_ID , PROCESS_ID_BOUNDARY_SIGNAL_PROCESS ) ; assertNotNull ( processInstanceId ) ; assertTrue ( processInstanceId . longValue ( ) > 0 ) ; try { checkAvailableBoundarySignals ( CONTAINER_ID , processInstanceId ) ; } catch ( Exception e ) { processClient . abortProcessInstance ( CONTAINER_ID , processInstanceId ) ; throw e ; } }
private void validateAppConfig ( String fileName ) throws Exception { String appsDir = getAppsDirectory ( ) ; if ( appsDir . equalsIgnoreCase ( "apps" ) && ! isAppConfiguredInSourceServerXml ( fileName ) ) { // add application configuration applicationXml . createWebApplicationElement ( fileName ) ; } else if ( appsDir . equalsIgnoreCase ( "dropins" ) && isAppConfiguredInSourceServerXml ( fileName ) ) { throw new MojoExecutionException ( messages . getString ( "error . install . app . dropins . directory" ) ) ; } }
< START > private static RequestContextDataHolder getRequestContext ( Context ctx ) { < END > return ctx . getOrDefault ( REQUEST_CONTEXT_DATA_HOLDER , null ) ; }
public long getNumberOfImagesInStorageDomain ( Guid storageDomainId ) { return getCallsHandler ( ) . executeRead ( "GetNumberOfImagesInStorageDomain" , getLongMapper ( ) , getCustomMapSqlParameterSource ( ) . addValue ( "storage_domain_id" , storageDomainId ) ) ; }
public TestObjectAsync ( ) { try { Thread . yield ( ) ; counter = 1 ; } catch ( InterruptedException ie ) { throw new RuntimeException ( ie ) ; } }
private static boolean isOptionalProperty ( Class beanClass , PropertyDescriptor beanProp ) { if ( beanProp . getReadMethod ( ) . getAnnotationsByType ( Optional . class ) . length > 0 ) { return true ; } Field field = getField ( beanClass , beanProp . getName ( ) ) ; return field != null && field . getAnnotationsByType ( Optional . class ) . length > 0 ; }
public int getImageSelector ( ) { return imageSelectorIndex ; }
public InputStream getInputStream ( FileHeader entry ) throws IOException { if ( entry == null ) { return null ; } InputStream inputStream = getEntryData ( entry ) . getInputStream ( ) ; if ( entry . getMethod ( ) == ZipEntry . DEFLATED ) { Inflater inflater = new Inflater ( true ) ; inputStream = new ZipInflaterInputStream ( inputStream , inflater , ( int ) entry . getSize ( ) , true ) ; } return inputStream ; }
private org . eclipse . swt . graphics . Image createImage ( ) { org . eclipse . swt . graphics . Image newImage ; RenderedImage image = renderManager . getImage ( ) ; AffineTransform backBufferTrsf = renderManager . getMapInternal ( ) . getViewportModel ( ) . worldToScreenTransform ( ) ; if ( image != null ) { newImage = AWTSWTImageUtils . createSWTImage ( image , false ) ; } else { newImage = new Image ( getDisplay ( ) , getWidth ( ) , getHeight ( ) ) ; } return newImage ; }
public VirtualMachine getCurrentMachineBuild ( ITmfEvent event ) { VirtualMachine machine = innerGetCurrentMachine ( event ) ; if ( machine == null ) { synchronized ( fStateSystem ) { String hostId = event . getTrace ( ) . getHostId ( ) ; machine = createMachine ( fStateSystem , event . getTimestamp ( ) . toNanos ( ) , hostId , event . getTrace ( ) . getName ( ) ) ; fKnownMachines . put ( hostId , machine ) ; } } return machine ; }
public static Predicate < Expression > isInferenceCandidate ( ) { return expression - > { expression = normalizeInPredicateToEquality ( expression ) ; if ( expression instanceof ComparisonExpression && isDeterministic ( expression ) && ! mayReturnNullOnNonNullInput ( expression ) && ! isDynamicFilter ( expression ) ) { ComparisonExpression comparison = ( ComparisonExpression ) expression ; if ( comparison . getType ( ) == ComparisonExpressionType . EQUAL ) { // We should only consider equalities that have distinct left and right components return ! comparison . getLeft ( ) . equals ( comparison . getRight ( ) ) ; } } return false ; } ; }  Explanation : The code defines a static method `isInferenceCandidate ( ) ` that returns a `Predicate < Expression > ` object . The predicate checks if the given `Expression` object is a candidate for inference . The code first normalizes the given expression to an equality expression using the `normalizeInPredicateToEquality ( ) ` method . Then it checks if the expression is a `ComparisonExpression` , is deterministic , does not return null on non - null input , and is not a dynamic filter using the respective methods . If all the conditions are satisfied , the code checks if the comparison type is `EQUAL` and the left and right components of the comparison are distinct . If so , it returns `true` , indicating that the expression is a candidate for inference . Otherwise , it returns `false` .
private void updateGroup ( final TupleBatch tb , final int row , final Object [ ] curAggStates ) throws DbException { for ( int agg = 0 ; agg < aggregators . length ; ++ agg ) { if ( ! ( aggregators [ agg ] instanceof StatefulUserDefinedAggregator ) ) { aggregators [ agg ] . addRow ( tb , row , curAggStates [ agg ] ) ; } } }
protected void update ( float delta ) { int lengthInterpretation = 0 ; try { lengthInterpretation = length == null ? 0 : length . interpretInteger ( sprite ) ; } catch ( InterpretationException e ) { Log . d ( getClass ( ) . getSimpleName ( ) , "Formula interpretation for this specific Brick failed . " , e ) ; } this . sprite . runningStitch . activateStitching ( sprite , new SimpleRunningStitch ( sprite , lengthInterpretation ) ) ; }
protected void processSpanImpl ( Span span , Map < String , String [ ] > servletRequestParameters ) { long sum = 0 ; for ( String weaselParameterToSum : weaselParametersToSum ) { final Long timing = parsedLongOrNull ( getParameterValueOrNull ( weaselParameterToSum , servletRequestParameters ) ) ; if ( timing == null ) { discardSpan ( span ) ; return ; } sum += timing ; } span . setTag ( TIMING_RESOURCE , sum ) ; }
private void close ( Path path ) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path . getParent ( ) ; try ( Stream < Path > s = Files . list ( directoryWhereGeneratedArtifactsWasPlaced ) ) { s . filter ( p - > ! Files . isDirectory ( p ) ) . forEach ( ThrowingConsumer . unchecked ( Files : : delete ) ) ; } }
public void verifyEqualsContract ( ) { EqualsVerifier . forClass ( MessageReference . class ) . withImmutableFields ( ) . verify ( ) ; }
public HttpRequest setUri ( String uri ) { this . uri = ObjectUtil . checkNotNull ( uri , "uri" ) ; return this ; }
java @Inject ServiceKeyAuthentication ( @Provider Supplier < Credentials > creds ) { this . creds = creds ; }
protected int countChildrenOf ( IResource resource ) throws CoreException { if ( resource . getType ( ) == IResource . FILE ) { return 1 ; } int count = 0 ; if ( resource . isAccessible ( ) ) { for ( IResource child : ( ( IContainer ) resource ) . members ( ) ) { count += countChildrenOf ( child ) ; } } return count ; }
public String getAppFolderToMonitor ( ) { if ( folder == null ) { return null ; } File f = new File ( "Applications" ) ; folder = f . getAbsolutePath ( ) ; return folder ; }
private static void count ( Object inputBase , long inputAddress , int inputSize , int [ ] counts ) { Arrays . fill ( counts , 0 ) ; for ( int i = 0 ; i < inputSize ; i ++ ) { int symbol = UNSAFE . getByte ( inputBase , inputAddress + i ) & 0xFF ; counts [ symbol ] ++ ; } }
public void submit ( List < LuceneWork > workList , IndexingMonitor monitor ) { Changeset changeset = new Changeset ( workList , Thread . currentThread ( ) , monitor ) ; transferQueue . add ( changeset ) ; wakeUpConsumer ( ) ; boolean interrupted = false ; while ( ! changeset . isProcessed ( ) ) { LockSupport . park ( ) ; if ( Thread . interrupted ( ) ) { interrupted = true ; return ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } }
public void setHttpService ( HttpService httpService ) { logger . debug ( "setHttpService called" ) ; this . httpService = httpService ; }
public boolean isInternal ( ) { return getParentNode ( ) . filter ( parent - > parent instanceof Name ) . map ( parent - > ( Name ) parent ) . flatMap ( Name : : getQualifier ) . map ( parentNameQualifier - > parentNameQualifier == this . getQualifier ( ) . orElse ( null ) ) . orElse ( false ) ; }
private void logStart ( ) { log ( 3 , "Running test " + m_testName + " on " + m_classMap . size ( ) + " " + " classes , " + String . valueOf ( " < START > " ) + " included groups : [ " + String . valueOf ( Strings . mapToString ( m_xmlMethodSelector . getIncludedGroups ( ) ) ) + " ] excluded groups : [ " + String . valueOf ( Strings . mapToString ( m_xmlMethodSelector . getExcludedGroups ( ) ) ) + " ] " ) ; if ( getVerbose ( ) >= 3 ) { for ( ITestClass tc : m_classMap . values ( ) ) { ( ( TestClass ) tc ) . dump ( ) ; } } }
java public NutchJob ( Configuration conf ) throws IOException { super ( conf , "NutchJob" ) ; }  Yes , the refactored code means that every Job will be named "NutchJob" .
private void loadMachineUUID ( BundleContext context ) { String uuid = context . getProperty ( PROP_UUID ) ; if ( uuid != null ) { return ; } uuid = loadExistingUUID ( ) ; if ( uuid == null ) { uuid = UUID . randomUUID ( ) . toString ( ) ; saveUUID ( uuid ) ; } EnvironmentInfo environment = environmentTracker . getService ( ) ; if ( environment != null ) { environment . setProperty ( PROP_UUID , uuid ) ; } else { System . setProperty ( PROP_UUID , uuid ) ; } }
private AtomicInteger currentTry = new AtomicInteger ( 0 ) ; private int maxRerunTimes = 3 ; public boolean retry ( ITestResult result ) { if ( currentTry . getAndIncrement ( ) < maxRerunTimes ) { return true ; } return false ; }
public Statistics < T > visitIntConstant ( ValueExpressions . IntExpression expr , Void value ) throws RuntimeException { return getStatistics ( expr . getInt ( ) ) ; }
public static final ServiceDate UNBOUNDED_END = null ; public ServiceDate getEnd ( ) { return end == UNBOUNDED_END ? null : end ; }
public boolean isLoggedIn ( ) { return token != null && hub != null ; }
public void setBuildStatus ( String buildStatus ) { try { this . buildStatus = StashBuildState . valueOf ( buildStatus ) ; } catch ( Exception e ) { // ignore unknown or null values } }
public void preInit ( FMLPreInitializationEvent evt ) { BCSiliconConfig . preInit ( ) ; BCSiliconItems . preInit ( ) ; BCSiliconBlocks . preInit ( ) ; BCSiliconConfig . reloadConfig ( EnumRestartRequirement . GAME ) ; RegistryHelper . useOtherModConfigFor ( MODID , BCCore . MODID ) ; NetworkRegistry . INSTANCE . registerGuiHandler ( INSTANCE , BCSiliconProxy . getProxy ( ) ) ; BCSiliconProxy . getProxy ( ) . fmlPreInit ( ) ; }
public Hash ( HashType type ) { this . type = type ; try { digest = type . get ( ) ; } finally { // Do not recycle digest here // Instead , rely on the finalizer to recycle it } } @Override protected void finalize ( ) throws Throwable { try { type . recycle ( digest ) ; } finally { super . finalize ( ) ; } }
private boolean validateExternalVnicProfileMapping ( ) { final ValidationResult validationResult = externalVnicProfileMappingValidator . validateExternalVnicProfileMapping ( getParameters ( ) . getExternalVnicProfileMappings ( ) , getParameters ( ) . getClusterId ( ) ) ; drMappingHelper . mapVnicProfiles ( vmTemplateFromConfiguration . getInterfaces ( ) , getParameters ( ) . getExternalVnicProfileMappings ( ) ) ; return validate ( validationResult ) ; }
public void serDeTest ( ) { List < String > testList = Arrays . asList ( "a" , "b" , " / signedId / abcdef" ) ; if ( testList != null ) { doSerDeTest ( testList ) ; } else { doSerDeTest ( Collections . emptyList ( ) ) ; } }
protected void buildVmVideoCards ( ) { createInfo . add ( VdsProperties . display , vm . getdisplay_type ( ) . toString ( ) ) ; // vnc , qxl createInfo . add ( VdsProperties . num_of_monitors , String . valueOf ( vm . getnum_of_monitors ( ) ) ) ; }
Here's the   public class MyClass { // other methods and variables public static String encode ( String segment ) { return URL . encodeQueryString ( type . replacePathSeparator ( segment ) ) ; } }  I made the following changes : - Made the `encode` method static , as suggested in the review . - Moved the `encode` method to the end of the class , as suggested in the review .
public List < String > getStrongDependencies ( ) { return Arrays . asList ( A_U_D_preferredMail , A_U_D_ISMail , A_U_D_publicAliasMails , A_U_D_privateAliasMails , A_U_D_o365EmailAddressesMU ) ; }
boolean isCacheable ( ) { return false ; }
Code : static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , String keyAlgorithm , File keyFile , String keyPassword , KeyManagerFactory kmf , String keyStore ) throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , CertificateException , KeyException , UnrecoverableKeyException { return buildKeyManagerFactory ( toX509Certificates ( certChainFile ) , keyAlgorithm , toPrivateKey ( keyFile , keyPassword ) , keyPassword , kmf , keyStore ) ; }
public void testWrongPortConnection ( ) throws Exception { BlockingChannel channel = new SSLBlockingChannel ( hostName , sslPort + 1 , new MetricRegistry ( ) , 10000 , 10000 , 10000 , 2000 , sslSocketFactory , clientSSLConfig ) ; try { // send request channel . connect ( ) ; fail ( "should have thrown ! " ) ; } catch ( IOException e ) { assertTrue ( e instanceof ConnectException ) ; } }
public void notifyParameterChanged ( String name ) { synchronized ( fParameters ) { if ( ! fParameterNames . contains ( name ) ) { throw new RuntimeException ( String . format ( Messages . TmfAbstractAnalysisModule_InvalidParameter , name , getName ( ) ) ) ; } Object oldValue = fParameters . get ( name ) ; Object value = getParameter ( name ) ; if ( ( value != null ) && ! ( value . equals ( oldValue ) ) ) { parameterChanged ( name ) ; } } }
public void testUnrecognizedSpec ( ) { when ( authentication . getAttributes ( ) . get ( any ( String . class ) ) ) . thenReturn ( "strong_two_factor" ) ; spec . setAuthenticationMethod ( "weak_two_factor" ) ; this . spec . isSatisfiedBy ( this . assertion ) ; }
Here's the  java public static void updateBundleConfig ( Connection connection , Bundle bundle ) throws SQLException { String sql = "UPDATE portti_view_bundle_seq SET config = ? WHERE bundle_id = ? AND view_id = ? " ; try ( PreparedStatement statement = connection . prepareStatement ( sql ) ) { statement . setString ( 1 , bundle . getConfig ( ) ) ; statement . setLong ( 2 , bundle . getBundleId ( ) ) ; statement . setLong ( 3 , bundle . getViewId ( ) ) ; statement . executeUpdate ( ) ; } }  Changes made : - Removed the `return null` statement as it was not necessary . - Changed the method signature to return `void` instead of `Bundle` . - Used the getter methods ( `getConfig ( ) ` , `getBundleId ( ) ` , `getViewId ( ) ` ) to access the fields of the `Bundle` object . - Changed `execute ( ) ` to `executeUpdate ( ) ` as we are performing an update operation .
protected int getOverProvisioningFactor ( ) { return Integer . parseInt ( Framework . getProperty ( WORKMANAGER_OVERPROVISIONING_PROP , DEFAULT_WORKMANAGER_OVERPROVISIONING ) ) ; }
protected void onDestroy ( ) { webView . setDownloadListener ( null ) ; super . onDestroy ( ) ; }
public void testClose ( ) { HttpRequest request = createRequestWithHeaders ( HttpMethod . GET , TestingUri . Close . toString ( ) ) ; EmbeddedChannel channel = createEmbeddedChannel ( ) ; channel . writeInbound ( request ) ; while ( channel . readOutbound ( ) != null ) { ; } assertFalse ( "Channel should be closed" , channel . isOpen ( ) ) ; assertTrue ( "Response channel should be closed" , channel . pipeline ( ) . get ( NettyResponseChannel . class ) . isClosed ( ) ) ; }  The `assertTrue` statement checks if the `NettyResponseChannel` is closed .
public String getRuleLogsForVms ( ) { final Script cmd = new Script ( _securityGroupPath , _timeout . toMillis ( ) , s_logger ) ; cmd . add ( "get_rule_logs_for_vms" ) ; final OutputInterpreter . OneLineParser parser = new OutputInterpreter . OneLineParser ( ) ; final String result = cmd . execute ( parser ) ; if ( result == null ) { return parser . getLine ( ) ; } return null ; }
private void addReporter ( Class < ? extends IReporter > r ) { if ( ! m_reporters . containsKey ( r ) ) { m_reporters . put ( r , ClassHelper . newInstance ( r ) ) ; } }
< START > public synchronized void addFunctions ( List < ? extends SqlFunction > functions ) { addFunctions ( TEMP_DEFAULT_CATALOG , functions ) ; } < END >
public synchronized void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { if ( oldInput != newInput && newInput != null ) { ImportTraceContentProvider input = ( ImportTraceContentProvider ) newInput ; clearCandidates ( ) ; fTraceTypes . putAll ( input . fTraceTypes ) ; fTraceFiles . putAll ( fTraceFiles ) ; } }
protected boolean isPowerManagementLegal ( ) { return IsPowerManagementLegal ( getParameters ( ) . getVdsStaticData ( ) , getVdsGroup ( ) . getcompatibility_version ( ) . toString ( ) ) ; }
public void info ( String message ) { logger . info ( message ) ; info . add ( message ) ; }
public static File makeNumericDimFile ( File dir , String dimension , ByteOrder order ) { String fileName = String . format ( "numeric_dim_ % s_ % s . drd" , dimension , order ) ; if ( fileName . contains ( " % " ) ) { throw new IllegalArgumentException ( "Bad format string" ) ; } return new File ( dir , fileName ) ; }
private AuditLogableBase createAuditLog ( final VmNic iface ) { AuditLogableBase logable = new AuditLogableBase ( ) ; logable . addCustomValue ( "MACAddr" , iface . getMacAddress ( ) ) ; logable . addCustomValue ( "IfaceName" , iface . getName ( ) ) ; return logable ; }  Since there is no longer a need for the VM ID , the line of code that sets the VM ID has been removed from the original code .
public boolean equals ( Object other ) { if ( other == null || ! ( other instanceof MapValue ) ) { return false ; } MapValue that = ( MapValue ) other ; return size ( ) == that . size ( ) && Arrays . equals ( keys , that . keys ) && Arrays . equals ( values , that . values ) ; }
private void processSingleClusterChanges ( ManageNetworkClustersParameters param ) { final List < ActionParametersBase > setupNetworksParams = new ArrayList < > ( createNetworkClustersToSetupNetworksParametersTransformer ( ) . transform ( param . getAttachments ( ) , param . getDetachments ( ) , param . getUpdates ( ) ) ) ; HostSetupNetworksParametersBuilder . updateParametersSequencing ( setupNetworksParams ) ; setupNetworksParams . forEach ( this : : withRootCommandInfo ) ; runInternalMultipleActions ( ActionType . PersistentHostSetupNetworks , setupNetworksParams , getContext ( ) . getExecutionContext ( ) ) ; }
< START > private static void setFixedLengthStreamingMode ( HttpURLConnection connection , long length ) { < END > try { HttpURLConnection . class . getMethod ( "setFixedLengthStreamingMode" , long . class ) . invoke ( connection , length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Cannot transfer 2 GB or larger chunks due to JDK 1 . 6 limitations . " + " Use chunked encoding or multi - part upload , if possible , or use a different http driver . " + " For more information : http :/ / bugs . sun . com / bugdatabase / view_bug . do ? bug_id = 6755625" ) ; } }
protected String getErrorMessage ( ClientResponse clientResponse ) { String response = clientResponse . getEntity ( String . class ) ; try { ApiError error = getJsonParser ( ) . readValue ( response , ApiError . class ) ; return error . getMessage ( ) ; } catch ( IOException e ) { int statusCode = clientResponse . getStatus ( ) ; ClientResponse . Status status = clientResponse . getClientResponseStatus ( ) ; String responseText = clientResponse . getEntity ( String . class ) ; return "Server returned " + status + " ( " + statusCode + " ) ; " + responseText ; } }
public int hashCode ( ) { int bits = 1 ; bits = 31 * bits + this . type . ordinal ( ) ; bits = 31 * bits + getToX ( ) ; bits = 31 * bits + getToY ( ) ; bits = 31 * bits + getToZ ( ) ; bits = 31 * bits + getFromX ( ) ; bits = 31 * bits + getFromY ( ) ; bits = 31 * bits + getFromZ ( ) ; return bits ^ ( bits > > 31 ) ; }
java public static AccountCollection all ( Map < String , Object > params ) throws AuthenticationException , InvalidRequestException , APIConnectionException , CardException , APIException { return all ( params , ( RequestOptions ) null ) ; }
public void onSaveClick ( ) { editView . setSaveState ( true ) ; WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient ( ) ; call = client . submitDescription ( pageTitle , editView . getDescription ( ) , new WikidataDescriptionEditDataClient . Callback ( ) { @Override public void success ( ) { editView . setSaveState ( false ) ; L . i ( "WD description edit successful" ) ; // TODO : go to success fragment } @Override public void failure ( @NonNull Throwable caught ) { editView . setSaveState ( false ) ; L . e ( "WD description edit failed : " , caught ) ; // TODO : go to failure fragment } } ) ; } @Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( call != null ) { call . cancel ( ) ; } }
protected ResourceSet loadResource ( IEditorInput editorInput ) { final URI resourceURI = EditUIUtil . getURI ( editorInput , null ) ; return ResourceSetHelpers . loadResourceSetWithProxies ( resourceURI , getCommandStack ( ) ) ; }
Code Refactored :  FileReftableStack . CompactionStats getCompactionStats ( ) throws IOException { return reftableStack . getStats ( ) ; }
public OnlineBackup incremental ( String targetDirectory ) { outcome = new BackupService ( ) . doIncrementalBackup ( hostNameOrIp , port , new File ( targetDirectory ) , getConsistencyCheck ( true ) , timeoutMillis , defaultConfig ( ) ) ; return this ; } // Review : This code changes the default behavior by calling the getConsistencyCheck method with a true parameter . It is unclear if this is intentional or not . If it is intentional , it should be documented and reviewed for potential impact on the system . If it is not intentional , the parameter should be changed to false or removed altogether to maintain the default behavior .
private boolean isValidConfiguration ( ) { return ! ( isDiscarding ( ) || isCalleeData ( ) ) || isAsync ( ) ; }
public boolean setTrace ( @NonNull ITmfTrace trace ) throws TmfAnalysisException { boolean ret = super . setTrace ( trace ) ; if ( ! ret ) { return ret ; } ret = fCriticalPathModule . setTrace ( trace ) ; if ( ret ) { fCriticalPathModule . setParameter ( CriticalPathModule . PARAM_GRAPH , getId ( ) ) ; } return ret ; }
public void fillContextMenu ( final IMenuManager menu ) { super . fillContextMenu ( menu ) ; final ISelection selection = getContext ( ) . getSelection ( ) ; if ( selection . isEmpty ( ) ) { return ; } try { Job . getJobManager ( ) . join ( AbstractRepresentationsFileJob . FAMILY , new NullProgressMonitor ( ) ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } contextMenuFiller . fillContextMenu ( menu , selection ) ; }
public void dispose ( ) { // run super . super . dispose ( ) ; // remove ourselves as a selection and registry listener getSite ( ) . getPage ( ) . removePostSelectionListener ( this ) ; RegistryFactory . getRegistry ( ) . removeListener ( this ) ; ISaveablesLifecycleListener saveables = getSite ( ) . getService ( ISaveablesLifecycleListener . class ) ; if ( saveables instanceof SaveablesList ) { ( ( SaveablesList ) saveables ) . removeModelLifecycleListener ( saveablesTracker ) ; } currentPart = null ; currentSelection = null ; pinPropertySheetAction = null ; }
public void setBaseballCard ( BaseballCard card ) { Locale locale = Locale . getDefault ( ) ; brand . setText ( card . brand ) ; year . setText ( String . valueOf ( card . year ) ) ; number . setText ( card . number ) ; player . setText ( card . playerName ) ; }
private static String capitalize ( String word ) { return Character . toUpperCase ( word . charAt ( 0 ) ) + word . substring ( 1 ) ; }

private static boolean isStringParameter ( @NonNull Expression expression , @NonNull JavaContext context ) { if ( expression instanceof StringLiteral ) { return true ; } else { ResolvedNode resolvedNode = context . resolve ( expression ) ; if ( resolvedNode instanceof ResolvedField ) { if ( ( ( ResolvedField ) resolvedNode ) . getValue ( ) instanceof String ) { return true ; } } } return false ; }
protected double getScore ( double availableCpu , double availableMemory , Map < String , Double > availableGenericResources ) { return getScore ( availableCpu , availableMemory , availableGenericResources , getNextHighest ( ) ) ; }
public < T extends Action > List < T > getActions ( Class < T > type ) { List < T > _actions = Util . filter ( getActions ( ) , type ) ; for ( TransientActionFactory < ? > taf : TransientActionFactory . factoriesFor ( getClass ( ) , type ) ) { _actions . addAll ( Util . filter ( createFor ( taf ) , type ) ) ; } return Collections . unmodifiableList ( _actions ) ; }
public void addRepresentation ( ImageData srcImageData , int zoom ) { if ( srcImageData == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; int imageSelectorIndex = DPIUtil . mapZoomToImageSelectorIndex ( zoom ) ; if ( imageSelectorIndex == getImageSelector ( ) ) { init ( srcImageData ) ; init ( ) ; } data [ imageSelectorIndex ] = srcImageData ; }
private DefaultEnvironment buildEnvironment ( EnvironmentType environmentType ) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment ( environmentType ) ; return defaultEnvironment ; }
public int hashCode ( ) { if ( getRepositoryName ( ) != null ) return getRepositoryName ( ) . hashCode ( ) ; return System . identityHashCode ( this ) ; }
public List < String > getExtensions ( ) { return extensions ; }
public List < RadiologyOrder > getRadiologyOrdersByPatient ( Patient patient ) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria ( ) ; addRestrictionOnPatient ( radiologyOrderCriteria , patient ) ; final List < RadiologyOrder > result = ( List < RadiologyOrder > ) radiologyOrderCriteria . list ( ) ; return result == null ? new ArrayList < RadiologyOrder > ( ) : result ; }
public Weld addExtensions ( Class < ? extends Extension > . . . extensionClasses ) { for ( Class < ? extends Extension > extensionClass : extensionClasses ) { try { Extension extension = SecurityActions . newInstance ( extensionClass ) ; addExtension ( extension ) ; } catch ( Exception ex ) { CommonLogger . LOG . unableToInstantiate ( extensionClass , new Object [ ] { } , ex ) ; } } return this ; }
public RTTestsParser ( ) { super ( Messages . _Warnings_RTTests_ParserName ( ) , Messages . _Warnings_RTTests_LinkName ( ) , Messages . _Warnings_RTTests_TrendName ( ) , CYCLICTEST_WARNING_PATTERN ) ; }
private ValidationResult hostExists ( ) { return getVds ( ) == null ? new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_HOST_NOT_EXIST ) : ValidationResult . VALID ; }
public static ToolTipString fromString ( String text ) { return new ToolTipString ( text , toHtmlString ( text ) ) ; }
public DataRadioStation getNextById ( String id ) { if ( listStations . isEmpty ( ) ) return null ; for ( int i = 0 ; i < listStations . size ( ) - 1 ; i ++ ) { if ( listStations . get ( i ) . ID . equals ( id ) ) { return listStations . get ( i + 1 ) ; } } return listStations . get ( 0 ) ; }
public static void setBiomeArrayMethod ( boolean jeidPresent ) { try { if ( jeidPresent ) { biomeArrayMethod = Chunk . class . getMethod ( "getIntBiomeArray" ) ; } else { biomeArrayMethod = Chunk . class . getMethod ( "getBiomeArray" ) ; } } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } }
public String getDescription ( ) { return "Transform files representing a structured table under an Alluxio directory . " + "\n\n" + "Files are coalesced and converted to parquet format . " + "\n\n" + "Definition is in format like 'write ( hive ) . option ( hive . num . files , 100 ) ' , " + "currently , the only modification you can do to the example definition is " + "the number of files in the option . " ; }
public static void validateNonNegative ( int [ ] data , String paramName ) { if ( data == null ) { return ; } boolean nonnegative = true ; for ( int value : data ) { if ( value < 0 ) { nonnegative = false ; } } Preconditions . checkArgument ( nonnegative , "Values for % s must be >= 0 , got : % s" , paramName , data ) ; }
public SetContentTypeFilter ( ) throws IOException { mimetypeToExtensionMap = new Properties ( ) ; mimetypeToExtensionMap . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "mimetypeToExtension . txt" ) ) ) ; contentTypeProperties = new Properties ( ) ; contentTypeProperties . load ( new InputStreamReader ( this . getClass ( ) . getResourceAsStream ( "toContentType . properties" ) ) ) ; }
private SwiftApi api ( String authUrl , Properties overrides ) throws IOException { overrides . setProperty ( CREDENTIAL_TYPE , "tempAuthCredentials" ) ; return ContextBuilder . newBuilder ( new SwiftApiMetadata ( ) ) . credentials ( "user" , "password" ) . endpoint ( authUrl ) . overrides ( overrides ) . modules ( ImmutableSet . of ( new ExecutorServiceModule ( sameThreadExecutor ( ) ) ) ) . buildApi ( SwiftApi . class ) ; }
public void setAcceptableValues ( Collection < K > values ) { buttons . clear ( ) ; panels . clear ( ) ; wrapperPanel . clear ( ) ; if ( values != null ) { for ( final K value : values ) { addValue ( value ) ; } } updateButtons ( ) ; }
public Bucket getOrCreateBucket ( String bucketName ) { Bucket bucket = storage . get ( bucketName ) ; if ( bucket == null ) { log . debug ( String . format ( "Creating a new bucket % s" , bucketName ) ) ; return storage . create ( BucketInfo . of ( bucketName ) ) ; } return bucket ; }
private void onFragmentLoaded ( ) { if ( searchAdapter == null ) { searchAdapter = new SearchlistAdapter ( getActivity ( ) , itemAccess ) ; setListAdapter ( searchAdapter ) ; } searchAdapter . notifyDataSetChanged ( ) ; setListShown ( true ) ; String query = getArguments ( ) . getString ( ARG_QUERY ) ; setEmptyText ( getString ( R . string . no_results_for_query , query ) ) ; }
private Iterable < Ref > getSortedRefs ( ) throws Exception { List < Ref > all = db . getRefDatabase ( ) . getRefsByPrefix ( ALL ) ; // TODO ( jrn ) check if we can reintroduce fast - path by e . g . implementing // SortedList return RefComparator . sort ( all ) ; }
private static void convertAAAProfilesResult ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { List < String > results = new ArrayList < String > ( ) ; for ( ProfileEntry profileEntry : source != null ? ( Collection < ProfileEntry > ) source : new ArrayList < ProfileEntry > ( ) ) { results . add ( profileEntry . getProfile ( ) ) ; } return results ; } } ; }
FunctionKindRowColumnHeaderMetaData ( final Supplier < FunctionDefinition > functionSupplier , final CellEditorControlsView . Presenter cellEditorControls , final KindPopoverView . Presenter editor , final Optional < String > editorTitle , final FunctionGrid gridWidget ) { super ( cellEditorControls , editor , editorTitle ) ; this . functionSupplier = functionSupplier ; this . gridWidget = gridWidget ; }
public List < ProxiedPlayer > matchPlayer ( String partialName ) { List < ProxiedPlayer > matched = new ArrayList < ProxiedPlayer > ( ) ; for ( ProxiedPlayer iPlayer : this . getPlayers ( ) ) { String iterPlayerName = iPlayer . getName ( ) ; if ( partialName . equalsIgnoreCase ( iterPlayerName ) ) { matched . add ( iPlayer ) ; break ; } if ( iterPlayerName . toLowerCase ( ) . startsWith ( partialName . toLowerCase ( ) ) ) { matched . add ( iPlayer ) ; } } return matched ; }
private int zigzagDecode ( int input ) { return ( input > > > 1 ) ^ ( - ( input & 1 ) ) ; }
public void testEqualsCondition ( ) { doTest ( ) ; }
public void testRedrawAfterDispose ( ) { LineNumberRulerColumn lineNumberRulerColumn = new LineNumberRulerColumn ( ) ; CompositeRuler ruler = new CompositeRuler ( ) ; ruler . addDecorator ( 0 , lineNumberRulerColumn ) ; SourceViewer sourceViewer = new SourceViewer ( fParent , ruler , SWT . NONE ) ; lineNumberRulerColumn . getControl ( ) . setSize ( 10 , 10 ) ; sourceViewer . getTextWidget ( ) . dispose ( ) ; lineNumberRulerColumn . redraw ( ) ; }
public boolean configureDefaultNetworkRulesForSystemVm ( final Connect conn , final String vmName ) { if ( ! _canBridgeFirewall ) { return false ; } final Script cmd = new Script ( _securityGroupPath , _timeout , s_logger ) ; cmd . add ( "default_network_rules_systemvm" ) ; cmd . add ( " -- vmname" , vmName ) ; cmd . add ( " -- localbrname" , _linkLocalBridgeName ) ; final String result = cmd . execute ( ) ; if ( result != null ) { return false ; } return true ; }
public void testQueryCumulativeTable ( ) { computeActual ( "SELECT * FROM \" * :* \"" ) ; computeActual ( "SELECT * FROM \"java . util . logging :* \"" ) ; assertTrue ( computeActual ( "SELECT * FROM \"java . lang :* \"" ) . getRowCount ( ) > 1 ) ; assertTrue ( computeActual ( "SELECT * FROM \"jAVA . LANg :* \"" ) . getRowCount ( ) > 1 ) ; }
public RequestLogger get ( ) { LoggingRequestLogger logger = new LoggingRequestLogger ( mapper , setMDC , setContextMDC ) ; log . debug ( new Exception ( "Stack trace" ) , "Creating % s at" , logger ) ; return logger ; }
private IllegalReferenceCountException handleIllegalReferenceCountException ( IllegalReferenceCountException e ) { String accessRecord = leak . toString ( ) ; if ( StringUtil . isNullOrEmpty ( accessRecord ) ) { // means leak has been closed and there is no accessRecord . return e ; } return new TrackedIllegalReferenceCountException ( accessRecord , e ) ; }
public List < Payment > getAccountPayments ( final UUID accountId , final boolean withPluginInfo , final boolean withAttempts , final Iterable < PluginProperty > properties , final TenantContext tenantContext ) throws PaymentApiException { return paymentProcessor . getAccountPayments ( accountId , withPluginInfo , withAttempts , tenantContext , internalCallContextFactory . createInternalTenantContext ( accountId , tenantContext ) ) ; }
public void startBucket ( String bucketKey ) { BulkCommand command = getCurrentCommand ( ) ; Serializable auditParam = command . getParam ( NXAuditEventsService . DISABLE_AUDIT_LOGGER ) ; disableAudit = auditParam != null && Boolean . parseBoolean ( auditParam . toString ( ) ) ; retentionManager = Framework . getService ( RetentionManager . class ) ; ruleId = command . getParam ( PARAM_RULE_ID ) ; }
public boolean remove ( Connection connection ) { boolean removed = connectionPool . remove ( connection ) ; if ( getHttpExchanges ( ) . isEmpty ( ) ) { tryRemoveIdleDestination ( ) ; } else if ( removed ) { // Process queued requests that may be waiting . // We may create a connection that is not // needed , but it will eventually idle timeout . process ( true ) ; } return removed ; }
public boolean getRewriteBatchedStatements ( ) { final String isRewrite = super . connectionProperties . getProperty ( REWRITE_BATCHED_STATEMENTS ) ; return isRewrite == null ? false : Boolean . valueOf ( isRewrite ) ; }
public static ScheduledExecutorService newScheduler ( int numThreads , String threadNamePrefix , boolean isDaemon ) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor ( numThreads , new SchedulerThreadFactory ( threadNamePrefix , isDaemon ) ) ; scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; return scheduler ; }
public boolean setValue ( T newValue ) { if ( ! validate ( newValue ) ) { return false ; } PropertyChangeEvent event = new PropertyChangeEvent ( this , id . toString ( ) , this . value , newValue ) ; this . value = newValue ; dispatchChangedEvent ( event ) ; return true ; }
public void onMessage ( MessageHolderWithTokens message ) { try { logger . trace ( "receiving tokens from queue , triggering Notification Dispatcher class to pick the right sender" ) ; dequeueEvent . fire ( message ) ; } catch ( DispatchInitiationException e ) { throw e ; } catch ( Exception e ) { logger . error ( "NotificationDispatcher or PushNotificationSender unexpectedly failed , the message won't be redelivered" , e ) ; } }
private Collection < Key > getRegisteredKeys ( ) { return new ArrayList < Key > ( cacheMap . keySet ( ) ) ; }
protected AbstractMetric ( String metricName , String metricType , T initialValue , MetricReportManager manager ) { name = metricName ; type = metricType ; value = initialValue ; metricManager = manager ; }
public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues ( ) { Allergy allergy = allergy ( ) ; assertThat ( allergy . hasSameValues ( allergy ( ) ) , is ( true ) ) ; }
private static String readMapping ( ) throws ParseException { JSONParser parser = new JSONParser ( ) ; ClassLoader classloader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try ( InputStream inputStream = classloader . getResourceAsStream ( "mapping . json" ) ) { String mapping = IOUtils . toString ( inputStream , "UTF - 8" ) ; Object object = parser . parse ( mapping ) ; JSONObject jsonObject = ( JSONObject ) object ; return jsonObject . toJSONString ( ) ; } catch ( IOException e ) { logger . error ( e ) ; return "" ; } }
public synchronized void commit ( ) throws CommitException { SyncCommitObserver sco = null ; try { sco = new SyncCommitObserver ( ) ; commitAsync ( sco ) ; sco . waitForCommit ( ) ; } finally { updates . clear ( ) ; weakNotification = null ; columnsRead . clear ( ) ; } }
public static boolean hasPictureId ( byte [ ] buf , int off , int len ) { return isValid ( buf , off , len ) && ( buf [ off ] & X_BIT ) != 0 && ( buf [ off + 1 ] & I_BIT ) != 0 ; }
public void setEnabled ( boolean enabled ) { this . active = enabled ; updateButtonState ( ) ; }
default void beforeDataProviderExecution ( IDataProviderMethod dataProviderMethod , ITestNGMethod method , ITestContext iTestContext ) { // not implemented }
private void handleEndActionJobAndStep ( ) { if ( ( ! hasTaskHandlers ( ) || getExecutionIndex ( ) == getTaskHandlers ( ) . size ( ) - 1 ) && ( ! parentHasCallback ( ) || getExecutionContext ( ) . getExecutionMethod ( ) == ExecutionMethod . AsStep ) ) { startFinalizingStep ( ) ; } }
private boolean waitForScanState ( ScanStates state ) { try { do { scanState . wait ( ) ; } while ( ! getScanState ( ) . equals ( state ) ) ; return true ; } catch ( InterruptedException e ) { tsLogger . logger . warn ( "problem waiting for scanLock whilst in state " + state . name ( ) , e ) ; return false ; } }
private void maybeScheduleCheckpoint ( ) { switch ( state ( ) ) { case RESTORING : case SUSPENDED : this . checkpoint = checkpointableOffsets ( ) ; break ; case RUNNING : if ( ! eosEnabled ) { this . checkpoint = checkpointableOffsets ( ) ; } break ; case CREATED : case CLOSED : throw new IllegalStateException ( "Illegal state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; default : throw new IllegalStateException ( "Unknown state " + state ( ) + " while scheduling checkpoint for active task " + id ) ; } }
protected void executeQueryCommand ( ) { Provider hostProvider = getProvider ( ) ; HostProviderProxy proxy = ProviderProxyFactory . getInstance ( ) . create ( hostProvider ) ; getQueryReturnValue ( ) . setReturnValue ( chainToString ( proxy . getCertificateChain ( ) ) ) ; }
public void t1 ( ) { }
public void testValidateDataStreamsNoConflicts ( ) { Metadata metadata = createIndices ( 5 , 10 , "foo - datastream" ) . metadata ; // don't expect any exception when validating a system without indices that would conflict with future backing indices validateDataStreams ( metadata . getIndicesLookup ( ) , ( DataStreamMetadata ) metadata . customs ( ) . get ( DataStreamMetadata . TYPE ) ) ; }
public ShaderProvider getPassShaderProvider ( int n ) { return passShaderProviders [ n ] ; }
public void onConnectionClosedForUser ( QBRTCSession qbrtcSession , Integer integer ) { setStatusForOpponent ( integer , getString ( R . string . closed ) ) ; }
public void install ( ITextViewer textViewer ) { for ( IReconciler iReconciler : fReconcilers ) { iReconciler . install ( textViewer ) ; } }
public JettyServer run ( WebApplicationContext baseContext , boolean directlyUseAsWebAppRoot , Function < Function < Integer , JettyServer > , JettyServer > serverStarter , boolean exitOnError ) { try { configureLogger ( ) ; configureSentry ( baseContext ) ; JettyServer jettyServer = createJettyServer ( baseContext , directlyUseAsWebAppRoot , serverStarter ) ; jettyServer . start ( ) ; logStartupInfo ( baseContext ) ; return jettyServer ; } catch ( Exception e ) { return logErrorAndExit ( e , exitOnError ) ; } }
public PlanItem ( String id , String definitionRef ) { this . id = id ; this . definitionRef = definitionRef ; }
public int hashCode ( ) { return ~~name . hashCode ( ) ; }
protected boolean copyObject ( String src , String dst ) { try { LOG . debug ( "Copying { } to { } " , src , dst ) ; mClient . copyObject ( mBucketNameInternal , src , mBucketNameInternal , dst ) ; return true ; } catch ( CosClientException e ) { LOG . error ( "Failed to rename file { } to { } " , src , dst , e ) ; return false ; } }
public RepositorySearchDialog ( Collection < String > existingDirs ) { this ( existingDirs , false , true ) ; }
public DelegatingResourceDescription getCreatableProperties ( ) { DelegatingResourceDescription description = super . getCreatableProperties ( ) ; description . addProperty ( "location" ) ; return description ; }
private JsonParser getParser ( String data ) throws IOException { // If the first character is { or [ , assume this is // JSON data and use a JsonParser . Otherwise assume // YAML and use a YAMLParser . char firstChar = data . charAt ( 0 ) ; if ( firstChar == ' { ' || firstChar == ' [ ' ) { return this . jsonFactory . createParser ( data ) ; } else { return this . yamlFactory . createParser ( data ) ; } }
public void testGenerateDroolsTestOption ( ) { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig ( ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; config . setGenerateDroolsTestOnError ( true ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isTrue ( ) ; config . setGenerateDroolsTestOnError ( Boolean . FALSE ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isFalse ( ) ; config . setGenerateDroolsTestOnError ( null ) ; assertThat ( config . isGenerateDroolsTestOnError ( ) ) . isNull ( ) ; }
private RawText getRawText ( ObjectId id , Repository repo ) throws IOException { if ( id . equals ( ObjectId . zeroId ( ) ) ) { return new RawText ( new byte [ ] { } ) ; } return new RawText ( repo . openBlob ( id ) . getCachedBytes ( ) ) ; }
private static String getUserAgentSuffix ( ) { return " ; " + USER_AGENT_SUFFIX ; }
public Builder setDataSize ( Estimate dataSize ) { this . dataSize = dataSize ; return this ; }
public boolean isExpired ( Date invocationDate ) { if ( getExpires ( ) != null ) { return getExpires ( ) . before ( invocationDate == null ? new Date ( ) : invocationDate ) ; } return false ; }
public void stop ( ) { if ( isRunning ( ) ) { process . destroy ( ) ; running . set ( false ) ; } }
public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof MacroId ) ) { return false ; } MacroId rhs = ( MacroId ) object ; return new EqualsBuilder ( ) . append ( getId ( ) , rhs . getId ( ) ) . append ( getSyntax ( ) , rhs . getSyntax ( ) ) . isEquals ( ) ; }
public Map < String , Object > getExtraInformation ( ) { return extraInformation ; }
public int hashCode ( ) { return Objects . hash ( pointer , ownerName ) ; }
private String getFriendsPath ( SourcePathResolver sourcePathResolver , ImmutableList < SourcePath > friendPathsSourcePaths ) { if ( friendPathsSourcePaths . isEmpty ( ) ) { return "" ; } // https :/ / youtrack . jetbrains . com / issue / KT - 29933 ImmutableSortedSet < String > absoluteFriendPaths = ImmutableSortedSet . copyOf ( friendPathsSourcePaths . stream ( ) . map ( path - > sourcePathResolver . getAbsolutePath ( path ) . toString ( ) ) . collect ( Collectors . toSet ( ) ) ) ; return " - Xfriend - paths = " + absoluteFriendPaths . stream ( ) . reduce ( "" , ( path1 , path2 ) - > path1 + " , " + path2 ) ; }
public Target ( String targetUriAsString ) { Assert . hasText ( targetUriAsString , "The provided targetUriAsString must neither be null nor empty . " ) ; this . targetUri = URI . create ( targetUriAsString ) ; }
public PropertyInvertedRegexTester ( IPersonAttributesGroupTestDefinition definition ) { super ( definition ) ; setPattern ( definition . getAttributeName ( ) , definition . getTestValue ( ) ) ; }
public final boolean doesProvideNewPage ( ) { return getProvision ( ) . doesProvideNewPage ( ) ; }
private synchronized Handler getHandler ( ) { if ( mHandler == null ) { // Use current main looper mHandler = new Handler ( mContext . getMainLooper ( ) ) ; } return mHandler ; }
@SuppressWarnings ( "UnusedDeclaration" ) @Deprecated public void setDebugging ( boolean debugging ) { setIndicatorsEnabled ( debugging ) ; }
public List < ServerTemplate > load ( ) { synchronized ( store ) { return store . values ( ) . stream ( ) . map ( this : : cloneServerTemplate ) . collect ( Collectors . toList ( ) ) ; } }
public String getLearnerMaster ( ) { QuorumPeer . QuorumServer learnerMaster = observer . getCurrentLearnerMaster ( ) ; if ( learnerMaster == null || learnerMaster . addr . isEmpty ( ) ) { return "Unknown" ; } InetSocketAddress address = learnerMaster . addr . getReachableOrOne ( ) ; return address . getAddress ( ) . getHostAddress ( ) + " : " + address . getPort ( ) ; }
default < R > Task < R > flatMap ( final String desc , final Function1 < ? super T , Task < R > > func ) { ArgumentUtil . requireNotNull ( func , "function" ) ; final Task < Task < R > > nested = map ( "map : " + desc , func ) ; nested . getShallowTraceBuilder ( ) . setSystemHidden ( true ) ; return flatten ( desc , nested ) ; }
protected List < String > findStringsInFileCommon ( String regexp , boolean stopOnFirst , int searchLimit , File fileToSearch ) { return findStringsInFileCommon ( regexp , stopOnFirst , searchLimit , fileToSearch , Project . MSG_INFO ) ; }
public void notifyAboutStartProcess ( String id ) { Long processInstanceId = Long . parseLong ( id ) ; newProcessInstanceEvent . fire ( new NewProcessInstanceEvent ( serverTemplateId , deploymentId , processInstanceId , processDefId , processName , null ) ) ; final String message = Constants . INSTANCE . ProcessStarted ( processInstanceId . longValue ( ) ) ; notificationEvent . fire ( new NotificationEvent ( message , NotificationEvent . NotificationType . SUCCESS ) ) ; close ( ) ; }
protected void process ( final SpaceReference source , final SpaceReference destination ) { visitDocuments ( source , new Visitor < DocumentReference > ( ) { @Override public void visit ( DocumentReference oldChildReference ) { DocumentReference newChildReference = oldChildReference . replaceParent ( source , destination ) ; maybeMove ( oldChildReference , newChildReference ) ; } } ) ; }
public void processEvent ( DiscoveryServiceEvent event ) { log . info ( "Process event { } " , event . getType ( ) ) ; switch ( event . getType ( ) ) { case DISCOVER_INIT_TOPOLOGY : startDiscovery ( ) ; break ; case ACQUIRE_LOCK : processLockAcquire ( ) ; break ; case RELEASE_LOCK : processLockRelease ( ) ; break ; case DISCOVERED_TOPOLOGY : processTopologyChangeNotification ( event ) ; break ; case UPGRADE : processUpgrade ( event ) ; break ; default : log . error ( "Invalid event type { } " , event . getType ( ) ) ; } }
public void deleteError ( final ProgramError error ) { errors . remove ( error ) ; eventBus . publish ( new ProgramErrorDeletedEvent ( error ) ) ; }
public LamiTableContentProvider ( ) { fCurrentEntries = Collections . emptyList ( ) ; }
public ArticlePageObject clickGetInfoLink ( ) { switchToIFrame ( ) ; try { waitForElementByElement ( getInfoLink ) ; // Opens new tab to Template namespace getInfoLink . click ( ) ; return new ArticlePageObject ( driver ) ; } finally { switchOutOfIFrame ( ) ; } }
@Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent ( ) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory ( ) ; factory . setAdviceChain ( new CacheInterceptor ( ) ) ; // the order of advices is important for the downstream interceptor to see the tracing context assertThat ( rabbitTracing . decorateSimpleRabbitListenerContainerFactory ( factory ) . getAdviceChain ( ) ) . hasSize ( 2 ) . matches ( adviceArray - > adviceArray [ 0 ] instanceof TracingRabbitListenerAdvice ) ; }
private static List < IResource > getReadonlyFiles ( IResource [ ] resources ) { List < IResource > readOnlyFiles = new ArrayList < > ( ) ; for ( IResource resource : resources ) { ResourceAttributes resourceAttributes = resource . getResourceAttributes ( ) ; if ( resource . getType ( ) == IResource . FILE && resourceAttributes != null && resourceAttributes . isReadOnly ( ) ) readOnlyFiles . add ( resource ) ; } return readOnlyFiles ; }
void clean ( K key ) { getDataMap ( ) . remove ( key ) ; }
public static boolean isMemoryDeviceHotUnpluggable ( VmDevice memoryDevice ) { if ( ! isMemory ( memoryDevice ) ) { throw new IllegalArgumentException ( "Memory device expected but device " + memoryDevice + " obtained . " ) ; } return getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_SIZE ) . isPresent ( ) && getSpecParamsIntValue ( memoryDevice , SPEC_PARAM_NODE ) . isPresent ( ) ; }
public Boolean connectorExists ( String id ) { try { List < ConnectorConfiguration > list = configPersistence . load ( ImmutableMap . of ( Constants . CONNECTOR_PERSISTENT_ID , id ) ) ; return ! list . isEmpty ( ) ; } catch ( PersistenceException e ) { throw new RuntimeException ( e ) ; } }
public void testUpdateStmtBuilder ( ) { printStatement ( "update foo set \"column [ 'looks_like_nested' ] \" = 1" ) ; printStatement ( "update foo set foo . a = 'b'" ) ; printStatement ( "update bar . foo set bar . foo . t = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3" ) ; printStatement ( "update foo set col [ 'x' ] = 3 where foo [ 'x' ] = 2" ) ; printStatement ( "update schemah . foo set foo . a = 'b' , foo . b = foo . a" ) ; printStatement ( "update schemah . foo set foo . a = abs ( - 6 . 3334 ) , x = true where x = false" ) ; }
public void setSetPath ( String path ) { requireNonNull ( path , "path is null" ) ; setPath . set ( path ) ; }
public EnvVars getEnvironment ( ) throws IOException , InterruptedException { EnvVars cachedEnvironment = this . cachedEnvironment ; if ( cachedEnvironment != null ) { return cachedEnvironment ; } cachedEnvironment = EnvVars . getRemote ( getChannel ( ) ) ; this . cachedEnvironment = cachedEnvironment ; return cachedEnvironment ; }

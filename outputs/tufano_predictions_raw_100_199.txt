protected void remove ( MessageGroup group ) { Object correlationKey = group . getGroupId ( ) ; if ( ForceReleaseMessageGroupProcessor . class . isInstance ( group . getProcessor ( ) ) ) { this . messageStore . removeMessageGroup ( correlationKey ) ; this . groupIds . remove ( correlationKey ) ; } }
public void sendOffsetsToTransaction ( Map < TopicPartition , OffsetAndMetadata > offsets , String consumerGroupId ) throws ProducerFencedException { ConsumerGroupMetadata cachedGroupMetadata = new ConsumerGroupMetadata ( consumerGroupId , JoinGroupRequest . UNKNOWN_GENERATION_ID , JoinGroupRequest . UNKNOWN_MEMBER_ID , Optional . empty ( ) ) ; sendOffsetsToTransactionInternal ( offsets , cachedGroupMetadata , false ) ; }
public boolean cancel ( final Exception rootReason ) { if ( transitionCancel ( rootReason ) ) { final Exception reason = new CancellationException ( rootReason ) ; try { traceFailure ( reason ) ; } catch ( Throwable ex ) { LOGGER . warn ( "Exception thrown in logging trace for failure ! " , ex ) ; try { LOGGER . error ( "Failed to log cancellation reason : " + ex . getMessage ( ) ) ; } catch ( Throwable t ) { // ignore } } getSettableDelegate ( ) . fail ( reason ) ; return true ; } return false ; }
private int allVersionsCombined ( ) { return formatIdentifier > > > SHIFT_FORMAT_IDENTIFIER | formatVersion > > > SHIFT_FORMAT_VERSION ; }
< START > protected void writeJDBCStoreConnection ( XMLExtendedStreamWriter writer , SimpleConnectionFactoryConfiguration configuration ) throws XMLStreamException { writer . writeStartElement ( Element . SIMPLE_CONNECTION ) ; writeOptional ( writer , Attribute . CONNECTION_URL , configuration . getConnectionUrl ( ) ) ; writeOptional ( writer , Attribute . DRIVER_CLASS , configuration . getDriverClass ( ) ) ; writeOptional ( writer , Attribute . USERNAME , configuration . getUsername ( ) ) ; writeOptional ( writer , Attribute . PASSWORD , configuration . getPassword ( ) ) ; writer . writeEndElement ( ) ; } < END >
private static ByteBuf copyData ( ByteBufList list ) { ByteBuf buf = Unpooled . buffer ( list . readableBytes ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { buf . writeBytes ( list . getBuffer ( i ) . slice ( ) ) ; } return buf ; }
private String getXMI_ID ( final EObject eobject ) { if ( eobject . eResource ( ) instanceof XMIResource ) { return ( ( XMIResource ) eobject . eResource ( ) ) . getID ( eobject ) ; } return null ; }
@Override public float getPressure ( ) { return 0 ; }
private boolean checkForJournalFlush ( ) { if ( QueueBatchSize == 0 ) return true ; if ( queue . size ( ) >= QueueBatchSize ) return true ; boolean journalSizeFlush = ( JournalThresholdSize > 0 && journal . size ( ) > JournalThresholdSize ) ; if ( journalSizeFlush ) return true ; return false ; }
private ProjectState newProjectState ( ProjectConfig local ) { PrologEnvironment . Factory envFactory = null ; GitRepositoryManager gitMgr = null ; ProjectControl . AssistedFactory projectControlFactory = null ; RulesCache rulesCache = null ; SitePaths sitePaths = null ; List < CommentLinkInfo > commentLinks = null ; ProjectState projectState = new ProjectState ( sitePaths , projectCache , allProjectsName , projectControlFactory , envFactory , gitMgr , rulesCache , commentLinks , local ) ; all . add ( projectState ) ; return projectState ; }
public static Collection < PersonaAccount > getPersonaAccountsForAccount ( long accountId ) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts . account_id = " + accountId + " AND p . status_id != " + Persona . PersonaStatus . DELETED . getStatusId ( ) ; CentralRepository cr = CentralRepository . getInstance ( ) ; if ( cr != null ) { PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback ( ) ; cr . executeSelectSQL ( queryClause , queryCallback ) ; return queryCallback . getPersonaAccountsList ( ) ; } return new ArrayList < > ( ) ; }
public boolean hasMultipleValues ( final String dimension ) { if ( isVirtualColumn ( dimension ) ) { return virtualColumns . getVirtualColumn ( dimension ) . capabilities ( dimension ) . hasMultipleValues ( ) ; } else { final Column column = index . getColumn ( dimension ) ; if ( column != null && columnSupportsFiltering ( column ) ) { return column . getCapabilities ( ) . hasMultipleValues ( ) ; } else { return false ; } } }
public void resumeNode ( String id ) { api . serverApi ( ) . updateStatus ( id , Server . UpdateStatus . create ( Types . ServerAction . POWER_ON , Types . ServerActionMethod . HARDWARE ) ) ; }
public IStyledLabelProvider [ ] loadLabelProviders ( ) { if ( fLabelProviders == null ) { fLabelProviders = CHEProviderSettings . getCCallHierarchyLabelProviders ( ) ; } return fLabelProviders ; }
It is unclear why the operations are being registered and what invokes them . Therefore , the code has been refactored to remove the unnecessary registration of operations . public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { if ( showResources ) { resourceRegistration . registerOperationHandler ( ShowJaxrsResourcesHandler . DEFINITION , new ShowJaxrsResourcesHandler ( ) ) ; } }
public int hashCode ( ) { int result = 17 ; result = 31 * result + processId . hashCode ( ) ; result = 31 * result + taskId . hashCode ( ) ; result = 31 * result + taskName . hashCode ( ) ; result = 31 * result + formName . hashCode ( ) ; return result ; }
< START > public void stop ( final String reason ) < END > { new Thread ( "Shutdown Thread" ) { @Override public void run ( ) { independentThreadStop ( reason , true ) ; } } . start ( ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return ( ( key == null ? e . getKey ( ) == null : key . equals ( e . getKey ( ) ) ) && ( value == null ? e . getValue ( ) == null : value . equals ( e . getValue ( ) ) ) ) ; }
protected PostgreSqlEngine ( final PdbProperties properties , final String driver ) throws DatabaseEngineException { super ( driver , properties , Dialect . POSTGRESQL ) ; }
public synchronized void dispose ( ) { clearCachedSwingEditor ( ) ; }
public void run ( ) { try { if ( logger . isInfoEnabled ( ) ) logger . info ( "Start reconnecting " + provider ) ; provider . register ( getUIService ( ) . getDefaultSecurityAuthority ( provider ) ) ; } catch ( OperationFailedException ex ) { logger . error ( "cannot re - register provider will keep going" , ex ) ; } }
public void checkProperties ( Properties properties , Class < ? > clazz ) { properties . setProperty ( "log4j . shutdownCallbackRegistry" , clazz . getPackage ( ) . getName ( ) + " . Log4jShutdown" ) ; properties . setProperty ( "log4j . shutdownHookEnabled" , "true" ) ; }
public void testUnmarshallTopLevelEmptyEventProperties ( ) throws Exception { Diagram < Graph , Metadata > diagram = unmarshall ( marshaller , BPMN_START_EVENT_FILE_PATH ) ; assertDiagram ( diagram , AMOUNT_OF_NODES_IN_DIAGRAM ) ; StartTimerEvent emptyTop = getStartNodeById ( diagram , EMPTY_TOP_LEVEL_EVENT_ID , StartTimerEvent . class ) ; assertGeneralSet ( emptyTop . getGeneral ( ) , EMPTY_VALUE , EMPTY_VALUE ) ; assertTimerEventEmpty ( emptyTop . getExecutionSet ( ) , NON_INTERRUPTING , EMPTY_VALUE ) ; // Know issue . Should be uncommented after https :/ / issues . jboss . org / browse / JBPM - 7038 will be fixed // assertDataIOSet ( emptySubprocess . getDataIOSet ( ) , EMPTY_VALUE ) ; }
private EmbeddedExpirableMetadata ( long lifespan , TimeUnit lifespanUnit , long maxIdle , TimeUnit maxIdleUnit , EntryVersion version ) { super ( version ) ; this . lifespan = lifespan < 0 ? lifespan : lifespanUnit . toMillis ( lifespan ) ; this . maxIdle = maxIdle < 0 ? maxIdle : maxIdleUnit . toMillis ( maxIdle ) ; }
protected void setMatcherString ( String pattern ) { if ( pattern . isEmpty ( ) ) { searchPattern = null ; } else { SearchPattern patternMatcher = new SearchPattern ( ) ; if ( ! pattern . startsWith ( " * " ) && ! pattern . startsWith ( " ? " ) && ! pattern . startsWith ( " . " ) ) { pattern = " * " + pattern ; } patternMatcher . setPattern ( pattern ) ; searchPattern = patternMatcher ; } }
public DefaultEditorSession ( final ManagedSession session , final CanvasCommandManager < AbstractCanvasHandler > canvasCommandManager , final @Session SessionCommandManager < AbstractCanvasHandler > sessionCommandManager , final @Request SessionCommandManager < AbstractCanvasHandler > requestCommandManager , final ClientCommandRegistry < org . kie . workbench . common . stunner . core . command . Command < AbstractCanvasHandler , CanvasViolation > > clientCommandRegistry ) { this . session = session ; this . commandRegistry = clientCommandRegistry ; this . commandRegistry . setSession ( session ) ; this . sessionCommandManager = sessionCommandManager ; this . requestCommandManager = requestCommandManager ; this . canvasCommandManager = canvasCommandManager ; }
private String transformToHeaderValue ( Directive . . . directives ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < directives . length - 1 ; i ++ ) { sb . append ( directives [ i ] . headerValue ) . append ( " , " ) ; } sb . append ( directives [ directives . length - 1 ] . headerValue ) ; return sb . toString ( ) ; }
private static void fireOnFailure ( final NodeProvisioner . PlannedNode plannedNode , final Throwable cause ) { for ( CloudProvisioningListener cl : CloudProvisioningListener . all ( ) ) { try { cl . onFailure ( plannedNode , cause ) ; } catch ( Throwable e ) { LOGGER . log ( Level . SEVERE , "Unexpected uncaught exception encountered while " + "processing onFailure ( ) listener call in " + cl + " for agent " + plannedNode . displayName , e ) ; if ( e instanceof Error ) { throw e ; } } } }
public synchronized boolean isLastMQNotifLongAgo ( ) { long delay = 18 * 3600 ; // 24h - 3h = 18h long threshold = sharedPreferences . getLong ( getCurrentModeName ( ) + LAST_MORNING_Q_TIMESTAMP , - delay ) + delay ; if ( threshold < Calendar . getInstance ( ) . getTimeInMillis ( ) ) { Logger . d ( TAG , " { } - Last MQ notif was yesterday" , getCurrentModeName ( ) ) ; return true ; } else { Logger . v ( TAG , " { } - Last MQ notif was recent , do not notify" , getCurrentModeName ( ) ) ; return false ; } }
public CrewMember apply ( org . atlasapi . media . entity . CrewMember input ) { if ( input instanceof org . atlasapi . media . entity . Actor ) { return translateLegacyActor ( ( org . atlasapi . media . entity . Actor ) input ) ; } else if ( input != null ) { return translateLegacyCrewMember ( input ) ; } else { return null ; } }
public void testSocket ( ) throws Exception { Socket s = new Socket ( ) ; s . connect ( server . getLocalAddress ( ) ) ; Map < String , Object > liveDescriptors = tagger . getLiveDescriptors ( ) ; s . close ( ) ; assertFalse ( liveDescriptors . isEmpty ( ) ) ; }
public ValuesMatcher ( Map < String , Integer > outputSymbolAliases , Optional < Integer > expectedOutputSymbolCount , Optional < List < List < Expression > > > expectedRows ) { this . outputSymbolAliases = ImmutableMap . copyOf ( outputSymbolAliases ) ; this . expectedOutputSymbolCount = expectedOutputSymbolCount ; this . expectedRows = expectedRows ; }
protected Button getButton ( int id ) { return buttons . get ( id ) ; }
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) { if ( data instanceof Map ) { Map < ? , ? > map = ( Map < ? , ? > ) data ; color = ( String ) map . get ( "color" ) ; // $NON - NLS - 1$ } }
public void addRequestCleanupHandler ( HttpServletRequest request ) { RequestContext . getActiveContext ( request ) . addRequestCleanupHandler ( new RequestCleanupHandler ( ) { @Override public void cleanup ( HttpServletRequest req ) { try { close ( ) ; } catch ( OperationException e ) { throw new NuxeoException ( e ) ; } } } ) ; }
public void visitStatementList ( PyStatementListTree pyStatementListTree ) { if ( isStmtListIncrementsNestingLevel ( pyStatementListTree . parent ( ) . isNot ( Kind . FILE_INPUT ) ) ) { nestingLevelStack . peek ( ) . increment ( ) ; super . visitStatementList ( pyStatementListTree ) ; nestingLevelStack . peek ( ) . decrement ( ) ; } else { super . visitStatementList ( pyStatementListTree ) ; } }  In the refactored code , the logic about `Kind . FILE_INPUT` has been moved inside the `isStmtListIncrementsNestingLevel` method . The `isNot` method is used to check if the parent node is not of type `Kind . FILE_INPUT` . This simplifies the code and makes it more readable .
private static void checkLxmlParseCall ( SubscriptionContext ctx ) { CallExpression callExpression = ( CallExpression ) ctx . syntaxNode ( ) ; if ( checkCallExpressionFqn ( callExpression , LXML_PARSE ) ) { CallExpression parserCall = getParserCall ( getArgValueAsCallExpression ( TreeUtils . nthArgumentOrKeyword ( 1 , "parser" , callExpression . arguments ( ) ) ) ) ; if ( parserCall != null && isUnsafeParserUsage ( parserCall ) ) { ctx . addIssue ( parserCall , MESSAGE ) . secondary ( callExpression ) ; } } }
public int getVisibility ( IBinding member ) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock ( getLinkage ( ) , record + MEMBERLIST ) ; return members . getAccessibility ( member ) ; } catch ( CoreException e ) { CCorePlugin . log ( e ) ; throw new IllegalArgumentException ( member . getName ( ) + " is not a member of " + getName ( ) ) ; } }
public Map < String , Object > getDynamicTemplateData ( ) { return ( dynamicTemplateData == null ) ? Collections . < String , Object > emptyMap ( ) : dynamicTemplateData ; }
private String version ; public String getVersion ( ) { return version ; }
public List < User > getUsers ( PerunSession sess ) throws InternalErrorException , PrivilegeException { Utils . checkPerunSession ( sess ) ; // Authorization if ( ! AuthzResolver . isAuthorized ( sess , Role . PERUNOBSERVER ) ) { throw new PrivilegeException ( sess , "getUsers" ) ; } return getUsersManagerBl ( ) . getUsers ( sess ) ; }
protected void setDefaultSwitchTypeIfNeeded ( ) { Cluster cluster = getCluster ( ) ; if ( ! cluster . isSetRequiredSwitchType ( ) ) { SwitchType defaultSwitchType = DefaultSwitchType . getDefaultSwitchType ( cluster . getCompatibilityVersion ( ) ) ; cluster . setRequiredSwitchTypeForCluster ( defaultSwitchType ) ; } }
public List < BlockLocationInfo > getBlockLocations ( AlluxioURI alluxioURI ) throws IOException { // implementation goes here }
public CustomTxtParserWizard ( ) { this ( null ) ; } public CustomTxtParserWizard ( String title ) { super ( ) ; setWindowTitle ( title != null ? title : Messages . CustomTxtParserInputWizardPage_windowTitle ) ; }
protected Provider < AdditionalProperties > createProvider ( String name ) { Provider < AdditionalProperties > provider = mock ( Provider . class ) ; when ( provider . getName ( ) ) . thenReturn ( name ) ; return provider ; }
public static int mapApiToArtVersion ( int api ) { if ( api < 19 ) { return NO_VERSION ; } switch ( api ) { case 19 : case 20 : return 7 ; case 21 : return 39 ; case 22 : return 45 ; case 23 : return 64 ; case 24 : case 25 : return 79 ; case 26 : return 124 ; case 27 : return 131 ; default : return 143 ; } }
public void onAppendColumnEvent ( ) { AppendColumnEvent event = new AppendColumnEvent ( COLUMN_GROUP ) ; scenarioSimulationEventHandler . onEvent ( event ) ; verify ( scenarioSimulationEventHandler , times ( 1 ) ) . commonExecution ( eq ( scenarioSimulationContextLocal ) , isA ( AppendColumnCommand . class ) ) ; } @Test public void onAppendColumnEvent_shouldSetFocusOnScenarioGridPanel ( ) { // given doNothing ( ) . when ( scenarioGridPanelMock ) . setFocus ( true ) ; AppendColumnCommand command = new AppendColumnCommand ( ) ; // when scenarioSimulationEventHandler . commonExecution ( scenarioSimulationContextLocal , command ) ; // then verify ( scenarioGridPanelMock ) . setFocus ( true ) ; }
public static < T extends Widget > T serializeAndDeserialize ( T instance ) throws Exception { byte [ ] bytes = serialize ( instance ) ; T result = deserialize ( bytes ) ; IDisplayAdapter displayAdapter = result . getDisplay ( ) . getAdapter ( IDisplayAdapter . class ) ; displayAdapter . attachThread ( ) ; return result ; }
< START > public void onPreReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( PreReceiveHook hook : hooks ) { hook . onPreReceive ( rp , commands ) ; } } < END >
public DescriptionBuilder withAdditionalAnnotations ( Annotation annotation , Annotation . . . additionalAnnotations ) { if ( annotation == null ) { throw new NullPointerException ( "Cannot add a null annotation" ) ; } List < Annotation > allAnnotations = new ArrayList < > ( ) ; allAnnotations . add ( annotation ) ; if ( additionalAnnotations != null ) { for ( Annotation a : additionalAnnotations ) { if ( a == null ) { throw new NullPointerException ( "Cannot add a null annotation" ) ; } allAnnotations . add ( a ) ; } } annotations . addAll ( allAnnotations ) ; return this ; }
public void onAttach ( final Activity activity ) { super . onAttach ( activity ) ; if ( activity instanceof Listener ) { mListener = ( Listener ) activity ; } else { Lg . e ( activity . getClass ( ) . getName ( ) , " should implement " , Listener . class . getName ( ) ) ; } }
private void preloadDataSet ( ) { preloadedDataSet = load ( iter . next ( ) ) ; totalOutcomes = preloadedDataSet . getLabels ( ) . size ( - 1 ) ; inputColumns = preloadedDataSet . getFeatureMatrix ( ) . size ( - 1 ) ; batch = preloadedDataSet . numExamples ( ) ; }
public void startup ( Application application , ComponentStartupStatus ss ) { FileOps . ensureDir ( deltaClientZone ) ; FileOps . clearAll ( deltaClientZone ) ; zone = Zone . connect ( deltaClientZone ) ; deltaLink = DeltaLinkHTTP . connect ( deltaServerURL ) ; deltaClient = DeltaClient . create ( zone , deltaLink ) ; jmsMessagingClient = application . getJMSMessagingClient ( ) ; ss . info ( String . format ( "DeltaClient connected to DeltaServer at % s with zone % s" , deltaServerURL , deltaClientZone ) ) ; }
protected void onInit ( ) { super . onInit ( ) ; if ( this . connectionFactory == null ) { this . connectionFactory = new TcpNioServerConnectionFactory ( super . getPort ( ) ) ; this . connectionFactory . setDeserializer ( new ByteArrayLfSerializer ( ) ) ; this . connectionFactory . setBeanFactory ( getBeanFactory ( ) ) ; if ( this . applicationEventPublisher != null ) { this . connectionFactory . setApplicationEventPublisher ( this . applicationEventPublisher ) ; } this . connectionFactory . afterPropertiesSet ( ) ; this . connectionFactory . registerListener ( this ) ; } }
public static Pair < Integer , Integer > getPrecisionAndScale ( String type ) { String param = type . substring ( 8 , type . length ( ) - 1 ) . trim ( ) ; String [ ] params = param . split ( "\\s * , \\s * " ) ; return new Pair < > ( Integer . parseInt ( params [ 0 ] ) , Integer . parseInt ( params [ 1 ] ) ) ; }  Explanation : - Added ` . trim ( ) ` to remove any extraneous whitespaces before and after the parameter string . - Used `\\s * , \\s * ` as the delimiter for `split ( ) ` to handle any whitespaces before or after the comma . - Removed ` . trim ( ) ` from `Integer . parseInt ( ) ` as it is not necessary .
< START > private static String constructSegmentPath ( String baseKey , String storageDir ) { if ( baseKey . isEmpty ( ) ) { return storageDir + " / index . zip" ; } else { return baseKey + " / " + storageDir + " / index . zip" ; } } < END >
public MappingIterator ( Collection < S > source , Function < S , D > transformation ) { this . sourceIt = source . iterator ( ) ; this . transformation = transformation ; } public boolean hasNext ( ) { return sourceIt . hasNext ( ) ; } public D next ( ) { S nextSource = sourceIt . next ( ) ; return transformation . apply ( nextSource ) ; }
public boolean removeAll ( Collection < ? > c ) { boolean changed = false ; for ( XWikiAttachment x : ( Collection < ? extends XWikiAttachment > ) c ) { if ( map . remove ( x . getFilename ( ) ) != x ) { changed = true ; } } if ( changed ) { updatedMap ( ) ; } return changed ; }
public void run ( String . . . strings ) throws Exception { // Starting Audit App }
public CollectEnvCommand ( FileSystemContext fsContext ) { super ( fsContext ) ; registerCommands ( ) ; }
protected void setBlobStorageService ( BlobStorageService blobStorageService ) { if ( blobStorageService == null ) { throw new IllegalArgumentException ( "BlobStorageService cannot be null" ) ; } this . blobStorageService = blobStorageService ; logger . trace ( "BlobStorage service set to { } " , blobStorageService . getClass ( ) ) ; }
public void dispose ( ) { app . getChildren ( ) . remove ( windowModel ) ; coolBarManager . dispose ( ) ; menuManager . dispose ( ) ; statusLineManager . dispose ( ) ; windowModel . getContext ( ) . deactivate ( ) ; windowModel . getContext ( ) . dispose ( ) ; ( ( Shell ) windowModel . getWidget ( ) ) . dispose ( ) ; }
public void setUp ( ) { n = new CacheManagerNotifierImpl ( ) ; cl = new CacheManagerListener ( ) ; TestingUtil . inject ( n , TestingUtil . named ( KnownComponentNames . ASYNC_NOTIFICATION_EXECUTOR , new WithinThreadExecutor ( ) ) ) ; n . start ( ) ; n . addListener ( cl ) ; }
public char getLabel ( ) { final char rv ; switch ( getType ( ) ) { case INPUT_VAL : rv = buttonData . inputVal ; break ; case AUTO_CHAR : rv = buttonData . autoChar ; break ; case CUSTOM : rv = buttonData . customChar ; break ; default : rv = ' * ' ; // Should never happen . } return rv ; }
public ReleasableBytesReference retainedSlice ( int from , int length ) { BytesReference slice = delegate . slice ( from , length ) ; return new ReleasableBytesReference ( slice , refCounted . incRef ( ) ) ; }
public static < T > Iterable < T > latest ( final Observable < ? extends T > source ) { return new Iterable < T > ( ) { @Override public Iterator < T > iterator ( ) { LatestObserverIterator < T > lio = new LatestObserverIterator < T > ( ) ; lio . subscription = source . materialize ( ) . subscribe ( lio ) ; return lio ; } } ; } private static class LatestObserverIterator < T > extends SafeSubscriber < Notification < ? extends T > > implements Iterator < T > { private Notification < ? extends T > next ; private boolean hasNext = false ; @Override public void onNext ( Notification < ? extends T > args ) { if ( args . isOnCompleted ( ) ) { unsubscribe ( ) ; } else { hasNext = true ; next = args ; } } @Override public void onError ( Throwable e ) { throw new RuntimeException ( e ) ; } @Override public void onCompleted ( ) { // Do nothing } @Override public boolean hasNext ( ) { if ( ! hasNext ) { next = takeNext ( ) ; } return hasNext ; } @Override public T next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } hasNext = false ; return next . getValue ( ) ; } private Notification < ? extends T > takeNext ( ) { if ( subscription . isUnsubscribed ( ) ) { throw new NoSuchElementException ( ) ; } hasNext
public static MessageType fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return current ; } } return null ; }  or  public static Optional < MessageType > fromId ( String id ) { for ( MessageType current : values ( ) ) { if ( current . getId ( ) . equals ( id ) ) { return Optional . of ( current ) ; } } return Optional . empty ( ) ; }  Note : The refactored code returns `null` or an `Optional` instead of an enum entry that only exists for this method .
private boolean isHostNetworkUnreacable ( VDS vds ) { VdsDynamic vdsDynamic = vds . getDynamicData ( ) ; return vdsDynamic . getStatus ( ) == VDSStatus . Down || vdsDynamic . getStatus ( ) == VDSStatus . Reboot || ( vdsDynamic . getStatus ( ) == VDSStatus . NonOperational && vdsDynamic . getNonOperationalReason ( ) == NonOperationalReason . NETWORK_UNREACHABLE ) ; }
public class ScriptExecutingMessageSource { public ScriptExecutingMessageSource ( AbstractScriptExecutingMessageProcessor < ? > scriptMessageProcessor ) { this . scriptMessageProcessor = scriptMessageProcessor ; } }
public void typeInSearchField ( String content ) { waitForElementVisibleByElement ( searchInput ) ; searchInput . sendKeys ( content ) ; PageObjectLogging . log ( "typeInSearchField" , "String > > " + content + " < < was typed in string field" , true ) ; }  Explanation : The substring was used to limit the length of the input string to be typed in the search field . However , it is not necessary to limit the length of the input string as the `sendKeys` method can handle the entire string . Therefore , the substring can be removed .
public Iterable < E > read ( Configuration configuration ) throws IOException { DatasetReader < E > reader = view . newReader ( ) ; return reader ; }
public void setRefreshInterval ( final long refreshInterval ) { final long refreshIntervalInSeconds = refreshInterval ; }
public void onNewImageFromCamera ( ) { if ( navigator . isSdkAboveOrEqualM ( ) && ! navigator . doIHavePermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) ) { navigator . askForPermission ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA ) ; } else { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; } } // Extracted function private boolean checkPermissionAndAsk ( String permission , int requestCode ) { if ( navigator . isSdkAboveOrEqualM ( ) && ! navigator . doIHavePermission ( permission ) ) { navigator . askForPermission ( new String [ ] { permission } , requestCode ) ; return false ; } else { return true ; } } public void onNewImageFromCamera ( ) { if ( checkPermissionAndAsk ( Manifest . permission . WRITE_EXTERNAL_STORAGE , PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA ) ) { interactor . createFile ( this , CREATE_FILE_TAKE_PHOTO , null ) ; } }
public void testEquals ( ) throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true , false , true ) ; FixedWidthConfiguration conf2 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , true , false , true ) ; assertEquals ( conf1 , conf2 ) ; FixedWidthConfiguration conf3 = new FixedWidthConfiguration ( 1 , "UTF8" , 10 , false , false , true ) ; assertFalse ( conf1 . equals ( conf3 ) ) ; } public class FixedWidthConfiguration { private int width ; private String encoding ; private boolean ignoreMissing ; private boolean ignoreExtra ; private boolean ignoreEmptyLines ; public FixedWidthConfiguration ( int width , String encoding , boolean ignoreMissing , boolean ignoreExtra , boolean ignoreEmptyLines ) { this . width = width ; this . encoding = encoding ; this . ignoreMissing = ignoreMissing ; this . ignoreExtra = ignoreExtra ; this . ignoreEmptyLines = ignoreEmptyLines ; } public FixedWidthConfiguration ( int width , String encoding , int ignoreMissing , boolean ignoreExtra , boolean ignoreEmptyLines ) { this . width = width ; this . encoding = encoding ; this . ignoreMissing = ignoreMissing == 1 ; this . ignoreExtra = ignoreExtra ; this . ignoreEmptyLines = ignoreEmptyLines ; } // getters and setters @Override public boolean equals ( Object o ) { if ( this == o )
public void showLinkPreview ( PageTitle title , int entrySource ) { final String linkPreviewFragmentTag = "link_preview_dialog" ; LinkPreviewDialog linkPreview = ( LinkPreviewDialog ) getSupportFragmentManager ( ) . findFragmentByTag ( linkPreviewFragmentTag ) ; if ( linkPreview == null ) { linkPreview = LinkPreviewDialog . newInstance ( title , entrySource ) ; linkPreview . show ( getSupportFragmentManager ( ) , linkPreviewFragmentTag ) ; } else { linkPreview . dismiss ( ) ; } }
public void clear ( ) { if ( loader instanceof CacheStore ) { try { ( ( CacheStore ) loader ) . clear ( ) ; } catch ( CacheLoaderException e ) { throw newCacheLoaderException ( e ) ; } } }
public ApplicabilityIds getApplicabilityIds ( ) { // Replace with call to IApplicabilityService calls once implemented ApplicabilityIds ids = new ApplicabilityIds ( ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 345L , "ARC - 210" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 366L , "COMM" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 376L , "ASM" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 368L , "UTF" ) ) ; ids . getApplicabilityIds ( ) . add ( new ApplicabilityId ( 466L , "MDR" ) ) ; return ids ; }
private MediaType tryNarrowMediaType ( MediaType negotiated , AdvancedCache < ? , ? > cache ) { if ( ! negotiated . matchesAll ( ) ) return negotiated ; MediaType storageMediaType = cache . getValueDataConversion ( ) . getStorageMediaType ( ) ; if ( storageMediaType == null ) return negotiated ; if ( storageMediaType . equals ( MediaType . APPLICATION_OBJECT ) ) return MediaType . TEXT_PLAIN ; if ( storageMediaType . match ( MediaType . APPLICATION_PROTOSTREAM ) ) return MediaType . APPLICATION_JSON ; return negotiated ; }
protected void addJAROption ( Composite comp ) { fJarButton = new Button ( comp , SWT . CHECK ) ; fJarButton . setText ( getJarButtonText ( ) ) ; }
public String getTurnDescription ( Translation tr ) { if ( ! name . isEmpty ( ) ) { return getName ( ) ; } return tr . tr ( "finish" ) ; }
private void fetchPresenterWidgetTemplate ( PresenterOptions presenterOptions ) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions ( ) ; presenterWidgetOptions . setSingleton ( presenterConfigModel . isUseSingleton ( ) ) ; createdPresenterWidgetTemplates = CreatePresenterWidget . run ( presenterOptions , presenterWidgetOptions , true ) ; }
public String toString ( ) { StringWriter writer = new StringWriter ( ) ; try { new ObjectMapper ( ) . writeValue ( writer , graph ) ; } catch ( Exception e ) { log . error ( "Error while constructing new ObjectMapper" , e ) ; } return writer . toString ( ) ; }
public TopicStatus ( String topic , ConnectorTaskId task , long discoverTimestamp ) { this ( topic , Objects . requireNonNull ( task ) . connector ( ) , task . task ( ) , discoverTimestamp ) ; } private TopicStatus ( String topic , String connector , int task , long discoverTimestamp ) { this . topic = topic ; this . connector = connector ; this . task = task ; this . discoverTimestamp = discoverTimestamp ; }
private static OGCGeometry readGeometry ( BasicSliceInput input , Slice inputSlice , GeometryType type , int length ) { switch ( type ) { case POINT : return readPoint ( input ) ; case MULTI_POINT : case LINE_STRING : case MULTI_LINE_STRING : case POLYGON : case MULTI_POLYGON : return readSimpleGeometry ( input , inputSlice , type , length ) ; case GEOMETRY_COLLECTION : return readGeometryCollection ( input , inputSlice ) ; case ENVELOPE : return OGCGeometry . createFromEsriGeometry ( readEnvelope ( input ) , null ) ; default : throw new IllegalArgumentException ( "Unexpected type : " + type ) ; } }
public void close ( ) { sketch = null ; values = null ; }
public boolean shouldSpill ( ) { long batchSize = ( batchMemoryManager . getRecordBatchSizer ( RIGHT_INDEX ) . getRowAllocWidth ( ) + 4 ) * recordsPerBatch ; long reserveForOutgoing = batchMemoryManager . getOutputBatchSize ( ) ; long memoryAvailableNow = allocator . getLimit ( ) - allocator . getAllocatedMemory ( ) - reserveForOutgoing - batchMemoryManager . getRecordBatchSizer ( LEFT_INDEX ) . getRowAllocWidth ( ) * recordsPerBatch ; boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow ; if ( needsSpill ) { logger . debug ( "should spill now - batch size { } , mem avail { } , reserved for outgoing { } " , batchSize , memoryAvailableNow , reserveForOutgoing ) ; } return needsSpill ; }
public void close ( ) { try { Await . result ( beam . close ( ) ) ; } catch ( Exception e ) { final String errorMsg = "Error while closing Druid beam client" ; LOG . error ( errorMsg , e ) ; throw new IOException ( errorMsg , e ) ; } }
private boolean isPlatformKeybindingBug517068Fixed ( ) { Bundle bundle = Platform . getBundle ( "org . eclipse . e4 . ui . bindings" ) ; // $NON - NLS - 1$ Version currentVersion = bundle . getVersion ( ) ; Version fixVersion = new Version ( 0 , 12 , 1 ) ; return currentVersion . compareTo ( fixVersion ) >= 0 ; }
public static boolean isPluginPrefixAndArtifactIdEquals ( Plugin p1 , Plugin p2 ) { return StringUtils . equals ( p1 . getArtifactId ( ) , p2 . getArtifactId ( ) ) && StringUtils . equals ( p1 . getPrefix ( ) , p2 . getPrefix ( ) ) ; }
public < VT > MessageOut < T > withParameter ( ParameterType type , VT value ) { List < Object > newParameters = new ArrayList < > ( parameters . size ( ) + 2 ) ; newParameters . addAll ( parameters ) ; newParameters . add ( type ) ; newParameters . add ( value ) ; return new MessageOut < T > ( verb , payload , serializer , newParameters ) ; }
private boolean validateTimeRange ( ) { boolean isEmpty = fStartTimeRangeText . getText ( ) . isEmpty ( ) || fEndTimeRangeText . getText ( ) . isEmpty ( ) ; return ! isEmpty && parseTimeRange ( ) && fStartTimestamp . compareTo ( fEndTimestamp ) < 0 ; }
public static String getFileNamePath ( final String filename , final FieldbookProperties fieldbookProperties ) { final String filenamePath ; StringBuilder filenameBuilder = new StringBuilder ( ) ; filenameBuilder . append ( fieldbookProperties . getUploadDirectory ( ) ) ; filenameBuilder . append ( File . separator ) ; filenameBuilder . append ( SettingsUtil . cleanSheetAndFileName ( filename ) ) ; filenamePath = filenameBuilder . toString ( ) ; return filenamePath ; }
protected void changeStorageDomainStatusInTransaction ( final StoragePoolIsoMap map , final StorageDomainStatus status ) { executeInNewTransaction ( new TransactionMethod < StoragePoolIsoMap > ( ) { @SuppressWarnings ( "synthetic - access" ) @Override public StoragePoolIsoMap runInTransaction ( ) { CompensationContext context = getCompensationContext ( ) ; context . snapshotEntityStatus ( map , map . getStatus ( ) ) ; map . setStatus ( status ) ; getStoragePoolIsoMapDao ( ) . updateStatus ( map . getId ( ) , map . getStatus ( ) ) ; getCompensationContext ( ) . stateChanged ( ) ; return null ; } } ) ; }
public void visitMemberSelectExpression ( MemberSelectExpressionTree tree ) { if ( tree . expression ( ) . is ( Tree . Kind . IDENTIFIER ) ) { IdentifierTree identifier = ( IdentifierTree ) tree . expression ( ) ; Symbol owner = identifier . symbol ( ) . owner ( ) ; if ( owner != null && owner . isMethodSymbol ( ) ) { // No need to investigate selection on local symbols return ; } } if ( tree . expression ( ) . symbolType ( ) . isSubtypeOf ( "java . lang . Class" ) ) { // No need to investigate selection on a Class object return ; } super . visitMemberSelectExpression ( tree ) ; }
public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) { checkNotNull ( key , NULL_KEY_IS_NOT_ALLOWED ) ; checkNotNull ( remappingFunction , NULL_BIFUNCTION_IS_NOT_ALLOWED ) ; return computeIfPresentLocally ( key , remappingFunction ) ; }
public void sendUnanchored ( Task task , String stream , List < Object > values , ExecutorTransfer transfer ) { Tuple tuple = task . getTuple ( stream , values ) ; List < Integer > tasks = task . getOutgoingTasks ( stream , values ) ; if ( ! tasks . isEmpty ( ) ) { for ( Integer t : tasks ) { transfer . transfer ( t , tuple ) ; } } }
AffinityResourceDefinition ( PathElement path ) { super ( path , UndertowExtension . getResolver ( Constants . HANDLER , Constants . AFFINITY , path . getValue ( ) ) , new RestartParentResourceRegistration ( ) , new RestartParentResourceRegistration ( ) ) ; }
@Override public E poll ( ) throws IOException { lock . lock ( ) ; try { if ( queue . isEmpty ( ) ) { return null ; } E peek = queue . peek ( ) ; queue . remove ( ) ; return peek ; } finally { lock . unlock ( ) ; } }
public void testTimeout ( ) throws SystemException , RemoteException { log . tracef ( "Method stateful #testTimeout called" ) ; Transaction txn ; txn = tm . getTransaction ( ) ; TxTestUtil . enlistTestXAResource ( txn ) ; TxTestUtil . enlistTestXAResource ( txn ) ; try { TxTestUtil . waitForTimeout ( tm ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RemoteException ( "Interupted during waiting for transaction timeout" , ie ) ; } }
private UnstagedComparator ( boolean sortAlphabetically ) { this . alphabeticallySort = sortAlphabetically ; }

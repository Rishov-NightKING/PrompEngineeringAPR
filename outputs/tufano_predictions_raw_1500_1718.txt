public List < StandardPreset > getAllStandardPresets ( ) { return this . workbenchDataManager . getStandardPresetDAO ( ) . getAll ( ) ; }
protected void executeVDSCommand ( ) { if ( _vdsManager != null ) { try { _vdsManager . getLockObj ( ) . lock ( ) ; executeVdsIdCommand ( ) ; } finally { _vdsManager . getLockObj ( ) . unlock ( ) ; } } else { executeVdsIdCommand ( ) ; } }
public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt ( ) throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc ( "We are introducing $ { myStringInCtxt } ! " , WEBVIEW_RITION ) ; TemplateBasedDocument templateBase = createTemplateBasedDoc ( templateSrc . getAdaptedDoc ( ) ) ; List < TemplateInput > params = List . of ( factory ( "myStringInCtxt" , StringValue , "Beautiful String" ) ) ; templateBase . saveParams ( TEMPLATE_NAME , params , true ) ; Blob result = templateBase . renderWithTemplate ( TEMPLATE_NAME ) ; assertNotNull ( result ) ; assertEquals ( "We are introducing Beautiful String ! " , result . getString ( ) ) ; }
public static PDPrintStyle getLineStyle ( JSONObject oskariStyle ) { JSONObject stroke = JSONHelper . optJSONObject ( oskariStyle , "stroke" , ( ) - > new JSONObject ( ) ) ; PDPrintStyle style = new PDPrintStyle ( LINE_CAP_STYLE . getOrDefault ( JSONHelper . optString ( stroke , "lineCap" ) , 0 ) ) ; setStrokeStyle ( style , stroke ) ; setLabelStyle ( style , oskariStyle ) ; return style ; }
public static synchronized void init ( Configuration conf ) { if ( ! initDone ) { DefaultConfiguration . conf = conf ; DefaultConfiguration . initDone = true ; // code to be executed } }
private void rollBackToTimestamp ( long timestamp ) { if ( getVersionUnsafe ( ) > timestamp ) { try { rollbackObjectUnsafe ( timestamp ) ; if ( getVersionUnsafe ( ) != timestamp ) { resetUnsafe ( ) ; } } catch ( NoRollbackException nre ) { log . warn ( "Rollback [ { } ] to { } failed { } " , this , timestamp , nre ) ; resetUnsafe ( ) ; } } }
public void prepare ( Properties options ) { Objects . requireNonNull ( mapper , "mapper can not be null" ) ; Objects . requireNonNull ( topicSelector , "topicSelector can not be null" ) ; producer = new KafkaProducer < > ( options ) ; }
protected Control createSWTControl ( Composite parent ) throws DatabindingFailedException { final Control control = super . createSWTControl ( parent ) ; final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory ( new AdapterFactory [ ] { new ReflectiveItemProviderAdapterFactory ( ) , new ComposedAdapterFactory ( ComposedAdapterFactory . Descriptor . Registry . INSTANCE ) } ) ; adapterFactoryItemDelegator = new AdapterFactoryItemDelegator ( composedAdapterFactory ) ; control . addDisposeListener ( e - > composedAdapterFactory . dispose ( ) ) ; return control ; }
public boolean isRegistered ( VeluxProduct product ) { logger . trace ( "isRegistered ( VeluxProduct { } ) called . " , product . toString ( ) ) ; if ( product . isV2 ( ) ) { return isRegistered ( product . getSerialNumber ( ) ) ; } return isRegistered ( product . getProductUniqueIndex ( ) ) ; }
public void tearDown ( ) throws Exception { FileUtils . deleteQuietly ( nuxeoHome ) ; originSystemProps . forEach ( ( key , value ) - > { if ( value == null ) { System . clearProperty ( key ) ; } else { System . setProperty ( key , value ) ; } } ) ; originSystemProps . clear ( ) ; }
private void checkDeployedProject ( String projectName ) { ServersView2 serversView = new ServersView2 ( ) ; serversView . open ( ) ; ServerModule module = serversView . getServer ( FULL_SERVER_NAME ) . getModule ( new RegexMatcher ( " .* " + projectName + " .* " ) ) ; new WaitUntil ( new ServerModuleHasState ( module , ServerState . STARTED ) , TimePeriod . getCustom ( 30 ) ) ; assertTrue ( "Module has not been started ! " , module . getLabel ( ) . getState ( ) == ServerState . STARTED ) ; }
SlackService getSlackService ( final String baseUrl , final String teamDomain , final String authTokenCredentialId , final boolean botUser , final String room ) { return new StandardSlackService ( baseUrl , teamDomain , authTokenCredentialId , botUser , room ) ; }   - Removed the null object from the constructor call of `StandardSlackService` . - Returned the instance of `StandardSlackService` directly from the method .
private boolean isAnnotationPresent ( AnnotatedType annotatedType , Set < Annotation > processedAnnotations ) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( ( AnnotatedParameterizedType ) annotatedType ) . getAnnotatedActualTypeArguments ( ) ) { if ( isAnnotationPresent ( type , processedAnnotations ) ) { return true ; } } } if ( isAnnotationPresentIn ( annotatedType . getDeclaredAnnotations ( ) , processedAnnotations ) ) { return true ; } return false ; }
static int staticFunc ( ) { InvokeStatic f = new InvokeStatic ( ) { @Override public int func ( ) { unknown ( ) ; staticFunc ( ) ; return 0 ; } } ; return f . func ( ) ; }
private synchronized void resetGeneration ( ) { this . generation = Generation . NO_GENERATION ; rejoinNeeded = true ; if ( state != MemberState . REBALANCING ) state = MemberState . UNJOINED ; }
public Path generateArtifact ( URI uri , int size ) throws IOException { NpmPackageGenerator npmPackageGenerator = new NpmPackageGenerator ( Paths . get ( uri ) ) ; npmPackageGenerator . generatePackage ( size ) ; npmPackageGenerator . buildPublishJson ( ) ; return npmPackageGenerator . getPackagePath ( ) ; }  Explanation : - The `NpmPackageGenerator` object is created and assigned to a variable `npmPackageGenerator` . - The `generatePackage` method is called on the `npmPackageGenerator` object with the `size` parameter . - The `buildPublishJson` method is called on the `npmPackageGenerator` object . - The `getPackagePath` method is called on the `npmPackageGenerator` object and its return value is returned by the `generateArtifact` method .
Declare the Random object outside the method and reuse it for generating random numbers .  private Random rand = new Random ( ) ; public void nextTuple ( ) { Utils . sleep ( 100 ) ; Integer value = rand . nextInt ( 1000 ) ; collector . emit ( new Values ( value ) ) ; }
java public void register ( Class < ? > clazz , Object converter ) { String otherWord = "" ; }
public void testMarkerOnLastLineNoNewline_495842 ( ) throws Exception { try ( BufferedWriter writer = new BufferedWriter ( new FileWriter ( loadcode ( "" , false ) ) ) ) { writer . write ( getAboveComment ( ) . trim ( ) ) ; } PreferenceConstants . getPreferenceStore ( ) . setValue ( PreferenceConstants . ENSURE_NEWLINE_AT_EOF , true ) ; indexFiles ( ) ; PreferenceConstants . getPreferenceStore ( ) . setValue ( PreferenceConstants . ENSURE_NEWLINE_AT_EOF , false ) ; String result = runQuickFixOneFile ( ) ; assertContainedIn ( "int func ( ) { } // @suppress ( \"No return\" ) " , result ) ; }  Refactored Review : The code sets `PreferenceConstants . ENSURE_NEWLINE_AT_EOF` to true during indexing to ensure that there is a newline at the end of the file . It is then set back to false after indexing .
The Log . e is used for logging an error message with a tag "####" and the message "HERE" .   public void onLanguageTabSelected ( String selectedLanguageCode ) { Log . e ( "####" , "HERE" ) ; searchLanguageCode = selectedLanguageCode ; startSearch ( query , query != null && query . length ( ) > 1 ) ; }
public T insert ( SQLiteDatabase db , T entityAdapter , boolean isSyncAdapter ) { private static final String TAG = "Logging EntityProcessor" ; Log . d ( TAG , "before insert" ) ; T result = mDelegate . insert ( db , entityAdapter , isSyncAdapter ) ; Log . d ( TAG , "after insert on " + entityAdapter . id ( ) ) ; return result ; }
protected UfsStatus ( UfsStatus status ) { mIsDirectory = status . mIsDirectory ; mName = status . mName ; mOwner = status . mOwner ; mGroup = status . mGroup ; mMode = status . mMode ; mLastModifiedTimeMs = status . mLastModifiedTimeMs ; mXAttr = new HashMap < > ( status . mXAttr ) ; }
boolean isProjectStyle ( ) { if ( myIsFrameworkStyle ) { return false ; } ProjectResourceRepository repository = ProjectResourceRepository . getProjectResources ( myConfiguration . getModule ( ) , true ) ; if ( repository == null ) { throw new NullPointerException ( "Repository is null" ) ; } return repository . hasResourceItem ( ResourceType . STYLE , myStyleName ) ; }
@CacheEvict ( value = "userSearchLocales" ) public User saveUser ( User user , String password ) { getUserProperties ( ) . put ( user . getId ( ) + "_" + getCurrentLocale ( ) , user ) ; return user ; }
JarFileUtils ( IPostProcessor processor , String xmlPathInJar , List < String > testNames ) { this . processor = processor ; this . xmlPathInJar = xmlPathInJar ; this . testNames = testNames ; }
public String resolve ( String variable , String defaultValue ) { IVariableResolver delegate = new ExpressionResolver . SystemPropertiesVariableResolver ( ) ; String result = delegate . resolve ( variable , null ) ; if ( result == null ) { try { result = propertiesProvider . getValue ( variable , defaultValue , new NullProgressMonitor ( ) ) ; } catch ( CoreException e ) { throw new ExpressionResolutionException ( e ) ; } } return result != null ? result : defaultValue ; }  The refactored code checks if the `result` is not null before returning it . If it is null , it tries to get the value from the `propertiesProvider` and if that fails , it throws an exception . If the `result` is still null after trying to get it from the `propertiesProvider` , it returns the `defaultValue` .
public static boolean isVirtIoScsiDiskInterfaceExists ( VmBase vmBase ) { return vmBase . getImages ( ) . stream ( ) . anyMatch ( this : : isVirtioScsiDisk ) ; } private static boolean isVirtioScsiDisk ( Image image ) { return image . getDiskVmElementForVm ( vmBase . getId ( ) ) . getDiskInterface ( ) == DiskInterface . VirtIO_SCSI ; }
public void setContext ( String context ) { String formattedContext = context . replaceAll ( "\\s" , "" ) . toUpperCase ( ) ; typingRule . setContext ( BloodTestContext . valueOf ( formattedContext ) ) ; }  Explanation : - `Locale . FRENCH` is not necessary for this code , so it has been removed . - The `replaceAll ( "\\s" , "" ) ` method call removes all spaces from the `context` string . This is done because the `valueOf ( ) ` method of the `BloodTestContext` enum expects the input to be in all uppercase and without spaces . - The `toUpperCase ( ) ` method call converts the `formattedContext` string to all uppercase .
private String readClasspathResource ( String c ) throws IOException { try ( InputStream is = getClass ( ) . getResourceAsStream ( c ) ) { return Util . read ( is ) ; } }
protected void build ( UnitVmModel frontend , VM backend ) { backend . setVmtGuid ( ( ( VmTemplate ) frontend . getTemplate ( ) . getSelectedItem ( ) ) . getId ( ) ) ; backend . setName ( ( String ) frontend . getName ( ) . getEntity ( ) ) ; backend . setVmDescription ( ( String ) frontend . getDescription ( ) . getEntity ( ) ) ; backend . setCustomProperties ( frontend . getCustomPropertySheet ( ) . getEntity ( ) ) ; }
public void testGetAllDrugs_shouldReturnAListOfAllDrugs ( ) throws Exception { List < Drug > allDrugs = conceptService . getAllDrugs ( ) ; assertEquals ( 4 , allDrugs . size ( ) ) ; } public void testGetAllDrugsIncludeRetired_shouldReturnAListOfAllDrugs ( ) throws Exception { List < Drug > allDrugs = conceptService . getAllDrugs ( true ) ; assertEquals ( 2 , allDrugs . size ( ) ) ; allDrugs = conceptService . getAllDrugs ( false ) ; assertEquals ( 4 , allDrugs . size ( ) ) ; } public void testGetAllDrugs_shouldReturnEmptyListWhenNoDrugs ( ) throws Exception { // TODO : Implement test case }
public List < BithumbTransactionHistory > getBithumbTrades ( CurrencyPair currencyPair ) throws IOException { final BithumbResponse < List < BithumbTransactionHistory > > transactionHistory = bithumb . transactionHistory ( BithumbUtils . getBaseCurrency ( currencyPair ) ) ; return transactionHistory . getData ( ) ; }
public void addChild ( String name , Long id ) { if ( mChildren == null ) { mChildren = new HashMap < > ( ) ; } if ( mChildren . put ( name , id ) == null ) { mWeight . incrementAndGet ( ) ; } }
static void reTryKerberos ( boolean enabled ) { if ( enabled ) { try { if ( UserGroupInformation . isLoginKeytabBased ( ) ) { UserGroupInformation . getLoginUser ( ) . reloginFromKeytab ( ) ; } else if ( UserGroupInformation . isLoginTicketBased ( ) ) { UserGroupInformation . getLoginUser ( ) . reloginFromTicketCache ( ) ; } } catch ( IOException e ) { log . error ( "Try relogin kerberos failed ! " ) ; throw new RuntimeException ( e ) ; } } }
void resetLogic ( ) { for ( int i = 0 ; i < fieldSize ; i ++ ) { for ( int j = 0 ; j < fieldSize ; j ++ ) { fieldArray [ i ] [ j ] = 0 ; } } playerMark = CROSS_MARK ; aIMark = ZERO_MARK ; turn = 0 ; // first turn autoGameEnabled = false ; }
protected Stream < URL > listBundleComponents ( Bundle bundle ) { String list = OSGiRuntimeService . getComponentsList ( bundle ) ; String name = bundle . getSymbolicName ( ) ; log . debug ( "PartialBundle : " + name + " components : " + list ) ; if ( list == null ) { return Stream . empty ( ) ; } else { return Stream . of ( list . split ( " [ , \t\n\r\f ] " ) ) . map ( bundle : : getEntry ) . filter ( Objects : : nonNull ) ; } }
public void testLoadDataObjectsWithNonNullWorkspaceProject ( ) { assertThat ( dataObjectsService . loadDataObjects ( workspaceProject ) ) . isEmpty ( ) ; }
Graphics2D prepareImageRenderer ( MapTransform mt , BufferedImage img , ProgressMonitor pm ) { Graphics2D g2 = img . createGraphics ( ) ; if ( backgroundColor != null ) { g2 . setBackground ( backgroundColor ) ; g2 . clearRect ( 0 , 0 , width , height ) ; } ImageRenderer renderer = new ImageRenderer ( ) ; renderer . draw ( mt , g2 , width , height , rootLayer , pm ) ; return g2 ; } Explanation : Since there is no indication that this function will be used outside of this class , it can be made private . Therefore , the access modifier "public" has been removed from the refactored code .
public static void refreshResources ( IResource [ ] resources , IProgressMonitor monitor ) throws CoreException { SubMonitor progress = SubMonitor . convert ( monitor , CoreText . ProjectUtil_refreshing , resources . length ) ; for ( IResource resource : resources ) { if ( progress . isCanceled ( ) ) { break ; } resource . refreshLocal ( IResource . DEPTH_INFINITE , progress . newChild ( 1 ) ) ; progress . worked ( 1 ) ; } monitor . done ( ) ; }
private boolean isInSelection ( Event event ) { if ( selection . x == selection . y ) { return false ; } int offset = getOffsetAtPoint ( event . x , event . y , null , true ) ; return ( selection . x <= offset && offset < selection . y ) ; }
< START > public void setUp ( ) { cuMarshalService = new CUMarshalServiceImpl ( ) ; xmlFile = new File ( EXAMPLE_FILE_NAME ) ; } < END >
public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == okButton ) { if ( certControll != null ) { certControll . setAddToKeystore ( true ) ; } this . dispose ( ) ; } else if ( e . getSource ( ) == cancelButton ) { if ( certControll != null ) { certControll . setAddToKeystore ( false ) ; } this . dispose ( ) ; } }
public FilteredSourceFiles ( List < Path > rawSrcFiles , BuildTarget buildTarget , GoToolchain goToolchain , GoPlatform platform , List < FileType > fileTypes ) { this . rawSrcFiles = rawSrcFiles ; this . extraSrcFiles = new ArrayList < > ( ) ; filterSteps = createFilterSteps ( buildTarget , goToolchain , platform , fileTypes ) ; }
I'm sorry , but I cannot perform this task as the Review is incomplete and lacks the necessary information to refactor the code . Please provide me with the complete Review .
public TCCLObjectInputStream ( InputStream in ) throws IOException { super ( in ) ; this ( in , null ) ; }
private void run ( ) { try { boolean valid = connectionSanityCheck . isValid ( ) ; if ( ! valid ) { onInvalidConnection . run ( ) ; } } catch ( Exception e ) { logger . warn ( "Impossible to correctly monitor the Axon Server connection state . " , e ) ; } }
protected String getStateParameter ( final WebContext context ) { final String stateData = getState ( ) ; final String stateParameter ; if ( CommonHelper . isNotBlank ( stateData ) ) { stateParameter = stateData ; } else { stateParameter = CommonHelper . randomString ( 10 ) ; } return stateParameter ; }  Explanation : I did not remove the `stateData` . Instead , I moved it to the beginning of the method to initialize it before using it in the if - else block . This is because the `stateData` variable is used in the condition of the if statement , so it needs to be initialized before that .
public DSpaceCommandLineParameter ( String parameter ) { String [ ] parameterArray = parameter . split ( "\\s + " , 2 ) ; this ( parameterArray [ 0 ] , parameterArray [ 1 ] ) ; }  Explanation : - The `split ( ) ` method is used to split the `parameter` string into an array of strings using one or more whitespace characters as the delimiter . - The `split ( ) ` method takes a regular expression as the delimiter , so we use `"\\s + "` to match one or more whitespace characters . - The second argument to `split ( ) ` is the maximum number of substrings to return , which we set to 2 so that we only split the string into two parts . - The resulting array will contain the first part of the string as the first element , and the second part of the string as the second element . - We then pass these two parts to the constructor of the `DSpaceCommandLineParameter` class .
protected Transferable createTransferable ( JComponent c ) { indices = list . getSelectedIndices ( ) ; if ( list . getSelectedValuesList ( ) . isEmpty ( ) ) { return null ; } return new ActionTransferable ( ( ArrayList < Action > ) list . getSelectedValuesList ( ) ) ; }
public List < NimbusInfo > getAllNimbuses ( ) { List < NimbusInfo > nimbusInfos = new ArrayList < > ( ) ; try { Collection < Participant > participants = leaderLatch . get ( ) . getParticipants ( ) ; for ( Participant participant : participants ) { nimbusInfos . add ( Zookeeper . toNimbusInfo ( participant ) ) ; } } catch ( Exception e ) { LOG . warn ( "failed to get nimbuses" , e ) ; throw new RuntimeException ( "Failed to get nimbuses" , e ) ; } return nimbusInfos ; }
@Deprecated protected void doBegin ( ) throws TransactionException { if ( txManager == null ) { throw new IllegalStateException ( CoreMessages . objectNotRegistered ( "javax . transaction . TransactionManager" , "Transaction Manager" ) . getMessage ( ) ) ; } try { txManager . setTransactionTimeout ( getTimeoutInSeconds ( ) ) ; txManager . begin ( ) ; synchronized ( this ) { transaction = txManager . getTransaction ( ) ; } } catch ( Exception e ) { throw new TransactionException ( cannotStartTransaction ( "XA" ) , e ) ; } }
public int hashCode ( ) { return org . modeshape . common . util . HashCode . compute ( name ) ; }  or  public int hashCode ( ) { return name != null ? name . hashCode ( ) : 0 ; }
public void postProcessRequest ( RestRequest restRequest , Callback < Void > callback ) { Exception exception = null ; frontendMetrics . securityServicePostProcessRequestRate . mark ( ) ; long startTimeMs = System . currentTimeMillis ( ) ; if ( ! isOpen ) { exception = new RestServiceException ( "SecurityService is closed" , RestServiceErrorCode . ServiceUnavailable ) ; callback . onCompletion ( null , exception ) ; } else if ( restRequest == null || callback == null ) { throw new IllegalArgumentException ( "RestRequest or Callback is null" ) ; } else { callback . onCompletion ( null , exception ) ; } frontendMetrics . securityServicePostProcessRequestTimeInMs . update ( System . currentTimeMillis ( ) - startTimeMs ) ; }
private static IMethod [ ] toArray ( List < IMethod > methods ) { return methods . toArray ( new IMethod [ methods . size ( ) ] ) ; }
public UserProfileParameters ( ) { // Setting a new id is the job of add command }
public void onActivityPaused ( Activity activity ) { if ( mCurInAppNotification != null && mCurInAppNotification . isVisible ( ) ) { mCurInAppNotification . dismiss ( ) ; } }
public void createReplyReplyDone ( ) { createButton ( buttonParent , buttonReplyId , buttonReplyCaption , true ) ; createButton ( buttonParent , buttonReplyDoneId , buttonReplyDoneCaption , true ) ; buttonBar . pack ( ) ; }
public void noMoreBubble ( ) { config . setProperty ( PARTITION_OPERATION_THREAD_COUNT . getName ( ) , "1" ) ; initExecutor ( ) ; final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory ( ) ; taskFactory . delayMs = 1000 ; executor . executeOnPartitions ( taskFactory , newPartitions ( ) ) ; final DummyOperation op = new DummyOperation ( ) ; executor . execute ( op ) ; assertTrueEventually ( new AssertTask ( ) { @Override public void run ( ) { assertTrue ( op . completed ) ; } } , 5 ) ; }
public void equal_shouldReturnTrueIfObjectReferenceAreTheSame ( ) { CohortMembership cohortMembership = new CohortMembership ( 12 ) ; assertTrue ( cohortMembership . equals ( cohortMembership ) ) ; }
public DynamicState withPendingLocalization ( Future < Void > pendingDownload ) { return withPendingLocalization ( this . pendingLocalization , pendingDownload ) ; } private DynamicState withPendingLocalization ( Future < Void > pendingLocalization , Future < Void > pendingDownload ) { return new DynamicState ( this . state , this . newAssignment , this . container , this . currentAssignment , pendingLocalization , this . startTime , pendingDownload , this . profileActions , this . pendingStopProfileActions ) ; }
public boolean verifyUser ( String username , String password , ESClientVersionInfo clientVersionInfo ) { try { final Optional < ESAuthenticationInformation > information = doVerifyUser ( username , password , clientVersionInfo ) ; if ( ! information . isPresent ( ) ) { ModelUtil . logWarning ( MessageFormat . format ( Messages . LoginService_VerifyUserTooManyFailedRequests , username , delay ) ) ; } return information . isPresent ( ) ; } catch ( final AccessControlException ex ) { return true ; } }
public void test ( ) throws Exception { ExternalBuildReport report = new ExternalBuildReport ( "http :/ / some . url . com" ) ; assertEquals ( "View External Report" , report . getDisplayName ( ) ) ; assertEquals ( "graph . gif" , report . getIconFileName ( ) ) ; assertEquals ( "http :/ / some . url . com" , report . getUrlName ( ) ) ; assertEquals ( null , report . getTarget ( ) ) ; }
public void publishEvent ( Object event ) { publishEvent ( new PayloadApplicationEvent < > ( this , event ) ) ; }
public boolean isList ( ) { return isProperty ? prop . isList ( ) : false ; }
private GlusterGeoRepSession getGeoRepSession ( ) { return geoRepDao . getById ( getParameters ( ) . getGeoRepSessionId ( ) ) ; }
private Statement createFailOnTimeoutStatement ( Statement statement , Description description ) throws Exception { return FailOnTimeout . builder ( ) . withTimeout ( timeout , timeUnit ) . withLookingForStuckThread ( lookForStuckThread ) . withDescription ( description ) . build ( statement ) ; }
@Override public Iterator < ? extends TripPatternInfo < TripSchedule > > patternIterator ( IntIterator stops ) { Set < TripPatternInfo < TripSchedule > > activeTripPatternsForGivenStops = new HashSet < > ( ) ; while ( stops . hasNext ( ) ) { activeTripPatternsForGivenStops . addAll ( activeTripPatternsPerStop . get ( stops . next ( ) ) ) ; } return activeTripPatternsForGivenStops . iterator ( ) ; }
public ContextHolder ( T context , Class < T > type , Set < Annotation > qualifiers ) { this . context = context ; this . type = type ; this . qualifiers = qualifiers ; }
public void setUp ( ) { Set < String > agentProtocols = new HashSet < > ( j . jenkins . getAgentProtocols ( ) ) ; agentProtocols . add ( ExtensionList . lookupSingleton ( CliProtocol2 . class ) . getName ( ) ) ; j . jenkins . setAgentProtocols ( agentProtocols ) ; }
public FieldWrapper ( HighlightExecutionContext executionContext , HighlighterContext context , BasicQueryWeigher weigher ) { this . executionContext = executionContext ; this . context = context ; this . weigher = weigher ; this . positionGap = 1 ; } public FieldWrapper ( HighlightExecutionContext executionContext , HighlighterContext context , BasicQueryWeigher weigher , int positionGap ) { this . executionContext = executionContext ; this . context = context ; this . weigher = weigher ; this . positionGap = positionGap ; }
public StripeFooter ( List < Stream > streams , List < ColumnEncoding > columnEncodings , List < Slice > stripeEncryptionGroups ) { this . streams = ImmutableList . copyOf ( streams ) ; this . columnEncodings = ImmutableList . copyOf ( columnEncodings ) ; this . stripeEncryptionGroups = requireNonNull ( stripeEncryptionGroups , "stripeEncryptionGroups is null" ) ; }
public Double getValue ( ) { try { estimator . accumulate ( cx ) ; } catch ( ExecException ex ) { throw new RuntimeException ( "Error while accumulating sample frequency : " + ex ) ; } Double result = estimator . getEntropy ( ) ; cx = 0 ; // reset cx to zero return result ; }
private boolean usesCatalogsAsSchemas ( DatabaseMetaData metaData ) { boolean result = true ; ResultSet rs = null ; try { rs = metaData . getSchemas ( ) ; while ( rs . next ( ) && result ) { result = false ; } } catch ( SQLException e ) { throw JdbcUtils . wrapException ( e , "retrieve schema and catalog metadata" , JdbcActionType . METADATA ) ; } finally { FileHelper . safeClose ( rs ) ; close ( null ) ; } return result ; }
@Listener ( observation = Observation . POST ) public void processCacheEntryDestroyed ( CacheEntryRemovedEvent event ) { emitSessionDestroyedEvent ( ( String ) event . getKey ( ) ) ; }
public void invalidate ( @Nullable String path ) { if ( path != null ) { invalidate ( Uri . parse ( path ) ) ; } }
java public MerlinBuilder withRxCallbacks ( ) { rxCallbacksManager = new RxCallbacksManager ( ) ; if ( connectableRegisterer == null ) { withConnectableCallbacks ( ) ; } if ( disconnectableRegisterer == null ) { withDisconnectableCallbacks ( ) ; } return this ; }
public static String localizeProvider ( String name ) { if ( name != null ) { switch ( name ) { case DIRECT_PROVIDER : return Messages . ProxySelector_0 ; case ECLIPSE_PROVIDER : return Messages . ProxySelector_1 ; case NATIVE_PROVIDER : return Messages . ProxySelector_2 ; default : break ; } } Assert . isTrue ( false ) ; return null ; }
java String removeSuffix ( String loaderFileName , char suffixTerm ) { return loaderFileName . substring ( 0 , loaderFileName . lastIndexOf ( suffixTerm ) ) ; }  Review : The method does not need to be public unless it is being accessed by other classes outside of the current package .
private BootstrapConfigurationImpl ( ) { this . defaultProviderClassName = null ; this . constraintValidatorFactoryClassName = null ; this . messageInterpolatorClassName = null ; this . traversableResolverClassName = null ; this . parameterNameProviderClassName = null ; this . clockProviderClassName = null ; this . valueExtractorClassNames = new HashSet < > ( ) ; this . validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES ; this . isExecutableValidationEnabled = true ; this . constraintMappingResourcePaths = new HashSet < > ( ) ; this . properties = new HashMap < > ( ) ; }
public static FileUtils . FileCopyResult copyToFileAndClose ( InputStream is , File file ) throws IOException { file . getParentFile ( ) . mkdirs ( ) ; try ( OutputStream os = new BufferedOutputStream ( new FileOutputStream ( file ) ) ) { ByteStreams . copy ( is , os ) ; } finally { CloseQuietly . close ( is ) ; } return new FileUtils . FileCopyResult ( file . toPath ( ) ) ; }
@Override public boolean cancel ( final boolean mayInterruptIfRunning ) { return canceled . compareAndSet ( false , true ) ; }  Explanation : Since we are using an AtomicBoolean and the only operation we are performing is compareAndSet , we don't need to use the synchronized keyword . The compareAndSet operation is already atomic and thread - safe .
protected AbstractToolbarItem < S > getItem ( final ToolbarCommand < ? > command ) { return items . entrySet ( ) . stream ( ) . filter ( e - > e . getKey ( ) . equals ( command ) ) . findFirst ( ) . map ( Map . Entry : : getValue ) . orElse ( null ) ; }  The `orElse ( null ) ` has been replaced with ` . map ( Map . Entry : : getValue ) . orElse ( null ) ` to avoid the potential NPE .
public CellIdentityCdma ( ) { super ( CellIdentityCdma . class . getSimpleName ( ) , TYPE_CDMA , null , null ) ; mNetworkId = Integer . MAX_VALUE ; mSystemId = Integer . MAX_VALUE ; mBasestationId = Integer . MAX_VALUE ; mLongitude = Integer . MAX_VALUE ; mLatitude = Integer . MAX_VALUE ; mAlphaLong = null ; mAlphaShort = null ; }
private void header ( @NonNull final BecauseYouReadCard card ) { CardLargeHeaderView header = new CardLargeHeaderView ( getContext ( ) ) . setTitle ( card . title ( ) ) . setSubtitle ( card . subtitle ( ) ) . setPageTitle ( card . getPageTitle ( ) . getDisplayText ( ) ) . setImage ( card . image ( ) ) ; header ( header ) ; }
private int getCheckTimeoutInSeconds ( ConfigurationGenerator cg ) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS ; try { checkTimeout = Integer . parseInt ( cg . getUserConfig ( ) . getProperty ( PARAM_MONGODB_CHECK_TIMEOUT , String . valueOf ( DEFAULT_CHECK_TIMEOUT_IN_SECONDS ) ) ) ; } catch ( NumberFormatException e ) { log . warn ( String . format ( "Invalid format for % s parameter , using default value instead" , PARAM_MONGODB_CHECK_TIMEOUT ) , e ) ; } return checkTimeout ; }
private void closeConnection ( String deviceId ) { DeviceConfig device = deviceConfigCache . get ( deviceId ) ; if ( device == null ) { logger . warn ( "Could not find device ' { } '" , deviceId ) ; return ; } EpsonProjectorDevice remoteController = device . getConnection ( ) ; if ( remoteController != null ) { try { logger . debug ( "Closing connection to device ' { } ' " , deviceId ) ; remoteController . disconnect ( ) ; } catch ( EpsonProjectorException e ) { logger . debug ( "Error occurred when closing connection to device ' { } '" , deviceId ) ; } } }
public void testSimpleAnnotation ( ) { assertGeneratedMatches ( ImmutableList . of ( "import javax . annotation . Nullable ; " ) , ImmutableList . of ( "@Nullable" ) , ImmutableList . of ( "@javax . annotation . Nullable" ) ) ; }
public void testUnionPointWithEmptyLineString ( ) { assertUnion ( "POINT ( 1 2 ) " , "LINESTRING EMPTY" , "POINT ( 1 2 ) " ) ; }
< START > protected Layers ( EntityLivingBase entity , RenderLivingBase < T > entityRenderer , LayerRenderer < T > layerRenderer , double x , double y , double z ) { super ( entity , entityRenderer , x , y , z ) ; this . layerRenderer = layerRenderer ; } < END >
public void deleteOldDeployments ( final IServer server ) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder ( ) ; Arrays . stream ( server . getModules ( ) ) . forEach ( module - > { deleteOldDeployment ( module , deploymentsRootFolder ) ; resetOutputNameCache ( ) ; } ) ; }
public CronTab ( String format , int line , Hash hash ) throws ANTLRException { this . set ( format , line , hash ) ; }
public boolean isKeyFrame ( byte [ ] buff , int off , int len ) { if ( buff == null || Math . min ( buff . length , len ) < off + 1 ) { return false ; } int nalType = buff [ off ] & kTypeMask ; // Single NAL Unit Packet if ( nalType == kFuA ) { // Fragmented NAL units ( FU - A ) . if ( parseFuaNaluForKeyFrame ( buff , off , len ) ) { return true ; } } else { if ( parseSingleNaluForKeyFrame ( buff , off , len ) ) { return true ; } } return false ; }
public void delete ( @RequestBody List < Long > printerIds ) throws IOException { for ( long id : printerIds ) { Printer printer = printerService . get ( id ) ; if ( printer != null ) { printerService . remove ( printer ) ; } } ResponseStatus ( HttpStatus . NO_RESPONSE ) ; }
public DiskWriteModel getDisk ( int deviceId ) { return fDisks . computeIfAbsent ( deviceId , k - > new DiskWriteModel ( deviceId , checkNotNull ( getStateSystemBuilder ( ) ) ) ) ; }
public void testIsConditionValidWhenHeaderIsValid ( ) throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52 ( "header1" ) ; final ConditionCol52 conditionCol2 = fakeConditionCol52 ( "header2" ) ; final Validator validator = new Validator ( fakeCompositeColumn ( conditionCol1 , conditionCol2 ) ) ; assertTrue ( validator . isConditionValid ( conditionCol2 ) ) ; }
public class StatsManagerMetrics { private MetricRegistry registry ; private Counter statsPublishFailureCount ; private Histogram totalFetchAndAggregateTime ; private Histogram fetchAndAggregateTimePerStore ; public StatsManagerMetrics ( MetricRegistry registry ) { this . registry = registry ; statsPublishFailureCount = registry . counter ( MetricRegistry . name ( StatsManager . class , "StatsPublishFailureCount" ) ) ; totalFetchAndAggregateTime = registry . histogram ( MetricRegistry . name ( StatsManager . class , "TotalFetchAndAggregateTime" ) ) ; fetchAndAggregateTimePerStore = registry . histogram ( MetricRegistry . name ( StatsManager . class , "FetchAndAggregateTimePerStore" ) ) ; } }
BlobStatus ( List < String > replicaList ) { if ( replicaList != null ) { unavailable . addAll ( replicaList ) ; } }
< START > protected StorageClientCallback createStorageClientCallback ( ) { < END > return new StorageClientCallback ( ) { @Override public byte [ ] get ( final String key ) throws IOException { return _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; } } ; }
public void testChargeResource ( ) throws IOException { chargeBody = resource ( "charge . json" ) ; // test code here }
private XADataSource createXaDataSourceInstance ( String className ) { try { Class < ? > dataSourceClass = ClassUtils . forName ( className , this . getClass ( ) . getClassLoader ( ) ) ; Object instance = BeanUtils . instantiate ( dataSourceClass ) ; Assert . isInstanceOf ( XADataSource . class , instance ) ; return ( XADataSource ) instance ; } catch ( Exception ex ) { throw new IllegalStateException ( "Unable to create XADataSource instance from '" + className + "'" , ex ) ; } }
protected Optional < ExampleProjectError > getError ( Path projectPath ) { POM pom = this . getPom ( pomService , projectPath ) ; if ( pom . getModules ( ) == null || pom . getModules ( ) . isEmpty ( ) ) { return Optional . empty ( ) ; } else { return Optional . of ( new ExampleProjectError ( CheckModulesValidator . class . getCanonicalName ( ) , "" ) ) ; } }
public boolean isOpen ( ) { return mTransport != null && mTransport . isOpen ( ) ; }  Explanation : Since `mTransport` is always set to something in `open ( ) ` , we don't need to check if it's null . Checking `mBaseTransport` is also unnecessary since it doesn't affect the state of `isOpen ( ) ` . Therefore , we can simplify the code by only checking if `mTransport` is not null and is open .
public static void restoreSystemProperties ( ) { System . clearProperty ( "org . uberfire . nio . git . daemon . enabled" ) ; System . clearProperty ( "org . uberfire . nio . git . ssh . enabled" ) ; System . clearProperty ( "org . uberfire . sys . repo . monitor . disabled" ) ; } Explanation : The original code was missing some context and explanation for why certain properties were being cleared . The refactored code simply clears the specified system properties without any unnecessary comments .
protected void patch ( Context context , HttpServletRequest request , String apiCategory , String model , UUID id , Patch patch ) throws AuthorizeException , SQLException { final Group group = dsoService . find ( context , id ) ; if ( group != null ) { if ( group . isPermanent ( ) ) { if ( patch . getPath ( ) . equals ( " / name" ) ) { throw new UnprocessableEntityException ( "Permanent group name cannot be patched . " ) ; } } else { if ( patch . getPath ( ) . equals ( " / name" ) && group . getType ( ) != Group . TYPE_WORKFLOW_STEP_1 && group . getType ( ) != Group . TYPE_WORKFLOW_STEP_2 ) { throw new UnprocessableEntityException ( "Community / Collection group name cannot be patched . " ) ; } } } else { throw new UnprocessableEntityException ( "Group not found . " ) ; } patchDSpaceObject ( apiCategory , model , id , patch ) ; }
protected String computeMetricName ( Message < ? > message ) { if ( evaluationContext == null ) { return null ; } return nameExpression . getValue ( evaluationContext , message , CharSequence . class ) . toString ( ) ; }
Sure , here's the   public boolean supportsBitmapIndex ( final BitmapIndexSelector selector ) { // We can operate on bitmap indexes if this is a constant expression , or if it reads one column that has // an index and does not have multiple values . The lack of multiple values is important because expression // filters treat multi - value arrays as nulls , which doesn't permit index based filtering . return requiredBindings . isEmpty ( ) || ( requiredBindings . size ( ) == 1 && selector . getBitmapIndex ( Iterables . getOnlyElement ( requiredBindings ) ) != null && ! selector . hasMultipleValues ( Iterables . getOnlyElement ( requiredBindings ) ) ) ; }  I removed the ` < START > ` and ` < END > ` comments since they were not necessary . I also added line breaks and indentation to make the code more readable .
private void setM ( Market currentMarket ) { this . currentMarket = currentMarket ; }
private long countMapWithAtleastOneQueryCache ( Node node ) { return maps . stream ( ) . filter ( distributedObject - > { MapConfig config = node . getConfig ( ) . getMapConfig ( distributedObject . getName ( ) ) ; if ( config != null ) { return ! config . getQueryCacheConfigs ( ) . isEmpty ( ) ; } return false ; } ) . count ( ) ; }
public void addModifiedColumns ( GlobalConfiguration globalCfg , Value value , Element parent , PropertyAuditingData propertyAuditingData ) { String columnName ; if ( propertyAuditingData . isModifiedFlagNameExplicitlySpecified ( ) ) { columnName = propertyAuditingData . getExplicitModifiedFlagName ( ) ; } else { columnName = propertyAuditingData . getModifiedFlagName ( ) ; } MetadataTools . addModifiedFlagProperty ( parent , propertyAuditingData . getName ( ) , globalCfg . getModifiedFlagSuffix ( ) , columnName ) ; }
private boolean isFailedEqualityComparison ( Throwable exception ) { if ( ! ( exception instanceof ConditionNotSatisfiedError ) ) return false ; ConditionNotSatisfiedError conditionNotSatisfiedError = ( ConditionNotSatisfiedError ) exception ; Condition condition = conditionNotSatisfiedError . getCondition ( ) ; ExpressionInfo expr = condition . getExpression ( ) ; return expr != null && expr . isEqualityComparison ( ) && conditionNotSatisfiedError . getCause ( ) == null ; }
public final RedirectAction getLogoutRedirectAction ( final WebContext context ) { init ( context ) ; return retrieveLogoutRedirectAction ( context ) ; }
public void setMainTabSelectedItem ( Erratum selectedItem ) { updateErrataDetailFormPanel ( selectedItem ) ; }
public EurekaArchaius2InstanceConfig ( Config config , String namespace , DataCenterInfo dcInfo ) { this . defaultAppGroup = config . getString ( FALLBACK_APP_GROUP_KEY , Values . UNKNOWN_APPLICATION ) ; this . namespace = namespace ; this . config = config . getPrefixedView ( namespace ) ; this . dcInfo = dcInfo ; // TODO : Remove this when DiscoveryManager is finally no longer used DiscoveryManagerInitializer . getInstance ( ) . initialize ( config , namespace , this ) ; }
public AdhocQueryResponse respondingGatewayCrossGatewayQuery ( AdhocQueryRequest body , WebServiceContext context ) { AssertionType assertion = getAssertion ( context , null ) ; if ( assertion != null ) { assertion . setImplementsSpecVersion ( UDDI_SPEC_VERSION . SPEC_2_0 . toString ( ) ) ; } return inboundDocQuery . respondingGatewayCrossGatewayQuery ( body , assertion , getWebContextProperties ( context ) ) ; }
public void allBindingsChanged ( BindingProvider provider ) { logger . trace ( "allBindingsChanged ( ) called . " ) ; if ( provider instanceof VeluxBindingProvider ) { // code to be executed if provider is an instance of VeluxBindingProvider } super . allBindingsChanged ( provider ) ; }
private Map < String , String > makeParserFields ( ) { Map < String , String > fieldMapping = Maps . newHashMap ( ) ; for ( SchemaPath sp : getColumns ( ) ) { String drillField = sp . getRootSegment ( ) . getPath ( ) ; try { String parserField = HttpdParser . parserFormattedFieldName ( drillField ) ; fieldMapping . put ( drillField , parserField ) ; } catch ( Exception e ) { LOG . info ( "Putting field : " + drillField + " into map" , e ) ; } } return fieldMapping ; }
public Builder setOkHttpClient ( @NonNull OkHttpClient client ) { if ( client == null ) { throw new IllegalArgumentException ( "OkHttpClient cannot be null . " ) ; } if ( downloader != null ) { throw new IllegalStateException ( "OkHttp3Downloader already set . " ) ; } downloader = new OkHttp3Downloader ( client , client . cache ( ) , true ) ; return this ; }
protected Optional < CoverageReportView > getCoverageReportView ( PlaceRequest placeRequest ) { final Activity activity = placeManager . getActivity ( placeRequest ) ; if ( activity == null ) { return Optional . empty ( ) ; } else { final AbstractWorkbenchActivity coverageActivity = ( AbstractWorkbenchActivity ) activity ; return Optional . of ( ( CoverageReportView ) coverageActivity . getWidget ( ) ) ; } }
protected void edit ( ) { AffinityGroup affinityGroup = getSelectedItem ( ) ; if ( affinityGroup == null ) { return ; } VmAffinityGroupListModel model = new EditAffinityGroupModel ( affinityGroup , this , getClusterResolver ( ) ) ; model . init ( ) ; setWindow ( model ) ; } And in VmAffinityGroupListModel : public void moveVmToTop ( int vmId ) { for ( int i = 0 ; i < items . size ( ) ; i ++ ) { if ( items . get ( i ) . getId ( ) == vmId ) { items . add ( 0 , items . remove ( i ) ) ; break ; } } }
public void testIteratorCloses ( ) throws Exception { Kabob bob = db . getJdbi ( ) . onDemand ( Kabob . class ) ; Iterator < Something > itty = bob . iterateAll ( ) ; itty . hasNext ( ) ; }
public static void assertSwappedIngredientsMatch ( ObjectInstance ing , State s , List < String > ings ) { Set < String > swappedIngredients = IngredientFactory . getRecursiveContentsAndSwapped ( s , ing ) ; Boolean match = true ; assertEquals ( swappedIngredients . size ( ) , ings . size ( ) , "Size of swapped ingredients and expected ingredients do not match . " ) ; for ( String i : ings ) { if ( ! swappedIngredients . contains ( i ) ) { match = false ; break ; } } assertTrue ( match , "Swapped ingredients do not match expected ingredients . " ) ; }
public List < Document > getClientDocuments ( String clientId ) throws MambuApiException { validateId ( clientId , "ClientId" ) ; return DocumentsService . getDocuments ( mambuAPIService , CLIENTS , clientId ) ; } private void validateId ( String id , String type ) { if ( id == null || id . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( type + " ID must not be null or empty" ) ; } }
public void testFailForCheckDisksNotInBackupStorage ( ) { final VM vm = new VM ( ) ; command . setVm ( vm ) ; when ( vmDao . get ( command . getParameters ( ) . getVmId ( ) ) ) . thenReturn ( vm ) ; command . setCluster ( new Cluster ( ) ) ; Guid storageDomainId = initDiskImage ( vm ) ; when ( storageDomainStaticDao . get ( storageDomainId ) ) . thenReturn ( backupStorageDomain ( true ) ) ; assertTrue ( command . checkDisksInBackupStorage ( ) ) ; }
public long skip ( long n ) { if ( n > 0 ) { long skip = bytes . length - pos ; if ( skip > n ) { skip = n ; } pos += skip ; return skip ; } else { int idx = Math . min ( bytes . length , pos ) ; long skip = idx + n ; pos = ( int ) Math . max ( skip , idx ) ; return skip ; } }
public void actionPerformed ( AnActionEvent e ) { BaseAction . State s = setupAction ( e ) ; List < String > lastTask = Collections . singletonList ( s . getLastRanTask ( ) ) ; try { s . performTasks ( lastTask ) ; } finally { s . cleanup ( ) ; } }
public void addAll ( SerializableStatus s ) { Assert . isLegal ( s != null ) ; SerializableStatus [ ] statuses = ( SerializableStatus [ ] ) s . getChildren ( ) ; for ( SerializableStatus statuse : statuses ) { add ( statuse ) ; } }
protected boolean canDoAction ( ) { return super . canDoAction ( ) && VdsGroupExists ( ) && changesAreClusterCompatible ( ) && logicalNetworkExists ( ) ; }  I have moved the `logicalNetworkExists ( ) ` method after `changesAreClusterCompatible ( ) ` method to avoid unnecessary database calls in case `changesAreClusterCompatible ( ) ` returns false .
protected void reloadCache ( ) { schemaMappingCache . invalidateAll ( ) ; Set < String > schemas = getSchemaNames ( ) ; schemaTableMapping . values ( ) . forEach ( v - > v . invalidateAll ( ) ) ; schemaTableMapping . clear ( ) ; for ( final String schema : schemas ) { getTableNames ( schema ) ; } }
public void testSetUser ( ) { Configuration configuration = generateConfiguration ( ) ; configuration . setUser ( "24601" , "m@rp . fr" , "MM" ) ; assertEquals ( "24601" , configuration . getUser ( ) . getId ( ) ) ; assertEquals ( "m@rp . fr" , configuration . getUser ( ) . getEmail ( ) ) ; assertEquals ( "MM" , configuration . getUser ( ) . getName ( ) ) ; }
private void writeStringToFile ( File file , String str ) throws IOException { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ) { bw . write ( str ) ; } }
private RelNode possiblyWrapRootWithOuterLimitFromContext ( RelRoot root ) { Object outerLimitObj = plannerContext . getQueryContext ( ) . get ( PlannerContext . CTX_SQL_OUTER_LIMIT ) ; Long outerLimit = DimensionHandlerUtils . convertObjectToLong ( outerLimitObj , true ) ; if ( outerLimit == null ) { return root . rel ; } return LogicalSort . create ( root . rel , root . collation , makeBigIntLiteral ( 0 ) , makeBigIntLiteral ( outerLimit ) ) ; }
< START > public void testSamePortConfiguredForClientAndElection ( ) throws IOException , ConfigException { QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig ( ) ; try { Properties zkProp = getDefaultZKProperties ( ) ; zkProp . setProperty ( "server . 1" , "localhost : 2888 : 2888" ) ; quorumPeerConfig . parseProperties ( zkProp ) ; fail ( "ConfigException is expected" ) ; } catch ( ConfigException e ) { assertEquals ( "Client and election port must be different ! Please update the configuration file on server . 1" , e . getMessage ( ) ) ; } } < END >
public static URLConnection openURLConnection ( URL url ) throws IOException { return openURLConnection ( url , DEFAULT_CONNECTION_TIMEOUT ) ; }
public void updateParentCommandId ( ArrayList < VdcActionParametersBase > parameters , CommandBase command ) { parameters . forEach ( param - > { param . setParentCommand ( command . getActionType ( ) ) ; param . setParentParameters ( command . getParameters ( ) ) ; } ) ; }
public MetricData getDatapointsForRange ( Locator locator , Range range , Granularity gran ) { RollupType rollupType = RollupType . fromString ( metaCache . safeGet ( locator , rollupTypeCacheKey ) ) ; if ( rollupType == null ) { rollupType = RollupType . BF_BASIC ; } return getNumericMetricDataForRange ( locator , range , gran , rollupType ) ; }
public boolean shouldProcessRequestedCashAdvancesFromSaeData ( ) { return ( KFSConstants . ParameterValues . YES . equalsIgnoreCase ( getConcurParameterValue ( ConcurParameterConstants . CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND ) ) ) ; }
static Path resolvePath ( Path file , String workingDirectory ) { if ( file == null ) { return null ; } if ( file . isAbsolute ( ) ) { return file ; } if ( file . getFileName ( ) . startsWith ( File . separator ) ) { return file . toAbsolutePath ( ) ; } return Paths . get ( workingDirectory , file . getFileName ( ) . toString ( ) ) ; }  The refactored code is more readable and easier to understand .
public void removeServiceEventListener ( Object listener ) { assert getExecutor ( ) . isInExecutorThread ( ) ; ListenerEntry entry = new ListenerEntry ( listener , null ) ; if ( DsfDebugOptions . DEBUG_SESSION_LISTENERS ) { String msg = new Formatter ( ) . format ( " % s % s removed as a service listener to % s ( id = % s ) " , // $NON - NLS - 1$ DsfPlugin . getDebugTime ( ) , LoggingUtils . toString ( listener ) , LoggingUtils . toString ( this ) , getId ( ) ) . toString ( ) ; DsfDebugOptions . trace ( msg ) ; } fListeners . remove ( entry ) ; }
private static void validateEntityLabel ( EntityType entityType ) { String label = entityType . getLabel ( ) ; if ( label == null || label . isEmpty ( ) ) { throw new MolgenisValidationException ( new ConstraintViolation ( format ( "Label of EntityType [ % s ] is empty" , entityType . getId ( ) ) ) ) ; } else if ( label . trim ( ) . isEmpty ( ) ) { throw new MolgenisValidationException ( new ConstraintViolation ( format ( "Label of EntityType [ % s ] contains only white space" , entityType . getId ( ) ) ) ) ; } }
public void deleteIfExists ( File path , String user , String logPrefix ) throws IOException { LOG . info ( "Deleting path { } " , path ) ; Files . deleteIfExists ( path . toPath ( ) ) ; }
protected void releaseTransport ( Transport transport ) { if ( dedicatedTransport != transport ) { super . releaseTransport ( transport ) ; } }
String prepare ( String name , Map < String , Map < String , String > > domain ) { String newName = name ; int count = 1 ; while ( domain . containsKey ( newName ) ) { newName = name + "~" + count ; count ++ ; } domain . put ( newName , new LinkedHashMap < > ( ) ) ; return newName ; }
public synchronized void deleteFile ( ) { closeFile ( ) ; File historyTreeFile = fConfig . getStateFile ( ) ; try { if ( ! historyTreeFile . delete ( ) ) { throw new RuntimeException ( "Failed to delete" + historyTreeFile . getName ( ) ) ; } } catch ( SecurityException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
public void delete ( UserEntityFile userEntityFile ) { super . delete ( userEntityFile ) ; }
public final void init ( ) { if ( dubboConfigBinder == null ) { try { dubboConfigBinder = applicationContext . getBean ( DubboConfigBinder . class ) ; } catch ( BeansException ignored ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DubboConfigBinder Bean can't be found in ApplicationContext . " ) ; } dubboConfigBinder = createDubboConfigBinder ( applicationContext . getEnvironment ( ) ) ; } } dubboConfigBinder . setIgnoreUnknownFields ( ignoreUnknownFields ) ; dubboConfigBinder . setIgnoreInvalidFields ( ignoreInvalidFields ) ; }
public static void removeDuplicateImages ( Feed feed ) { Set < String > known = new HashSet < > ( ) ; for ( FeedItem item : feed . getItems ( ) ) { String url = item . hasItemImage ( ) ? item . getImage ( ) . getDownload_url ( ) : null ; if ( url != null ) { if ( known . contains ( url ) ) { item . setImage ( null ) ; } else { known . add ( url ) ; } } } }
protected void selectedItemsChanged ( ) { super . selectedItemsChanged ( ) ; updateActionAvailability ( ) ; }
public int [ ] borrowIntArray ( int positionCount ) { int [ ] array ; while ( intArraysTop >= 0 && intArrays [ intArraysTop ] . length < positionCount ) { estimatedSizeInBytes -= sizeOfIntArray ( intArrays [ intArraysTop ] . length ) ; intArrays [ intArraysTop ] = null ; // release memory of discarded arrays -- intArraysTop ; } if ( intArraysTop < 0 ) { array = new int [ positionCount ] ; estimatedSizeInBytes += sizeOfIntArray ( positionCount ) ; } else { array = intArrays [ intArraysTop ] ; intArrays [ intArraysTop ] = null ; // release memory of discarded arrays -- intArraysTop ; } ++ borrowedIntArrays ; return array ; }
public List < MergeStrategySection > getAllMergeStrategySections ( ) { List < MergeStrategySection > all = new ArrayList < > ( ) ; all . addAll ( getLocalMergeStrategySections ( ) ) ; all . addAll ( getInheritedMergeStrategySections ( ) ) ; return all ; }
public String getDeleteDescription ( ) { String alias = getAlias ( ) ; if ( alias == null ) { alias = "" ; } return getName ( ) + " ( " + alias + " ) " ; }
boolean selectCommonAncestor ( ReadOnlyDocument doc1 , ReadOnlyDocument doc2 ) throws CouchbaseLiteException { if ( ! c4doc . getRawDoc ( ) . selectCommonAncestorRevision ( doc1 . getRevID ( ) , doc2 . getRevID ( ) ) ) { throw new CouchbaseLiteException ( ) ; } setC4Doc ( c4doc ) ; return true ; }  In the original code , the method signature indicates that it throws a CouchbaseLiteException , but the method does not actually throw it . Therefore , I added a throw statement to the if block to throw the exception if the condition is true . Additionally , the method should not return void if it throws an exception , so I changed the return type to boolean .
< START > protected void setHazelcastRegisteredEventListenerId ( String hazelcastRegisteredEventListenerId ) { this . hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId ; } < END >
protected String getFileName ( ITask task , Predicate < String > fileExists ) { String encodedFileName = CoreUtil . asFileName ( task . getTaskId ( ) ) ; if ( fileExists . test ( encodedFileName ) ) { return encodedFileName ; } String fileName ; if ( requiresEncoding ( task . getTaskId ( ) ) ) { fileName = encodedFileName ; } else { fileName = task . getTaskId ( ) ; } return trimFilenameIfRequired ( fileName ) ; }
public boolean createIndex ( String indexName ) { Assert . notNull ( indexName , "No index defined for Query" ) ; try { return client . indices ( ) . create ( createIndexRequest ( indexName ) , RequestOptions . DEFAULT ) . isAcknowledged ( ) ; } catch ( Exception e ) { throw new ElasticsearchException ( "Failed to create index " + indexName , e ) ; } }
public static Properties defaultProperties ( ) { Properties properties = BaseHttpApiMetadata . defaultProperties ( ) ; properties . setProperty ( ShipyardProperties . SHIPYARD_CREDENTIAL , " < remote - service - key - given - by - shipyard - cli > " ) ; return properties ; }  Review : This property is used to set the remote service key given by the Shipyard CLI .
protected boolean writeNeedsRemoteValue ( InvocationContext ctx , WriteCommand command , Object key ) { if ( command . hasFlag ( Flag . CACHE_MODE_LOCAL ) ) { return false ; } if ( ctx . isOriginLocal ( ) ) { if ( ! command . readsExistingValues ( ) ) { return false ; } if ( command . hasFlag ( Flag . SKIP_REMOTE_LOOKUP ) ) { return false ; } } else { if ( ! command . alwaysReadsExistingValues ( ) ) { return false ; } } return true ; }
public BulkReceiveLibraryBackend ( LibraryDto dto , Integer quantity , Project project , SampleClass aliquotClass , String defaultSciName , LibraryTemplateService libraryTemplateService ) { super ( "libraryReceipt" , LibraryDto . class , "Libraries" , dto , quantity ) ; if ( isDetailedSampleEnabled ( ) && aliquotClass == null ) throw new InvalidParameterException ( "Aliquot class cannot be null" ) ; this . project = project ; this . aliquotClass = aliquotClass ; this . defaultSciName = defaultSciName ; this . libraryTemplateService = libraryTemplateService ; newBox = dto . getBox ( ) ; }
public void evict ( AccountExternalId id ) { byKey . remove ( id . getKey ( ) ) ; byAccountId . remove ( id . getAccountId ( ) ) ; if ( id . getEmailAddress ( ) != null ) { byEmail . remove ( new EmailWrapper ( id . getEmailAddress ( ) ) ) ; } }
public void outjectRequestMap ( ) { for ( ValuedParameter vparameter : methodInfo . getValuedParameters ( ) ) { result . include ( vparameter . getName ( ) , vparameter . getValue ( ) ) ; } }
public AbstractBlockFamily ( BlockFamilyDefinition definition , BlockShape shape , BlockBuilderHelper blockBuilder ) { super ( definition , shape , blockBuilder ) ; }
public void onStop ( ) { super . onStop ( ) ; if ( mGoogleApiClient != null ) { mGoogleApiClient . stopAutoManage ( getActivity ( ) ) ; if ( mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } } }
protected Guid getQuotaId ( ) { if ( getNewDisk ( ) != null && isInternalManagedDisk ( ) ) { return ( ( DiskImage ) getNewDisk ( ) ) . getQuotaId ( ) ; } return null ; }
public JClogin ( ) { logger . trace ( "JClogin ( this = { } ) called . " , this ) ; }
public ScriptingJobs ( ScriptingAdaptor adaptor , XenonEngine xenonEngine , SchedulerConnectionFactory connectionFactory ) { this . adaptor = adaptor ; this . xenonEngine = xenonEngine ; this . adaptorName = adaptor . getName ( ) ; this . connectionFactory = connectionFactory ; Map < String , Connection > connections = new HashMap < > ( 1 ) ; }
public TMSKeyBuilder ( final String prefix , TileLayerDispatcher layers ) { this . prefix = String . join ( "" , prefix , " / " ) ; this . layers = layers ; }
public void testLeftJoinMissingStats ( ) { PlanNodeStatsEstimate leftStats = planNodeStats ( 0 , new SymbolStatistics ( LEFT_JOIN_COLUMN , UNKNOWN_STATS ) , new SymbolStatistics ( LEFT_OTHER_COLUMN , UNKNOWN_STATS ) ) ; PlanNodeStatsEstimate rightStats = planNodeStats ( 0 , new SymbolStatistics ( RIGHT_JOIN_COLUMN , UNKNOWN_STATS ) , new SymbolStatistics ( RIGHT_OTHER_COLUMN , UNKNOWN_STATS ) ) ; assertJoinStats ( LEFT , leftStats , rightStats , leftStats ) ; }
public List < ClassDefinition > generate ( ExtensionContext input ) throws UnableToCompleteException { PrintWriter printWriter = tryCreate ( ) ; if ( printWriter != null ) { mergeTemplate ( printWriter ) ; commit ( printWriter ) ; registerGinBinding ( ) ; } else { getLogger ( ) . debug ( "Jackson Mapper Provider already generated . Returning . " ) ; } return new ArrayList < > ( getClassDefinition ( ) ) ; }
@Test public void shouldHandleSchemeInsensitiveCase ( ) { String [ ] schemes = { "http" , "https" , "HTTP" , "HTTPS" , "HTtP" } ; for ( String scheme : schemes ) { final Uri uri = URI_1 . buildUpon ( ) . scheme ( scheme ) . build ( ) ; final Boolean shouldHandle = networkHandler . canHandleRequest ( TestUtils . mockRequest ( uri ) ) ; assertThat ( shouldHandle ) . isTrue ( ) ; } }
public void populate ( CoreSession session ) throws ClientException { UserManager um = Framework . getLocalService ( UserManager . class ) ; if ( um != null ) { Framework . doPrivileged ( ( ) - > createUsersAndGroups ( um ) ) ; } }
public void stop ( BundleContext context ) throws Exception { try { Job . getJobManager ( ) . join ( LUCENE_JOB_FAMILY , null ) ; } finally { plugin = null ; super . stop ( context ) ; } }
public ScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { ObjectUtil . checkNotNull ( command , "command" ) ; ObjectUtil . checkNotNull ( unit , "unit" ) ; if ( delay < 0 ) { delay = 0 ; } validateScheduled0 ( delay , unit ) ; return schedule ( new ScheduledFutureTask < Void > ( this , command , deadlineNanos ( unit . toNanos ( delay ) ) ) ) ; }
public Integer invoke ( ) { Integer result = 0 ; try ( InputStream in = cache . getViaStream ( key ) ) { if ( in == null ) { return null ; } int read = 0 ; while ( ( read = in . read ( buffer ) ) != - 1 ) { result = result + read ; } return result ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public CoreEvent process ( CoreEvent event ) throws MuleException { try { return processToApply ( event , this ) ; } catch ( Exception error ) { Throwable cause = error . getCause ( ) ; if ( cause != null && cause instanceof RetryContextInitializationException && cause . getCause ( ) instanceof ExpressionRuntimeException ) { throw ( ( ExpressionRuntimeException ) cause . getCause ( ) ) ; } else { throw error ; } } }
private static void addChildren ( Map < String , List < PatchLineComment > > parentMap , List < PatchLineComment > children , List < PatchLineComment > outResult ) { if ( children != null ) { for ( PatchLineComment c : children ) { outResult . add ( c ) ; addChildren ( parentMap , parentMap . get ( c . getKey ( ) . get ( ) ) , outResult ) ; } } }
public void dispose ( ) { fWindow = null ; }
public boolean equals ( byte [ ] obj , Object otherObj ) { if ( obj == otherObj ) return true ; if ( obj == null || obj . getClass ( ) != byte [ ] . class ) return false ; if ( otherObj == null || otherObj . getClass ( ) != byte [ ] . class ) return false ; byte [ ] byteArray = obj ; byte [ ] otherByteArray = ( byte [ ] ) otherObj ; return Arrays . equals ( byteArray , otherByteArray ) ; }
private EngineSearcherTotalHitsMatcher ( Query query , int totalHits ) { this . query = query ; this . totalHits = totalHits ; }
protected boolean processEntryForContext ( final ILogData data ) { if ( data != null ) { try { final Object payload = data . getPayload ( ) ; } catch ( Throwable e ) { log . error ( "Exception caught at address { } , { } , { } " , data . getGlobalAddress ( ) , data . getStreams ( ) , data . getType ( ) ) ; throw e ; } } return false ; }
public boolean isQueryCacheable ( Query query ) { return query . isAscending ( ) && ! unCacheable . contains ( query . getType ( ) ) ; }  Explanation : The original code disabled caching for descending order queries , but there is no explanation for why this is necessary . The refactored code assumes that caching is only disabled for queries that are not ascending ( i . e . descending or unordered ) , and that this is sufficient to prevent caching issues . The `isDescending ( ) ` method is replaced with `isAscending ( ) ` , which returns the opposite boolean value .
public static boolean isMoeFile ( IResource resource ) { if ( resource instanceof IFile ) { return MODEL_OBJECT_ELEMENTFILE_EXTENSION . equals ( resource . getFileExtension ( ) ) ; } return false ; }
public List < Property > getProperties ( ) { return new ArrayList < > ( m_properties ) ; }
public void setup ( ) throws NoSuchFieldException , IllegalAccessException { Field instanceCountField = OpenHelperManager . class . getDeclaredField ( "instanceCount" ) ; instanceCountField . setAccessible ( true ) ; instanceCountField . setInt ( null , 0 ) ; activity = Robolectric . buildActivity ( OrmLiteActivity_ . class ) . create ( ) . get ( ) ; }
public static Injector getInjector ( EntityManagerFactory emf ) { Injector injector = Guice . createInjector ( new GuiceModule ( emf ) ) ; return injector ; }
public void serialize ( ) throws Exception { String xml = serializer . serialize ( header ) ; String contentUriXpath = " / subscriptionHeader / contentUri" ; String packageHeaderXpath = " / subscriptionHeader / packageHeader" ; String packageNameXpath = " / subscriptionHeader / packageHeader / name" ; XMLAssert . assertXpathExists ( contentUriXpath , xml ) ; XMLAssert . assertXpathExists ( packageHeaderXpath , xml ) ; XMLAssert . assertXpathExists ( packageNameXpath , xml ) ; }
protected IMicroblockContainerTile getMicroblockTile ( IBlockAccess world , BlockPos pos ) { if ( world == null || pos == null ) { return null ; } TileEntity tile = world . getTileEntity ( pos ) ; if ( tile instanceof IMicroblockContainerTile ) { return ( IMicroblockContainerTile ) tile ; } else { return null ; } }
protected void setMethod ( final ZonemasterRequest . Method method ) { this . method = method . getMethod ( ) ; this . id = method . getId ( ) ; }
public Dimension getFloatingItemOffset ( ) { Dimension offset = new Dimension ( ) ; if ( editPart instanceof FloatingLabelEditPart ) { offset = ( ( FloatingLabelEditPart ) editPart ) . getFloatingItemOffset ( ) ; } return offset ; }
private static synchronized ITerminalConnector getConnector ( IRemoteConnection irc ) throws RemoteConnectionException { ITerminalConnector con = cons . get ( irc . getAddress ( ) ) ; if ( con == null ) { con = TerminalConnectorExtension . makeTerminalConnector ( "org . eclipse . ptp . remote . internal . terminal . RemoteToolsConnector" ) ; // $NON - NLS - 1$ cons . put ( irc . getAddress ( ) , con ) ; } if ( irc . isOpen ( ) ) { return null ; } else { irc . open ( new NullProgressMonitor ( ) ) ; return null ; } return con ; }
public long getGlobalClassLoaderId ( ) { return ClassLoaderIdentifier . GLOBAL_ID ; }  Explanation : Since `GLOBAL_ID` is already defined as a `long` in the `ClassLoaderIdentifier` class , there is no need to cast it to a `long` again in the `getGlobalClassLoaderId ( ) ` method . We can simply return the `GLOBAL_ID` value directly .
private int getCmasSeverity ( ) { switch ( messageIdentifier ) { case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY : return SmsCbCmasInfo . CMAS_SEVERITY_EXTREME ; case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED : case SmsCbConstants . MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY : return SmsCbCmasInfo . CMAS_SEVERITY_SEVERE ; default : return SmsCbCmasInfo . CMAS_SEVERITY_UNKNOWN ; } }
public Collection < String > getAliases ( final KeyStore keyStore ) throws ScriptSignatureException { try { if ( keyStore != null ) { return Collections . list ( keyStore . aliases ( ) ) ; } return Collections . emptyList ( ) ; // return an empty list if keyStore is null } catch ( KeyStoreException e ) { throw new ScriptSignatureException ( "Keystore not initialized properly . Try again . " , e ) ; } }
public List getExpressions ( ) { List result = new ArrayList ( groupByAttributes ) ; result . add ( expression ) ; return result ; }
private boolean isIdentityProvider ( ) { try { PackageInfo packageInfo = context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_ACTIVITIES ) ; for ( ActivityInfo activityInfo : packageInfo . activities ) { if ( activityInfo . name . equals ( IDPAccountPickerActivity . class . getName ( ) ) ) { return true ; } } } catch ( NameNotFoundException e ) { SalesforceSDKLogger . e ( TAG , "Exception occurred while examining application info" , e ) ; } return false ; }
private List < BlockedItem > getBlockedItems ( ) { return new ArrayList < BlockedItem > ( snapshot . blockedProjects ) ; }
public IStatus validate ( String path ) { if ( fTrace == null ) { return new Status ( IStatus . ERROR , Activator . PLUGIN_ID , "Trace is null" ) ; } return fTrace . validate ( null , path ) ; }
public static boolean isTCCPacket ( ByteArrayBuffer baf ) { int rc = RTCPHeaderUtils . getReportCount ( baf ) ; return rc == FMT && isRTPFBPacket ( baf ) ; }  Yes , it is worth putting the `rc == FMT` check first for a short - circuiting efficiency improvement .
private Result waitForCompletion ( ) throws InterruptedException , IOException { Result result ; while ( ( result = checkForCompletion ( ) ) == null ) { Thread . sleep ( 1000 ) ; } return result ; }
public void testUnderlyingReaders ( ) throws IOException , FormatException { FakeReader reader = new FakeReader ( ) ; FileStitcher fs = new FileStitcher ( reader ) ; assertNotNull ( fs . getUnderlyingReaders ( ) ) ; fs . setId ( "test_z < 0 - 2 > . fake" ) ; assertNotNull ( fs . getUnderlyingReaders ( ) ) ; fs . close ( ) ; }
public void shouldGetDiagnosisByUuid ( ) { Diagnosis diagnosis = diagnosisDAO . getDiagnosisByUuid ( "4e663d66 - 6b78 - 11e0 - 93c3 - 18a905e044dc" ) ; assertEquals ( 1 , ( int ) diagnosis . getId ( ) ) ; }
public void setUpCallToAction ( String callToActionText ) { callToActionContainer . setVisibility ( callToActionText == null ? GONE : VISIBLE ) ; if ( callToActionText != null ) { callToActionTextView . setText ( callToActionText ) ; } }
protected AbstractTableViewer getTableViewer ( ) { return actionContext . getViewer ( ) ; }
public void start ( ) { if ( ! started ) { log . info ( "Starting prefetching thread . " ) ; executorService . execute ( new DefaultGetRecordsCacheDaemon ( ) ) ; } started = true ; }
public SymbolTableBuilder ( String fullyQualifiedModuleName ) { this . fullyQualifiedModuleName = new ArrayList < > ( List . of ( fullyQualifiedModuleName . split ( "\\ . " ) ) ) ; }  Explanation : The `new ArrayList < > ( Arrays . asList ( ) ) ` syntax can be simplified to `new ArrayList < > ( List . of ( ) ) ` which is more concise and readable .
public long getNextTimestamp ( ) throws TimestampIOException { long nextTS = _timestampCounter . addAndGet ( TIMESTAMP_INCREMENT ) ; if ( nextTS > _maxReservedTimestamp ) { reserveNextBlock ( nextTS ) ; } _numTimestampsCreated . incrementAndGet ( ) ; return nextTS ; }
public TileRenderRunnable ( TileCanvasViewGroup viewGroup , Tile tile ) { mTileCanvasViewGroup = new WeakReference < > ( viewGroup ) ; mTile = new WeakReference < > ( tile ) ; }
public Response viewDataverse ( @PathParam ( "identifier" ) String idtf ) { return allowCors ( response ( req - > ok ( json ( execCommand ( new GetDataverseCommand ( req , findDataverseOrDie ( idtf ) ) ) , false , settingsService . isTrueForKey ( SettingsServiceBean . Key . ExcludeEmailFromExport , false ) ) ) ) ) ; }
public ResourceNotFoundException ( IdString id ) { super ( id . get ( ) ) ; } The code has been updated to use the decoded id instead of the encoded id . This is consistent with other places in the codebase and improves readability and maintainability .
private AppiumDriver < ? > getDriverSafe ( ) { WebDriver driver = getDriver ( ) ; if ( driver instanceof EventFiringWebDriver ) { driver = ( ( EventFiringWebDriver ) driver ) . getWrappedDriver ( ) ; } return ( AppiumDriver < ? > ) driver ; }
public void assertSimilarity ( final File actualFile , final double maxDistance ) throws IOException { BufferedImage tempImg = ImageIO . read ( actualFile ) ; File tempFile = File . createTempFile ( "print - test" , " . png" ) ; ImageIO . write ( tempImg , "png" , tempFile ) ; assertSimilarity ( ImageIO . read ( tempFile ) , maxDistance ) ; }
public URI getLocationHeaderAsURI ( ) { try { return locationHeader != null ? new URI ( locationHeader ) : null ; } catch ( URISyntaxException e ) { if ( LRALogger . logger . isInfoEnabled ( ) ) { LRALogger . logger . infof ( "missing Location header on ACCEPTED response % s failed : % s" , getRequestURI ( ) , e . getMessage ( ) ) ; } return null ; } }
public void setup ( Method method ) throws Exception { logger . info ( "test name : " + method . getName ( ) ) ; bundles [ 0 ] = Util . readELBundles ( ) [ 0 ] [ 0 ] ; bundles [ 0 ] = new Bundle ( bundles [ 0 ] , cluster . getEnvFileName ( ) , cluster . getPrefix ( ) ) ; bundles [ 0 ] . generateUniqueBundle ( ) ; bundles [ 0 ] . setProcessWorkflow ( aggregateWorkflowDir ) ; }
public View getOverflowMenuAnchor ( ) { View view = getToolbar ( ) . findViewById ( R . id . menu_overflow_button ) ; if ( view != null ) { return view ; } return getToolbar ( ) ; }
public List < ResponseInfo > sendAndPoll ( List < RequestInfo > requestInfos ) throws IOException { try { if ( closed ) { close ( ) ; throw new IllegalStateException ( "The NetworkClient is closed . " ) ; } List < ResponseInfo > responseInfoList = new ArrayList < ResponseInfo > ( ) ; for ( RequestInfo requestInfo : requestInfos ) { pendingRequests . add ( new RequestMetadata ( time . milliseconds ( ) , requestInfo , null ) ) ; } List < NetworkSend > sends = prepareSends ( responseInfoList ) ; selector . poll ( POLL_TIMEOUT_MS , sends ) ; handleSelectorEvents ( responseInfoList ) ; return responseInfoList ; } catch ( IOException e ) { close ( ) ; throw e ; } }
public void handleQuotaColumnVisibility ( ) { isQuotaVisible = false ; SystemTreeItemModel treeItem = ( SystemTreeItemModel ) CommonModel . getInstance ( ) . getSystemTree ( ) . getSelectedItem ( ) ; if ( treeItem != null && treeItem . getType ( ) == SystemTreeItemType . DataCenter ) { StoragePool storagePool = ( StoragePool ) treeItem . getEntity ( ) ; if ( storagePool . getQuotaEnforcementType ( ) != QuotaEnforcementTypeEnum . DISABLED ) { isQuotaVisible = true ; } } onDiskViewTypeChanged ( ) ; }
public CompletableFuture < StaticResource > getResource ( String name ) { StaticResource template = templates . get ( name ) ; if ( template != null ) { return CompletableFuture . completedFuture ( template ) ; } return delegate . getResource ( name ) . exceptionally ( ( th ) - > { templates . put ( name , null ) ; return null ; } ) . thenApply ( ( file ) - > { templates . put ( name , file ) ; return file ; } ) ; }
public void testSessionTicketsWithTLSv13AndNoKey ( ) throws Throwable { assumeTrue ( OpenSsl . isTlsv13Supported ( ) ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V1_3 ) ; SSLContext . setDefault ( sslContext ) ; SSLContext sslContext = SSLContext . getInstance ( SslUtils . PROTOCOL_TLS_V
Here's the   @BeforeClass public static void setUp ( ) { TmfEventMatching . registerMatchObject ( new TcpEventMatching ( ) ) ; TmfEventMatching . registerMatchObject ( new TcpLttngEventMatching ( ) ) ; }
@NonNullByDefault protected void updateTitle ( @NonNull String brand ) { IBrandManager brandManager = TasksUiPlugin . getDefault ( ) . getBrandManager ( ) ; setTitle ( brandManager . getConnectorLabel ( getConnector ( ) , brand ) ) ; }
public static int getSegmentForKey ( Object key , Cache cache ) { KeyPartitioner keyPartitioner = extractComponent ( cache , KeyPartitioner . class ) ; if ( keyPartitioner != null ) { return keyPartitioner . getSegment ( key ) ; } throw new IllegalArgumentException ( "KeyPartitioner not found in cache configuration" ) ; }

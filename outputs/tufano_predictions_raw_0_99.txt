private static Set < String > getRootQualifiers ( ResourceTypes resourceTypes ) { return resourceTypes . getRoots ( ) . stream ( ) . map ( ResourceType : : getQualifier ) . filter ( q - > ! DEPRECATED_QUALIFIERS . contains ( q ) && ! q . equals ( "LIBRARY" ) ) . collect ( Collectors . toCollection ( TreeSet : : new ) ) ; }
public RuntimeFilterManager ( QueryWorkUnit workUnit , DrillbitContext drillbitContext ) { this . rootWrapper = workUnit . getRootWrapper ( ) ; this . drillbitContext = drillbitContext ; lineSeparator = System . lineSeparator ( ) ; }
private void activateMarkers ( ) { if ( ! fGerritClient . getRepository ( ) . getServerInfo ( ) . isAnonymous ( ) ) { String value = Messages . ChangeDetailEditor_EGerriTipValue ; UIUtils . showDialogTip ( MARKERS_KEY , headerSection . getShell ( ) , Messages . EGerriTip , value ) ; } }
Corrected Code : public void testCreate ( ) throws StripeException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( "currency" , "usd" ) ; final Order order = Order . create ( params ) ; assertNotNull ( order ) ; verifyRequest ( APIResource . RequestMethod . POST , " / v1 / orders" , params ) ; }
private FirewallRule findById ( List < FirewallRule > collection , String id ) { for ( FirewallRule rule : collection ) { if ( rule . id ( ) . equals ( id ) ) { return rule ; } } return null ; }
public void addDownload ( String download ) { Set < String > downloads = new HashSet < > ( ) ; if ( ! downloads . contains ( download ) ) { downloads . add ( download ) ; } }
public void copyDetailsFromOtherCuObjectCodeActivationGlobal ( CuObjectCodeActivationGlobal oldGlobal ) { for ( CuObjectCodeGlobalDetail oldDetail : oldGlobal . getObjectCodeGlobalDetails ( ) ) { CuObjectCodeGlobalDetail newDetail = ( CuObjectCodeGlobalDetail ) ObjectUtils . deepCopy ( oldDetail ) ; newDetail . setObjectId ( null ) ; newDetail . setDocumentNumber ( getDocumentNumber ( ) ) ; newDetail . setVersionNumber ( 1L ) ; getObjectCodeGlobalDetails ( ) . add ( newDetail ) ; } }
private void loadVncData ( HasConsoleModel model , KeyMaker keyMaker ) { if ( ! ( model . getDefaultConsoleModel ( ) instanceof VncConsoleModel ) ) { return ; } model . setSelectedProtocol ( ConsoleProtocol . VNC ) ; try { asVncConsoleModel ( model ) . setVncImplementation ( VncConsoleModel . ClientConsoleMode . valueOf ( clientStorage . getLocalItem ( keyMaker . make ( VNC_CLIENT_MODE ) ) ) ) ; } catch ( IllegalArgumentException e ) { // handle the exception as needed } }
private RuleApplication applyRule ( ) { SymbolAllocator symbolAllocator = new SymbolAllocator ( symbols ) ; Memo memo = new Memo ( idAllocator , plan ) ; Lookup lookup = Lookup . from ( memo : : resolve ) ; Optional < PlanNode > result = inTransaction ( session - > rule . apply ( memo . getNode ( memo . getRootGroup ( ) ) , lookup , idAllocator , symbolAllocator , session ) ) ; return new RuleApplication ( memo , lookup , symbolAllocator . getTypes ( ) , result ) ; }
public void testPushDownArray ( ) throws Exception { testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] = 1" , 3 , 2 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] = 100" , 0 , 1 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] != 1" , 8 , 7 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 2 ] > 20" , 5 , 4 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 0 ] between 10 and 20" , 5 , 5 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 4 ] = 15" , 1 , 3 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 2 ] is not null" , 11 , 6 ) ; testParquetFilterPushDown ( "t . `user` . hobby_ids [ 3 ] is null" , 11 , 7 ) ; }
Default Direction getBubbleElevatorDirection ( ) { Block block = this . getBlockState ( ) . getBlock ( ) ; if ( block == Blocks . BUBBLE_COLUMN ) { return this . getBlockState ( ) . get ( BubbleColumnBlock . DRAG ) ? Direction . DOWN : Direction . UP ; } return block . getDefaultBubbleElevatorDirection ( ) ; }
public void testSystemPropertiesOverrideConfigurationValues ( ) { final String keyName = CoreConfig . MAX_CASSANDRA_CONNECTIONS . toString ( ) ; Configuration config = Configuration . getInstance ( ) ; try { Assert . assertEquals ( "75" , config . getStringProperty ( CoreConfig . MAX_CASSANDRA_CONNECTIONS ) ) ; System . setProperty ( keyName , "something else" ) ; Assert . assertEquals ( "something else" , config . getStringProperty ( CoreConfig . MAX_CASSANDRA_CONNECTIONS ) ) ; } finally { System . clearProperty ( keyName ) ; Configuration . getInstance ( ) . clearProperty ( keyName ) ; } }
java public void onSubscribe ( Subscription inner ) { this . inner = inner ; o . onSubscribe ( this ) ; inner . request ( Long . MAX_VALUE ) ; }
public WebElement forElementPresent ( By by ) { changeImplicitWait ( 250 , TimeUnit . MILLISECONDS ) ; try { return wait . until ( ExpectedConditions . presenceOfElementLocated ( by ) ) ; } catch ( TimeoutException e ) { PageObjectLogging . log ( ELEMENT_PRESENT_MESSAGE , String . format ( ELEMENT_PRESENT_ERROR_FORMAT , by . toString ( ) ) , false ) ; throw e ; } finally { restoreDeaultImplicitWait ( ) ; } }
public boolean accept ( Issue issue ) { return ! issueShouldNotBeReported ( issue , excludedLinesByRule ( ) ) ; }
private HashMap < String , ArrayList < Order > > getBuyOrders ( ) { return buyOrders ; }
static Color getSystemForegroundColor ( Display display ) { ColorRegistry colorRegistry = JFaceResources . getColorRegistry ( ) ; Color foreground = colorRegistry . get ( JFacePreferences . INFORMATION_FOREGROUND_COLOR ) ; if ( foreground == null ) { return JFaceColors . getInformationViewerForegroundColor ( display ) ; } return foreground ; }
public boolean hasNoDefault ( SwitchStatementTree switchStatementTree ) { return allLabels ( switchStatementTree ) . noneMatch ( SwitchLastCaseIsDefaultCheck : : isDefault ) ; } public void visitNode ( Tree tree ) { if ( ! hasSemantic ( ) ) { return ; } SwitchStatementTree switchStatementTree = ( SwitchStatementTree ) tree ; if ( ! hasNoDefault ( switchStatementTree ) ) { return ; } if ( ! isSwitchOnEnum ( switchStatementTree ) ) { reportIssue ( switchStatementTree . switchKeyword ( ) , "Add a default case to this switch . " ) ; } else if ( missingCasesOfEnum ( switchStatementTree ) ) { reportIssue ( switchStatementTree . switchKeyword ( ) , "Complete cases by adding the missing enum constants or add a default case to this switch . " ) ; } }
public synchronized String getAttribute ( ) { if ( fAttribute . equals ( NOT_SET ) ) { setAttribute ( ) ; } return fAttribute ; }
public DotRunnableThread ( final List < DotRunnable > allListeners ) { this . listeners = getListeners ( allListeners ) ; this . flushers = getFlushers ( allListeners ) ; startNetworkCacheFlushThread ( ) ; } private void startNetworkCacheFlushThread ( ) { this . networkCacheFlushThread . start ( ) ; }
private void createIndex ( ) { lastFoundElementPosition = 0 ; filteredPlan . clear ( ) ; for ( PlanElement element : plan . getList ( ) ) if ( ! element . isComment ( ) ) filteredPlan . add ( element ) ; }
public Collection < Map . Entry < K , V > > scanAndFilterByEntry ( Predicate < ? super Map . Entry < K , V > > entryPredicate ) { return mainMap . entrySet ( ) . parallelStream ( ) . filter ( entryPredicate ) . collect ( Collectors . toCollection ( ArrayList : : new ) ) ; }  Explanation : The `entrySet ( ) ` method returns a `Set` view of the mappings contained in the map . The `entryStream ( ) ` method returns a sequential `Stream` of the entries in the map . The `parallel ( ) ` method on a `Stream` returns an equivalent stream that is parallel . Therefore , there is no difference between `parallelStream ( ) ` and `entryStream ( ) . parallel ( ) ` . In the refactored code , we use `entrySet ( ) . parallelStream ( ) ` to get a parallel stream of the entries in the map . This stream is then filtered using the `entryPredicate` and collected into an `ArrayList` .
java private boolean isValidChar ( final char c ) { return isValidChar ( regExp , c ) ; }
java public boolean verifyEventIdentifier ( AbstractPlaceEvent event ) { if ( ! Objects . equals ( editorPlaceRequest , event . getPlace ( ) ) ) { return false ; } if ( ! Objects . equals ( getEditorIdentifier ( ) , event . getPlace ( ) . getIdentifier ( ) ) ) { return false ; } return true ; }
public void star ( ) throws IOException { this . request = this . entry . uri ( ) . path ( RtGist . PATH_ELEMENT_STAR ) . back ( ) . method ( "PUT" ) ; this . request . fetch ( ) . as ( RestResponse . class ) . assertStatus ( HttpURLConnection . HTTP_NO_CONTENT ) ; }
public IssueOutputView ( Issue issue , IssueArticles issueArticles ) { this ( issue , issueArticles , null ) ; }  Explanation : - The `IssueOutputView` constructor now requires an `Issue` object and an `IssueArticles` object . - The third parameter is still nullable , but it is not required for the constructor to work properly . - If the third parameter is needed , a separate view class can be created to handle that scenario .
public ProcessEngineConfiguration setDefaultNumberOfRetries ( int defaultNumberOfRetries ) { this . defaultNumberOfRetries = defaultNumberOfRetries ; return this ; } // This code may break binary compatibility .
public void testSequenceFlowSupplier ( ) { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand ( parent , candidate , index , originalParent , originalIndex ) ; final Supplier < ViewConnector < SequenceFlow > > supplier = command . sequenceFlowSupplier ( ) ; final ViewConnector < SequenceFlow > viewConnector = supplier . get ( ) ; assertNotNull ( viewConnector ) ; assertNotNull ( viewConnector . getSourceConnection ( ) ) ; assertNotNull ( viewConnector . getTargetConnection ( ) ) ; assertNotNull ( viewConnector . getBounds ( ) ) ; assertNotNull ( viewConnector . getDefinition ( ) ) ; }
public long getSessionSeqId ( ) { if ( sessionSeqId == null ) { String sessionId = getContext ( ) . getEngineContext ( ) . getSessionId ( ) ; // The session may not exist for quartz jobs if ( getSessionDataContainer ( ) . isSessionExists ( sessionId ) ) { sessionSeqId = getSessionDataContainer ( ) . getEngineSessionSeqId ( sessionId ) ; } else { sessionSeqId = - 1L ; } } return sessionSeqId ; }
private boolean isTxnRelatedEvent ( final NotificationEvent event ) { return ( ( event . getEventType ( ) . equals ( MessageFactory . OPEN_TXN_EVENT ) ) || ( event . getEventType ( ) . equals ( MessageFactory . COMMIT_TXN_EVENT ) ) || ( event . getEventType ( ) . equals ( MessageFactory . ABORT_TXN_EVENT ) ) || ( event . getEventType ( ) . equals ( MessageFactory . ALLOC_WRITE_ID_EVENT ) && isLookupOnDBTable ( event ) ) ) ; } private boolean isLookupOnDBTable ( final NotificationEvent event ) { // logic to check if the event is related to a DB / table lookup // return true if it is , false otherwise }
public static void setBackground ( boolean async ) { FileStore . setAttributeCacheBackground ( async ) ; }
public V put ( @NonNull K key , @NonNull V value ) { map . put ( key , new Entry < > ( key , value , ++ time ) ) ; if ( map . size ( ) > maximumSize ) { purge ( ) ; } return value ; }
private static void setIfNotNullOrEmpty ( MongoProperties . Builder builder , MongoProp prop , String value ) { if ( value != null && value . trim ( ) . length ( ) > 0 ) { boolean isPassword = MongoProp . PASSWORD . equals ( prop ) ; if ( isPassword ) { value = Encr . decryptPasswordOptionallyEncrypted ( value ) ; } builder . set ( prop , value ) ; } }
public Mutation toMutation ( K key ) { byte [ ] encodedValue = valueDataConversion . toStorage ( value . toString ( ) . getBytes ( StandardCharsets . UTF_8 ) ) ; V valueFromStorage = valueDataConversion . fromStorage ( encodedValue ) ; return new Mutations . ReadWriteWithValue < > ( valueFromStorage , f ) ; }
< START > Entry ( Map . Entry < String , String > e ) { < END > this ( e . getKey ( ) , e . getValue ( ) ) ; }
private String parsePath ( ) throws URISyntaxException { String [ ] parts = uri . split ( "\\ ? " ) [ 0 ] . split ( " : " , 2 ) ; if ( parts . length < 2 || parts [ 1 ] . isEmpty ( ) ) { throw new URISyntaxException ( uri , "invalid path" ) ; } else { return parts [ 1 ] ; } }
public void setItems ( Collection value ) { genVersionToBaseTemplate ( value ) ; super . setItems ( value ) ; } // In UserPortalTemplateListModel public void setItems ( Collection value ) { genVersionToBaseTemplate ( value ) ; final List < VmTemplate > sortedValues = sortTemplates ( value ) ; super . setItems ( sortedValues ) ; }
public void edit ( VolumeBrickModel object ) { table . setRowData ( object . getBricks ( ) ) ; Driver . driver . edit ( object ) ; }
public List < QuickFilter > getQuickFilters ( ) { return quickFilters ; }
public void testBounds ( ) { assertEquals ( LOW , fCondition . min ( ) ) ; assertEquals ( HIGH , fCondition . max ( ) ) ; }
public String weather ( ) { String result = restTemplate . getForObject ( "http :/ / " + WEATHER_SERVICE + " / weather" , String . class ) ; return "Weather Service Response : " + result ; }
public boolean isExtensionEnabled ( ) { if ( enablement != null ) { try { return EnablementTester . evaluate ( enablement ) ; } catch ( CoreException e ) { // TODO : handle exception } } return true ; }
public ProviderNotificationManager createProviderNotificationManager ( final DiagramEventBroker diagramEventBroker , final EObject view , final NotificationListener notificationListener ) { ProviderNotificationManager manager = null ; if ( manager == null ) { manager = new ProviderNotificationManager ( diagramEventBroker , view , notificationListener ) { @Override protected void registerListeners ( ) { // TODO install listener on allocation ( Abstraction ) of the model . } } ; } return manager ; }
private void syncFolder ( OCFile folder ) { long currentSyncTime = System . currentTimeMillis ( ) ; mSyncInProgress = true ; RemoteOperation synchFolderOp = new RefreshFolderOperation ( folder , currentSyncTime , false , false , false , getStorageManager ( ) , getAccount ( ) , getApplicationContext ( ) ) ; synchFolderOp . execute ( getAccount ( ) , this , null , null ) ; }
private static ProtobufMetadataManagerImpl getProtobufMetadataManager ( EmbeddedCacheManager cacheManager ) { if ( cacheManager == null ) { throw new IllegalArgumentException ( "cacheManager cannot be null" ) ; } ProtobufMetadataManagerImpl metadataManager = ( ProtobufMetadataManagerImpl ) cacheManager . getGlobalComponentRegistry ( ) . getComponent ( ProtobufMetadataManager . class ) ; if ( metadataManager == null ) { throw new IllegalStateException ( "ProtobufMetadataManager not initialised yet ! " ) ; } return metadataManager ; }
public void onSessionKeyUpdate ( SessionKey sessionKey ) { synchronized ( DistributedHerder . this ) { DistributedHerder . this . sessionKey = sessionKey . key ( ) ; if ( isLeader ( ) && keyRotationIntervalMs > 0 ) { DistributedHerder . this . keyExpiration = sessionKey . creationTimestamp ( ) + keyRotationIntervalMs ; } } log . info ( "Session key updated" ) ; }  The log message should be after we update the session key . Therefore , I moved the log statement to the end of the method .
public String getAuthorizationUrl ( OAuthConfig config ) { System . out . print ( "Authorization URL : " ) ; // Added missing 'z' in Authorization String url = String . format ( AUTHORIZE_URL , OAuthEncoder . encode ( config . getApiKey ( ) ) , OAuthEncoder . encode ( config . getCallback ( ) ) , OAuthEncoder . encode ( config . getScope ( ) ) , OAuthEncoder . encode ( config . getState ( ) ) ) ; return url ; }
public Object getParameter ( String name ) { final HostThread currentHostThread = fCurrentHostThread ; if ( currentHostThread == null ) { return null ; } if ( name . equals ( CriticalPathModule . PARAM_WORKER ) ) { IAnalysisModule mod = getModule ( ) ; if ( ( mod != null ) && ( mod instanceof CriticalPathModule ) ) { LttngWorker worker = new LttngWorker ( currentHostThread , "" , 0 ) ; // $NON - NLS - 1$ return worker ; } } return null ; }
public static ExceptionThrowingSubTest expectThrowable ( Runnable runnable ) { return expectException ( runnable . toString ( ) , runnable ) ; }
protected CONNECTCXFClient ( ServicePortDescriptor < T > portDescriptor , String url , AssertionType assertion , ServicePortBuilder < T > portBuilder ) { serviceEndpoint = super . configureBasePort ( portBuilder . createPort ( ) , url , assertion != null ? assertion . getTransactionTimeout ( ) : null ) ; }
public < V > Setting < V > get ( SimpleUri id , Class < V > valueType ) { Setting < V > setting = settings . get ( id ) ; Class < ? > settingValueClass = setting . getValueClass ( ) ; if ( ! settingValueClass . equals ( valueType ) ) { throw new ClassCastException ( "Expected a Setting of type " + valueType . getName ( ) + " , found a Setting of type " + settingValueClass . getName ( ) + " for setting " + id ) ; } return setting ; }
public String getCustomField ( String fieldName ) { if ( customFields . isEmpty ( ) ) { return null ; } for ( CustomField f : customFields ) { if ( f . getName ( ) . equals ( fieldName ) ) { return f . getValue ( ) ; } } return null ; }
private CommandCall duplicateCommandForDifferentElement ( CommandCall commandCall , Element element ) { String expression = commandCall . getExpression ( ) ; if ( commandCall . getCommand ( ) . isExample ( ) && expression . isEmpty ( ) ) { expression = element . getText ( ) ; } return new CommandCall ( null , commandCall . getCommand ( ) , element , expression , commandCall . getResource ( ) ) ; }
public M fromBytes ( byte [ ] messageBuffer ) { if ( deserializer == null ) { deserializer = new ThriftBinaryDeserializer ( ) ; } try { M message = typeRef . safeNewInstance ( ) ; deserializer . deserialize ( message , messageBuffer ) ; return message ; } catch ( Throwable e ) { logWarning ( "failed to deserialize" , e ) ; return null ; } }
public void showPage ( Control page ) { if ( page == null || page . isDisposed ( ) || page . getParent ( ) != this ) { return ; } currentPage = page ; page . setVisible ( true ) ; layout ( true ) ; Control [ ] children = getChildren ( ) ; for ( Control child : children ) { if ( child != page && ! child . isDisposed ( ) ) { child . setVisible ( false ) ; } } }
public void warn ( String message , Object . . . objects ) { LOG . warn ( message , objects ) ; }
public String getLinkAt ( int offset ) { for ( int i = 0 ; i < linkRanges . size ( ) ; i ++ ) { if ( linkRanges . get ( i ) . isOffsetInRange ( offset ) ) { return hrefs . get ( i ) ; } } return "" ; }
public String toString ( ) { return "FileListCacheValue { fileNames = " + getFileNames ( ) + " } " ; }
protected Control createControl ( Composite parent ) { CTConfiguration config = new CTConfiguration ( parent , CTConfiguration . STYLE_GRID ) ; config . setHorizontalAlignment ( SWT . CENTER ) ; config . setCellSelectionEnabled ( false ) ; config . setColumnSelectionEnabled ( false ) ; config . setRowSelectionEnabled ( false ) ; config . setColumnHeaderLayout ( CTConfiguration . COLUMN_HEADER_LAYOUT_FILL_EQUAL ) ; config . setRowHeaderLayout ( CTConfiguration . ROW_HEADER_LAYOUT_DEFAULT ) ; this . table = new ComponentTable ( parent , SWT . FULL_SELECTION , config ) ; return this . table . getControl ( ) ; }
public boolean isEnabled ( ) { return true ; }
void verifyMetadata ( MessageMetadata metadata ) throws WrongMessageTypeException { if ( metadata . getMessageMetadataType ( ) != MessageType . LOG_ENTRY_MESSAGE || metadata . getSnapshotTimestamp ( ) != srcGlobalSnapshot ) { log . error ( "Wrong message metadata { } , expecting type { } snapshot { } " , metadata , MessageType . LOG_ENTRY_MESSAGE , srcGlobalSnapshot ) ; throw new WrongMessageTypeException ( "Wrong type of message" ) ; } }
public void setVmBackup ( VmBackup value ) { this . vmBackup = value ; }
public void setPrice1 ( int price3 ) { if ( price3 < 0 || price3 > 10000 ) { throw new IllegalArgumentException ( "Invalid price : " + price3 ) ; } assert price3 > 1000 ; }
public String evaluate ( TransactionContext txnCtx , Input < Object > [ ] args ) { if ( args . length != 2 ) { throw new IllegalArgumentException ( "repeat takes exactly two arguments" ) ; } String text = ( String ) args [ 0 ] . value ( ) ; if ( text == null ) { return null ; } int repetitions = 0 ; try { repetitions = ( int ) args [ 1 ] . value ( ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( "Second argument must be an integer" ) ; } if ( repetitions <= 0 ) { return "" ; } else { return text . repeat ( repetitions ) ; } }  The refactored code checks if the number of arguments is exactly two and throws an exception if it is not . It also checks if the second argument is an integer and throws an exception if it is not . This ensures that the code will not fail on `null` or non - integer inputs .
java void setActionBarNotificationBarColor ( MaterialColor color ) { getSupportActionBar ( ) . setBackgroundDrawable ( new ColorDrawable ( color . toActionBarColor ( this ) ) ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { getWindow ( ) . setStatusBarColor ( color . toStatusBarColor ( this ) ) ; } }  The `public` access modifier has been removed as it was not necessary for the method to be accessible outside of the class .
public static ProjectBuildType getProjectType ( IProject project ) { if ( isAutoTools ( project ) ) { return ProjectBuildType . AUTO_TOOLS ; } IConfiguration defaultConfiguration = helper_getActiveConfiguration ( project ) ; IBuilder builder = defaultConfiguration . getBuilder ( ) ; Boolean projIsManaged = builder . isManagedBuildOn ( ) ; if ( projIsManaged ) { return ProjectBuildType . MANAGED_MAKEFILE ; } else { return ProjectBuildType . OTHER ; // E . g a manual makefile . } }
protected long download ( T object , File outFile ) throws IOException { openObjectFunction . open ( object , outFile ) ; return outFile . length ( ) ; }
private Collection < VCastResult > getResultFiles ( VCastDataStore dataStore ) throws OseeCoreException { Collection < VCastResult > results = null ; try { results = dataStore . getAllResults ( ) ; } catch ( OseeCoreException ex ) { throw new OseeCoreException ( "SQL error while reading results" , ex ) ; } return results ; }  In the original code , catching and then throwing the same exception type is redundant and unnecessary . In the refactored code , the catch block is modified to pass the original exception as a parameter to the new exception being thrown . This preserves the original exception information while providing a more informative error message .
public PinotQueryGeneratorContext visitFilter ( FilterNode node , PinotQueryGeneratorContext context ) { context = node . getSource ( ) . accept ( this , context ) ; requireNonNull ( context , "context is null" ) ; LinkedHashMap < VariableReferenceExpression , Selection > selections = context . getSelections ( ) ; String filter = node . getPredicate ( ) . accept ( pinotFilterExpressionConverter , ( var ) - > selections . get ( var ) ) . getDefinition ( ) ; return context . withFilter ( filter ) . withOutputColumns ( node . getOutputVariables ( ) ) ; }
/* * * Constructs a new Space object with the given enumerated value . * * @param enumeratedValue the enumerated value to set for the Space object */ private Space ( String enumeratedValue ) { this . enumeratedValue = enumeratedValue ; }
public Guid getStorageDomainIdForPoolByType ( Guid pool , StorageDomainType type ) { Guid returnValue = Guid . Empty ; List < storage_domains > domains = getAllForStoragePool ( pool ) ; for ( storage_domains domain : domains ) { if ( domain . getstorage_domain_type ( ) == type ) { returnValue = domain . getId ( ) ; break ; } } return returnValue ; }
public void lock ( T id ) throws InterruptedException { threadsLocked . inc ( ) ; try { idsLocked . update ( 1 ) ; lockInternal ( id ) ; } finally { threadsLocked . dec ( ) ; } }
public RunLengthEncodedBlock ( Block value , int positionCount ) { Objects . requireNonNull ( value , "value is null" ) ; if ( value . getPositionCount ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( "Expected value to contain a single position but has % s positions" , value . getPositionCount ( ) ) ) ; } if ( value instanceof RunLengthEncodedBlock ) { throw new IllegalArgumentException ( String . format ( "Value can not be an instance of a % s" , getClass ( ) . getName ( ) ) ) ; } if ( positionCount < 0 ) { throw new IllegalArgumentException ( "positionCount is negative" ) ; } this . value = value ; this . positionCount = positionCount ; }
public Message . Request request ( ) { Message . Request request = callback . request ( ) ; if ( retryConsistencyLevel != null && retryConsistencyLevel != request . consistency ( ) ) { return request . copy ( retryConsistencyLevel ) ; } else { return request ; } }
public void init ( FilterConfig filterConfig ) throws ServletException { directoryAllowed = Context . getConfig ( ) . getBoolean ( "media . directoryAllowed" ) ; }
public ExtentBufferedCompositePattern ( Extent extent , Pattern . . . patterns ) { super ( extent ) ; checkArgument ( patterns . length > 0 , "patterns cannot be empty" ) ; this . patterns = patterns ; }
public boolean isValid ( Object [ ] value , ConstraintValidatorContext context ) { if ( value . length != 3 ) { throw new IllegalArgumentException ( "Unexpected method signature" ) ; } if ( value [ 1 ] == null || value [ 2 ] == null ) { return true ; } return ( ( Date ) value [ 1 ] ) . before ( ( Date ) value [ 2 ] ) ; }
private static boolean monoNativeFailure ( Either < Utils . CommandResult > result ) { if ( result == null || ! result . isSuccess ( ) ) { return true ; } else { Utils . CommandResult commandResult = result . get ( ) ; return monoNativeFailure ( commandResult . output ) || monoNativeFailure ( commandResult . error ) ; } } // Refactored Code private static boolean monoNativeFailure ( Either < Utils . CommandResult > result ) { if ( result == null || ! result . isSuccess ( ) ) { return true ; } else { Utils . CommandResult commandResult = result . get ( ) ; return monoNativeFailure ( commandResult . output ) || monoNativeFailure ( commandResult . error ) ; } }
private void removeAppBar ( ) { DWORD dwABM = new DWORD ( ) ; APPBARDATA ABData = new APPBARDATA . ByReference ( ) ; ABData . cbSize . setValue ( ABData . size ( ) ) ; dwABM . setValue ( ShellAPI . ABM_REMOVE ) ; UINT_PTR result = Shell32 . INSTANCE . SHAppBarMessage ( dwABM , ABData ) ; assertNotNull ( result ) ; }
public boolean couldMatch ( ScriptPath path ) { return path . eventLower . startsWith ( "mythicmob" ) && path . eventArgLowerAt ( 2 ) . equals ( "spawns" ) ; }
void init ( ) { controllerHomeDir = resolveControllerHome ( ) ; initAccessOfDirectories ( ) ; initAccessOfHosts ( ) ; } private String resolveControllerHome ( ) { // logic to resolve controller home directory } private void initAccessOfDirectories ( ) { // logic to initialize access of directories } private void initAccessOfHosts ( ) { // logic to initialize access of hosts }
protected Sequence getServicesSequence ( DsfSession session , ILaunch launch , IProgressMonitor rm ) { return new ServicesLaunchSequence ( session , ( GdbLaunch ) launch , rm ) ; }  Explanation : Since it is always expected that `launch` would be an instance of `GdbLaunch` , there is no need to check it . Therefore , we can directly create a new `ServicesLaunchSequence` object with the given parameters .
public AdvanceResult advanceNursery ( final AdvancingNursery advanceInfo , final Workbook workbook ) throws RuleException , FieldbookException { return this . namingConventionService . advanceNursery ( advanceInfo , workbook ) ; }
public org . ovirt . engine . api . model . Cluster update ( org . ovirt . engine . api . model . Cluster incoming ) { MacPool macPool = incoming . getMacPool ( ) ; macPool . setId ( MacPoolIdByIdOrName . get ( macPool . getId ( ) , macPool . getName ( ) , this ) ) ; return performUpdate ( incoming , new QueryIdResolver < > ( VdcQueryType . GetClusterById , IdQueryParameters . class ) , VdcActionType . UpdateCluster , new UpdateParametersProvider ( ) ) ; }
protected @NonNull TmfViewer createLeftChildViewer ( @Nullable Composite parent ) { String analysisId = NonNullUtils . nullToEmptyString ( getViewSite ( ) . getSecondaryId ( ) ) ; IAnalysisModule module = TmfTraceUtils . getAnalysisModuleOfClass ( getTrace ( ) , IAnalysisModule . class , analysisId ) ; if ( ! ( module instanceof ISegmentStoreProvider ) ) { Activator . getDefault ( ) . getLog ( ) . log ( new Status ( IStatus . ERROR , Activator . PLUGIN_ID , "Invalid analysis ID" ) ) ; return null ; } ISegmentStoreProvider provider = ( ISegmentStoreProvider ) module ; return new AbstractSegmentStoreScatterChartTreeViewer ( Objects . requireNonNull ( parent ) ) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider ( ITmfTrace trace ) { return provider ; } } ; }
public void testReservedSkippableBeforeStreamIdentifier ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { - 0x7f , 0x06 , 0x00 , 0x00 , 's' , 'n' , 'e' , 't' , 't' , 'y' } ) ; channel . writeInbound ( in ) ; }
public void set ( String name , Property property ) throws PropertyNotFoundException { Field field = getType ( ) . getField ( name ) ; if ( field == null ) { Property removedProperty = computeRemovedProperty ( name ) ; if ( removedProperty != null ) { removedProperty . set ( name , property ) ; } return ; } String key = field . getName ( ) . getPrefixedName ( ) ; children . put ( key , property ) ; setIsModified ( ) ; }
public int andCardinality ( Container x ) { if ( this . getCardinality ( ) == 0 || x . getCardinality ( ) == 0 ) { return 0 ; } else if ( x instanceof ArrayContainer ) { return andCardinality ( ( ArrayContainer ) x ) ; } else if ( x instanceof BitmapContainer ) { return andCardinality ( ( BitmapContainer ) x ) ; } else { return andCardinality ( ( RunContainer ) x ) ; } }
public Set < WorkerNetAddress > getWorkerAddresses ( ) throws UnavailableException { if ( mSafeModeManager . isInSafeMode ( ) ) { throw new UnavailableException ( ExceptionMessage . MASTER_IN_SAFEMODE . getMessage ( ) ) ; } Set < WorkerNetAddress > workerAddresses = new HashSet < > ( mWorkers . size ( ) ) ; for ( MasterWorkerInfo worker : mWorkers ) { workerAddresses . add ( worker . getWorkerAddress ( ) ) ; } return workerAddresses ; }
public void setUp ( ) { String signature = "RSOYDt4T1cUTdK1PDd93 / VVr8B8 = " ; params . put ( "CallSid" , "CA1234567890ABCDE" ) ; params . put ( "Caller" , " + 14158675309" ) ; params . put ( "Digits" , "1234" ) ; params . put ( "From" , " + 14158675309" ) ; params . put ( "To" , " + 18005551212" ) ; }  In the refactored code , the `signature` variable is declared and initialized before the `params` map is populated . This ensures that the `signature` value is not overwritten or changed accidentally .
public @Nullable String getAttributeValue ( @Nullable String name ) { return name ; }
public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { for ( Object cookie : this . cookiesToClear ) { Cookie realCookie = null ; if ( cookie instanceof String ) { realCookie = new Cookie ( ( String ) cookie , null ) ; String cookiePath = request . getContextPath ( ) + " / " ; realCookie . setPath ( cookiePath ) ; realCookie . setMaxAge ( 0 ) ; } else if ( cookie instanceof Cookie ) { realCookie = ( Cookie ) cookie ; } response . addCookie ( realCookie ) ; } }
< START > private MethodHandles . Lookup getMethodHandleLookup ( Class < ? > endpointClass ) { return MethodHandles . publicLookup ( ) . in ( endpointClass ) ; } < END >
public void channelOpen ( ChannelHandlerContext ctx , ChannelStateEvent e ) throws Exception { if ( maxConnections > 0 ) { if ( numConnections . incrementAndGet ( ) > maxConnections ) { numConnections . decrementAndGet ( ) ; ctx . getChannel ( ) . close ( ) ; log . info ( "Accepted connection above limit ( { } ) . Dropping . " , maxConnections ) ; return ; } } super . channelOpen ( ctx , e ) ; }  In the refactored code , the `numConnections . decrementAndGet ( ) ` statement is moved before the `ctx . getChannel ( ) . close ( ) ` statement to avoid double - decrement . Also , a `return` statement is added after the `ctx . getChannel ( ) . close ( ) ` statement to prevent the execution of the `super . channelOpen ( ctx , e ) ` statement in case the connection is dropped .
public Builder from ( int . . . nums ) { Arrays . sort ( nums ) ; this . matchers . add ( ( from , to , msg ) - > Arrays . binarySearch ( nums , from ) >= 0 ) ; return this ; }
public B channel ( Class < ? extends C > channelClass ) { return channelFactory ( new ReflectiveChannelFactory < C > ( ObjectUtil . checkNotNull ( channelClass , "channelClass" ) ) ) ; }
public void getActiveConditions_shouldGetActiveConditions ( ) { List < Condition > activeConditions = conditionService . getActiveConditions ( patientService . getPatient ( 2 ) ) ; Condition firstActiveCondition = activeConditions . get ( 0 ) ; Condition secondActiveCondition = activeConditions . get ( 1 ) ; Assert . assertTrue ( activeConditions . size ( ) == 2 ) ; Assert . assertEquals ( "2cc6880e - 2c46 - 11e4 - 9138 - a6c5e4d20fb7" , firstActiveCondition . getUuid ( ) ) ; Assert . assertEquals ( "2cc6880e - 2c46 - 15e4 - 9038 - a6c5e4d22fb7" , secondActiveCondition . getUuid ( ) ) ; }
public synchronized Inode < ? > getInodeOrNull ( ) { if ( ! fullPathExists ( ) ) { return null ; } List < Inode < ? > > inodeList = new ArrayList < > ( mLockList . getInodes ( ) ) ; return inodeList . get ( inodeList . size ( ) - 1 ) ; }  Explanation : The `newArrayList` method is not a standard Java method and is likely a custom method from a third - party library . It is unclear why it was used in the original code . Instead , the standard `ArrayList` constructor can be used to create a new list with the elements from `mLockList . getInodes ( ) ` .
private static < T > Set < T > findDuplicates ( Collection < T > list ) { Set < T > duplicates = new HashSet < > ( ) ; Set < T > uniques = new HashSet < > ( ) ; list . stream ( ) . forEach ( t - > { if ( ! uniques . add ( t ) ) { duplicates . add ( t ) ; } } ) ; return duplicates ; }
public boolean next ( ) throws IOException { for ( ; ; ) { LogQueueEntry t = queue . poll ( ) ; if ( t == null ) { return false ; } refName = t . lc . getRefName ( ) ; updateIndex = t . lc . getUpdateIndex ( ) ; entry = t . lc . getReflogEntry ( ) ; boolean include = includeDeletes || entry != null ; skipShadowed ( refName , updateIndex ) ; add ( t ) ; if ( include ) { return true ; } } }

private void loadPerspectiveAndCheckLoadingTime ( String perspectiveID , boolean headerIncluded ) { // long loadingStart = System . currentTimeMillis ( ) ; String standalonePerspectiveURL = getStandalonePerspectiveURL ( perspectiveID , headerIncluded ) ; driver . get ( standalonePerspectiveURL ) ; ApplicationLoadingPopup . waitForDisappearance ( PERSPECTIVE_LOADING_TIMEOUT ) ; BusyPopup . waitForDisappearance ( ) ; // double perspectiveLoadingTime = ( System . currentTimeMillis ( ) - loadingStart ) / ( double ) 1000 ; // TODO : What is the acceptable loading time ? Do we want to test this ? // assertThat ( perspectiveLoadingTime ) // . as ( "It should take less than " + PERSPECTIVE_LOADING_TIMEOUT + " seconds to load the perspective " + perspectiveID + " . " ) // . isLessThan ( PERSPECTIVE_LOADING_TIMEOUT ) ; }
public default IVariableBinding [ ] getSyntheticOuterLocals ( ) { return new IVariableBinding [ 0 ] ; }
protected void executeCommand ( ) { AuthenticationProfile profile = sessionDataContainer . getProfile ( getParameters ( ) . getSessionId ( ) ) ; sessionId = getParameters ( ) . getSessionId ( ) ; sourceIp = sessionDataContainer . getSourceIp ( getParameters ( ) . getSessionId ( ) ) ; if ( profile == null ) { setSucceeded ( false ) ; } else { sessionDataContainer . setSessionValid ( getParameters ( ) . getSessionId ( ) , false ) ; setSucceeded ( true ) ; } }
public static void updateNotification ( Context context , MasterSecret masterSecret , long threadId ) { if ( ! TextSecurePreferences . isNotificationsEnabled ( context ) ) { return ; } if ( visibleThread == threadId ) { DatabaseFactory . getThreadDatabase ( context ) . setRead ( threadId ) ; sendInThreadNotification ( context ) ; } else { updateNotification ( context , masterSecret , true ) ; } }
protected void fillOptions ( Map < Enum , String > options ) { options . put ( EnumModel . VAL1 , EnumModel . VAL1 . name ( ) ) ; options . put ( EnumModel . VAL2 , EnumModel . VAL2 . name ( ) ) ; options . put ( EnumModel . VAL3 , EnumModel . VAL3 . name ( ) ) ; options . put ( EnumModel . VAL4 , EnumModel . VAL4 . name ( ) ) ; }
public boolean removeQueues ( Queue . . . queues ) { removeQueues ( Arrays . stream ( queues ) . map ( Queue : : getName ) ) ; return super . removeQueues ( queues ) ; }
private static Object castIntegerToObect ( int value , Type type ) { if ( type == INTEGER || type == TINYINT || type == BIGINT ) { return ( long ) value ; } if ( type == VARCHAR ) { return String . valueOf ( value ) ; } if ( type == DOUBLE ) { return ( double ) value ; } throw new UnsupportedOperationException ( ) ; }
public void testXmlConfig ( ) throws IOException { EmbeddedCacheManager cm = null ; try { cm = new DefaultCacheManager ( "jpa - config . xml" ) ; Cache < String , KeyValueEntity > specificCache = cm . getCache ( "specificCache" ) ; validateConfig ( specificCache ) ; KeyValueEntity entity = new KeyValueEntity ( "k" , "v" ) ; specificCache . put ( entity . getK ( ) , entity ) ; } finally { if ( cm != null ) cm . stop ( ) ; } }
public boolean equals ( Object o ) { boolean equals = this == o || o instanceof SessionEditorInput && getURI ( ) . equals ( ( ( SessionEditorInput ) o ) . getURI ( ) ) ; if ( equals && o instanceof SessionEditorInput ) { EObject input = getInput ( false ) ; if ( input != null ) { SessionEditorInput otherSessionEditorInput = ( SessionEditorInput ) o ; return input . equals ( otherSessionEditorInput . getInput ( false ) ) ; } } return equals ; }
private void loadChildEntities ( LibraryDilution dilution ) throws IOException { if ( dilution . getLibrary ( ) != null ) { dilution . setLibrary ( libraryDao . get ( dilution . getLibrary ( ) . getId ( ) ) ) ; } if ( dilution . getTargetedSequencing ( ) != null ) { dilution . setTargetedSequencing ( targetedSequencingDao . get ( dilution . getTargetedSequencing ( ) . getId ( ) ) ) ; } }
GdkColor getContextColor ( ) { long /* int */ fontHandle = fontHandle ( ) ; long /* int */ context = OS . gtk_widget_get_style_context ( fontHandle ) ; int styleState = OS . gtk_widget_get_state_flags ( handle ) ; GdkRGBA rgba = new GdkRGBA ( ) ; rgba = display . styleContextGetColor ( context , styleState , rgba ) ; return display . toGdkColor ( rgba ) ; }
public Subquery parameter ( String listId , Object . . . values ) { if ( values == null || values . length == 0 || values [ 0 ] == null ) { return this ; } where . setToIntersection ( ) ; where . addParameter ( listId , values ) ; return this ; }
public int hashCode ( ) { int result = key ? 1 : 0 ; result = 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; return result ; }
public boolean doSynchronousPing ( ) { MerlinLog . d ( "Pinging : " + hostAddress ) ; try { responseCodeFetcher . from ( hostAddress ) ; } catch ( RequestException e ) { if ( e . causedByIO ( ) ) { return false ; } throw e ; } return true ; }
public T hasThisElement ( final Object val ) { Assert . parametersNotNull ( "val" , val ) ; return addCriteria ( FilterOperator . ELEMENT_MATCH , val , false ) ; }
public Builder setSSHDirectory ( final File sshDirectory ) { Assert . assertNotNull ( sshDirectory ) ; this . sshDirectory = sshDirectory ; return this ; }
public List < Attribute > getRequiredAttributes ( PerunSession sess , List < Service > services , Facility facility , Resource resource , User user , Member member ) throws MemberResourceMismatchException { Set < Attribute > attributes = new HashSet < > ( ) ; for ( Service service : services ) { attributes . addAll ( getRequiredAttributes ( sess , service , facility , resource , user , member ) ) ; } return new ArrayList < > ( attributes ) ; }
public void zrevrangeByScoreWithScores ( final byte [ ] key , final double max , final double min , final int offset , final int count ) { sendCommand ( ZREVRANGEBYSCORE , key , toByteArray ( max ) , toByteArray ( min ) , LIMIT . raw , toByteArray ( offset ) , toByteArray ( count ) , WITHSCORES . raw ) ; }
public void write ( int b ) throws IOException { mSingleCharWrite [ 0 ] = ( byte ) b ; write ( mSingleCharWrite ) ; }
public void deallocateFlow ( String flowId ) throws FlowNotFoundException , ProvisionerException { try { String netId = getNetworkSelector ( ) . findNetworkForFlowId ( flowId ) ; getNclController ( ) . deallocateFlow ( flowId , netId ) ; } catch ( Exception e ) { throw new ProvisionerException ( e ) ; } }
private String _encode ( String strVal ) { try { return URLEncoder . encode ( strVal , StandardCharsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
public boolean contains ( Object o ) { boolean contains = false ; if ( o != null ) { contains = super . contains ( o ) ; if ( ! contains ) { MarshalledEntry < K , V > me = persistenceManager . loadFromAllStores ( o , true ) ; contains = me != null ; } } return contains ; }
public boolean provides ( IOperation operation ) { if ( ! ( operation instanceof CreateDecoratorsOperation ) ) { return false ; } IDecoratorTarget decoratorTarget = ( ( CreateDecoratorsOperation ) operation ) . getDecoratorTarget ( ) ; View view = ( View ) decoratorTarget . getAdapter ( View . class ) ; return view != null && DDiagramEditPart . MODEL_ID . equals ( SiriusVisualIDRegistry . getModelID ( view ) ) ; }
public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert ( ) { CuratedContentPageObject ccp = new CuratedContentPageObject ( driver ) ; wikiURL = urlBuilder . getUrlForWiki ( MercuryWikis . MERCURY_CC ) ; ccp . openMercuryArticleByNameWithNoCacheBuster ( wikiURL , MercurySubpages . CC_MAIN_PAGE ) ; MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject ( driver , MercuryAlertComponentObject . AlertMessage . NOT_EXISTING_CATEGORY ) ; String oldUrl = driver . getCurrentUrl ( ) ; ccp . clickOnCuratedContentElementByIndex ( 2 ) ; Assertion . assertTrue ( mercuryAlert . isAlertMessageVisible ( ) ) ; ccp . waitForLoadingSpinnerToFinish ( ) ; Assertion . assertUrlEqualToCurrentUrl ( driver , oldUrl ) ; }
private void testUpdateInterface ( Guid interface_id ) { VdsNetworkInterface iface = dao . get ( interface_id ) ; iface . setName ( iface . getName ( ) . toUpperCase ( ) ) ; iface . setQos ( newQos ) ; dao . updateInterfaceForVds ( iface ) ; VdsNetworkInterface ifaced = dao . get ( interface_id ) ; assertEquals ( iface . getName ( ) , ifaced . getName ( ) ) ; assertEquals ( iface . getQos ( ) , ifaced . getQos ( ) ) ; }
public PatientProgram savePatientProgram ( PatientProgram patientProgram ) throws DAOException { CustomDatatypeUtil . saveAttributesIfNecessary ( patientProgram ) ; if ( patientProgram . getPatientProgramId ( ) == null ) { sessionFactory . getCurrentSession ( ) . save ( patientProgram ) ; } else { sessionFactory . getCurrentSession ( ) . merge ( patientProgram ) ; } return patientProgram ; }
public UploadDirectoryToCDN ( String username , String apiKey ) { BlobStoreContext context = ContextBuilder . newBuilder ( PROVIDER ) . credentials ( username , apiKey ) . buildView ( BlobStoreContext . class ) ; storage = context . getBlobStore ( ) ; rackspace = context . unwrap ( CloudFilesApiMetadata . CONTEXT_TOKEN ) . getApi ( ) ; // can use unwrapApi ( ) in jclouds 1 . 7 . 0 }
public SslContextBuilder keyManager ( KeyManager keyManager ) { if ( forServer ) { checkNotNull ( keyManager , "keyManager required for servers" ) ; } if ( keyManager != null ) { this . keyManagerFactory = new KeyManagerFactoryWrapper ( keyManager ) ; } else { this . keyManagerFactory = null ; } keyCertChain = null ; key = null ; keyPassword = null ; return this ; }
protected boolean isTypeSupported ( Class < T > clazz ) { // TODO : Add other types ? Float , etc if ( String . class . isAssignableFrom ( clazz ) || Integer . class . isAssignableFrom ( clazz ) || Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } return false ; }
private List < Person > createModel ( ) { List < Person > elements = new ArrayList < Person > ( 4 ) ; elements . add ( new Person ( "Tom" , "Schindl" , "tom . schindl@bestsolution . at" ) ) ; elements . add ( new Person ( "Tod" , "Creasey" , "Tod_Creasey@ca . ibm . com" ) ) ; elements . add ( new Person ( "Wayne" , "Beaton" , "wayne@eclipse . org" ) ) ; return elements ; }
protected void updateIteration ( ) { refreshIteration = ( ++ refreshIteration ) % NUMBER_VMS_REFRESHES_BEFORE_SAVE ; }
public void add ( E newInterval ) { super . add ( newInterval ) ; }
public RuleEvaluationWorker ( Map < String , Set < String > > docsToCheckAndEvents ) { this . docsToCheckAndEvents = docsToCheckAndEvents ; List < String > docs = new ArrayList < > ( ) ; docs . addAll ( docsToCheckAndEvents . keySet ( ) ) ; setDocuments ( Framework . getService ( RepositoryManager . class ) . getDefaultRepositoryName ( ) , docs ) ; }
private static String getTestingAlias ( GoImportSpec testingImportSpec ) { return testingImportSpec == null ? GoConstants . TESTING_PATH : ! testingImportSpec . isDot ( ) ? StringUtil . notNullize ( testingImportSpec . getAlias ( ) , GoConstants . TESTING_PATH ) : "" ; }
public SystemPurposeComplianceStatusDTO ( SystemPurposeComplianceStatusDTO source ) { super ( source ) ; }
public MapOperation ( ) { }
private static Instant retrieveDeadlineTimestamp ( JobDataMap jobDataMap ) { Object timestamp = jobDataMap . get ( MESSAGE_TIMESTAMP ) ; if ( timestamp instanceof String ) { return Instant . parse ( timestamp . toString ( ) ) ; } return Instant . ofEpochMilli ( ( long ) timestamp ) ; }
AggregatorFactory [ ] getMetrics ( ) { return metrics ; }
public void prepare ( ) throws IOException { e = SQLExecutor . builder ( clusterService ) . addTable ( "create table t ( " + " id integer primary key , " + " qty integer constraint check_qty_gt_zero check ( qty > 0 ) , " + " constraint check_id_ge_zero check ( id >= 0 ) " + " ) " ) . build ( ) ; plannerContext = e . getPlannerContext ( clusterService . state ( ) ) ; }
public void setUp ( ) { jUnitCore . addListener ( testListener ) ; }
protected boolean validate ( ) { if ( ! canRunActionOnNonManagedVm ( ) ) { return false ; } if ( ! isInternalExecution ( ) && ! ObjectIdentityChecker . canUpdateField ( getVm ( ) , "clusterId" , getVm ( ) . getStatus ( ) ) ) { addValidationMessage ( EngineMessage . VM_STATUS_NOT_VALID_FOR_UPDATE ) ; return false ; } ChangeVmClusterValidator validator = ChangeVmClusterValidator . create ( this , getParameters ( ) . getClusterId ( ) , getParameters ( ) . getVmCustomCompatibilityVersion ( ) ) ; return validator . validate ( ) ; }
public TrustManagerFactory getTrustMgr ( String serverName ) { return trustMgrMap . get ( serverName ) ; }
public TextEdit formatModuleInfoFile ( int kind , String source , int offset , int length , int indentationLevel , String lineSeparator ) { boolean tmp = this . isInModuleInfo ; try { this . isInModuleInfo = true ; return format ( kind , source , new IRegion [ ] { new Region ( offset , length ) } , indentationLevel , lineSeparator ) ; } finally { this . isInModuleInfo = tmp ; } }
public < K , V > RemoteCache < K , V > getCache ( String cacheName ) { RemoteCache < K , V > cache = hotrodClient . getCache ( cacheName ) ; if ( cache == null ) { throw log . expectedCachesNotDefined ( Collections . singleton ( cacheName ) ) ; } return cache ; }
public static Object valueForStringWithType ( String value , VoltType type ) { if ( type == VoltType . NULL ) { return null ; } // leverage existing ( rather heavyweight ) code to convert param types Object retval = ParameterConverter . tryToMakeCompatible ( type . classFromType ( ) , value ) ; // check the result type in an assert assert ( ParameterConverter . verifyParameterConversion ( retval , type . classFromType ( ) ) ) ; return retval ; }
public void testContructor ( ) throws IOException { String code = "S2020 - 04 - 04" ; ReportingPeriod period = ReportingPeriod . from ( code ) ; assertEquals ( period . getClass ( ) , SinceX . class ) ; }
public void testGetConnectableFileStorageConnectionsByStorageType ( ) { List < StorageServerConnections > conns = dao . getConnectableStorageConnectionsByStorageType ( FixturesTool . STORAGE_POOL_NFS_2 , StorageType . NFS ) ; assertNotNull ( conns ) ; assertEquals ( 1 , conns . size ( ) ) ; for ( StorageServerConnections conn : conns ) { assertEquals ( StorageType . NFS , conn . getstorage_type ( ) ) ; } }
public static void setOverrideFileName ( String . . . path ) { fOverridePath = path ; fOverride = true ; }
void addChanges ( Collection < String > filesToUpdate , Collection < IResource > resourcesToUpdate ) { synchronized ( lock ) { files . addAll ( filesToUpdate ) ; resources . addAll ( resourcesToUpdate ) ; } if ( ! filesToUpdate . isEmpty ( ) ) schedule ( defaultDelay ) ; }
public static synchronized String getEncryptionKey ( String name ) { if ( CACHED_ENCRYPTION_KEYS . get ( name ) == null ) { generateEncryptionKey ( name ) ; } return CACHED_ENCRYPTION_KEYS . get ( name ) ; }
public void init ( IEditorSite site , IEditorInput input ) { super . init ( site , input ) ; TaskData taskData = getModel ( ) . getTaskData ( ) ; if ( taskData != null ) { GerritChange change = GerritUtil . getChange ( taskData ) ; final ChangeDetailX detail = change . getChangeDetail ( ) ; review = GerritUtil . toReview ( detail ) ; } }
public ISnapshotInfo getSnapshotInfo ( String sessionName , IProgressMonitor monitor ) throws ExecutionException { return null ; }
public long getEntryLastModified ( ) { if ( modTimes == null ) return 0 ; Long cutOff = Long . valueOf ( super . getEntryLastModified ( ) + 1 ) ; SortedSet < Long > head = modTimes . headSet ( cutOff ) ; return head . isEmpty ( ) ? 0 : head . last ( ) . longValue ( ) ; }
public ParameterizedSqlFactory ( String initialSql ) { sqlStringBuilder = new StringBuilder ( initialSql ) ; parameters = new ArrayList < > ( ) ; }
public long getReadyTimestamp ( Constraints viewConstraints ) { String normalizedConstraints = getNormalizedConstraints ( viewConstraints ) ; Path signalPath = new Path ( signalDirectory , normalizedConstraints ) ; // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem . getFileStatus ( signalPath ) ; return signalStatus . getModificationTime ( ) ; } catch ( final FileNotFoundException ex ) { // empty , will be thrown when the signal path doesn't exist } return - 1 ; } catch ( IOException e ) { throw new DatasetIOException ( "Could not access signal path : " + signalPath , e ) ; } }
private boolean hostHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; if ( cluster == null ) { return false ; } ArchitectureType archType = cluster . getArchitecture ( ) ; return ArchitectureType . ppc64 . equals ( archType ) || ArchitectureType . ppc64le . equals ( archType ) || ArchitectureType . ppcle . equals ( archType ) ; }
private static String getExtension ( String name ) { int ext = name . lastIndexOf ( ' . ' ) ; return 0 < ext ? name . substring ( ext ) : "" ; }
public void checkpoint ( ) { }
private void recalculateMacsCount ( ) { if ( ! validate ( ) ) { setAvailableMacsCount ( - 1 ) ; return ; } if ( macRange . getMacPoolId ( ) == null ) { String from = getLeftBound ( ) . getEntity ( ) ; String to = getRightBound ( ) . getEntity ( ) ; long count = MacRangeValidation . macToLong ( to ) - MacRangeValidation . macToLong ( from ) + 1 ; setAvailableMacsCount ( ( int ) count ) ; } }
public void setup ( ) { buffer = new DiskBuffer ( BUFFER_DIR , maxEvents ) ; }
private boolean filterInvalid ( Position position ) { if ( filterInvalid == true ) { return ! position . getValid ( ) || position . getLatitude ( ) > 90 || position . getLongitude ( ) > 180 || position . getLatitude ( ) < - 90 || position . getLongitude ( ) < - 180 ; } return false ; }
public Set < Location > getAllowedLocations ( ) { return new HashSet < Location > ( asList ( CONSTRUCTOR , METHOD , FIELD , OVERVIEW , PACKAGE , TYPE ) ) ; }
public String getTasksJsonString ( long taskId ) throws JSONException { TaskObject task = TaskObject . get ( taskId ) ; return ConvertSprintBacklog . getTaskJsonString ( task ) ; }
private void addVolumeToDb ( final GlusterVolumeEntity createdVolume ) { // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume . setClusterId ( getVdsGroupId ( ) ) ; DbFacade . getInstance ( ) . getGlusterVolumeDao ( ) . save ( createdVolume ) ; }
public Sheet getDataSheet ( File file ) { Workbook wb = null ; try { stream = new PushbackInputStream ( new FileInputStream ( file ) ) ; wb = WorkbookFactory . create ( stream ) ; } catch ( Exception e ) { log . error ( "Workbook creation exception : " + e ) ; } return wb . getSheetAt ( 0 ) ; }
public boolean updateAttributes ( ) { OSProcess process = operatingSystem . getProcess ( this . processID ) ; if ( process == null ) { LOG . debug ( "No process found : { } " , this . processID ) ; return false ; } copyValuesToThisProcess ( process ) ; return true ; }
public boolean isMissingHookConflict ( ) { return ( conflictStatus & MISSING_HOOK . getValue ( ) ) == MISSING_HOOK . getValue ( ) ; }
public Map < AccountGroup . UUID , GroupMembersList > getUnresolvedGroups ( final boolean recursive ) { if ( ! recursive ) { if ( isResolved ( ) ) { return Collections . emptyMap ( ) ; } return Collections . singletonMap ( getGroup ( ) . getGroupUUID ( ) , this ) ; } return getAllUnresolvedGroups ( new HashSet < AccountGroup . Id > ( ) ) ; }
public boolean nextBoolean ( ) throws IOException { requirePeek ( ) ; boolean value = parser . getBooleanValue ( ) ; clearPeek ( ) ; return value ; }
public boolean closeOnProtocolViolation ( ) { return closeOnProtocolViolation ; }
public String getSelinuxEnforceMode ( ) { return selinuxEnforceMode ; }
public void startThreads ( ) { synchronized ( this ) { if ( ! this . threadStarted ) { int nbThreads = this . configuration . getProperty ( "mentions . poolSize" , 1 ) ; for ( int i = 0 ; i < nbThreads ; i ++ ) { startConsumer ( ) ; } this . threadStarted = true ; } } }
public void init ( EObject original , EditingDomain editingDomain ) { List < EStructuralFeature > features = featuresProvider . getFeatures ( original ) ; initControlFactory ( editingDomain , original ) ; for ( final EStructuralFeature feature : features ) { createControlForFeature ( feature ) ; } // toolkit . paintBordersFor ( main ) ; this . layout ( ) ; }
public List < Annotation > getQualifiers ( ) { return Arrays . asList ( ( Annotation ) new org . jboss . arquillian . warp . servlet . AfterServlet ( ) { @Override public Class < ? extends Annotation > annotationType ( ) { return org . jboss . arquillian . warp . servlet . AfterServlet . class ; } } ) ; }
protected void initialize ( Subject subj ) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig ( subj ) ; remoteCacheManager = new RemoteCacheManager ( config , true ) ; remoteCache = remoteCacheManager . getCache ( TEST_CACHE_NAME ) ; }
LauncherDiscoveryRequest buildRequest ( Bundle bundle ) { List < DiscoverySelector > selectors = new ArrayList < > ( baseSelectors . size ( ) + 1 ) ; selectors . addAll ( baseSelectors ) ; selectors . add ( BundleSelector . selectBundle ( bundle ) ) ; return LauncherDiscoveryRequestBuilder . request ( ) . configurationParameter ( BundleEngine . CHECK_UNRESOLVED , unresolved ) . selectors ( selectors ) . build ( ) ; }
protected void statementExecuteUpdateBefore ( StatementProxy statement , String sql ) { super . statementExecuteUpdateBefore ( statement , sql ) ; Before ( statement , sql ) ; }
public static DecoderResult failure ( Throwable cause ) { return new DecoderResult ( ObjectUtil . checkNotNull ( cause , "cause" ) ) ; }
private void writeObject ( Schema schema , GenericRecord datum ) throws Exception { BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( new ByteArrayOutputStream ( ) , null ) ; GenericDatumWriter < GenericData . Record > writer = new GenericDatumWriter < GenericData . Record > ( schema ) ; writer . write ( schema , datum , encoder ) ; }
public Collection < String > getNames ( ) { final Set < String > names = new HashSet < > ( named . keySet ( ) ) ; namedArgumentFinder . forEach ( args - > names . addAll ( args . getNames ( ) ) ) ; return Collections . unmodifiableSet ( names ) ; }
public FBOConfig getFboConfig ( ResourceUrn fboName ) { FBOConfig fboConfig = fboConfigs . get ( fboName ) ; if ( fboConfig == null ) { logger . warn ( "Failed to retrieve FBOConfig '" + fboName + "' ! " ) ; } return fboConfig ; }
protected void setKey ( Input newInput , char newKeyChar ) { this . input = newInput ; this . keyChar = newKeyChar ; }
public Builder < EvictionConfiguration > configure ( OperationContext context , ModelNode model ) throws OperationFailedException { EvictionStrategy strategy = ModelNodes . asEnum ( STRATEGY . getDefinition ( ) . resolveModelAttribute ( context , model ) , EvictionStrategy . class ) ; this . builder . strategy ( strategy ) ; if ( strategy . isEnabled ( ) ) { this . builder . type ( EvictionType . COUNT ) . size ( MAX_ENTRIES . getDefinition ( ) . resolveModelAttribute ( context , model ) . asLong ( ) ) ; } return this ; }
public void closed ( BoltConnection connection ) { String id = connection . id ( ) ; try { CompletableFuture < Boolean > currentFuture = activeWorkItems . remove ( id ) ; if ( currentFuture != null ) { currentFuture . cancel ( true ) ; } } finally { activeConnections . remove ( id ) ; } }
public void testIsExternalVM ( ) throws Exception { XmlDocument xmlDocument = new XmlDocument ( getXmlOvfData ( ) ) ; assertFalse ( "VM should not be external VM" , OvfUtils . isExternalVM ( xmlDocument ) ) ; }
public static boolean folderContains ( File folder , String filename ) { if ( folder == null ) { return false ; } File [ ] fileList = folder . listFiles ( ) ; if ( fileList == null ) { return false ; } for ( File f : fileList ) { if ( f . getName ( ) . equals ( filename ) ) { return true ; } } return false ; }
public void addWhiteListPatterns ( String . . . patterns ) { Collections . addAll ( this . whiteListPatterns , patterns ) ; }
private Long getRegistrationMillis ( String playerName ) { PlayerAuth auth = playerCache . getAuth ( playerName ) ; if ( auth == null ) { auth = dataSource . getAuth ( playerName ) ; } if ( auth != null ) { return auth . getRegistrationDate ( ) ; } return null ; }
public HashConfigurationBuilder capacityFactor ( float capacityFactor ) { if ( capacityFactor < 0 ) throw new IllegalArgumentException ( "capacityFactor must be positive" ) ; this . capacityFactor = capacityFactor ; return this ; }
public synchronized void onHeaders ( Response response ) { long length = response . getHeaders ( ) . getLongField ( HttpHeader . CONTENT_LENGTH . asString ( ) ) ; if ( length > maxLength ) { response . abort ( new ResponseTooLargeException ( ) ) ; } }
public WorkspaceItem build ( ) { return workspaceItem ; }
public static SortedMap < String , Charset > requiredCharsets ( ) { return REQUIRED_CHARSETS ; }
protected void checkProject ( Project project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . getProjectApi ( ) . getProject ( project . getId ( ) ) . toString ( ) ) ; assertTrue ( project . getState ( ) != null ) ; assertTrue ( project . getState ( ) != Project . State . UNRECOGNIZED ) ; }
public AtsProgramArtifactToken ( Long id , String name , ArtifactTypeToken artifactType ) { super ( id , name , CoreBranches . COMMON , artifactType ) ; }
public void setUseBulkWriteOperations ( final boolean useBulkWriteOperations ) { }
public void setActionConfirmationMessage ( String message ) { boolean isNonEmptyMessage = message != null ; if ( isNonEmptyMessage ) { actionConfirmationMessage . setText ( message ) ; } }
public void close ( ) throws InterruptedException { close ( false ) ; }
protected void recursivelyPrint ( AbstractPlanNode node , StringBuilder sb ) { recursivelyPrint ( node , sb , 0 ) ; }
public void update ( int inputIndex ) { status . setTargetOutputRowCount ( super . update ( inputIndex , status . getOutPosition ( ) ) ) ; logger . debug ( "BATCH_STATS , incoming { } : { } " , inputIndex == 0 ? "left" : "right" , getRecordBatchSizer ( inputIndex ) ) ; }
private int getNextPosition ( ) throws CoreException { if ( nextMemberPosition < 0 ) { nextMemberPosition = 0 ; while ( nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord ( nextMemberPosition ) != 0 ) { nextMemberPosition ++ ; } } return nextMemberPosition ; }
public BulkResponse executeRequest ( ) { if ( bulkRequest . numberOfActions ( ) == 0 ) { return null ; } logger . trace ( " [ { } ] ES API CALL : bulk request with { } actions" , ( ) - > jobId , ( ) - > bulkRequest . numberOfActions ( ) ) ; BulkResponse bulkResponse = resultsPersisterService . bulkIndexWithRetry ( bulkRequest , jobId , shouldRetry , msg - > auditor . warning ( jobId , "Bulk indexing of annotations failed " + msg ) ) ; bulkRequest = new BulkRequest ( AnnotationIndex . WRITE_ALIAS_NAME ) ; return bulkResponse ; }
public int size ( ) { int size = 0 ; // We have to loop through to make sure to remove expired entries for ( Iterator < InternalCacheEntry < K , V > > iter = iterator ( ) ; iter . hasNext ( ) ; ) { iter . next ( ) ; if ( ++ size == Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return size ; }
public static File getDiskCacheDir ( Context context , String uniqueName ) { // Check if media is mounted or storage is built - in , if so , try and use external cache dir // otherwise use internal cache dir . final String cachePath ; if ( Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) && context . getExternalCacheDir ( ) != null ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return new File ( cachePath + File . separator + uniqueName ) ; }
public static String getBucketName ( URI uri ) { if ( uri . getHost ( ) != null ) { return uri . getHost ( ) ; } if ( uri . getUserInfo ( ) == null ) { return uri . getAuthority ( ) ; } throw new IllegalArgumentException ( "Unable to determine S3 bucket from URI . " ) ; }
private MustacheFactory createNewMustacheFactory ( Class < ? extends View > key ) { return new DefaultMustacheFactory ( fileRoot . isPresent ( ) ? new FileSystemResolver ( fileRoot . get ( ) ) : new PerClassMustacheResolver ( key ) ) ; }
public boolean isValidValue ( final Object element ) { boolean result = super . isValidValue ( element ) ; if ( result ) { EObject eObject = EMFHelper . getEObject ( element ) ; result = ( ProtocolUtils . isProtocol ( eObject ) && ! SystemElementsUtils . isBaseProtocol ( ( Collaboration ) eObject ) ) ; } return result ; }
public void testLogin ( ) throws Throwable { runOnMainSync ( new Runnable ( ) { @Override public void run ( ) { loginTestTask . execute ( ) ; } } ) ; completionLatch . await ( ) ; }
public static void warnIfDeprecatedDnsLookupValue ( AbstractConfig config ) { String clientDnsLookupValue = config . getString ( CLIENT_DNS_LOOKUP_CONFIG ) ; if ( clientDnsLookupValue . equals ( ClientDnsLookup . DEFAULT . toString ( ) ) ) log . warn ( "Configuration ' { } ' with value ' { } ' is deprecated and will be removed in " + "future version . Please use ' { } ' or another non - deprecated value . " , CLIENT_DNS_LOOKUP_CONFIG , ClientDnsLookup . DEFAULT , ClientDnsLookup . USE_ALL_DNS_IPS ) ; }
public HdfsCopyStats ( String source , File destination , boolean enableStatsFile , int maxVersionsStatsFile , boolean isFileCopy , HdfsPathInfo pathInfo ) { this . sourceFile = source ; this . totalBytesTransferred = 0L ; this . bytesTransferredSinceLastReport = 0L ; this . pathInfo = pathInfo ; this . lastReportNs = System . nanoTime ( ) ; this . startTimeMS = System . currentTimeMillis ( ) ; initializeStatsFile ( destination , enableStatsFile , maxVersionsStatsFile , isFileCopy ) ; }
private void writeAlias ( VmDevice device ) { writer . writeStartElement ( "alias" ) ; writer . writeAttributeString ( "name" , String . format ( "ua - % s" , device . getId ( ) . getDeviceId ( ) ) ) ; writer . writeEndElement ( ) ; }
public ChartData ( IDataChartProvider < ? > provider , List < ChartSeries > series ) { fProvider = provider ; fSeries = ImmutableList . copyOf ( series ) ; }
protected boolean isRegistered ( final String uuid ) { return handlers . containsKey ( uuid ) ; }
public Class < ? > defineClass ( String name , byte [ ] bytecode ) { return defineClass ( name , convertClassToResourcePath ( name ) , bytecode ) ; }
public boolean onOptionsItemSelected ( MenuItem item ) { // home references the app icon if ( item . getItemId ( ) == android . R . id . home ) { toggle ( ) ; // toggles the state of the sliding menu if ( getSlidingMenu ( ) . isMenuShowing ( ) && menu . isAdded ( ) ) { setTitle ( ( ( ITitleable ) menu ) . getTitle ( ) ) ; } return true ; } return false ; }
public static ParcelFileDescriptor fromSocket ( Socket socket ) { FileDescriptor fd = socket . getFileDescriptor$ ( ) ; try { return fd != null ? ParcelFileDescriptor . dup ( fd ) : null ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
private String getThemePrefixedPath ( String path ) { String prefix = themeProperties != null ? themeProperties . get ( IntroTheme . ATT_ID ) : null ; prefix = prefix == null ? "" : prefix . trim ( ) ; // $NON - NLS - 1$ if ( prefix . length ( ) == 0 ) { return null ; } return prefix + Path . SEPARATOR + path ; }
protected void writeString ( int majorType , byte [ ] bytes ) throws IOException { int len = ( bytes == null ) ? 0 : bytes . length ; writeType ( majorType , len ) ; if ( len > 0 ) { m_os . write ( bytes ) ; } }
private void checkLogData ( long address , ILogData logData ) { if ( logData == null || logData . getType ( ) == DataType . EMPTY ) { throw new RuntimeException ( "Unexpected return of empty data at address " + address + " on read" ) ; } if ( logData . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } }
private static void merge ( AggregatedCalledFunction destination , AggregatedCalledFunction source ) { long sourceDuration = source . getDuration ( ) ; long sourceSelfTime = source . getSelfTime ( ) ; destination . addToDuration ( sourceDuration ) ; destination . addToSelfTime ( sourceSelfTime ) ; destination . fStatistics . update ( source . fStatistics . getMaxSegment ( ) , source . fStatistics . getMinSegment ( ) , sourceDuration , sourceSelfTime ) ; // merge the children callees . mergeChildren ( destination , source ) ; }
@Override protected void doEnqueue ( Callback < V > callback ) { sendRequest ( ) . handle ( ( response , t ) - > { if ( t != null ) { callback . onError ( t ) ; } else { try { V value = parseResponse ( response , bodyConverter ) ; callback . onSuccess ( value ) ; } catch ( Throwable t1 ) { propagateIfFatal ( t1 ) ; callback . onError ( t1 ) ; } } return null ; } ) ; }
public SpiTransaction createServerTransaction ( boolean isExplicit , int isolationLevel ) { SpiTransaction t = transactionManager . createTransaction ( isExplicit , isolationLevel ) ; if ( isExplicit ) { try { transactionScopeManager . set ( t ) ; } catch ( PersistenceException existingTransactionError ) { t . end ( ) ; throw existingTransactionError ; } } return t ; }
C baseApply ( ) { final TreeMap < String , String > t = new TreeMap < String , String > ( validate ( ) ) ; C child = children . get ( t ) ; if ( child == null ) { child = newChild ( ) ; children . put ( t , child ) ; } return child ; }
public void onConnect ( String message ) { debugView . showPermanently ( getString ( R . string . connected ) ) ; switchableView . setDisplayedChild ( 1 ) ; }

import java . util . ArrayList ; /* * * This class provides helper functions for Wifi connectivity related modules to * access WifiNative . It starts with firmware roaming . TODO ( b / 34819513 ) : Move operations * such as connection to network and legacy framework roaming here . */ public class WifiConnectivityHelper { private static final String TAG = "WifiConnectivityHelper" ; private final WifiNative mWifiNative ; private boolean mFirmwareRoamingSupported = false ; private int mMaxNumBlacklistBssid = INVALID_LIST_SIZE ; private int mMaxNumWhitelistSsid = INVALID_LIST_SIZE ; WifiConnectivityHelper ( WifiNative wifiNative ) { mWifiNative = wifiNative ; } /* * * Query firmware if it supports * { @link android . net . wifi . WifiManager#WIFI_FEATURE_CONTROL_ROAMING } . If yes , get the firmware * roaming capabilities . */ public void getFirmwareRoamingInfo ( ) { int fwFeatureSet = mWifiNative . getSupportedFeatureSet ( ) ; Log . d ( TAG , "Firmware supported feature set : " + Integer . toHexString ( fwFeatureSet ) ) ; mFirmwareRoamingSupported = ( fwFeatureSet & WIFI_FEATURE_CONTROL_ROAMING ) > 0 ;
mMaxNumWhitelistSsid = - 1 ; if ( mFirmwareRoamingSupported ) { WifiNative . RoamingCapabilities roamingCap = new WifiNative . RoamingCapabilities ( ) ; if ( mWifiNative . getRoamingCapabilities ( roamingCap ) ) { mMaxNumBlacklistBssid = roamingCap . maxBlacklistSize ; mMaxNumWhitelistSsid = roamingCap . maxWhitelistSize ; Log . d ( TAG , "Firmware roaming capabilities : max num blacklist bssid = " + mMaxNumBlacklistBssid + " max num whitelist ssid = " + mMaxNumWhitelistSsid ) ; } else { Log . e ( TAG , "Failed to get firmware roaming capabilities" ) ; } if ( fallbackToFrameworkRoaming ) { Log . e ( TAG , "Fall back to framework roaming" ) ; mFirmwareRoamingSupported = false ; return false ; } }
mMaxNumWhitelistSsid = roamingCap . maxWhitelistSize ; Log . d ( TAG , "Firmware roaming capabilities : max num blacklist bssid = " + mMaxNumBlacklistBssid + " max num whitelist ssid = " + mMaxNumWhitelistSsid ) ; } else { Log . e ( TAG , "Failed to get firmware roaming capabilities" ) ; } } } /* * * Return if firmware roaming is supported . */ public boolean isFirmwareRoamingSupported ( ) { return mFirmwareRoamingSupported ; } /* * * Get the maximum size of BSSID blacklist firmware supports . * * @return INVALID_LIST_SIZE if firmware roaming is not supported , or * maximum size of the BSSID blacklist firmware supports . */ public int getMaxNumBlacklistBssid ( ) { if ( mFirmwareRoamingSupported ) { return mMaxNumBlacklistBssid ; } else { Log . e ( TAG , "Firmware roaming is not supported" ) ; return - 1 ; } } /* * * Return the maximum size of SSID whitelist . */ public int getMaxNumWhitelistSsid ( ) { if ( mFirmwareRoamingSupported ) { return mMaxNumWhitelistSsid ; } else { Log . e ( TAG , "Firmware roaming is not supported" ) ; return - 1 ; } } /* *
public int getMaxNumBlacklistBssid ( ) { if ( mFirmwareRoamingSupported ) { return mMaxNumBlacklistBssid ; } else { Log . e ( TAG , "getMaxNumBlacklistBssid : Firmware roaming is not supported" ) ; return INVALID_LIST_SIZE ; }
public int getMaxNumBlacklistBssid ( ) { if ( mFirmwareRoamingSupported ) { return mMaxNumBlacklistBssid ; } else { Log . e ( TAG , "getMaxNumBlacklistBssid : Firmware roaming is not supported" ) ; return INVALID_LIST_SIZE ; }
public int getMaxNumWhitelistSsid ( ) { if ( mFirmwareRoamingSupported ) { return mMaxNumWhitelistSsid ; } else { Log . e ( TAG , "getMaxNumWhitelistSsid : Firmware roaming is not supported" ) ; return INVALID_LIST_SIZE ; }
/* * Sets up test . */ @Before public void setUp ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; setupWifiNative ( ) ; mWifiConnectivityHelper = new WifiConnectivityHelper ( mWifiNative ) ; } /* * Cleans up test . */ @After public void cleanup ( ) { validateMockitoUsage ( ) ; } private WifiConnectivityHelper mWifiConnectivityHelper ; @Mock private WifiNative mWifiNative ; @Captor ArgumentCaptor < WifiNative . RoamingConfig > mRoamingConfigCaptor ; private int mFeatureSetValue ; private static final String TAG = "WifiConnectivityHelperTest" ; private static final int MAX_BSSID_BLACKLIST_SIZE = 16 ; private static final int MAX_SSID_WHITELIST_SIZE = 8 ; private void setupWifiNative ( ) { // Return firmware roaming feature as supported by default . when ( mWifiNative . getSupportedFeatureSet ( ) ) . thenReturn ( WIFI_FEATURE_CONTROL_ROAMING ) ; doAnswer ( new AnswerWithArguments ( ) { public boolean answer ( WifiNative . RoamingCapabilities roamCap ) throws Exception { roamCap . maxBlacklistSize = MAX_BSSID_BLACKLIST_SIZE ; roamCap . maxWhitelistSize = MAX_SSID_WHITELIST_SIZE ; return true ;
public void verifyFirmwareRoamingCapabilityWithFailureNativeCall ( ) { doAnswer ( new AnswerWithArguments ( ) { public boolean answer ( WifiNative . RoamingCapabilities roamCap ) throws Exception { roamCap . maxBlacklistSize = - 1 ; roamCap . maxWhitelistSize = - 1 ; return false ; } } ) . when ( mWifiNative ) . getRoamingCapabilities ( anyObject ( ) ) ; assertFalse ( mWifiConnectivityHelper . getFirmwareRoamingInfo ( ) ) ; assertFalse ( mWifiConnectivityHelper . isFirmwareRoamingSupported ( ) ) ; assertEquals ( WifiConnectivityHelper . INVALID_LIST_SIZE , mWifiConnectivityHelper . getMaxNumBlacklistBssid ( ) ) ; assertEquals ( WifiConnectivityHelper . INVALID_LIST_SIZE , mWifiConnectivityHelper . getMaxNumWhitelistSsid ( ) ) ;
public void verifySetFirmwareRoamingConfigurationWithGoodInput ( ) { assertTrue ( mWifiConnectivityHelper . getFirmwareRoamingInfo ( ) ) ; ArrayList < String > blacklist = buildBssidBlacklist ( MAX_BSSID_BLACKLIST_SIZE ) ; ArrayList < String > whitelist = buildSsidWhitelist ( MAX_SSID_WHITELIST_SIZE ) ; assertTrue ( mWifiConnectivityHelper . setFirmwareRoamingConfiguration ( blacklist , whitelist ) ) ;
* [ or other varieties of that API ] . * * * @hide */ public String createNetworkSpecifierPassphrase ( @Nullable PeerHandle peerHandle , @NonNull String passphrase ) { if ( passphrase == null || passphrase . length ( ) == 0 ) { throw new IllegalArgumentException ( "Passphrase must not be null or empty" ) ; } if ( mTerminated ) { Log . w ( TAG , "createNetworkSpecifierPassphrase : called on terminated session" ) ; return null ; } int role = this instanceof SubscribeDiscoverySession ? WifiAwareManager . WIFI_AWARE_DATA_PATH_ROLE_INITIATOR : WifiAwareManager . WIFI_AWARE_DATA_PATH_ROLE_RESPONDER ; return mgr . createNetworkSpecifier ( mClientId , role , mSessionId , peerHandle , null , passphrase ) ; } } /* * * Create a { @link android . net . NetworkRequest . Builder#setNetworkSpecifier ( String ) } for an
* Copyright ( C ) 2017 The Android Open Source Project * * Licensed under the Apache License , Version 2 . 0 ( the "License" ) ; * you may not use this file except in compliance with the License . * You may obtain a copy of the License at * * http :/ / www . apache . org / licenses / LICENSE - 2 . 0 * * Unless required by applicable law or agreed to in writing , software * distributed under the License is distributed on an "AS IS" BASIS , * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . * See the License for the specific language governing permissions and * limitations under the License . */ import java . lang . reflect . Method ; public class Main { // Workaround for b / 18051191 . class InnerClass { } public static void main ( String [ ] args ) throws Exception { Class < ? > c = Class . forName ( "IrreducibleLoop" ) ; Method m = c . getMethod ( "simpleLoop" , int . class ) ; Object [ ] arguments = { 42 } ; System . out . println ( m . invoke ( null , arguments ) ) ; } }
boolean waitForCallback ( int callback ) { synchronized ( mLocalLock ) { boolean found = mCallbackQueue . remove ( callback ) ; if ( found ) { return true ; } mCurrentWaitForCallback = callback ; mBlocker = new CountDownLatch ( 1 ) ; } try { return mBlocker . await ( WAIT_FOR_AWARE_CHANGE_SECS , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { return false ; }
boolean hasCallbackAlreadyHappened ( int callback ) { synchronized ( mLocalLock ) { return mCallbackQueue . contains ( callback ) ; } return false ;
public void testSubscribeDiscoverySuccess ( ) { if ( ! TestUtils . shouldTestWifiAware ( getContext ( ) ) ) { return ; } final String serviceName = "ValidName" ; WifiAwareSession session = attachAndGetSession ( ) ; SubscribeConfig subscribeConfig = new SubscribeConfig . Builder ( ) . setServiceName ( serviceName ) . build ( ) ; DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest ( ) ; // 1 . subscribe session . subscribe ( subscribeConfig , discoveryCb , null ) ; assertTrue ( "Subscribe started" , discoveryCb . waitForCallback ( DiscoverySessionCallbackTest . ON_SUBSCRIBE_STARTED ) ) ; SubscribeDiscoverySession discoverySession = discoveryCb . getSubscribeDiscoverySession ( ) ; assertNotNull ( "Subscribe session" , discoverySession ) ; // 2 . update - subscribe subscribeConfig = new SubscribeConfig . Builder ( ) . setServiceName ( serviceName ) . setServiceSpecificInfo ( "extras" . getBytes ( ) ) . build ( ) ; discoverySession . updateSubscribe ( subscribeConfig ) ; assertTrue ( "Subscribe update" , discoveryCb . waitForCallback ( DiscoverySessionCallbackTest . ON_SESSION_CONFIG_UPDATED ) ) ; // 3 . destroy assertFalse ( "Subscribe not terminated" , discoveryCb . hasCallbackAlreadyHappened ( DiscoverySessionCallbackTest . ON_SESSION_TERMINATED ) ) ; discoverySession . destroy ( ) ;
assertTrue ( "Incorrect longitude : " + longitude , Math . abs ( longitude - LONGITUDE ) <= TOLERANCE ) ; retriever . release ( ) ; return true ; } private void checkOutputExist ( ) { assertTrue ( mOutFile . exists ( ) ) ; assertTrue ( mOutFile . length ( ) > 0 ) ; assertTrue ( mOutFile . delete ( ) ) ; } public void testRecorderVideo ( ) throws Exception { if ( ! hasCamera ( ) ) { return ; } mCamera = Camera . open ( 0 ) ; setSupportedResolution ( mCamera ) ; mCamera . unlock ( ) ; mMediaRecorder . setVideoSource ( MediaRecorder . VideoSource . CAMERA ) ; mMediaRecorder . setOutputFormat ( MediaRecorder . OutputFormat . DEFAULT ) ; mMediaRecorder . setOutputFile ( OUTPUT_PATH2 ) ; mMediaRecorder . setVideoEncoder ( MediaRecorder . VideoEncoder . DEFAULT ) ; mMediaRecorder . setPreviewDisplay ( mActivity . getSurfaceHolder ( ) . getSurface ( ) ) ; mMediaRecorder . setVideoSize ( mVideoWidth , mVideoHeight ) ; FileOutputStream fos = new FileOutputStream ( OUTPUT_PATH2 ) ; FileDescriptor fd = fos . getFD ( ) ; mMediaRecorder . setOutputFile ( fd ) ; long maxFileSize = MAX_FILE_SIZE * 10 ; recordMedia ( maxFileSize , mOutFile2 ) ;
assertNotNull ( durationStr ) ; return Integer . parseInt ( durationStr ) ; } public void testSetMaxFileSize ( ) throws Exception { testSetMaxFileSize ( 512 * 1024 , 50 * 1024 ) ; } private void testSetMaxFileSize ( long fileSize , long tolerance ) throws Exception { if ( ! hasMicrophone ( ) || ! hasCamera ( ) || ! hasAmrNb ( ) || ! hasH264 ( ) ) { MediaUtils . skipTest ( "no microphone , camera , or codecs" ) ; return ; } mCamera = Camera . open ( 0 ) ; setSupportedResolution ( mCamera ) ; mCamera . unlock ( ) ; mMediaRecorder . setAudioSource ( MediaRecorder . AudioSource . MIC ) ; mMediaRecorder . setVideoSource ( MediaRecorder . VideoSource . CAMERA ) ; mMediaRecorder . setOutputFormat ( MediaRecorder . OutputFormat . THREE_GPP ) ; mMediaRecorder . setAudioEncoder ( MediaRecorder . AudioEncoder . AMR_NB ) ; mMediaRecorder . setVideoEncoder ( MediaRecorder . VideoEncoder . H264 ) ; mMediaRecorder . setVideoSize ( mVideoWidth , mVideoHeight ) ; mMediaRecorder . setVideoEncodingBitRate ( 256000 ) ; mMediaRecorder . setPreviewDisplay ( mActivity . getSurfaceHolder ( ) . getSurface ( ) ) ; mMediaRecorder . setMaxFileSize ( fileSize ) ; mMediaRecorder . prepare ( ) ; mMediaRecorder . start ( ) ;
// Refuse to send SMS if we can't get the calling package name . Rlog . e ( TAG , "Can't get calling app package name : refusing to send SMS" ) ; tracker . onFailed ( mContext , RESULT_ERROR_GENERIC_FAILURE , 0 /* errorCode */ ) ; return ; } // Get package info via packagemanager PackageInfo appInfo ; try { // XXX this is lossy - apps can share a UID appInfo = pm . getPackageInfoAsUser ( packageNames [ 0 ] , PackageManager . GET_SIGNATURES , Binder . getCallingUid ( ) ) ; } catch ( PackageManager . NameNotFoundException e ) { Rlog . e ( TAG , "Can't get calling app package info : refusing to send SMS" ) ; tracker . onFailed ( mContext , RESULT_ERROR_GENERIC_FAILURE , 0 /* errorCode */ ) ; return ; } // checkDestination ( ) returns true if the destination is not a premium short code or the // sending app is approved to send to short codes . Otherwise , a message is sent to our // handler with the SmsTracker to request user confirmation before sending . if ( checkDestination ( tracker ) ) {
mMediaRecorder . setVideoEncoder ( MediaRecorder . VideoEncoder . DEFAULT ) ; mMediaRecorder . setPreviewDisplay ( mActivity . getSurfaceHolder ( ) . getSurface ( ) ) ; mMediaRecorder . setVideoSize ( mVideoWidth , mVideoHeight ) ; FileOutputStream fos = new FileOutputStream ( OUTPUT_PATH2 ) ; FileDescriptor fd = fos . getFD ( ) ; mMediaRecorder . setOutputFile ( fd ) ; long maxFileSize = MAX_FILE_SIZE * 10 ; recordMedia ( maxFileSize , mOutFile2 ) ; assertFalse ( checkLocationInFile ( OUTPUT_PATH2 ) ) ; fos . close ( ) ; } public void testRecordingAudioInRawFormats ( ) throws Exception { int testsRun = 0 ; if ( hasAmrNb ( ) ) { testsRun += testRecordAudioInRawFormat ( MediaRecorder . OutputFormat . AMR_NB , MediaRecorder . AudioEncoder . AMR_NB ) ; } if ( hasAmrWb ( ) ) { testsRun += testRecordAudioInRawFormat ( MediaRecorder . OutputFormat . AMR_WB , MediaRecorder . AudioEncoder . AMR_WB ) ; } if ( hasAac ( ) ) { testsRun += testRecordAudioInRawFormat ( MediaRecorder . OutputFormat . AAC_ADTS , MediaRecorder . AudioEncoder . AAC ) ; }
mMediaRecorder . setPreviewDisplay ( mActivity . getSurfaceHolder ( ) . getSurface ( ) ) ; mMediaRecorder . setMaxFileSize ( fileSize ) ; mMediaRecorder . prepare ( ) ; mMediaRecorder . start ( ) ; // Recording a scene with moving objects would greatly help reduce // the time for waiting . if ( ! mMaxFileSizeCond . block ( MAX_FILE_SIZE_TIMEOUT_MS ) ) { fail ( "timed out waiting for MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED" ) ; } mMediaRecorder . stop ( ) ; checkOutputFileSize ( OUTPUT_PATH , fileSize , tolerance ) ; } private void checkOutputFileSize ( final String fileName , long fileSize , long tolerance ) { assertTrue ( mOutFile . exists ( ) ) ; assertEquals ( fileSize , mOutFile . length ( ) , tolerance ) ; assertTrue ( mOutFile . delete ( ) ) ; } public void testOnErrorListener ( ) throws Exception { if ( ! hasMicrophone ( ) || ! hasAmrNb ( ) ) { MediaUtils . skipTest ( "no audio codecs or microphone" ) ; return ; } mMediaRecorder . setAudioSource ( MediaRecorder . AudioSource . DEFAULT ) ; mMediaRecorder . setOutputFormat ( MediaRecorder . OutputFormat . THREE_GPP ) ;
assertTrue ( "Incorrect longitude : " + longitude , Math . abs ( longitude - LONGITUDE ) <= TOLERANCE ) ; retriever . release ( ) ; return true ; } private void checkOutputExist ( ) { assertTrue ( mOutFile . exists ( ) ) ; assertTrue ( mOutFile . length ( ) > 0 ) ; assertTrue ( mOutFile . delete ( ) ) ; } public void testRecorderVideo ( ) throws Exception { if ( ! hasCamera ( ) ) { return ; } mCamera = Camera . open ( 0 ) ; setSupportedResolution ( mCamera ) ; mCamera . unlock ( ) ; mMediaRecorder . setVideoSource ( MediaRecorder . VideoSource . CAMERA ) ; mMediaRecorder . setOutputFormat ( MediaRecorder . OutputFormat . DEFAULT ) ; mMediaRecorder . setOutputFile ( OUTPUT_PATH2 ) ; mMediaRecorder . setVideoEncoder ( MediaRecorder . VideoEncoder . DEFAULT ) ; mMediaRecorder . setPreviewDisplay ( mActivity . getSurfaceHolder ( ) . getSurface ( ) ) ; mMediaRecorder . setVideoSize ( mVideoWidth , mVideoHeight ) ; FileOutputStream fos = new FileOutputStream ( OUTPUT_PATH2 ) ; FileDescriptor fd = fos . getFD ( ) ; mMediaRecorder . setOutputFile ( fd ) ; long maxFileSize = MAX_FILE_SIZE * 10 ; recordMedia ( maxFileSize , mOutFile2 ) ;
|| regState == ServiceState . RIL_REG_STATE_DENIED ) { rejectCode = Integer . parseInt ( states [ 13 ] ) ; } } if ( states . length > 14 ) { if ( states [ 14 ] != null && states [ 14 ] . length ( ) > 0 ) { psc = ( int ) Long . parseLong ( states [ 14 ] , 16 ) ; } } } catch ( NumberFormatException ex ) { loge ( "error parsing RegistrationState : " + ex ) ; } } mGsmRoaming = regCodeIsRoaming ( registrationState ) ; mNewRejectCode = reasonForDenial ; boolean isVoiceCapable = mPhone . getContext ( ) . getResources ( ) . getBoolean ( com . android . internal . R . bool . config_voice_capable ) ; if ( ( regState == ServiceState . RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState . RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState . RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED
private int getRegStateFromHalRegState ( int regState ) { switch ( regState ) { case RegState . NOT_REG_MT_NOT_SEARCHING_OP : return ServiceState . RIL_REG_STATE_NOT_REG ; case RegState . REG_HOME : return ServiceState . RIL_REG_STATE_HOME ; case RegState . NOT_REG_MT_SEARCHING_OP : return ServiceState . RIL_REG_STATE_SEARCHING ; case RegState . REG_DENIED : return ServiceState . RIL_REG_STATE_DENIED ; case RegState . UNKNOWN : return ServiceState . RIL_REG_STATE_UNKNOWN ; case RegState . REG_ROAMING : return ServiceState . RIL_REG_STATE_ROAMING ; case RegState . NOT_REG_MT_NOT_SEARCHING_OP_EM : return ServiceState . RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED ; case RegState . NOT_REG_MT_SEARCHING_OP_EM : return ServiceState . RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED ; case RegState . REG_DENIED_EM : return ServiceState . RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED ; case RegState . UNKNOWN_EM : return ServiceState . RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED ; default : return ServiceState . REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING ; }
if ( DBG ) { log ( "handlPollVoiceRegResultMessage : regState = " + registrationState + " radioTechnology = " + voiceRegStateResult . rat ) ; } break ; } case EVENT_POLL_STATE_GPRS : { DataRegStateResult dataRegStateResult = ( DataRegStateResult ) ar . result ; int regState = convertHalRegStateToServiceState ( dataRegStateResult . regState ) ; int dataRegState = regCodeToServiceState ( regState ) ; int newDataRat = dataRegStateResult . rat ; mNewSS . setDataRegState ( dataRegState ) ; mNewSS . setRilDataRadioTechnology ( newDataRat ) ; if ( mPhone . isPhoneTypeGsm ( ) ) { mNewReasonDataDenied = dataRegStateResult . reasonDataDenied ; mNewMaxDataCalls = dataRegStateResult . maxDataCalls ; mDataRoaming = regCodeIsRoaming ( regState ) ; if ( DBG ) { log ( "handlPollStateResultMessage : GsmSST setDataRegState = " + dataRegState + " regState = " + regState + " dataRadioTechnology = " + newDataRat ) ; } } else if ( mPhone . isPhoneTypeCdma ( ) ) {
* < td > TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA </ td > * < td > 1 & ndash ; 8 </ td > * < td > 1 & ndash ; 8 </ td > * </ tr > * < tr class = "deprecated" > * < td > TLS_DHE_RSA_WITH_AES_128_CBC_SHA </ td > * < td > 9 & ndash ; TBD </ td > * < td > 9 & ndash ; TBD </ td > * </ tr > * < tr class = "deprecated" > * < td > TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 </ td > * < td > 20 & ndash ; TBD </ td > * < td > </ td > * </ tr > * < tr class = "deprecated" > * < td > TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 </ td > * < td > 20 & ndash ; TBD </ td > * < td > 20 & ndash ; TBD </ td > * </ tr > * < tr class = "deprecated" > * < td > TLS_DHE_RSA_WITH_AES_256_CBC_SHA </ td > * < td > 9 & ndash ; TBD </ td > * < td > 20 & ndash ; TBD </ td > * </ tr > * < tr class = "deprecated" >
} } } @Test public void testSocketConnectTimeout ( ) throws Exception { // #connect ( SocketAddress endpoint , int timeout ) checkOperationTimesOut ( ( ) - > new Socket ( ) , s - > s . connect ( UNREACHABLE_ADDRESS , TIMEOUT_MILLIS ) ) ; // Setting SO_TIMEOUT should not affect connect timeout . checkOperationTimesOut ( ( ) - > new Socket ( ) , s - > { s . setSoTimeout ( TIMEOUT_MILLIS / 2 ) ; s . connect ( UNREACHABLE_ADDRESS , TIMEOUT_MILLIS ) ; } ) ; } @Test public void testSocketReadTimeout ( ) throws Exception { // #read ( ) try ( ServerSocket ss = new ServerSocket ( 0 ) ) { // The server socket will accept the connection without explicitly calling accept ( ) due // to TCP backlog . checkOperationTimesOut ( ( ) - > new Socket ( ) , s - > { s . connect ( ss . getLocalSocketAddress ( ) ) ; s . setSoTimeout ( TIMEOUT_MILLIS ) ; s . getInputStream ( ) . read ( ) ; } ) ; } } @Test public void testSocketWriteNeverTimeouts ( ) throws Exception {
writeCompleted . countDown ( ) ; } catch ( IOException ignored ) { } finally { writeCompleted . countDown ( ) ; } } ) ; thread . start ( ) ; // Wait for the thread to start . assertTrue ( threadStarted . await ( 500 , TimeUnit . MILLISECONDS ) ) ; // Wait for TIMEOUT_MILLIS + slop . If write does not complete by then , we assume it has // blocked . boolean blocked = ! writeCompleted . await ( TIMEOUT_MILLIS * 2 , TimeUnit . MILLISECONDS ) ; assertTrue ( blocked ) ; // Make sure the writing thread completes after the socket is closed . sock . close ( ) ; assertTrue ( writeCompleted . await ( 5000 , TimeUnit . MILLISECONDS ) ) ; } } @Test public void testServerSocketAcceptTimeout ( ) throws Exception { // #accept ( ) checkOperationTimesOut ( ( ) - > new ServerSocket ( 0 ) , s - > { s . setSoTimeout ( TIMEOUT_MILLIS ) ; s . accept ( ) ; } ) ; } @Test public void testServerSocketChannelAcceptTimeout ( ) throws Exception { // #accept ( ) checkOperationTimesOut ( ( ) - > ServerSocketChannel . open ( ) , s - > {
if ( roamingCap . maxBlacklistSize < 0 || roamingCap . maxWhitelistSize < 0 ) { Log . e ( TAG , "Invalid firmware roaming capabilities : max num blacklist bssid = " + roamingCap . maxBlacklistSize + " max num whitelist ssid = " + roamingCap . maxWhitelistSize ) ; } else { mFirmwareRoamingSupported = true ; mMaxNumBlacklistBssid = roamingCap . maxBlacklistSize ; mMaxNumWhitelistSsid = roamingCap . maxWhitelistSize ; Log . d ( TAG , "Firmware roaming supported with capabilities : max num blacklist bssid = " + mMaxNumBlacklistBssid + " max num whitelist ssid = " + mMaxNumWhitelistSsid ) ; return true ; } } else { Log . e ( TAG , "Failed to get firmware roaming capabilities" ) ; } return false ;
public boolean setFirmwareRoamingConfiguration ( ArrayList < String > blacklistBssids , ArrayList < String > whitelistSsids ) { if ( ! mFirmwareRoamingSupported ) { Log . e ( TAG , "Firmware roaming is not supported" ) ; return false ; } if ( blacklistBssids == null || whitelistSsids == null ) { Log . e ( TAG , "Invalid firmware roaming configuration settings" ) ; return false ; } int blacklistSize = blacklistBssids . size ( ) ; int whitelistSize = whitelistSsids . size ( ) ; if ( blacklistSize > mMaxNumBlacklistBssid || whitelistSize > mMaxNumWhitelistSsid ) { Log . e ( TAG , "Invalid BSSID blacklist size " + blacklistSize + " SSID whitelist size " + whitelistSize + " . Max blacklist size : " + mMaxNumBlacklistBssid + " , max whitelist size : " + mMaxNumWhitelistSsid ) ; return false ; } WifiNative . RoamingConfig roamConfig = new WifiNative . RoamingConfig ( ) ; roamConfig . blacklistBssids = blacklistBssids ; roamConfig . whitelistSsids = whitelistSsids ; return mWifiNative . configureRoaming ( roamConfig ) ;
public boolean requestIcon ( String bssid , String fileName ) { if ( bssid == null || fileName == null ) { Log . e ( mTAG , "Invalid arguments for Icon request . " ) ; return false ; } return mSupplicantStaIfaceHal . initiateHs20IconQuery ( bssid , fileName ) ;
* limitations under the License . */ package com . android . server . wifi ; import static org . junit . Assert . assertTrue ; import static org . mockito . Mockito . mock ; import android . os . Handler ; import android . os . Message ; import android . util . SparseArray ; import java . util . HashMap ; import java . util . Map ; /* * * Creates a mock WifiMonitor . * WARNING : This does not perfectly mock the behavior of WifiMonitor at the moment * ex . startMonitoring does nothing and will not send a connection / disconnection event */ public class MockWifiMonitor extends WifiMonitor { private final Map < String , SparseArray < Handler > > mHandlerMap = new HashMap < > ( ) ; public MockWifiMonitor ( ) { super ( mock ( WifiInjector . class ) ) ; } @Override public void registerHandler ( String iface , int what , Handler handler ) { SparseArray < Handler > ifaceHandlers = mHandlerMap . get ( iface ) ; if ( ifaceHandlers == null ) { ifaceHandlers = new SparseArray < > ( ) ; mHandlerMap . put ( iface , ifaceHandlers ) ; } ifaceHandlers . put ( what , handler ) ; } @Override
result . setResult ( mISupplicantP2pIface . startWpsPinKeypad ( groupIfName , pin ) ) ; } catch ( RemoteException e ) { Log . e ( TAG , "ISupplicantP2pIface exception : " + e ) ; supplicantServiceDiedHandler ( ) ; } return result . isSuccess ( ) ; } } /* * * Initiate WPS Pin Display setup . * * @param groupIfName Group interface name to use . * @param bssid BSSID of the AP . Use zero'ed bssid to indicate wildcard . * @return generated pin if operation was successful , null otherwise . */ public String startWpsPinDisplay ( String groupIfName , String bssid ) { if ( TextUtils . isEmpty ( groupIfName ) || TextUtils . isEmpty ( bssid ) ) return null ; synchronized ( mLock ) { if ( ! checkSupplicantP2pIfaceAndLogFailure ( "startWpsPinDisplay" ) ) return null ; if ( groupIfName == null ) { Log . e ( TAG , "Group name required when requesting WPS KEYPAD . " ) ; return null ; } // Null values should be fine , since bssid can be empty . byte [ ] macAddress = null ; if ( bssid != null ) {
public WifiNative ( String interfaceName , WifiVendorHal vendorHal , SupplicantStaIfaceHal staIfaceHal , SupplicantP2pIfaceHal p2pIfaceHal , WificondControl condControl ) { mTAG = "WifiNative - " + interfaceName ; mInterfaceName = interfaceName ; mWifiVendorHal = vendorHal ; mSupplicantStaIfaceHal = staIfaceHal ; mSupplicantP2pIfaceHal = p2pIfaceHal ; mWificondControl = condControl ; } public String getInterfaceName ( ) { return mInterfaceName ; } /* * * Enable verbose logging for all sub modules . */ public void enableVerboseLogging ( int verbose ) { mWificondControl . enableVerboseLogging ( verbose > 0 ? true : false ) ; mSupplicantStaIfaceHal . enableVerboseLogging ( verbose > 0 ) ; mWifiVendorHal . enableVerboseLogging ( verbose > 0 ) ; } /* ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** * * Native Initialization / Deinitialization ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** / /* * * Setup wifi native for Client mode operations . * * 1 . Starts the Wifi HAL and configures it in client / STA mode . * 2 . Setup Wificond to operate in client mode and retrieve the handle to use for client * operations . *
public boolean startFilteringMulticastV4Packets ( ) { return mSupplicantStaIfaceHal . stopRxFilter ( ) && mSupplicantStaIfaceHal . removeRxFilter ( SupplicantStaIfaceHal . RX_FILTER_TYPE_V4_MULTICAST ) && mSupplicantStaIfaceHal . startRxFilter ( ) ;
public boolean stopFilteringMulticastV4Packets ( ) { return mSupplicantStaIfaceHal . stopRxFilter ( ) && mSupplicantStaIfaceHal . addRxFilter ( SupplicantStaIfaceHal . RX_FILTER_TYPE_V4_MULTICAST ) && mSupplicantStaIfaceHal . startRxFilter ( ) ;
public boolean startFilteringMulticastV6Packets ( ) { return mSupplicantStaIfaceHal . stopRxFilter ( ) && mSupplicantStaIfaceHal . removeRxFilter ( SupplicantStaIfaceHal . RX_FILTER_TYPE_V6_MULTICAST ) && mSupplicantStaIfaceHal . startRxFilter ( ) ;
public boolean stopFilteringMulticastV6Packets ( ) { return mSupplicantStaIfaceHal . stopRxFilter ( ) && mSupplicantStaIfaceHal . addRxFilter ( SupplicantStaIfaceHal . RX_FILTER_TYPE_V6_MULTICAST ) && mSupplicantStaIfaceHal . startRxFilter ( ) ;
public boolean setSerialNumber ( String value ) { return mSupplicantStaIfaceHal . setWpsSerialNumber ( value ) ; } public void setPowerSave ( boolean enabled ) { mSupplicantStaIfaceHal . setPowerSave ( enabled ) ; } /* * * "sta" prioritizes STA connection over P2P and "p2p" prioritizes * P2P connection over STA */ public boolean setConcurrencyPriority ( boolean isStaHigherPriority ) { return mSupplicantStaIfaceHal . setConcurrencyPriority ( isStaHigherPriority ) ; } /* * * Migrate all the configured networks from wpa_supplicant . * * @param configs Map of configuration key to configuration objects corresponding to all * the networks . * @param networkExtras Map of extra configuration parameters stored in wpa_supplicant . conf * @return Max priority of all the configs . */ public boolean migrateNetworksFromSupplicant ( Map < String , WifiConfiguration > configs , SparseArray < Map < String , String > > networkExtras ) { return mSupplicantStaIfaceHal . loadNetworks ( configs , networkExtras ) ; } /* *
/* * * Handler to notify the occurrence of various events during PNO scan . */ public interface PnoEventHandler { /* * * Callback to notify when one of the shortlisted networks is found during PNO scan . * @param results List of Scan results received . */ void onPnoNetworkFound ( ScanResult [ ] results ) ; /* * * Callback to notify when the PNO scan schedule fails . */ void onPnoScanFailed ( ) ; } public static final int WIFI_SCAN_RESULTS_AVAILABLE = 0 ; public static final int WIFI_SCAN_THRESHOLD_NUM_SCANS = 1 ; public static final int WIFI_SCAN_THRESHOLD_PERCENT = 2 ; public static final int WIFI_SCAN_FAILED = 3 ; public boolean startScan ( ScanSettings settings , ScanEventHandler eventHandler ) { return mWifiVendorHal . startScan ( settings , eventHandler ) ; } public void stopScan ( ) { mWifiVendorHal . stopScan ( ) ; } public void pauseScan ( ) { mWifiVendorHal . pauseScan ( ) ; }
public void setWifiLinkLayerStats ( String iface , int enable ) { // TODO ( b // 36087365 ) Remove this . Link layer stats is enabled when the HAL is started .
/* * * Indicates whether getChannelsForBand is supported . * * @return true if it is . */ public boolean isGetChannelsForBandSupported ( ) { return mWifiVendorHal . isGetChannelsForBandSupported ( ) ;
void onWifiAlert ( int errorCode , byte [ ] buffer ) ; } public boolean setLoggingEventHandler ( WifiLoggerEventHandler handler ) { return mWifiVendorHal . setLoggingEventHandler ( handler ) ; } public boolean startLoggingRingBuffer ( int verboseLevel , int flags , int maxInterval , int minDataSize , String ringName ) { return mWifiVendorHal . startLoggingRingBuffer ( verboseLevel , flags , maxInterval , minDataSize , ringName ) ; } public int getSupportedLoggerFeatureSet ( ) { return mWifiVendorHal . getSupportedLoggerFeatureSet ( ) ; } /* * * Stops all logging and resets the logger callback . * This stops both the alerts and ring buffer data collection . */ public boolean resetLogHandler ( ) { return mWifiVendorHal . resetLogHandler ( ) ; } public String getDriverVersion ( ) { return mWifiVendorHal . getDriverVersion ( ) ; } public String getFirmwareVersion ( ) { return mWifiVendorHal . getFirmwareVersion ( ) ; } public static class RingBufferStatus { String name ; int flag ; int ringBufferId ; int ringBufferByteSize ; int verboseLevel ; int writtenBytes ; int readBytes ; int writtenRecords ; // Bit masks for interpreting |flag| public static final int HAS_BINARY_ENTRIES = ( 1 < < 0 ) ;
* @hide */ public static final String KEY_NOTIFY_INTERNATIONAL_CALL_ON_WFC_BOOL = "notify_international_call_on_wfc_bool" ; /* * * Offset to be reduced from rsrp threshold while calculating signal strength level . * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int" ; /* * * Threshold of EARFCN above which signal_strength_offset_int will be applied . * @hide */ public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT = "signal_strength_earfcn_threshold_int" ; /* * The default value for every variable . */ private final static PersistableBundle sDefaults ; static { sDefaults = new PersistableBundle ( ) ; sDefaults . putBoolean ( KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL , true ) ; sDefaults . putBoolean ( KEY_ADDITIONAL_CALL_SETTING_BOOL , true ) ; sDefaults . putBoolean ( KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL , false ) ; sDefaults . putBoolean ( KEY_ALLOW_LOCAL_DTMF_TONES_BOOL , true ) ;
"notify_international_call_on_wfc_bool" ; /* * * Offset to be reduced from rsrp threshold while calculating signal strength level . * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int" ; /* * * Threshold of EARFCN above which signal_strength_offset_int will be applied . * Unit of this value should be in MHz . * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCN_THRESHOLD_INT = "signal_strength_earfcn_threshold_int" ; /* * The default value for every variable . */ private final static PersistableBundle sDefaults ; static { sDefaults = new PersistableBundle ( ) ; sDefaults . putBoolean ( KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL , true ) ; sDefaults . putBoolean ( KEY_ADDITIONAL_CALL_SETTING_BOOL , true ) ; sDefaults . putBoolean ( KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL , false ) ; sDefaults . putBoolean ( KEY_ALLOW_LOCAL_DTMF_TONES_BOOL , true ) ; sDefaults . putBoolean ( KEY_APN_EXPAND_BOOL , true ) ; sDefaults . putBoolean ( KEY_AUTO_RETRY_ENABLED_BOOL , false ) ;
* * < p > Requires Permission : * { @link android . Manifest . permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE } * Or the calling app has carrier privileges . @see #hasCarrierPrivileges * * @param AID Application id . See ETSI 102 . 221 and 101 . 220 . * @param p2 P2 parameter ( described in ISO 7816 - 4 ) . Default value : 0x00 * @return an IccOpenLogicalChannelResponse object . */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel ( String AID , int p2 ) { return iccOpenLogicalChannel ( getSubId ( ) , AID , p2 ) ; } /* * * Opens a logical channel to the ICC card . * * Input parameters equivalent to TS 27 . 007 AT + CCHO command . * * < p > Requires Permission : * { @link android . Manifest . permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE } * Or the calling app has carrier privileges . @see #hasCarrierPrivileges * * @param subId The subscription to use . * @param AID Application id . See ETSI 102 . 221 and 101 . 220 .
* limitations under the License . */ package com . android . server . wifi . scanner ; import android . content . Context ; import android . net . wifi . WifiScanner ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . util . Log ; import com . android . server . wifi . Clock ; import com . android . server . wifi . WifiNative ; /* * * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for oneshot scans . * @see com . android . server . wifi . scanner . WifiScannerImpl for more details on each method . */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler . Callback { private static final String TAG = "HalWifiScannerImpl" ; private static final boolean DBG = false ; private final WifiNative mWifiNative ; private final ChannelHelper mChannelHelper ; private final WificondScannerImpl mWificondScannerDelegate ; private final boolean mHalBasedPnoSupported ; public HalWifiScannerImpl ( Context context , WifiNative wifiNative , Looper looper , Clock clock ) { mWifiNative = wifiNative ; mChannelHelper = new HalChannelHelper ( wifiNative ) ;
* limitations under the License . */ package com . android . server . wifi . scanner ; import android . content . Context ; import android . net . wifi . WifiScanner ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . util . Log ; import com . android . server . wifi . Clock ; import com . android . server . wifi . WifiMonitor ; import com . android . server . wifi . WifiNative ; /* * * WifiScanner implementation that takes advantage of the gscan HAL API * The gscan API is used to perform background scans and wificond is used for oneshot scans . * @see com . android . server . wifi . scanner . WifiScannerImpl for more details on each method . */ public class HalWifiScannerImpl extends WifiScannerImpl implements Handler . Callback { private static final String TAG = "HalWifiScannerImpl" ; private static final boolean DBG = false ; private final WifiNative mWifiNative ; private final ChannelHelper mChannelHelper ; private final WificondScannerImpl mWificondScannerDelegate ; private final boolean mHalBasedPnoSupported ; public HalWifiScannerImpl ( Context context , WifiNative wifiNative , WifiMonitor wifiMonitor , Looper looper , Clock clock ) {
public void describeTo ( Description description ) { description . appendText ( toString ( ) ) ;
String [ ] s ; s = params . getCipherSuites ( ) ; if ( s != null ) { setEnabledCipherSuites ( s ) ; } s = params . getProtocols ( ) ; if ( s != null ) { setEnabledProtocols ( s ) ; } if ( params . getNeedClientAuth ( ) ) { setNeedClientAuth ( true ) ; } else if ( params . getWantClientAuth ( ) ) { setWantClientAuth ( true ) ; } else { setWantClientAuth ( false ) ; } } // Android - added : Make toString explicit that this is an SSLServerSocket ( http :/ / b / 6602228 ) @Override public String toString ( ) { return "SSL" + super . toString ( ) ; } }
*/ public void receivedWnmFrame ( WnmData data ) { mHandler . notifyWnmFrameReceived ( data ) ; } /* * * Request the specified icon file |fileName| from the specified AP |bssid| . * @return true if the request is sent successfully , false otherwise */ public boolean queryPasspointIcon ( long bssid , String fileName ) { return mHandler . requestIcon ( bssid , fileName ) ; } /* * * Lookup the ANQP elements associated with the given AP from the cache . An empty map * will be returned if no match found in the cache . * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map < Constants . ANQPElementType , ANQPElement > getANQPElements ( ScanResult scanResult ) { // Retrieve the Hotspot 2 . 0 Vendor Specific IE . InformationElementUtil . Vsa vsa = InformationElementUtil . getHS2VendorSpecificIE ( scanResult . informationElements ) ; // Lookup ANQP data in the cache . long bssid = Utils . parseMac ( scanResult . BSSID ) ; ANQPData anqpEntry = mAnqpCache . getEntry ( ANQPNetworkKey . buildKey (
mHandler . notifyWnmFrameReceived ( data ) ; } /* * * Request the specified icon file |fileName| from the specified AP |bssid| . * @return true if the request is sent successfully , false otherwise */ public boolean queryPasspointIcon ( long bssid , String fileName ) { return mHandler . requestIcon ( bssid , fileName ) ; } /* * * Lookup the ANQP elements associated with the given AP from the cache . An empty map * will be returned if no match found in the cache . * * @param scanResult The scan result associated with the AP * @return Map of ANQP elements */ public Map < Constants . ANQPElementType , ANQPElement > getANQPElements ( ScanResult scanResult ) { // Retrieve the Hotspot 2 . 0 Vendor Specific IE . InformationElementUtil . Vsa vsa = InformationElementUtil . getHS2VendorSpecificIE ( scanResult . informationElements ) ; // Lookup ANQP data in the cache . long bssid = Utils . parseMac ( scanResult . BSSID ) ; ANQPData anqpEntry = mAnqpCache . getEntry ( ANQPNetworkKey . buildKey ( scanResult . SSID , bssid , scanResult . hessid , vsa . anqpDomainID ) ) ;
public void enter ( ) { super . enter ( ) ; setSpeakerphoneOn ( false ) ; // Do not enable SCO audio here , since RING is being sent to the headset . CallAudioState newState = new CallAudioState ( mIsMuted , ROUTE_BLUETOOTH , mAvailableRoutes ) ; setSystemAudioState ( newState ) ; updateInternalCallAudioState ( ) ;
* { @link android . Manifest . permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE } * Or the calling app has carrier privileges . @see #hasCarrierPrivileges * * @param AID Application id . See ETSI 102 . 221 and 101 . 220 . * @return an IccOpenLogicalChannelResponse object . * @deprecated Replaced by { @link #iccOpenLogicalChannel ( String , byte ) } */ @Deprecated public IccOpenLogicalChannelResponse iccOpenLogicalChannel ( String AID ) { return iccOpenLogicalChannel ( getSubId ( ) , AID , - 1 ) ; } /* * * Opens a logical channel to the ICC card . * * Input parameters equivalent to TS 27 . 007 AT + CCHO command . * * < p > Requires Permission : * { @link android . Manifest . permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE } * Or the calling app has carrier privileges . @see #hasCarrierPrivileges * * @param AID Application id . See ETSI 102 . 221 and 101 . 220 . * @param p2 P2 parameter ( described in ISO 7816 - 4 ) . Default value : 0x00
private static LinkProperties getUniqueLocalConfig ( byte [ ] ulp , String ifname ) { LinkProperties lp = new LinkProperties ( ) ; lp . setInterfaceName ( ifname ) ; final IpPrefix local48 = getUniqueLocalPrefix ( ulp , ( short ) 0 , 48 ) ; lp . addRoute ( new RouteInfo ( local48 , null , null ) ) ; final IpPrefix local64 = getUniqueLocalPrefix ( ulp , subnetId , 64 ) ; lp . addLinkAddress ( new LinkAddress ( local64 . getAddress ( ) , 64 ) ) ; return lp ;
private int mEvdoDbm ; // This value is the EVDO RSSI value private int mEvdoEcio ; // This value is the EVDO Ec / Io private int mEvdoSnr ; // Valid values are 0 - 8 . 8 is the highest signal to noise ratio private int mLteSignalStrength ; private int mLteRsrp ; private int mLteRsrq ; private int mLteRssnr ; private int mLteCqi ; private int mLteRsrpBoost ; // offset to be reduced from the rsrp threshold while calculating // signal strength level private int mTdScdmaRscp ; private boolean isGsm ; // This value is set by the ServiceStateTracker onSignalStrengthResult /* * * Create a new SignalStrength from a intent notifier Bundle * * This method is used by PhoneStateIntentReceiver and maybe by * external applications . * * @param m Bundle from intent notifier * @return newly created SignalStrength * * @hide */ public static SignalStrength newFromBundle ( Bundle m ) { SignalStrength ret ; ret = new SignalStrength ( ) ; ret . setFromNotifierBundle ( m ) ;
public void setLteRsrpBoost ( int lteRsrpBoost ) { mLteRsrpBoost = lteRsrpBoost ;
*/ int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN , rsrpIconLevel = - 1 , snrIconLevel = - 1 ; int [ ] threshRsrp = Resources . getSystem ( ) . getIntArray ( com . android . internal . R . array . config_lteDbmThresholds ) ; if ( threshRsrp . length != 6 ) { Log . wtf ( LOG_TAG , "getLteLevel - config_lteDbmThresholds has invalid num of elements . " + " Cannot evaluate RSRP signal . " ) ; } else { if ( mLteRsrp > threshRsrp [ 5 ] ) { rsrpIconLevel = - 1 ; } else if ( mLteRsrp >= ( threshRsrp [ 4 ] - mLteRsrpBoost ) ) { rsrpIconLevel = SIGNAL_STRENGTH_GREAT ; } else if ( mLteRsrp >= ( threshRsrp [ 3 ] - mLteOffset ) ) { rsrpIconLevel = SIGNAL_STRENGTH_GOOD ; } else if ( mLteRsrp >= ( threshRsrp [ 2 ] - mLteOffset ) ) { rsrpIconLevel = SIGNAL_STRENGTH_MODERATE ; } else if ( mLteRsrp >= ( threshRsrp [ 1 ] - mLteOffset ) ) { rsrpIconLevel = SIGNAL_STRENGTH_POOR ; } else if ( mLteRsrp >= threshRsrp [ 0 ] ) {
"notify_international_call_on_wfc_bool" ; /* * * Offset to be reduced from rsrp threshold while calculating signal strength level . * @hide */ public static final String KEY_SIGNAL_STRENGTH_OFFSET_INT = "signal_strength_offset_int" ; /* * * List of EARFCN ranges on which signal_strength_offset_int will be applied . * Format of the String array is expected to be { "erafcn1_start - earfcn1_end" , * "earfcn2_start - earfcn2_end" . . . } * @hide */ public static final String KEY_SIGNAL_STRENGTH_EARFCNS_LIST_STRING_ARRAY = "signal_strength_earfcn_threshold_int" ; /* * The default value for every variable . */ private final static PersistableBundle sDefaults ; static { sDefaults = new PersistableBundle ( ) ; sDefaults . putBoolean ( KEY_ALLOW_HOLD_IN_IMS_CALL_BOOL , true ) ; sDefaults . putBoolean ( KEY_ADDITIONAL_CALL_SETTING_BOOL , true ) ; sDefaults . putBoolean ( KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL , false ) ; sDefaults . putBoolean ( KEY_ALLOW_LOCAL_DTMF_TONES_BOOL , true ) ;
* @return error a { @code TETHER_ERROR } value indicating success or failure type * * { @hide } */ public int setUsbTethering ( boolean enable ) { try { return mService . setUsbTethering ( enable ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } /* * * Request that a local - only Wi - Fi hotspot be started . The supplied Wi - Fi * configuration is used to start the Wi - Fi hotspot , and must be non - null . * * Local - only Wi - Fi hotspot functionality is currently mutually exclusive * with other tethering functionality . * * @param cfg The { @link android . net . wifi . WifiConfiguration } to use . * @return error a { @code TETHER_ERROR } value indicating success or failure * * @hide */ public int startLocalOnlyWifiHotspot ( WifiConfiguration cfg ) { try { return mService . startLocalOnlyWifiHotspot ( cfg ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } /* *
public void getFirmwareRoamingInfo ( ) { reset ( mWifiConnectivityHelper ) ; // WifiConnectivityManager is on by default mWifiConnectivityManager . setWifiEnabled ( true ) ; verify ( mWifiConnectivityHelper ) . getFirmwareRoamingInfo ( ) ;
// SSID as the one to be selected . WifiConfiguration currentNetwork = generateWifiConfig ( 0 , CANDIDATE_NETWORK_ID , CANDIDATE_SSID , false , true , null , null ) ; when ( mWifiConfigManager . getConfiguredNetwork ( anyInt ( ) ) ) . thenReturn ( currentNetwork ) ; // Set WiFi to connected state mWifiConnectivityManager . handleConnectionStateChanged ( WifiConnectivityManager . WIFI_STATE_CONNECTED ) ; // Set screen to on mWifiConnectivityManager . handleScreenStateChanged ( true ) ; verify ( mWifiStateMachine ) . startRoamToNetwork ( eq ( CANDIDATE_NETWORK_ID ) , mCandidateScanResultCaptor . capture ( ) ) ; assertEquals ( mCandidateScanResultCaptor . getValue ( ) . BSSID , CANDIDATE_BSSID ) ;
public void noFrameworkRoamingIfFirmwareControlRoaming ( ) { // Firmware controls roaming when ( mWifiConnectivityHelper . isFirmwareRoamingSupported ( ) ) . thenReturn ( true ) ; // Set WiFi to connected state mWifiConnectivityManager . handleConnectionStateChanged ( WifiConnectivityManager . WIFI_STATE_CONNECTED ) ; // Set screen to on mWifiConnectivityManager . handleScreenStateChanged ( true ) ; verify ( mWifiStateMachine , times ( 0 ) ) . startRoamToNetwork ( anyInt ( ) , anyObject ( ) ) ;
* 6 . "San Francisco" location card opens . * 7 . Select "San Francisco" . * 8 . Tap on the Drive icon . * Verify : * 1 . Map points to San Francisco location . * 2 . Navigation overview is displayed . * </ pre > */ @Test @TestInfo ( id = "145493594" ) public void testMapsApp ( ) throws Exception { Instrumentation instrumentation = testFramework . getInstrumentation ( ) ; UiDevice mDevice = testFramework . getDevice ( ) ; AppLauncher . launch ( instrumentation , "Maps" ) ; UiObject acceptButton = mDevice . findObject ( new UiSelector ( ) . textContains ( "ACCEPT & CONTINUE" ) ) ; // "Accept & Continue" occurs only on first time Maps gets launched . if ( acceptButton . exists ( ) ) { acceptButton . clickAndWaitForNewWindow ( ) ; } // SKIP button only exist's occurs only on first time Maps gets launched . UiObject skipText = mDevice . findObject ( new UiSelector ( ) . textContains ( "SKIP" ) ) ; if ( skipText . exists ( ) ) {
scrollView . scrollIntoView ( new UiSelector ( ) . text ( QUERY_STRING ) ) ; selectedLocation = scrollView . getChildByText ( new UiSelector ( ) . className ( TextView . class . getName ( ) ) , QUERY_STRING ) ; Assert . assertTrue ( selectedLocation . exists ( ) ) ; selectedLocation . clickAndWaitForNewWindow ( ) ; // Verify the Query String is present after completing search . UiObject searchTextView = searchUiObject . getChild ( new UiSelector ( ) . className ( TextView . class . getName ( ) ) ) ; Assert . assertTrue ( searchTextView . getText ( ) . contains ( QUERY_STRING ) ) ; } else { searchEditText = mDevice . findObject ( new UiSelector ( ) . className ( EditText . class . getName ( ) ) ) ; searchEditText . setText ( QUERY_STRING ) ; UiScrollable listViewSelector = new UiScrollable ( new UiSelector ( ) . className ( ListView . class . getName ( ) ) ) ; selectedLocation = listViewSelector . getChildByText ( new UiSelector ( ) . className ( TextView . class . getName ( ) ) , QUERY_STRING ) ; selectedLocation . clickAndWaitForNewWindow ( ) ; // Verify the Query String is present after completing search . Assert . assertTrue ( searchEditText . getText ( ) . contains ( QUERY_STRING ) ) ; }
private static final String TAG = "CellBroadcastReceiver" ; static final boolean DBG = false ; // STOPSHIP : change to false before ship public static final String CELLBROADCAST_START_CONFIG_ACTION = "android . cellbroadcastreceiver . START_CONFIG" ; // Key to access the stored reminder interval default value private static final String CURRENT_INTERVAL_DEFAULT = "current_interval_default" ; public static final String ACTION_MARK_AS_READ = "com . google . android . clockwork . cmas . intent . action . MARK_AS_READ" ; public static final String EXTRA_DELIVERY_TIME = "com . android . cellbroadcastreceiver . intent . extra . ID" ; @Override public void onReceive ( Context context , Intent intent ) { onReceiveWithPrivilege ( context , intent , false ) ; } protected void onReceiveWithPrivilege ( Context context , Intent intent , boolean privileged ) { if ( DBG ) log ( "onReceive " + intent ) ; String action = intent . getAction ( ) ; final long deliveryTime = intent . getLongExtra ( EXTRA_DELIVERY_TIME , - 1 ) ; if ( ACTION_MARK_AS_READ . equals ( action ) ) { new CellBroadcastContentProvider . AsyncCellBroadcastTask ( context . getContentResolver ( ) )
protected void onReceiveWithPrivilege ( Context context , Intent intent , boolean privileged ) { if ( DBG ) log ( "onReceive " + intent ) ; String action = intent . getAction ( ) ; if ( ACTION_MARK_AS_READ . equals ( action ) ) { new CellBroadcastContentProvider . AsyncCellBroadcastTask ( context . getContentResolver ( ) ) . execute ( new CellBroadcastContentProvider . CellBroadcastOperation ( ) { @Override public boolean execute ( CellBroadcastContentProvider provider ) { return provider . markBroadcastRead ( CellBroadcasts . DELIVERY_TIME , deliveryTime ) ; } } ) ; } else if ( TelephonyIntents . ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED . equals ( action ) || CarrierConfigManager . ACTION_CARRIER_CONFIG_CHANGED . equals ( action ) || CELLBROADCAST_START_CONFIG_ACTION . equals ( action ) ) { // Todo : Add the service state check once the new get service state API is done . // Do not rely on mServiceState as it gets reset to - 1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done .
protected void onReceiveWithPrivilege ( Context context , Intent intent , boolean privileged ) { if ( DBG ) log ( "onReceive " + intent ) ; String action = intent . getAction ( ) ; final long deliveryTime = intent . getLongExtra ( EXTRA_DELIVERY_TIME , - 1 ) ; if ( ACTION_MARK_AS_READ . equals ( action ) ) { final long deliveryTime = intent . getLongExtra ( EXTRA_DELIVERY_TIME , - 1 ) ; new CellBroadcastContentProvider . AsyncCellBroadcastTask ( context . getContentResolver ( ) ) . execute ( new CellBroadcastContentProvider . CellBroadcastOperation ( ) { @Override public boolean execute ( CellBroadcastContentProvider provider ) { return provider . markBroadcastRead ( CellBroadcasts . DELIVERY_TIME , deliveryTime ) ; } } ) ; } else if ( TelephonyIntents . ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED . equals ( action ) || CarrierConfigManager . ACTION_CARRIER_CONFIG_CHANGED . equals ( action ) || CELLBROADCAST_START_CONFIG_ACTION . equals ( action ) ) { // Todo : Add the service state check once the new get service state API is done . // Do not rely on mServiceState as it gets reset to - 1 time to time because // the process of CellBroadcastReceiver gets killed every time once the job is done .
/* * Intent action to display alert dialog / notification , after verifying the alert is new . */ static final String SHOW_NEW_ALERT_ACTION = "cellbroadcastreceiver . SHOW_NEW_ALERT" ; /* * Use the same notification ID for non - emergency alerts . */ static final int NOTIFICATION_ID = 1 ; /* * Sticky broadcast for latest area info broadcast received . */ static final String CB_AREA_INFO_RECEIVED_ACTION = "android . cellbroadcastreceiver . CB_AREA_INFO_RECEIVED" ; /* * Intent extra for passing a SmsCbMessage */ private static final String EXTRA_MESSAGE = "message" ; /* * * Container for service category , serial number , location , body hash code , and ETWS primary / * secondary information for duplication detection . */ private static final class MessageServiceCategoryAndScope { private final int mServiceCategory ; private final int mSerialNumber ; private final SmsCbLocation mLocation ; private final int mBodyHash ; private final boolean mIsEtwsPrimary ; MessageServiceCategoryAndScope ( int serviceCategory , int serialNumber , SmsCbLocation location , int bodyHash , boolean isEtwsPrimary ) { mServiceCategory = serviceCategory ;
ArrayList < CellBroadcastMessage > messageList , Context context , boolean fromSaveState ) { int channelTitleId = CellBroadcastResources . getDialogTitleResource ( context , message ) ; CharSequence channelName = context . getText ( channelTitleId ) ; String messageBody = message . getMessageBody ( ) ; // Create intent to show the new messages when user selects the notification . Intent intent ; if ( context . getPackageManager ( ) . hasSystemFeature ( PackageManager . FEATURE_WATCH ) ) { // For FEATURE_WATCH we want to mark as read intent = createMarkAsReadIntent ( context , message . getDeliveryTime ( ) ) ; } else { // For phone we handle it differently intent = createDisplayMessageIntent ( context , CellBroadcastAlertDialog . class , messageList ) ; } intent . putExtra ( CellBroadcastAlertDialog . FROM_NOTIFICATION_EXTRA , true ) ; intent . putExtra ( CellBroadcastAlertDialog . FROM_SAVE_STATE_NOTIFICATION_EXTRA , fromSaveState ) ; PendingIntent pi ; if ( context . getPackageManager ( ) . hasSystemFeature ( PackageManager . FEATURE_WATCH ) ) { pi = PendingIntent . getBroadcast ( context , 0 , intent , 0 ) ; } else { pi = PendingIntent . getActivity ( context , NOTIFICATION_ID , intent ,
static Intent createMarkAsReadIntent ( Context context , long deliveryTime ) { Intent deleteIntent = new Intent ( context , CellBroadcastReceiver . class ) ; deleteIntent . setAction ( CellBroadcastReceiver . ACTION_MARK_AS_READ ) ; deleteIntent . putExtra ( CellBroadcastReceiver . EXTRA_DELIVERY_TIME , deliveryTime ) ; return deleteIntent ;
/* * * @hide */ public class NetdService { private static final String TAG = NetdService . class . getSimpleName ( ) ; private static final String NETD_SERVICE_NAME = "netd" ; private static final int BASE_TIMEOUT_MS = 100 ; private static final int MAX_TIMEOUT_MS = 1000 ; /* * * It is the caller's responsibility to check for a null return value * and to handle RemoteException errors from invocations on the returned * interface if , for example , netd dies and is restarted . * * Returned instances of INetd should not be cached . * * @return an INetd instance or null . */ public static INetd getInstance ( ) { // NOTE : ServiceManager does no caching for the netd service , // because netd is not one of the defined common services . final INetd netdInstance = INetd . Stub . asInterface ( ServiceManager . getService ( NETD_SERVICE_NAME ) ) ; if ( netdInstance == null ) { Log . w ( TAG , "WARNING : returning null INetd instance . " ) ; } return netdInstance ; } /* * * Blocks until an INetd instance is available . *
if ( netdInstance == null ) { Log . w ( TAG , "WARNING : returning null INetd instance . " ) ; } return netdInstance ; } /* * * Blocks until an INetd instance is available . * * It is the caller's responsibility to handle RemoteException errors * from invocations on the returned interface if , for example , netd * dies after this interface was returned . * * Returned instances of INetd should not be cached . * * @return an INetd instance or null . */ public static INetd get ( int maxTimeoutMs ) { int timeoutMs = BASE_TIMEOUT_MS ; for ( int i = 0 ; i > - 1 ; i ++ ) { final INetd netdInstance = getInstance ( ) ; if ( netdInstance != null ) { return netdInstance ; } // No netdInstance was received ; sleep and retry . final int timeoutMs = ( i < ( MAX_TIMEOUT_MS / BASE_TIMEOUT_MS ) ) ? ( i * BASE_TIMEOUT_MS ) : MAX_TIMEOUT_MS ; try { Thread . sleep ( timeoutMs ) ; } catch ( InterruptedException e ) { } } }
public static INetd get ( ) { for ( int i = 0 ; ; i ++ ) { final INetd netdInstance = getInstance ( ) ; if ( netdInstance != null ) { return netdInstance ; } // No netdInstance was received ; sleep and retry . final int timeoutMs = ( i < ( MAX_TIMEOUT_MS / BASE_TIMEOUT_MS ) ) ? ( i * BASE_TIMEOUT_MS ) : MAX_TIMEOUT_MS ; try { Thread . sleep ( timeoutMs ) ; } catch ( InterruptedException e ) { // If this occurs we can lose track of some time slept . } if ( maxTimeoutMs > 0 ) maxTimeoutMs -= timeoutMs ; }
void run ( INetd netd ) throws RemoteException ; } /* * * Blocks until an INetd instance is availabe , and retries until either * the command succeeds or a ServiceSpecificError is thrown . */
void run ( INetd netd ) throws RemoteException , ServiceSpecificException ; } /* * * Blocks until an INetd instance is availabe , and retries until either * the command succeeds or a runtime exception is thrown . */
public static void run ( NetdCommand cmd ) { while ( true ) { try { cmd . run ( get ( ) ) ; return ; } catch ( RemoteException re ) { Log . e ( TAG , "error communicated with netd : " + re ) ; } }
public static void run ( NetdCommand cmd ) { while ( true ) { try { cmd . run ( get ( ) ) ; return ; } catch ( RemoteException re ) { Log . e ( TAG , "error communicated with netd : " + re ) ; } }
ResultUnit . BYTE ) ; Stat . StatResult stat = Stat . getStat ( mbps ) ; getReportLog ( ) . printSummary ( "write throughput" , stat . mAverage , ResultType . HIGHER_BETTER , ResultUnit . MBPS ) ; } @TimeoutReq ( minutes = 80 ) public void testSingleSequentialUpdate ( ) throws Exception { final long fileSize = FileUtil . getFileSizeExceedingMemory ( getContext ( ) , BUFFER_SIZE ) ; if ( fileSize == 0 ) { // not enough space , give up return ; } final int NUMBER_REPETITION = 3 ; FileUtil . doSequentialUpdateTest ( getContext ( ) , DIR_SEQ_UPDATE , getReportLog ( ) , fileSize , BUFFER_SIZE , NUMBER_REPETITION ) ; } @TimeoutReq ( minutes = 30 ) public void testSingleSequentialRead ( ) throws Exception { final long fileSize = FileUtil . getFileSizeExceedingMemory ( getContext ( ) , BUFFER_SIZE ) ; if ( fileSize == 0 ) { // not enough space , give up return ; } long start = System . currentTimeMillis ( ) ; final File file = FileUtil . createNewFilledFile ( getContext ( ) , DIR_SEQ_RD , fileSize ) ; long finish = System . currentTimeMillis ( ) ;
private void updateSavedNetworkSelectionStatus ( ) { List < WifiConfiguration > savedNetworks = mWifiConfigManager . getSavedNetworks ( ) ; if ( savedNetworks . size ( ) == 0 ) { localLog ( "No saved networks . " ) ; return ; } StringBuffer sbuf = new StringBuffer ( "Saved Networks List : \n" ) ; for ( WifiConfiguration network : savedNetworks ) { /* * * Ignore Passpoint networks . Passpoint networks are also considered as "saved" * network , but without being persisted to the storage . They are managed * by { @link PasspointNetworkEvaluator } . */ if ( network . isPasspoint ( ) ) { continue ; } WifiConfiguration . NetworkSelectionStatus status = network . getNetworkSelectionStatus ( ) ; // If a configuration is temporarily disabled , re - enable it before trying // to connect to it . mWifiConfigManager . tryEnableNetwork ( network . networkId ) ; // TODO ( b / 30928589 ) : Enable "permanently" disabled networks if we are in DISCONNECTED // state . // Clear the cached candidate , score and seen . mWifiConfigManager . clearNetworkCandidateScanResult ( network . networkId ) ;
List < WifiConfiguration > associatedConfigurations = null ; WifiConfiguration associatedConfiguration = mWifiConfigManager . getSavedNetworkForScanDetailAndCache ( scanDetail ) ; if ( associatedConfiguration == null ) { continue ; } else { associatedConfigurations = new ArrayList < > ( Arrays . asList ( associatedConfiguration ) ) ; } for ( WifiConfiguration network : associatedConfigurations ) { /* * * Ignore Passpoint networks . Passpoint networks are also considered as "saved" * network , but without being persisted to the storage . They are being evaluated * by { @link PasspointNetworkEvaluator } . */ if ( network . isPasspoint ( ) ) { continue ; } WifiConfiguration . NetworkSelectionStatus status = network . getNetworkSelectionStatus ( ) ; status . setSeenInLastQualifiedNetworkSelection ( true ) ; if ( ! status . isNetworkEnabled ( ) ) { continue ; } else if ( network . BSSID != null && ! network . BSSID . equals ( "any" ) && ! network . BSSID . equals ( scanResult . BSSID ) ) { // App has specified the only BSSID to connect for this // configuration . So only the matching ScanResult can be a candidate .
"am stack move - top - activity - to - pinned - stack 1 0 0 500 500" ; protected static final String LAUNCHING_ACTIVITY = "LaunchingActivity" ; private static final String AM_RESIZE_DOCKED_STACK = "am stack resize - docked - stack " ; private static final String AM_MOVE_TASK = "am stack movetask " ; private static final String AM_SUPPORTS_SPLIT_SCREEN_MULTIWINDOW = "am supports - split - screen - multiwindow" ; private static final String INPUT_KEYEVENT_HOME = "input keyevent 3" ; /* * A reference to the device under test . */ protected ITestDevice mDevice ; private HashSet < String > mAvailableFeatures ; protected static String getAmStartCmd ( final String activityName ) { return "am start - n " + getActivityComponentName ( activityName ) ; } protected static String getAmStartCmdOverHome ( final String activityName ) { return "am start -- activity - task - on - home - n " + getActivityComponentName ( activityName ) ; } static String getActivityComponentName ( final String activityName ) {
public int startLocalOnlyWifiHotspot ( WifiConfiguration cfg ) { final Mode current = mMode ; if ( current != Mode . IDLE ) { if ( VDBG ) { Log . e ( TAG , "Attempt to startLocalOnlyWifiHotspot absent corresponding stop . " ) ; } return ConnectivityManager . TETHER_ERROR_SERVICE_UNAVAIL ; } mMode = Mode . LOCAL_HOTSPOT ; return setWifiTethering ( cfg , true ) ;
public int startLocalOnlyWifiHotspot ( WifiConfiguration cfg ) { if ( mMode == Mode . LOCAL_HOTSPOT ) { if ( VDBG ) { Log . e ( TAG , "Already in mode : " + current . description ) ; } return ConnectivityManager . TETHER_ERROR_SERVICE_UNAVAIL ; } mMode = Mode . LOCAL_HOTSPOT ; return setWifiTethering ( cfg , true ) ;
public void stopLocalOnlyWifiHotspot ( ) { if ( mMode != Mode . LOCAL_HOTSPOT ) { if ( VDBG ) { Log . e ( TAG , "Local hotspot not running . " ) ; } return ; } setWifiTethering ( null , false ) ;
protected boolean turnOffMasterTetherSettings ( ) { if ( ! stopIpServices ( ) ) { transitionTo ( mStopTetheringErrorState ) ; return false ; } if ( mMode == Mode . TETHERING ) { try { mNMService . setIpForwardingEnabled ( false ) ; } catch ( Exception e ) { transitionTo ( mSetIpForwardingDisabledErrorState ) ; return false ; } } transitionTo ( mInitialState ) ; return true ;
import java . util . Random ; /* * * IPv6 tethering is rather different from IPv4 owing to the absence of NAT . * This coordinator is responsible for evaluating the dedicated prefixes * assigned to the device and deciding how to divvy them up among downstream * interfaces . * * @hide */ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator . class . getSimpleName ( ) ; private static final boolean DBG = false ; private static final boolean VDBG = false ; private static class Downstream { public final TetherInterfaceStateMachine tism ; public final short subnetId ; DownstreamState ( TetherInterfaceStateMachine tism , short subnetId ) { this . tism = tism ; this . subnetId = subnetId ; } } private final ArrayList < TetherInterfaceStateMachine > mNotifyList ; private final LinkedList < DownstreamState > mActiveDownstreams ; private short mNextSubnetId ; private byte [ ] mUniqueLocalPrefix ; private NetworkState mUpstreamNetworkState ; public IPv6TetheringCoordinator ( ArrayList < TetherInterfaceStateMachine > notifyList ) { mNotifyList = notifyList ; mActiveDownstreams = new LinkedList < > ( ) ;
*/ public class IPv6TetheringCoordinator { private static final String TAG = IPv6TetheringCoordinator . class . getSimpleName ( ) ; private static final boolean DBG = false ; private static final boolean VDBG = false ; private static class DownstreamState { public final TetherInterfaceStateMachine tism ; public final short subnetId ; DownstreamState ( TetherInterfaceStateMachine tism , short subnetId ) { this . tism = tism ; this . subnetId = subnetId ; } } private final ArrayList < TetherInterfaceStateMachine > mNotifyList ; private final LinkedList < Downstream > mActiveDownstreams ; private short mNextSubnetId ; private byte [ ] mUniqueLocalPrefix ; private NetworkState mUpstreamNetworkState ; public IPv6TetheringCoordinator ( ArrayList < TetherInterfaceStateMachine > notifyList ) { mNotifyList = notifyList ; mActiveDownstreams = new LinkedList < > ( ) ; mNextSubnetId = 0 ; } public void addActiveDownstream ( TetherInterfaceStateMachine downstream ) { if ( findDownstream ( downstream ) == null ) { // Adding a new downstream appends it to the list . Adding a // downstream a second time without first removing it has no effect .
public void addActiveDownstream ( TetherInterfaceStateMachine downstream ) { if ( findDownstream ( downstream ) == null ) { // Adding a new downstream appends it to the list . Adding a // downstream a second time without first removing it has no effect . mActiveDownstreams . offer ( new Downstream ( downstream , mNextSubnetId ++ ) ) ; updateIPv6TetheringInterfaces ( ) ; }
private static byte [ ] generateUniqueLocalPrefix ( ) { final byte [ ] ulp = new byte [ 6 ] ; // 6 = 48bits / 8bits / byte ( new Random ( ) ) . nextBytes ( ulp ) ; final byte [ ] in6addr = Arrays . copyOf ( ulp , NetworkConstants . IPV6_ADDR_LEN ) ; in6addr [ 0 ] = ( byte ) 0xfd ; // fc00 : :/ 7 and L = 1 return in6addr ;
ActivityReceiverFilter appEndReceiver = new ActivityReceiverFilter ( ACTIVITY_EXIT_ACTION ) ; // The filter for the time event . ActivityReceiverFilter timeReceiver = new ActivityReceiverFilter ( ACTIVITY_TIME_TRACK_INFO ) ; // Run the activity . mContext . startActivity ( intent , options . toBundle ( ) ) ; // Wait until it finishes and end the reciever then . assertEquals ( RESULT_PASS , appEndReceiver . waitForActivity ( ) ) ; appEndReceiver . close ( ) ; if ( ! noHomeScreen ( ) ) { // At this time the timerReceiver should not fire , even though the activity has shut // down , because we are back to the home screen . assertEquals ( RESULT_TIMEOUT , timeReceiver . waitForActivity ( ) ) ; assertTrue ( timeReceiver . mTimeUsed == 0 ) ; } else { assertEquals ( RESULT_PASS , timeReceiver . waitForActivity ( ) ) ; } // Issuing now another activity will trigger the timing information release . final Intent dummyIntent = new Intent ( context , MockApplicationActivity . class ) ; dummyIntent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; final Activity activity = mInstrumentation . startActivitySync ( dummyIntent ) ; // Wait until it finishes and end the reciever then .
private CdmaSubscriptionSourceManager mCdmaSSM ; public static final String INVALID_MCC = "000" ; public static final String DEFAULT_MNC = "00" ; private HbpcdUtils mHbpcdUtils = null ; /* Used only for debugging purposes . */ private String mRegistrationDeniedReason ; private String mCurrentCarrier = null ; /* list of LTE EARFCNs ( E - UTRA Absolute Radio Frequency Channel Number , * Reference : 3GPP TS 36 . 104 5 . 4 . 3 ) * inclusive ranges for which the lte rsrp boost is applied */ private ArrayList < Pair < Integer , Integer > > mEarfcnPairListForRsrpBoost = null ; private int mLteRsrpBoost = 0 ; // offset which is reduced from the rsrp threshold // while calculating signal strength level . private final Object mLteRsrpBoostLock = new Object ( ) ; // mLteRsrpBoost lock public ServiceStateTracker ( GsmCdmaPhone phone , CommandsInterface ci ) { mPhone = phone ; mCi = ci ; mRatRatcheter = new RatRatcheter ( mPhone ) ; mVoiceCapable = mPhone . getContext ( ) . getResources ( ) . getBoolean ( com . android . internal . R . bool . config_voice_capable ) ;
/* list of LTE EARFCNs ( E - UTRA Absolute Radio Frequency Channel Number , * Reference : 3GPP TS 36 . 104 5 . 4 . 3 ) * pairs for which the lte rsrp boost is applied */ private ArrayList < Pair < Integer , Integer > > mEarfcnPairListForRsrpBoost = null ; private int mLteRsrpBoost = 0 ; // offset which is reduced from the rsrp threshold // while calculating signal strength level . private final Object mLteRsrpBoostLock = new Object ( ) ; private static final int INVALID_LTE_EARFCN = - 1 ; public ServiceStateTracker ( GsmCdmaPhone phone , CommandsInterface ci ) { mPhone = phone ; mCi = ci ; mRatRatcheter = new RatRatcheter ( mPhone ) ; mVoiceCapable = mPhone . getContext ( ) . getResources ( ) . getBoolean ( com . android . internal . R . bool . config_voice_capable ) ; mUiccController = UiccController . getInstance ( ) ; mUiccController . registerForIccChanged ( this , EVENT_ICC_CHANGED , null ) ; mCi . setOnSignalStrengthUpdate ( this , EVENT_SIGNAL_STRENGTH_UPDATE , null ) ; mCi . registerForCellInfoList ( this , EVENT_UNSOL_CELL_INFO_LIST , null ) ; mSubscriptionController = SubscriptionController . getInstance ( ) ;
&& ServiceState . isCdma ( newDataRat ) ) ) { mCi . getSignalStrength ( obtainMessage ( EVENT_GET_SIGNAL_STRENGTH ) ) ; } // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA mNewSS . setDataRoaming ( regCodeIsRoaming ( regState ) ) ; if ( DBG ) { log ( "handlPollStateResultMessage : CdmaLteSST setDataRegState = " + dataRegState + " regState = " + regState + " dataRadioTechnology = " + newDataRat ) ; } } updateServiceStateLteEarfcnBoost ( mNewSS , getLteEarfcn ( dataRegStateResult ) ) ; break ; } case EVENT_POLL_STATE_OPERATOR : { if ( mPhone . isPhoneTypeGsm ( ) ) { String opNames [ ] = ( String [ ] ) ar . result ; if ( opNames != null && opNames . length >= 3 ) { // FIXME : Giving brandOverride higher precedence , is this desired ? String brandOverride = mUiccController . getUiccCard ( getPhoneId ( ) ) != null ? mUiccController . getUiccCard ( getPhoneId ( ) ) . getOperatorBrandOverride ( ) : null ; if ( brandOverride != null ) {
private void updateLteEarfcnBoost ( int lteEarfcn ) { synchronized ( mLteRsrpBoostLock ) { if ( ( lteEarfcn != - 1 ) && containsEarfcnInEarfcnRange ( mEarfcnPairListForRsrpBoost , lteEarfcn ) ) { serviceState . setLteEarfcnRsrpBoost ( mLteRsrpBoost ) ; } else { mNewSS . setLteEarfcnRsrpBoost ( 0 ) ; } }
&& mRingingCall . getState ( ) == ImsPhoneCall . State . IDLE ) { mForegroundCall . detach ( mPendingMO ) ; removeConnection ( mPendingMO ) ; mPendingMO . finalize ( ) ; mPendingMO = null ; mPhone . initiateSilentRedial ( ) ; return ; } else { mPendingMO = null ; int cause = getDisconnectCauseFromReasonInfo ( reasonInfo ) ; ImsPhoneConnection conn = findConnection ( imsCall ) ; if ( conn != null ) { conn . setPreciseDisconnectCause ( getPreciseDisconnectCauseFromReasonInfo ( reasonInfo ) ) ; } processCallStateChange ( imsCall , ImsPhoneCall . State . DISCONNECTED , cause ) ; } mMetrics . writeOnImsCallStartFailed ( mPhone . getPhoneId ( ) , imsCall . getCallSession ( ) , reasonInfo ) ; }
* onFeatureCapabilityChanged ( int , int [ ] , int [ ] ) } callbacks , or values received via the * { @link ImsCallProfile#EXTRA_CALL_RAT_TYPE } extra . Util we receive a value via the extras , * we will use the wifi state based on the { @code onFeatureCapabilityChanged } . Once a value * is received via the extras , we will prefer those values going forward . */ private boolean mIsWifiStateFromExtras = false ; private int mPreciseDisconnectCause = 0 ; // ** ** * Event Constants private static final int EVENT_DTMF_DONE = 1 ; private static final int EVENT_PAUSE_DONE = 2 ; private static final int EVENT_NEXT_POST_DIAL = 3 ; private static final int EVENT_WAKE_LOCK_TIMEOUT = 4 ; private static final int EVENT_DTMF_DELAY_DONE = 5 ; // ** ** * Constants private static final int PAUSE_DELAY_MILLIS = 3 * 1000 ; private static final int WAKE_LOCK_TIMEOUT_MILLIS = 60 * 1000 ; // ** ** * Inner Classes class MyHandler extends Handler {
/* * Not a preempted call */ public static final int CDMA_PREEMPTED = 1007 ; /* * Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008 ; /* * Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009 ; /* * Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200 ; // The operation is invoked in invalid call state public static final int LOCAL_ILLEGAL_STATE = 1201 ; // IMS service internal error public static final int INTERNAL_ERROR = 1202 ; // IMS service goes down ( service connection is lost ) public static final int IMS_SERVICE_DOWN = 1203 ; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204 ; // Service unavailable ; by power off public static final int POWER_OFF = 1205 ; // Service unavailable ; by low battery public static final int LOW_BATTERY = 1206 ;
public static final int CDMA_PREEMPTED = 1007 ; /* * Not an emergency call */ public static final int CDMA_NOT_EMERGENCY = 1008 ; /* * Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009 ; /* * Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200 ; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201 ; // IMS service internal error public static final int LOCAL_INTERNAL_ERROR = 1202 ; // IMS service goes down ( service connection is lost ) public static final int IMS_SERVICE_DOWN = 1203 ; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204 ; // Service unavailable ; by power off public static final int POWER_OFF = 1205 ; // Service unavailable ; by low battery public static final int LOW_BATTERY = 1206 ; // Service unavailable ; by out of service ( data service state )
/* * Access Blocked by CDMA network */ public static final int CDMA_ACCESS_BLOCKED = 1009 ; /* * Mapped from ImsReasonInfo */ /* The passed argument is an invalid */ public static final int ILLEGAL_ARGUMENT = 1200 ; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201 ; // IMS service internal error public static final int INTERNAL_ERROR = 1202 ; // IMS service goes down ( service connection is lost ) public static final int LOCAL_IMS_SERVICE_DOWN = 1203 ; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204 ; // Service unavailable ; by power off public static final int POWER_OFF = 1205 ; // Service unavailable ; by low battery public static final int LOW_BATTERY = 1206 ; // Service unavailable ; by out of service ( data service state ) public static final int NETWORK_NO_SERVICE = 1207 ; /* Service unavailable ; by no LTE coverage * ( VoLTE is not supported even though IMS is registered )
public static final int ILLEGAL_ARGUMENT = 1200 ; // The operation is invoked in invalid call state public static final int ILLEGAL_STATE = 1201 ; // IMS service internal error public static final int INTERNAL_ERROR = 1202 ; // IMS service goes down ( service connection is lost ) public static final int IMS_SERVICE_DOWN = 1203 ; // No pending incoming call exists public static final int NO_PENDING_CALL = 1204 ; // Service unavailable ; by power off public static final int LOCAL_POWER_OFF = 1205 ; // Service unavailable ; by low battery public static final int LOW_BATTERY = 1206 ; // Service unavailable ; by out of service ( data service state ) public static final int NETWORK_NO_SERVICE = 1207 ; /* Service unavailable ; by no LTE coverage * ( VoLTE is not supported even though IMS is registered ) */ public static final int NETWORK_NO_LTE_COVERAGE = 1208 ; /* * Service unavailable ; by located in roaming area */ public static final int NETWORK_ROAMING = 1209 ;
/* * Service unavailable ; by located in roaming area */ public static final int NETWORK_ROAMING = 1209 ; /* * Service unavailable ; by IP changed */ public static final int NETWORK_IP_CHANGED = 1210 ; /* * Service unavailable ; other */ public static final int SERVICE_UNAVAILABLE = 1211 ; /* Service unavailable ; IMS connection is lost ( IMS is not registered ) */ public static final int NOT_REGISTERED = 1212 ; /* * Max call exceeded */ public static final int LOCAL_MAX_CALL_EXCEEDED = 1213 ; /* * Call decline */ public static final int LOCAL_CALL_DECLINE = 1214 ; /* * SRVCC is in progress */ public static final int VCC_ON_PROGRESSING = 1215 ; /* * Resource reservation is failed ( QoS precondition ) */ public static final int RESOURCE_RESERVATION_FAILED = 1216 ; /* * Retry CS call ; VoLTE service can't be provided by the network or remote end * Resolve the extra code ( EXTRA_CODE_CALL_RETRY_ * ) if the below code is set */

public Canvas addShapeIntoView ( final Shape shape ) { if ( shape . getUUID ( ) == null ) { shape . setUUID ( UUID . uuid ( ) ) ; } getView ( ) . add ( shape . getShapeView ( ) ) ; return this ; }
public boolean getRequiredParamBoolean ( final String key ) throws ActionParamsException { final String val = getRequiredParam ( key ) ; try { return Boolean . parseBoolean ( val ) ; } catch ( Exception e ) { throw new ActionParamsException ( e . getMessage ( ) ) ; } }
public void onPingFromClient ( PingFromClientEvent event , EntityRef entity ) { Instant end = Instant . now ( ) ; endMap . put ( entity , end ) ; updatePing ( entity ) ; }
public boolean areEqual ( MapObject o1 , MapObject o2 ) { if ( o1 == null ) { return o2 == null ; } else { return o1 . id . equals ( o2 . id ) ; } }
public RedisMetadataStore ( RedisConnectionFactory connectionFactory ) { Assert . notNull ( connectionFactory , "'connectionFactory' must not be null . " ) ; this . redisTemplate = new StringRedisTemplate ( connectionFactory ) ; }
public CompleteTransactionMessage ( long initiatorHSId , long coordinatorHSId , long txnId , boolean isReadOnly , int hash , boolean isRollback , boolean requiresAck , boolean isRestart , boolean isForReplay ) { super ( initiatorHSId , coordinatorHSId , txnId , 0 , isReadOnly , isForReplay ) ; m_hash = hash ; setBit ( ISROLLBACK , isRollback ) ; setBit ( REQUIRESACK , requiresAck ) ; setBit ( ISRESTART , isRestart ) ; }
private CuEinvoiceDao getCuEinvoiceDao ( ) { if ( ObjectUtils . isNull ( cuEinvoiceDao ) ) { cuEinvoiceDao = SpringContext . getBean ( CuEinvoiceDaoOjb . class ) ; } return cuEinvoiceDao ; }
private static EchoTagStatementTree newEchoTagStatement ( ExpressionTree expression , InternalSyntaxToken eosToken ) { SeparatedList < ExpressionTree > expressionList = new SeparatedListImpl < > ( Collections . singletonList ( expression ) , Collections . emptyList ( ) ) ; return newEchoTagStatement ( expressionList , eosToken ) ; }
private static TextSummarizer getLocalSummarizer ( ) { Collection < ? extends TextSummarizer > summarizers = Lookup . getDefault ( ) . lookupAll ( TextSummarizer . class ) ; if ( ! summarizers . isEmpty ( ) ) { summarizerToUse = summarizers . iterator ( ) . next ( ) ; return summarizerToUse ; } return null ; }
public void verifyNoVideo ( ) { if ( checkIfElementOnPage ( mediaNode ) ) { throw new AssertionError ( "Media Node is still on the page" ) ; } else { PageObjectLogging . log ( "verifyNoVideo" , "Verified no video is on page" , true , driver ) ; } }
private void startOrStopGeoDataListener ( ) { geoDataSubscription . unsubscribe ( ) ; if ( requireGeodata ) { geoDataSubscription = locationUpdater . start ( GeoDirHandler . UPDATE_GEODATA ) ; } }
ZipFormatter ( Formatters formatters , FormatterUtil formatterUtil , HtmlBuilder html ) { this . util = formatterUtil ; this . html = html ; }
private boolean clusterHasPpcArchitecture ( ) { Cluster cluster = getModel ( ) . getSelectedCluster ( ) ; return cluster != null && cluster . getArchitecture ( ) != null && ArchitectureType . ppc == cluster . getArchitecture ( ) . getFamily ( ) ; }
private void createIndex ( Connection conn , String indexExt , String columnName ) throws PersistenceException { if ( metaData . isIndexingDisabled ( ) ) return ; boolean indexExists = indexExists ( getIndexName ( false , indexExt ) , conn ) ; if ( ! indexExists ) { String ddl = String . format ( "CREATE INDEX % s ON % s ( % s ) " , getIndexName ( true , indexExt ) , getTableName ( ) , columnName ) ; if ( log . isTraceEnabled ( ) ) { log . tracef ( "Adding index with following DDL : ' % s' . " , ddl ) ; } executeUpdateSql ( conn , ddl ) ; } }
public Object getValue ( ) { return value ; }
private boolean needProjectionNode ( AbstractPlanNode root ) { if ( ! root . planNodeClassNeedsProjectionNode ( ) ) { return false ; } // If there is a complexGroupby at his point , it means that // display columns contain all the order by columns and // does not require another projection node on top of sort node . // If there is a complex aggregation case , the projection plan node is already added // right above the group by plan node . In future , we may inline that projection node . if ( m_parsedSelect . hasComplexGroupby ( ) || m_parsedSelect . hasComplexAgg ( ) ) { return false ; } if ( root instanceof AbstractReceivePlanNode && m_parsedSelect . hasPartitionColumnInGroupby ( ) ) { // Top aggregate has been removed , its schema is exactly the same to // its local aggregate node . return false ; } return true ; }
public void isExecutable_HeaderCellSelected ( ) { when ( scenarioGridModelMock . getSelectedCells ( ) ) . thenReturn ( Collections . emptyList ( ) ) ; when ( scenarioGridModelMock . getSelectedHeaderCells ( ) ) . thenReturn ( Arrays . asList ( selectedCell , selectedCell2 ) ) ; assertTrue ( handler . isExecutable ( scenarioGridMock ) ) ; }
public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof XarSecurityRule ) ) { return false ; } XarSecurityRule rhs = ( XarSecurityRule ) object ; return new EqualsBuilder ( ) . append ( this . right , rhs . right ) . append ( this . simple , rhs . simple ) . isEquals ( ) ; }
public static boolean containsSearchAnnotations ( XClass mappedClass ) { List < XClass > hierarchy = createXClassHierarchy ( mappedClass ) ; for ( XClass clazz : hierarchy ) { if ( containsLocalSearchAnnotation ( clazz ) ) { return true ; } } return false ; }
private static int computeNewVectorCapacity ( int usedCapacity , int newPayload , int currentCapacity ) { int newUsedCapacity = BaseAllocator . nextPowerOfTwo ( usedCapacity + newPayload ) ; assert newUsedCapacity >= 0 ; return Math . max ( currentCapacity , newUsedCapacity ) ; }
private static void cleanShutdown ( ) { log . info ( "CleanShutdown : Starting Cleanup . " ) ; shutdownServer = true ; try { CorfuServerNode current = activeServer ; if ( current != null ) { current . close ( ) ; } } catch ( Throwable th ) { log . error ( "cleanShutdown : failed during shutdown" , th ) ; } // Flush the async appender before exiting to prevent the loss of logs LoggerContext loggerContext = ( LoggerContext ) LoggerFactory . getILoggerFactory ( ) ; loggerContext . stop ( ) ; }
public void preInit ( FMLPreInitializationEvent event ) { configDir = new File ( event . getModConfigurationDirectory ( ) , "antiqueatlas" ) ; configDir . mkdir ( ) ; extTileIdMap = ExtTileIdMap . instance ( ) ; extTileConfig = new ExtTileConfig ( new File ( configDir , "tileids . json" ) ) ; extTileConfig . load ( extTileIdMap ) ; // Assign default values AFTER the config file loads , so that the old saved values are kept : registerVanillaCustomTiles ( ) ; checkSaveConfig ( ) ; }
public void close ( ) { try { if ( this . readingRaw . get ( ) && ! finalizeRaw ( ) && LOGGER . isWarnEnabled ( ) ) { LOGGER . warn ( "Finalize on readRaw ( ) returned false for " + this ) ; } if ( this . client . isConnected ( ) ) { this . client . logout ( ) ; } this . client . disconnect ( ) ; } catch ( Exception e ) { LOGGER . warn ( "failed to disconnect FTPClient" , e ) ; } }
protected FileType doGetType ( ) throws Exception { return this . stat == null ? FileType . IMAGINARY : FileType . FILE_OR_FOLDER ; }
public EquivalentHashMap ( int initialCapacity , float loadFactor , Equivalence < K > keyEq , Equivalence < V > valueEq ) { int capacity = 1 ; while ( capacity < initialCapacity ) capacity < <= 1 ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; table = new Node [ capacity ] ; this . keyEq = keyEq ; this . valueEq = valueEq ; }
private void mockSSHClient ( ) { try { doNothing ( ) . when ( sshclient ) . connect ( ) ; doNothing ( ) . when ( sshclient ) . authenticate ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public static String sanitizeKey ( final Contentlet vanityUrl ) throws DotDataException , DotSecurityException { Host host = hostAPI . find ( vanityUrl . getStringProperty ( VanityUrlContentType . SITE_FIELD_VAR ) , APILocator . systemUser ( ) , false ) ; return sanitizeKey ( host . getIdentifier ( ) , fixURI ( vanityUrl . getStringProperty ( VanityUrlContentType . URI_FIELD_VAR ) ) , vanityUrl . getLanguageId ( ) ) ; }
protected void dataTemplateToJsonGenerator ( Object data , DataSchema schema , JsonGenerator generator , boolean order ) throws IOException { if ( order ) { JacksonTraverseCallback callback = new SchemaOrderTraverseCallback ( schema , generator ) ; Data . traverse ( data , callback ) ; } else { objectToJsonGenerator ( data , generator ) ; } }
public void execute ( ) throws ServerApiException , ConcurrentOperationException { ListResponse < KubernetesSupportedVersionResponse > response = kubernetesVersionService . listKubernetesSupportedVersions ( this ) ; response . setResponseName ( getCommandName ( ) ) ; setResponseObject ( response ) ; }
public void loggedInUserPropertyFalseTest ( ) throws Exception { configurationService . setProperty ( "webui . user . assumelogin" , false ) ; String token = getAuthToken ( admin . getEmail ( ) , password ) ; getClient ( token ) . perform ( get ( " / api / authn / status" ) . header ( "X - On - Behalf - Of" , eperson . getID ( ) ) ) . andExpect ( status ( ) . isBadRequest ( ) ) ; }
protected void addExtraHeaders ( Builder webResource ) { if ( additionalHeaders != null ) { for ( Map . Entry < String , List < Object > > entry : additionalHeaders . entrySet ( ) ) { webResource . header ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }
private boolean hasNewFragment ( EList < InteractionFragment > currentList , List < InteractionFragment > newList ) { return ( newList . size ( ) > currentList . size ( ) ) ; }
void closeResultSets ( ) throws SQLException { closeResultSets ( activeResultSets ) ; generatedKeysResultSet = null ; }
public boolean isTemplateAvailable ( String view , Environment environment , ClassLoader classLoader , ResourceLoader resourceLoader ) { if ( ClassUtils . isPresent ( "org . apache . jasper . compiler . JspConfig" , classLoader ) ) { String resourceName = getResourceName ( view , environment ) ; if ( resourceLoader . getResource ( resourceName ) . exists ( ) ) { return true ; } try { return new File ( "src / main / webapp" , resourceName ) . exists ( ) ; } catch ( AccessControlException ex ) { } } return false ; }
public T visit ( final AntlrBaseNode node ) { return node . accept ( this ) ; }
public static void addDiskToVm ( BaseDisk disk , Guid vmId ) { DbFacade . getInstance ( ) . getBaseDiskDao ( ) . save ( disk ) ; VmDeviceUtils . addManagedDevice ( new VmDeviceId ( disk . getId ( ) , vmId ) , VmDeviceType . DISK , VmDeviceType . DISK , null , true , false ) ; }
private static Throwable getConfigFailureException ( ITestContext context ) { for ( IInvokedMethod method : context . getSuite ( ) . getAllInvokedMethods ( ) ) { ITestNGMethod m = method . getTestMethod ( ) ; if ( m . isBeforeSuiteConfiguration ( ) && ( ! method . getTestResult ( ) . isSuccess ( ) ) ) { return method . getTestResult ( ) . getThrowable ( ) ; } } return null ; }
protected String toString ( Operator operator ) { if ( Operator . STARTSWITH . equals ( operator ) ) { return LIKE ; } return operator . toString ( ) ; }
static UberDocument toUberDocument ( final Object object ) { if ( object == null ) { return null ; } if ( object instanceof UberDocument ) { return ( UberDocument ) object ; } throw new IllegalArgumentException ( "Don't know how to handle type : " + object . getClass ( ) ) ; }
private ArgumentSplitter ( String arguments ) { this . arguments = arguments ; }
public LgoProducts getProducts ( ) throws IOException { return this . proxy . getProducts ( exchange . getNonceFactory ( ) . createValue ( ) , exchange . getSignatureService ( ) ) ; }
protected void addAttachmentToNote ( T document , AccountingXmlDocumentBackupLink backupLink , Note note ) { try { Attachment attachment = accountingXmlDocumentDownloadAttachmentService . createAttachmentFromBackupLink ( document , backupLink ) ; note . setAttachment ( attachment ) ; } catch ( IOException e ) { LOG . error ( "addAttachmentToNote , unable to create attachment : " + e . getMessage ( ) ) ; String message = MessageFormat . format ( configurationService . getPropertyValueAsString ( CuFPKeyConstants . ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD ) , backupLink . getLinkUrl ( ) ) ; throw new ValidationException ( message ) ; } }
public Void getResult ( ) { throw new UnsupportedOperationException ( ) ; }
public PlanWithProperties visitUnnest ( UnnestNode node , PreferredProperties preferredProperties ) { PreferredProperties translatedPreferred = preferredProperties . translate ( variable - > node . getReplicateVariables ( ) . contains ( variable ) ? Optional . of ( variable ) : Optional . empty ( ) ) ; return rebaseAndDeriveProperties ( node , planChild ( node , translatedPreferred ) ) ; }
public ValidationResult isAnyDomainInProcess ( ) { List < StoragePoolIsoMap > poolIsoMaps = getStoragePoolIsoMapDao ( ) . getAllForStoragePool ( storagePool . getId ( ) ) ; for ( StoragePoolIsoMap domainIsoMap : poolIsoMaps ) { if ( domainIsoMap . getStatus ( ) != null && domainIsoMap . getStatus ( ) . isStorageDomainInProcess ( ) ) { return new ValidationResult ( VdcBllMessages . ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2 , String . format ( "$status % 1$s" , domainIsoMap . getStatus ( ) ) ) ; } } return ValidationResult . VALID ; }
private static boolean isFunctionNameMatch ( RowExpression rowExpression , String expectedName ) { if ( castToExpression ( rowExpression ) instanceof FunctionCall ) { return ( ( FunctionCall ) castToExpression ( rowExpression ) ) . getName ( ) . toString ( ) . equalsIgnoreCase ( expectedName ) ; } return false ; }
public boolean hasError ( ) { return result != null && CommandResult . Type . ERROR . equals ( result . getType ( ) ) ; }
private void setupVdsNetworkInterfaceDao ( ) { List < VdsNetworkInterface > expectedVdsNetworkInterface = Collections . singletonList ( vdsNetworkInterface ) ; when ( vdsNetworkInterfaceDaoMock . getVdsInterfacesByNetworkId ( networkId ) ) . thenReturn ( expectedVdsNetworkInterface ) ; when ( getDbFacadeMockInstance ( ) . getInterfaceDao ( ) ) . thenReturn ( vdsNetworkInterfaceDaoMock ) ; }
protected void setProject ( IProject project ) { this . project = project ; }
public List < String > values ( String name ) { return headers == null ? null : headers . get ( name ) ; }
protected Pair < Recipients , Boolean > doInBackground ( Recipients . . . recipients ) { Capability textCapability = DirectoryHelper . getUserCapabilities ( context , recipients [ 0 ] ) . getTextCapability ( ) ; return new Pair < > ( recipients [ 0 ] , textCapability == Capability . SUPPORTED ) ; }
public void cleanup ( ) { myNavigationHelper . cleanup ( ) ; }
private static DateTime setBeginValidTime ( DateTime beginValidTimeArg , DateTime issueInstant ) { DateTime beginValidTime = beginValidTimeArg ; final DateTime now = new DateTime ( ) ; if ( beginValidTime == null || beginValidTime . isAfter ( now ) ) { beginValidTime = now ; } // If provided time is after the given issue instant , // modify it to include the issue instant if ( beginValidTime . isAfter ( issueInstant ) ) { if ( issueInstant . isAfter ( now ) ) { beginValidTime = now ; } } else { beginValidTime = issueInstant ; } return beginValidTime ; }
void setupRestrictedNotification ( ) { final Resources res = getResources ( mContext , mActiveDataSubId ) ; final String title = res . getString ( R . string . disable_tether_notification_title ) ; final String message = res . getString ( R . string . disable_tether_notification_message ) ; showNotification ( R . drawable . stat_sys_tether_general , title , message , "" ) ; }
protected File getFeatureTypeDir ( File featureTypesBaseDir , String namespacePrefix , String typeName ) { return new File ( featureTypesBaseDir , getDataStoreName ( namespacePrefix , typeName ) ) ; }
public static void setupSystemProperties ( ) { // These are not needed for the tests System . setProperty ( "org . uberfire . nio . git . daemon . enabled" , "false" ) ; System . setProperty ( "org . uberfire . nio . git . ssh . enabled" , "false" ) ; System . setProperty ( "org . uberfire . sys . repo . monitor . disabled" , "true" ) ; }
public void setPreferredAgencies ( String s ) { if ( ! s . isEmpty ( ) ) { preferredAgencies = new HashSet < > ( ) ; Collections . addAll ( preferredAgencies , s . split ( " , " ) ) ; } }
synchronized void updateSubscribedTopics ( final Set < String > topics , final String logPrefix ) { log . debug ( " { } found { } topics possibly matching subscription" , logPrefix , topics . size ( ) ) ; subscriptionUpdates . clear ( ) ; subscriptionUpdates . addAll ( topics ) ; setRegexMatchedTopicsToSourceNodes ( ) ; setRegexMatchedTopicToStateStore ( ) ; }
public void releaseCursor ( Cursor cursor ) { try { cursor . release ( ) ; if ( cursors . remove ( cursor ) && provider . isClosed ( ) && cursors . isEmpty ( ) ) { releaseResources ( ) ; } } catch ( Exception e ) { LOGGER . warn ( "Exception was found trying to release cursor resources . Execution will continue" , e ) ; } finally { statistics . decrementOpenCursors ( ) ; } }
protected void doStop ( ) { if ( autoEncryptionSupport != null ) { autoEncryptionSupport . close ( ) ; } super . doStop ( ) ; LDAPCache . clear ( ) ; }
Now ( A a ) { this . a = a ; }
private String getWorkspaceRelativePath ( String sourcePath ) { if ( org . apache . commons . lang . StringUtils . isBlank ( sourcePath ) || sourcePath . contains ( " { " ) ) { return sourcePath ; } IPath absolutePath = new Path ( sourcePath ) ; IContainer container = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getContainerForLocation ( absolutePath ) ; if ( container != null ) { return container . getFullPath ( ) . toString ( ) ; } return null ; }
private void buildErrataDetailPanel ( ) { errataDetailPanel . clear ( ) ; errataDetailFormPanel = new GeneralFormPanel ( ) ; errataTitle = new Span ( ) ; errataTitle . setStyleName ( style . errataTitleLabel ( ) ) ; FlowPanel errataTitlePanel = new FlowPanel ( ) ; errataTitlePanel . setStyleName ( style . errataTitlePanel ( ) ) ; errataTitlePanel . add ( errataTitle ) ; errataDetailPanel . add ( errataTitlePanel ) ; errataDetailPanel . add ( errataDetailFormPanel ) ; }
public List < String > getMoreStable ( String branch ) { int i = order . indexOf ( fullName ( branch ) ) ; if ( 0 <= i ) { return order . subList ( i + 1 , order . size ( ) ) ; } else { return ImmutableList . of ( ) ; } }
public void notifyListeners ( int eventType , Event event ) { if ( this . dropdownTable != null && ! this . dropdownTable . isDisposed ( ) ) this . dropdownTable . notifyListeners ( eventType , event ) ; }
public static void setup ( ) throws Exception { startMiniDfsCluster ( TestSqlStdBasedAuthorization . class . getSimpleName ( ) ) ; prepHiveConfAndData ( ) ; setSqlStdBasedAuthorizationInHiveConf ( ) ; startHiveMetaStore ( ) ; startDrillCluster ( true ) ; addHiveStoragePlugin ( getHivePluginConfig ( ) ) ; addMiniDfsBasedStorage ( new HashMap < > ( ) ) ; generateTestData ( ) ; }
public OrderType retireOrderType ( OrderType orderType , String reason ) { orderType . setRetired ( true ) ; orderType . setRetireReason ( reason ) ; return saveOrderType ( orderType ) ; }
private void updateFiltersCheckState ( ) { ICommonFilterDescriptor filterDescriptor ; INavigatorFilterService filterService = getContentService ( ) . getFilterService ( ) ; for ( Object child : filterContentProvider . getElements ( getContentService ( ) ) ) { filterDescriptor = ( ICommonFilterDescriptor ) child ; if ( filterService . isActive ( filterDescriptor . getId ( ) ) ) { getTableViewer ( ) . setChecked ( child , true ) ; getCheckedItems ( ) . add ( child ) ; } else { getTableViewer ( ) . setChecked ( child , false ) ; } } }
public FeatureTypeStyle transform ( MBStyle styleContext , Double minScaleDenominator , Double maxScaleDenominator ) { // Would prefer to accept zoom levels here ( less concepts in our API ) // If we accept zoom levels we may be able to reduce , and return a list of FeatureTypeStyles // ( with the understanding that the list may be empty if the MBLayer does not contribute any content // at a specific zoom level range ) FeatureTypeStyle style = transform ( styleContext ) ; if ( style == null ) { return null ; } for ( Rule rule : style . rules ( ) ) { if ( minScaleDenominator != null ) { rule . setMinScaleDenominator ( minScaleDenominator ) ; } if ( maxScaleDenominator != null ) { rule . setMaxScaleDenominator ( maxScaleDenominator ) ; } } return style ; }
public Optional < RevCommit > areAllReachable ( Collection < RevCommit > targets , Collection < RevCommit > starters ) throws MissingObjectException , IncorrectObjectTypeException , IOException { walk . reset ( ) ; if ( topoSort ) { walk . sort ( RevSort . TOPO ) ; } for ( RevCommit target : targets ) { walk . markStart ( target ) ; } for ( RevCommit starter : starters ) { walk . markUninteresting ( starter ) ; } return Optional . ofNullable ( walk . next ( ) ) ; }
public Optional < SessionStore < J2EContext > > buildFromTrackableSession ( final J2EContext context , final Object trackableSession ) { return trackableSession != null ? Optional . of ( new J2EProvidedSessionStore ( ( HttpSession ) trackableSession ) ) : Optional . empty ( ) ; }
public Response awaitResponse ( ) throws Exception { return remoteFuture . get ( ) ; }
static boolean isDefaultArgumentsConstructor ( final MethodNode methodNode ) { if ( ! " < init > " . equals ( methodNode . name ) ) { return false ; } final Type [ ] argumentTypes = Type . getMethodType ( methodNode . desc ) . getArgumentTypes ( ) ; if ( argumentTypes . length < 2 ) { return false ; } return "kotlin . jvm . internal . DefaultConstructorMarker" . equals ( argumentTypes [ argumentTypes . length - 1 ] . getClassName ( ) ) ; }
public void increment ( long amount ) { long now = clock . now ( ) / 1000L ; if ( now != currentSecond . get ( ) ) { currentCount . set ( 0 ) ; currentSecond . set ( now ) ; } long count = currentCount . addAndGet ( amount ) ; updatePeak ( count ) ; }
public static void assertValidSubmodulePath ( String path ) throws SubmoduleValidationException { if ( path . startsWith ( " - " ) ) { // $NON - NLS - 1$ throw new SubmoduleValidationException ( MessageFormat . format ( JGitText . get ( ) . submodulePathInvalid , path ) , GITMODULES_PATH ) ; } }
public String getMessage ( ) { String message = super . getMessage ( ) ; if ( pql . isPresent ( ) ) { message += " with pql \"" + pql . get ( ) + "\"" ; } return message ; }
protected AbstractGraphDecorator ( Graph g ) { if ( g == null ) { throw new IllegalArgumentException ( "g may not be null . " ) ; } this . inner = g ; }
public boolean isDTS ( ) { return getCodecA ( ) != null && ( getCodecA ( ) . contains ( "dts" ) || getCodecA ( ) . contains ( "dca" ) ) ; }
CacheCollection < V > values ( EnumSet < Flag > explicitFlags , ClassLoader explicitClassLoader ) { return new ValueCacheCollection < > ( this , cacheEntrySet ( explicitFlags , explicitClassLoader ) ) ; }
public synchronized void setBrightnessInUserInterfaceDimensionUnit ( float percent ) { if ( percent < 0f ) { percent = 0f ; } else if ( percent > 200f ) { percent = 200f ; } brightness = percent / 100f ; refreshTextures ( true ) ; }
public void setForceEndTransactions ( boolean forceEndTransactions ) { this . forceEndTransactions = forceEndTransactions ; }
protected Cause createUpstreamCause ( Run < ? , ? > build ) { if ( Jenkins . getInstance ( ) . getPlugin ( "promoted - builds" ) != null ) { // Test only when promoted - builds is installed . if ( build instanceof Promotion ) { Promotion promotion = ( Promotion ) build ; // This cannot be done for PromotionCause#PromotionCause is in a package scope . // return new PromotionCause ( build , promotion . getTarget ( ) ) ; return new UpstreamCause ( ( Run < ? , ? > ) promotion . getTarget ( ) ) ; } } return new UpstreamCause ( build ) ; }
public static < Arg1 , Arg2 extends Arg1 > boolean nullSafeEquals ( Arg1 d1 , Arg2 d2 ) { if ( d1 == null ) { return d2 == null ; } else if ( d2 == null ) { return false ; } return ( d1 instanceof Date && d2 instanceof Date ) ? compare ( ( Date ) d1 , ( Date ) d2 ) == 0 : d1 . equals ( d2 ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final HeapObject other = ( HeapObject ) obj ; if ( node == null ) { return other . node == null ; } return node . equals ( other . node ) ; }
public void testSignalIntermediateThrow ( ) throws Exception { KieBase kbase = createKnowledgeBase ( "BPMN2 - IntermediateThrowEventSignal . bpmn2" ) ; ksession = createKnowledgeSession ( kbase ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( "x" , "MyValue" ) ; ProcessInstance processInstance = ksession . startProcess ( "SignalIntermediateEvent" , params ) ; assertThat ( processInstance . getState ( ) ) . isEqualTo ( ProcessInstance . STATE_COMPLETED ) ; }
public KHyperLogLog ( int maxSize , int hllBuckets , Long2ObjectSortedMap < HyperLogLog > minhash ) { this . maxSize = maxSize ; this . hllBuckets = hllBuckets ; this . minhash = requireNonNull ( minhash , "minhash is null" ) ; minhash . values ( ) . forEach ( this : : increaseTotalHllSize ) ; }
public ChangeControl controlFor ( Change change , CurrentUser user ) throws NoSuchChangeException { try { return projectControl . controlFor ( change . getProject ( ) , user ) . controlFor ( change ) ; } catch ( NoSuchProjectException e ) { throw new NoSuchChangeException ( change . getId ( ) , e ) ; } }
public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; try { mListener = ( ShareFragmentListener ) activity ; } catch ( IllegalStateException e ) { throw new IllegalStateException ( activity . toString ( ) + " must implement OnShareFragmentInteractionListener" ) ; } }
public void afterTaskInputVariableChangedEvent ( TaskEvent event , Map < String , Object > variables ) { if ( variables == null || variables . isEmpty ( ) ) { return ; } Task task = event . getTask ( ) ; List < TaskVariableImpl > taskVariables = indexVariables ( task , variables , VariableType . INPUT ) ; sendMessage ( new AuditTaskData ( null , null , taskVariables , null ) , 2 ) ; }
public RubyGemParser ( IFile file ) throws IOException , CoreException { mSetupDefinitions = new HashMap < String , ArrayList < String > > ( ) ; mSetupDependencies = new HashMap < String , ArrayList < String > > ( ) ; if ( file . getContents ( ) . available ( ) <= 0 ) { return ; } this . file = file ; gemVariable = "" ; parse ( ) ; }
public boolean canHandle ( Message < ? > message ) { return message instanceof DeadlineMessage && deadlineNameMatch ( ( DeadlineMessage ) message ) && super . canHandle ( message ) ; }
private void checkImportedSymbol ( Symbol symbol ) { for ( IdentifierTree usageIdentifier : symbol . usages ( ) ) { Tree parent = usageIdentifier . parent ( ) ; if ( parent . is ( Kind . MEMBER_SELECT ) && ( ( MemberSelectExpressionTree ) parent ) . expression ( ) . is ( Kind . MEMBER_SELECT ) ) { reportIssue ( parent , String . format ( MESSAGE , symbol . name ( ) ) ) ; } } }
public void jmsPort_shouldBeExportedWithCorrectId ( ) throws Exception { OutgoingPort serviceWithId = OpenEngSBCoreServices . getServiceUtilsService ( ) . getServiceWithId ( OutgoingPort . class , "jms - json" , 60000 ) ; assertNotNull ( serviceWithId ) ; }
private EventHandler createContextEventHandler ( ) { if ( contextEventHandler == null ) { contextEventHandler = event - > handleContextSet ( event ) ; } return contextEventHandler ; }
public AnnotationValueReader ( @Nonnull DexBuffer dex , @Nonnull ByteInput in ) { super ( dex , in ) ; }
protected Blob convertBlobToMimeType ( Blob blob , String destinationMimeType ) { BlobHolder bh = new SimpleBlobHolder ( blob ) ; bh = convertToMimeType ( destinationMimeType , bh , null ) ; return bh == null ? null : bh . getBlob ( ) ; }
private Set < SupportedAdditionalClusterFeature > getAdditionalClusterFeaturesAdded ( ) { // Lets not modify the existing collection . Hence creating a new hashset . Set < SupportedAdditionalClusterFeature > featuresSupported = new HashSet < > ( getVdsGroup ( ) . getAddtionalFeaturesSupported ( ) ) ; featuresSupported . removeAll ( clusterFeatureDao . getSupportedFeaturesByClusterId ( getVdsGroup ( ) . getId ( ) ) ) ; return featuresSupported ; }
static void runScript ( String filename , Connection cx ) throws SQLException { try { SqlUtil . runScript ( new GeoPackage ( ) . getClass ( ) . getResourceAsStream ( filename ) , cx ) ; } catch ( IOException e ) { throw new SQLException ( e ) ; } }
public void recycleAttributes ( long ts ) { fPoolAttributes . entrySet ( ) . forEach ( e - > { NonNullUtils . checkNotNull ( e . getKey ( ) ) . recycle ( e . getValue ( ) , ts ) ; } ) ; }
public boolean hasNext ( ) { // If we have the next element pipelined , go ahead and return true . if ( next != null ) { return true ; } // If the iterator is valid , this means that the next entry exists . checkInvariants ( ) ; if ( iterator . isValid ( ) ) { // Go ahead and cache that entry . next = new AbstractMap . SimpleEntry ( serializer . deserialize ( Unpooled . wrappedBuffer ( iterator . key ( ) ) , corfuRuntime ) , serializer . deserialize ( Unpooled . wrappedBuffer ( iterator . value ( ) ) , corfuRuntime ) ) ; // Advance the underlying iterator . iterator . next ( ) ; } else { // If there is no more elements to consume , we should release the resources . iterator . close ( ) ; } return next != null ; }
public int run ( ) throws IOException { int b ; if ( in != null ) { while ( ( b = in . read ( ) ) != - 1 ) { out . write ( b ) ; } in . close ( ) ; } out . close ( ) ; return - 1 ; }
public List < Cohort > getCohortsContainingPatientId ( Integer patientId ) throws DAOException { return getCohortsContainingPatientId ( patientId , false ) ; }
protected void init ( final ImmutableMap < String , Object > execEnvVars ) throws DbException { try { tupleWriter . open ( dataSink . getOutputStream ( ) ) ; tupleWriter . writeColumnHeaders ( getChild ( ) . getSchema ( ) . getColumnNames ( ) ) ; } catch ( IOException e ) { throw new DbException ( e ) ; } }
public long getSizeInBytes ( ) { long sizeInBytes = 0 ; for ( int i = 0 ; i < partitionData . length ; i ++ ) { sizeInBytes += partitionData [ i ] . getSizeInBytes ( ) ; } return sizeInBytes ; }
public FixedRealVarImpl ( String name , double value , Model model ) { this ( name , value , value , model ) ; }
public void isGreaterThan ( ) throws Exception { assertTrue ( V3_0 . isGreaterThan ( of ( 2 , 0 ) ) ) ; assertFalse ( V3_0 . isGreaterThan ( of ( 3 , 0 ) ) ) ; assertFalse ( V3_0 . isGreaterThan ( of ( 4 , 0 ) ) ) ; }
private String extractDefinitionLine ( String typeDeclaration ) { String typeLine = "" ; String [ ] lines = typeDeclaration . split ( "\n" ) ; for ( String line : lines ) { typeLine = line ; if ( line . contains ( " { " ) ) { break ; } } return typeLine ; }
public ItemAshenMask ( ArmorMaterial material , int renderIndex , EntityEquipmentSlot slot , AshenMasks maskType ) { super ( material , renderIndex , slot ) ; this . maskType = maskType ; ItemRegistry . maskMap . put ( maskType , this ) ; }
private void onSuccess ( ) { errorCount . getAndSet ( 0 ) ; }
private ApplicationReportModel createAppDependencyGraphReport ( GraphContext context ) { ApplicationReportService applicationReportService = new ApplicationReportService ( context ) ; ApplicationReportModel report = applicationReportService . create ( ) ; report . setReportPriority ( 104 ) ; report . setReportIconClass ( "glyphicon glyphicon - tree - deciduous" ) ; report . setTemplatePath ( TEMPLATE ) ; report . setTemplateType ( TemplateType . FREEMARKER ) ; report . setDisplayInApplicationReportIndex ( Boolean . TRUE ) ; return report ; }
private void startClient ( ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException , UnknownHostException { if ( client == null ) { LOG . info ( "Connecting to the ElasticSearch cluster : " + configuration . getClusterName ( ) ) ; if ( configuration . getHostAddressesList ( ) != null && ! configuration . getHostAddressesList ( ) . isEmpty ( ) ) { client = createClient ( ) ; } else { LOG . warn ( "Incorrect ip address and port parameters settings for ElasticSearch cluster" ) ; } } }
protected String getRemoveQosMessage ( int size ) { return ConstantsManager . getInstance ( ) . getMessages ( ) . removeStorageQoSMessage ( size ) ; }
public static Map < Guid , List < DiskImage > > getImagesLeaf ( List < DiskImage > images ) { Map < Guid , List < DiskImage > > retVal = new HashMap < > ( ) ; images . forEach ( image - > MultiValueMapUtils . addToMap ( image . getId ( ) , image , retVal ) ) ; retVal . values ( ) . forEach ( ImagesHandler : : sortImageList ) ; return retVal ; }
protected void moveToState ( STATE to ) { if ( state . get ( ) != to ) { moveToState ( state . get ( ) , to ) ; } }
public void writeTo ( Resource file ) throws JDOMException , IOException { try ( OutputStream out = path . out ( ) ) { IOUtils . write ( body , out ) ; } }
protected ApplicationFetchException ( String apiKey , ErrorCode errorCode ) { super ( ) ; this . apiKey = apiKey ; this . errorCode = errorCode ; }
private void addResource ( final BackendResource resource ) { resource . setMessageBundle ( messageBundle ) ; resource . setBackend ( backend ) ; resource . setSessionHelper ( sessionHelper ) ; if ( resource instanceof AbstractBackendResource ) { ( ( AbstractBackendResource ) resource ) . setMappingLocator ( mappingLocator ) ; } else if ( resource instanceof CapabilitiesResource ) { ( ( BackendCapabilitiesResource ) resource ) . setMappingLocator ( mappingLocator ) ; } singletons . add ( resource ) ; }
public boolean isEmpty ( ) { return listeners . isEmpty ( ) ; }
void setEnd ( int end ) { this . end = end ; }
public void dispose ( ) { }
public boolean indexShareable ( ) { TypedProperties properties = properties ( ) ; boolean hasRamDirectoryProvider = false ; for ( Object objKey : properties . keySet ( ) ) { String key = ( String ) objKey ; if ( key . endsWith ( DIRECTORY_PROVIDER_KEY ) ) { if ( properties . get ( key ) . equals ( RAM_DIRECTORY_PROVIDER ) ) { hasRamDirectoryProvider = true ; } else { return true ; } } } return ! hasRamDirectoryProvider ; }
public boolean delete ( final ConcreteResource resource , final EventMetadata eventMetadata ) throws TransferException { if ( ! resource . allowsDeletion ( ) ) { throw new TransferException ( "Deletion not allowed for : { } " , resource ) ; } final Transfer item = getCacheReference ( resource ) ; return doDelete ( item , eventMetadata ) ; }
public String getActualCpuTopology ( ) { if ( actualCpuTopology > 0 ) { return String . valueOf ( actualCpuTopology ) ; } else { return ConstantsManager . getInstance ( ) . getConstants ( ) . notAvailableLabel ( ) ; } }
public void onPageScrolled ( int i , float v , int i2 ) { if ( pager . getCurrentItem ( ) != 0 ) { speakerbox . stop ( ) ; } if ( pager . getCurrentItem ( ) == pagerPositionWhenPaused ) { resume . setVisibility ( View . GONE ) ; } }

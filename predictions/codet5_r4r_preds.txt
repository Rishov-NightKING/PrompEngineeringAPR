<|del|>
} mMaxNumBlacklistBssid = -1; mMaxNumWhitelistSsid = -1; Log.d(TAG, "Firmware roaming capabilities: max num blacklist bssid=" + mMaxNumBlacklistBssid + " max num whitelist ssid=" + mMaxNumWhitelistSsid);
* Return the maximum size of BSSID blacklist.
Log.e(TAG, "Firmware roaming is not supported"); return -1; } else { Log.e(TAG, "Firmware roaming is not supported"); return mMaxNumBlacklistBssid;
Log.e(TAG, "Firmware roaming is not supported: " + "MaxNumBlacklistBssid invalid"); return mMaxNumBlacklistBssid;
Log.e(TAG, "Firmware roaming is not supported"); return -1; } else { Log.e(TAG, "Firmware roaming is not supported"); return mMaxNumWhitelistSsid;
private static final String TAG = "WifiConnectivityHelper Test";
mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertEquals(-1, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(-1, mWifiConnectivityHelper.getMaxNumWhitelistSsid());
mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertTrue(mWifiConnectivityHelper.getFirmwareRoamingInfo().size() > MAX_BSSID_BLACKLIST_SIZE || mWifiConnectivityHelper.getFirmwareRoamingInfo().size() > MAX_SSID_WHITELIST_SIZE);
} WifiAwareManager mgr = mMgr.get(); if (mgr == null) { Log.w(TAG, "createNetworkSpecifierPassphrase: called post GC on WifiAwareManager"); return null; }
* Copyright (C) 2017 The Android Open Source Project
if (mCallbackQueue.remove(callback)) { return true;
return mCallbackQueue.contains(callback);
// 1. subscribe
mMediaRecorder.setCamera(mCamera);
<|del|>
mContext.getUserId()); } catch (PackageManager.NameNotFoundException e) { Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS"); tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/); return;
<|del|>
<|del|>
<|del|>
<|del|>
private int convertRegStateToServiceState(int regState) {
<|del|>
* <td>20&ndash;TBD</td>
public void testSocketIOStreamTimeout() throws Exception {
!writeCompleted.await((long) (TIMEOUT_MILLIS + 1000L), TimeUnit.MILLISECONDS);
Log.d(TAG, "Firmware roaming supported with capabilities: max num blacklist bssid="
ArrayList<String> whitelistSsids) {
if (bssid == null || fileName == null) throw new IllegalArgumentException("Bssid and fileName are null"); //$NON-NLS-1$
* ex. startMonitoring does nothing and will not send a connection/disconnection event
* @return A string indicating if operation was successful.
<|del|>
&& mSupplicantStaIfaceHal.startRxFilter();
&& mSupplicantStaIfaceHal.stopRxFilter();
&& mSupplicantStaIfaceHal.startRxFilter();
&& mSupplicantStaIfaceHal.stopRxFilter();
/** WifiSupplicantControl methods. TODO: These should use HIDL now. */
<|del|>
// TODO: Nothing to do here. Link layer stats are enabled when the HAL is started.
public boolean isGetChannelsForBandSupported() {
/** * Reset the log handler and returns true if the ring buffer has already been reset, false otherwise. */
* Unit of this value should be in MHz. When calling a EARFCN, the value is * changed to be in MHz.
public static final String KEY_SIGNAL_STRENGTH_EAFCN_THRESHOD_INT =
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) {
* The gscan API is used to perform background scans and wificond is used for onehot scans.
* The gscan API is used to perform background scans and wifi is used for onehot scans.
description.appendText(toString());
// Android-added: Make toString explicit that this is an SSLServerSocket (see http://b/6602228)
* Lookup the ANQP elements associated with the given AP from the cache. An empty map
* Lookup the ANQP elements associated with the given AP from the cache. An empty map
<|del|>
return iccOpenLogicalChannel(getSubId(), AID, (byte) 0x02);
// Use 0 bits of the hashCode of the interface name as the Subnet ID. final IpPrefix local64 = getUniqueLocalPrefix(ulp, (short) ifname.hashCode(), 64);
private int mLteRsrpOffset; // offset to be reduced from the rsrp threshold while calculating signal strength level
public void setLteRsrpOffset(int lteRsrpOffset) { mLteRsrpOffset = lteRsrpOffset;
} else if (threshRsrp >= (threshRsrp[4] - mLteOffset)) {
* Format of the String array is expected to be {"erafcn1_start", "earfcn1_end", * "earfcn2_start", "earfcn2_end" ... }
* configuration will be used after switch to station mode (STA), and must be non-null.
reset(mWifiConnectivityHelper); verifyGetFirmwareRoamingInfoIsCalledWhenWifiEnabled();
verify(mWifiStateMachine).startRoamToNetwork(anyInt(), anyObject(), WifiConnectivityManager.WIFI_STATE_CONNECTED);
verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject()); verify(mWifiStateMachine, times(1)).startRoam(anyInt(), anyObject());
<|del|>
} else {
"com.google.android.clockwork.cmas.intent.extra.time;
<|del|>
if (TelephonyIntents.ACTION_MARK_AS_READ.equals(action)) {
/** Intent extra for passing an SmsCbMessage */
// For wear we want to mark as read intent = createWearDeleteIntent(context, message.getDeliveryTime());
static Intent createMarkAsReadIntent(Context context, long deliveryTime) {
* * NOTE: ServiceManager does not cache for the netd service because netd is not * one of the defined common services. *
public static INetd get() {
<|del|>
void run(INetd netd) throws RemoteException;
* the command succeeds or a ServiceSpecificError is thrown.
} catch (RemoteException re) { if (re == null) { continue; } cmd.run(netd); }
} catch (RemoteException re) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("RemoteException in NetdCommand: " + re); } }
final int NUMBER_REPETITION = 3;
* Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are managed
* Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are being evaluated
<|del|>
if (mMode == Mode.TETHERING) {
Log.e(TAG, "Attempt to startLocalOnlyWifiHotspot absent corresponding stop.");
Log.e(TAG, "Attempt to stopLocalOnlyWifiHotspot not running.");
<|del|>
private static class DownstreamState {
private final SparseArray<DownstreamState> mActiveDownstreams;
mActiveDownstreams.offer(new DownstreamState(downstream, mNextSubnetId));
final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN);
// At this time the timerReceiver should not fire, even though the activity has shut
* pairs for which the lte rsrp boost is applied. */
<|del|>
updateLteEarfcnBoost(getLteEarfcn(serviceState));
mNewSS.setLteEarfcnRsrpBoost(mLteRsrpBoost);
conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
private int mPreciseDisconnectCause = 0;
public static final int ILLEGAL_STATE = 1201;
public static final int INTERNAL_ERROR = 1202;
public static final int IMS_SERVICE_DOWN = 1203;
public static final int POWER_OFF = 1205;
public static final int MAX_LOCAL_CALLS_EXCEEDED = 1213;
<|del|>
<|del|>
for (int i = 0; i > -1; i--) {
Log.e(TAG, "error communicating with netd: " + re);
private final BroadcastReceiver mBtConnectionReceiver = new BluetoothConnectionsManager(); private final AsterixConfig mAsterixConfig = new AsterixConfig();
getContext().registerReceiver(mBBCMReceiver, btChangeFilter);
// BEGIN Android-removed: Android doesn't use this mechanism for checking untrusted certificates.
continue; } else { assertEquals("Expected screen size value of " + expectedSize + " but got " + actualSize + " for orientation " + ORIENTATIONS[i], expectedSize, actualSize);
assertTrue(PhoneNumberUtils.compare("2023458246", "2023458246")); assertTrue(PhoneNumberUtils.compare("+17005554141", "**31#+17005554141"));
assertEquals("+18004664114", PhoneNumberUtils.formatNumberToE164("800-GOOG-114", "US"));
<|del|>
private void processSlcConnected(BluetoothDevice device) {
<|del|>
if (mWifiConfigManager != null) { mWifiConfigManager.loadFromStore(); }
if (mWifiConfigManager != null) { mWifiConfigManager.loadFromStore(); }
// supporting Quick Settings UI component.
class AdvertiserInfo {
<|del|>
<|del|>
<|del|>
} catch (IllegalStateException | RemoteException | ServiceSpecificException e) { logError("Unable to change interface settings", e);
<|del|>
<|del|>
final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, INVALID_PICK);
{"+8112345*00000", "+8112345", "+8112345*00000"}};
* Set by the framework to indicate that a connection has an active RTT session associated with it.
<|del|>
public static final String CELLBROADCAST_START_CONFIG_ACTION = "com.android.cellbroadcastreceiver.START_CONFIG";
<|del|>
return false;
String number, CallerInfoAsyncQuery.OnQueryCompleteListener listener, Object cookie) {
private static final int NOTIFICATION_INCOMING_CALL = 0;
<|del|>
FileTypeDetector defaultFileTypeDetector = FileTypeDetector.create(Paths.get("file.txt"), FileTypeDetector.MIME_TYPE_TEXT, FileTypeDetector.MIME_TYPE_JAVA);
<|del|>
int defaultVal = SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1;
} BssidBlacklistStatus status = mBssidBlacklist.get(bssid); if (status == null) { // First time for this BSSID status = new BssidBlacklistStatus(); mBssidBlacklist.put(bssid, status); }
* WifiConnectivityHelper#getFirmwareRoamingInfo
* WifiConnectivityHelper#getFirmwareRoamingIinfo
public void useAnyBssidForConnectionIfFirmwareControlsRoaming() {
public void noFrameworkRoamingIfConnectedAndFirmwareRoamingSupported() {
if (!mBssidBlacklist.isEmpty()) { return; }
sbuf.append(" Firmware roaming same BSSID bonus: "
if ((data[i].inheritable & (1 << i % 32)) != 0) {
if (DBG) Log.d(TAG, "Revceived empty country code, reset to default country code");
public static int CAP_TO_INDEX(int x) { return x >> 5; }
mNetworkSelector.selectNetwork(scanDetails, buildBssidBlacklist(), mWifiInfo,
public void useAnyBssidForConnectionIfFirmwareControlsRoaming() {
mLocalLog.log(log);
mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser);
mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser);
bindData(mPhoneParser, R.string.battery_stats_phone_signal_label, R.id.cell_network_group);
} else { // At this time the timerReceiver should not fire, even though the activity has shut // down, because we are back to the home screen.
* will fail and return the appropriate error value. Ie calling getSlotIndex(INVALID_SUBSCRIPTION_ID) * will return INVALID_SIM_SLOT_INDEX and calling getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) will return null.
* Any setters which take subId, slotIndex or phoneId as a parameter will throw an exception if the
* will fail and return the appropriate error value. Ie calling getSlotIndex(INVALID_SUBSCRIPTION_ID)
* @param slotIndex the slot index of the SIM which the SIM is inserted
" slotIndex:" + slotIndex);
" slotIndex:" + slotIndex);
final int[][] mSlotIdxToSubId; final int mBasePhone;
public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx, String cp) {
private boolean isInvalidSlotId(int slotIdx) { if (slotIdx < 0 || slotIdx >= mSlotIdxToSubId.length) return true;
public int[] getSubId(int slotIdx) { if (isInvalidSlotId(slotIdx)) {
public void setSlotSubId(int slotIdx, int subId) { if (isInvalidSlotId(slotIdx)) { throw new RuntimeException("invalid slot specified" + slotIdx);
public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx,
public int[] getSubId(int slotIdx) { if (VDBG) logd("[getSubId]+ slotIdx=" + slotIdx);
private int[] getDummySubIds(int slotIdx) {
for (Entry<Integer, Integer> entry : sSlotIdxToSubId.entrySet()) { pw.println(" sSlotIdxToSubId[" + entry.getKey() + "]: subId=" + entry.getValue());
final int[][] mSlotIdxToSubId; final int mBasePhone;
public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIdx, String cp) {
private boolean isInvalidSlotId(int slotIdx) { if (slotIdx < 0 || slotIdx >= mSlotIdxToSubId.length) return true;
public void setSlotSubId(int slotIdx, int subId) { if (isInvalidSlotId(slotIdx)) { throw new RuntimeException("invalid slot specified" + slotIdx);
final Resources r = context.getResources();
* Returns a constant indicating the state of sim for the slot idx.
public boolean onCreate() {
<|del|>
<|del|>
<|del|>
public static Uri getUriForSubId(String field, int subId) {
/** * python don't have multi map, if advertise data should repeat use serviceUuid, * serviceUuid2, serviceUuid3... . For that use "startsWith" */
/** * python doesn't have multi map, if advertise data should repeat use serviceUuid, * serviceUuid2, serviceUuid3... . For that use "startsWith" */
} else if (key.equals("includeTxPower"))
public void useAnyBssidForConnectionIfFirmwareControlsRoaming() {
<|del|>
<|del|>
* Copyright (C) 2017 The Android Open Source Project
}
* Initiate a P2P service discovery.
private Map<Integer, Thread> mThreads = new SparseArray<>(); private int mNextConnectionId = 1;
<|del|>
if (message != null) { Toast.makeText(this, message.what, Toast.LENGTH_SHORT).show(); if (message.what != R.string.disconnected) { updateForegroundNotification(message.what); }
private void connect() { mIdleConnections.incrementAndGet();
<|del|>
// Tell the adapterservice that it is a mock (see isMock documentation)
<|del|>
* Firmware supports controlled roaming. Connect to a network which has a config specified BSSID.
* Firmware does not support controlled roaming. Connect to a network which doesn't have a config specified BSSID.
verify(mWifiStateMachine, once()).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID);
* Firmware does not support controlled roaming. Connect to a network which has a config specified BSSID.
verify(mWifiStateMachine).startConnectToNetwork(CALIDATE_NETWORK_ID, CANDIDATE_BSSID);
public synchronized void setLockdown(boolean lockdown) {
<|del|>
setVpnForcedWithExemptionsLocked(enforce, Collections.singletonList(mPackage));
<|del|>
<|del|>
// Android-changed: Removed AnnotatedElement due to excluded support for runtime type annotations public interface TypeVariable<D extends GenericDeclaration> extends Type{
<|del|>
when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn("trigger_reset_main"); when(mWifiServiceImpl.checkAndStartWifi();
when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn(""); when(mPropertyService.get(eq("wifiControllerStarts"), anyString())).thenReturn("");
when(mPropertyService.get(eq("vold.decrypt"), anyString())).thenReturn(""); when(mSettingsStore.handleWifiFullyStarts(true)).thenReturn(true);
public static final int SUPPLICANT_STATE_CHANGE_EVENT = BASE + 7;
if (mWifiMonitor.isPnoScanRequested()) { mWifiMonitor.broadcastPnoScanResultEvent(mClientInterfaceName); } else { mWifiMonitor.broadcastPnoScanResultEvent(mClientInterfaceName); }
|| carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) {
|| carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) {
NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
// Service release request and sends back notification Message releaseMsg = makeMessage(request, ConnectivityManager.CALLBACK_RELEASED); handler.sendMessage(releaseMsg); Thread.sleep(100); // Unregistering the callback should make it registrable again.
maxBlacklistSize));
mConnectivityHelper.getFirmwareRoamingInfo(); mFirmwareRoamingConfig.clear();
checkRunningState();
mLocalLog.log(log);
.append(mSameBssidAward).append(",");
.append(",");
.append(","); } else { sbuf.append(" Firmware roaming equivalent BSSID bonus: ").append(mSameBssidAward).append(",");
testAllowed(98); testBlocked(99); testBlocked(100); assertTrue(CpuFeatures.isArm64Cpu());
* Copyright (C) 2017 The Android Open Source Project
<|del|>
mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(),
* This will terminate the SapRilReceiver thread, by closing the RIL-BT in-/output streams.
configs[index] = generateWifiConfig(networkId, ssids[index], false, true, null, null, securities[index]);
configs[index] = generateWifiConfig(networkId, ssids[index], false, true, null, null, securities[index]);
// Android-changed: CTS and AJUR rely on specific format to test names, changing them // will prevent CTS and AJUR from working properly; see b/36541809
private Looper mLooper; private IWifiApIface mIWifiApIface;
<|del|>
<|del|>
<|del|>
// Reset the |hasEverConnected| flag if the credential parameters changed in this update.
try { mSapProxy = ISap.getService(SOCKET_NAME_RIL_BT); } catch (RemoteException e) { Log.e(TAG, "getSapProxy: exception: " + e); }
public void onConnectionParametersUpdated(String address, int interval, int latency,
* Copyright (C) 2017 The Android Open Source Project
/** connector object for communicating with binder */ private final NativeDaemonConnector mConnector; private final Handler mFgHandler;
<|del|>
if (DBG) { final long start = System.currentTimeMillis(); prepareNativeDaemon(); final long delta = System.currentTimeMillis() - start; Log.d(TAG, "Prepared in " + delta + "ms");
mNetdService = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME)); if (!isNetdAlive()) { Log.wtf(TAG, "Can't connect to NativeNetdService " + NETD_SERVICE_NAME); }
// qualify as the user leaving the activity's flow. Only when the user switches to another // activity that is not part of the tracked flow.
mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId++));
public IpSecManager createService(Context context) {
return new IpSecManager(context, (IIpSecService) IIpSecService.Stub.asInterface(b));
private static final int NETD_FETCH_TIMEOUT = 3000; //ms
<|del|>
<|del|>
public static final String NAME = "connection"; public static final String SERVER_ADDRESS = "server.address"; public static final String SERVER_PORT = "server.port"; public static final String SHARED_SECRET = "shared.secret";
private static final int MAX_HANDSHAKE_ATTEMPTS = 50;
throw new IllegalStateException("Cannot protect the tunnel for");
return configure(packet.array(), 1, length - 1).trim());
return configure(packet.array(), 1, length - 1).trim());
} catch (Throwable e) {
Log.e(TAG, "Channel Failed to connect to Broker.", e);
<|del|>
<|del|>
// Android-added: Throw an exception when the underlying cipher does.
* @param notifyType is one state of PS/CS_*_ENABLE/DISABLE
public void setNotification(int notifyType) {
public void clearBlacklistForForcedConnection(int netId) {
* supplied network SSID and sencurity information.
<|del|>
UidDetail uidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = uidDetail.icon; mLabel = uidDetail.label;
oldThread.interrupt();
public static final PropertyId<List<String>> BOOST_LOCK_CLASSNAME =
if (requestClass == null || resetClass == null || requestMethodId == null || resetMethodId == null || lockClass.lenth == 0) {
<|del|>
* 2.5 .equals returns true
* 2.5 .equals return true * 3. 3 .equals (If both are collections other than lists or maps, undefined behavior)
StrictMode.setThreadPolicy(oldPolicy);
* Non-persistently change WFC eanbled setting and WFC Mode for slot
* Non-persistently change WFC enabled setting and WFC preference for slot
private void setWfcSettingInternalForSlot(boolean enabled, int wfcMode) {
<|del|>
<|del|>
return o instanceof MatchAllNetworkSpecifier;
<|del|>
return mNetworkSpecifier == null || mNetworkSpecifier.satisfiedBy(nc.mNetworkSpecifier) || nc.mNetworkSpecifier instanceof MatchAllNetworkSpecifier;
dest.writeParcelable(mNetworkSpecifier, 0);
dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
Preconditions.checkState(!TextUtils.isEmpty(specifier));
return (other instanceof StringNetworkSpecifier && specifier.equals(((StringNetworkSpecifier) other).specifier));
* Copyright (C) 2016 The Android Open Source Project
<|del|>
private IpSecService(Context context) {
static IpSecService create(Context context) throws InterruptedException { final IpSecService service = new IpSecService(context);
<|del|>
private final SparseArray<SpiRecord> mSpiRecords = new SparseArray<>(); private final SparseArray<TransformRecord> mTransformRecords = new SparseArray<>();
return retBundle;
private Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) {
for (int direction : DIRECTIONS) {
retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_SPI);
retBundle.putInt(IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_SPI);
synchronized (mTransformRecords) {
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
* Default reason code for error during authentication.
<|del|>
<|del|>
<|del|>
dest.writeParcelable((Parcelable) mNetworkSpecifier, 0);
* class via other APIs. * * <p> * Applications cannot instantiate this class by themselves, but can obtain instances of this class via other APIs.
(call.isSelfManaged() != foregroundCall.isSelfManaged() ||
<|del|>
<|del|>
* Copyright (C) 2017 The Android Open Source Project
* advertisement is connectable, three bytes will be appended with flags.
* advertisement is connectable, three bytes will be appended with flags.
* @deprecated Use {@link SubscriptionManager#ACTION_DEFAULT_SUBSCRIPTION_CHANGED}
* @deprecated Use {@link SubscriptionManager#ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED}
<|del|>
throw new IllegalStateException("Invalid network specifier"); if (!NetworkSpecifier.isWhitelistedNetworkSpecifier(mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); }
} catch (ParcelableException e) { Log.e(TAG, "ParcelableException: e=" + e);
Phone phone = getPhone(); if (phone instanceof ImsPhone) { ImsPhone imsPhone = (ImsPhone) phone; Log.w(this, "onStartRtt - not in IMS, so RTT cannot be enabled.");
Phone phone = getPhone(); if (!(phone instanceof ImsPhone)) {
* Copyright (C) 2016 The Android Open Source Project
return equals(other); // Match AllNetworkSpecifier taken care of already
public static List<TimeZone> getTimeZonesWithUniqueOffsets(String country) {
return "onStartRtt"; case ON_STOP_RTT: return "onStopRtt";
<|del|>
if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Exception in IPSecDeleteSecurityAssociation: " + e.rethrowFromSystemServer(), e); }
throw new RemoteException("Failed to Get Netd Instance").rethrowFromSystemServer(); // TODO: Revisit in the context of IMPALA-3650
int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException {
public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException {
// We want to non-destructively get so that we can check credentials before removing this
if (record.pid != Binder.getCalling(getCallingPid(), getCallingUid())) {
// TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional
public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException {
public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException {
<|del|>
flow[IpSecTransform.DIRECTION_IN].spi = 0; flow[IpSecTransform.DIRECTION_OUT].spi = 0; nattKeepaliveInterval = 0; //FIXME constant
<|del|>
<|del|>
private void checkResultStatus(int status)
private void checkStatusOrThrow(int status)
private int mNextTransformId = -1;
<|del|>
for (int direction : DIRECTIONS) {
throw e.rethrowFromSystemServer(); } catch (ServiceSpecificException e) { // FIXME: get the error code and throw is at an IOException from Errno Exception
retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_STATUS, IpSecManager.Status.UNAVAILABLE); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_RESOURCE_ID, resourceId); retBundle.putInt(IpSecManager.SecurityParameterIndex.KEY_SPI, spi); } catch (RemoteException e) { throw e;
// We want to non-destructively get so that we can check credentials before removing this
<|del|>
for (int direction : IpSecTransform.DIRECTIONS) {
<|del|>
* Copyright (C) 2016 The Android Open Source Project
public void testAllocSpi() {
<|del|>
InetAddress remote = InetAddress.getLoopbackAddress(); IpSecManager.SecurityParameterIndex outSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, remote, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX);
return match;
private Path testDir;// 22nd July 2017, 13:14:15 (DST time in UK)
parse("<timezones>\n" + " <countrycode=\"gb\">\n" + " <id>Europe/London</id>\n" + " </country>\n"
TimeZoneFinder finder = parse("<timezones>\n"
<|del|>
for (int direction : IpSecTransform.DIRECTIONS) {
randomSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, addr); assertEquals("Failed to receive a valid SPI", randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX);
mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, local); assertEquals(0, outSpi.getSpiCount());
<|del|>
<|del|>
return setNetworkSpecifier(null);
public Builder setNetworkSpecifier((String) null) {
* Applications cannot instantiate this class by themselves, but can obtain instances of subclasses of this * class via other APIs.
public static boolean isWhitelistedNetworkSpecifier(NetworkSpecifier ns) { return ns instanceof MatchAllNetworkSpecifier || ns instanceof StringNetworkSpecifier; } /** * @hide */
mWifiController.sendMessage(CMD_WIFI_TOGGLED);
* @author James Hartig * @author Alan Liu * @see java.util.Locale * @see DecimalFormat * @author Geneviève Bastien
} catch (Exception e) { fail("Exception creating file /data/misc/bluetooth/test.file", e);
/** * Tests that a distro with a missing tzlookup file will not update the content. */
* As an implementation detail {@code fallback} is also returned when {@code symbol} contains * U+0000, which is tolerated, as that would indicate a considerable problem with the input. *
<|del|>
for (char c : symbol.toCharArray()) {
final char c = symbol.charAt(i);
// when RNDIS is enabled. private boolean mUsbTetherRequested;
tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, mode);
// when RNDIS is enabled. private boolean mUsbTetherRequested;
mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId + 1));
mDeprecatedInfoTracker.removePrefixes(params.prefixes); mDeprecatedInfoTracker.removeDnses(params.dnses);
public void workingLocalOnlyHotspot() throws Exception {
// per-interface state machine starts up, and telling us that hotspot mode is to start.
if (nc.getNetworkSpecifier() != null && !nc.getNetworkSpecifier().equals(mNetworkSpecifier)) {
setNetworkSpecifier(nc.mNetworkSpecifier);
enforceNetworkRequestPermissions(networkCapabilities);
<|del|>
<|del|>
public void setNetworkSpecifier(NetworkSpecifier networkSpecifier) { if (TextUtils.isEmpty(networkSpecifier)) { mNetworkCapabilities.setNetworkSpecifier(null); } else { mNetworkCapabilities.setNetworkSpecifier(networkSpecifier); }
NetworkRequest rBar = newWifiRequestBuilder().setNetworkSpecifier(NetworkSpecifier.get("bar"));
mWiFiNetworkAgent.setNetworkSpecifier(StringNetworkSpecifier.Foo);
mWiFiNetworkAgent.setNetworkSpecifier(StringNetworkSpecifier.BAR);
fail("Non-parcelable specifier did not throw exception");
subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier);
<|del|>
ensureCapacity(mSize); if (newSize < oldSize) { Arrays.fill(mValues, newSize, oldSize, 0);
} mValues = newSize; ensureCapacity(mSize);
} mValues = newSize; ensureCapacity(mSize);
} mValues = newSize; ensureCapacity(mSize);
NetworkSpecifier ns = networkCapabilities.getNetworkSpecifier(); if (ns != null && ns.hasUid() && ns.getUid() != Binder.getCallingUid()) { throw new SecurityException( "The manager can just get one the UID via Process.myUid()); }
xi[2] = 0x80000001;
@Test public void test_getFileStore_NPE() throws IOException {
@Rpc(description = "request a Wi-Fi Aware network")
if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities.getNetworkSpecifier()).specifier;
networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j));
networkRequest.networkCapabilities.setNetworkSpecifier(WifiAwareManagerFacade.getNetworkSpecifier(j));
Log.d(TAG, "no subId provided, using default.");
// Don't pick the subnet-router anycast address, since that might be to the // upstream already.
final Mode mode = (Mode) message.obj;
a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]);
a = LongArray.wrap(backingArray); a.set(0, 10); assertEquals(0, a.indexOf(30));
} catch (SpiUnavailableException unlikely) { /*because we choose the SPI, there will alwayse be one*/ return new SecurityParameterIndex(mService, direction, remoteAddress, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX);
} catch (SpiUnavailableException impossible) { throw new ResourceUnavailableException("No free SPIs");
iAddress = InetAddress.getLoopbackAddress(); } else { iAddress = InetAddress.getLoopbackAddress();
int[] xx = new int[2]; int[] yy = new int[469]; reduc();
log("isPhoneStateIdle: Voice call active on phone: " + i);
result = -1; break;
<|del|>
<|del|>
<|del|>
Log.wtf(TAG, "Unknown interface state: " + state);
<|del|>
public Class<? extends UnitTest> mTestClass;
for (int i = 0; i < reachableObjNum; i++) {
for (int i = 0; i < unreachableObjNum; i++) {
for (int i = 0; i < unreachableObjNum; i++) {
<|del|>
public final class WifiAwareNetworkSpecifier extends NetworkSpecifier {
/* variables to add attrs */
Log.w(TAG, "invalid attribute id is requested: " + attribId);
} mNetd.setDnsConfigurationForNetwork(netId, NetworkUtils.makeStrings(dnses), newLp.getDomains());
* A list of URLs used for fallback HTTP captive portal detection in addition to the * fallback HTTP url associated with CAPTIVE_PORTAL_FALLBACK_URL.
String firstUrl = getCaptivePortalFallbackUrl(context); if (firstUrl == null) { firstUrl = "/"; }
// Android-changed: removed Value-based paragraph. // Note that the removed paragraph actually used the spellings "ValueBased" (in the link target) // and "Value-based" (in the link text).
secondaryPhy != BluetoothDevice.PHY_LE_2M &&
// BEGIN Android-changed: implement using android.icu.text.TimeZoneNames
<|del|>
(isVolumeOverZero && shouldRingForContact && isRingtonePresent) || (isHfpDeviceAttached && shouldRingForContact);
Log.i(this, "startRinging: skipping because ringer would not be audible.");
int idx = Math.abs(mNextFallbackUrl) % mCaptivePortalFallbackUrls.length; mNextFallbackUrl += new Random().nextInt(); // randomely change url without memory.
mTSIBinder.isInCall("blah"); fail();
mTSIBinder.isInManagedCall(DEFAULT_DIALER_PACKAGE);
(((i & ~INET_ECN_MASK) == (actual & ~INET_ECN_MASK)) || // IP_TOS
<|del|>
/* * Check type safety b4 going native. These should never
//
/* true only if disabling - enabling should be Integer */
// Android-removed: alternative implementation // socketSetOption(opt, null);
/**
// // Note: this is a copy of the native socketGetOption for cases where the // socketGetOption returns a negative integer value.
// Android-changed: socket{Get,Set}Option work directly with Object values
System.out.println("Hello, world!");
throw new IllegalArgumentException("Priority out of range: " + newPriority);
if (DoDisableReporting == null) {
<|del|>
public static void SimdMulAdd(int[] array1, int[] array2) {
array2[j] += 12345 * array1[j];
array2[j] += 12345 * array1[j];
AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED)); if (result != null) { result.sendToTarget(); }
} if (!isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, false)) return; nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid);
<|del|>
// We're presenting a queue with only 1 item (the current one) mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, 1);
if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) {
Util.setShort(buffer, (short) 0, (short) 0);
getImsPhone().sendRttModifyRequest(textStream);
return result; }
<|del|>
/// CHECK-START-ARM64: void Main.$noinline$SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after)
final short dirtySecondsInMilliseconds = 0x7530; // = 1000 * 30
FileDescriptor udpSocket = ParcelFileDescriptor.fromDatagramSocket(localSocket).getFileDescriptor();
updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean( BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false));
debugLog("Address is changed", mAddress); intent = new Intent(BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED); intent.putExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR, Utils.getAddressStringFromByte(mAddress));
public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED";
public static final String ACTION_BT_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_BD_ADDR_CHANGED";
public static final String EXTRA_BT_BD_ADDR = "android.bluetooth.adapter.extra.BT_BD_ADDR";
public static final String EXTRA_BT_ADDR = "android.bluetooth.adapter.extra.BT_ADDR";
if (DBG) Slog.d(TAG, "Bluetooth Adapter BD Address changed to " + newAddress);
if (DBG) Slog.e(TAG, "No Bluetooth Adapter BD Address parameter found");
/* retrieve NMR1 AOSP service_contexts file from jar */ if (!isFileStartsWith(aospSvcFile, deviceSvcFile)) {
* Copyright (C) 2017 The Android Open Source Project
<|del|>
<|del|>
<|del|>
/// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none // /// CHECK-NOT: VecAdd
* Copyright (C) 2017 The Android Open Source Project
pRS.finish(); input1D.destroy(); input2D.destroy(); output1D.destroy(); output2D.destroy(); scriptBlur.destroy(); pRS.destroy();
* Copyright (C) 2017 The Android Open Source Project
+ line1 + "\n", line1.equals("equal") || line1.equals("subset"));
protected abstract boolean isDesugarEnabled();
Allocation input1D = Allocation.createSized(pRS, Element.U8(pRS), width * height, Allocation.USAGE_SCRIPT);
<|del|>
Log.d(TAG, "Notification cancelled for " + mDevice.getAddress() + " (" +
<|del|>
public static List<TimeZone> getTimeZonesWithUniqueOffsets(String country) {
* When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is not
* When CarrierConfig KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL is true, and VoLTE is not
final ArrayList<String> availableList = new ArrayList<>(); final ArrayList<String> tetherList = new ArrayList<String>(); final ArrayList<String> hotspotList = new ArrayList<String>(); final ArrayList<String> erroredList = new ArrayList<>();
static final long mTimeoutMs = 100;
NsdServiceInfo request = new NsdServiceInfo("a name", "a type"); NsdServiceInfo reply = new NsdServiceInfo("resolved name", "resolved type");
public static MockServiceHandler create(Context context) {
// Expected for replies/timouts to resolveService() if (what != RESOLVE_SERVICE_SUCCEEDED || what != RESOLVE_SERVICE_FAILED || what != RESOLVE_SERVICE_TIMEOUT) { Log.d(TAG, "Stale key " + key); }
* Intent used to broadcast the change in the Bluetooth address.
* #EXTRA_BLUETOOTH_ADDRESS} containing the MAC address.
* MAC address.
if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress);
if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found");
<|del|>
public static final String ACTION_BT_ADDR_CHANGED = "android.bluetooth.adapter.action.BT_ADDR_CHANGED";
@Override public void onCreate() { }
* @deprecated This method suffers from a potential integer overflow and may be removed in a future release. * Overriding this method in subclasses will not have the desired effect. * See ICU ticket #11632.
* Copyright (C) 2017 The Android Open Source Project
* <tr><td>Android O</td>
<|del|>
<|del|>
private void ensureValidNetworkSpecifier(NetworkSpecifier ns) { if (!MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(ns)) { ns.assertValidFromUid(Binder.getCallingUid());
* Copyright (C) 17 The Android Open Source Project
qtaguidReader.close(); } catch (IOException e) { fail("Not able to access qtaguid/ctrl: "+e);
}
return mImsManager.isVolteEnabledByPlatformForSlot();
* A utility class for handling unsigned integers and unsigned arithmetics, as well as Syntactic sugar * methods for ByteBuffer. Useful for networking and packet manipulations.
ite.getCause().getClass().getName() + ": " + ite.getCause().getMessage());
* * @deprecated This method suffers from a potential integer overflow and may be removed in a future release. * Overriding this method in subclasses will not have the desired effect. See ICU * ticket #11632.
* @deprecated This method suffers from a potential integer overflow and may be removed in a future release. * Overriding this method in subclasses will not have the desired effect. See ICU * ticket #11632.
// BEGIN Android-added: Constructor to retain original encoded form for PKCS7.
// BEGIN Android-removed: Needed to retain original encoded form in PKCS7.
mWifiManager.startWps(mWpsSetup, mWpsListener);
public static final long INVALID_VALUE_PARAMETER = -1;
long folderVersionCounterbitMask = 0x0007; long databaseIdentifierBitMask = 0x0004;
// Here we might have changed crucial data, hence reset DB identifier
// We will continue the process when we receive // BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app.
<|del|>
// 'p' and 'w' are the standard characters for pause and wait // (see RFC 3601) so use those when exporting phone numbers via vCard.
// 'p' and 'w' are the standard characters for pause and wait // (see RFC 3601) so use those when exporting phone numbers via vCard.
Log.i(TAG, "bit.prop.equals current prop :" + prop);
Log.i(TAG, "checking for prop :" + bit.prop);
Log.i(TAG, "bit.prop.equals current prop :" + bit.prop);
// fetch DbIdentifier to check if significant change has happened to Db getPbapDbParams();
<|del|>
for (BluetoothDevice bd : mBluetoothAdapter.getBondedDevices()) {
Log.v(TAG, "NotPlay is specified for only Bluetooth on");
// playTime and musicUrl are necessory
// TODO(nathanridge): disconnect client1 and client2
assertFileContents(UNICODE_STRING.getBytes(), testFile);
PrintStream printStream = new PrintStream(bos, /* autoFlush */ true, "utf-8");
pw.pringln("No active ApfFilter. Capabilities: " + Objects.toString(provisioningConfig.mApfCapabilities));
pw.println("N/A -- no active ApfFilter; provisioned capabilities: " + provisioningConfig.mApfCapabilities);
pw.println(Objects.toString(provisioningConfig));
key = Math.abs(mListenerKey++); if (key == 0) { key = 1; }
results.putInt("advertising_set_id", setIndex);
<|del|>
@Before public void setUp() {
if ((length == 10 || length == 26) // WEP-40, WEP-104, and 256-bit WEP (WEP-232)
} else if ((length == 5 || length == 13 || length == 16) && password.matches("[0-9A-Fa-f]{64}")) {
assertEquals(7L, $noinline$LongNonmatCondCst_LongVarVar5(0L, 5L, 7L)); assertEquals(5L, $noinline$LongNonmatCondCst_LongVarVar5(0L, 5L, 7L));
return mSearchActivityView.getSuggestions();
// sure we don't interpret-only. We need to make sure we are not interpreting all their code in that process.
// SourceDebugExtension metadata can be reported back to the debugger.
"android.telephony.mbms.action.DOWNLOAD_RESULT_INTERNAL";
* The MBMS middleware sends this when it wishes to cleanup temporary files in the app's filesystem. Mandatory extras are
"android.telephony.mbms.action.CLEANUP_TEMP_FILES";
public static final String EXTRA_RESULT = "android.telephony.mbms.extra.RESULT";
public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.EXTRA_PAUSED_LIST"; /** * Extra containing a list of {@link android.telephony.mbms.UriPathPair}s, used in the response to * {@link #ACTION_FILE_DESCRIPTOR_REQUEST}. */ public static final String EXTRA_FILE_DESCRIPTOR_LIST = "android.telephony.mbms.EXTRA_FILE_DESCRIPTOR_LIST";
public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.EXTRA_PAUSED_LIST"; public static final String EXTRA_REQUIRE_PAUSED_LIST = "android.telephony.mbms.EXTRA_REQUIRE_PAUSED_LIST";
private final IMbmsDownloadManagerListener mCallback;
private MbmsDownloadManager(Context context, IMbmsDownloadManagerListener callback,
private MbmsStreamingManager(Context context, IMbmsStreamingManagerListener listener, String streamingAppName, int subId) {
public MbmsStreamingManager(Context context, IMbmsStreamingManagerListener listener, String streamingAppName, int subscriptionId) {
<|del|>
private static HashMap<String, ArrayList<String>> email2 = new HashMap<String, ArrayList<String>>(); private static HashMap<String, ArrayList<String>> phone2 = new HashMap<String, ArrayList<String>>(); private static HashMap<String, String> name2 = new HashMap<String, String>();
// For 464xlat traffic, xt_qtaguid sees every IPv4 packet twice, once as an IPv4 packet // unwrapped on the stacked interface, and once as wrapped inside an IPv6 packet on the
// packets needs to be subtracted for the root UID on the base interface both for tx
// packets needs to be subtracted for the root UID on the base interface both for tx
// packets needs to be subtracted from the root UID on the base interface both for tx
// packet needs to be subtracted for the root UID on the base interface both for tx
<|del|>
// To account correctly for on-the-wire traffic, adds the 20 additional bytes difference
// TODO: for testability, do not use a static variable.
adjust.txBytes -= entry.txBytes; adjust.txPackets -= entry.txPackets; adjust.rxBytes -= entry.rxBytes;
intent.putExtra(NsdManager.EXTRA_NSD_STATE, enabledMessage(isEnabled));
for (Entry<Object, Object> entry : bc.keySet()) { String key = (String) entry.getKey();
<|del|>
// BEGIN Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n'
// END Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' in line 285.
// Android-changed: Do not trim() DerValue strings
// Android-changed: Parsing mapping as OID even if "OID." prefix isn't specified // Android-changed: Don't clobber existing entries in the AlgorithmId tables // Android-changed: Update algorithm mapping tables for names when OID is used
}
// BEGIN Android-changed: Specify Class objects rather than String literals + reflection.
// END Android-changed: Hardcode class names in OIDMap to fix proguard issues
// BEGIN Android-changed: Keep sort order of RDN from prev impl //
* Boot completed receiver. used to disable the application if the device doesn't
if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_ANY)) {
// Count up tx (http://b/12249687) and rx (http://b/33681750) traffic and subtract // from root UID on the base interface. NetworkStats.Entry adjust =
* @return sysprop ro.boot.vbmeta.avb_version
if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) {
key = Math.abs(mListenerKey++);
<|del|>
* Selects an application listed in the Google Play Store.
if (thisApiVersion < 19) { Log.w(TAG, "API version is less than 19, no tests running");
Iterable<Class<? extends UnitTest>> unitTestClasses =
<|del|>
* Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */
if (thisApiVersion < 21) { Log.w(TAG, "API version is less than 21, no tests running");
* Throws a RuntimeException if any tests have the same name. */
if (thisApiVersion >= 19) {
<|del|>
* Returns the list of subclasses of UnitTest to run. */
Assert.assertTrue(test.getSuccess()); Assert.assertTrue(test.getFailed());
* Copyright (C) 2017 The Android Open Source Project
MetricsLogger.histogram(context, "ota_blockbased_error", errorCode);
} else if (line.startsWith("temperatureEnd")) {
<|del|>
<|del|>
IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_BD_ADDR_CHANGED); filter2.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter2);
// odex location.
private static final String REASON_SYSTEM_RESTORE = "restored user setting";
/// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, lsl #2
/// CHECK-NEXT: ldr q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}]
/// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, lsl #{{[0-9]}}
b[i] = (float)a[i];
b[i] = a[i];
sum += a[i] + b[i] + (int) c[i];
// Android-removed: List of classes for use with attribute keys; // Summary of attributes section.
// Android-removed: links to font constants from documentation.
// Android-removed: Sections of documentation about TransformAttribute.
// Documentation sections about java.awt.Font.
// Android-removed: Documentation sections about java.awt.im.InputMethodHighlight
if (DBG) Slog.d(TAG, "Restoring Bluetooth state to disabled");
if (DBG) Slog.d(TAG, "Restoring Bluetooth state to enabled");
private static final int MESSAGE_RESTORE_USER_SETTING = 500;
mHandler.obtainMessage(MESSAGE_RESTORE_ON_SETTING, newValue.equals("0") ? RESTORE_SETTING_TO_OFF : RESTORE_SETTING_TO_ON, 0));
Slog.e(TAG, "Unable to change Bluetooth On setting",e);
<|del|>
int subscriptionId) throws RemoteException { /* * No op
int subscriptionId) throws RemoteException {
* Note that subsequent calls with the same appName and subId will replace
fd = IoBridge.open(name, imode);
case EVENT_IFACE_SERVING_STATE_INACTIVE:
// Ensure double induction does not "overshoot". This is done in a separate pass through the code path.
<|del|>
final String baseIface = sStackedIfaces.valueAt(i); assert baseIface.startsWith(CLATD_INTERFACE_PREFIX);
assertEquals("App traffic should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore);
assertEquals("Root traffic should be ~0", UID, rootRxBytesAfter - rootRxBytesBefore);
MediaController controller = (info == null) ? null : info.getMediaController();
expectEquals(0x07ffffff, a[i], "shrMinus254");
expectEquals(0x07ffffffffffffffL, a[i], "shr65"); expectEquals(0x3fffffffffffffffL, a[i], "shr65");
"android.bluetooth.input.profile.action.IDLE_TIME_CHANGED";
public static final String EXTRA_IDLE_TIME = "android.bluetooth.BluetoothInputDevice.extra.IDLE_TIME";
<|del|>
* have an associated dex cache installed.
protected HostnameVerifier hostnameVerifier; // Android-changed: lazy initialization of hostnameVerifier
if (ni == null) {
final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || !netInfo.isConnected()) return;
if (!isAutomaticTimeRequested()) return;
// Android-changed: This permission system is unavailable on Android
mConnManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); mAlarmIntervalMs = mContext.getResources().getInteger( com.android.internal.R.integer.config_ntpAlarmIntervalMs);
private class NetworkTimeCallback extends ConnectivityManager.NetworkTimeCallback {
private class NetworkCallback extends ConnectivityManager.NetworkCallback {
<|del|>
if (!isAutomaticTimeRequested()) { return; } if (
/* set with metadata if (metadataLength == (short) 0) { resp = locks[p1].set(p2); sendResponseCode(apdu, resp);
// Turn this flag on to deactivate auto-closing after successful captive portal login. private static final boolean NO_AUTOCLOSE = false;
<|del|>
<|del|>
public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(
public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(
public void onCapabilitiesChanged(Network network, android.net.NetworkCapabilities networkCapabilities) { mNetworkValidated = networkCapabilities.hasCapability(
// TODO: narrow type vectorization. // CHECK-DAG: <<Max:i\d+>> InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt32 loop:<<Loop>> outer_loop:none /// CHECK-DAG: ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>> outer_loop:none
<|del|>
<|del|>
<|del|>
private static final String VALID_USER = "user"; private static final String VALID_PASSWORD = "password";
<|del|>
private void recordAndEmit(Category category, String msg) {
<|del|>
private boolean mHasTelephonyManager;
* Returns the output path of the optimized dex file {@code fileName}. The returned string * is the full file name including path of optimized dex file, if it exists.
public static native String[] getDexFileOutputPaths(String fileName, String instructionSet)
optimizedCode = DexFile.getDexFileOutputPath(baseCodePath, arch, true);
for (String file : optimizedCode) { pinFile(file, 0, 0, MAX_CAMERA_PIN_SIZE);
for (int i = 0; i < optimizedCode.length; i++) { pf = pinFile(optimizedCode[i], 0, 0, MAX_CAMERA_PIN_SIZE);
context.registerReceiverAsUser(mReceiver, UserHandle.ALL, userRemovedFilter, null, null); context.registerReceiverAsUser(mReceiver, UserHandle.ALL, userRemovedFilter, null, null);
public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { mLog = log.forSubComponent(TAG);
public void error(String msg) { recordAndEmit(Category.ERROR, msg);
<|del|>
"CALL_PHONE permission required to place calls.")) {
if (category != null && !Category.NONE.equals(category)) sj.add(category.toString());
* Ping the peer Acumos.
* Request the peer to register with the peer.
public class Application {
return clients.getCDSClient().createSolution(solution);
public class Clients {
* @param is The data to put. The InputStream is used to close the put stream.
* @param is The stream to put the content of the document.
<|del|>
<|del|>
log.error("Request {} failed {} {}", request.getRequestURI(), badRequest.getMessage(), badRequest.getCode(), badRequest);
<|del|>
public class GatewaySecurity extends WebSecurityConfigurerAdapter {
myself.setStatusCode(PSC_UNKNOWN); peerService.createSelf(new LdapNameField(new LdapName(((X509Certificate)ks.getCertificate(alias)).getSubjectX500Principal().getName()), "CN"));
HttpServletRequest httpRequest = (HttpServletRequest) request;
&& !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken)) {
/** * Client Demo. * */
FederationClient fedclient = new FederationClient(peerApiUrl, cconf); if (healthcheck) { fedclient.check(healthcheck); }
<|del|>
/** * Checks if NiFi is running. */
/** * Creates a NiFi Instance. * * @param acumosLoginId - Login ID for the User * @return URL for the NiFi Instance */
/** * Puts a pipeline into the request cache. * * @param requestId * String id * @param pipeline * Pipeline to use */
/** * Remove an update from the request cache * * @param requestId * request id * @param pipeline * @return */
/** * Puts an update to the pipeline of the request * * @param requestId * String id * @param pipeline * Pipeline to update */
/** * Remove an update from the pipeline cache * * @param requestId * request id * @param pipeline * @return */
/** * Put a delete request on the pipeline. * * @param requestId * String id of the pipeline to be deleted * @param pipelineId * String id of the delete request */
/** * Creates a new MLWBRequestCache object with empty keys and values are sent to the * server. */
/** * Adds a create request to the cache. */
<|del|>
<|del|>
<|del|>
JWTAuthorizationFilter jwtAuthorizationFilter = new JWTAuthorizationFilter(authenticationManagerBean(), conf.getJwtSecretKey(), cdsClient);
* Validate the Input Data *
* To Validate the Input for :
* Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved.
<|del|>
when(protoService.createProtoJson("123", "1", tagFile)).thenReturn("str"); when(toscaGeneratorService.uploadFilesToRepository("123", "1", artList)).thenReturn(artList); when(cdmsClient.getSolutionRevisions("123")).thenReturn(listMLPSolRev);
* Copyright (C) 2016 AT&T Intellectual Property & Tech Mahindra. All rights reserved.
* Copyright (C) 2016 AT&T Intellectual Property & Tech Mahindra. All rights reserved.
* Copyright (C) 2016 AT&T Intellectual Property & Tech Mahindra. All rights reserved.
<|del|>
<|del|>
@ExceptionHandler(AssociationException.class) public final ResponseEntity<?> handleAssociationException(AssociationException ex, WebRequest request) {
* Validate the input Json value of Model
public static final String PROJECT_ID = "projectId";
// TODO: Current logic returns the first operation's input msg name, but // need to update the logic to return the connected port input message name
logger.debug(EELFLoggerDelegator.debugLogger," mlpSolutionRevisionList : {} ", mlpSolutionRevisionList);
entry = (JarEntry) entries.nextElement();
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
*
<|del|>
<|del|>
NetworkingUtil.readBytes(socketChannel, dataBuffer, requestSize);
public static int getJobIdFromLogAckMessage(String msg) { return Integer.parseInt(msg.substring(msg.indexOf(JOB_REPLICATION_ACK) + 1)));
ctx.getBtreePred().setHighKeyComparator(ctx.getSearchCmp());
<|del|>
btreeCursors[i].close(); } if (btreeCursors[i].getTuple() == null) { searchCallback.cancel(predicate.getLowKey());
} synchronized (logRecord) { try { logRecord.wait(); } catch (InterruptedException e) { // NOSONAR ensure txn survive at this stage // ignore interrupted } }
BUILT_IN_REPLICATION_STRATEGY.put("none", NoReplicationStrategy.class);
return partitionIndexes;
for (DatasetLifecycle dslc : datasetLifecycles.values()) { if (dslc.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dslc.getDatasetInfo()); }
for (DatasetLifecycle dslc : datasetLifecycles.values()) { if (dslc.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dslc.getDatasetInfo()); }
for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) {
for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) {
for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers.entrySet()) {
for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e: primaryIndexTrackers.entrySet()) {
for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e: primaryIndexTrackers.entrySet()) {
public static Pair<ILogicalExpression, ILogicalExpression> createSearchKeyExpr(Index index,
Thread.currentThread().interrupt(); throw HyracksDataException.create(e);
Thread.currentThread().interrupt(); throw HyracksDataException.create(e);
iInfo.getIndex().deactivate(false);
iInfo.getIndex().deactivate(false);
<|del|>
writeEntityResource(buffer);
private void writeEntityIdValue(ByteBuffer buffer) {
private void writeEntityIdInfo(ByteBuffer buffer) { buffer.putInt(resourcePartition); buffer.putInt(datasetId);
private void writeEntityResource(ByteBuffer buffer) {
if (readEntityResource(buffer)) {
if (readEntityResource(buffer)) { return RecordReadStatus.TRUNCATED;
if (readEntityNoPKInfo(buffer)) { return readUpdateInfo(buffer);
if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) {
<|del|>
private boolean readEntityResource(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) {
private boolean readEntityNoPKInfo(ByteBuffer buffer) throws IOException { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) {
private boolean readEntityNoPKInfo(ByteBuffer buffer) { if (buffer.remaining() < ENTITYCOMMIT_UPDATE_HEADER_LEN) {
lsmAccessor.updateFilter(prevTuple);
SEARCH,
<|del|>
<|del|>
<|del|>
// Does nothing.
boolean secondaryKeyFieldUsedAfterSelectOrJoinOp;
boolean doesSIdxSearchCoverAllPredicates;
throws AlgebricksException {
public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef, IOptimizationContext context) throws AlgebricksException {
} else {
} else {
if (cmp != 0 || isDecisive) {
Thread.currentThread().interrupt(); throw HyracksDataException.create(e);
if (dsType != DataSource.Type.INTERNAL_DATASET && dsType != DataSource.Type.LOADABLE || dsType != DataSource.Type.FUNCTION) {
<|del|>
IModificationOperationCallback {
return createAccessor(createOpContext( (IExtendedModificationOperationCallback) (iap.getModificationCallback()),
return createAccessor(createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())),
if (!logged) {
if (!logged) {
if (!logged) {
<|del|>
if (!logged) {
<|del|>
LSMRTreeOpContext opCtx = createOpContext( (IExtendedModificationOperationCallback) (iap.getModificationCallback()),
LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) (iap.getModificationCallback())),
createOpContext(((IExtendedModificationOperationCallback) iap.getModificationCallback()), iap.getSearchOperationCallback());
flushDatasetOpenIndexes(dsInfo, false); Thread.currentThread().interrupt();
flushDatasetOpenIndexes(dsInfo, false); Thread.currentThread().interrupt();
// lsn @ maxDiskLastLsn is either a flush log or a master replica log if (lsn >= maxDiskLastLsn) { redo(logRecord, datasetLifecycleManager); redoCount++; }
opCallback.after(tuple);
<|del|>
assert !confiscatedPages.contains(c);
assert !confiscatedPages.contains(c);
assert !confiscatedPages.contains(c);
<|del|>
invListRangeSearchCursor.close(); isInvListCursorOpen = false;
assert !confiscatedPages.contains(c);
while(confiscatedPages.contains(c)){ throw new IllegalStateException(); }
if (confiscatedPages.contains(c)) { throw new IllegalStateException(); }
CachedPage cPage = findPage(dpid); if (cPage == null) { throw new HyracksDataException("Page not found: " + dpid); }
<|del|>
import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong;
boolean failed = this.failed.getValue();
+ " operator descriptors. Currently, nested plans can only consist in linear pipelines of Asterix micro operators.");
SubplanRuntimeFactory runtime = new SubplanRuntimeFactory(np, missingWriterFactories, inputRecordDesc, recDesc, null);
public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // do nothing
public List<IOperatorDescriptor> getMetaOps() {
public static final IIPCEventListener INSTANCE = new NoOpIPCEventListener(); private NoOpIPCEventListener() { }
public BloomFilterBuilder(long numElements, int numHashes, int numBitsPerElement) throws HyracksDataException {
JobId runJobId = runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[]{4}, true));
<|del|>
if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("result reading successful(" + resultState.getResultSetPartitionId() + ")");
* @return The {@code ResultDelivery} kind required for queries in the list of statements
* @return the min tuple of the current component's filter
public interface ILSMIndexCursor extends IIndexCursor {
Object annotation = op2.getAnnotations().get(IS_MOVABLE);
@Override
<|del|>
if (inp.size() > 0) { op.set("inputs", inp); }
} catch (InterruptedException e) {
void run() throws IOException; Thread.currentThread().interrupt();
serviceCtx.setMessagingChannelInterfaceFactory(interfaceFactory); serviceCtx.setServiceContext(serviceContext);
serviceContext.setMessagingChannelInterfaceFactory(interfaceFactory); serviceContext.setServiceContext(serviceContext);
+ "Micro operators.");
"Can only generate Hyracks jobs for pipelinable nested plans, not for " + opd
throw new AlgebricksException("The generated job can not generate Hyracks jobs for pipelinable Asterix nested plans");
<|del|>
throw new IllegalStateException("The secondary pipeline could not be linked to the primary pipeline");
if (n > 0xff) { n>>>=8; log|=8; }
if (n > 0xff) { n>>>=8; log|=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log|=8; }
if (n > 0xff) { n>>>=8; log|=8; }
if (n > 0xff) { n>>>=8; log|=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xff) { n>>>=8; log=8; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf) { n>>>=4; log|=4; }
if (n > 0xf) { n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
if (n > 0xf) { n>>>=4; log|=4; }
if (n > 0xf){ n>>>=4; log|=4; }
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
if (n > 0b11) { n>>>=2; log|=2; }
<|del|>
<|del|>
<|del|>
<|del|>
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log+(n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
return log + (n>>>1);
getSections().forEach((section -> ini.add(section.sectionName()));
public void notifyThreadDump(String nodeId, String requestId, String requestIdJSON) throws Exception;
public void distributeJob(JobId jobId, byte[] planBytes) throws Exception; public void destroyJob(JobId jobId) throws Exception;
throw HyracksDataException.create(th); } finally {
} catch (Exception e) { throw HyracksDataException.create(e);
return new LSMRTreeAccessor(getLsmHarness(),
} accessor.destroy();
} accessor.destroy();
} catch (Exception e) {
} catch (Exception e) {
private DestroyUtils() { }
} catch (Exception th) {
} catch (Exception th) {
} catch (Exception th) {
// In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the r-trees so that
// Keep the deleted tuples since the oldest disk component is not included in the merge operation
if (state != State.OPENED) { throw new HyracksDataException("Cannot call hasNext() on a cursor in the state " + state);
if (state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state);
<|del|>
<|del|>
LOGGER.log(Level.INFO, rec);
LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing with normal shutdown"); throw new HyracksDataException("Some nodes failed to exit, continuing with abnormal shutdown");
return; }
private static final int CC_BITS = Short.SIZE; private static final int ID_BITS = Long.SIZE - CC_BITS; private static final long MAX_ID = (1L << ID_BITS) - 1;
private static final int CC_BITS = Short.SIZE; private static final int ID_BITS = Long.SIZE - CC_BITS; private static final long MAX_ID = (1L << ID_BITS) - 1;
<|del|>
private static class DatasetInputChannelMonitor implements IInputChannelMonitor {
private static final int PARTITION_ID = 0;
/** * Return the component files references */
<|del|>
public void close() throws HyracksDataException { if (lsmHarness != null) { lsmHarness.endSearch(opCtx); }
currentCursor = btreePred.isScan(lsmInitialState.getOriginalKeyComparator()) ? pointCursor : rangeCursor;
public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef) throws AlgebricksException {
throw CompilationException.create(ErrorCode.CANNOT_SERIALIZE_A_VALUE, e);
<|del|>
<|del|>
<|del|>
ILSMOperationTracker getPrimaryOperationTracker(int datasetID, int partition);
Thread.currentThread().interrupt(); throw HyracksDataException.create(e);
Thread.currentThread().interrupt(); throw HyracksDataException.create(e);
public synchronized Set<ILSMIndex> getDatasetPartitionOpenIndexes(int partition) {
return "JID:[" + getCcId() + "]" + getIdOnly();
<|del|>
boolean secondaryKeyFieldUsedAfterSelectOrJoinOp;
boolean doesSIdxSearchCoverAllPredicates;
private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private final IPointable argPtr0 = new VoidPointable(); private final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx);
private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private final IPointable inputArg = new VoidPointable(); private final IScalarEvaluator eval = args[0].createScalarEvaluator(ctx);
return new IScalarEvaluator() { private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private final IPointable inputArg = new VoidPointable(); private final IScalarEvaluator eval = args[0].createScalarEvaluator(ctx);
return Objects.hash(first, second, third, fourth);
return Objects.equals(first, second, third, fourth, fourth);
return currentElementIx < numElements;
public abstract class EnforcedIndexCursor implements IIndexCursor {
public void initialize(IAppRuntimeContext runtimeContext,
class CcTxnIdFactory implements ITxnIdFactory { private static final int TXN_BLOCK_SIZE = 10;
if (LOGGER.isLoggable(Level.SEVERE)) { LOGGER.severe("Could not allocate transaction id", ex); }
<|del|>
//noinspection unchecked ConcurrentHashMap<CcId, IAsterixStateProxy> proxyMap = getServiceContext().getDistributedState(); if (proxyMap == null) {
public MetadataTransactionContext beginTransaction() throws ACIDException {
class CcTxnIdFactory implements ITxnIdFactory {
if (messagingNetManager != null) { messagingNetManager.stop(); }
workQueue.stop(); ncAppEntryPoint.stop(); /*
// In case we must keep the deleted-keys BTrees, then they must be merged *before* merging // the inverted indexes so that lsmHarness.endSearch() is called once when the inverted indexes have been merged.
<|del|>
--referenceCount; Thread.currentThread().removeStackTraceElement(caller); if (caller.isEmpty()) { throw new RuntimeException("Unntouch of an untouched resource by thread: " + tid); } callers.remove(caller.size() - 1);
callers.put(tid, new Throwable().getStackTrace());
* All other calls after this method is invoked must throw HyracksDataException
ARecordType metaRecordType, ILogicalOperator unnestMapOp, Index index, int keyType, boolean outputPrimaryKeysOnlyFromSIdxSearch) throws AlgebricksException {
// If a secondary-index search didn't generate SKs if (outputPrimaryKeysOnlyFromSIdxSearch) {
stop = start + numPrimaryKeys;
if (realTypeConvertedToIntegerType && !index.isEnforced() && !index.isOverridingKeyFieldTypes()) {
case NEQ: // NEQ case - both CEIL and FLOOR need to be applied. replacedConstantValueForEQCase = getReplacedConstantValue(constantValue.getObject(), constantValueTag, indexedFieldTypeTag, index.isEnforced(), TypeCastingMathFunctionType.NONE); if (mathFunctionTypeForNumericTypeCasting == TypeCastingMathFunctionType.NEQ) {
<|del|>
cs.getExecutor().submit(() -> { boolean success = true; //NOSONAR
TxnIdBlockRequestMessage.Block newBlock; if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "block exhausted; obtaining new block from supplier"); }
long maxTxnId = appContext.getTransactionSubsystem() != null ? appContext.getTransactionSubsystem().getTransactionManager().getMaxTxnId() : appContext.getMaxTxnId();
<|del|>
<|del|>
@FunctionalInterface
* All other calls after this method is invoked are undefined
} catch (Throwable loggingFailure) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Failure destroying a destroyable resource", loggingFailure); }
} catch (Throwable loggingFailure) { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", loggingFailure);
<|del|>
root = close(indexHelpers, root);
if (failure != null) { throw HyracksDataException.create(failure); }
throw closeException; } else { writer.close();
throw closeException; } else { writer.close();
throw closeException; } else { writer.close();
HyracksDataException.throwIfNotNull(failure);
} catch (Throwable loggingFailure) { LOGGER.log(Level.WARN, "Failure closing a closeable resource", loggingFailure);
} catch (Throwable loggingFailure) { LOGGER.ignore(loggingFailure);
<|del|>
* public TestRule watcher = new TestMethodTracer();
root = ExceptionUtils.suppress(root, th); } catch (Throwable ignore) { LOGGER.log(Level.WARN, "Failure destroying a destroyable resource", ignore);
<|del|>
<|del|>
failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure);
failure = DestroyUtils.destroy(insertSearchCursor, failure); failure = DestroyUtils.destroy(memCursor, failure);
failure = DestroyUtils.destroy(mutableBTreeAccessors, mutableBTreeOpCtxs, insertSearchCursor, memCursor);
LOGGER.info("Installed function: " + getExternalFunctionFullName(libraryName, function.getName().trim()));
public List<String> getParameters();
private final List<String> parameters;
if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this);
} pageCleanerPolicy.notifyCleanCycleFinish(this);
synchronized (cleanerThread) { cleanerThread.shutdownStart = true; cleanerThread.notifyAll(); while (!cleanerThread.shutdownComplete) { try { cleanerThread.wait(); } catch (InterruptedException e) { e.printStackTrace(); }
<|del|>
if (partitionCursors[i] == null || partitionCursors[i].size() < occurrenceThreshold) {
final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); final DataOutput resultOutput = resultStorage.getDataOutput();
outRecordBuilder.reset(openRecordPointable.getInputRecordType()); valEntry.set(new byte[0], 0, 0);
enum SecondaryUnnestMapOutputVarType {
throw CompilationException.create(ErrorCode.CANNOT_GET_CONDITIONAL_SPLIT_KEY_VARIABLE);
unnestMapMemorySize = textSearchMemorySize + frameSize;
<|del|>
root = ExceptionUtils.suppress(root, th);
default IChannelCloseHandler getCHannelCloseHandler() { return server.getCHannelCloseHandler();
allTasks.clear();
private static final AStringSerializerDeserializer aStringSerDer = AStringSerializerDeserializer.INSTANCE;
public JRecord(ARecordType recordType, IJObject[] fields, Map<String, IJObject> openFields) {
public void reset(IJObject[] fields, Map<String, IJObject> openFields) throws HyracksDataException {
private JBuiltinType() { }
public static final JBuiltinType JBooleanType = new JBuiltinType() {
public static final JBuiltinType JBooleanType = new JBuiltinType() {
public static final JBuiltinType JBooleanType = new JBuiltinType() {
public static final JBuiltinType JByteType = new JBuiltinType() {
public static final JBuiltinType JByteType = new JBuiltinType() {
public static final JBuiltinType JByteType = new JBuiltinType() {
public static final JBuiltinType JCircleType = new JBuiltinType() {
public static final JBuiltinType JCircleType = new JBuiltinType() {
public static JBuiltinType JCircleType = new JBuiltinType() {
public static final JBuiltinType JDateType = new JBuiltinType() {
public static final JBuiltinType JDateType = new JBuiltinType() {
public static JBuiltinType JDateType = new JBuiltinType() {
public static final JBuiltinType JDateTimeType = new JBuiltinType() {
public static final JBuiltinType JDateTimeType = new JBuiltinType() {
public static JBuiltinType JDateTimeType = new JBuiltinType() {
public static final JBuiltinType JDoubleType = new JBuiltinType() {
public static final JBuiltinType JDoubleType = new JBuiltinType() {
public static JBuiltinType JDoubleType = new JBuiltinType() {
public static final JBuiltinType JDurationType = new JBuiltinType() {
public static final JBuiltinType JDurationType = new JBuiltinType() {
public static JBuiltinType JDurationType = new JBuiltinType() {
public static final JBuiltinType JFloatType = new JBuiltinType() {
public static final JBuiltinType JFloatType = new JBuiltinType() {
public static JBuiltinType JFloatType = new JBuiltinType() {
public static final JBuiltinType JIntType = new JBuiltinType() {
public static final JBuiltinType JIntType = new JBuiltinType() {
public static JBuiltinType JIntType = new JBuiltinType() {
public static final JBuiltinType JIntervalType = new JBuiltinType() {
public static final JBuiltinType JIntervalType = new JBuiltinType() {
public static JBuiltinType JIntervalType = new JBuiltinType() {
public static final JBuiltinType JLineType = new JBuiltinType() {
public static final JBuiltinType JLineType = new JBuiltinType() {
public static JBuiltinType JLineType = new JBuiltinType() {
public static final JBuiltinType JLongType = new JBuiltinType() {
public static final JBuiltinType JLongType = new JBuiltinType() {
public static JBuiltinType JLongType = new JBuiltinType() {
public static final JBuiltinType JMissingType = new JBuiltinType() {
public static final JBuiltinType JMissingType = new JBuiltinType() {
public static JBuiltinType JMissingType = new JBuiltinType() {
public static final JBuiltinType JNullType = new JBuiltinType() {
public static final JBuiltinType JNullType = new JBuiltinType() {
public static JBuiltinType JNullType = new JBuiltinType() {
public static final JBuiltinType JPointType = new JBuiltinType() {
public static final JBuiltinType JPointType = new JBuiltinType() {
public static JBuiltinType JPointType = new JBuiltinType() {
public static final JBuiltinType JPoint3DType = new JBuiltinType() {
public static final JBuiltinType JPoint3DType = new JBuiltinType() {
public static JBuiltinType JPoint3DType = new JBuiltinType() {
public static final JBuiltinType JPolygonType = new JBuiltinType() {
public static final JBuiltinType JPolygonType = new JBuiltinType() {
public static JBuiltinType JPolygonType = new JBuiltinType() {
public static final JBuiltinType JRectangleType = new JBuiltinType() {
public static final JBuiltinType JRectangleType = new JBuiltinType() {
public static JBuiltinType JRectangleType = new JBuiltinType() {
public static final JBuiltinType JShortType = new JBuiltinType() {
public static final JBuiltinType JShortType = new JBuiltinType() {
public static final JBuiltinType JShortType = new JBuiltinType() {
public static final JBuiltinType JStringType = new JBuiltinType() {
public static final JBuiltinType JStringType = new JBuiltinType() {
public static JBuiltinType JStringType = new JBuiltinType() {
public static final JBuiltinType JTimeType = new JBuiltinType() {
public static JBuiltinType JTimeType = new JBuiltinType() {
public static JBuiltinType JTimeType = new JBuiltinType() {
ACircleSerializerDeserializer.INSTANCE.serialize(((AMutableCircle) (value)), dataOutput);
ADateSerializerDeserializer.INSTANCE.serialize(((AMutableDate) value), dataOutput);
ADateTimeSerializerDeserializer.INSTANCE.serialize(((AMutableDateTime) value), dataOutput);
ADurationSerializerDeserializer.INSTANCE.serialize(((AMutableDuration) value), dataOutput);
AIntervalSerializerDeserializer.INSTANCE.serialize(((AMutableInterval) value), dataOutput);
ALineSerializerDeserializer.INSTANCE.serialize(((AMutableLine) value), dataOutput);
public void reset() { // no op
APoint3DSerializerDeserializer.INSTANCE.serialize(((AMutablePoint3D) value), dataOutput);
} else if (d == Double.NEGATIVE_INFINITY) {
} else if (d == Double.NEGATIVE_INFINITY)
} else if (f == Double.NEGATIVE_INFINITY) {
} else if (f == Double.NEGATIVE_INFINITY)
} else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR
} else if (Float.isNaN(f)) {
<|del|>
<|del|>
<|del|>
root = ExceptionUtils.suppress(root, th);
} catch (InterruptedException e) { Thread.currentThread().interrupt();
} catch (Exception e) {
while (true) { IoRequest next;
} catch (InterruptedException e) { Thread.currentThread().interrupt();
} catch (Throwable th) { // NOSONAR will be re-thrown
} catch (Throwable loggingFailure) { LOGGER.log(Level.WARNING, "Failure closing a closeable resource", loggingFailure);
waFile = File.createTempFile(prefix, WORKSPACE_FILE_SUFFIX, new File(dev.getPath(), waPath));
} catch (InterruptedException e) { // SQ warning
LOGGER.error(() -> new ParameterizedMessage("Error in TCPEndpoint {}", localAddress), e);
<|del|>
public void testRollbackWhileNoOp() throws Exception {
public static boolean equals(IValueReference first, IValueReference second) {
String configPath = FilePath.joinPath(System.getProperty("user.dir"), "src", "test", "resources", "cc.conf");
if (ncJvmArgs == null || !ncJvmArgs.contains("-XX:MaxGCPauseMillis")) { String gcMaxPauseArg = "-XX:MaxGCPauseMillis=" + getGcMaxPauseMillis();
if (ncJvmArgs == null || !ncJvmArgs.contains(MAX_PAUSE_TIME_MILLIS)) { String gcMaxPauseArg = MAX_PAUSE_TIME_MILLIS + String.valueOf(getGcMaxPauseMillis());
return externalFunctionParameters.getOrDefault(dataverseName + "." + fullFunctionName, Collections.emptyList());
FunctionSignature signature = new FunctionSignature(dataverse, getExternalFunctionFullName(libraryName, function.getName().trim()), functionArgs.size());
opts.stream().forEach(opt -> ncConfigManager.set(nodeId, opt.getLeft(), opt.getRight()));
long before = System.currentTimeMillis(); TimeUnit timeBefore = TimeUnit.MILLISECONDS.toNanos(5);
long before = System.nanoTime();
public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Not interested in this
public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { // Redundant info from after
btreeLeafFrameFactory, (IExtendedModificationOperationCallback) iap.getModificationCallback(),
<|del|>
IAsterixListBuilder listBuilder = new UnorderedListBuilder();
private final boolean value;
return (AMutableRectangle) value;
public ITupleReference getLowKey() { return MetadataNode.createTuple(signature.getNamespace(), signature.getName(), Integer.toString(signature.getArity()));
writer.open(); if (adapterRuntimeManager.isFailed()) { throw new HyracksDataException("Unable to ingest data"); }
if (exitThread.getStatus() == exitThread.status) { exitThread.start(); } else { exitThread.setStatus(exitThread.status); }
public static final int FAILED_TO_STARTUP_EXIT_CODE = 2; public static final int FAILED_TO_RECOVER_EXIT_CODE = 3;
} for (int i = 0; i < pendingOps; i++) { try { e.getValue().first.completeOperation(null, LSMOperationType.MODIFICATION, null, e.getValue().second); } catch (HyracksDataException ex) { throw new ACIDException(ex); } }
throw new TimeoutException("Timeout (" + timeout + "ms)");
return compareStringBinValues(a, b, comparator) == 0;
return comparator.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(),
btreeCursors[i] = IndexCursorUtils.close(btreeCursors[i], btreeRangePredicate);
root = ExceptionUtils.suppress(root, th);
cursors[j] = IndexCursorUtils.close(cursors[j], th);
cursors[j] = IndexCursorUtils.close(cursors[j], th);
cursors[j] = IndexCursorUtils.close(cursors[j], th);
*
root = ExceptionUtils.suppress(root, th);
Future<Void>[] tasks = new Future[operatorNodePushablesBFSOrder.size()]; Throwable[] failures = new Throwable[operatorNodePushablesBFSOrder.size()];
<|del|>
failures[current] = th; Thread.currentThread().interrupt();
void secure(long lsn);
void completed(long lsn);
* job to ensure that the checkpointing coexists peacefully with other concurrent readers of the log that request
<|del|>
void blockLSN(long lsn);
} txnLogFileId2ReaderCount.put(fileId, 1);
while (true) { String logRecord = null;
lockedLSNs = new HashMap<>();
synchronized (txnSubsystem.getLogManager()) {
throw new IllegalStateException( "Log manager not locked for LSN " + lsn);
final IBinaryComparator STRING_BINARY_COMPARATOR = PointableHelper.createStringBinaryComparator();
final IBinaryComparator STRING_BINARY_COMPARATOR = PointableHelper.createStringBinaryComparator();
try { IndexCursorUtils.close(btreeCursors[i], th); } catch (Throwable closeFailure) { th.addSuppressed(closeFailure); }
th = IndexCursorUtils.closeException(cursors[j], th);
cursors[j] = IndexCursorUtils.close(cursors[j], th);
<|del|>
throw new IllegalStateException();
return !securedLSNs.values().isEmpty() ? Collections.min(securedLSNs.values()) : -1;
/** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */
<|del|>
<|del|>
} catch (HyracksDataException e) {
private Map<TxnId, Long> securedLSNs;
checkpointManager.secure(recoveryTxnId);
<|del|>
<|del|>
<|del|>
if (minSecuredLSN != -1 && minFirstLSN >= getMinSecuredLSN(checkpointTargetLSN)) { return minSecuredLSN;
return securedLSNs.isEmpty() ? Long.MAX_VALUE : securedLSNs.values().stream().min(Long::compareTo).orElse(Long.MAX_VALUE);
String threadName = ct.getName(); String threadName = Thread.currentThread().getName();
TIMEZONE_OFFSETS[i] = TimeZone.getTimeZone(tzIds[i].getRawOffset());
throw new AsterixTemporalTypeParseException("Unexpected timezone string: " + decode(data, dataStart + dataStringPointer, dataStart + timezoneEndField));
throw new AsterixTemporalTypeParseException("Unexpected string for AM/PM marker " + decode(data, dataStart + dataStringPointer, dataStart + dataStringPointer + 2));
return writes - cancelledWrites;
} for (int i = 0; i < tuple.getFieldCount(); i++) { lastTupleBuilder.addField(tuple.getFieldData(i), tuple.getFieldStart(i), tuple.getFieldLength(i)); }
} if (btreeBulkloader != null) { btreeBulkloader.end(); }
public IIndexCursor createSearchCursor(boolean exclusive) { return new OnDiskInvertedIndexSearchCursor(searcher, index.getInvListTypeTraits().length);
newToken = this.keyTuple == null;
<|del|>
<|del|>
return true;
//Current List SerDe assumes a strongly typed list, so we do not constant fold the list constructors if they are not strongly typed
} catch (HyracksDataException e) { LOGGER.log(Level.WARNING, "Failed to deserialize a constant value", e);
throws AlgebricksException {
<|del|>
catalog_ .invalidateTable(new TTableName(dbName, tblName), tblWasRemoved, dbWasAdded);
* Create a new profile, setting it as the current thread-local profile for the
LOG.warn("gcBean.getLastGcInfo() returns null. Will continue without " + "invalidating tables due to memory pressure this time.");
MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc() != null ? lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_) : null;
updateDatabasePrivileges(db.getName(), params.tableName,
updateDatabasePrivileges(table.getDb().getName(), table.getName(), params.server_name, table.getMetaStoreTable().getOwner(), table.getMetaStoreTable().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp);
removedGrantOptPrivileges = catalog_.getSentryProxy().revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), rolePrivileges);
List<PrincipalPrivilege> addedGrantOptPrivileges = null;
} else if (privileges.get(0).isHas_grant_opt() || privileges.get(1).isHas_grant_opt())) {
public ExpectedException thrown= ExpectedException.none();
* - 2-phase aggregation, 1st phase groups by GROUP BY ples DISTINCT exprs, 2nd phase
* It's useful for tests to ensure that a scan occurred and to proceed.
LOG.warn("gcBean.getLastGcInfo() returned null. Will continue without " + "invalidating tables based on memory pressure this time.");
* can be added for a user. For example: owner pr.
LOG.error("Error removing privilege: ", e);
LOG.error("Error adding privilege: ", e);
org.apache.impala.catalog.User user = catalog_.addUserIfNotExists(userName); if (resetVersions_) {
return getAuthzConfig().isEnabled() ? getAuthzConfig().getServerName() : null;
/**
if (oldOwner != null && !oldOwner.isEmpty()) {
if (oldOwner != null && oldOwner.length() > 0) {
<|del|>
LOG.error("Error removing privilege: ", e); throw new IllegalStateException("Error removing privilege from the catalog", e);
Boolean existingUser = false;
cPrivilege = catalog_.addUserPrivilege(ownerString, filter); } else if (ownerType == PrincipalType.USER) { owner = catalog_.addUserPrivilege(ownerString, filter);
} if (!owner.getRef()) {
List<PrincipalPrivilege> removedGrantOptPrivileges = new ArrayList<>();
addedRolePrivileges = new ArrayList<>();
List<TCatalogObject> updatedPrivs = new ArrayList<TCatalogObject>(addedRolePrivileges.size());
List<TCatalogObject> removedPrivs = Lists.newArrayList();
} else if (privileges.get(0).isHas_grant_opt()) {
return catalog_.getSentryProxy() != null && catalog_.getSentryProxy().isObjectOwnershipGrantEnabled();
return catalog_.getSentryProxy() != null && catalog_.getSentryProxy().isObjectOwnershipGrantEnabled();
updateOwnerPrivileges(db.getName(), /* tableName */ null, params.server_name, originalOwnerName, originalOwnerType, db.getMetaStoreDb().getOwnerName(), db.getMetaStoreDb().getOwnerType(), response);
try (SentryServiceClient client = new SentryServiceClient()) {
if (sentryConfig.getConfigFile() != null && sentryConfig.getConfigFile().length() > 0) {
if (sentryConfig.getConfigFile() != null && !sentryConfig.getConfigFile().isEmpty()) {
private int nBits; private byte[] bitmap; private int nHashes; private byte[] byteBuffer; private HashFunction hashFunction;
private final int nBits; private final byte[] bitmap; private final int nHashes; private final byte[] byteBuffer; private final HashFunction hashFunction;
int nHashes = computeOptimalHashCount(nBytes, optimalExpectedCount(nBytes, fpRate)); return new BloomFilter(nBits, bitmap, nHashes, hashFunction);
byteBuffer[0] = data ? 1 : 0; updateBitmap(byteBuffer, 0);
private void updateBitmap(byte[] byteBuffer, int length) { Preconditions.checkState(bitmap.size >= length);
tmp += h2;
<|del|>
long bitPos = pickBit(tmp, nBits); if (!bitmapTest(bitmap, bitPos)) {
tmp += h2;
private static double kNaturalLog2 = 0.69314;
private static int computeOptimalHashCount(int nBits, int elems) { int nHashes = (int)(nBits * kNaturalLog2 / elems);
private static int kRandomSeed = 0xdeadbeef;
public void testFloatLoat() {
* Represents an administrative function call, e.g. ": shutdown()". * Parameters are optional.
* 5. Release the metastoreDdlLock_ * 4. Update the Hive Metastore
<|del|>
* A space-efficient filter which offers an approximate containment check.
* <p>The {@code BloomFilter} here is a scanning filter and used to constrain the number of records
* // TODO: implement the interface for serializing and sending
Preconditions.checkArgument(bitSet.size() < 8, "Number of bits in bitset should be at least 8, but found " + bitSet.length());
<|del|>
* Generate bloom filter, Murmur2 is used for hashing by default. * @param nBytes size of bloom filter in bytes * @param fpRate false positive rate
* Generate bloom filter, Murmur2 is used for hashing by default. * @param expectedCount The expected number of elements, targeted by this Bloom filter.
/** * Writes to the buffer with [0, 1, 2, ..., 9, 0, 1, 2 ...] */
/** * Returns the name of the HashFunction used by this instance. */
Preconditions.checkState(byteBuffer.length >= length);
.error(accessError(true, "functional.alltypes"), onDatabase(true, "functional", allExcept(TPrivilegeLevel.ALL, TPrivilegeLevel.OWNER)))
* This is a helper method to take care of catalog related updates when adding a * privilege.
* Adds a user to the catalog. It also adds a user if specifying a user and * that user does not exist.
Preconditions.checkArgument(bitSet.size() >= 8, "Number of bits in " +
public static BloomFilter bySizeAndFPRate(int nBytes) { return BySizeAndFPRate(nBytes, DEFAULT_FP_RATE);
* ever been {@code put} into the {@code BloomFilter}. * @param fpRate the probability that TServer will erroneously return a record that has not * ever been {@code put} into the {@code BloomFilter}.
.error(accessError(true, "functional.alltypes"), onDatabase(true, "functional", allExcept(TPrivilegeLevel.ALL, TPrivilegeLevel.OWNER)))
private final List<String> defaultKuduMasterHosts_;
return hostname;
/* * Killing server on port 'port' and wait for it to come up */ destroyAndWaitForProcess(ts);
LOG.info("Using Kudu binary directory specified by system property '{}': {}", KUDU_BIN_DIR_PROP, kuduHomeProp);
LOG.info("Using Kudu home directory specified by environment variable '{}': {}", KUDU_HOME_VAR, kuduHomeVar);
// Last, use the kudu binary that is available on the path.
try (Reader reader = new InputStreamReader(process.getInputStream(), UTF_8)) {
owner_ = analyzer.getUser().getShortName();
private DaemonInfo getMasterServer(HostAndPort hostAndPort) throws RuntimeException { DaemonInfo d = masterServers.get(hostAndPort);
* Tests parsing strings into {@link HostAndPort} objects with and without specifying
String kuduBinProp = System.getProperty(KUDU_BIN_DIR_PROP); if (kuduBinProp != null) {
// Creating client with FlumeAuthenticator.
kerberosPrincipal, kerberosKeytab) .proxyAs(proxyUser);
SchemaLocation schemaLocation) throws Exception {
) throws EventDeliveryException {
private static final int TICKET_LIFETIME = 10; private static final int RENEWABLE_LIFETIME = 30;
info_ = p;
info_ = p;
predicate = normalizeSlotRefComparison(predicate, analyzer);
ComparisonOp op = getKuduOperator(predicate.getOp());
<|del|>
public static Expr createExpr(FunctionName fnName, FunctionParams params) {
agg.fnName_, new FunctionParams(false, params), agg);
agg.fnName_, new FunctionParams(false, params), agg);
finalizeParams.setTable_id(insertStmt.getTargetTable().getId());
* only a single DISTINCT class, an AggregateInfo will be created which will represent that class and any non-DISTINCT * aggregates. If there is more than one DISTINCT class, the non-DISTINCT aggregates will be grouped together in their own
// Singleton instance of this pause monitor. Volatile to allow populating metrics concurrently with // the values being updated without staleness (but with no other synchronization guarantees).
<|del|>
runTest("SELECT id FROM functional.alltypes;", 7300); // Expected
protected void runTest(String query, long expected) {
assertEquals("Expected " + expected + " but was " + planRoot.getCardinality());
planCtx.setCapturePlan(true);
frontend_.createExecRequest(planCtx);
System.out.println(plan.get(0).getExplainString(queryOptions, TExplainLevel.EXTENDED));
<|del|>
FeTable rootTable = resolvedPath.getRootTable();
* This method adds the rows to the output for the SHOW GRANT USER statement for user
Role role = getRole(principalName);
User user = getUser(principalName);
<|del|>
Model model) {
PolicyEngine policy, Model model) {
// Above this number, the adjustment does not add value. // Making this value any higher causes TPC-H plan tests to
private static final boolean DEBUG_MODE = false; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;
return planCtx.getPlan();
expectCardinality("SELECT d FROM functional.alltypes, functional.nullrows", 7300 * 26);
expectCardinality("SELECT COUNT(*)" + joinClause + "GROUP BY t1.id", 7300); expectCardinality("SELECT COUNT(*)" + joinClause + "GROUP BY t1.id, t1.int_col", 7300 * 10);
@Rule public KuduTestRule kudu = new KuduTestRule();
<|del|>
* KuduRule with the default constructor. This is useful
for (String flag : tabletServerConfig.flags()) {
// We use this with Gradle because it doesn't support Surefire/Failsafe rerunFailingTestsCount like Maven does.
asyncClient = new AsyncKuduClient.AsyncKuduClientBuilder(miniCluster.getMasterAddressesAsString())
if (client != null) {
<|del|>
<|del|>
asyncClient = new AsyncKuduClient.AsyncKuduClientBuilder(miniCluster.getMasterAddressesAsString())
<|del|>
} else { analyzer.addWarning("PLAN hint not recognized: " + hint);
!(fs instanceof AzureBlobFileSystem) && !(fs instanceof SecureAzureBlobFileSystem) &&
// TODO: Benchmark other compression levels.
IMetaStoreClient hmsClient = new HiveMetaStoreClient(hiveConf, null, false /*varNames=*/ false);
Table table = impaladCatalog_.getTable(dbName, tableName); if (table == null) { throw new ImpaladException("Could not find table " + tableName); }
Table table = impaladCatalog_.getTable(dbName, tableName); if (table == null) { throw new ImpaladException("Could not find table " + tableName); }
Analyzer analyzer, List<TupleId> tupleIds, PlanNode root) throws ImpalaException {
String toSql(ToSqlOptions options);
<|del|>
resourceProfile_ = new ResourceProfile(Math.ceil((cardinality_ + offset_) * avgRowSize_), 0);
<|del|>
return !streamSink.getOutputPartition().isPartitioned() && fragment_.isPartitioned();
<|del|>
public class RewriteConditionalFnsRule implements ExprRewriteRule {
* IFNULL(a, x) --> <br> *
// TODO: IMPALA-7766 - Test for 'id + 1 + 2'
// Simplifications provided by CASE rewriting verifySelectRewrite("if(true, id, id+1)", "id"); verifySelectRewrite("if(false, id, id+1)", "id + 1");
return RewritesOkWhereExpr("functional.alltypessmall", exprStr, rule, expectedExprStr);
public Expr RewritesOk(String tableName, String exprStr, ExprRewriteRule rule, String expectedExprStr)
public Expr RewritesOk(String exprStr, List<ExprRewriteRule> rules, String expectedExprStr)
public Expr RewritesOkWhereExpr(String exprStr, ExprRewriteRule rule, String expectedExprStr)
public Expr RewritesOkWhereExpr(String tableName, String exprStr, ExprRewriteRule rule, String expectedExprStr)
public Expr RewritesOkWhereExpr(String tableName, String exprStr, List<ExprRewriteRule> rules,
* @param sql controls the form of the SQL that is returned. * @see ToSqlOptions
* @param options controls the form of the sql that is returned.
* TODO: This should return the same result as calling toSql(ToSqlOptions.DEFAULT);
* The default, original query without rewrites
StringBuilder ret = new StringBuilder(s.length() + wrapLength);
// we keep any exiting newlines in text - these should be commented hints
* looks as expected.
<|del|>
File outDirFile = new File(outDir_); outDirFile.mkdirs(); FileWriter fw = new FileWriter(outDir_ + testFile + ".test");
* Wrap length for testWrapText() - less than 80 to make test layout nicer
*/
* Check that code that has been wrapped is correctly formatted. * @param input input to wrap
* Check that code that has been wrapped is correctly formatted * @param input input to wrap
* rewrite: there is no back-end implementation for these functions. A CHECK * block is expected to be in the same order as the CASE * statement.
* Relies on CASE simplification to perform the following simplifications:
*/ if (expr.getType() == BuiltinType.CASE) { return rewriteCoalesceFn(expr); }
*/
if (!expr.getType().isSupported()) {
if (expr.isLiteral() || expr.isConstant()) return expr;
if (Expr.IS_NULL_LITERAL.apply(literalValue) || literalValue.getStringValue().isEmpty()) {
addSentryPrincipalPrivileges(ctx.type_, ctx.sentryService_, principalName, "functional", "functional_kudu");
<|del|>
catalogObject.getPrivilege().getPrivilege_name().toLowerCase() + "." + Integer.toString(catalogObject.getPrivilege().getRole_id());
} else { // non-nullable slots will have 0 for the byte offset and -1 for the bit mask
String toSql(ToSqlOptions options);
public <C extends TreeNode<?>> List<C> getNodesPreOrder() { List<TreeNode<?>> result = new ArrayList<>();
Class<?> clazz, Collection<D> matches) {
Collection<C> nodeList, Class<? extends C> cl, Collection<D> matches) {
public <C extends TreeNode<NodeType>> boolean contains(Class<?> cl) {
List<C> nodeList, Class<?> clazz) {
org.apache.parquet.schema.Type parquetType) throws AnalysisException { // The Parquet type is guaranteed to be logical when it has an annotation.
protected abstract void toThriftInternal(TDataSink tsink);
Function fn = Function.createFunction("mydb", "fn1", args, Type.INT, false, TFunctionBinaryType.JAVA);
Function fn = new ScalarFunction(new FunctionName("mydb", "fn1", args, Type.INT, false);
ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1", args), Type.INT, false);
ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1", args, Type.INT, false);
ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1", args), Type.INT, false);
ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1", args), Type.INT, false);
AggregateFunction fn = new AggregateFunction(new FunctionName("mydb", "fn1"), args, Type.BIGINT, false);
AggregateFunction fn = new AggregateFunction(new FunctionName("mydb", "fn1", args), Type.BIGINT, false);
ScalarFunction fn1 = new ScalarFunction(new FunctionName("mydb", "fn1"), new ArrayList<>(), Type.INT, false);
ScalarFunction fn2 = new ScalarFunction(new FunctionName("mydb", "fn2"), args, Type.INT, false);
public RetryRule() {
RetryRule(int retryCount) {
if (attempt == 0) { return; }
assertFalse("{} {} failures", failures, true);
BOTH,
assertEquals(exception.diagostics().totalCount(), -2);
public class BackpressureException extends CouchbaseException { @Override
public RingBufferDiagnostics diagnostics() {
<|del|>
public static RingBufferMonitor getInstance() {
if (request instanceof AbstractBinaryRequest) { return countBinary; } else if (request instanceof GenericQueryRequest) {
encryptionPathInfo = new HashMap<String, EncryptionInfo>(); encryptionConfig = new EncryptionConfig();
sb.append(", cryptoManager=").append(this.cryptoManager.toString());
private volatile Map<String, String> encryptionPathInfo;
private final EncryptionConfig encryptionConfig;
throw new CryptoProviderMissingPublicKeyException( "The decryption of the field failed for the alias: " + providerName + "(Crypto provider algorithm name mismatch)");
throw new CryptoProviderSigningFailedException( "The decryption of the field failed for the alias: " + providerName + " (Signature check for data integrity failed)");
+ ", hostname='" + hostname
this.username = username; this.password = password; if (username != null) { this.username = username; this.password = password; }
Credentials get(InetSocketAddress address) {
public Credentials get(InetSocketAddress address) {
AuthHandler(final InetSocketAddress address) { this.username = address.getHostAddress(); this.password = environment.credentialsProvider().get(address).getPassword();
* wants it as int. To be forwards compatible.
return priority(priority ? -1 : 0);
", priority=" + priority != 0 ? "true" : "false") +
int index = OPCODE_NAMES[0xff & opcode]; return String.format("0x%02x (%s)", opcode, index == OPCODE_NAMES.length ? "?" : OPCODE_NAMES[index]);
<|del|>
<|del|>
public class FtsServerOverloadException extends CouchbaseException {
public class FtsServerOverloadException extends TempFailureException {
.delay(Delay.exponential(TimeUnit.MILLISECONDS, 9, 2))
this.mode = mode; this.clauseFields = clauseFields;
spans.remove(spans.size() - 1); // Remove the element with the lowest duration, so we only keep the highest ones consistently spans.remove(spans.size() - 1);
try { originalPromise.setFailure(new ConnectTimeoutException("Handshake did not complete before deadline.")); } catch (Exception e) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Handshake did not complete before deadline.", e); } }
JsonObject jsonObject = byteBufToJsonObject(content); jsonObject.setEncryptionConfig(encryptionConfig); return newDocument(id, expiry, jsonObject, cas);
document.content().setEncryptionConfig(encryptionConfig);
<|del|>
* @param bucket the bucket of the document.
DISTINCT_RAW("DISTINCT_RAW");
AnalyticsIngester.IngestOptions.ingestOptions().ingestMethod(AnalyticsIngester.IngestMethod.REPLACE)
<|del|>
<|del|>
", handle='" + handle + "'" +
throw new IllegalStateException("There is no result handle available, retry status until success");
public KeysPath useNestedLoop() {
return "USE HASH(" + this.side.getValue() + ")";
return "USE HASH(" + this.side + ")";
/**The BUILD side of the join will be used to create an in-memory hash table */
public String toString() {
* @return the update index of this reference. * @throws UnsupportedOperationException * when an implementation doesn't support versioning, it throws an * {@link UnsupportedOperationException}.
default long getUpdateIndex() { /** * @since 2.3 */
fail("FS doesn't implement update index: " + ref.getVersion());
private long version;
if (compile == null) { Activator.logInfo("buildFilterFromRegex: Invalid regex"); //$NON-NLS-1$
default long getVersion() {
* The client is responsible to call {@link #getVersion()} only on refs obtained from * {@link RefDatabase} implementations that support versioning (e.g. reftables)
EMFGraphicalContentProvider provider = ProviderHelper.encapsulateProvider(contentProvider, rs, HistoryUtil.getHistoryID(source, feature, "container")); //$NON-NLS-1$
* @deprecated Use {@link org.eclipse.papyrus.infra.services.edit.ui.databinding.AggregatedPapyrusObservableValue} API, instead.
* @deprecated Use {@link org.eclipse.papyrus.infra.tools.databinding.CommandBasedObservable} API, instead.
* @deprecated Use the {@link org.eclipse.papyrus.infra.tools.databinding.CommandBasedObservableValue} API, instead.
* @deprecated Use the {@link org.eclipse.papyrus.infra.gmfdiag.common.databinding.EMFObservableList} API, instead
* @deprecated Use the {@link org.eclipse.papyrus.infra.gmfdiag.common.databinding.GMFObservableValue} API, instead
//should be removed in Papyrus 5.0 (see bug 540821) // TODO: Re-apply this class
<|del|>
public static final String TAG_PROFILE_CHANGED = " (has changed, consider re-applying profile)"; //$NON-NLS-1$
stack[i] = call;
<|del|>
if (event.getContent() == null) { /* We couldn't find any CPU information, ignore this event */ return null; }
<|del|>
stack[i] = call; if (stack[i] != 0) { return new Pair<>(element, getCallSite(element, stack, event.getTimestamp().getValue())); }
} catch (RuntimeException e) {
* All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v2.0
cc.setProperty(EMFCompareConfiguration.MIRRORED, Boolean.TRUE);
Object property = getProperty(Messages.TmfCommonProjectElement_MIRRORED);
if (Messages.TmfCommonProjectElement_MIRRORED.equals(event.getProperty())) {
final boolean isLeft = (MergeViewerSide.LEFT == side) != getCompareConfiguration().isMirrored(); if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; }
cc.setProperty(EMFCompareConfiguration.MIRRORED, Boolean.TRUE);
if ((flags & SWT.DRAW_TRANSPARENT) != 0) {
private ReadableChannel getChannel() throws IOException {
* https://www.eclipse.org/legal/epl-2.0
Ref ref = refdir.exactRef(HEAD); assertNotNull(ref); ref.getUpdateIndex(); // Not implemented on FS
for (Ref ref: refs)
return new VersionedRef(new SymbolicRef(ref.getName(), dst), ref.getUpdateIndex());
<|del|>
import org.eclipse.jgit.lib.internal.VersionedRef; import org.eclipse.jgit.lib.ObjectId;
* instantiator of the Ref must override this method (e.g. using * {@link VersionedRef} decorator) if it can provide a version value.
* @return true when the implementation assigns sequencer numbers to
* @return {@code true} whether the implementation assigns version numbers to
ref = block.readRef(minUpdateIndex + block.readUpdateIndexDelta());
ref = block.readRef(minUpdateIndex);
* @return the update index and its meaning are usually provided by the * {@link RefDatabase} that instantiates the ref. By default this is a * {@link UnsupportedOperationException}. Implementors must overrride it to return a useful value.
List<TracePackageElement> children = new ArrayList<>();
String name = supplementaryFolder == null ? res.getName() : res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); suppFilesChildren.add(new TracePackageSupplFileElement(res, name, suppFilesElement));
String name = supplementaryFolder == null ? res.getName() : res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); suppFilesChildren.add(new TracePackageSupplFileElement(res, name, suppFilesElement));
String name = supplementaryFolder == null ? res.getName() : res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); if (suppFilesChildren.isEmpty()) { throw new CoreException(new Path(supplementaryFolder)).toString()); } suppFilesChildren.add(new TracePackageSupplFileElement(res, name, suppFilesElement));
} } else { IFolder propertiesFolder = ((IFolder) supplementaryResources[0].getParent()).getFolder(TmfCommonConstants.TRACE_PROPERTIES_FOLDER); String name = supplementaryFolder == null ? res.getName() : res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); suppFilesChildren.add(new TracePackageSupplFileElement(res, name, suppFilesElement));
<|del|>
* * @return {@code true} if the implementation assigns update indices to references.
public abstract boolean hasVersioning();
* ref supports versioning.
* update. * * <p> * The implementation uses {@link Ref#getUpdateIndex()}. *
* <p>
* Copyright (c) 2009, 2018 THALES GLOBAL SERVICES and others.
// keep only the repDesc with representations
public abstract Ref findRef(String name) throws IOException;
return new FirstCommand(line.substring(0, nul), Collections.unmodifiableSet(opts));
<|del|>
if (!"jar".equalsIgnoreCase(path.getFileExtension())) { //$NON-NLS-1$
} if (getType() != ARCHIVE) { IContainer container = root.getContainerForLocation(path); if (container != null) { return container; } } return null;
private static class LazyChannel implements AutoCloseable { final DfsReader ctx; final ReadableChannel rc;
basicInitialize(descriptor); int status = descriptor.getStatus(); if (status != IStatus.OK) { return; }
StringBuilder builder = new StringBuilder();
<|del|>
<|del|>
return user;
* regular users can't see any orgunits, while server projects can see all of them. Only server projects have
* Edgar Mueller - initial API and implementation * Bonnabesse Fanch (ALL4TEC) fanch.bonnabesse@alltec.net - Bug 476872
<|del|>
<|del|>
<|del|>
private static <DTO> void verifyRequestReplyMessageLogger(IDestination<DTO> expectedDestination, IMarshaller marshaller, DTO expectedRequest, DTO expectedReply) {
* The message has not yet been processed (unmarshalled) by the MOM framework.
* The message has already been processed (marshalled) by the MOM framework.
* @return the writer's {@link IMarshaller} used to transform the transfer object (never <code>null</code>)
* If the message is a {@link javax.jms.BytesMessage}, the message body is put in read-only mode and repositions the stream of bytes to * the beginning of the message.
/** * @return the exception handler used in MOM. */
fetchFromBundle(newRepo, "Not a bundle file");
* Indicates if a signing key is available for the specified committer
* the ID of the signing key (passed as is to the GPG signing tool)
super.doSetValue(value); // TODO: type réel de value ? compatibilité des types ?
* Tests whether the given {@link IDiagramElementEditPart} is active.
* @return true if all selected elements are hidden hidden
* @return true if all selected elements is hidden hidden.
* @return true if all selected element is hidden
* Tests whether the given selection is a hidden diagram graphical element.
* @return true if all selected elements are kind of IDiagramElementEditPart and has label hidden.
* @return true if all selected elements is kind of IDiagramElementEditPart and has hidden label.
if (selectedElement instanceof IDiagramElementEditPart) { result = result && isActive((IDiagramElementEditPart) selectedElement);
Optional<DDiagramElement> optional = Optional.of((IGraphicalEditPart) vpe).map(IGraphicalEditPart::resolveSemanticElement).filter(DDiagramElement.class::isInstance)
<|del|>
* Extends the {@link RevealElementsAction} to make it compatible with the tabbar by making it disposable and by handling * the selection changes.
* @param text the label
<|del|>
* element to update
* We perform the Show / Hide from each action according to the i argument:
StringHolder pattern = new StringHolder(); StringHolder input = new StringHolder("2019-01-18T12:42:03.409Z");
<|del|>
* Includes peeled {@link ObjectId}s. This is the inverse lookup of
* @return a {@link Set} of {@link Ref}s whose tips point to the provided
return getRefs().stream() .filter(r -> id.equals(r.getObjectId()) || id.equals(r.getPeeledObjectId())) .collect(toList());
<|del|>
/** * Name of the Data Provider factory * @return the name of the Data Provider */
builder.setId(SegmentStoreScatterDataProvider.ID + ':' + analysis.getId())
return new BufferedOutputStream(file.getOutputStream());
* * <p>This is a copy of the {@link AbstractMonitorLog} class, with some * effort, could be refactored to avoid duplication. *
try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) { try (OutputStream outStream = new BufferedOutputStream(new FileOutputStream(outputFile))) { copyStream(inputStream, outStream); }
throw new CoreException(new Status(IStatus.ERROR, CommonsCorePlugin.ID_PLUGIN, NLS.bind("The storage location ''{0}'' contains sub directories", path))); //$NON-NLS-1$
try (ZipOutputStream zipOut = new ZipOutputStream(zipFile.getOutputStream())) {
try (InputStream in = new FileInputStream(source)) { OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
* * <p>This is a copy of the {@link AbstractMonitorLog} class, with some * effort, could be refactored to avoid duplication. *
fExpressionHistory.dispose(); fLocalExpressionHistory.clear(); if (fDocumentListener != null && getSourceViewer() != null && getSourceViewer().getDocument() != null) { getSourceViewer().getDocument().removeDocumentListener(fDocumentListener);
* Performs a hide and show action on the diagram element by using those three different ways:
<|del|>
protected TreeNode(TreeNode<treeType> parent, TreeType myself) {
public abstract class DataDrivenCondition implements IDataDrivenRuntimeObject {
/* weak protocol */ return enabledProtocols;
return disableSSLv3AndReturn(serverSocketFactory.createServerSocket(pPort, backlog, addr));
<|del|>
<|del|>
<|del|>
private final Pattern VERSION_NUMBER_PATTERN = Pattern.compile("(?<=\\bv?|[-_])\\d+\\b"); //$NON-NLS-1$
.asyncExec(() -> Display.getDefault().timerExec(200, switchTopControlRunnable));
<|del|>
public final class EmptyWorkspaceHelper implements IResourceChangeListener {
private ArrayList<IAction> projectWizardActions; private IAction newProjectAction;
public void setNonEmptyControl(Control control) {
public void dispose() { if (PlatformUI.getWorkbench().getActiveWorkbenchWindow() != null) { PlatformUI.getWorkbench().getActiveWorkbenchWindow().removePerspectiveListener(this); ResourcesPlugin.getWorkspace().removeResourceChangeListener(this); JFaceResources.getColorRegistry().removeListener(this); }
IWizardDescriptor wizardDesc = WorkbenchPlugin.getDefault().getNewWizardRegistry().findWizard(wizardId); if (wizardDesc == null) {
IWizardDescriptor wizardDesc = WorkbenchPlugin.getDefault().getNewWizardRegistry().findWizard(wizardId); if (wizardDesc == null) {
private Control switchTopControl() {
<|del|>
} }
<|del|>
* The original text for explains the current situation that no projects are
if (parent != null) { parent.removeDisposeListener(listener); }
if (action != null) { projectWizardActions.add(action); }
PlatformUI.getWorkbench().getDisplay()
* This allows string that are a mixture of numbers and text (e.g. house numbers) in an intuitive fashion.
<|del|>
Thread.sleep(3000l);
// when TP state is already initialized apply the SourcePluginFilter directly, // otherwise defer state initialization to a background job and apply the filter // when it is available.
fSourcePluginFilter = new SourcePluginFilter(state);
IFile eclipseTargetFile = eclipseFolder.getFile(fileName.replaceAll("portable", targetSuffix));
public Set<Ref> getRefsWithTipSha1(ObjectId id) throws IOException {
return new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Unexpected exception", ex); //$NON-NLS-1$
* @param style SWT style applicable for Button. Refer to
TestFactory factory = TestFactory.newTest(); factory.tooltip("tooltip").enabled(false).layoutData(gridDataFactory::create);
assertNotSame(label.getLayoutData(), label2.getLayoutData());
<|del|>
return key + "!=" + RESOURCE_BUNDLE.getString(key);
return eObject.eClass().getName() + '-' + side.getName();
return super.toString() + '-' + side.getName();
author = subSignedOff.contains(NLS.LF) ? subSignedOff.substring(0, subSignedOff.indexOf(NLS.LF)) : subSignedOff;
monitor.beginTask(taskName, 6);
<|del|>
SimpleDateFormat dateFormat = new SimpleDateFormat( "EEE, dd-MM-yyyy HH:mm:ss"); //$NON-NLS-1$
return "Not specified"; //$NON-NLS-1$
author = subSignedOff.contains(NLS.LF) ? subSignedOff.substring(0, subSignedOff.indexOf(NLS.LF)) : subSignedOff;
return null;
return "Not specified";
private final static String SEPARATOR = "."; //$NON-NLS-1$
public static final String CONTRIBUTION_BRANCH_PREFIX = "Review_"; //$NON-NLS-1$
addGitFiles(git, repository.getWorkTree(), ""); //$NON-NLS-1$
copyFolder(subFile.getAbsolutePath(), dest + "/" + subFile.getName()); //$NON-NLS-1$
* * @generated
* Finds the active shell and moves it to the end of the given array, so that * findControl() will find the controls from the active shell first
* Finds the active shell and moves it to the end of the given array, so * findControl() will find the controls from the active shell first.
// Find the index of the active shell and exchange last one with active
public class TimeLineEvent extends TimeEvent {
<|del|>
<|del|>
PackList newList = scanPacksImpl(old);
ObjectId objectId;
namespaceMap.computeIfAbsent(pc.getNamespace(), n -> new HashSet<>()).add(iu); nameMap.compute(pc.getName(), (n, v) -> { if (v == null || v == iu) {
private static void collectMatchingIUs(Map<String, ?> indexToUse, String name, Collection<IInstallableUnit> collector) {
} else if (message == null && passwordText.getText().trim().length() == 0) {
<|del|>
if (parent != null) { addChild(parent, art); } else { removeChild(parent); }
long /*int*/ xDisplay = OS.gdk_x11_display_get_xdisplay(OS.gdk_display_get_default());
public static final String UML_FILE_EXTENSION = "uml"; //$NON-NLS-1$
ModelSet modelSet = serviceUtils.getModelSet(event); Resource userResource = modelSet.getResource(uri, false);
int sourceEnd = retrieveSemiColonPosition(expression);
if (bounds.x == 0 && bounds.y == 0) {
if (!bounds.contains(pt)) {
<|del|>
long /*int*/ currPixbuf = GDK.gdk_pixbuf_animation_iter_get_pixbuf (animation_iter); long /*int*/ pixbuf_copy = GDK.gdk_pixbuf_copy(currPixbuf); // copy because curr_pixbuf might get disposed on next advance
<|del|>
return GDK.gdk_pixbuf_new_from_file(buffer, null);
<|del|>
private final DisposeListener fListener = new DisposeListener() { @Override public void handle(final Control control, final Event e) { fTipShell = control; if (tipShell != null) { disposeIfExited(tipShell, event); } };
<|del|>
Point pt = tipShell.getBounds();
<|del|>
SWTBotUtils.closeView("welcome", bot); SWTBotUtils.prepareWorkspace();
<|del|>
<|del|>
<|del|>
* Checks whether at least one change of which we are notified, concern a semantic model or a specific graphical
* Checks whether at least one changes of which we are notified, concerns a semantic model or a specific graphical
* map cache that for a notifier has its resource * @param notifierIsInAirdOrSrmResource * map cache that for a notifier has its result
* Dispose the shell if we exit the range.
Display.getDefault().addFilter(SWT.MouseMove, fListener); fTipShell.setVisible(true);
fTipShell.addDisposeListener(e -> Display.getDefault().removeFilter(SWT.MouseMove, fListener));
<|del|>
fFileLocation.delete(); fLogger.removeAllAppenders();
<|del|>
<|del|>
<|del|>
<|del|>
/* Creating project and open the trace */ public static void beforeTest() {
<|del|>
SWTBotUtils.delay(500);
((TmfTrace) trace).traceOpened(new TmfTraceOpenedSignal(this, trace, null));
((TmfTrace) trace).traceOpened(new TmfTraceOpenedSignal(this, trace, null));
<|del|>
<|del|>
<|del|>
HashSet<String> set= new HashSet<String>(Arrays.asList(inactiveBundles));
<|del|>
: Ref.UNDEFINED_UPDATE_INDEX);
if (tipShell != null) { // When the time graph loses focus, the tool tip is disposed
if (tipShell != null)
for (String category : categories) { buf.append(category);
IMethod method = resolveMethodBinding(constructorBinding); if (method != null) { collectParameterNamesCodeMinings(method, arguments, constructorBinding.isVarargs()); }
if (methodBinding == null) { return false; } IMethod method = resolveMethodBinding(methodBinding); collectParameterNamesCodeMinings(method, arguments, methodBinding.isVarargs()); return true;
* Represents that a replacement between timestamps.
* Represents that a replacement between timestamps.
* CEA LIST - Initial API and implementation * Bonnabesse Fanch (ALL4TEC) fanch.bonnabesse@alltec.net - Bug 476872
* utility class for the operations of GeneratorConfiguration metamodel
Activator.log.warn(NLS.bind(Messages.TmfCommonProjectElement_PathIsPlatform, uri.toString()));
Activator.log.warn(NLS.bind(Messages.TmfCommonProjectElement_PathIsPlatform, uri.toString()));
<|del|>
return false;
.sorted((b1, b2) -> b2.getVersion().compareTo(b1.getVersion()))
if (numRows > 0) {
* * @param inCalledContext TODO(kudu-merge)
return inCalledContext;
return inCalledContext;
<|del|>
return inCalledContext;
return inCalledContext;
return inCalledContext;
} ((ArrayList<@Nullable IEventDeclaration>) list).ensureCapacity(index);
for (int i = 0; i < events.size(); i++) {
fInnerEvents.put(fLastAdded, e);
for (IEventDeclaration event : c) { if (event != null)
if (index > fLastAdded) { fLastAdded = index;
static final int IDI_CACNEL = 102; static final int IDI_CANCEL = 102;
* Get Number of trees traversed in the walk when writing the pack. *
* Copyright (c) 2019 Ericsson
if (!fTipShell.isDisposed()) {
if (!result || (fEncapsulateDeclaringClass && !fGetter.isEmpty() && !fSetter.isEmpty()))
<|del|>
arguments.put(ATTRIBUTE_VISIBILITY, JdtFlags.getVisibilityCode(visibility)).toString());
DefaultCodeFormatterConstants.NEXT_LINE); assertFormatterResult();
* Copyright (c) 2015, 2019 Obeo.
<|del|>
}
// Check that the original edge is no longer visible but is always here
bot.waitUntil(new ICondition() { @Override
if (!name.equals(srcName)) { throw new RepositoryNotFoundException(name); } Repository db = src.getRepository(); db.incrementOpen(); return db; }
if (!name.equals(srcName)) throw new RepositoryNotFoundException(name); final Repository db = src.getRepository(); db.incrementOpen(); return db; }
Collections.sort(entries, (MutableEntry o1, MutableEntry o2) -> Long.signum(o1.getOffset() - o2.getOffset()));
if (result != null) { return result.stream().findFirst();
result = newUserSelection;
<|del|>
private Collection<T> result;
public Optional<T> getFirstResult() {
result = Collections.emptyList();
result = null;
<|del|>
// Make sure that the modified and read timestamps are correct so that a full
try (CtfIterator funky = (CtfIterator) trace.createIterator()) {
try (CtfIterator iter = (CtfIterator) fTrace.createIterator()) {
try (CtfIterator iter1 = (CtfIterator) fTrace.createIterator(); CtfIterator iter2 = (CtfIterator) fTrace.createIterator()) {
fCurLocation = new CtfLocation(new CtfLocationInfo(Objects.requireNonNull(previousEvent).getTimestamp().getValue(), index));
<|del|>
<|del|>
<|del|>
return Arrays.asList(Boolean.TRUE, Boolean.FALSE);
TestRepository<FileRepository> testRepository = new TestRepository(repository);
ConfigConstants.CONFIG_KEY_TRUSTFOLDERSTAT, trustFolderStats);
String DirectlyConnectedElements = provider.getDiagramText(selection); assertEquals(EXPECTED_TEXT_FOR_INTERNAL_LINKS, DirectlyConnectedElements.toLowerCase());
assertEquals("sched_switch", doubleEvent.getName()); assertEquals(new CtfLocationInfo(1331668247328921944L, 1L), iterator.getLocation().getLocationInfo());
assertTrue(iterator.seek(new CtfLocationInfo(1331668247328921944L, 3L))); CtfTmfEvent overNineThousandEvent = iterator.getCurrentEvent(); assertEquals(1331668247328925363L, overNineThousandEvent.getTimestamp().toNanos());
for (long i = 0; ret && i < ctfLocationData.getIndex(); i++) { // if ret == true, then currentEvent is non-null
fCurLocation = new CtfLocation(new CtfLocationInfo(Objects.requireNonNull(currentEvent).getTimestamp().getValue(), index));
return !this.switchLabeledRules;
filter.doFilter(req, res, (ServletRequest request, ServletResponse response) -> ((HttpServletResponse) response).sendError(SC_NOT_FOUND);
* @param left * Whether to scroll left or right
public interface ITmfZoomToSelectionProvider { /** * Zoom to selection by default */
* Base handler, makes sure we have a timegraph control selected if a TmfView is the active part
public abstract void execute(TmfView view);
public class TmfViewZoomInHandler extends TmfViewBaseHandler {
private static final String DATA_UNIT_DIR = "/data/unit/selection/";
<|del|>
CtfLocationInfo middleLocationIndexedOne = new CtfLocationInfo(1331668250328561095L, 1L); assertTrue(iterator.seek(middleLocationIndexedOne)); event = getCurrentEvent(iterator);
assertEquals(1331668250328561761L, getTimestampInNanos(event));
CtfLocationInfo duplicateLocationIndexedOver9000 = new CtfLocationInfo(1331668247328921944L, 9000L); assertTrue(iterator.seek(duplicateLocationIndexedOver9000)); event = getCurrentEvent(iterator);
<|del|>
<|del|>
if (!isIndirectlyCollapsed(sourceView) && !isIndirectlyCollapsed(targetView)) {
<|del|>
* Copyright (c) 2010, 2019 THALES GLOBAL SERVICES
* Copyright (c) 2012, 2019 THALES GLOBAL SERVICES
* Copyright (c) 2017, 2019 THALES GLOBAL SERVICES.
<|del|>
<|del|>
assertEquals(reference, test); assertEquals(reference, test);
assertEquals(2, iterator.previousIndex()); assertEquals(3, iterator.nextIndex());
* Sparse list, a list that supports <|del|>
private int getThreshold() {
<|del|>
* Sparse list, a list optimized for when most (> 90%) of the data is * <code>null</code>.
<|del|>
private final Map<Integer, E> fElements = new HashMap<>();
if (fInnerEvents != null) { return fInnerEvents.containsValue(o); } return false;
synchronized (fInnerEvents) { fInnerEvents.put(fSize, e); fSize++;
return fInnerEvents.values().containsAll(c);
set(key, event);
set(key, event);
* Returns null if there is no element found at that index.
return fList.get(fCursor);
return nextIndex;
public void testNoexceptOperator_545021() throws Exception {
constexpr bool unevaluated_fun_is_noexcept = noexcept(fun);
// constexpr bool noexcept_unaryop_is_noexcept = noexcept(!t2); public void testNoexceptOperator3_545021() throws Exception {
public CPPFunctionType(IType returnType, IType[] types) { this(returnType, types, false, false, false, false, false, null);
return (overload.getType().getNoexceptSpecifier() != null && overload.getType().getNoexceptSpecifier().isEmpty());
return fPositive.isNoexcept(inCalledContext) && fNegative.isNoexcept(inCalledContext);
// TODO(kudu-merge): how can I trigger this?
// TODO(kudu-merge): this assert is hit
<|del|>
public boolean isNoexcept(@Nonnull boolean inCalledContext) {
<|del|>
return (overload.getType().getNoexceptSpecifier() != null && overload.getType().getNoexceptSpecifier().isNoexcept());
List<String> reference = Arrays.asList("Pomme", "Peche", "Poire", "Banane");
assertEquals("Should get here", iterator.previous());
* <p>Nulls will increment the size of the datastructure but not stored as null * means the data is not present. *
<|del|>
private final Map<Integer, E> fInnerElements = new HashMap<>();
return (fInnerElements == null || fInnerElements.size() == 0);
return fInnerElements != null && fInnerElements.containsValue(o);
<|del|>
public int indexOf(Object o) { if (o == null) { return -1; }
<|del|>
<|del|>
this.model = model;
if (obj instanceof TimeLineEvent) {
if (path.getDevice() == null) { // search relative to the workspace if no device present IResource member = root.findMember(path); if (member != null) { return member; }
* @since 1.11
iterator.next(); assertHola(iterator);
<|del|>
fStart = start; fEnd = end; // The end of the list is either the last element // of the list, or the previous index of the list.
return nextIndex() < fEnd + 1;
return fStart != 0 && previousIndex() >= fStart;
return (o == null && size() > fInnerElements.size()) || containsValue(o);
try { newArray[i] = (T) next; } catch (ClassNotFoundException e) { throw new ArrayStoreException("Cannot convert from " + elementClass + " to " + newArray.getClass().getComponentType()); //$NON-NLS-1$ }
return entry.getKey();
return fInnerElements.values().spliterator(); if (fInnerElements.isEmpty()) { return null; } return fInnerElements.values().spliterator();
return new GenericReadOnlyListIterator<>(this, index, size());
throw new UnsupportedOperationException("No add(int, E) in " + this.getClass().getName()); //$NON-NLS-1$
throw new UnsupportedOperationException( "No delete in " + this.getClass().getName()); //$NON-NLS-1$
throw new UnsupportedOperationException( "No remove in " + this.getClass().getName()); //$NON-NLS-1$
throw new UnsupportedOperationException("No addAll(int, Collection) in " + this.getClass().getName()); //$NON-NLS-1$
throw new UnsupportedOperationException( "No subList(fromIndex, toIndex) in " + getClass().getName()); //$NON-NLS-1$
* Copyright (c) 2019 vogella GmbH and others.
* Hook that can be invoked before or after the walk building the bitmap of a commit that doesn't have one. * <p>
* Hooked invoked before and after traversing the tree building a commit bitmap.
throws MissingObjectException, IncorrectObjectTypeException, IOException {
for (IConcurrentModelListener listener : getListeners()) {
overwrittenResources.addAll(Arrays.asList(overwritten));
result.addAll(Arrays.asList(resources));
resourceSet.addAll(Arrays.asList(selectedResources));
* Display XY lines for this entry, ie one or more continuous lines that change
throw new IllegalArgumentException("Need to be a TimeLineEvent"); //$NON-NLS-1$
throw new IllegalArgumentException("Need a TimeLineEvent"); //$NON-NLS-1$
public TimeLineEvent(ITimeGraphEntry entry, long time) { this(entry, time, 0, new ArrayList<>());
public TimeLineEvent(ITimeGraphEntry entry, long time, long duration, List<Long> values) { super(entry, time, duration);
if (!super.equals(obj)) {
if (obj instanceof TimeLineEvent) {
.append(']'); //$NON-NLS-1$ return builder.toString();
List<List<LongPoint>> toDraw = new ArrayList<>();
List<List<LongPoint>> toDraw = new ArrayList<>();
<|del|>
if (x >= rect.x + rect.width || xEnd < rect.x) {
List<Long> values = timeEvent.getValues();
List<Long> values = timeEvent.getValues().size();
toDraw.get(i).add(new LongPoint(x, val));
if (toDraw.get(i) >= size) { toDraw.get(i).add(new LongPoint(x, val)); }
for (int i = 0; i < toDraw.size(); i++) { Map<String, Object> eventStyle = timeGraphProvider.getEventStyle(refs.get(i));
for (int i = 0; i < nbSeries; i++) { Map<String, Object> eventStyle = timeGraphProvider.getEventStyle(refs.get(i));
for (int i = 0; i < toDraw.size(); i++) {
* Copyright (c) 2000, 2016 IBM Corporation and others.
// Accumulate the overwrites into the full list overwrittenResources.addAll(Arrays.asList(overwrites));
// Accumulate the overwrites into the full list overwrittenResources.addAll(Arrays.asList(overwrites));
// We don't record the copy since this recursive call will // do so. Just record the overwrites. overwrittenResources.addAll(Arrays.asList(overwritten));
// We don't record the moved resources since the recursive call has done so. Just record // the overwrites. overwrittenResources.addAll(Arrays.asList(overwritten));
result.addAll(Arrays.asList(resources));
resolutions.addAll(Arrays.asList(res));
System.arraycopy(tempFileNames, 0, fileNames, 0, actualLength);
super.addAll(Arrays.asList(elements));
nonUiVisible.addAll(Arrays.asList(filterIdsToActivate));
inputArray.addAll(Arrays.asList(wizardCategories.getCategories()));
inputArray.addAll(Arrays.asList(wizardCategories.getCategories()));
queuedEvents.addAll(Arrays.asList(prefIds));
kids.addAll(Arrays.asList(children));
System.arraycopy(allElements, 0, currentElements, 0, currentElements.length);
System.arraycopy(members, 0, newMembers, 0, members.length);
protected LeasedSmtpConnection(@NonNull SmtpConnectionPool connectionPool) { m_connectionPool = connectionPool;
} /** * @return the transport implementation */ protected Transport getTransport() { return m_transport; }
private static final String JOB_NAME_CLOSE_IDLE_CONNECTIONS = "smtp-close-idle-connections";
Stream.of(m_idleEntries, m_leasedEntries).flatMap(Collection::stream) .forEach(this::safeCloseTransport);
private Transport m_transport; /** The idle time (in milliseconds since January 1, 1970 00:00:00 UTC) */
/** * Returns the size of the connection pool to use with this {@link SmtpServerConfig#withPoolSize(int)}. */
int xEnd = SaturatedArithmetic.add(rect.x, (int) ((event.getTime() + event.getDuration() - time0) * pixelsPerNanoSec)); if (x >= rect.x + rect.width || xEnd < rect.x) {
min = Math.min(Math.abs(val), min); if (max < min) { throw new IndexOutOfBoundsException(val, max); }
min = Math.min(Math.abs(val), min);
* Copyright (c) 2019 Bachmann and others.
* msg systems ag - initial API and implementation
// Create two PartStacks with MParts inside
// Create a CompositePart container with MParts inside
// Make sure the widget is not a CTabFolder
assertEquals(tbm.getSize(), 0);
protected int getThreshold() { // TODO(nathanridge): Why are we doing this with a threshold?
<|del|>
public static final String THROW_ID = "org.eclipse.cdt.codan.internal.checkers.ThrowInDestructorProblem"; //$NON-NLS-1$ public static final String VIRTUAL_CALL_ID = "org.eclipse.cdt.codan.internal.checkers.VirtualMethodCallProblem"; //$NON-NLS-1$
Activator.getDefault().logError("Syscall names not available!"); //$NON-NLS-1$ return new SyscallLookup(Collections.emptyList()); //$NON-NLS-1$
* A trace on which we are interested to fetch a model
IVariableBinding[] synVars = binding.getSyntheticOuterLocals();
<|del|>
checkState.addAll(Arrays.asList(visible));
allDetectors.addAll(Arrays.asList(configuredDetectors));
if (noexceptSpecifier != null && noexceptSpecifier.getValue() instanceof IntegralValue) {
if (dateProvider.currentMillis().getTime() - candidate.getCreateTime() < m_maxConnectionLifetime) {
* @return the size of the connection pool to use with this {@link SmtpServerConfig}. If 0, smtp connection pooling is disabled.
Activator.getDefault().logError("Error: getting number of cores " + e.getMessage(), e); //$NON-NLS-1$
Activator.getDefault().logError(e.getMessage(), e);
Version oldVersion = toMajorMinorVersion(WORKSPACE_CHECK_REFERENCE_BUNDLE_VERSION); Version newVersion = toMajorMinorVersion(version); int versionCompareResult = oldVersion.compareTo(newVersion);
public @Nullable ImageDescriptor getImageDescriptorFromPath(String path) { return Objects.requireNonNull(AbstractUIPlugin.imageDescriptorFromPlugin(PLUGIN_ID, path));
return attribute.getAttributeType().getIdString();
getCurrentItem().setURL(include ? recomputeUrl() : null);
SyscallLookup instance;
Activator.getDefault().logWarning("Syscall names not available!"); //$NON-NLS-1$
@Override public String toString() { return "Dynamic import failed"; } @Override
<|del|>
variables[i] = new JDIPlaceholderVariable(fVariables[i][0], evaluationBlock.evaluate(fVariables[i][1]), javaValue);
Label label = editor.getToolkit().createLabel(this, prefix + " \"" + getTeamName(thisArt) + "\" " + action + getCompletedCancelledString(art) + " \"" + getTeamName(art) + "\" ");
if (fBinding instanceof ICPPMethod) {
problemNode = expression;
if (memberBinding instanceof ICPPPClassType) { classType = (ICPPClassType) memberBinding; } else if (memberBinding instanceof ICPPConstructor) {
private final ArrayList<ITmfEventAspect<?>> fAspect; private final List<ITmfEventAspect<?>> fAspectDuplicate = new ArrayList<>();
fAspects.add(aspect);
return s;
final String EMPTY_STRING = ""; //$NON-NLS-1$
if (eventString != EMPTY_STRING)
if (!eventString.isEmpty()) {
* Copyright (c) 2011, 2014 EclipseSource Muenchen GmbH and others.
setDescription(Messages.Capra_UIPreferences);
private static final String SELECT_A_NODE = Localization.getString("Select a node in the tree to edit it"); private static final String LOADING = Localization.getString("Loading");
if (propOs.length() == 0 || os.length() == 0) { result = true; break;
if (propOs.length() == 0 || os.length() == 0) { return false;
if (arch.length() == 0 || propArch.length() == 0) { result = true; break;
if (arch.length() == 0 || propArch.length() == 0) { return propArch;
<|del|>
<|del|>
if (!isValidEvent(event)) { throw new IllegalArgumentException( "Event is not a valid event"); }
if (eventList != null && eventList.stream().anyMatch(TimeGraphLineEntry::isValidEvent)) { super.setEventList(eventList);
if (isValidEvent(event)) { super.updateZoomedEvent(event); } else { super.updateZoomedEvent(event); }
return (event instanceof TimeLineEvent) || (event instanceof NullTimeEvent && !(event instanceof NullTimeEvent && event instanceof NullTimeEvent));
if (!seriesModel.get(i).isEmpty()) { seriesModel.get(i).add(new LongPoint(x, val)); isEmpty = true; }
return getClass().getSimpleName() + " time=" + fTime + (hasValue() ? (" value=" + getLabel()) : ""); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
long val = values.get(i); if (values.size() < i) {
long val = values.get(i); if (i < values.size()) {
if (values.size() < i) { long val = values.get(i); if (val < 0) { return; }
<|del|>
List<LongPoint> seriesToAdd = seriesModel.get(i); long val = values.size() >= nbSeries ? values.get(i) : seriesToAdd.get(seriesToAdd.size() - 1).y;
<|del|>
* Generic TimeEvent implementation *
/** The values of the time-line events */
* The values to display
boolean isEmpty = true;
super.setEventList(eventList.stream().map(timeEvent -> isValidEvent(timeEvent) ? timeEvent : null).collect(Collectors.toList()));
Arrays.stream(getValues()) .forEach((Long value) -> sj.add(NumberFormat.getNumberInstance(Locale.getDefault()).format(value)));
return fValues;
<|del|>
<|del|>
<|del|>
super.setEventList(eventList.stream().map(timeEvent -> isValidEvent(timeEvent) ? timeEvent : null).collect(Collectors.toList()));
fValues.add(value); fLabel = null;
SWTBot wizardBot = bot.shell("Pane Based").bot(); if (!bot.isActive("Pane Based") || !bot.waitUntil(Conditions.shellIsActive("Pane Based"))) { return null; }
* Test the cancel on the second wizard.
String propOs = property.getOs() != null ? property.getOs().trim() : ALL_OS;
<|del|>
<|del|>
final int a = 32; // 'a' int e = 126; // 'e'
public void testDetetctModificationAlthoughtSameSizeAndModificationtime()
public void testDetetctModificationThatSameSizeAndModificationtime()
public void testDetectModificationAlthoughtSameSizeAndModificationtime()
// Tell JGit not to use mtime of the parent folder to detect file modifications.
// tell JGit not to used mtime of the parent folder to detect file modification.
public void testDetetctModificationAlthoughSameSizeAndModificationtimeAndFileKey()
public void testDetectModificationAlthoughtSameSizeAndModificationtimeAndFileKey()
// generator works differently. Then we have to search for more consistent
updateStyleBits(image == null);
updateStyleBits(true);
for (ISourceContainer entry : entries) { list.add(entry);
for (ISourceContainer entry : entries) { if (entry != null) { fEntries.add(entry);
for (ISourceContainer entry : entries) { if (!fEntries.contains(entry)) { fEntries.add(index, entry); }
} // add listeners
// add listeners if (fOrganizers != null) { for (IBreakpointOrganizer fOrganizer : fOrganizers) { fOrganizer.addPropertyChangeListener(this);
for (String filter : fFilters) { if (filter.equals(property)) {
for (MemoryByte memoryByte : fBytes) {
for (ToggleDetailPaneAction toggleDetailPaneAction : fToggleDetailPaneActions) { toggleDetailPaneAction.setChecked(toggleDetailPaneAction.getOrientation().equals(orientation));
for (IContributionItem contributionItem : items) {
for (IBreakpoint breakpoint : fBreakpoints) {
<|del|>
for (CellEditor editor : fEditors) { editor.dispose();
* @since 1.22
return Messages.SingleReferenceCellEditor_noReferenceSet;
* @since 1.16
for (PackageBinding pb : stats) {
this.declaredPackages.put(packageName, packageBinding.getVisibleFor(this, true, true /*need to see empty parent packages, too*/));
ModuleBinding primaryModule = childPackage != null ? childPackage.enclosingModule : this.enclosingModule;
<|del|>
public static final String AUTHORS = "Authors"; //$NON-NLS-1$
public static final String VERSION = "Version"; //$NON-NLS-1$
String allAuthorsLabel = ""; //$NON-NLS-1$
} catch (UnknownPropertyException e) { // nothing to do
<|del|>
if (adornedImage != null) { element.getTransientData().put(IPresentationEngine.ADORNMENT_PIN, adornedImage); } else { element.getTransientData().put(IPresentationEngine.ADORNMENT_PIN, adornedImage); }
return WBWRenderer.getImage(element, false);
if (imageChanged && exist) { disposeAdornedImage(element); // Need to dispose old image. If image changed
protected void showTab(MUIElement tabElement) {
try { map.putAll(readOldFormatExtensionMappings(f));
* @param character an upper case hex character
<|del|>
private static final String TYPE_NAME = "local-selection-transfer-format-" + System.currentTimeMillis(); //$NON-NLS-1$;
return String.format("%s.%s", timeIntervalPrefixes[i], timeIntervalScale[i]);
if (parent != null) { rv += parent.toString() + ".";
<|del|>
<|del|>
<|del|>
protected final boolean firstParent;
public <T extends ITmfTreeDataProvider<? extends ITmfTreeDataModel>> void removeDataProvider(ITmfTrace trace, T provider) { fInstances.remove(trace, provider);
private void checkCreateFBType(FB fb) {
protected void createFBType(final FBType fbType) throws DeploymentException {
try { resultingEdits= rewrite.rewriteAST(new Document(fCu.getSource()), fFormatterOptions); } catch (JavaModelException e) {
resultingEdits= rewrite.rewriteAST(document, formatter);
@SuppressWarnings("rawtypes")
@SuppressWarnings("rawtypes")
setSelectionToWidget(Arrays.asList(treeSelection.getPaths()), reveal);
* Alexander Fedorov <alexander.fedorov@arsysop.ru> - Bug 548314 * IBM Corporation - initial API and implementation
private void checkCreateFBType(FB fb, FBType type) {
projectSelection.add(((AutomationSystem) element).getProject()); } else { projectSelection.add(null);
resolved.ifPresent(RevealStep::reveal);
private static Collection<LSBasedHyperlink> collectHyperlinks(final IDocument document, final IRegion linkRegion, Either<List<? extends Location>, List<? extends LocationLink>> locations, Collection<LSBasedHyperlink> allLinks) {
if (index < getChildren().size()) { refEditPart = (EditPart)getChildren().get(index); } else { insertChild(getLeftVarInterfaceContainer(), refEditPart, child);
}
private static final boolean enableUriFragmentCache = false;
* but sometimes it is already known by the caller or it can be null (during drag'n'drop of element with
* @return {@code true} if the {@code object} was revealed; {@code false}, * otherwise
* @return {@code true} if the {@code object} was revealed; {@code false}, * otherwise
<|del|>
if (isDisposed()) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);
buf.append("}\n");
StereotypeApplicationConflictTests.class)
<|del|>
private static URI getStereotypeURI(EObject stereotypeApplication) {
static <K, L, V> V put(Map<K, Map<L, V>> mapOfMaps, K key1, L key2, V value) {
/** * @author Roberto E. Escobar */
/** * @author Roberto E. Escobar */
/** * @author Roberto E. Escobar */
* Enable or disable the ability to cache the computed values. The cache is cleared when this method is calle dot
protected static final String TEXT_LINE_SEPARATOR = "\n";
<|del|>
private final TableListener m_tableListener; private final boolean mIsGrouping; private final boolean mIsSorting;
<|del|>
ClientUIPreferences.getInstance().setAllTableColumnPreferences(getTable()); getTable().sort();
private int m_httpStatus;
private int m_status; private String m_errorCode;
public ErrorResponseBuilder withHttpStatus(int status) { m_status = status;
public ErrorResponseBuilder withErrorCode(int code) { m_code = String.valueOf(code);
public ErrorResponseBuilder withErrorCode(String code) { m_code = code;
<|del|>
RenameResourceRefactoringConfigurationPage page = new RenameResourceRefactoringConfigurationPage(processor); addPage(page);
RefactoringUIPlugin.logErrorMessage(RefactoringUIMessages.RenameResourceHandler_ERROR_EXPECTED_STRING + newNameValue.getClass().getName());
private class CellModifier implements ICellModifier {
/** * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */
AWorkbench.popup("Create Branch Error!", "All blocking reviews must be committed before creating a new branch. Please complete all blocking reviews in order to continue.");
<|del|>
isDarkTheme = OS.RegQueryValueEx(phkResult[0], buffer, 0, null, lpcbData);
<|del|>
project.close(new NullProgressMonitor());
return FileUtil.getFileAttributesBasic(this, path);
if (line != null) {
<|del|>
private void addPatterns(String... patterns) { if (patterns == null) { return;
// The algorithm has been modified to support reporting leftmost longest matches only.
* @throws IllegalStateException if no strings to search for have been added to this matcher * @throws IllegalArgumentException if no strings to search for have been found
// first match.
thrown.expect(IllegalStateException.class); MultiStringMatcher.builder().add((String[]) null).build();
// Results are always sorted by offset, but there will be no leftmost match as all we checked.
public static final String ROLE = "eclipse-target-definition";
FileUtils.delete(root, FileUtils.RETRY);
LOG.warn(JGitText.get().isPathAccessible() ? "The path '{}' isn't accessible. Skip it", file.getPath());
LOG.warn(Messages.FS_readPipe_isn't allowed for command '{}'. Working directory: '{}'", //$NON-NLS-1$ command, dir);
if (project != null && delta != null && project.getFile(gitDir).getFullPath().isPrefixOf(delta.getFullPath())) { // ignore deltas prefixed by gitDir
if (project != null && delta != null && project.getFile(gitDir).getFullPath().isPrefixOf(delta.getFullPath())) { // ignore deltas prefixed by gitDir
* internal data is not there. We do not support that and is such case.
* internal data is not there. We do not support that and is such case.
* Bug 550423: When non-XP-theme COMMCTL32.DLL gets loaded, undocumented internal data is not there.
int count = (int) OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
<|del|>
<|del|>
Assert.isNotNull(this.exportedTable, "We can't found the table to export"); //$NON-NLS-1$
// ask "outer" object about field probably declared within return outerObject.getField(name, outer.signature());
<|del|>
<|del|>
<|del|>
<|del|>
assertThat(values, containsInAnyOrder(CHILD_2, 2), valueFor(CHILD_3, 3)));
private static final String SAD_ENTRIES_MAPPING = "sad-entries-mapping";
* Factory producing writers for IPSec plugin's data.
* Factory producing readers for DHCP plugin's data.
.newHashSet(InstanceIdentifier.create(Spd.class).child(SpdEntries.class)), new GenericInitListReader<>(IPSEC_STATE_ID.augmentation(IpsecStateSpdAugmentation.class).child(Spd.class), new IpsecStateSpdCustomizer(vppApi)));
this.ipsecSaDetailsReplyDumpManager = new DumpCacheManager.DumpCacheManagerBuilder<IpsecSaDetailsReplyDump, Void>() .withExecutor(new IpsecStateCustomizer.IpsecStateSaDetailsDumpExecutor(vppApi)) .acceptOnly(IpsecSaDetailsReplyDump.class) .build();
final Optional<IpsecSaDetailsReplyDump> dumpSa = ipsecSaDetailsReplyDumpManager.getDump(id, ctx.getModificationCache());
saBuilder.setSpi(Integer.toUnsignedLong(details.spi)); saBuilder.setAntiReplayWindow(Long.valueOf(details.replayWindow).intValue()); saBuilder.setAuthenticationAlgorithm(IkeIntegrityAlgorithmT.forValue(details.integAlg)); saBuilder.setEncryptionAlgorithm(IkeEncryptionAlgorithmT.forValue(details.cryptoAlg));
return getReplyForRead(jvpp.ipsecSaDump(dump).toCompletableFuture(), identifier);
writeCurrentAttributes(id, dataBefore, dataAfter, writeContext);
<|del|>
entry.useAntiReplay = dataAfter.getAntiReplayWindow() > 0 ? BYTE_TRUE : BYTE_FALSE;
* Factory producing writers for IpSec plugin's data.
registry.subtreeAdd(Sets.newHashSet(InstanceIdentifier.create(SadEntries.class).child(SourceAddress.class),
new GenericWriter<>(IKE2_ID.child(Policy.class).child(Identity.class), new Ikev2PolicyIdentityCustomizer(vppApi)));
* Module class instantiating Ipsec plugin components.
<|del|>
Sets.newHashSet(IID.child(ConformAction.class), IID.child(ExceedAction.class), IID.child(ViolateAction.class)), new GenericListWriter<>(POLICER_IID, new PolicerCustomizer(vppApi, policerContext), new PolicerValidator(policerContext)));
* Copyright (c) 2017 Cisco and/or its affiliates.
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
LOG.debug("Sending InterfaceStatisticsDump request...");
checkNotNull(bridgeDomainContext, "bridgedomaincontext should not be null");
checkNotNull(bridgeDomainContext, "bridgedomaincontext should not be null");
checkNotNull(interfaceDisableContext, "interfaceDisableContext should not be null");
private void validateVxlan(final Vxlan data) {
public String getProjectName() { return mProjectNameResult.getText();
public String getTxtProjectID() { return mTxtProjectID.getText();
public String getTxtProjectPath() { return mTxtProjectPath.getText();
<|del|>
<|del|>
<|del|>
this.controllerOptions = nvmecontroller.getOptions();
<|del|>
@JsonProperty("environment")
@JsonProperty("cubeSpecular") @NonNull
mMatrix = MatrixHelper.createMatrix(data);
<|del|>
<|del|>
@JsonProperty("asset")
<|del|>
@JsonProperty("vertex")
<|del|>
System.loadLibrary("model-exporter-jni");
* @param inputPath - path to the .dae file to process. Required. * @param outputName - the name and path to save the .dli and .bin files to.
<|del|>
// TODO: public static void setRotation(double[] rotation, double[] matrix)
static void createPart(String id) {
<|del|>
<|del|>
<|del|>
* A widget for a property whose value can be presented as a text entry.
<|del|>
<|del|>
lpr.addCommand(GlobalData.get().getTizenPath() + " security-profiles list", new LoggingProcessRunner.Parser() {
* Provides descriptions of a given list of resources.
* Get the top level nodes from an element. This should return the array of resources that the * provider was created with. The nodes are meshes.
<|del|>
public void populate(ITreeContentProvider<Animation> provider, PropertyProviderSelectionChangedListener listener) {
@JsonGetter("indices")
receiver.register("Texture" + index, new Property(this, "TextureArray", Property.Type.String, true, null, new ArrayElementSetter(index), String[].class));
Double number = 0.0;
token.login(password);
<|del|>
<|del|>
<|del|>
connParam.setInitiator_depth((byte) 512); //connParam.setResponder_resources((byte) 512);
<|del|>
<|del|>
} catch (Exception e) { CMS.debug(method + e.toString());
null, // password converter new PasswordConverter(), // encryption public ASN1Value create_EPKI_with_PBE_SHA1_DES3_CBC(CryptoToken token, PrivateKey privateKey, Password password) throws Exception { return create_EPKI_with_PBE_SHA1_DES3_CBC(token, privateKey, password); }
<|del|>
<|del|>
* a worker thread pool, which allows blocking operations inside the future.
* @return A Handler with the Future which contains the post collection action.
<|del|>
private final Map<String, AtomicLong> qualityMap = new ConcurrentHashMap<>(); private final Map<String, AtomicLong> errorMap = new ConcurrentHashMap<>();
public void registerQueueMetrics(AtomicInteger currentQueueSize, int queueSize) {
public void registerTotalMetrics(AsyncResult<CollectorJobResult> postResult) {
<|del|>
return new CollectorJobResult(requestId, "test-source", "test-quality", "test-created", new JsonObject(), error);
<|del|>
if (certs.length == 0) { throw new CertificateException("PKITrustManager: no certs provided");
public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {
if ("rsa".equals(algorithm)) {
else if ("ecc".equals(algorithm)) {
<|del|>
"-l", "" + length, "-c", curve,
content.putSingle("actualProfileId", actualProfileId);
<|del|>
<|del|>
throw new PKIException("Failed to parse profile configuration", e);
Pattern.compile("^" + "plugin-" + PLUGIN_NAME_PATTERN_STRING + "-[a-zA-Z]+$");
PluginPermissionsUtil(
* scoped to. * TODO(b/35714185): Remove all NoteDb refs (refs/changes/*, refs/users/*, edit refs) from the result.
// TODO(b/35190858): implement for plugin defined project permissions.
new Description("Average delay per updated change for a push")
new Description("delay for a single push (which may consist of multiple changes")
Field.ofString("type", "type of push (create/replace, autoclose)"));
metrics.changes.record(ResultChangeIds.Key.AUTOCLOSED, autoclosed.size()); totalChanges += autoclosed.size();
if (testCheckerUpdate.forceInvalidConfig().orElse(true)) {
public abstract Optional<Boolean> forceInvalidConfig();
} @Test public void checkerUuidInvalid() throws Exception { checksApiFactory.revision(patchSetId).id("checker-uuid-invalid").get(); }
ownerId = Optional.ofNullable(accountId);
Field.ofString("type", "type of push (create, replace, autoclose)"));
"Processing delay per push divided by the number of changes in a push.")
private static ProjectAccessInput createAccessInput(String accessSection, String permissionName) {
public void isPluginPermissionNameValid() {
public void isPluginPermissionNameInvalid() { ImmutableList<String> validPluginPermissions =
public void isPluginPermissionInvalidNameReturnFalse() { ImmutableList<String> invalidPluginPermissions =
public void setAccess_addPluginCapability_succeed() throws Exception {
jiraClient.addValueToField(issueKey, value, fieldId); // Do nothing.
input = new CheckInput();
throws RestApiException, IOException, OrmException { if (input == null) { input = new CheckInput(); }
multisiteLog.error(String.format("invalid value for %s; using default value %d", name, defaultValue)); multisiteLog.debug("Failed to retrieve integer value: " + e.getMessage(), e);
errorLog.info("[{}] Setting kafka property: {} = {}", subsectionName, propName, value);
multisiteLog.error(String.format("invalid value for %s; using default value %s", name, defaultValue)); multisiteLog.debug("Failed to retrieve boolean value: " + e.getMessage(), e);
public class Module extends LifecycleModule {
bind(LifecycleListener.class) .annotatedWith(UniqueAnnotations.create()) .to(MultiSiteLogFile.class);
import static com.googlesource.gerrit.plugins.multisite.MultiSiteLogFile.msgLog;
errorLog.debug("Already connected.");
multisiteLog.debug("Invalidated cache {}", entry.getCacheName()); } else { cache.invalidate(entry.getKey());
multisiteLog.debug( "Invalidated cache {}[{}]", entry.getCacheName(), entry.getKey());
multisiteLog.debug("Header[{}] Body[{}]", event.getHeader(), event.getBody());
Copyright (C) 2019 The Android Open Source Project
public static String stripEndSlash(String name) { name = name.replaceAll("/$", ""); name = name.replaceAll("\\/$", "");
private static String strip(String name) {
@Test
@Test
"gerrit create-project --branch master --owner " + newGroupName + " " + newProjectName + ".git");
<|del|>
<|del|>
bind(DfsRefDatabase.class).to(InMemoryDfsRefDatabase.class);
return refName.startsWith("refs/changes/" + refName.get() + "/meta");
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
<|del|>
Copyright (C) 2019 The Android Open Source Project
* attributes of the new check. To create the check in the storage, {@link
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
<|del|>
@Inject
<|del|>
List<Event> createdChangeEvents = receiveFromQueue(droppedEventsQueue, 3); assertThat(createdChangeEvents).hasSize(3);
.containsExactlyElementsIn(ImmutableList.of("refs/meta/changes", change.currentPatchSet().getRefName()));
import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.revwalk.RevWalk.Any;
"Gerrit is still running on ReviewDb and then reload the multi-site plugin.");
<|del|>
Stream.of(checkStates).forEach(listPendingChecks::addState);
Stream.of(checkStates).forEach(listPendingChecks::addState);
import static com.googlesource.gerrit.plugins.its.jira.JiraConfig.ItsFacade; import static com.googlesource.gerrit.plugins.its.jira.JiraConfig.ItsFacadeFactory; import static com.googlesource.gerrit.plugins.its.jira.JiraConfig.ItsFacadeFactory; import static com.googlesource.gerrit.plugins.its.jira.Jira.Its.Its.Its.base.Its
Ordering.natural().sortedCopy(result.errors).forEach(l -> logger.atSevere().log(l));
readFiles.put(includedFileKey(project, file), content);
// TODO: Check if an included file exists and has valid syntax.
Set<String> allFiles; // to detect recursive inclusion quickly
allFiles.add(project + ":" + file); indexLocal.add(file);
allFiles.remove(currentProject() + ":" + currentFile());
return allFiles.contains(project + ":" + file);
String pushType; List<Change.Id> created = resultChangeIds.get(ResultChangeIds.Key.CREATED); List<Change.Id> replaced = resultChangeIds.get(ResultChangeIds.Key.REPLACED); metrics.changes.record(pushType, created.size() + replaced.size());
totalChanges += replaced.size() + created.size();
.containsAllOf(changeNotesRef, patchsetRef); // The events for other refs are skipped.
<|del|>
throw asRestApiException("Cannot retrieve check", e);
static <T extends Enum<T> & ListOption> EnumSet<T> fromBits(Class<T> clazz, int v) { EnumSet<T> r = EnumSet.noneOf(clazz); T[] values;
public boolean get(ChangeNotes notes, @Nullable String claimedOriginal)
return pureRevertCache.isPureRevert(notes.getProjectName(), ObjectId.fromString(currentPatchSet.getRevision().get()), claimedOriginalObjectId);
static final String ID_CACHE = "pure_revert";
* Returns {@code true} if {@code claimedRevert} is a pure (clean) revert of {@code claimedRevert}.
ObjectId.fromString(ps.getRevision().get()));
* @throws IOException if there was a problem with the storage layer
return false;
return cache.isPureRevert(notes); } catch (IOException | BadRequestException e) {
public void testRoundTrip() { ObjectId revertId = ObjectId.zeroId(); ObjectId originalId = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
static String getFileID(String project, String file) {
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
<|del|>
// TODO(kudu-merge): What if this is a Tombstone reference, as defined in cassandra?
// Make sure new refInfo and updateRefInfo are never the same assertThat(newRefInfo).isNotEqualTo(updateRefInfo);
public boolean equals(Object other) { if (other == this) {
"Error trying to perform CAS at path %s", ZkRefInfoMarshaller.pathFor(projectName, newRef));
ZkRefInfoMarshaller marshaller,
private final TestingServer testServer;
listener().toInstance(new ZookeeperStopAtShutdown(zookeeper)); } catch (GuiceBindingFailure e) { throw e; }
static String aProjectName() { return "refs/for/" + RandomStringUtils.random(20, ALLOWED_NAME_CHARS);
ObjectId objectId = anObjectId(); String refName = aChangeRefName();
marshaller.create(new ZkRefInfo(projectName, oldRef, UUID.randomUUID()));
assertThat(inZk.get().projectName()).isEqualTo(projectName); assertThat(inZk.get().refName()).isEqualTo(oldRef.getName()); assertThat(inZk.get().objectId()).isEqualTo(ObjectId.zeroId());
Optional<ObjectId> objectId = readObjectIdAt(rootPath + "/" + OBJECT_ID_PATH);
@Named("ZkLockTimeout") Duration lockTimeout) {
<|del|>
<|del|>
<|del|>
checkerOperations.checker(testCheckerUuid).get().getStatus().isEqualTo(CheckerStatus.ENABLED); assertThat(checkerOperations.checker(testCheckerUuid).get().getBlockingConditions()).containsExactly(BlockingCondition.STATE_NOT_PASSING);
public void disabledCheckerDoesNotBlockSubmit() throws Exception {
public void multipleCheckerBlockingSubmit() throws Exception {
* "owners" found in lines controls changed files in 'dir'.
* For an 'include' statement, parsed data is all appended to the given result parameter.
* The inclusion is skipped if to be included file is already on the including file stack.
// containsExactly does not check order of elements.
PushOneCommit.Result r = createCommitAndPush(testRepo, "refs/for/master", "test message", "A/1/foo.c", "void main()\n");
* referenced in {@link com.google.gerrit.reviewdb.client.Change#getRevertOf()}.
ChangeNotes changeNotes =
private void readProjectConfig() throws Exception { testRepo.git().fetch().setRefSpecs(new RefSpec(REFS_CONFIG + ":" + REFS_CONFIG)).call();
PluginConfig pluginConfig = pluginConfigFactory.getFromProjectConfigWithInheritance(projectState, pluginName);
if (enforce_level == EnforcementLevel.DISABLED) { this.logger.atWarning().withCause(e).log("Cannot find approval for change %s", Config.getChangeId(cd));
OwnersDb db = Cache.getInstance(pluginConfigFactory, repoManager).get(true, projectState, accounts, emails, repoManager, pluginConfigFactory, cd);
if (enforce_level == ENFORCE) { sr.status = OK; return sr;
public void createTestChangeWithoutPermissions() throws Exception {
if (!exists(rootPath)) return Optional.empty();
.setFallbackText("All required checks must pass") .setType("passing_all_required_checks")
.setFallbackText("Checks pass required") .setType("checks_pass")
<|del|>
gApi.changes().id(testChangeId).current().submit(); assertThat(gApi.changes().id(testChangeId).get().status).isEqualTo(ChangeStatus.MERGED);
private static byte[] writeObjectId(ObjectId value) throws IOException {
checkers.checkersOf(resource.getProject()).stream()
<|del|>
new DistributedAtomicValue(client, pathFor(projectName, oldRef), retryPolicy);
new DistributedAtomicValue(client, pathFor(projectName, oldRef), retryPolicy);
private final AllProjectsName allProjects;
allProjects = plugin.getSysInjector().getInstance(AllProjectsName.class);
<|del|>
<|del|>
checkerOperations.checker(checkerUuid).forUpdate().repository(allProjects).update();
assertThat(changeInfo.submittable).isTrue(); assertThat(changeInfo.requirements).isEmpty();
assertThat(changeInfo.submittable).isFalse(); assertThat(changeInfo.requirements).containsExactly(changeInfo.requirements);
static { System.setProperty("gerrit.notedb", "ON");
getPostFilteredPendingChecks(cd.project(), cd.currentPatchSet().getId())
Truth.assertThat(patchSet).that(patchSet.pendingChecks()).isNotNull();
DynamicSet.bind(binder(), ChangeCheckAttributeFactory.class) .annotatedWith(Exports.named("checks"))
@Test public void isRequiredIfNoBlockingCondition() { Checker checker = new Checker().setBlockingConditions(ImmutableSortedSet.of(STATE_NOT_PASSING)).build(); assertThat(checker.isRequired()).containsExactly(STATE_NOT_PASSING); }
.setBlockingConditions(ImmutableSortedSet.of(CheckerState.NOT_PASSING))
return oldState;
if (opts == null || !opts.combined) {
checkKey.project(), refUpdate, currentUser.map(user -> user.state()).orElse(null));
public void updatingCheckStateUpdatesCache() throws Exception {
* can also implement a way to clear per user sessions.
/** * Return the current account id for this query. */
<|del|>
zookeeperContainer.createRefInZk(A_TEST_PROJECT_NAME, ref); assertThat(zkContainer.readRefValueFromZk(A_TEST_PROJECT_NAME, ref)).isEqualTo(ref.getObjectId());
assertThat(e).hasMessageThat().contains(expectedMessage); assertThat(e).hasMessageThat().ignoringCase().contains(expectedMessageParts);
int actualType = actual().getType(); check("getType()").that(actualType).named("expected %s, actual %s", typeName(expectedType), typeName(actualType)) .isEqualTo(expectedType);
public static Check newBackfilledCheck(Project.NameKey cd, PatchSet ps) { return new Check.Builder(CheckKey.create(cd.project(), ps.getId()), checker.getUuid()))
checker.queryMatchingChanges(retryHelper, queryBuilderProvider.get(), changeQueryProvider);
CheckState.tryParse(value) .orElse(() -> ChangeStatusPredicate.this.parse(value))
this.checkerUuid = requireNonNull(checkerUuid);
&& resturi.matcher(((HttpServletRequest) req).getServletPath()).matches();
check("trimmedMessages()").that(got).containsAllIn(expectedLines).inOrder();
assertThat(checkersByRepositoryNotes.get(project)).containsExactly(checkerUuid); assertThat(checkersByRepositoryNotes.get(project).commit didn't change)
assertThat(checkersByRepositoryNotes.get(project2)).isEmpty(); assertThat(checkersByRepositoryNotes.get(project1)).containsExactly(checkerUuid2);
public void updateCheckersByRepositoryNotes() throws Exception {
log.atWarning().withCause(e).log("Cannot check project access permission");
private final Filter errorHandler;
public class RequestFailureException extends RestApiException {
GitRepositoryManager gitRepositoryManager, MultiSiteRepository.Factory multiSiteRepoFactory) {
bind(binder(), GitRepositoryManager.class) .to(MultiSiteGitRepositoryManager.class); bind(binder(), SharedRefDatabase.class) .to(ZkSharedRefDatabase.class);
DynamicSet.bind(binder(), GitRepositoryManager.class) .to(MultiSiteGitRepositoryManager.class); DynamicSet.bind(binder(), SharedRefDatabase.class) .to(ZkSharedRefDatabase.class);
doReturn(true).when(sharedRefDb).compareAndPut(A_TEST_PROJECT_NAME, oldRef, newRef);
@Assisted Repository repository) {
return multiSiteRefDbFactory.create(projectName, repository.getRefDatabase());
private boolean quiet = false;
<|del|>
return multiSiteRepoFactory.create(name.get(), gitRepositoryManager.openRepository(name.get()));
return multiSiteRepoFactory.create(name.get(), gitRepositoryManager.createRepository(name.get()));
<|del|>
<|del|>
this(new FileBasedConfig(sitePaths.etc_dir.resolve(PLUGIN_NAME + ".config").toFile(), FS.DETECTED));
@Singleton protected void configure() {
"Cannot get rate limits for anonymous access from remote host ''{}''", req.getRemoteHost(), e);
logger.error("Failed to post heartbeat event: {}", e.getMessage(), e);
"%d %ss reindexed in %d msec (%d/sec), %d failed",
log.atWarning().log( "Change %s seems too old compared to the event timestamp (event-Ts=%s >> change-Ts=%s)", id, indexEvent, checker); rescheduleIndex(id, indexEvent, retryCount + 1);
log.atSevere().log("Failed to process eviction request: {}", e.getMessage());
"Failed to %s %s on %d [%d/%d]", action, key, destination, execCnt, maxTries);
log.atSevere().withCause(ie).log(
+ " Only two members are supported. Members: {}",
log.atFine().log("Channel bound to %s", address.get());
ImmutableList.of("refs/draft-comments/.*", "refs/changes/.*/[0-9][0-9]+");
private final Pattern servletPath =
if (!self.get().isIdentifiedUser()) {
ImmutableList<String> refsToIgnoreInSharedDb = ImmutableList.of("refs/draft-comments/.*", "refs/changes/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+");
return (ref.getName().startsWith("refs/draft-comments") && !ref.getName().endsWith("/meta"));
<|del|>
<|del|>
return (refName == null) || (refName.startsWith("refs/draft-comments")
new DistributedAtomicValue(client, pathFor(projectName, oldRef), retryPolicy); return ignoreRefInSharedDb(oldRef) || compareAndPut(project, oldRef, NULL_REF);
assertThat(zookeeperContainer.readRefValueFromZk(A_TEST_PROJECT_NAME, ref).getName()).isEqualTo(ref.getObjectId().getName()); assertThat(zookeeperContainer.readRefValueFromZk(A_TEST_PROJECT_NAME, ref).getName()).isEqualTo(ref.getObjectId().getName());
DispatchCommand(PermissionBackend permissionBackend, @Assisted Map<String, CommandProvider> all, DynamicSet<SshCommandPreExecutionFilter> commandFilters) {
// If we are using this identity, don't report the exception. throw new IllegalArgumentException( "Username " + username + " already in use");
private final List<Destination> allDestinations;
<|del|>
String notExistingCheckerUuid = CheckerTestData.INVALID_UUID;
RevWalk rw = new RevWalk(repo)) {
Ref nullRef = SharedRefDatabase.NULL_REF;
assertThat(zkSharedRefDatabase.compareAndPut(A_TEST_PROJECT_NAME, existingRef, nullRef))
private List<ChangeData> executeIndexQueryWithRetry(RetryHelper retryHelper, Provider<ChangeQueryProcessor> changeQueryProcessorProvider, Predicate<ChangeData> predicate)
return executeIndexQueryWithRetry(retryHelper, changeQueryProcessorProvider, createQueryPredicate(checker));
// Verify that CheckerTestData#longQueryWithSupportedOperators(int) produces a query with n terms assertInvalidQuery(CheckerTestData.INVALID_QUERY, "invalid", CheckerTestData.INVALID_QUERY);
Future<?> future = executor.submit(evaluationTask);
private void addTaskListener(Future<?> future, EvaluationTask evaluationTask) { ListenableFuture listenableFuture = JdkFutureAdapters.listenInPoolThread(future);
private void addTaskListener(ListenableFuture<?> future, EvaluationTask evaluationTask) { ListenableFuture listenableFuture = JdkFutureAdapters.listenInPoolThread(future);
<|del|>
when(executor.submit(taskSamePathNotCompleted)).thenReturn(new CompletableFuture<>());
/** Name of the access section. */
/** Name of the access section. It could be a ref pattern or else. */
this.permissions = Collections.EMPTY_LIST;
Copyright (C) 2019 The Android Open Source Project
com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(
// Create normalUserGroup, containing current user, and contextUserGroup, containing contextUser
// Create normalUserGroup, containing current user, and contextUserGroup, containing contextUser
Map<String, CommandProvider> all, DynamicSet<SshExecuteCommandInterceptor> commandInterceptors) {
String.format("blocked by %s, contact gerrit administrators for more details", commandInterceptor.name()));
* @return whether or not this command with these arguments can be executed
for (SshCommandInterceptor filter : commandFilters) { if (!filter.accept(actualCommandName, args)) { throw new UnloggedFailure(126, "blocked by " + filter.name()); }
* @return whether or not this command with this arguments can be executed
<|del|>
public static class FlatFileWebSessionCleaner { public static String toString() { return "FlatFile WebSession Cleaner"; }
indexer.index(project, changeId); } catch (Exception e) { throw new OrmException(String.format( "Unstar change %d failed", changeId.get()), e);
try { for (ChangeDraftUpdate update : allUsersRepo.cmds) { if (update.getRefLogMessage() != null) { bru.setRefLogMessage(refLogMessage, false); } }
final AllUsersName allUsers; final AllProjectsName allProjects;
<|del|>
// Don't email if an administrator added a key on behalf of the user.
deleteKeyFactory.create(user, "SSH").send();
"Cannot send SSH key deletion message to {}", user.getAccount().getPreferredEmail(), e);
private static final FluentLogger logger = FluentLogger.forEnclosingClass();
private void updateRefDb(
logger.atWarning().withCause(e).log( "Failed to apply full batch %s", e.getMessage());
cmd.getOldRef() == null ? sharedRefDb.NULL_REF : sharedRefDb.newRef(cmd.getRefName(), cmd.getOldRef()),
// Doesn't have to be the actual Path we lock but just a unique identifier of the ref.
boolean isInSync;
throw new HyracksDataException(errorMessage);
String errorMessage = String.format("Failing batch executeWrapper in MultiSiteBatchRefUpdate with exception %s", e.getMessage()); logger.atWarning().withCause(errorMessage);
"Unable to update ref '%s', trying to create a new ref but there is a value "
}
if (newRef == NULL_REF) {
<|del|>
<|del|>
new ZkSharedRefDatabase(zookeeperContainer.getCurator(), new RetryNTimes(5, 30));
// Don't email if an administrator removed a key on behalf of the user.
"Cannot send HttpPassword added or changed message to {}", user.getAccount().getPreferredEmail(), e);
/** ObjectId of commit */
// directly, and instead use the public getter/setter that wraps an ObjectId.
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
return abbreviateName(id, ABBREVIATED_STRING_LENGTH);
* @param n number of hex chars. * <p> * @param reader object reader for determining uniqueness.
* chars. * @throws IOException if the object could not be abbreviated
* @param n minimum number of hex chars in the valid range.
* {@code n} chars. * @throws IOException thrown if the object reader could not be abbreviated.
return "implicit merge of " + abbreviateName(commit, 7);
// Recipe for creating ambiguous IDs courtesy of t1512-rev-parse-disambiguation.sh in git core. // See https://code.google.com/p/android/issues/detail?id=1512
return "implicit merge of " + abbreviateName(commit, DEFAULT_CHAR_LIMIT);
private static final String KEY_DIRECTORY = "directory";
Path ensured = Files.createDirectories(Paths.get(dataDir.toString()));
/** Returns the name of the REST API handler */
firstNonNull(NoteDbUtil.guessRestApiHandler(), "Update NoteDb refs");
public void markCommentPublished(Comment c) {
boolean publishOnly = draftUpdates.values().stream().anyMatch(ChangeDraftUpdate::isPublishOnly);
<|del|>
<|del|>
public List<TopMenu.MenuEntry> topMenus() throws RestApiException {
protected void doIndex(String id, Optional<ChangeIndexEvent> indexEvent) throws StorageException {
colsProto.toBuilder() .setTopic("topic")
logger.atWarning().log(
@Nullable ProjectState projectState,
static final String NAME = "combined_check_state";
Field.ofBoolean("withUpdate", "whether reloading resulted in updating the cached value"));
void recordReload(boolean dirty, Duration elapsed, TimeUnit timeUnit) { reloadLatency.record(dirty, elapsed, timeUnit); reloadCount.incrementAndGet(dirty);
metrics.recordReload(dirty, sw.elapsed(NANOSECONDS), NANOSECONDS);
checkOperations.newCheck(CheckKey.create(project, psId, checkerUuid)) .state(CheckState.FAILED) .upsert();
expect(cd.project()).andReturn(new Project.NameKey("My-Project")); expect(cd.getId()).andReturn(new Change.Id(1)); expect(cd.currentPatchSet()).andThrow(new OrmException("Fail for test"));
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
private Change newChange(String changeKey, String changeId) {
event.submitter = createSupplier(new AccountAttribute());
* @param stateCount count of
* @return the {@link CheckStateCount} of the given state map.
for (Map.Entry<CheckState, Boolean> optional : statesAndRequired.entries()) { CheckState state = optional.getKey();
// Gets all required checks results of the given change. ImmutableMap<String, CheckInfo> allRequiredChecks;
default boolean doesRefNeedClusterSynchronisation(String refName) {
PRODUCTION, ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector, LibModuleType.DB_MODULE)));
/** Loadable module type for the different Gerrit server injectors. */
* Returns the module type for libModule loaded from <gerrit_site/lib> directory.
protected void doIndex(Account.Id id, Optional<IndexEvent> indexEvent) throws IOException {
private static final double CHANGE_NUM_DOUBLE = CHANGE_NUM;
private static final String ALL = ".*";
projectAndRefsEnforcements.put(projectName, existingOrDefaultRef); } catch (AssertionError expected) { throw expected;
PREDEF_ENFORCEMENTS.get(projectName).get(refName) == null ? PREDEF_ENFORCEMENTS.get(projectName).get(ALL) : PREDEF_ENFORCEMENTS.get(projectName).get(refName);
Optional.ofNullable(PREDEF_ENFORCEMENTS.get(projectName).get(refName) == null ? PREDEF_ENFORCEMENTS.get(projectName).get(refName) : PREDEF_ENFORCEMENTS.get(projectName).get(refName));
boolean isUpToDate(String project, Ref ref) throws IOException;
AutoCloseable lockRef(String projectName, Ref ref) throws IOException;
AutoCloseable lockRef(String projectName, Ref ref) throws IOException;
<|del|>
return readObjectId(valueInZk, ref.getObjectId());
@Override public void lockRef(String projectName, Ref ref) throws IOException {
throw new IOException("Failed to create lock in ZK", e);
MultiSiteBatchRefUpdate create(String project, RefDatabase refDb);
batchRefUpdate, () -> batchRefUpdate.execute(walk, monitor, options));
batchRefUpdate, () -> batchRefUpdate.execute(walk, monitor));
@Assisted RefDatabase refDb) {
<|del|>
return delegateValidation.apply(batchRefUpdate, gitUpdateFun); }
<|del|>
} logger.atInfo().withCause(failedRef.exception).log("Failed to fetch ref entries");
protected RefPair newRefPairFrom(RefUpdate refUpdate, String newRef) { return new RefPair(refUpdate.getRef(), sharedRefDb.newRef(refUpdate.getName(), newRef));
protected RefPair newRefPairFrom(RefUpdate refUpdate) { return new RefPair(refUpdate.getRef(), sharedRefDb.newRef(refUpdate.getName(), refUpdate.getNewObjectId()));
@Assisted RefDatabase refDb) {
@Assisted RefDatabase refDb) {
private void executeBatchUpdateWithPolicy(String errorMessage, BatchValidationWrapper delegateValidation, BatchRefUpdate batchRefUpdate, NoParameterVoidFunction gitUpdateFun)
protected void executeBatchUpdateWithPolicy(String errorMessage, BatchValidationWrapper delegateValidation, BatchRefUpdate batchRefUpdate, NoParameterVoidFunction gitUpdateFun)
if (refPair.oldRef != null) { isInSync = sharedRefDb.isUpToDate(projectName, refPair.oldRef);
@RunWith(MockitoJUnitRunner.class) @Mock
return result;
assertThrows(errType, () -> branch(branch).create(in));
ReviewInput review = new ReviewInput(); review.label(P.getName(), P.getMax().getValue()); revision(r).review(review);
data.put("staticResourcePath", sanitizedStaticPath); data.put("cdnPath", cdnPath);
Map<String, Object> data = new HashMap<>();
<|del|>
PatchSet.Builder builder = PatchSet.builder().id(patchSetIdConverter.fromProto(proto.getId()));
public void getBranchReturnsCorrectBranchForVersion() throws Exception {
* delegate.doFilter(req, res, chain);
INCORRECT_OBJECT_TYPE(SC_BAD_REQUEST),
import java.io.IOException; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Set;
.toInstance(new CustomSharedRefEnforcementByProject(cfg.getZookeeperConfig().getEnforcementRules()));
Strings.isNullOrEmpty(accountState.getUserName().isPresent())
<|del|>
<|del|>
// TODO: Why doesn't it work when populating the cache?
if (args.getSchema().hasField(ChangeField.EXTENSION)) {
public MissingMandatoryPluginsException(Collection<String> pluginNames) {
private MissingMandatoryPluginsException(Set<String> pluginNames) {
throw new ProvisionException(String.format("Failed to load mandatory plugins: %s", missingMandatory));
<|del|>
return getIndexType(injector.getInstance(Key.get(Config.class, GerritServerConfig.class)));
return cfg == null ? null : cfg.getEnum("index", null, "type", IndexType.LUCENE);
protected ChangeQueryBuilder(Arguments args) {
if (ext.isEmpty() && indexType == IndexType.ELASTICSEARCH.name()) { return new FileWithNoExtensionPredicate();
abandonIfMergeable = cfg.getBoolean(SECTION, null, KEY_ABANDON_IF_MERGEABLE, false);
ProjectState cachedProjectState2 = projectCache.checkedGet(key); assertThat(cachedProjectState2).isSameInstanceAs(cachedProjectState1); assertThat(cachedProjectState2.getProject().getDescription()).isEmpty();
return check("getSections()).that(config.getSections()).isNotNull();
* A marker to say a method/type/field is added or it's visibility is increased to public solely because it is called from inside a * project or an organisation using Gerrit.
boolean requestRunway(PushOne op) {
DeleteKeySender.Factory deleteKeySenderFactory) {
private final AddKeySender.Factory senderFactory;
deleteKeyFactory .create(user, toRemove.stream().map(Fingerprint::toString).collect(toList()))
private final DeleteKeySender.Factory deleteKeySenderFactory;
DeleteKeySender create(IdentifiedUser user, List<String> gpgKeys);
DeleteKeySender create(IdentifiedUser user, List<String> gpgKeys);
this.gpgKeys = Collections.emptyList();
@Assisted List<String> gpgKeys) {
this.gpgKeys = checkNotNull(gpgKeys);
if (gpgKeys != null) { return "GPG"; } throw new InvalidCredentialsException();
public String getGpgKeysFingePrints() { if (gpgKeys != null) { return Joiner.on("\n").join(gpgKeys);
* Records a permission to be updated.
/** Sets the name of the permission. */ public abstract Builder name(String name);
allow(allUsers, RefNames.REFS_USERS + "*", Permission.CREATE, REGISTERED_USERS); allow(allUsers, RefNames.REFS_USERS + "*", Permission.PUSH, REGISTERED_USERS);
<|del|>
<|del|>
<|del|>
@Test public void testGetIndexThreadPoolSize() throws Exception { assertThat(getConfiguration().index().threadPoolSize()).isEqualTo(THREAD_POOL_SIZE); globalPluginConfig.setInt(INDEX_SECTION, null, THREAD_POOL_SIZE_KEY, THREAD_POOL_SIZE); assertThat(getConfiguration().index().threadPoolSize()).isEqualTo(THREAD_POOL_SIZE); }
Map<String, List<Event>> eventsByType = receiveEventsByType(droppedEventsQueue, sharedDirConfig);
<|del|>
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
/** Starts a builder for allowing a permission. */
* quota issues so that the user gets throttled. This implies there are no * guarantees on the first line of defence (e.g. always deduct HTTP quota even if the request failed for other * quota checks).
import java.util.logging.Logger; import org.eclipse.jgit.transport.ReceiveCommand.Type;
LOG.info(String.format("Migrated %d users to schema 146", i));
<|del|>
// Pop up to the top-level source folder by looking for .buckconfig.
protected String getDeleteActions(Id c) { return delete(OPEN_CHANGES, c) + delete(CLOSED_CHANGES, c);
private final boolean omitTypeFromSearch; private final String prefix;
private boolean isVersion(int v) { return Integer.valueOf(version.split("\\.")[0]) >= v;
<|del|>
<|del|>
.containsEntry("abandon", "group global:Registered-Users"); assertThat(projectOperations.project(key).getConfig()).containsEntry("access", "refs/foo") .containsKey("abandon");
expected ? "should notify" : "shouldn't notify", type + ": " + users.emailToName(email)));
+ "If you are sure you wish to delete this project, re-run with the --yes-really-delete flag.\n\n",
<|del|>
projectOperations.project(allUsers).getHead(RefNames.refsUsers(accountId));
<|del|>
AccountIT.projectOperations
.add(allowCapability(GlobalCapability.ACCESS_DATABASE) .group(REGISTERED_USERS))
ProjectConfig newLocal = projectConfigFactory.create(localKey);
.add(block(PUSH).ref("refs/heads/*").group(ANONYMOUS_USERS)) .add(allow(PUSH).ref("refs/heads/master").group(DEVS))
.setExclusiveGroup(excludingGroup(PUSH).ref("refs/heads/master"), true)
* <p>If the execution is synchronous or the results are know a-priori, consider using {@link
resultsCallback = requireNonNull(r);
results = ImmutableList.copyOf(requireNonNull(r));
() -> allowCapability(ADMINISTRATE_SERVER).group(REGISTERED_USERS).range(1, 0).build()); assertCapabilitySupportsRange(ADMINISTRATE_SERVER).group(REGISTERED_USERS).build());
class GsonParser { private final Gson gson;
public static abstract class Result { static Result create(boolean isValid, List<CommitValidationMessage> messages) {
static Result create(boolean isValid, ImmutableList<CommitValidationMessage> messages) {
abstract ImmutableList<CommitValidationMessage> messages();
<|del|>
throw new MethodNotAllowedException("checks are not supported on an edit");
Set<Entry<Account.Id, Timestamp>> accounts = scanAccounts(db, ui).entrySet();
* default visibility checker should cover all common use cases.
/** * @param topoSort whether to use a more thorough reachability check * by sorting in topological order */
public void setUp() throws Exception {
// TODO: This behavior is likely a bug. A fix might not be easy as it might break syntax highlighting.
GsonParser(GsonProvider gson) { this.gson = gson;
<|del|>
private final String pluginName; // Refer to https://github.com/cloudera/googlesource/blob/e9fb111182b55cc82c530d82f13176c7a85cd958/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/org/jira/browse/j
* the same pattern signature, this method returns a single valid find with the number of
private final Config cfg;
<|del|>
pluginName, event.getChange().currentRevision, entry.getKey(), arr.error);
? (RestApiException) e : new RestApiException("Cannot review", e);
<|del|>
/** Configuration state for {@link CopyrightValidator}. */
public boolean isAtLeastVersion(String v) { return isAtLeastVersion(version.getMajor() && getMinor() >= version.getMinor());
ImmutableList<PerformanceLogRecord> oldPerformanceLogRecords = loggingCtx.getPerformanceLogEntries(); if (oldPerformanceLogRecords != null) { loggingCtx.setPerformanceLogEntries(oldPerformanceLogRecords); }
LoggingContext.getInstance().setPerformanceLogEntries(oldPerformanceLogEntries); // Restore old state. runEach(performanceLoggers, LoggingContext.getInstance().getPerformanceLogEntries());
"refs/tags/master-tag"); assertUploadPackRefs("HEAD", psRef1, metaRef1, psRef3, metaRef3, "refs/heads/branch", "refs/heads/master", "refs/tags/branch-tag");
"HEAD", psRef1, metaRef1, psRef3, metaRef3, "refs/heads/master", "refs/tags/master-tag");
import com.google.gerrit.testutil.ConfigSuite; import com.google.gerrit.testutil.PluginNamePrefix;
throws BadRequestException, OrmException, IOException,
+ concat(ownerJson("pA@g", 0, 1, 0), " ]");
logger.warn("Unable to process event {} on project {}", event, event.getProjectName(), e);
handleGitReferenceUpdatedAsUser(event, updaterAccountInfo);
loggingCtx.setMutablePerformanceLogRecordList(mutablePerformanceLogRecords); loggingCtx.setPerformanceLogRecords(mutablePerformanceLogRecords);
CopyrightReviewApi reviewApi) throws IOException, ConfigInvalidException {
<|del|>
logger.atSevere().log("\n\nonGitRefUpdated: '%s'\n\n", checkConfig);
logger.atSevere().log("\n\nonGitRefUpdated: '%s'\n\n", checkConfig);
logger.atSevere().log("\n\nonGitRefUpdated: '%s'\n\n", checkConfig);
// The draft was deleted despite drafts is ignored on publishing a comment.
return assertAbout(optionals()).that(optional, StandardSubjectBuilder::that);
return that(optional, (builder, value) -> builder.that(value));
private PluginConfig gerritConfig; private CheckConfig checkConfig; private final RevisionCreatedListener revisionCreatedListener;
throw new CommitValidationException("failed to read new project.config", e);
*/ @Nullable
// throw IllegalStateException? RestApiException?
try (TreeWalk tw = TreeWalk.forPath(repo, filename, tree)) {
try (TreeWalk tw = TreeWalk.forPath(repo, filename, null)) {
<|del|>
<|del|>
public static final String ZOOKEEPER_MS_CONFIG = "multi-site.config";
public ZkValidationModule(MultiSiteConfig multiSiteConfig) { this.multiSiteConfig = multiSiteConfig;
private final FileBasedConfig multiSiteConfig; private final FileBasedConfig sharedRefConfig;
@Inject private Provider<ChangesCollection> changes; @Inject private Provider<PostReview> postReview; @Inject private RequestScopeOperations requestScopeOperations;
@Inject private Provider<ChangesCollection> changes; @Inject private Provider<PostReview> postReview; @Inject private RequestScopeOperations requestScopeOperations;
bind(CommentValidationListener.class) .annotatedWith(Exports.named("TestCommentValidationListener")) .to(TestCommentValidationListener.class) .asEagerSingleton();
String changeId = r.getChangeId(); String revId = r.getCommit().getName();
log.warn(
<|del|>
<|del|>
public static List<CommentValidationFailure> findInvalidComments(
throws OrmException, IOException { List<Comment> newComments = new ArrayList<>();
/** * Iterates over the elements of this sequence, up to the given limit. */
<|del|>
<|del|>
multisiteLog.warn(
/** * Constructor *
assertThat(testCommentUtil.getPublishedComments(r.getChangeId())).isEmpty(); BadRequestException restApiException =
switch (getSQLStateInt(err)) { case 1:
<|del|>
cfg.get() .getBoolean(KAFKA_SECTION, KAFKA_PUBLISHER_SUBSECTION, ENABLE_KEY, DEFAULT_BROKER_ENABLED);
public static final String KAFKA_CONFIG = "config"; public static final String KAFKA_PROPERTY_PREFIX = "KafkaProp-";
queuedIndexTasks.remove(this);
<|del|>
queuedIndexTasks.remove(this);
<|del|>
<|del|>
public static final String KAFKA_CONFIG = KAFKA_CONFIG_DEFAULT;
private KafkaProperties properties;
<|del|>
<|del|>
<|del|>
patterns = getList(cfg, CACHE_SECTION, null, PATTERN_KEY, DEFAULT_PATTERN_KEY);
<|del|>
<|del|>
.update(); // First 3 changes are merged, which means the tags pointing to them are visible. projectOperations .project(project).forUpdate().add(allow(Permission.SUBMIT).ref("refs/for/refs/heads/*").group(admins)) .update();
* <p>TODO(hiesel): Instrument this heuristic and proof its value.
*/ @VisibleForTesting
/** Returns a URL pointing to a section of the settings page. */
producer = new KafkaProducer<>(properties.kafkaPublisher());
producer = producerProvider.get(); producer.start();
/**Skip unnecessary insertions and deletions. */ SKIP_INSERT_DELETE(24);
if (!has(SKIP_INSERT_DELETE)) {
return new PermissionRange(permissionName, min, max);
<|del|>
/** * @return the builder with the name and description of this type */
@Memoized public static <T> Function<T, String> formatter() { return (s) -> initFormatter(valueType()); }
logger.atWarning().log(
public Context start() { return new Context(this);
return new AutoValue_Field.Builder<E>() .valueType(enumType) .formatter(fieldValue -> enumValue.name()).name(name);
Field.ofInteger( "status", (metadataBuilder, fieldValue) -> metadataBuilder.httpStatus(fieldValue))
public static Field.Builder<Boolean> ofBoolean(String name) {
/** * @return description text for the field explaining its range of values. */
Field.ofEnum(Operation.class, "operation", (metadataBuilder, fieldValue) -> metadataBuilder.gitOperation(fieldValue.name())) .build();
// The type of change ID (e.g. numeric ID, triplet etc.).
// The name under which a plugin extension was registered. public abstract Optional<String> pluginName();
// An LDAP domain name. public abstract Optional<String> authenticationDomainName();
public abstract Builder branch(@Nullable String branch);
* <p>Meta data is stored in separate key/value fields to avoid expensive instantiation of Map * objects.
@Nullable public abstract Metadata metadata();
succeeded = sharedRefDb.compareAndPut(projectName, refPair.putValue);
return new RefPair(p.compareRef, getCurrentRef().getObjectId());
* <li>{@code SKIP_DIFFSTAT} is omitted to skip diffstat calculations.
private List<RefPair> getRefPairsToUpdate(
protected RefPair updateRefPair(
<|del|>
.render(AdvisingAppendable.class).get());
return RefNames.isGerritRef(refName) || RefNames.isNoteDbMetaRef(refName);
return RefNames.isGerritRef(refName);
sharedRefDb.isUpToDate(projectName, localRef);
logger.atWarning().withCause(err).log("REST call failed: %d", statusCode);
if (changeData.isEmpty()) {
* Type of the request, telling through which channel the request was coming in (REST, Git * receive, git upload, SSH).
<|del|>
private boolean isOwner(Project.NameKey project) {
* <li>{@code SKIP_DIFFSTAT} is omitted to skip diffstat calculations. If the SKIP_DIFFSTAT option is omitted, the diffstat calculations are not skipped.
/** Skip diffstat computation (total number of inserted/deleted lines of the latest patch set). */
* @param accounts may be either just a list of: account IDs, Full names, or usernames.
* @param accounts may be either just a list of: account IDs, Full names, or usernames. * Also could be list of those: "Full name <email@example.com>" or "Full name (<ID>)"
.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "initial content\n", changeId)
.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "initial content\n", changeId)
DynamicItem.itemOf(binder(), EventBroker.class);
} catch (KafkaException e) { LOGGER.log(Level.WARNING, e.getMessage(), e);
subscriberMetrics.incrementSubscriberFailedToConsumeMessage(); } catch (OrmException e) { logger.atSevere().withCause(e).log( "Cannot handle message %s: [Exception: %s]", event.getHeader().getEventType(), e); subscriberMetrics.incrementSubscriberFailedToProcessMessage();
remoteUpdatesList = pushFilter == null ? remoteUpdateList : pushFilter.filter(projectName.get(), remoteUpdatesList);
DynamicItem.itemOf(binder(), BeforeReplicationFilter.class); DynamicItem.bind(binder(), BeforeReplicationFilter.class) .to(BeforeReplicationFilterNoOp.class);
assertThat(autoReloadConfig.getDestinations(FilterType.ALL)).isNotEmpty(); assertThat(autoReloadConfig.getDestinations(FilterType.ALL).size()).isEqualTo(1);
Copyright (C) 2019 The Android Open Source Project
public static boolean isActive() {
repository, path, parseCommit(repository, repository.resolve(revision)).getTree())) {
public class QuotaGroupDefinitions { /** * Resource name for the quota group. * * @return String * @author Matthew Khouzam */
<|del|>
Matcher m = Pattern.compile("\r\n|\r|\n").matcher(content);
this.retryWithTraceOnFailure = cfg.getBoolean("retry", "retryWithTraceOnFailure", false);
* <p>Metadata to provide additional context can be included by providing a {@link Metadata}
Field.ofEnum(ActionType.class, "action_type", (metadataBuilder, fieldValue) -> metadataBuilder.actionType(fieldValue.name()).build();
changeIndexedListener = new TraceChangeIndexedListener(); changeIndexedListenerRegistrationHandle = changeIndexedListeners.add("gerrit", changeIndexedListener);
* <p>If a user specifies an unknown option and this unknown option doesn't get accepted, the
boolean accept(@Nullable String name, @Nullable String value);
// This field is only used for staleness detection which will discover the
// Therefore, defer to the currently configured All-Users name.
<|del|>
public String persist(String project, String ref, URIish uri) { String json = getEventJson(project, ref, uri);
public void delete(String project, String ref, URIish uri) { String eventKey = getEventKey(getEventJson(project, ref, uri));
logger.atWarning().withCause(e).log( "Account %s has invalid filter in project watch %s: %s", accountId, key, e.getMessage());
@VisibleForTesting
PushOneCommit.Result r1 = push("refs/for/master", PushOneCommit.SUBJECT, "one.txt", "One"); PushOneCommit.Result r2 = push("refs/for/master", PushOneCommit.SUBJECT, "two.txt", "Two");
<|del|>
* Filter that is invoked before list of remote ref updates is pushed to remote instance. It can be * used to filter out unwanted updates.
<|del|>
private Renderer renderer(String templateName) {
private static final String LOG_NAME = "sharedrefDB_log"; private static final Logger sharedRefDBLog;
public void logRefUpdate(String project, Ref currRef, ObjectId newRefValue) {
public void logProjectDelete(String project) {
<|del|>
succeeded = sharedRefDb.compareAndPut(projectName, refPair.compareRef, refPair.putValue);
if (lowerCase) {
repLog.info("Replication {} was canceled", getURI());
repLog.info( "Replication {} was canceled while being executed", getURI());
try (Repository repo = gitRepositoryManager.openRepository(new Project.NameKey(project)); RevWalk walk = new RevWalk(repo)) { if (!ObjectId.zeroId().equals(newRefValue)) {
type = Type.DELETE_PROJECT;
ConfigUtil.getTimeUnit(config, "gerrit", null, "sshConnectionTimeout", 2, SECONDS));
throw new ConfigInvalidException(
&& !requestTypes().stream().anyMatch(type -> type.equalsIgnoreCase(requestInfo.requestType()))) {
/** Reruns the check and returns the {@link CheckInfo} for the updated check. Input ignores "state". */ CheckInfo rerun(CheckInput input) throws RestApiException;
/** * reruns the check and returns the CheckInfo for the updated check. Input ignores "state". */ CheckInfo rerun(CheckInput input) throws RestApiException;
@Override public CheckInfo apply(CheckResource checkResource, CheckInput input) throws RestApiException, IOException, PermissionBackendException, ConfigInvalidException {
<|del|>
TestTimeUtil.resetWithClockStep(1, TimeUnit.SECONDS); TestTimeUtil.setClock(Timestamp.from(Instant.EPOCH));
checkerOperations.newCheck(checkKey).upsert();
public void rerunCheck() throws Exception {
CheckInfo info = checksApiFactory.revision(patchSetId).id(checkKey.checkerUuid()).rerun(input);
throws RestApiException, PermissionBackendException {
<|del|>
/** Description of the checker that produced this check. */ public String description;
<|del|>
// - 32px for avatars on next to names e.g. on the dashboard.
Copyright (C) 2019 The Android Open Source Project
Copyright (C) 2019 The Android Open Source Project
private GitRepositoryManager gitRepositoryManagerMock; private Repository repositoryMock; private PermissionBackend permissionBackendMock; private PermissionBackend.WithUser withUserMock; private PermissionBackend.ForProject forProjectMock;
while (!isCallFinished.get()) {
private void setupGitRepoManagerMock() throws Exception {
<|del|>
public String refName; public String oldId; public String newId;
public String refName; public String oldId; public String comment;
private final PostCheck postCheck; private final ChecksRestApiBindingsIT checksRestApiBindingsIT;
/** Loads cache values for the external ID cache using either a full or a partial reload. */ @Singleton
// is found within this number of parents,, we fall back to reading everything from scratch.
config.getBoolean("cache", ExternalIdCacheImpl.CACHE_NAME, "enablePartialReloads", false);
private String existingProjectName; // @Option(name = "--new-name", aliases = {"-r"}, metaVar = "NEWNAME", usage = "new name for the project") private String newProjectName;
* @param started - set the time the check started. Time can be reset to "null" if passed but not * {@code null}.
// is found within this number of parents, we fall back to reading everything from scratch. // TODO(kudu-merge): Maximum number of changes we inspect to find a base for differential.
RevWalk rw = new RevWalk(repo); RevCommit currentCommit = rw.parseCommit(extId.getObjectId());
for (RevCommit commit : rw.next()) { if (commit.getParentCount() != MAX_HISTORY_LOOKBACK) { return reloadAllExternalIdsAndCachePersistently(notesRev); }
reloadDifferential.start(System.nanoTime() - start, TimeUnit.NANOSECONDS); return new AutoValue_AllExternalIds(byAccount.build(), byEmail.build());
return ObjectId.fromString(path.lastIndexOf('/') > 0 ? path.substring(lastSlash + 1) : path);
externalIdCache.getIfPresent(notesRev, allExternalIds);
// Boolean: partial or full
sshdThreads = cfg.getInt("sshd", "threads", Math.min(4, 3 * cores));
public void insert(Account account) throws IOException, ConfigInvalidException {
allUsersName.get() + ":" + RefNames.refsUsers(Account.id(1)).get() + ":" + metaId;
private final Provider<ProjectCache> projectCache;
&& Objects.equals(other.description, description);
* @param started - set the time the check started. Time can be reset to "null" if passed * new Timestamp(0).
* @param started - set the time the check started. Time can be reset to "null" if passed a * {@code new Timestamp(0)}
* @param started Set the time the check started. Time can be reset to "null" if passed * {@code new Timestamp(0)}
Account account = accounts.insert(Account.builder(id, TimeUtil.nowTs()).setFullName(name).setPreferredEmail(email));
if (requireChangeId) {
/** * Reruns the check and returns the {@link CheckInfo} for the updated check. Input ignores * "state". */
@Override
<|del|>
checkOperations.newCheck(checkKey).upsert(); assertThat(checkerOperations.get(checkKey).state()).isEqualTo(CheckState.NOT_STARTED);
public void rerunNotExistingCheckThrowsError() throws Exception {
.add("description", checkerDescription)
/** * @param started Set the time the check started. Time can be reset to "null" if passed * {@code new Timestamp(0)} */
@Test public void fallsBackToFullReloadOnManyUpdatesOnBranch() throws Exception { insertExternalId(1, 1); ObjectId head = deleteExternalId(1, 1); assertThat(loader.load(head)).isEqualTo(allFromGit(head)); verify(externalIdReaderSpy, times(1)).all(head); } @Test
assertThat(timestamp).isEqualTo(never());
Iterables.getOnlyElement(queryProvider.get().byKey(Change.key(r.getChangeId()))); assertThat(cd.change().isMerged()).isTrue();
// memory.
this(add);
assertThat(info.created).isGreaterThan(info.updated); assertThat(info.created).isNotTouched();
/** * A delegate to SoySauceTemplate#render(Appendable, String, ContentKind, Map<String, ?>) */
.setData(toHeaderSoyData(paginator, revision)) .renderHtml(out));
public String renderHtml(String templateName, Map<String, ?> soyData) {
.setIj(ImmutableMap.of("staticUrls", staticUrls.build()));
// We failed to load the requested value from the cache (hence, this loader was invoked). // Therefore, try to create this entry from a past value using the minimal amount of Git // operations possible to reduce latency.
// We failed to load the requested value from the cache (hence, this loader was invoked). // Therefore, try to create this entry from a past value using the minimal amount of Git // operations possible to reduce latency.
private static AllExternalIds buildAllExternalIds(
private static final AllUsersName ALL_USERS = new AllUsersName(AllUsersNameProvider.DEFAULT);
throw new JsonSyntaxException("Invalid value of the enum '" + enum.getName() + "' expected an existing enum value.");
public void testEmptyEnumValueIsRejectedOnParse() { assertThrows(JsonSyntaxException.class, () -> gson.fromJson("{\"value\":\"\"}", TestData.class));
if (isInterrupted.get()) { Thread.sleep(100); } else { Thread.sleep(100); }
<|del|>
<|del|>
return Response.ok(getWatchedProjects.apply(rsrc).value());
return query.apply(TopLevelResource.INSTANCE).value();
public Response<Object> apply(ProjectResource rsrc, Input input) {
return get.get().apply(target).value();
public Response<?> apply(ProjectResource rsrc, Input input) throws IOException, RestApiException {
<|del|>
<|del|>
/** * A module that provides the extensions of the {@link ReplicationPushFilter} class. */
public void shouldPushAllRefsWhenNoFiltersSetup() throws InterruptedException, IOException {
public void shouldApplyReplicationPushFilter() throws InterruptedException, IOException {
return remoteUpdatesList;
.newCommentFormatter() .format(listComments(rsrc));
// Name of config parameters that can be defined in project.config or gerrit.confg:
logger.atSevere().log( "Project %s has empty emptry %s", project, OWNERS_FILE_NAME);
* {@link ExternalIds}.
<|del|>
UPDATE_BLOB,
DynamicItem<SharedRefDatabase> sharedRefDatabase, SharedRefLogger sharedRefLogger) { this.sharedRefDb = sharedRefDatabase.get();
DynamicItem<SharedRefDatabase> sharedRefDatabase, SharedRefLogger sharedRefLogger) { this.sharedRefDb = sharedRefDatabase;
logger.atFine().log( "FindOwnersCacheStats: {}", dbCache.stats());
public void contributorSectionIsUnsetIfNoPermissionsAreSet() throws Exception {
public void notifySectionIsUnsetIfNoPermissionsAreSet() throws Exception {
public void commentLinksAreSet() throws Exception {
assertThat(submitRecords.isPresent()).isTrue();
* SubmitRecord}.
Optional<SubmitRecord> submitRecords = rule.evaluate(r.getChange());
assertThat(rule.evaluate(r.getChange()).isEmpty();
assertThat(record).isPresent();
assertThat(record).isPresent(); assertThat(record.get()).isEqualTo(expectedRecord);
assertThat(record).isEqualTo(expectedRecord); assertThat(record.get()).isEqualTo(expectedRecord);
<|del|>
<|del|>
Field.ofString(PUBLISHER_FAILURE_COUNTER, (metadataBuilder, fieldValue) -> metadataBuilder.addPluginMetadata(PluginMetadata.create(PUBLISHER_FAILURE_COUNTER, fieldValue)))
private BiConsumer<Metadata.Builder, String> metadataMapper(String metadataKey) { return (metadataBuilder, fieldValue) -> metadataBuilder.addPluginMetadata(PluginMetadata.create(metadataKey, fieldValue));
} catch (Exception e) {
"Cannot handle message %s: [Exception: %s]", event.getHeader().getEventType(), e); subscriberMetrics.incrementSubscriberFailedToConsumeMessage();
SubscriberMetrics subscriberMetrics) {
SubscriberMetrics subscriberMetrics) {
SubscriberMetrics subscriberMetrics) {
SubscriberMetrics subscriberMetrics) {
String replacement) {
<|del|>
// Also return a backfilled check for checkers that do not apply to the change.
// Also return a backfilled check for checkers that do not apply to the change.
Project.NameKey otherProject = createProjectOverAPI("other", null, true, null);
/** * This interface is intended to be used by other plugins as an external API. */
throw new ResourceConflictException( "base revision is missing from the destination branch: " + str);
private final KafkaEventSubscriber subscriber; // It is not expected that multiple receivers have a single consumer, // therefore there is only one subscriber per receiver.
public void receiveAync(String topic, Consumer<EventWrapper> eventConsumer) {
<|del|>
public void receiveAsync(String topic, Consumer<SourceAwareEventWrapper> eventConsumer) { apiDelegate.get().receiveAsync(topic, eventConsumer);
synchronized (subscribers) { subscribers.add(subscriber); }
<|del|>
@Override public StoredConfig getUserConfig() throws IOException, ConfigInvalidException { return oldSystemReader.getUserConfig(); }
private final ReplicationTaskStorage replicationTaskStorage;
ReplicationTasksStorage ts,
eventsStorage.persist(project.get(), ref, e.getURI(), getRemoteConfigName());
eventsStorage.put(
private final ReplicationTaskStorage taskStorage;
ReplicationTasksStorage es) { this.logDetails = logDetails;
Set<String> tasksReplayed = new HashSet<>();
PushOne e = pending.get(uri); if (e == null) { e = opFactory.create(project, uri); addRef(e, ref); e.addState(ref, state);
void notifyFinished(PushOne op) {
String taskJson = GSON.toJson(r) + "\n"; String eventKey = sha1(taskJson).name();
String taskKey = GSON.toJson(r) + "\n";
<|del|>
private void firePendingTasks() {
if (tasksReplayed.contains(t.project + ":" + t.ref)) {
public String persist(String project, String ref, URIish uri) {
logger.atWarning().withCause(e).log( "Couldn't persist event %s", json);
<|del|>
private Path pluginDataDir;
.collect(toList());
ReplicationState(@Assisted PushResultProcessing processing) {
Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser());
public Stream<ChangeData> getUpdatedStreams() { return Stream.concat(updatedStreams);
try (Repository repository = repoManager.openRepository(key)) { repository.close(); RepositoryCache.close(repository); }
cleanJGitCache(key);
return currentConfig.getConfig().getBoolean("gerrit", "autoReload", false);
if (!options.enableGwtUi() || !p.equals("/")) {
public ReplicateRefUpdate(String project, String ref, URIish uri) { this.project = project; this.ref = ref; this.uri = uri.toASCIIString(); this.remote = remote;
Path path = refUpdates().resolve(eventKey);
logger.atFine().log( "CREATE %s (%s)", path, r); Files.write(path, json.getBytes(UTF_8));
Path file = refUpdates().resolve(taskKey);
Path path = refUpdates().resolve(taskKey);
logger.atFine().log( "DELETE %s (%s)", path, r); Files.delete(refUpdates.resolve(taskKey));
<|del|>
String topicConfigKey = eventTopic.topic() != null ? eventTopic.topicAliasKey() : "";
Repository sourceRepo = repoManager.openRepository(project)) {
"change %s unexpectedly had status %s after submit attempt", updatedChange.getId(), updatedChange.getStatus()));
waitUntil(() -> gitPath.resolve(sourceProject + REPLICATION_git).toFile().isDirectory());
waitUntil(() -> projectExists(new Project.NameKey(sourceProject + "replica.git")));
public static String s_mCloudUid; public static String s_mCloudAccesstoken; public static String s_mAuthCode; public static String s_mErrorMessage;
public static String s_mCloudUid; public static String s_mCloudAccesstoken; public static String s_mAuthCode; public static String s_mErrorMessage;
private TestBroadCast mTestBroadCast;
<|del|>
<|del|>
PlatformConfig cfg = new PlatformConfig(ServiceType.IN_PROC,
private static RIHelper riHelperInstance;
* 8. onPostListener event handler
<|del|>
mPMHelper.clearAll();
<|del|>
* 2. queryParamsMap map with query paramter and value * ` 3. OnPutListener event handler
PlatformConfig cfg = new PlatformConfig(ServiceType.IN_PROC,
<|del|>
<|del|>
* // Copyright 2018 Intel Corporation All Rights Reserved.
* // Copyright 2018 Intel Corporation All Rights Reserved.
* // Copyright 2016 Intel Corporation All Rights Reserved.
* // Copyright 2016 Intel Corporation All Rights Reserved.
public static final String OCF_OIC_URI_PREFIX_MEDIA_CONTROL = "/ocf/media-control/"; public static final String UPNP_OIC_URI_PREFIX_MEDIA_CONTROL = "/upnp/media-control/";
* // Copyright 2016 Intel Corporation All Rights Reserved.
static public final String RESOURCE_TYPE = "oic.d.light"; static public final String DEVICE_RES_TYPE = "oic.wk.d";
public void update(int brightness) {
<|del|>
OCMain.setDelayedCallback(stopObserve, 1000);
long timeToWait = nextEvent - now; // Note that the clock time is always returned in nanoseconds.
int ret = OCMain.initPlatform("Apple"); ret |= OCMain.addDevice("/oic/d", "oic.d.phone", "Kishen's Android Phone", "ocf.1.0.0", "ocf.res.1.0.0");
CborEncoder myObject = OCMain.repOpenObject(root, "my_object");
System.out.println("inside ObtInitHandler.initialize()");
if (0 < OCObt.discoverOwnedDevices(ownedDeviceHandler)) {
System.out.print("Enter resource type: " + (j + 1) + " ");
System.out.println("inside ObtInitHandler.initialize()");
if (status >= 0) { ObtMain.ownedDevices.remove(uuid); }
long timeToWait = (NANOS_PER_SECOND / OCClock.clockSeconds()) * (nextEvent - now);
new PostLightRequestHandler(activity).handler(request, interfaces);
<|del|>
// the factory presets handler must be set prior to calling init(), // the init() function will call the factory presets handler when set.
// the factory presets handler must be set prior to calling init(), // the init() function will call the factory presets handler when set.
System.out.println("Get Owned Device Name Response Handler:");
System.out.println("Get Unowned Device Name Handler:");
public boolean getBoolean() throws OcCborException {
public long getLong() throws OcCborException {
public Double getDouble() throws OcCborException {
<|del|>
public boolean getBoolean(String key) throws OcCborException {
public long getLong(String key) throws OcCborException { OCRep.clearCborErrno();
public double getDouble(String key) throws OcCborException {
if (null != nativeRep && OCRep.getCborErrno() == 0) {
} Settings.System.putInt(mContext.getContentResolver(), Settings.System.STATUS_BAR_LAST_NOTIFICATION_STYLE, mRebootMode); Settings.System.putInt(mContext.getContentResolver(), Settings.System.STATUS_BAR_LAST_NOTIFICATION_STYLE, mRebootMode); mTileMode = 2; refreshState();
int qsQuickPulldownValue = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.STATUS_BAR_QUICK_QS_PULLDOWN, 0);
int qsQuickPulldownValue = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.STATUS_BAR_QUICK_QS_PULLDOWN, 0, UserHandle.USER_CURRENT);
ImageView v = new ImageView(mContext, value);
boolean showIndicator = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCK_HIDE_INDICATOR_DISPLAY, 0, UserHandle.USER_CURRENT) == 0;
Settings.System.QS_PANEL_BG_ALPHA, 255,
boolean locationDisabled = Settings.Secure.getInt(getActivity(),
boolean disableIfMusicActive = getPrefs(context).getBoolean(EventServiceSettings.EVENT_MUSIC_ACTIVE, false);
private CheckBoxPreference mHomeAnswerCall; private ListPreference mFeelingluckyPressAction; private ListPreference mFeelingluckyPressAction;
case 3:
<|del|>
public static final int MAX_VISIBLE_ICONS_WHEN_DARK = getResources().getInteger(R.integer.config_maxVisibleNotificationIconsWhenDark); public static final int MAX_STATIC_ICONS = getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
private static final int MAX_VISIBLE_ICONS_WHEN_DARK = getResources().getInteger(R.integer.config_maxVisibleNotificationIconsWhenDark); public static final int MAX_STATIC_ICONS = getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
// Use the SystemUI context, so it gets properly themed according to the theme used (Dark or Light). Toast.makeText(ActivityThread.currentActivityThread().getSystemUiContext(), toastText, Toast.LENGTH_SHORT).show();
logger.info("provisionONT with device id : {} success : {}",serialNumber, result);
logger.info("createChassis with clli : {}",request.getCLLI());
VlanId subscriberVlan = subscribers.remove(port); if (subscriberVlan == null) { log.warn("Unknown subscriber at location {}", port);
<|del|>
/** * {@inheritDoc} */ @Override protected boolean resolve() { return CapellaECrossReferenceAdapter.this.resolve(); }
private final Map<String, String> filterNameExceptions;
protected BooleanBooleanPropertiesCheckbox isHumanCheckbox; protected BooleanBooleanPropertiesCheckbox isActorCheckbox;
if (isHumanCheckbox.isEnabled() && (condition1 || condition2 || condition3))
if (isActorCheckbox.isEnabled() && (condition1 || condition2 || condition3 || condition4)) {
* Copyright (c) 2006, 2016 THALES GLOBAL SERVICES.
* Copyright (c) 2006, 2018 THALES GLOBAL SERVICES.
* Copyright (c) 2006, 2018 THALES GLOBAL SERVICES.
<|del|>

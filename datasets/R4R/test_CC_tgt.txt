 private int mMaxNumBlacklistBssid = INVALID_LIST_SIZE; private int mMaxNumWhitelistSsid = INVALID_LIST_SIZE; 
 } if (fallbackToFrameworkRoaming) { Log.e(TAG, "Fall back to framework roaming"); mFirmwareRoamingSupported = false; return false; } 
 * Get the maximum size of BSSID blacklist firmware supports. * * @return INVALID_LIST_SIZE if firmware roaming is not supported, or * maximum size of the BSSID blacklist firmware supports. 
 Log.e(TAG, "getMaxNumBlacklistBssid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; 
 Log.e(TAG, "getMaxNumBlacklistBssid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; 
 Log.e(TAG, "getMaxNumWhitelistSsid: Firmware roaming is not supported"); return INVALID_LIST_SIZE; 
 private static final String TAG = "WifiConnectivityHelperTest"; 
 assertFalse(mWifiConnectivityHelper.getFirmwareRoamingInfo()); assertFalse(mWifiConnectivityHelper.isFirmwareRoamingSupported()); assertEquals(WifiConnectivityHelper.INVALID_LIST_SIZE, mWifiConnectivityHelper.getMaxNumBlacklistBssid()); assertEquals(WifiConnectivityHelper.INVALID_LIST_SIZE, mWifiConnectivityHelper.getMaxNumWhitelistSsid()); 
 assertTrue(mWifiConnectivityHelper.getFirmwareRoamingInfo()); 
 } 
 * Copyright (C) 2017 The Android Open Source Project 
 boolean found = mCallbackQueue.remove(callback); if (found) { return true; 
 return mCallbackQueue.contains(callback); 
 // 1. subscribe 
 mCamera.unlock(); 
 mCamera.unlock(); 
 Binder.getCallingUid()); 
<|del|> 
<|del|> 
<|del|> 
 mGsmRoaming = regCodeIsRoaming(registrationState); mNewRejectCode = reasonForDenial; 
 private int getRegStateFromHalRegState(int regState) { 
<|del|> 
 * <td>20&ndash;TBD</td> 
 public void testSocketReadTimeout() throws Exception { 
 !writeCompleted.await(TIMEOUT_MILLIS * 2, TimeUnit.MILLISECONDS); 
 Log.d(TAG, "Firmware roaming supported with capabilities: max num blacklist bssid=" 
 ArrayList<String> whitelistSsids) { 
 if (bssid == null || fileName == null) { Log.e(mTAG, "Invalid arguments for Icon request."); return false; } 
 * ex. startMonitoring does nothing and will not send a connection/disconnection event 
 * @return generated pin if operation was successful, null otherwise. 
 /** * Enable verbose logging for all sub modules. */ 
 && mSupplicantStaIfaceHal.startRxFilter(); 
 && mSupplicantStaIfaceHal.startRxFilter(); 
 && mSupplicantStaIfaceHal.startRxFilter(); 
 && mSupplicantStaIfaceHal.startRxFilter(); 
<|del|> 
<|del|> 
 // TODO(b//36087365) Remove this. Link layer stats is enabled when the HAL is started. 
 /** * Indicates whether getChannelsForBand is supported. * * @return true if it is. */ public boolean isGetChannelsForBandSupported() { 
 /** * Stops all logging and resets the logger callback. * This stops both the alerts and ring buffer data collection. */ 
<|del|> 
 public static final String KEY_SIGNAL_STRENGTH_EARFCN_THRESHOLD_INT = 
 public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, int p2) { 
 * The gscan API is used to perform background scans and wificond is used for oneshot scans. 
 * The gscan API is used to perform background scans and wificond is used for oneshot scans. 
 description.appendText(toString()); 
 // Android-added: Make toString explicit that this is an SSLServerSocket (http://b/6602228) 
 * Lookup the ANQP elements associated with the given AP from the cache. An empty map 
 * Lookup the ANQP elements associated with the given AP from the cache. An empty map 
 setSpeakerphoneOn(false); // Do not enable SCO audio here, since RING is being sent to the headset. 
 return iccOpenLogicalChannel(getSubId(), AID, -1); 
 final IpPrefix local64 = getUniqueLocalPrefix(ulp, subnetId, 64); 
 private int mLteRsrpBoost; // offset to be reduced from the rsrp threshold while calculating // signal strength level 
 public void setLteRsrpBoost(int lteRsrpBoost) { mLteRsrpBoost = lteRsrpBoost; 
 } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) { 
 * Format of the String array is expected to be {"erafcn1_start-earfcn1_end", * "earfcn2_start-earfcn2_end" ... } 
 * configuration is used to start the Wi-Fi hotspot, and must be non-null. 
 reset(mWifiConnectivityHelper); // WifiConnectivityManager is on by default 
 verify(mWifiStateMachine).startRoamToNetwork(eq(CANDIDATE_NETWORK_ID), mCandidateScanResultCaptor.capture()); assertEquals(mCandidateScanResultCaptor.getValue().BSSID, CANDIDATE_BSSID); 
 verify(mWifiStateMachine, times(0)).startRoamToNetwork(anyInt(), anyObject()); 
<|del|> 
 } else { 
 "com.android.cellbroadcastreceiver.intent.extra.ID"; 
<|del|> 
 if (ACTION_MARK_AS_READ.equals(action)) { final long deliveryTime = intent.getLongExtra(EXTRA_DELIVERY_TIME, -1); 
 /** Intent extra for passing a SmsCbMessage */ 
 // For FEATURE_WATCH we want to mark as read intent = createMarkAsReadIntent(context, message.getDeliveryTime()); 
 static Intent createMarkAsReadIntent(Context context, long deliveryTime) { 
 * * Returned instances of INetd should not be cached. * 
 public static INetd get(int maxTimeoutMs) { int timeoutMs = BASE_TIMEOUT_MS; for (int i = 0; i > -1; i++) { 
 } catch (InterruptedException e) { // If this occurs we can lose track of some time slept. } if (maxTimeoutMs > 0) maxTimeoutMs -= timeoutMs; 
 void run(INetd netd) throws RemoteException; 
 * the command succeeds or a runtime exception is thrown. 
 } catch (RemoteException re) { Log.e(TAG, "error communicated with netd: " + re); } 
 } catch (RemoteException re) { Log.e(TAG, "error communicated with netd: " + re); } 
 final int NUMBER_REPETITION = 3; 
 * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are managed 
 * Ignore Passpoint networks. Passpoint networks are also considered as "saved" * network, but without being persisted to the storage. They are being evaluated 
<|del|> 
 final Mode current = mMode; if (current != Mode.IDLE) { 
 Log.e(TAG, "Already in mode: " + current.description); 
 Log.e(TAG, "Local hotspot not running."); 
<|del|> 
 private static class Downstream { 
 private final LinkedList<Downstream> mActiveDownstreams; 
 mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId++)); 
 final byte[] in6addr = Arrays.copyOf(ulp, NetworkConstants.IPV6_ADDR_LEN); 
 // At this time the timerReceiver should not fire, even though the activity has shut 
 * inclusive ranges for which the lte rsrp boost is applied */ 
 private final Object mLteRsrpBoostLock = new Object(); private static final int INVALID_LTE_EARFCN = -1; 
 updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult)); 
 serviceState.setLteEarfcnRsrpBoost(mLteRsrpBoost); 
 conn.setPreciseDisconnectCause( getPreciseDisconnectCauseFromReasonInfo(reasonInfo)); 
 private int mPreciseDisconnectCause = 0; 
 public static final int LOCAL_ILLEGAL_STATE = 1201; 
 public static final int LOCAL_INTERNAL_ERROR = 1202; 
 public static final int LOCAL_IMS_SERVICE_DOWN = 1203; 
 public static final int LOCAL_POWER_OFF = 1205; 
 public static final int LOCAL_MAX_CALL_EXCEEDED = 1213; 
<|del|> 
<|del|> 
 while (true) { 
 Log.e(TAG, "error communicating with netd: " + re); 
<|del|> 
 getContext().registerReceiver(mBCMReceiver, btChangeFilter); 
 // BEGIN Android-removed: Certificate checking // Android doesn't use this mechanism for checking untrusted certificates. 
 tearDown(); return; 
 assertTrue(PhoneNumberUtils.compare("2023458246", "2023458246")); 
 assertEquals("+18004664114", PhoneNumberUtils.formatNumberToE164("800-GOOG-114", "US")); 
<|del|> 
 private void processSlcConnected() { 
<|del|> 
 mWifiConfigStore.enableAllNetworks(); mWifiConfigStore.loadConfiguredNetworks(); 
 mWifiConfigStore.enableAllNetworks(); mWifiConfigStore.loadConfiguredNetworks(); 
 // supporting Quick Settings UI component, according to the CDD: // http://source.android.com/compatibility/7.1/android-7.1-cdd.html#3_13_quick_settings 
 class AdvertiserInfo { 
<|del|> 
 if (linkAddr.getPrefixLength() != RFC7421_PREFIX_LENGTH) continue; 
<|del|> 
 } catch (RemoteException re) { logError("Unable to change interface settings: %s", re); 
<|del|> 
<|del|> 
 final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, INVALID_PICK); 
 {"+8112345*00000", "+8112345", "+8112345*00000"}, {"12345*00000", "12346", "12346"}}; 
 * Set by the framework to indicate that a connection has an active RTT session associated with * it. 
 // Max number of HF connections at any time 
<|del|> 
<|del|> 
 Log.i(this, "Skipping binding to %s - doesn't support self-mgd calls", mInCallServiceInfo); mIsConnected = false; return CONNECTION_NOT_SUPPORTED; 
 String number, CallerInfoAsyncQuery.OnQueryCompleteListener listener, Object cookie) { 
 @VisibleForTesting public static final int NOTIFICATION_INCOMING_CALL = 1; 
<|del|> 
 FileTypeDetector defaultFileTypeDetector = sun.nio.fs.DefaultFileTypeDetector.create(); // The method uses file extensions to deduce mime type, therefore, it doesn't check for // file existence. 
 // Package name for platform carrier config app, bundled with system image. private final String mPlatformCarrierConfigPackage; 
 int defaultVal = (mSystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1); 
 } 
 * WifiConnectivityHelper#getFirmwareRoamingInfo 
 * WifiConnectivityHelper#getFirmwareRoamingInfo 
 public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasNoBssidSpecified() { 
 public void noFrameworkRoamingIfConnectedAndFirmwareRoamingSupported() { 
<|del|> 
 sbuf.append(" Firmware roaming equivalent BSSID bonus: ") 
 int dataIndex = OsConstants.CAP_TO_INDEX(i); int capMask = OsConstants.CAP_TO_MASK(i); if ((data[dataIndex].inheritable & capMask) != 0) { 
 if (DBG) Log.d(TAG, "Received empty country code, reset to default country code"); 
 public static int CAP_TO_INDEX(int x) { return x >>> 5; } 
 mNetworkSelector.selectNetwork(scanDetails, buildBssidBlacklist(), mWifiInfo, 
 public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasNoBssidSpecified() { 
 mLocalLog.log(log); 
 mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser, mPhoneParser); 
 mScreenOn, mGpsParser, mFlashlightParser, mCameraParser, mWifiParser, mCpuParser); 
 bindData(mPhoneParser, R.string.battery_stats_phone_signal_label, R.id.cell_network_group); 
 } else { // With platforms that have no home screen, focus is returned to something else that is // considered a completion of the tracked activity flow, and hence time tracking is // triggered. 
 * will fail and return the appropriate error value. Ie calling * getSlotIndex(INVALID_SUBSCRIPTION_ID) will return INVALID_SIM_SLOT_INDEX and calling * getSubInfoForSubscriber(INVALID_SUBSCRIPTION_ID) will return null. 
 * Any setters which take subId, slotIndex or phoneId as a parameter will throw an exception if the 
 * will fail and return the appropriate error value. Ie calling getSlotIndex(INVALID_SUBSCRIPTION_ID) 
 * @param slotIndex the slot which the SIM is inserted 
 " slotIndex:" + slotIndex); 
 " slotIndex:" + slotIndex); 
 final int[][] mSlotIndexToSubId; 
 public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex, String cp){ 
 private boolean isInvalidSlotId(int slotIndex) { if (slotIndex < 0 || slotIndex >= mSlotIndexToSubId.length) return true; 
 public int[] getSubId(int slotIndex) { if (isInvalidSlotId(slotIndex)) { 
 public void setSlotSubId(int slotIndex, int subId) { if (isInvalidSlotId(slotIndex)) { throw new RuntimeException("invalid slot specified" + slotIndex); 
 public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex, 
 public int[] getSubId(int slotIndex) { if (VDBG) printStackTrace("[getSubId]+ slotIndex=" + slotIndex); 
 private int[] getDummySubIds(int slotIndex) { 
 for (Entry<Integer, Integer> entry : sSlotIndexToSubId.entrySet()) { pw.println(" sSlotIndexToSubId[" + entry.getKey() + "]: subId=" + entry.getValue()); 
 final int[][] mSlotIndexToSubId; 
 public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex, String cp){ 
 private boolean isInvalidSlotId(int slotIndex) { if (slotIndex < 0 || slotIndex >= mSlotIndexToSubId.length) return true; 
 public void setSlotSubId(int slotIndex, int subId) { if (isInvalidSlotId(slotIndex)) { throw new RuntimeException("invalid slot specified" + slotIndex); 
 final Resources r = context.getResources(); 
 * Returns a constant indicating the state of sim for the slot index. 
 public boolean onCreate() { mServiceState = new ServiceState(); mServiceState.setStateOutOfService(); 
<|del|> 
<|del|> 
<|del|> 
 public static Uri getUriForFieldAndSubId(String field, int subId) { 
 /** Python doesn't have multi map, if advertise data should repeat use * serviceUuid, serviceUuid2, serviceUuid3... . For that use "startsWith" */ 
 /** Python doesn't have multi map, if advertise data should repeat use * serviceUuid, serviceUuid2, serviceUuid3... . For that use "startsWith" */ 
 } else if (key.equals("interval")) { 
 public void useAnyBssidToConnectWhenFirmwareRoamingOnAndConfigHasNoBssidSpecified() { 
 } result <<= 7; result |= b & 0x7f; 
<|del|> 
 * Copyright (C) 2017 The Android Open Source Project 
 } if (passphrase != null && passphrase.length() != 0) { req.cipherType = getStrongestCipherSuiteType(capabilities.supportedCipherSuites); req.securityConfig = NanDataPathSecurityConfig.PASSPHRASE; convertNativeByteArrayToArrayList(passphrase.getBytes(), req.passphrase); } 
 * Initiate a P2P service discovery indefinitely. * Will trigger {@link WifiP2pMonitor#P2P_DEVICE_FOUND_EVENT} on finding devices. 
 private SparseArray<Thread> mThreads = new SparseArray<>(); private AtomicInteger mNextConnectionId = new AtomicInteger(1); 
<|del|> 
 Toast.makeText(this, message.what, Toast.LENGTH_SHORT).show(); if (message.what != R.string.disconnected) { updateForegroundNotification(message.what); 
 private void connect() { 
<|del|> 
 // Tell the AdapterService that it is a mock (see isMock documentation) 
 private Phone mPhone; 
 * Firmware supports controlled roaming. * Connect to a network which has a config specified BSSID. 
 * Firmware does not support controlled roaming. * Connect to a network which doesn't have a config specified BSSID. 
 verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); 
 * Firmware does not support controlled roaming. * Connect to a network which has a config specified BSSID. 
 verify(mWifiStateMachine).startConnectToNetwork(CANDIDATE_NETWORK_ID, CANDIDATE_BSSID); 
 public synchronized void setLockdown(boolean lockdown) { 
 mLockdown = lockdown; // Update app lockdown setting if it changed. Legacy VPN lockdown status is controlled by // LockdownVpnTracker.isEnabled() which keeps track of its own state. if (mAlwaysOn) { saveAlwaysOnPackage(); } 
 final List<String> exemptedPackages = isNullOrLegacyVpn(mPackage) ? null : Collections.singletonList(mPackage); setVpnForcedWithExemptionsLocked(enforce, exemptedPackages); 
<|del|> 
<|del|> 
// Android-changed: Removed AnnotatedElement super-class due to excluded support // for runtime type annotations public interface TypeVariable<D extends GenericDeclaration> extends Type { 
 * This function is used only at boot time 
 when(mFrameworkFacade.inStorageManagerCryptKeeperBounce()).thenReturn(true); 
 when(mFrameworkFacade.inStorageManagerCryptKeeperBounce()).thenReturn(false); 
 when(mFrameworkFacade.inStorageManagerCryptKeeperBounce()).thenReturn(false); 
 public static final int SUPPLICANT_STATE_CHANGE_EVENT = BASE + 6; 
 mWifiMonitor.broadcastPnoScanResultEvent(mClientInterfaceName); 
 || carrierConfig.getBoolean( CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { 
 || carrierConfig.getBoolean( CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL)) { 
 NetworkRequest request = makeRequest(1); 
 // unregistering the callback should make it registrable again. 
 maxBlacklistSize)); 
 mConnectivityHelper.getFirmwareRoamingInfo(); clearBssidBlacklist(); 
<|del|> 
 mLocalLog.log(log); 
 .append(mSameBssidAward).append(","); 
 .append(","); 
 .append(","); 
 testBlocked(217); // __NR_add_key testBlocked(219); // __NR_keyctl testAllowed(56); // __NR_openat 
 * Copyright (C) 2017 The Android Open Source Project 
<|del|> 
 mUserWantsSuspendOpt.set(mFacade.getIntegerSetting(mContext, 
 * This will reset SapProxy. 
 configs[index] = generateWifiConfig(id.intValue(), 0, ssids[index], false, true, null, null, securities[index]); 
 configs[index] = generateWifiConfig(id.intValue(), 0, ssids[index], false, true, null, null, securities[index]); 
 // Android-changed: CTS and AndroidJUnitRunner rely on specific format to test names, changing // them will prevent CTS and AndroidJUnitRunner from working properly; see b/36541809 
 private TestLooper mLooper; 
<|del|> 
 mWifiConnectionStatistics.numWifiManagerJoinAttempt++; boolean hasCredentialChanged = false; 
 mWifiConnectionStatistics.numWifiManagerJoinAttempt++; boolean hasCredentialChanged = false; 
 // Reset the |hasEverConnected| flag if the credential parameters changed in this update. boolean hasCredentialChanged = newNetwork || WifiConfigurationUtil.hasCredentialChanged( existingInternalConfig, newInternalConfig); 
 synchronized (mSapProxyLock) { 
 @Override public void onConnectionUpdated(String address, int interval, int latency, 
 * Copyright (C) 2017 The Android Open Source Project 
<|del|> 
 private static final int NETD_FETCH_TIMEOUT = 1000; //ms 
 if (isNetdAlive()) { Slog.d(TAG, "IpSecService is ready"); 
 // Avoid blocking the system server to do this Thread t = new Thread( 
 // qualify as the user leaving the activity's flow. The time tracking is considered // complete only when the user switches to another activity that is not part of the // tracked flow. 
 if (mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId))) { mNextSubnetId = (short) Math.max(0, mNextSubnetId + 1); // always positive } 
 public IpSecManager createService() { 
 IIpSecService service = IIpSecService.Stub.asInterface(b); return new IpSecManager(service); 
 private static final int NETD_FETCH_TIMEOUT = 5000; //ms 
 private static final int NETD_FETCH_TIMEOUT = 5000; //ms 
<|del|> 
 public interface Prefs { String NAME = "connection"; String SERVER_ADDRESS = "server.address"; String SERVER_PORT = "server.port"; String SHARED_SECRET = "shared.secret"; 
 private static final int MAX_HANDSHAKE_ATTEMPTS = 50; 
 throw new IllegalStateException("Cannot protect the tunnel"); 
 return configure(new String(packet.array(), 1, length - 1, US_ASCII).trim()); 
 return configure(new String(packet.array(), 1, length - 1, US_ASCII).trim()); 
 } catch (SecurityException e) { 
 Log.e(TAG, "Interrupting thread", e); } catch (IOException e) { Log.e(TAG, "Closing VPN interface", e); 
<|del|>
<|del|> 
 // Android-added: Throw an exception when the underlying cipher does. http://b/36636576 
 * @param notifyType is one state of * PS/CS_*_ENABLE/DISABLE/ * CS_REJECT_CAUSE_ENABLED/CS_REJECT_CAUSE_DISABLED 
 private void setNotification(int notifyType) { 
 public void prepareForForcedConnection(int netId) { localLog("prepareForForcedConnection: netId=" + netId); 
 * supplied network SSID and security information. 
 UidDetail uidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = uidDetail.icon; mLabel = uidDetail.label; 
 UidDetail uidDetail = new UidDetailProvider(context).getUidDetail(mAppItem.key, true); mIcon = uidDetail.icon; mLabel = uidDetail.label; 
 oldThread.interrupt(); 
 public static final PropertyId<List<String>> BOOST_LOCK_CLASSNAME = 
 if (lockClass.length == 0) { 
 * 2.5 lft.equals(rgt) returns true 
 * 2.5 lft.equals(rgt) returns true 
 * 2.5 lft.equals(rgt) returns true 
 StrictMode.setThreadPolicy(oldPolicy); 
 * Non-persistently change WFC enabled setting and WFC mode for slot 
 * Non-persistently change WFC enabled setting and WFC mode for slot 
 public void setWfcNonPersistentForSlot(boolean enabled, int wfcMode) { 
 private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); 
<|del|> 
 return o instanceof MatchAllNetworkSpecifier; 
<|del|> 
 return mNetworkSpecifier == null || mNetworkSpecifier.satisfiedBy(nc.mNetworkSpecifier) || nc.mNetworkSpecifier instanceof MatchAllNetworkSpecifier; 
 if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); 
 if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); 
 Preconditions.checkStringNotEmpty(specifier); 
 return equals(other); 
 * Copyright (C) 2017 The Android Open Source Project 
 if (other == null) return false; 
 private IpSecService(Context context) { 
 static IpSecService create(Context context) throws InterruptedException { final IpSecService service = new IpSecService(context); 
<|del|> 
 private final SparseArray<SpiRecord> mSpiRecords = new SparseArray<>(); private final SparseArray<TransformRecord> mTransformRecords = new SparseArray<>(); 
 return retBundle; 
 public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) { // TODO: Basic input validation here since it's coming over the Binder 
 for (int direction : DIRECTIONS) { 
 retBundle.putInt( IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_RESOURCE_ID); 
 retBundle.putInt( IpSecTransform.KEY_RESOURCE_ID, IpSecTransform.INVALID_RESOURCE_ID); 
 synchronized (mTransformRecords) { TransformRecord record; 
 // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * The reason code if there is no error during authentication. * It could also imply that there no authentication in progress, * this reason code also serves as a reset value. 
<|del|> 
<|del|> 
<|del|> 
 if (mNetworkSpecifier != null && !NetworkSpecifier.isWhitelistedNetworkSpecifier( mNetworkSpecifier)) { throw new IllegalStateException("Invalid network specifier"); } dest.writeParcelable((Parcelable) mNetworkSpecifier, flags); 
 * class via other APIs. * * @hide 
 ((call.isSelfManaged() != foregroundCall.isSelfManaged()) || 
<|del|> 
<|del|> 
 * Copyright (C) 2017 The Android Open Source Project 
 * advertisement is connectable, three bytes will be added for flags. 
 * advertisement is connectable, three bytes will be added for flags. 
 * @deprecated Use {@link SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED} 
 * @deprecated Use {@link SubscriptionManager.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED} 
 final int initialRotation = 4 - rotationStep; setDeviceRotation(initialRotation); 
 throw new IllegalArgumentException("Invalid network specifier"); 
 } catch (Exception e) { Log.e(TAG, "Exception: e=" + e); 
 if (isImsConnection()) { ImsPhone imsPhone = (ImsPhone) getPhone(); 
 if (!isImsConnection()) { 
 * Copyright (C) 2017 The Android Open Source Project 
 // MatchAllNetworkSpecifier is taken care in NetworkCapabilities#satisfiedBySpecifier. return equals(other); 
 public static List<String> getTimeZoneIdsWithUniqueOffsets(String country) { 
 return "onStartRtt"; case ON_RTT_REQUEST_RESPONSE: return "onRttRequestResponse"; case ON_STOP_RTT: return "onStopRtt"; 
<|del|> 
 Log.e(TAG, "Failed to delete SPI reservation with ID: " + mResourceId); 
 throw new RemoteException("Failed to Get Netd Instance"); 
 int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException { 
 public Bundle createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException { 
 // We want to non-destructively get so that we can check credentials before removing // this from the records. 
 if (record.pid != Binder.getCallingPid() || record.uid != Binder.getCallingUid()) { 
 // TODO: if releaseResources() throws RemoteException, we can try again to clean up on // binder death. Need to make sure that path is actually functional. 
 public void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { 
 public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException { 
<|del|> 
 IpSecConfig() {} 
import static android.net.IpSecManager.INVALID_RESOURCE_ID; import static android.net.IpSecManager.KEY_STATUS; import static android.net.IpSecManager.KEY_RESOURCE_ID; 
<|del|> 
 private void checkResultStatusAndThrow(int status) 
 private void checkResultStatusAndThrow(int status) 
 private AtomicInteger mNextResourceId = new AtomicInteger(0x00FADED0); 
 pid = Binder.getCallingPid(); uid = Binder.getCallingUid(); 
 for (int direction : DIRECTIONS) { 
 Log.e(TAG, "Failed to delete SA with ID: " + mResourceId); 
 // TODO: Add appropriate checks when other ServiceSpecificException types are supported retBundle.putInt(KEY_STATUS, IpSecManager.Status.SPI_UNAVAILABLE); retBundle.putInt(KEY_RESOURCE_ID, resourceId); retBundle.putInt(KEY_SPI, spi); 
 // We want to non-destructively get so that we can check credentials before removing // this from the records. 
 // TODO: if releaseResources() throws RemoteException, we can try again to clean up on binder death. // Need to make sure that path is actually functional 
 for (int direction : DIRECTIONS) { 
 private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG); 
 * Copyright (C) 2017 The Android Open Source Project 
 public void testAllocSpi() throws Exception { 
<|del|> 
 IpSecManager.SecurityParameterIndex inSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_IN, local, outSpi.getSpi()); 
 return match; 
<|del|> 
 validate("<timezones>\n" 
 TimeZoneFinder finder = validate("<timezones>\n" 
<|del|> 
 for (int direction : DIRECTIONS) { 
 randomSpi = mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, addr, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); assertTrue(randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); 
 mISM.reserveSecurityParameterIndex( IpSecTransform.DIRECTION_OUT, local, IpSecManager.INVALID_SECURITY_PARAMETER_INDEX); 
<|del|> 
<|del|> 
 return setNetworkSpecifierObject(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier)); 
 public Builder setNetworkSpecifierObject(NetworkSpecifier networkSpecifier) { 
 * Applications cannot instantiate this class by themselves, but can obtain instances of * subclasses of this class via other APIs. 
<|del|> 
 mWifiController.sendMessage(CMD_WIFI_TOGGLED); 
 * @see java.util.Locale * @see DecimalFormat * @author Mark Davis * @author Alan Liu 
 } catch (IOException e) { fail("Exception creating file /data/misc/bluetooth/test.file: " + e); 
 /** Tests that a distro with a bad tzlookup file will not update the content. */ 
<|del|> 
<|del|> 
 for (int i = 0; i < length; i++) { char c = symbol.charAt(i); 
 final char c = symbol.charAt(i); 
 // when RNDIS is enabled 
 tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED); 
 // when RNDIS is enabled 
 mActiveDownstreams.offer(downstream); 
 mDeprecatedInfoTracker.removePrefixes(newParams.prefixes); mDeprecatedInfoTracker.removeDnses(newParams.dnses); 
 public void workingLocalOnlyHotspot() throws Exception { 
 // per-interface state machine to start up, and telling us that // hotspot mode is to be started. 
 if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.mNetworkSpecifier)) { 
 setNetworkSpecifier(nc.mNetworkSpecifier); 
 MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier( networkCapabilities.getNetworkSpecifier()); 
 MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier( networkCapabilities.getNetworkSpecifier()); 
 MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier( networkCapabilities.getNetworkSpecifier()); 
 public void setNetworkSpecifier(NetworkSpecifier networkSpecifier) { mNetworkCapabilities.setNetworkSpecifier(networkSpecifier); 
 NetworkRequest rBar = newWifiRequestBuilder().setNetworkSpecifier( new StringNetworkSpecifier("bar")).build(); 
 mWiFiNetworkAgent.setNetworkSpecifier(new StringNetworkSpecifier("foo")); 
 mWiFiNetworkAgent.setNetworkSpecifier(new StringNetworkSpecifier("bar")); 
 fail("Parceling a non-parcelable specifier did not throw an exception"); 
 try { subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier); } catch (NumberFormatException e) { Rlog.e(LOG_TAG, "NumberFormatException on " + ((StringNetworkSpecifier) specifier).specifier); subId = INVALID_SUBSCRIPTION_ID; } 
<|del|> 
 Preconditions.checkArgumentNonnegative(newSize); if (newSize <= mValues.length) { Arrays.fill(mValues, newSize, mValues.length, 0); } else { ensureCapacity(newSize - mSize); 
 } mSize = newSize; 
 } mSize = newSize; 
 } mSize = newSize; 
<|del|> 
 xi[2] = 0x80000001; 
<|del|> 
 @Rpc(description = "Request a Wi-Fi Aware network") 
 if (networkRequest.networkCapabilities.getNetworkSpecifier() instanceof StringNetworkSpecifier) { String ns = ((StringNetworkSpecifier) networkRequest.networkCapabilities .getNetworkSpecifier()).specifier; 
 networkRequest.networkCapabilities.setNetworkSpecifier( WifiAwareManagerFacade.getNetworkSpecifier(j)); 
 networkRequest.networkCapabilities.setNetworkSpecifier( WifiAwareManagerFacade.getNetworkSpecifier(j)); 
 Log.d(TAG, "insert: no subId provided in uri"); throw e; 
 // Don't pick the subnet-router anycast address, since that might be // in use on the upstream already. 
 final Mode mode = (Mode) message.obj; 
 a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]); 
 a.resize(2); assertEquals(0, backingArray[2]); assertEquals(0, backingArray[3]); 
 } catch (SpiUnavailableException unlikely) { throw new ResourceUnavailableException("No SPIs available"); 
 } catch (SpiUnavailableException unlikely) { throw new ResourceUnavailableException("No SPIs available"); 
 iAddress = InetAddress.getLocalHost(); 
 int[] xx = new int[2]; int[] yy = new int[469]; reduc(xx, yy); 
 log("isPhoneStateIdle false: Voice call active on phone " + i); 
 Log.wtf(TAG, "Unknown interface state: " + requestedState); return; 
<|del|> 
<|del|> 
 private final HashSet<TetherInterfaceStateMachine> mForwardedDownstreams; 
 Log.wtf(TAG, "Unknown interface state: " + state); 
 mIsMergeCallSupported = isCarrierMergeCallSupported(); mIsMergeImsCallSupported = isCarrierMergeImsCallSupported(); 
 public UnitTest mTest; 
 for (int i = 0; i < reachableObjNum; i++) { 
 for (int i = 0; i < unreachableObjNum; i++) { 
 for (int i = 0; i < unreachableObjNum; i++) { 
<|del|> 
public final class WifiAwareNetworkSpecifier extends NetworkSpecifier implements Parcelable { 
 /* variables to accumulate attrs */ 
 Log.w(TAG, "invalid attribute id is requested: " + attribId); 
 } final NetworkAgentInfo defaultNai = getDefaultNetwork(); if (defaultNai != null && defaultNai.network.netId == netId) { setDefaultDnsSystemProperties(dnses); } 
 * A "|" separated list of URLs used for captive portal detection in addition to the * fallback HTTP url associated with the CAPTIVE_PORTAL_FALLBACK_URL settings. 
 String firstUrl = getSetting(context, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, DEFAULT_FALLBACK_URL); 
// Android-changed: removed ValueBased paragraph. 
 secondaryPhy != BluetoothDevice.PHY_LE_2M && 
 // BEGIN Android-changed: implement using android.icu.text.TimeZoneNames 
<|del|> 
 isRingerAudible || (isHfpDeviceAttached && shouldRingForContact) || isSelfManaged; 
 Log.i(this, "startRinging: skipping because ringer would not be audible. " + "isVolumeOverZero=%s, shouldRingForContact=%s, isRingtonePresent=%s", isVolumeOverZero, shouldRingForContact, isRingtonePresent); 
 int idx = Math.abs(mNextFallbackUrlIndex) % mCaptivePortalFallbackUrls.length; mNextFallbackUrlIndex += new Random().nextInt(); // randomely change url without memory. 
 mTSIBinder.isInCall("blah"); fail(); 
 mTSIBinder.isInManagedCall("blah"); fail(); 
 (actual == (i & ~INET_ECN_MASK)); // IP_TOS: ECN bits should be 0 
 // Android-removed: Logic dealing with value type moved to socketSetOption. 
 /* check type safety b4 going native. These should never 
 * 
 /* true only if disabling - enabling should be Integer * 
 // Android-removed: Logic dealing with value type moved to socketGetOption. 
 /* 
 * 
 // Android-changed: Method signature changed, socket{Get,Set}Option work directly with Object // values. 
 System.out.println(test()); 
 throw new IllegalArgumentException("Priority out of range: " + newPriority); 
 if (doDisableReporting == null) { 
 doEnableReporting = testwatcher_class.getDeclaredMethod("EnableReporting"); doDisableReporting = testwatcher_class.getDeclaredMethod("DisableReporting"); 
 public static void SimdMulAdd(int[] array1, int[] array2) { 
 array2[j] += 12345 * array1[j]; 
 array2[j] += 12345 * array1[j]; 
 if (result != null) { AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED)); result.sendToTarget(); } 
 } LinkProperties lp = getLinkProperties(nai); if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) { return; } nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid); 
<|del|> 
 // We may be presenting a queue with only 1 item (the current one) int count = mediaController.getMetadata() != null ? 1 : 0; mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, count); 
 if (wifiSecurity == WifiSecurity.PSK && password.length() < FormPageDisplayer.PSK_MIN_LENGTH) { 
 Util.setShort(buffer, (short) 0, (short) 0); 
 ImsPhoneConnection originalConnection = (ImsPhoneConnection) mOriginalConnection; originalConnection.sendRttModifyRequest(textStream); 
 return result; 
<|del|> 
<|del|>
 final short thirtySecondsInMilliseconds = 0x7530; // = 1000 * 30 
<|del|> 
 updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean( BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false)); 
 String address = Utils.getAddressStringFromByte(mAddress); debugLog("Address is:" + address); intent = new Intent(BluetoothAdapter.ACTION_BD_ADDR_CHANGED); intent.putExtra(BluetoothAdapter.EXTRA_BD_ADDR, address); 
 public static final String ACTION_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BD_ADDR_CHANGED"; 
 public static final String ACTION_BD_ADDR_CHANGED = "android.bluetooth.adapter.action.BD_ADDR_CHANGED"; 
 public static final String EXTRA_BD_ADDR = "android.bluetooth.adapter.extra.BD_ADDR"; 
 public static final String EXTRA_BD_ADDR = "android.bluetooth.adapter.extra.BD_ADDR"; 
 if (DBG) Slog.d(TAG, "Bluetooth Adapter MAC Address changed to " + newAddress); 
 if (DBG) Slog.e(TAG, "No Bluetooth Adapter MAC Address parameter found"); 
 /* retrieve NMR1 AOSP service_contexts file from jar */ if (!isFileStartsWith(aospSvcFile, deviceSvcFile)) { 
 * Copyright (C) 2017 The Android Open Source Project 
 return Consts.SW_WRONG_KEY; 
<|del|> 
<|del|> 
 /// CHECK-DAG: VecMultiplyAccumulate kind:Add loop:<<Loop>> outer_loop:none /// CHECK-START-ARM64: void Main.SimdMulAdd(int[], int[]) instruction_simplifier_arm64 (after) /// CHECK-NOT: VecMull /// CHECK-NOT: VecAdd 
 * Copyright (C) 2017 The Android Open Source Project 
 cleanup(); 
 * Copyright (C) 2017 The Android Open Source Project 
 + line + "\n", line.equals("equal") || line.equals("subset")); 
 protected abstract boolean isDesugarEnabled(); 
 input1D = Allocation.createSized(RS, Element.U8(RS), width * height, Allocation.USAGE_SCRIPT); 
<|del|> 
 Log.d(TAG, "Notification cancel " + mDevice.getAddress() + " (" + 
<|del|> 
 public static List<String> getTimeZoneIdsWithUniqueOffsets(String country) { 
 * When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is not 
 * When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is not 
 ArrayList<String> availableList = new ArrayList<String>(); ArrayList<String> activeList = new ArrayList<String>(); ArrayList<String> erroredList = new ArrayList<String>(); 
 long mTimeoutMs = 100; // non-final so that tests can adjust the value. 
 NsdServiceInfo request = new NsdServiceInfo("a_name", "a_type"); NsdServiceInfo reply = new NsdServiceInfo("resolved_name", "resolved_type"); 
 public static MockServiceHandler create(Context context) { 
 // Another message associated with that key notified the listener first. // This is expected for replies and timeouts to resolveService(). 
 * Intent used to broadcast the change in the Bluetooth address * of the local Bluetooth adapter. 
 * #EXTRA_BLUETOOTH_ADDRESS} containing the Bluetooth address. 
 * Bluetooth address. 
 if (DBG) Slog.d(TAG, "Bluetooth Adapter address changed to " + newAddress); 
 if (DBG) Slog.e(TAG, "No Bluetooth Adapter address parameter found"); 
 filter = new IntentFilter(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); 
 public static final String ACTION_BLUETOOTH_ADDRESS_CHANGED = "android.bluetooth.adapter.action.BLUETOOTH_ADDRESS_CHANGED"; 
 @Override public void onCreate() { } 
 * @deprecated This method suffers from a potential integer overflow and may be removed or * changed in a future release. See <a href="http://bugs.icu-project.org/trac/ticket/11632"> * ICU ticket #11632</a> for details. 
 * Copyright (C) 2017 The Android Open Source Project 
 * <tr><td>Android O</td> 
 // Test we will bind fine if we make no changes. 
<|del|> 
 private void ensureValidNetworkSpecifier(NetworkCapabilities nc) { if (nc == null) { return; 
 * Copyright (C) 2017 The Android Open Source Project 
<|del|> 
 } qtaguidReader.close(); 
 return mImsManager.isVolteEnabledByPlatformForSlot(); 
 * A utility class for handling unsigned integers and unsigned arithmetics, as well as syntactic * sugar methods for ByteBuffer. Useful for networking and packet manipulations. 
 ite.getCause().getClass().getName() + ": " + ite.getCause().getMessage()); 
 * @deprecated This method suffers from a potential integer overflow and may be removed in a * future release. Overriding this method in subclasses will not have the desired effect. * See ICU ticket #11632. 
 * @deprecated This method suffers from a potential integer overflow and may be removed in a * future release. Overriding this method in subclasses will not have the desired effect. * See ICU ticket #11632. 
<|del|> 
 // BEGIN Android-removed: unused code 
 startWps(); 
 public static final long INVALID_VALUE_PARAMETER = -1; 
<|del|> 
 /* Here we might have changed crucial data, hence reset DB identifier */ 
 /* We will continue the process when we receive * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */ 
<|del|> 
 /* 'p' and 'w' are the standard characters for pause and wait * (see RFC 3601) so use those when exporting phone numbers via vCard.*/ 
 /* 'p' and 'w' are the standard characters for pause and wait * (see RFC 3601) so use those when exporting phone numbers via vCard.*/ 
 Log.d(TAG, "bit.prop.equals current prop :" + prop); 
 Log.d(TAG, "checking for prop :" + bit.prop); 
 Log.d(TAG, "bit.prop.equals current prop :" + bit.prop); 
 // fetch Pbap Params to check if significant change has happened to Database BluetoothPbapUtils.fetchPbapParams(mContext); 
 if (bondedDevices == null) { Log.e(TAG, "Bonded devices list is null"); return false; } 
 Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices(); if (bondedDevices == null) return false; for (BluetoothDevice bd : bondedDevices) { 
 Log.v(TAG, "NotPlay is specified for baseline case that only Bluetooth is on"); 
 // playTime and musicUrl are necessary 
 // TODO: disconnect client1 // TODO: disconnect client2 
 assertFileContents(UNICODE_STRING.getBytes(Charset.defaultCharset()), testFile); 
 PrintStream printStream = new PrintStream(bos, true /* autoFlush */, "utf-8"); 
 pw.print("No active ApfFilter"); pw.println((provisioningConfig != null) ? "; provisioned capabilities: " + provisioningConfig.mApfCapabilities : ""); 
 pw.print("No active ApfFilter"); pw.println((provisioningConfig != null) ? "; provisioned capabilities: " + provisioningConfig.mApfCapabilities : ""); 
 pw.println(Objects.toString(provisioningConfig, "N/A")); 
 key = nextListenerKey(); 
 results.putInt("setId", setIndex); 
 ClassLoader classLoader = null; if (System.getProperty("java.vendor").contains("Android")) { classLoader = getClassLoaderInitializedWithDexFile(); } else { classLoader = getClassLoaderInitializedWithClassFile(); } 
 public void testCanStart() { 
 if ((length == 10 || length == 26 || length == 32 || length == 58) 
 } else if (length == 5 || length == 13 || length == 16 || length == 29) { 
 long[] expected_1 = {5L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L}; 
 return suggestions.getResult(); 
 // sure we are not interpreting all their code in that process. 
 // SourceDebugExtension metadata can be reported back to the debugger. 
 "android.telephony.mbms.action.DOWNLOAD_RESULT_INTERNAL"; 
 * The MBMS middleware should send this when it wishes to clean up temp files in the app's * filesystem. Mandatory extras are: 
 "android.telephony.mbms.action.CLEANUP"; 
 public static final String EXTRA_RESULT = "android.telephony.mbms.extra.RESULT"; 
 public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.extra.PAUSED_LIST"; 
 public static final String EXTRA_PAUSED_LIST = "android.telephony.mbms.extra.PAUSED_LIST"; 
 private final IMbmsDownloadManagerCallback mCallback; 
 private MbmsDownloadManager(Context context, IMbmsDownloadManagerCallback callback, 
 private MbmsStreamingManager(Context context, IMbmsStreamingManagerCallback listener, String streamingAppName, int subscriptionId) { 
 private MbmsStreamingManager(Context context, IMbmsStreamingManagerCallback listener, String streamingAppName, int subscriptionId) { 
<|del|> 
 private static final String TYPE_NAME = "name"; private static final String TYPE_PHONE = "phone"; private static final String TYPE_EMAIL = "email"; private static final String TYPE_ADDRESS = "address"; 
 // For 464xlat traffic, xt_qtaguid sees every IPv4 packet twice, once as a native IPv4 // packet on the stacked interface, and once as translated to an IPv6 packet on the 
 // packet needs to be subtracted from the root UID on the base interface both for tx 
 // packet needs to be subtracted from the root UID on the base interface both for tx 
 // packet needs to be subtracted from the root UID on the base interface both for tx 
 // packet needs to be subtracted from the root UID on the base interface both for tx 
<|del|> 
 // To account correctly for on-the-wire traffic, add the 20 additional bytes difference 
 // TODO: to improve testability and avoid global state, do no use a static variable. 
 adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA); adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA); 
 int nsdState = isEnabled ? NsdManager.NSD_STATE_ENABLED : NsdManager.NSD_STATE_DISABLED; intent.putExtra(NsdManager.EXTRA_NSD_STATE, nsdState); 
 for (Object keyObject : bc.keySet()) { String key = (String) keyObject; 
<|del|> 
 // BEGIN Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' 
 // END Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n' 
<|del|> 
<|del|> 
 } 
 // BEGIN Android-changed: Specify Class objects rather for oidMap rather than String // literals + reflection. 
<|del|> 
 // BEGIN Android-changed: Keep sort order of RDN from Android M 
 * Boot completed receiver. used to disable the application if the device doesn't 
 if (Intent.ACTION_BOOT_COMPLETED.equals(action)) { 
 if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_ANY)) { 
 NetworkStats.Entry adjust = 
 * @return libavb version in bootloader. Format is {@code x.y}. 
 if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) { 
 key = nextListenerKey(); 
<|del|> 
 * Selects an application listed in the Play Store. 
 int minApiVersion = 21; if (thisApiVersion < minApiVersion) { Log.w(TAG, String.format("API version is less than %d, no tests running", minApiVersion)); 
 List<UnitTest> validUnitTests = new ArrayList<>(); Iterable<Class<? extends UnitTest>> testClasses = 
 UnitTest.checkDuplicateNames(validUnitTests); return validUnitTests; 
 * Returns the list of subclasses of UnitTest to run. * * Filters out any tests with API version greater than current API version. */ 
 if (thisApiVersion < 21) { Log.w(TAG, "API version is less than 21, no tests running"); 
 * Throws RuntimeException if any tests have the same name. */ 
 if (thisApiVersion >= 19) { 
<|del|> 
 * Returns the list of subclasses of UnitTest to run. */ 
 Assert.assertTrue(mTest.getSuccess()); 
 * Copyright (C) 2017 The Android Open Source Project 
 MetricsLogger.histogram(context, "ota_non_ab_error_code", errorCode); 
 } else if (line.startsWith("temperature_end")) { 
<|del|> 
<|del|> 
 filter = new IntentFilter(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); mContext.registerReceiver(mReceiver, filter); filter = new IntentFilter(Intent.ACTION_SETTING_RESTORED); mContext.registerReceiver(mReceiver, filter); 
 // apk/odex location (the reason for the '-'. A positive value means // the 'oat' location). 
<|del|> 
 /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #2 
 /// CHECK-NEXT: ldr q{{[0-9]+}}, [x{{[0-9]+}}, x{{[0-9]+}}] 
 /// CHECK: IntermediateAddressIndex /// CHECK-NEXT: add w{{[0-9]+}}, w{{[0-9]+}}, w{{[0-9]+}}, lsl #2 
 b[i] = (float) a[i]; 
 b[i] = (float) a[i]; 
 sum += a[i] + b[i] + (int) c[i]; 
// Android-removed: List of classes for use with attribute keys; Android doesn't have those. // Android-removed: "Summary of attributes" section. Android doesn't have the referenced classes. 
 // Android-removed: Don't link to java.awt.Font class, it doesn't exist on Android. 
 // Android-removed: References to classes that don't exist on Android. // These classes were AffineTransform, Font, and TransformAttribute. 
 // Android-removed: Don't link to java.awt.Font class, it doesn't exist on Android. 
 // Android-removed: References to java.awt.im.InputMethodHighlight (doesn't exist on Android). 
 if (DBG) Slog.d(TAG, "Restore Bluetooth state to disabled"); 
 if (DBG) Slog.d(TAG, "Restore Bluetooth state to enabled"); 
 private static final int MESSAGE_RESTORE_USER_SETTING = 500; 
 Message msg = mHandler.obtainMessage(MESSAGE_RESTORE_USER_SETTING, newValue.equals("0") ? RESTORE_SETTING_TO_OFF : RESTORE_SETTING_TO_ON, 0); mHandler.sendMessage(msg); 
 Slog.e(TAG,"Unable to change Bluetooth On setting", e); 
<|del|> 
 int subscriptionId) throws RemoteException { 
 int subscriptionId) throws RemoteException { 
 * Note that subsequent calls with the same uid, appName and subId will replace 
 fd = IoBridge.open(name, imode); 
 case CMD_TETHER_MODE_UNREQUESTED: { 
 // Ensure double induction does not "overshoot" the subscript range. 
<|del|> 
 final String baseIface = sStackedIfaces.valueAt(i); if (!stackedIface.startsWith(CLATD_INTERFACE_PREFIX)) { continue; } 
 assertEquals("App traffic should be ~100MB", 110553449, appRxBytesAfter - appRxBytesBefore); 
 assertEquals("UID 0 traffic should be ~0", 4623, rootRxBytesAfter - rootRxBytesBefore); 
 MediaController controller = (info == null) ? null : info.getMediaController(); 
 expectEquals(0x07ffffff, a[i], "shrMinus254"); 
 expectEquals(0x07ffffffffffffffL, a[i], "shrMinus254"); 
 "android.bluetooth.input.profile.action.IDLE_TIME_CHANGED"; 
 public static final String EXTRA_IDLE_TIME = "android.bluetooth.BluetoothInputDevice.extra.IDLE_TIME"; 
<|del|> 
 * have an associated DEX cache. 
 protected HostnameVerifier hostnameVerifier; // END Android-changed: Use lazily-created OkHttp hostname verifier 
 if (ni == null || !ni.isConnected()) { 
 final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || (netInfo != null && !netInfo.isConnected())) return; 
 final NetworkInfo netInfo = mConnManager == null ? null : mConnManager.getActiveNetworkInfo(); if (!isAutomaticTimeRequested() || (netInfo != null && !netInfo.isConnected())) return; 
// Android-changed: We don't implement this permission system on Android. 
 mCM = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); 
 private class NetworkTimeUpdateCallback extends ConnectivityManager.NetworkCallback { 
 private class NetworkTimeUpdateCallback extends ConnectivityManager.NetworkCallback { 
 } @Override public void onLost(Network network) { mNetworkValidated = false; } 
 if (!isAutomaticTimeRequested() || 
 // useMetadata argument byte is required. if (numBytes != 1) { sendResponseCode(apdu, (short)0x0200); 
<|del|> 
<|del|> 
<|del|> 
 public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { mNetworkValidated = netCap.hasCapability( 
 public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { mNetworkValidated = netCap.hasCapability( 
 public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { mNetworkValidated = netCap.hasCapability( 
 // TODO: narrow type vectorization. /// CHECK-START: void Main.doitMax(byte[], byte[], byte[]) loop_optimization (after) /// CHECK-NOT: VecMax 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private void recordAndEmit(Category category, String msg) { 
<|del|> 
 private boolean mHasTelephonyManager; 
 * Returns the paths of the optimized files generated for {@code fileName}. * If no optimized code exists the method returns null. 
 public static native String[] getDexFileOutputPaths(String fileName, String instructionSet) 
 files = DexFile.getDexFileOutputPaths(baseCodePath, arch); 
 for (String file : files) { pf = pinFile(file, 0, 0, MAX_CAMERA_PIN_SIZE); 
 for (String file : files) { pf = pinFile(file, 0, 0, MAX_CAMERA_PIN_SIZE); 
 context.registerReceiver(mReceiver, userRemovedFilter); 
 public IPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList) { 
 public void e(String msg) { Log.e(mTag, record(Category.ERROR, msg)); 
<|del|> 
 "CALL_PHONE permission required to place calls.")) { 
 if (category != Category.NONE) sj.add(category.toString()); 
 * Verify connectivity between the local gateway server and the remote * federation server. 
 * Ask the remote federation server to * add the local server to its list of peers. 
public class Application { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 return clients.getCDSClient().createSolution(solution); 
public class Clients { 
 * @param is The data to put. Implementations must close the input stream. 
 * @param is The data to put. Implementations must close the input stream. 
 private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 log.warn("Rejecting invalid request {}: {} {} {}", request.getRequestURI(), badRequest.getMessage(), badRequest.getCode(), badRequest); 
 private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
public class Security extends WebSecurityConfigurerAdapter { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 myself.setStatusCode(PSC_UNKNOWN); log.error("Cannot determine 'self' peer", e); 
 HttpServletRequest httpRequest = request; 
 && !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken) && validateToken(jwtTokenVO, secretKey)) { //validate token 
 /** * Demonstrates use of the Federation (public "E5" interface) and * Gateway (private internal interface) clients. */ 
 FederationClient fedclient = new FederationClient(peerApiUrl, cconf); System.out.println("Checking connectivity to remote acumos using public E5 interface"); System.out.println("Response from remote acumos is " + fedclient.ping()); 
<|del|> 
 /** * This method will check if the NiFi POD is running or not * @param acumosLoginId * Accepts acumosLoginId as parameter * @return * boolean as true/false */ 
 /** * This method will create the Instance of NiFi * @param acumosLoginId * Accepts acumosLoginId as parameter * @return * NiFi URL */ 
 /** * This method will put the create request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ 
 /** * This method will remove the create request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ 
 /** * This method will put update request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ 
 /** * This method will remove update request * @param requestId * Accepts the requestId as parameter * @param pipeline * Accepts the pipeline as parameter */ 
 /** * This method will put delete request * @param requestId * Accepts the requestId as parameter * @param pipelineId * Accepts the pipelineId as parameter * */ 
 /** * Constructor */ 
 /** * This method will Add Create Request * @param key * Accepts key as parameter * @param value * Accepts value as parameter */ 
 gdmServiceImpl.createDeployGDM(cdump, nodeId, userId); } catch (ServiceException e) { e.printStackTrace(); } 
import static org.junit.Assert.*; 
<|del|>
 JWTAuthorizationFilter jwtAuthorizationFilter = new JWTAuthorizationFilter(authenticationManagerBean(), conf.getJwtSecretKey(), cdsClient); 
 * To Validate the Input for * 
 * To Validate the Input Data * 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 @Test() 
<|del|> 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 @ApiOperation(value = "List out all the Models that belongs to user") 
import org.springframework.web.client.RestClientResponseException; 
 @ExceptionHandler(AssociationException.class) public final ResponseEntity<?> handleAssociationExistsException(AssociationException ex, WebRequest request) { 
 * To validate the input Json value of Model 
 public static final String PROJECTID = "projectId"; 
 // TODO : Current logic returns the first operation's input msg name, but need to update the logic to return the connected port input message name 
 logger.debug(EELFLoggerDelegator.debugLogger," SolutionRevisonId for Version : " + solutionRevisionId); 
 // Read the entry and write it to the temp jar. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * 
<|del|> 
<|del|> 
 NetworkingUtil.readBytes(socketChannel, buf, requestSize); 
 public static int getTxnIdFromLogAckMessage(String msg) { return Integer.parseInt(msg.substring(msg.indexOf(LOG_REPLICATION_ACK) + 1)); 
 ctx.btreePred.setHighKeyComparator(ctx.prefixSearchCmp); 
<|del|> 
 rangeCursors[i].close(); 
 }); 
 BUILT_IN_REPLICATION_STRATEGY.put("none", NoReplicationStrategy.class); 
 return indexSet; 
 ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { if (dsr.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dsr.getDatasetInfo()); 
 ArrayList<DatasetResource> openDatasets = new ArrayList<>(datasets.values()); for (DatasetResource dsr : openDatasets) { if (dsr.getDatasetID() >= getFirstAvilableUserDatasetID()) { closeDataset(dsr.getDatasetInfo()); 
 for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { 
 for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { 
 for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { 
 for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { 
 for (Entry<Integer, Pair<PrimaryIndexOperationTracker, IModificationOperationCallback>> e : primaryIndexTrackers .entrySet()) { 
 public static Triple<ILogicalExpression, ILogicalExpression, Boolean> createSearchKeyExpr(Index index, 
 Thread.currentThread().interrupt(); throw HyracksDataException.create(e); 
 Thread.currentThread().interrupt(); throw HyracksDataException.create(e); 
 closeIndex(iInfo); 
 closeIndex(iInfo); 
<|del|> 
 writeEntityResource(buffer); writeEntityValue(buffer); 
 private void writeEntityValue(ByteBuffer buffer) { 
 private void writeEntityValue(ByteBuffer buffer) { 
 private void writeEntityResource(ByteBuffer buffer) { 
 if (readEntityResource(buffer) && readEntityValue(buffer)) { 
 if (readEntityResource(buffer)) { return readUpdateInfo(buffer); 
 if (readEntityResource(buffer)) { return readUpdateInfo(buffer); 
 if (buffer.remaining() < ENTITY_VALUE_HEADER_LEN) { 
<|del|> 
 private boolean readEntityResource(ByteBuffer buffer) { //attempt to read in the resourcePartition and dsid if (buffer.remaining() < ENTITY_RESOURCE_HEADER_LEN) { 
 private boolean readEntityResource(ByteBuffer buffer) { //attempt to read in the resourcePartition and dsid if (buffer.remaining() < ENTITY_RESOURCE_HEADER_LEN) { 
 private boolean readEntityResource(ByteBuffer buffer) { //attempt to read in the resourcePartition and dsid if (buffer.remaining() < ENTITY_RESOURCE_HEADER_LEN) { 
 lsmAccessor.updateFilter(prevTuple); 
 SEARCH, FILTER_MOD, 
<|del|> 
<|del|> 
<|del|> 
 //Nothing to do there, not testing filters 
 boolean secondaryKeyFieldUsedAfterSelectOrJoinOp; 
 boolean doesSIdxSearchCoverAllPredicates; 
 throws AlgebricksException { 
 public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef) throws AlgebricksException { 
 } else { 
 } else { 
 if (cmp != 0 || normalizedKeyDecisive) { 
 throw HyracksDataException.create(e); 
 if (dsType != DataSource.Type.INTERNAL_DATASET && dsType != DataSource.Type.EXTERNAL_DATASET) { 
<|del|> 
 IModificationOperationCallback { 
 return createAccessor(createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), 
 return createAccessor(createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), 
 if (!logged) { 
 if (!logged) { 
 if (!logged) { 
<|del|> 
 if (!logged) { 
<|del|> 
 LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) iap.getModificationCallback()), 
 LSMRTreeOpContext opCtx = createOpContext(((IExtendedModificationOperationCallback) iap.getModificationCallback()), 
 createOpContext((IExtendedModificationOperationCallback) iap.getModificationCallback(), iap.getSearchOperationCallback()); 
 flushDatasetOpenIndexes(dsr, false); 
 flushDatasetOpenIndexes(dsr, false); 
 } 
 opCallback.after(tuple); logged = true; 
<|del|> 
 throw new IllegalStateException(); 
 throw new IllegalStateException(); 
 throw new IllegalStateException(); 
 Thread.sleep(25); // NOSONAR Sleep so some reads are successful 
 invListRangeSearchCursor.close(); isInvListCursorOpen = false; 
 throw new IllegalStateException(); 
 throw new IllegalStateException(); 
 throw new IllegalStateException(); 
 CachedPage cPage = findPage(dpid, false); 
 CachedPage cPage = findPage(dpid, false); 
<|del|> 
 boolean failed = failedShared.getValue(); failedShared.setValue(Boolean.TRUE); 
 + " operator descriptors. Currently, nested plans can only consist in linear pipelines of " + "Asterix micro operators."); 
 SubplanRuntimeFactory runtime = new SubplanRuntimeFactory(np, missingWriterFactories, inputRecordDesc, recDesc, null); 
 public void setInputRecordDescriptor(int index, RecordDescriptor recordDescriptor) { // input is not accessed 
 public List<IOperatorDescriptor> getMetaOps() { 
 public static final IIPCEventListener INSTANCE = new NoOpIPCEventListener(); private NoOpIPCEventListener() { } 
 public BloomFilterBuilder(long estimatedNumElemenets, int numHashes, int numBitsPerElement) throws HyracksDataException { 
 JobId runJobId = runTest(spec, new ExceptionOnCreatePushRuntimeOperatorDescriptor(spec, 0, 1, new int[] { 4 }, true)); 
<|del|> 
 if (LOGGER.isDebugEnabled()) { LOGGER.debug("result reading successful(" + resultState.getResultSetPartitionId() + ")"); 
 * Gets the required result properties of the request. * * @return the result properties 
 * @return the min tuple of the corresponding component's filter 
public interface ILSMIndexCursor extends IIndexCursor { 
 Object annotation = op2.getAnnotations().get("isMovable"); 
<|del|> 
<|del|> 
<|del|> 
 } catch (ClosedByInterruptException | InterruptedException e) { 
 void run() throws IOException, InterruptedException; 
 this.ncServiceCtx.setMessagingChannelInterfaceFactory(interfaceFactory); 
 this.ncServiceCtx.setMessagingChannelInterfaceFactory(interfaceFactory); 
 + "micro operators."); 
 "Can only generate jobs for pipelinable nested plans, not for " + opd 
 throw new IllegalStateException("Unexpected nested plan"); 
 super.contributeRuntimeOperator(builder, context, op, opSchema, inputSchemas, outerPlanSchema); 
 throw new IllegalStateException("Invalid pipeline"); 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xff) { n >>>= 8; log |= 8; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 0xf) { n >>>= 4; log |= 4; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 if (n > 3) { n >>>= 2; log |= 2; } 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
 return log + (n >>> 1); 
<|del|> 
 public void notifyThreadDump(String nodeId, String threadDumpJSON) throws Exception; 
<|del|> 
 } catch (Throwable failFailure) {// NOSONAR: Must maintain all stacks failure = ExceptionUtils.suppress(failure, failFailure); } } finally { try { 
<|del|> 
 return new LSMRTreeAccessor(getHarness(), 
 } if (failure != null) { throw HyracksDataException.create(failure); } 
 } if (failure != null) { throw HyracksDataException.create(failure); } 
 } catch (Throwable th) { // NOSONAR. Must destroy all cursors 
 } catch (Throwable th) { // NOSONAR. Don't lose the root cause 
 private DestroyUtils() { } 
 } catch (Throwable th) { // NOSONAR must destroy all 
 } catch (Throwable th) { // NOSONAR must destroy all 
 } catch (Throwable th) { // NOSONAR must destroy all 
 // In case we must keep the deleted-keys BTrees, then they must be merged // *before* merging the r-trees so that 
 // Keep the deleted tuples since the oldest disk component // is not included in the merge operation 
 if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call hasNext() on a cursor in the state " + state); 
 if (ENFORCE_NEXT_HAS_NEXT && state != State.OPENED) { throw new IllegalStateException("Cannot call next() on a cursor in the state " + state); 
<|del|> 
<|del|> 
 LOGGER.info(rec); 
 LOGGER.log(Level.SEVERE, "Some jobs failed to exit, continuing shutdown abnormally"); 
 return; } 
 private static final int CC_BITS = Short.SIZE; private static final int ID_BITS = Long.SIZE - CC_BITS; static final long MAX_ID = (1L << ID_BITS) - 1; 
 private static final int CC_BITS = Short.SIZE; private static final int ID_BITS = Long.SIZE - CC_BITS; static final long MAX_ID = (1L << ID_BITS) - 1; 
<|del|> 
 private static class DatasetInputChannelMonitor implements IInputChannelMonitor { 
 private static final int PARTITION_ID = 0; 
 /** * @return the component files produced by this operation */ 
 private boolean isDiskComponentScan; 
 public void doDestroy() throws HyracksDataException { if (btreeCursors != null) { for (int i = 0; i < numBTrees; ++i) { if (btreeCursors[i] != null) { btreeCursors[i].destroy(); } 
 currentCursor = lsmInitialState.isDiskComponentScan() ? scanCursor : btreePred.isPointPredicate(lsmInitialState.getOriginalKeyComparator()) ? pointCursor : rangeCursor; 
 public boolean initFromSubTree(Mutable<ILogicalOperator> subTreeOpRef) throws AlgebricksException { 
 throw CompilationException.create(ErrorCode.CANNOT_SERIALIZE_A_VALUE, e); 
<|del|> 
<|del|> 
<|del|> 
 ILSMOperationTracker getPrimaryOperationTracker(int datasetID, int partition); 
 Thread.currentThread().interrupt(); throw HyracksDataException.create(e); 
 Thread.currentThread().interrupt(); throw HyracksDataException.create(e); 
 public synchronized Set<ILSMIndex> getDatasetPartitionOpenIndexes(int partition) { 
 return "JID[" + (id >>> ID_BITS) + ":" + getIdOnly() + "]"; 
<|del|> 
 boolean secondaryKeyFieldUsedAfterSelectOrJoinOp; 
 boolean doesSIdxSearchCoverAllPredicates; 
 private class AbstractSTSingleGeometryEvaluator implements IScalarEvaluator { 
 private class STGeomFromWKBEvaulator implements IScalarEvaluator { 
 return new STPolygonizeEvaluator(args, ctx); } }; } 
 return Objects.hash(first, second, third, fourth); 
 Quadruple<?, ?, ?, ?> quadruple = (Quadruple<?, ?, ?, ?>) o; return Objects.equals(first, quadruple.first) && Objects.equals(second, quadruple.second) && Objects.equals(third, quadruple.third) && Objects.equals(fourth, quadruple.fourth); 
 return currentElementIx < numElements; 
public abstract class EnforcedIndexCursor implements IIndexCursor { 
 public void initialize(INcApplicationContext runtimeContext, 
class CcTxnIdFactory implements ITxnIdFactory { private static final int TXN_BLOCK_SIZE = 1024; 
 // retry LOGGER.info("block exhausted; obtaining new block from supplier"); 
 IAsterixStateProxy proxy; if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Bootstrapping metadata"); } 
 proxy = (IAsterixStateProxy) getServiceContext().getDistributedState(); if (proxy == null) { 
 public MetadataTransactionContext beginTransaction() throws RemoteException { 
class CcTxnIdFactory implements ITxnIdFactory { private static final int TXN_BLOCK_SIZE = 1024; 
 queue.stop(); if (ncAppEntryPoint != null) { ncAppEntryPoint.stop(); 
 /** 
 // In case we must keep the deleted-keys BTrees, then they must be merged *before* merging the inverted // indexes so that lsmHarness.endSearch() is called once when the inverted indexes have been merged. 
<|del|> 
 --referenceCount; if (referenceCount < 0) { throw new IllegalStateException("Unreferencing an unreferenced object"); } 
 threads.add(new Throwable().getStackTrace()); 
 * All other calls after this method is invoked is undefined 
 ARecordType metaRecordType, ILogicalOperator unnestMapOp, Index index, secondaryUnnestMapOutputVarType keyVarType) throws AlgebricksException { 
 // If a secondary-index search didn't generate SKs, set it to zero. // Currently, only an inverted-index search doesn't generate any SKs. boolean isNgramOrKeywordIndex = isInvertedIndex(index); if (isNgramOrKeywordIndex) { 
 stop = start + 1; 
 if (realTypeConvertedToIntegerType && !index.isEnforced() && !index.isOverridingKeyFieldTypes()) { 
 } else if (!realTypeConvertedToIntegerType) { // Type conversion only case: (e.g., INT -> BIGINT) 
<|del|> 
 boolean success = true; try { Throwable exception = null; 
 TxnIdBlockRequest.Block newBlock; 
 long maxTxnId = appContext.getMaxTxnId(); 
 } catch (Throwable ignore) { // NOSONAR Logging exception will be ignored // NOSONAR ignore 
 } catch (Throwable ignore) { // NOSONAR Logging exception will be ignored // NOSONAR ignore 
 @FunctionalInterface 
 * The behavior of other calls after this method is invoked is undefined 
 } catch (Throwable ignore) { 
 } catch (Throwable ignore) { 
<|del|> 
 root = close(indexHelpers.get(i), root); 
 HyracksDataException.throwIfNotNull(failure); 
 throw HyracksDataException.create(closeException); 
 throw HyracksDataException.create(closeException); 
 throw HyracksDataException.create(closeException); 
 HyracksDataException.throwIfNotNull(failure); 
 } catch (Throwable ignore) { // NOSONAR Logging exception will be ignored // NOSONAR ignore 
 } catch (Throwable ignore) { 
 HyracksDataException.throwIfNotNull(failure); 
 * public TestRule watcher = new TestMethodTracer(Level.INFO); * </code> 
<|del|> 
<|del|> 
<|del|> 
 failure = DestroyUtils.destroy(failure, insertSearchCursor, memCursor); 
 failure = DestroyUtils.destroy(failure, insertSearchCursor, memCursor); 
 failure = DestroyUtils.destroy(failure, insertSearchCursor, memCursor); 
 LOGGER.info("Installed function: " + functionFullName); 
 public String getParamsString(); 
 private final String paramsString; 
 curPage++; 
 } if (!shutdownStart) { pageCleanerPolicy.notifyCleanCycleFinish(threadLock); } 
 try { synchronized (cleanerThread.threadLock) { cleanerThread.shutdownStart = true; cleanerThread.threadLock.notifyAll(); while (!cleanerThread.shutdownComplete) { cleanerThread.threadLock.wait(); 
 int pinCount; 
 if (partitionCursors[i] == null) { 
 private static final int TABLE_FRAME_SIZE = 32768; private static final int TABLE_SIZE = 100; 
 argPointables = new IPointable[args.length]; argRecordPointables = new ARecordVisitablePointable[args.length]; openRecordPointable = new ARecordVisitablePointable(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); 
 enum SecondaryUnnestMapOutputVarType { 
 throw CompilationException.create(ErrorCode.CANNOT_GET_CONDITIONAL_SPLIT_KEY_VARIABLE); 
 unnestMapMemorySize += textSearchMemorySize; 
 root = ExceptionUtils.suppress(root, th); // NOSONAR 
 root = ExceptionUtils.suppress(root, th); // NOSONAR 
 default IChannelClosedHandler getChannelCloseHandler(HttpServer server) { return server.getChannelCloseHandler(); 
 ncs.getWorkQueue().schedule(new EnsureAllCcTasksCompleted(ncs, ccId, abortedTasks)); 
<|del|> 
 public JRecord(ARecordType recordType, IJObject[] fields, Map<String, IJObject> openFields) { 
 public void reset(IJObject[] fields, Map<String, IJObject> openFields) throws HyracksDataException { 
 private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { 
 private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { 
 private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { 
 private JBuiltinType(){ // no op } public static final JBuiltinType JBOOLEAN = new JBuiltinType() { 
 public static final JBuiltinType JBYTE = new JBuiltinType() { 
 public static final JBuiltinType JBYTE = new JBuiltinType() { 
 public static final JBuiltinType JBYTE = new JBuiltinType() { 
 public static final JBuiltinType JCIRCLE = new JBuiltinType() { 
 public static final JBuiltinType JCIRCLE = new JBuiltinType() { 
 public static final JBuiltinType JCIRCLE = new JBuiltinType() { 
 public static final JBuiltinType JDATE = new JBuiltinType() { 
 public static final JBuiltinType JDATE = new JBuiltinType() { 
 public static final JBuiltinType JDATE = new JBuiltinType() { 
 public static final JBuiltinType JDATETIME = new JBuiltinType() { 
 public static final JBuiltinType JDATETIME = new JBuiltinType() { 
 public static final JBuiltinType JDATETIME = new JBuiltinType() { 
 public static final JBuiltinType JDOUBLE = new JBuiltinType() { 
 public static final JBuiltinType JDOUBLE = new JBuiltinType() { 
 public static final JBuiltinType JDOUBLE = new JBuiltinType() { 
 public static final JBuiltinType JDURATION = new JBuiltinType() { 
 public static final JBuiltinType JDURATION = new JBuiltinType() { 
 public static final JBuiltinType JDURATION = new JBuiltinType() { 
 public static final JBuiltinType JFLOAT = new JBuiltinType() { 
 public static final JBuiltinType JFLOAT = new JBuiltinType() { 
 public static final JBuiltinType JFLOAT = new JBuiltinType() { 
 public static final JBuiltinType JINT = new JBuiltinType() { 
 public static final JBuiltinType JINT = new JBuiltinType() { 
 public static final JBuiltinType JINT = new JBuiltinType() { 
 public static final JBuiltinType JINTERVAL = new JBuiltinType() { 
 public static final JBuiltinType JINTERVAL = new JBuiltinType() { 
 public static final JBuiltinType JINTERVAL = new JBuiltinType() { 
 public static final JBuiltinType JLINE = new JBuiltinType() { 
 public static final JBuiltinType JLINE = new JBuiltinType() { 
 public static final JBuiltinType JLINE = new JBuiltinType() { 
 public static final JBuiltinType JLONG = new JBuiltinType() { 
 public static final JBuiltinType JLONG = new JBuiltinType() { 
 public static final JBuiltinType JLONG = new JBuiltinType() { 
 public static final JBuiltinType JMISSING = new JBuiltinType() { 
 public static final JBuiltinType JMISSING = new JBuiltinType() { 
 public static final JBuiltinType JMISSING = new JBuiltinType() { 
 public static final JBuiltinType JNULL = new JBuiltinType() { 
 public static final JBuiltinType JNULL = new JBuiltinType() { 
 public static final JBuiltinType JNULL = new JBuiltinType() { 
 public static final JBuiltinType JPOINT = new JBuiltinType() { 
 public static final JBuiltinType JPOINT = new JBuiltinType() { 
 public static final JBuiltinType JPOINT = new JBuiltinType() { 
 public static final JBuiltinType JPOINT3D = new JBuiltinType() { 
 public static final JBuiltinType JPOINT3D = new JBuiltinType() { 
 public static final JBuiltinType JPOINT3D = new JBuiltinType() { 
 public static final JBuiltinType JPOLYGON = new JBuiltinType() { 
 public static final JBuiltinType JPOLYGON = new JBuiltinType() { 
 public static final JBuiltinType JPOLYGON = new JBuiltinType() { 
 public static final JBuiltinType JRECTANGLE = new JBuiltinType() { 
 public static final JBuiltinType JRECTANGLE = new JBuiltinType() { 
 public static final JBuiltinType JRECTANGLE = new JBuiltinType() { 
 public static final JBuiltinType JSHORT = new JBuiltinType() { 
 public static final JBuiltinType JSHORT = new JBuiltinType() { 
 public static final JBuiltinType JSHORT = new JBuiltinType() { 
 public static final JBuiltinType JSTRING = new JBuiltinType() { 
 public static final JBuiltinType JSTRING = new JBuiltinType() { 
 public static final JBuiltinType JSTRING = new JBuiltinType() { 
 public static final JBuiltinType JTIME = new JBuiltinType() { 
 public static final JBuiltinType JTIME = new JBuiltinType() { 
 public static final JBuiltinType JTIME = new JBuiltinType() { 
 ACircleSerializerDeserializer.INSTANCE.serialize((AMutableCircle) value, dataOutput); 
 ADateSerializerDeserializer.INSTANCE.serialize((AMutableDate) value, dataOutput); 
 ADateTimeSerializerDeserializer.INSTANCE.serialize((AMutableDateTime) value, dataOutput); 
 ADurationSerializerDeserializer.INSTANCE.serialize((AMutableDuration) value, dataOutput); 
 AIntervalSerializerDeserializer.INSTANCE.serialize((AMutableInterval) value, dataOutput); 
 ALineSerializerDeserializer.INSTANCE.serialize((AMutableLine) value, dataOutput); 
 public void reset() { // no op for NULL 
 APoint3DSerializerDeserializer.INSTANCE.serialize((AMutablePoint3D) value, dataOutput); 
 } else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR 
 } else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR 
 } else if (f == Float.NEGATIVE_INFINITY) { // NOSONAR 
 } else if (f == Float.NEGATIVE_INFINITY) { // NOSONAR 
 } else if (d == Double.NEGATIVE_INFINITY) { // NOSONAR 
 } else if (f == Float.NEGATIVE_INFINITY) { // NOSONAR 
 flushIfNeeded(); 
 } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure 
 } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure 
 root = ExceptionUtils.suppress(root, th); // NOSONAR 
 } catch (InterruptedException e) { // NOSONAR: The call below will re-interrupt 
 } catch (Throwable th) { // NOSONAR: This method must never throw anything 
 while (true) { // NOSONAR: Suppress 1 continue and 1 break 
 } catch (InterruptedException e) { // NOSONAR: This is not supposed to be ever interrupted 
 } catch (Throwable th) { // NOSONAR Will be suppressed 
 } catch (Throwable loggingFailure) { // NOSONAR: Ignore catching Throwable // NOSONAR ignore logging failure 
 waf = File.createTempFile(prefix, WORKSPACE_FILE_SUFFIX, new File(dev.getMount(), waPath)); 
 } catch (InterruptedException e) { // NOSONAR: This is not supposed to be ever interrupted 
 LOGGER.error("Error in TCPEndpoint {}", localAddress, e); 
<|del|> 
 public void testFlushMetadataOnlyComponent() { 
 public static boolean equals(IValueReference first, IValueReference second) { // NOSONAR 
 String configPath = Paths.get(System.getProperty("user.dir"), "src", "test", "resources", "cc.conf").toString(); 
 if (ncJvmArgs == null || !ncJvmArgs.contains(JVM_ARG_MAX_GCPAUSE_MILLIS)) { String gcMaxPauseArg = JVM_ARG_MAX_GCPAUSE_MILLIS + getGcMaxPauseMillis(); 
 if (ncJvmArgs == null || !ncJvmArgs.contains(JVM_ARG_MAX_GCPAUSE_MILLIS)) { String gcMaxPauseArg = JVM_ARG_MAX_GCPAUSE_MILLIS + getGcMaxPauseMillis(); 
 return externalFunctionParameters.getOrDefault(dataverseName + "." + fullFunctionName, Collections.emptyList()); 
 FunctionSignature signature = new FunctionSignature(dataverse, functionFullName, args.size()); 
 opts.forEach(opt -> ncConfigManager.set(nodeId, opt.getLeft(), opt.getRight())); 
 long before = System.nanoTime(); 
 long before = System.nanoTime(); 
 public synchronized void afterFinalize(LSMOperationType opType, ILSMDiskComponent newComponent) throws HyracksDataException { 
 public void afterFinalize(ILSMIndexOperationContext opCtx) throws HyracksDataException { 
 btreeLeafFrameFactory, (IExtendedModificationOperationCallback) iap.getModificationCallback(), 
<|del|> 
 IAsterixListBuilder listBuilder = new OrderedListBuilder(); 
 private boolean aBoolean; 
 return (AMutableRectangle) value; 
 public String getInitParameters() { return initParameters; 
 writer.open(); open = true; 
<|del|> 
<|del|> 
 }); 
 throw new TimeoutException("Stop condition was not met after " + unit.toSeconds(timeout) + " seconds."); 
 return compareStringBinValues(a, b, comparator) == 0; 
 return comparator.compare(a.getByteArray(), a.getStartOffset() + 1, a.getLength() - 1, b.getByteArray(), 
 IndexCursorUtils.close(btreeCursors[i], th); 
 root = ExceptionUtils.suppress(root, th); // NOSONAR: Using the same variable is not bad in this context 
 IndexCursorUtils.close(cursors[j], th); 
 IndexCursorUtils.close(cursors[j], th); 
 th = IndexCursorUtils.close(cursors[j], th); // NOSONAR: Using the same variable is cleaner in this context 
 * 
 root = ExceptionUtils.suppress(root, th); 
 List<Future<Void>> tasks = new ArrayList<>(operatorNodePushablesBFSOrder.size()); Queue<Throwable> failures = new ArrayBlockingQueue<>(operatorNodePushablesBFSOrder.size()); 
<|del|> 
 failures.offer(th); 
 void completed(TxnId id); 
 void completed(TxnId id); 
 * job to ensure that the checkpointing coexists peacefully * with other concurrent readers of the log that request 
<|del|> 
 void completed(TxnId id); 
 } fileChannel.close(); 
 while (!Thread.currentThread().isInterrupted()) { 
 securedLSNs = new HashMap<>(); 
 synchronized (txnSubsystem.getRecoveryManager()) { 
 throw new IllegalStateException("Unlock on nonexisting LSN"); 
 final IBinaryComparator stringBinaryComparator = PointableHelper.createStringBinaryComparator(); 
 final IBinaryComparator stringBinaryComparator = PointableHelper.createStringBinaryComparator(); 
 IndexCursorUtils.close(btreeCursors[i], th); 
 IndexCursorUtils.close(cursors[j], th); 
 IndexCursorUtils.close(cursors[j], th); 
 } finally { completeSemaphore.acquireUninterruptibly(); 
 logReadFailure(status); throw new IllegalStateException("Unexpected log read status: " + status); 
 return securedLSNs.isEmpty() ? Collections.min(securedLSNs.values()) : -1; 
 /** * Notifies this {@link ICheckpointManager} that the transaction identified by {@code id} completed. * * @param id */ 
<|del|> 
<|del|> 
 } catch (HyracksDataException e) { 
 protected Map<TxnId, Long> securedLSNs; 
 checkpointManager.secure(recoveryTxnId); 
<|del|> 
<|del|> 
<|del|> 
 if (minSecuredLSN != NO_SECURED_LSN && minFirstLSN >= getMinSecuredLSN()) { return minSecuredLSN; 
 return securedLSNs.isEmpty() ? NO_SECURED_LSN : Collections.min(securedLSNs.values()); 
 String threadName = ct.getName(); ct.setName(displayName + ":" + taskAttemptId + ":" + 0); 
 TIMEZONE_OFFSETS[i] = TimeZone.getTimeZone(new String(TIMEZONE_IDS[i], ENCODING)).getRawOffset(); 
 throw new AsterixTemporalTypeParseException("Unexpected timezone string: " + new String( data, dataStart + dataStringPointer, dataStart + timezoneEndField, ENCODING)); 
 throw new AsterixTemporalTypeParseException("Unexpected string for AM/PM marker " + new String(data, dataStart + dataStringPointer, dataStart + dataStringPointer + 2, ENCODING)); 
 return writes - cancelledWrites; 
 } lastTuple.reset(lastTupleBuilder.getFieldEndOffsets(), lastTupleBuilder.getByteArray()); 
 } 
 public IIndexCursor createSearchCursor(boolean exclusive) throws HyracksDataException { if (searcher == null) { searcher = new TOccurrenceSearcher(index, ctx); } return new OnDiskInvertedIndexSearchCursor(searcher); 
 newToken = this.keyTuple == null; 
<|del|> 
 LSMInvertedIndexTestUtils.compareActualAndExpectedIndexesRangeSearch(testCtx); 
 return true; 
 // Current List SerDe assumes a strongly typed list, so we do not constant fold the list constructors // if they are not strongly typed 
 } catch (HyracksDataException | AlgebricksException e) { if (AlgebricksConfig.ALGEBRICKS_LOGGER.isDebugEnabled()) { AlgebricksConfig.ALGEBRICKS_LOGGER.debug("Exception caught at constant folding: " + e, e); } 
 throws AlgebricksException { if (hasRun) { return false; } 
<|del|> 
 catalog_.invalidateTable(new TTableName(dbName, tblName), tblWasRemoved, dbWasAdded); 
 * Create a new profile, setting it as the current thread-local profile for the 
 LOG.warn("gcBean.getLastGcInfo() returned null. Table invalidation based on " + "memory pressure was skipped."); 
 MemoryUsage tenuredGenUsage = lastGcInfo.getMemoryUsageAfterGc().get(oldGcGenName_); Preconditions.checkState(tenuredGenUsage != null); 
 updateOwnerPrivileges(db.getName(), /* tableName */ null, params.server_name, 
 updateDatabasePrivileges(table.getDb().getName(), table.getName(), params.server_name, table.getMetaStoreTable().getOwner(), table.getMetaStoreTable().getOwnerType(), /* newOwner */ null, /* newOwnerType */ null, resp); 
 removedGrantOptPrivileges = catalog_.getSentryProxy() .revokeRolePrivileges(requestingUser, roleName, privileges, grantRevokePrivParams.isHas_grant_opt(), rolePrivileges); 
 List<PrincipalPrivilege> addedRolePrivileges = null; 
 } } else if (privileges.get(0).isHas_grant_opt()) { if (!updatedPrivs.isEmpty() && !removedPrivs.isEmpty()) { 
 public ExpectedException thrown = ExpectedException.none(); 
 * - 2-phase aggregation, 1st phase groups by GROUP BY plus DISTINCT exprs, 2nd phase 
 * It's useful for tests to ensure that a scan happened. 
 LOG.warn("gcBean.getLastGcInfo() returned null. Table invalidation based on " + "memory pressure was skipped."); 
 * can be added for a user. example: owner privileges. 
 LOG.error("Error removing privilege: ", e); 
 LOG.error("Error adding privilege: ", e); 
 Reference<Boolean> existingUser = new Reference<>(); org.apache.impala.catalog.User user = catalog_.addUserIfNotExists(userName, existingUser); if (existingUser.getRef() && resetVersions_) { 
 return getAuthzConfig().isEnabled() ? getAuthzConfig().getServerName() : null; 
 /** * Update the owner privileges for an object. 
 if(oldOwner != null && !oldOwner.isEmpty()) { 
 if(oldOwner != null && !oldOwner.isEmpty()) { 
<|del|> 
 LOG.error("Error removing privilege: ", e); } finally { catalog_.getLock().writeLock().unlock(); 
<|del|> 
 cPrivilege = catalog_.addUserPrivilege(ownerString, filter); if (!existingUser.getRef()) { owner.setCatalogVersion(catalog_.incrementAndGetCatalogVersion()); } 
<|del|> 
 List<PrincipalPrivilege> removedGrantOptPrivileges = Lists.newArrayListWithExpectedSize(privileges.size()); 
 addedRolePrivileges = Lists.newArrayListWithExpectedSize(privileges.size()); 
 List<TCatalogObject> updatedPrivs = Lists.newArrayListWithExpectedSize(addedRolePrivileges.size()); 
 List<TCatalogObject> removedPrivs = Lists.newArrayListWithExpectedSize(removedGrantOptPrivileges.size()); 
 } } else if (privileges.get(0).isHas_grant_opt()) { if (!updatedPrivs.isEmpty() && !removedPrivs.isEmpty()) { 
 return catalog_.getSentryProxy() == null ? false : catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); 
 return catalog_.getSentryProxy() == null ? false : catalog_.getSentryProxy().isObjectOwnershipGrantEnabled(); 
<|del|> 
 try (SentryServiceClient client = new SentryServiceClient()) { 
 if (sentryConfig.getConfigFile() != null && !sentryConfig.getConfigFile().isEmpty()) { 
 if (sentryConfig.getConfigFile() != null && !sentryConfig.getConfigFile().isEmpty()) { 
 private final int nBits; private final BitSet bitSet; private final int nHashes; private final byte[] byteBuffer; private final HashFunction hashFunction; 
 private final int nBits; private final BitSet bitSet; private final int nHashes; private final byte[] byteBuffer; private final HashFunction hashFunction; 
 int nHashes = computeOptimalHashCount(nBits, expectedCount); return new BloomFilter(new BitSet(nBits), nHashes, hashFunction); 
 byteBuffer[0] = (byte)(data ? 1 : 0); updateBitset(byteBuffer, 1); 
 private void updateBitset(byte[] byteBuffer, int length) { assert (byteBuffer.length >= length); 
 long bitPos = tmp % nBits; bitSet.set((int)bitPos); tmp += h2; 
 @InterfaceAudience.LimitedPrivate("Test") 
 long bitPos = tmp % nBits; if (!bitSet.get((int)bitPos)) { 
 tmp += h2; 
 private static double kNaturalLog2 = 0.69314; 
 private static int computeOptimalHashCount(int nBits, int elems) { int nHashes = (int)(nBits * kNaturalLog2 / elems); 
 private long kRandomSeed = System.currentTimeMillis(); 
 public void testFloat() { 
 * Represents an administrative function call, e.g. ": shutdown('hostname:123')". 
 * 6. Release the metastoreDdlLock_ 
<|del|> 
 * An space-efficient filter which offers an approximate containment check. 
 * <p>The {@code BloomFilter} here is a scanning filter and used to constrain the number of records 
 * // TODO: implement the interface for serializing and sending 
 Preconditions.checkArgument(bitSet.size() > 8, "Number of bits in " + "bitset should be at least 8, but found %s.", bitSet.size()); 
 Preconditions.checkArgument(bitSet.size() > 8, "Number of bits in " + "bitset should be at least 8, but found %s.", bitSet.size()); 
 * Generate bloom filter, default hashing is {@code Murmur2} and false positive rate is 0.01. * @param nBytes size of bloom filter in bytes 
 * Generate bloom filter, default hashing is {@code Murmur2} and false positive rate is 0.01. * @param expectedCount The expected number of elements, targeted by this bloom filter. 
 /** * Update bloom filter with a {@code byte[]}. */ 
 /** * Get the name of hashing used when updating or checking containment. */ 
 Preconditions.checkArgument(byteBuffer.length >= length); 
 .error(accessError(true, "functional.alltypes"), onDatabase(true, "functional", allExcept(TPrivilegeLevel.ALL, TPrivilegeLevel.OWNER))) 
 * This is a helper method to take care of catalog related updates when adding * a privilege. This will also add a user to the catalog if it doesn't exist. 
 * This is a helper method to take care of catalog related updates when adding * a privilege. This will also add a user to the catalog if it doesn't exist. 
 Preconditions.checkArgument(bitSet.size() >= 8, "Number of bits in " + 
 public static BloomFilter bySize(int nBytes) { return bySizeAndFPRate(nBytes, DEFAULT_FP_RATE); 
 * ever been {@code put} into the {@code BloomFilter}. 
 .error(accessError(true, "functional.alltypes"), onDatabase(true, "functional", allExcept(TPrivilegeLevel.ALL, TPrivilegeLevel.OWNER))) 
<|del|> 
 return hostname; 
<|del|> 
 LOG.info("Using Kudu binary directory specified by system property '{}': {}", KUDU_BIN_DIR_PROP, kuduHomeProp); 
 LOG.info("Using Kudu home directory specified by environment variable '{}': {}", KUDU_HOME_VAR, kuduHomeVar); 
 // Last, if the `kudu` binary is found on the PATH using `which kudu`, // use its parent directory. 
 final Reader reader = new InputStreamReader(process.getInputStream(), UTF_8); try { 
 owner_ = analyzer.getUserShortName(); 
 private DaemonInfo getMasterServer(HostAndPort hp) throws RuntimeException { DaemonInfo d = masterServers.get(hp); 
 * Tests parsing strings into {@link HostAndPort} objects with and without specifying 
 String kuduBinDirProp = System.getProperty(KUDU_BIN_DIR_PROP); if (kuduBinDirProp != null) { 
 // Creating client with FlumeAuthenticator. 
 kerberosPrincipal, kerberosKeytab).proxyAs(proxyUser); 
 SchemaLocation schemaLocation) throws Exception { 
 ) throws EventDeliveryException { 
 private static final int TICKET_LIFETIME_SECONDS = 10; private static final int RENEWABLE_LIFETIME_SECONDS = 30; 
 this.info_ = Preconditions.checkNotNull(p); 
 this.info_ = Preconditions.checkNotNull(p); 
 predicate = KuduScanNode.normalizeSlotRefComparison(predicate, analyzer); 
 ComparisonOp op = getKuduOperator(((BinaryPredicate)predicate).getOp()); 
<|del|> 
 public static Expr createExpr(FunctionName fnName, FunctionParams params) throws AnalysisException { 
 agg.fnName_, new FunctionParams(false, params), mergeAggInputFn); 
 agg.fnName_, new FunctionParams(false, params), mergeAggInputFn); 
 finalizeParams.setTable_id(DescriptorTable.TABLE_SINK_ID); 
 * only a single DISTINCT grouping, a single AggregateInfo will be created which will * represent that grouping and any non-DISTINCT aggregates. If there is more than one * DISTINCT grouping, the non-DISTINCT aggregates will be grouped together in their own 
 // Singleton instance of this pause monitor. 
 case PRINCIPAL: // The combination of principal_id + privilege_name is guaranteed to be unique. return "PRINCIPAL:" + catalogObject.getPrincipal().getPrincipal_name() .toLowerCase(); 
 expectCardinality("SELECT id FROM functional.alltypes", 7300); 
 protected void expectCardinality(String query, long expected) { 
 assertEquals("Cardinality error for: " + query, expected, planRoot.getCardinality()); 
 planCtx.requestPlanCapture(); 
<|del|> 
 System.out.println(plan.get(0).getExplainString( queryOptions, TExplainLevel.EXTENDED)); 
<|del|>
 numDistinctValues_ = desc_.getStats().getNumDistinctValues(); Table rootTable = resolvedPath.getRootTable(); 
 * This method adds the rows to the output for the SHOW GRANT USER statement for user 
 Role role = getRole(principalName); 
 User user = getUser(principalName); 
<|del|> 
 Model model) { 
 PolicyEngine policy, Model model) { 
 // Above this number, the adjustment is not that helpful. // Further, a higher value causes TPC-H plan tests to 
<|del|> 
 return planCtx.getPlan(); 
 verifyCardinality( "SELECT d FROM functional.alltypes, functional.nullrows", 7300 * 26); 
 verifyCardinality( "SELECT COUNT(*)" + joinClause + "GROUP BY t1.id", 7300); verifyCardinality( "SELECT COUNT(*)" + joinClause + "GROUP BY t1.id, t1.int_col", 7300 * 10); 
 private static Schema schema; 
 @Rule RetryRule retryRule = new RetryRule(); 
 * KuduRule with the default constructor. This is useful 
 for (String flag : tabletServerConfig.flags()) { 
<|del|> 
 asyncClient = new AsyncKuduClientBuilder(miniCluster.getMasterAddressesAsString()) 
 if (client != null) { 
<|del|> 
<|del|> 
 asyncClient = new AsyncKuduClientBuilder(miniCluster.getMasterAddressesAsString()) 
<|del|> 
 } else { 
 !(fs instanceof AzureBlobFileSystem) && !(fs instanceof SecureAzureBlobFileSystem) && 
 // Experiments on a wide partitioned table with incremental stats showed that the // Deflater with 'BEST_SPEED' level provided reasonable compression ratios at much // faster speeds compared to other modes like BEST_COMPRESSION/DEFAULT_COMPRESSION. 
 IMetaStoreClient hmsClient = new HiveMetaStoreClient(hiveConf); 
 Table table = impaladCatalog_.get().getTable(dbName, tableName); 
 Table table = impaladCatalog_.get().getTable(dbName, tableName); 
 Analyzer analyzer, List<TupleId> tupleIds, PlanNode root) { 
 String toSql(ToSqlOptions options); 
<|del|> 
 nodeResourceProfile_ = ResourceProfile.noReservation( getSortInfo().estimateTopNMaterializedSize(cardinality_, offset_)); 
<|del|> 
 return !streamSink.getOutputPartition().isPartitioned() && fragment_.isPartitioned(); 
<|del|> 
public class RewriteConditionalFnsRule implements ExprRewriteRule { 
 * IFNULL(a, x) --> 
 // TODO: IMPALA-7766: Perform constant folding within an expression 
 // Base case, no further simplificatin needed verifySelectRewrite("if(id = 0, id, id+1)", "CASE WHEN id = 0 THEN id ELSE id + 1 END"); 
 return RewritesOkWhereExpr("functional.alltypessmall", exprStr, rule, expectedExprStr); 
 public Expr RewritesOk(String tableName, String exprStr, ExprRewriteRule rule, String expectedExprStr) 
 public Expr RewritesOk(String exprStr, List<ExprRewriteRule> rules, String expectedExprStr) 
 public Expr RewritesOkWhereExpr(String exprStr, ExprRewriteRule rule, String expectedExprStr) 
 public Expr RewritesOkWhereExpr(String tableName, String exprStr, ExprRewriteRule rule, String expectedExprStr) 
 public Expr RewritesOkWhereExpr(String tableName, String exprStr, List<ExprRewriteRule> rules, 
<|del|> 
<|del|> 
 * This should return the same result as calling toSql(ToSqlOptions.DEFAULT). * TODO use an interface default method to implement this when we fully move to Java8. 
 * The default way of displaying the original SQL query without rewrites. 
 StringBuilder ret = new StringBuilder(s.length()); 
 // we keep any existing newlines in text - these should be commented hints 
 * looks as expected. * columnName is the name of a column in functional.alltypesnopart. * data is the literal value to insert. * castColumn is the type to which the literal is expected to be cast. 
<|del|> 
 outDir_.toFile().mkdirs(); FileWriter fw = new FileWriter(outDir_.resolve(testFile + ".test").toFile()); 
 * Wrap length for testWrapText() - less than 80 to make test layout nicer. 
 **/ 
 * Check that code that has been wrapped is correctly formatted. 
 * Check that code that has been wrapped is correctly formatted. 
 * rewrite. 
 * Relies on a round of CASE simplification to perform the * following simplifications after this rewrite: 
 */ @SuppressWarnings("unused") 
 */ 
 if (!expr.getType().isSupported()) { 
 for (Expr child: expr.getChildren()) if (!Expr.IS_LITERAL.apply(child)) return expr; if (Expr.IS_LITERAL.apply(expr) || !expr.isConstant()) return expr; 
 if (Expr.IS_NULL_LITERAL.apply(literalValue) || literalValue.getStringValue().isEmpty()) { 
 addSentryPrincipalPrivileges(ctx.type_, ctx.sentryService_, principalName, "functional", "functional_kudu"); 
 case PRINCIPAL: // The combination of principal_id + privilege_name is guaranteed to be unique. return "PRINCIPAL:" + catalogObject.getPrincipal().getPrincipal_name() .toLowerCase(); 
 PrincipalPrivilege.buildPrivilegeName(catalogObject.getPrivilege()) .toLowerCase() + "." + Integer.toString(catalogObject.getPrivilege().getPrincipal_id()); 
 } // non-nullable slots have 0 for the byte offset and -1 for the bit mask // to make sure IS NULL always evaluates to false in the BE without having // to check nullability explicitly if (!d.getIsNullable()) { 
 String toSql(ToSqlOptions options); /** * Returns the SQL string corresponding to this node and its descendants. * This should return the same result as calling toSql(ToSqlOptions.DEFAULT). */ String toSql(); 
 public <C extends TreeNode<NodeType>> ArrayList<C> getNodesPreOrder() { ArrayList<C> result = new ArrayList<C>(); 
 Class<D> cl, Collection<D> matches) { 
 Collection<C> nodeList, Class<D> cl, Collection<D> matches) { 
 public <C extends TreeNode<NodeType>> boolean contains(Class<C> cl) { 
 List<C> nodeList, Class<? extends C> cl) { 
 org.apache.parquet.schema.Type parquetType) throws AnalysisException { // The Parquet API is responsible for deducing logical type if only converted type // is set. 
 abstract protected void toThriftImpl(TDataSink tsink); 
 Function fn = Function.createFunction("mydb", "fn1", args, Type.INT, false, TFunctionBinaryType.JAVA); 
 Function fn = new ScalarFunction(new FunctionName("mydb", "fn1"), args, Type.INT, false); 
 ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1"), args, Type.INT, false); 
 ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1"), args, Type.INT, false); 
 ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1"), args, Type.INT, false); 
 ScalarFunction fn = new ScalarFunction(new FunctionName("mydb", "fn1"), args, Type.INT, false); 
 AggregateFunction fn = new AggregateFunction(new FunctionName("mydb", "fn1"), args, Type.BIGINT, false); 
 AggregateFunction fn = new AggregateFunction(new FunctionName("mydb", "fn1"), args, Type.BIGINT, false); 
 ScalarFunction fn1 = new ScalarFunction(new FunctionName("mydb", "fn1"), new ArrayList<>(), Type.INT, false); 
 ScalarFunction fn2 = new ScalarFunction(new FunctionName("mydb", "fn2"), args, Type.INT, false); 
 public RetryRule() { 
 RetryRule(int retryCount) { 
 attempt++; 
 assertFalse(String.format("%d failures", failures), true); 
 public static NetworkResolution AUTOMATIC = new NetworkResolution("auto"); 
 assertEquals(0, exception.diagostics().totalCount()); 
public class BackpressureException extends CouchbaseException { private RingBufferDiagnostics diagnostics; 
 @InterfaceAudience.Public @InterfaceStability.Experimental public RingBufferDiagnostics diagostics() { 
 RingBufferMonitor ringBufferMonitor = RingBufferMonitor.instance(); ringBufferMonitor.addRequest(request); 
 public static RingBufferMonitor instance() { 
 if (request instanceof GenericQueryRequest) { 
 encryptionPathInfo = new HashMap<String, String>(); 
 sb.append(", cryptoManager=").append(this.cryptoManager.toString()); 
 private volatile Map<String, String> encryptionPathInfo; 
 private volatile CryptoManager cryptoManager; 
 throw new CryptoProviderMissingPublicKeyException("Cryptographic providers require a non-null, empty public and key identifier (kid) be configured for the alias: " + providerName); 
 throw new CryptoProviderSigningFailedException("The authentication failed while checking the signature of the message payload for the alias: " + providerName); 
 + ", hostname='" + hostname + ", alternateAddresses=" + alternateAddresses 
 this.username = requireNonNull(username, "username can't be null"); this.password = requireNonNull(password, "password can't be null"); 
 Credentials get(InetSocketAddress address); 
 public Credentials get(InetSocketAddress address) { 
 AuthHandler(String username, String password) { this.username = username; this.password = password; 
 * wants it as int to be forwards compatible (since at some * point we might want to expose this as a number to users). 
 return priority(priority ? -1 : 0); 
 ", priority=" + priority + 
 return String.format("0x%02x (%s)", opcode, getOpcodeName(opcode)); 
 if (LOGGER.isTraceEnabled()) { pipeline.addLast(new DcpLoggingHandler(LogLevel.TRACE)); } 
<|del|> 
public class FtsServerOverloadException extends TemporaryFailureException { 
public class FtsServerOverloadException extends TemporaryFailureException { 
 .delay(Delay.exponential(TimeUnit.MILLISECONDS, upperRetryLimit, lowerRetryLimit)) 
 this.mode = mode; this.conditions = whereFields == null ? null : conditions(whereFields); 
 spans.remove(); 
 originalPromise().tryFailure(new ConnectTimeoutException("Handshake did not complete before deadline.")); 
 JsonDocument document = newDocument(id, expiry, byteBufToJsonObject(content), cas); if (document.content() != null) { document.content().setCryptoManager(this.cryptoManager); } return document; 
<|del|> 
<|del|> 
 * @param bucket the bucket of the document. 
 DISTINCT_RAW("DISTINCT RAW"); 
 ingestOptions().ingestMethod(AnalyticsIngester.IngestMethod.REPLACE) 
<|del|> 
 * Throws {@link RuntimeException} if there is no result handle available 
 ", handle='" + handle+ '\'' + 
 throw new IllegalStateException("There is no result handle available, retry status until success"); 
 public KeysPath useNestedLoop() { 
 return "USE HASH(" + this.side + ")"; 
 return "USE HASH(" + this.side + ")"; 
 /** * The BUILD side of the join will be used to create an in-memory hash table * */ 
 @Override public String toString() { 
 * @return the version of this reference. * @throws UnsupportedOperationException * if the creator of the instance (e.g. {@link RefDatabase}) * doesn't support versioning and doesn't override this method * @since 5.2 
 default long getVersion() { 
 fail("FS doesn't implement ref versioning"); 
 private long version; 
 if (compile == null) { Activator.logInfo("buildFilterFromRegex: Invalid regex"); //$NON-NLS-1$ 
 default long getUpdateIndex() { 
 * The client is responsible to call {@link #getVersion()} only on refs obtained * from {@link RefDatabase} implementations that support versioning (e.g. * reftables). This can be checked via {@link RefDatabase#hasVersioning()} * method. 
 EMFGraphicalContentProvider provider = ProviderHelper.encapsulateProvider(contentProvider, rs, HistoryUtil.getHistoryID(source, feature, "container")); //$NON-NLS-1$ 
 * @deprecated since * Use the {@link org.eclipse.papyrus.infra.services.edit.ui.databinding.AggregatedPapyrusObservableValue} API, instead. 
 * @deprecated since 1.2.0 * Use the {@link org.eclipse.papyrus.infra.tools.databinding.CommandBasedObservable} API, instead. 
 * @deprecated since 1.2.0 * Use the {@link org.eclipse.papyrus.infra.tools.databinding.CommandBasedObservableValue} API, instead. 
 * @deprecated since 1.2.0 * Use the {@link org.eclipse.papyrus.infra.gmfdiag.common.databinding.GMFObservableList} API, instead 
 * @deprecated since 1.2.0 * Use the {@link org.eclipse.papyrus.infra.gmfdiag.common.databinding.GMFObservableValue} API, instead 
//should be removed in Papyrus 5.0 (see bug 540821) /** * @deprecated since 1.2.0 * @author VL222926 * */ 
//should be removed in Papyrus 5.0 (see bug 540821) /** * @deprecated since 1.2.0 * @author VL222926 * */ 
 public static final String TAG_PROFILE_CHANGED = " (has changed, consider re-applying profile)"; //$NON-NLS-1$ 
 stack[i] = (call instanceof Long) ? (long) call : UNDEFINED_SYMBOL; 
<|del|> 
<|del|> 
<|del|> 
 stack[i] = (call instanceof Long) ? (long) call : UNDEFINED_SYMBOL; 
 } catch (RuntimeException e) { 
 * This program and the accompanying materials * are made available under the terms of the Eclipse Public License 2.0 
 cc.setProperty(EMFCompareConfiguration.MIRRORED, Boolean.TRUE); 
 Object property = getProperty(EMFCompareConfiguration.MIRRORED); 
 if (EMFCompareConfiguration.MIRRORED.equals(event.getProperty())) { 
 boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } 
 cc.setProperty(EMFCompareConfiguration.MIRRORED, Boolean.TRUE); 
 if (length == 1 && (flags & SWT.DRAW_TRANSPARENT) != 0) { 
 private ReadableChannel channel() throws IOException { 
 * https://www.eclipse.org/legal/epl-2.0 
 Ref ref = refdir.exactRef(HEAD); assertNotNull(ref); ref.getUpdateIndex(); // Not implemented on FS 
 for (Ref ref : refs) { 
 return new SymbolicRef(ref.getName(), dst, ref.getUpdateIndex()); 
<|del|> 
<|del|> 
 * instantiator of the Ref must override this method (e.g. by using the * {@code VersionedRef} decorator) if it can provide a version value. 
 * @return true whether the implementation assigns update indices to 
 * @return true whether the implementation assigns update indices to 
 ref = block.readRef(minUpdateIndex + block.readUpdateIndexDelta()); 
 ref = block .readRef(minUpdateIndex + block.readUpdateIndexDelta()); 
 * Should not be used unless the {@code RefDatabase} that instantiated the * ref supports versioning (see {@link RefDatabase#hasVersioning()} 
<|del|> 
 String name = res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); new TracePackageSupplFileElement(res, name, suppFilesElement); 
 String name = res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); new TracePackageSupplFileElement(res, name, suppFilesElement); 
 String name = res.getLocation().makeRelativeTo(new Path(supplementaryFolder)).toString(); new TracePackageSupplFileElement(res, name, suppFilesElement); 
 } } 
<|del|> 
 * <p> * @implSpec This method returns false by default. Implementations * supporting versioning must override it to return true. * @return true if the implementation assigns update indices to references. 
 public boolean hasVersioning() { return false; } 
 * ref supports versioning (see {@link RefDatabase#hasVersioning()}) 
 * update. See {@link Ref#getUpdateIndex()}. * 
 * <p> 
 * Copyright (c) 2009, 2018 THALES GLOBAL SERVICES and others. 
 // keep only the DRepresentationDescriptor which DRepresentation is not null 
 public final Ref getRef(String name) throws IOException { return findRef(name); } 
 return new FirstCommand(line.substring(0, nul), unmodifiableSet(opts)); 
 // look for files or folders with the given path 
 if (getType() != ARCHIVE) { 
 } if (getType() != ARCHIVE) { @SuppressWarnings("deprecation") IContainer[] containers = root.findContainersForLocation(path); if (containers.length > 0) { return containers[0]; } } 
 private static class LazyChannel implements AutoCloseable, DfsBlockCache.ReadableChannelSupplier { private final DfsReader ctx; private final DfsPackDescription desc; private final PackExt ext; 
 basicInitialize(descriptor); if (!getStatus().isOK()) { return; } 
 StringBuilder builder = new StringBuilder(); 
<|del|> 
<|del|> 
 return user; 
 * regular users can't see any orgunits, while server admins can see all of them. Only project admins have 
 * Johannes Faltermeier - initial API and implementation 
 getSuperAdminBroker().changeRole(getProjectSpace().getProjectId(), group, Roles.writer()); final int oldSize = getSuperAdminBroker().getGroups().size(); 
<|del|> 
 uninstallTestMessagehandler(); 
 protected static <DTO> void verifyRequestReplyMessageHandler(IDestination<DTO> expectedDestination, IMarshaller marshaller, DTO expectedRequest, DTO expectedReply) { 
 * The message has not yet been processed (unmarshalled) by the MOM framework. 
 * The message has already been processed (marshalled) by the MOM framework. 
 * @return the writer's {@link IMarshaller} used to transform the transfer object (never <code>null</code>). 
 * If the message is a {@link javax.jms.BytesMessage}, the message body is put in read-only mode and repositions the * stream of bytes to the beginning. 
 /** * @return the associated {@link IJmsMessageHandler} for this JMS MOM implementor. It is never <code>null</code>. */ 
 fetchFromBundle(newRepo, "Not a bundle file".getBytes(UTF_8)); 
 * Indicates if a signing key is available for the specified committer 
 * the signing key to locate (passed as is to the GPG signing * tool as is; eg., value of <code>user.signingkey</code>) 
 super.doSetValue(value); // TODO : real type of the value ? type compatibility ? 
 * Tests whether this action should be active. The action is active if the given {@link IDiagramElementEditPart} is * hidden. 
 * @return true if the selected element is hidden. 
 * @return true if the selected element is hidden. 
 * @return true if the selected element is hidden. 
 * Tests whether this action should be active. The action is active if the the given selection contains only hidden * diagram graphical element. 
 * @return true if all selected elements are hidden. 
 * @return true if all selected elements are hidden. 
 final Object selectedElement = iterator.next(); if (selectedElement instanceof IDiagramElementEditPart) { result = result && isActive((IDiagramElementEditPart) selectedElement); 
 Optional<DDiagramElement> optionalDiagramElement = Optional.of((IGraphicalEditPart) vpe).map(IGraphicalEditPart::resolveSemanticElement).filter(DDiagramElement.class::isInstance) 
<|del|> 
 * Extends the {@link RevealElementsAction} to make it compatible with the tabbar by making it disposable and by * handling the selection changes. 
 * @param label the label 
<|del|> 
 * element to hide and reveal 
 * We perform the Show / Hide for each action according to the i argument: 
 final StringHolder pattern = new StringHolder(); final String input = "2019-01-18T12:42:03.409Z"; 
<|del|> 
 * Includes peeled {@linkObjectId}s. This is the inverse lookup of 
 * @return a {@link Set} of {@link Ref}s whose tips point to the provided 
 return getRefs().stream().filter(r -> id.equals(r.getObjectId()) || id.equals(r.getPeeledObjectId())).collect(toSet()); 
<|del|> 
 /** The data provider title text */ 
 builder.setId(SegmentStoreScatterDataProvider.ID + DataProviderConstants.ID_SEPARATOR + analysis.getId()) 
 return new FileOutputStream(file); 
 * 
 try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry)); OutputStream outStream = new BufferedOutputStream(new FileOutputStream(outputFile))) { copyStream(inputStream, outStream); 
 throw new CoreException(new Status(IStatus.ERROR, CommonsCorePlugin.ID_PLUGIN, NLS.bind( "The storage location ''{0}'' contains sub directories", path))); //$NON-NLS-1$ 
 try (ZipOutputStream zipOut = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile)))) { 
 try (InputStream in = new FileInputStream(source); OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { 
 * 
 if (fExpressionHistory != null) { fExpressionHistory.dispose(); 
 * Performs a hide and show action on the diagram element by using those three different ways: 
<|del|> 
 protected TreeNode(TreeNode<TreeType> parent, TreeType myself) { 
public interface DataDrivenCondition extends IDataDrivenRuntimeObject { 
 throw new FatalSocketException(); 
 try { return disableSSLv3AndReturn(serverSocketFactory.createServerSocket(pPort, backlog, addr)); } catch (final FatalSocketException ex) { shutdown(serverSocketFactory, ex); throw new IOException(ex.getMessage()); } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 .asyncExec(() -> PlatformUI.getWorkbench().getDisplay().timerExec(200, switchTopControlRunnable)); 
<|del|> 
public final class EmptyWorkspaceHelper { 
 private ArrayList<IAction> projectWizardActions; private IAction newProjectAction; 
 public void setNonEmptyControl(Control control) { 
 private void dispose(Listener listener) { PlatformUI.getWorkbench().getActiveWorkbenchWindow().removePerspectiveListener(listener); ResourcesPlugin.getWorkspace().removeResourceChangeListener(listener); JFaceResources.getColorRegistry().removeListener(listener); parent.removeDisposeListener(listener); 
 IWizardRegistry newWizardRegistry = WorkbenchPlugin.getDefault().getNewWizardRegistry(); IWizardDescriptor wizardDesc = newWizardRegistry.findWizard(wizardId); if (wizardDesc == null) { 
 IWizardRegistry newWizardRegistry = WorkbenchPlugin.getDefault().getNewWizardRegistry(); IWizardDescriptor wizardDesc = newWizardRegistry.findWizard(wizardId); if (wizardDesc == null) { 
 private boolean switchTopControl() { if (control.isDisposed() || emptyArea.isDisposed()) { return false; } 
<|del|> 
 } @Override public void widgetDisposed(DisposeEvent e) { dispose(this); } 
<|del|> 
 * The explanatory text explains the current situation that no projects are 
 parent.removeDisposeListener(listener); // paranoia parent = null; emptyArea = null; layout = null; control = null; displayArea = null; projectWizardActions = null; newProjectAction = null; 
 if (action != null) { projectWizardActions.add(action); } 
 PlatformUI.getWorkbench().getDisplay() 
 * This allows to sort strings that are a mixture of numbers and text (e.g. house numbers) in an intuitive fashion. 
<|del|> 
<|del|> 
<|del|> 
 fSourcePluginFilter = new SourcePluginFilter(state); fTreeViewer.addFilter(fSourcePluginFilter); 
 IFile eclipseTargetFile = eclipseFolder.getFile(fileName.replaceAll("portable", targetSuffix)); //$NON-NLS-1$ 
 public Set<Ref> getTipsWithSha1(ObjectId id) throws IOException { 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.GenerateTargetsHandler_UnexpectedException, ex); 
 * @param style SWT style applicable for Button. Refer to 
 TestFactory factory = TestFactory.newTest().layoutData(gridDataFactory::create); 
 assertNotSame(label.getLayoutData(), label2.getLayoutData()); 
<|del|> 
 return '!' + key + '!'; //$NON-NLS-1$ //$NON-NLS-2$ 
 return eObject.eClass().getName() + '-' + side.getName(); //$NON-NLS-1$ 
 return super.toString() + '-' + side.getName(); //$NON-NLS-1$ 
 author = subSignedOff.contains("\n") ? subSignedOff.substring(0, subSignedOff.indexOf("\n")) : subSignedOff; //$NON-NLS-1$ //$NON-NLS-2$ 
 monitor.beginTask(taskName, 6); 
<|del|> 
 SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss"); //$NON-NLS-1$ 
 return "Not specified"; //$NON-NLS-1$ 
 author = subSignedOff.contains("\n") ? subSignedOff.substring(0, subSignedOff.indexOf("\n")) : subSignedOff; //$NON-NLS-1$ //$NON-NLS-2$ 
 return "Unknown"; //$NON-NLS-1$ 
 return "Not specified"; //$NON-NLS-1$ 
 private final static String SEPARATOR = "."; //$NON-NLS-1$ 
 public static final String CONTRIBUTION_BRANCH_PREFIX = "Review_"; //$NON-NLS-1$ 
 addGitFiles(git, repository.getWorkTree(), ""); //$NON-NLS-1$ 
 copyFolder(subFile.getAbsolutePath(), dest + "/" + subFile.getName()); //$NON-NLS-1$ 
<|del|> 
 * Finds the active shell and moves it to the end of the given array, so that * findControl() will find the controls from the active shell first. 
 * Finds the active shell and moves it to the end of the given array, so that * findControl() will find the controls from the active shell first. 
 // Find the index of the active shell and exchange last one with active 
public class TimeLineEvent extends TimeEvent { 
<|del|> 
<|del|> 
 PackList newList = scanPacks(old, force); 
<|del|> 
 namespaceMap.computeIfAbsent(pc.getNamespace(), namespace -> new HashSet<>()).add(iu); nameMap.compute(pc.getName(), (name, prev) -> { if (prev == null || prev == iu) { 
 private static void collectMatchingIUs(Map<String, ?> indexToUse, String name, Collection<IInstallableUnit> collector) { 
 } else if (passwordText.getText().trim().isEmpty()) { 
 } else if (prev instanceof IInstallableUnit) { Collection<IInstallableUnit> ius = new HashSet<>(); ius.add((IInstallableUnit) prev); ius.add(iu); return ius; 
 if (parent != null) { addChild(parent, art); } 
<|del|>
 public static final String UML_EXT = org.eclipse.papyrus.uml.tools.model.UmlModel.UML_FILE_EXTENSION; 
 ModelSet modelSet = serviceUtils.getModelSet(event); URI uri = modelSet.getURIWithoutExtension().appendFileExtension(UML_EXT); Resource userResource = modelSet.getResource(uri, false); 
 int sourceEnd = statement.sourceEnd; 
 if (bounds.x == 0 && bounds.y == 0) { 
 if (!bounds.contains(pt) && !fInitialDeadzone.contains(pt)) { 
 // Fix the number of GIF frames as GdkPixbufAnimation does not provide an API to // determine number of frames. 
 long curr_pixbuf = GDK.gdk_pixbuf_animation_iter_get_pixbuf (animation_iter); long pixbuf_copy = GDK.gdk_pixbuf_copy(curr_pixbuf); // copy because curr_pixbuf might get disposed on next advance 
<|del|> 
 return GDK.gdk_pixbuf_new_from_file(buffer, null); 
<|del|> 
 private final Listener fListener = this::disposeIfExited; 
<|del|> 
<|del|> 
 Display.getDefault().addFilter(SWT.MouseMove, fListener); 
 SWTBotUtils.closeView("welcome", bot); /* Prepare the workspace */ prepareWorkspace(); 
 background = rgba; } if (GTK.GTK4) { 
<|del|> 
<|del|> 
 * Checks whether at least one change of which we are notified, concerns a semantic model or a specific graphical 
 * Checks whether at least one change of which we are notified, concerns a semantic model or a specific graphical 
 * a cache map used to retrieve the resource from a notifier 
 * Dispose the shell if we exit the range. 
 Display display = Display.getDefault(); display.addFilter(SWT.MouseMove, fListener); display.addFilter(SWT.FocusOut, fListener); 
 fTipShell.addDisposeListener(e -> e.display.removeFilter(SWT.MouseMove, fListener)); fTipShell.addDisposeListener(e -> e.display.removeFilter(SWT.FocusOut, fListener)); 
 fFileLocation.delete(); SWTBotUtils.deleteProject(PROJECT_NAME, fBot); 
 fFileLocation.delete(); tearDown(); 
 display.addFilter(SWT.FocusOut, fFocusLostListener); 
<|del|> 
<|del|> 
<|del|> 
 /* Creating project and open the trace */ 
<|del|> 
 SWTBotUtils.delay(1000); 
 ((TmfTrace) trace).traceOpened(new TmfTraceOpenedSignal(this, trace, null)); 
 ((TmfTrace) trace).traceOpened(new TmfTraceOpenedSignal(this, trace, null)); 
<|del|>
<|del|> 
<|del|>
 Set<String> set= new HashSet<>(Arrays.asList(inactiveTestBundles)); 
<|del|> 
 : UNDEFINED_UPDATE_INDEX); 
 if (tipShell!= null) { 
 if (tipShell!= null) { 
 for (String category : categories) { buf.append(category); 
 if (constructorBinding != null) { IMethod method = resolveMethodBinding(constructorBinding); collectParameterNamesCodeMinings(method, arguments, constructorBinding.isVarargs()); } 
 if (methodBinding != null) { IMethod method = resolveMethodBinding(methodBinding); collectParameterNamesCodeMinings(method, arguments, methodBinding.isVarargs()); } 
 * Represents a replacement between timestamps. * Either the old or the new timestamp can be null, but not at the same time. 
 * Represents a replacement between timestamps. * Either the old or the new timestamp can be null, but not at the same time. 
 * Vincent Lorenzo (CEA LIST) vincent.lorenzo@cea.fr - Initial API and implementation 
 * Utility class for the operations of GeneratorConfiguration metamodel 
 Activator.log.warn(NLS.bind("The path {0} must not be a platform path", uri.toString())); //$NON-NLS-1$ 
 Activator.log.warn(NLS.bind("The path {0} must not be a platform path", uri.toString())); //$NON-NLS-1$ 
 SWTBotPreferences.TIMEOUT = 50000; /* 50 second timeout */ 
 // do nothing 
 .sorted((b1, b2) -> b2.getVersion().compareTo(b1.getVersion())) // highest version first 
 if (numCols > 0) { 
 * @param inCalledContext {@code true} if the evaluation is the target of a function call 
 return true; 
 return fPositive.isNoexcept(inCalledContext) && fNegative.isNoexcept(inCalledContext); 
 // assert false; // TODO this assert is hit 
 assert false; return true; 
 return true; 
 assert false; return true; 
 } } else if( list instanceof SparseList) { SparseList sparseList = (SparseList) list; sparseList.ensureSize(index); 
 for (int i = 0; i < events.size(); i++) { 
 fInnerEvents.put(fSize, e); fSize++; 
 for (IEventDeclaration event : c) { if (event!= null) { 
 if (index > fSize) { fSize = index; 
 static final int IDI_CANCEL = 102; 
<|del|> 
 * Copyright (c) 2017, 2019 Ericsson 
 if (!fTipShell.isDisposed()) { 
 if (!result || fEncapsulateDeclaringClass) 
<|del|> 
 arguments.put(ATTRIBUTE_VISIBILITY, Integer.valueOf(fVisibility).toString()); 
 DefaultCodeFormatterConstants.NEXT_LINE); assertFormatterResult(); 
 * Copyright (c) 2015, 2019 Obeo. 
 * @param source * Semantic element corresponding to the source of the reference 
 } 
 // Check that the original edge is no longer visible but is always here 
 bot.waitUntil(new DefaultCondition() { 
 if (!name.equals(srcName)) throw new RepositoryNotFoundException(name); final Repository db = src.getRepository(); db.incrementOpen(); return db; }); 
 if (!name.equals(srcName)) throw new RepositoryNotFoundException(name); final Repository db = src.getRepository(); db.incrementOpen(); return db; }); 
 Collections.sort(entries, (MutableEntry o1, MutableEntry o2) -> Long .signum(o1.getOffset() - o2.getOffset())); 
 if (result != null) { return result.stream().findFirst(); 
 result = newUserSelection; 
<|del|> 
 private Collection<T> result; 
 public Optional<T> getFirstResult() { 
 result = null; 
 result = null; 
<|del|> 
 // Make sure that timestamps are modified and read so that a full 
 try (CtfIterator funky = (CtfIterator) trace.createIterator()) { 
 try (CtfIterator iter = (CtfIterator) fTrace.createIterator();) { 
 try (CtfIterator iter1 = (CtfIterator) fTrace.createIterator(); CtfIterator iter2 = (CtfIterator) fTrace.createIterator()) { 
 long time = Objects.requireNonNull(currentEvent).getTimestamp().getValue(); fCurLocation = new CtfLocation(new CtfLocationInfo(time, time != seekToTimestamp ? 0 : index)); 
<|del|> 
<|del|> 
<|del|> 
 return Arrays.asList(Boolean.TRUE, Boolean.FALSE); 
 TestRepository<FileRepository> testRepository = new TestRepository<FileRepository>(repository); 
 ConfigConstants.CONFIG_KEY_TRUSTFOLDERSTAT, trustFolderStats.booleanValue()); 
 String directlyConnectedElements = provider.getDiagramText(selection); assertTrue(directlyConnectedElements.equals(EXPECTED_TEXT_FOR_INTERNAL_LINKS)); 
 assertEquals("sched_switch", event.getName()); assertEquals(duplicateLocationIndexedOne, iterator.getLocation().getLocationInfo()); 
 CtfLocationInfo duplicateLocationOutOfBounds = new CtfLocationInfo(1331668247328921944L, 4L); assertTrue(iterator.seek(duplicateLocationOutOfBounds)); event = getCurrentEvent(iterator); assertNotNull(event); assertEquals(1331668247328925363L, getTimestampInNanos(event)); 
 long offset = ctfLocationData.getIndex(); while (currentEvent != null && index < offset) { 
 long time = Objects.requireNonNull(currentEvent).getTimestamp().getValue(); fCurLocation = new CtfLocation(new CtfLocationInfo(time, time != seekToTimestamp ? 0 : index)); 
 return true; 
 filter.doFilter(req, res, (ServletRequest request, ServletResponse response) -> { ((HttpServletResponse) response).sendError(SC_NOT_FOUND); }); 
 * @param left * true to scroll left else false 
public interface ITmfZoomToSelectionProvider { /** * Zoom to selection */ void zoomToSelection(); 
 * Base handler, makes sure we have a TMF view control selected. 
 public abstract void execute(TmfView view); 
public class TmfViewZoomInHandler extends TmfViewBaseHandler { 
 private static final String DATA_UNIT_DIR = "/data/unit/selection/"; 
 // Trace 2 has duplicate time stamps 
 CtfLocationInfo middleLocationIndexOne = new CtfLocationInfo(1331668250328561095L, 1L); assertTrue(iterator.seek(middleLocationIndexOne)); event = iterator.getCurrentEvent(); 
 assertEquals(1331668250328561761L, iterator.getCurrentTimestamp()); // next event location 
 CtfLocationInfo duplicateLocationIndexHuge = new CtfLocationInfo(1331668247328921944L, 9001000000L); assertTrue(iterator.seek(duplicateLocationIndexHuge)); event = iterator.getCurrentEvent(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (c) 2010, 2019 THALES GLOBAL SERVICES 
 * Copyright (c) 2012, 2019 THALES GLOBAL SERVICES 
 * Copyright (c) 2017, 2019 THALES GLOBAL SERVICES. 
<|del|> 
<|del|> 
<|del|> 
 assertEquals(3, iterator.previousIndex()); assertEquals(4, iterator.nextIndex()); 
 * Sparse list, a list optimized for when most (> 90%) of the data is * <code>null</code>. * * Note: this iterates in the sorted order. * * This implementation supports: 
 private int getThreshold() { 
<|del|> 
 * Sparse list, a list optimized for when most of the data is <code>null</code>. * Nulls will increment the size of the datastructure but not stored as null * means the data is not present. 
 * TODO: Keep an eye out for a better datastructure... this is fine, but if it * can be replaced by an externally maintained datastructure, that would be * better. 
 private final Map<Integer, E> fInnerElements = new HashMap<>(); 
 return fInnerElements.containsValue(o); 
 if (e != null) { fInnerElements.put(fSize, e); 
 return fInnerElements.values().containsAll(c); 
 set(key, event); 
 set(key, event); 
 * Returns null if there is no element found at that index. 
 return fList.get(fCursor); 
 return fCursor + 1; 
 public void testNoexceptOperatorFunctions_545021() throws Exception { parseAndCheckBindings(); 
<|del|> 
 // constexpr bool noexcept_unaryop_is_noexcept = noexcept(!t2); public void testNoexceptOperatorOverloadedOperators_545021() throws Exception { parseAndCheckBindings(); 
 public CPPFunctionType(IType returnType, IType[] types, ICPPEvaluation noexceptSpecifier) { this(returnType, types, noexceptSpecifier, false, false, false, false, false); 
 if (!EvalUtil.evaluateNoexceptSpecifier(overload.getType().getNoexceptSpecifier())) return false; 
 return fCondition.isNoexcept(inCalledContext) && fPositive.isNoexcept(inCalledContext) && fNegative.isNoexcept(inCalledContext); 
<|del|> 
 assert false; // Shouldn't exist outside of a dependent context 
 assert false; // Shouldn't exist outside of a dependent context 
 public boolean isNoexcept(boolean inCalledContext) { if (!fOwnerEval.isNoexcept(inCalledContext)) return false; 
 assert false; // Shouldn't exist outside of a dependent context 
 if (!EvalUtil.evaluateNoexceptSpecifier(overload.getType().getNoexceptSpecifier())) return false; 
 List<String> reference = Arrays.asList("Pomme", "Peche", "Poire", null, "Banane"); 
 assertEquals("yo", iterator.previous()); assertEquals("Hola", iterator.previous()); 
 * Nulls will increment the size of the SparseList but they are not stored * internally. * </p> * <p> * Note: this iterates in the list order. * </p> 
 * Nulls will increment the size of the SparseList but they are not stored * internally. * </p> * <p> * Note: this iterates in the list order. * </p> 
 /** * A backing map used to store the non-null elements */ private final Map<Integer, @NonNull E> fInnerElements = new HashMap<>(); /** * The list size: map size + number of nulls */ 
 return fSize == 0; 
 return (o == null && size() > fInnerElements.size()) || fInnerElements.containsValue(o); 
<|del|> 
 public int indexOf(Object o) { if (o == null && contains(null)) { for (int i = 0; i < size(); i++) { if (!fInnerElements.containsKey(i)) { return i; } } } 
 int last = -1; if (o == null && contains(null)) { for (int i = size() -1; i >= 0; i--) { if (!fInnerElements.containsKey(i)) { return i; } } } 
 perspSwitcherToolbar.requestLayout(); 
 fModel = model; fStartTime = model.getStartTime(); fEndTime = model.getEndTime(); 
 if (obj instanceof TimeLineEvent) { 
 if (getType() == PROJECT) { // project entry always has workspace relative path return root.findMember(path); 
<|del|> 
 assertEquals("Hola", iterator.next()); 
<|del|> 
<|del|> 
 return nextIndex() < fList.size(); 
 return previousIndex() >= 0; 
 return o == null ? size() > fInnerElements.size() : fInnerElements.containsValue(o); 
 returnArray[i] = (T) next; 
 first = Math.min(entry.getKey(), first); 
 return Spliterators.spliterator(iterator(), fSize, Spliterator.ORDERED); 
 return new GenericReadOnlyListIterator<>(this, index); 
 throw new UnsupportedOperationException("No add(int, E) in " + this.getClass().getName()); //$NON-NLS-1$ 
 throw new UnsupportedOperationException("No delete(int) in " + this.getClass().getName()); //$NON-NLS-1$ 
 throw new UnsupportedOperationException("No remove(Object) in " + this.getClass().getName()); //$NON-NLS-1$ 
 throw new UnsupportedOperationException("No addAll(int, Collection<? extends E>) in " + this.getClass().getName()); //$NON-NLS-1$ 
 throw new UnsupportedOperationException("No subList(int, int) in " + this.getClass().getName()); //$NON-NLS-1$ 
 * Copyright (c) 2019 vogella GmbH and others. 
<|del|> 
 * This is invoked just before starting to walk looking for the closes * bitmap. Can be used to tune the walker configuration. 
 throws MissingObjectException, IncorrectObjectTypeException, IOException { 
 IConcurrentModelListener[] listeners = getListeners(); for (IConcurrentModelListener listener : listeners) { 
 // We don't record the copy since this recursive call will // do so. Just record the overwrites. overwrittenResources.addAll(Arrays.asList(overwritten)); 
 result.addAll(Arrays.asList(resources)); 
 resourceSet.addAll(Arrays.asList(selectedResources)); 
 * Display XY lines for this entry, ie one or more continuous lines that change 
 throw new IllegalArgumentException("Needs to be a TimeLineEvent"); //$NON-NLS-1$ 
 throw new IllegalArgumentException("Needs to be a TimeLineEvent"); //$NON-NLS-1$ 
 public TimeLineEvent(ITimeGraphEntry entry, long time) { this(entry, time, new ArrayList<>()); 
 public TimeLineEvent(ITimeGraphEntry entry, long time, List<Long> values) { super(entry, time, 0); 
 if (!super.equals(obj)) { 
 if (obj instanceof TimeLineEvent) { 
 .append(']').toString(); 
 List<List<LongPoint>> seriesModel = new ArrayList<>(); 
 List<List<LongPoint>> seriesModel = new ArrayList<>(); 
 int nbSeries = -1; 
 if (x >= rect.x + rect.width) { 
 List<Long> values = timeEvent.getValues(); if (nbSeries == -1) { nbSeries = values.size(); } 
 List<Long> values = timeEvent.getValues(); if (nbSeries == -1) { nbSeries = values.size(); } 
 seriesModel.get(i).add(new LongPoint(x, val)); 
 seriesModel.get(i).add(new LongPoint(x, val)); 
 for (TimeLineEvent ref : refs) { Map<String, Object> eventStyle = timeGraphProvider.getEventStyle(ref); 
 for (TimeLineEvent ref : refs) { Map<String, Object> eventStyle = timeGraphProvider.getEventStyle(ref); 
 for (int i = 0; i < seriesModel.size(); i++) { 
 * Copyright (c) 2000, 2019 IBM Corporation and others. 
 // Accumulate the overwrites into the full list overwrittenResources.addAll(Arrays.asList(overwrites)); 
 // Accumulate the overwrites into the full list overwrittenResources.addAll(Arrays.asList(overwrites)); 
 // We don't record the copy since this recursive call will // do so. Just record the overwrites. overwrittenResources.addAll(Arrays.asList(overwritten)); 
 // We don't record the moved resources since the recursive // call has done so. Just record the overwrites. overwrittenResources.addAll(Arrays.asList(overwritten)); 
 result.addAll(Arrays.asList(resources)); 
 resolutions.addAll(Arrays.asList(res)); 
 System.arraycopy(tempFileNames, 0, fileNames, 0, actualLength); 
 super.addAll(Arrays.asList(elements)); 
 nonUiVisible.addAll(Arrays.asList(filterIdsToActivate)); 
 inputArray.addAll(Arrays.asList(wizardCategories.getCategories())); 
 inputArray.addAll(Arrays.asList(wizardCategories.getCategories())); 
 queuedEvents.addAll(Arrays.asList(prefIds)); 
 kids.addAll(Arrays.asList(children)); 
 System.arraycopy(allElements, 0, currentElements, 0, currentElements.length); 
 System.arraycopy(members, 0, newMembers, 0, members.length); 
 protected LeasedSmtpConnection withConnectionPool(SmtpConnectionPool connectionPool) { m_connectionPool = connectionPool; 
 } public boolean isClosed() { return m_closed; } 
 protected static final String JOB_NAME_CLOSE_IDLE_CONNECTIONS = "smtp-close-idle-connections"; 
 Stream.of(m_idleEntries, m_leasedEntries) .flatMap(Collection::stream) .forEach(this::safeCloseTransport); 
 private Transport m_transport; // creation time of this pool entry object in milliseconds 
 /** * @return Returns the poolSize specified for this {@link SmtpServerConfig} object. */ 
 if (x >= rect.x + rect.width) { 
 min = 0; 
 min = 0; 
 * Copyright (c) 2019 Bachmann electronic GmbH and others. 
 * Bachmann electronic GmbH - initial API and implementation 
 // Create two PartStacks with MParts inside 
 // Create a CompositePart with MParts inside 
 // Make sure the widget is not a CTabFolder 
 assertEquals(tbm.getSize(), 0); 
 protected int getThreshold() { // fixed default threshold provided up to v3.15 
 fCategoryViewer.refresh(); 
<|del|> 
 Activator.getDefault().logError("Syscall names not available!"); //$NON-NLS-1$ return new SyscallLookup(Collections.emptyList()); 
 * A trace on which we are interested to fetch a model 
 IVariableBinding[] synVars = binding.getSyntheticOuterLocals(); if (synVars == null || synVars.length == 0) {// name cannot be updated if Synthetic Outer Locals are not available return true; } 
 @Override 
 for (int i = 0; i < visible.length; i++) { checkState.add(visible[i]); } 
 allDetectors.addAll(Arrays.asList(configuredDetectors)); 
 if (noexceptSpecifier != null && noexceptSpecifier.getValue() instanceof IntegralValue) { 
 P_ReuseCheckResult reuseCheckResult = isReuseAllowed(candidate); if (reuseCheckResult.isReuseAllowed()) { 
 * @return Returns the size of the connection pool to use with this {@link SmtpServerConfig}. If 0, smtp connection * pooling is disabled. 
 Activator.getDefault().logError(e.getMessage(), e); 
 Activator.getDefault().logError("Error: getting number of core " + e.getMessage(), e); //$NON-NLS-1$ 
 int versionCompareResult = compareWorkspaceAndIdeVersions(url); 
 public @Nullable ImageDescriptor getImageDescripterFromPath(String path) { return AbstractUIPlugin.imageDescriptorFromPlugin(PLUGIN_ID, path); 
 return attribute.getAttributeType().getIdString(); 
 ISiteFeature feature = getCurrentItem(); if (feature != null) { String value = include ? recomputeUrl() : null; feature.setURL(value); } 
 SyscallLookup instance = sInstance; 
 Activator.getDefault().logWarning("Syscall names not available!"); //$NON-NLS-1$ 
<|del|> 
<|del|> 
 variables[i] = new JDIPlaceholderVariable(fVariables[i][0], evaluationBlock.evaluate(fVariables[i][1]), javaValue); 
 Label label = editor.getToolkit().createLabel(this, prefix + " \"" + getObjectName( thisArt) + "\" " + action + getCompletedCancelledString(art) + " \"" + getObjectName(art) + "\" "); 
 if (fBinding instanceof ICPPMethod) { 
 reportProblem(VIRTUAL_CALL_ID, problemNode); 
 if (memberBinding instanceof ICPPConstructor) { 
 private final List<ITmfEventAspect<?>> fAspects = new ArrayList<>(); 
 fAspects.add(aspect); 
 return EMPTY_STRING; 
<|del|> 
 if (eventString != EMPTY_STRING) { 
 if (!eventString.isEmpty()) { 
 * Copyright (c) 2011-2019 EclipseSource Muenchen GmbH and others. 
 setDescription(PREFERENCE_PAGE_DESCRIPTION); 
<|del|> 
 if (ALL_OS.equals(propOs) || ALL_OS.equals(os)) { return true; 
 if (ALL_OS.equals(propOs) || ALL_OS.equals(os)) { return true; 
 if (ALL_ARCH.equals(arch) || ALL_ARCH.equals(propArch)) { return true; 
 if (ALL_ARCH.equals(arch) || ALL_ARCH.equals(propArch)) { return true; 
<|del|> 
 private static final String ALL_ARCH = ""; //$NON-NLS-1$ private static final String ALL_OS = ""; //$NON-NLS-1$ 
 super.addEvent(event); 
 if (eventList != null) { // Sets a filtered list super.setEventList(eventList.stream().map(timeEvent -> isValidEvent(timeEvent) ? timeEvent : null).collect(Collectors.toList())); 
 if (isValidEvent(event)) { super.updateZoomedEvent(event); } 
 return (event instanceof TimeLineEvent); 
 seriesToAdd.add(new LongPoint(x, val)); 
 return getClass().getSimpleName() + " time=" + fTime + " value=[" + getLabel() + ']'; //$NON-NLS-1$ //$NON-NLS-2$ 
 long val = values.get(i); 
 long val = values.get(i); 
 long val = values.get(i); 
 isValidEvent(event); 
 if (values.size() < i) { long val = values.get(i); 
<|del|> 
 * Generic TimeLineEvent implementation, basically a point with multiple * potential Y values and one X 
 /** * One time line X and mutliple Ys. Able to support multiple lines for a * series. */ 
 * The values to display at this given timestamp 
 boolean isEmpty = true; 
 sanitizeList(eventList, super::setEventList); 
 getValues().forEach((Long value) -> sj.add(value == null ? String.valueOf(value) : NumberFormat.getNumberInstance(Locale.getDefault()).format(value))); 
 return Collections.unmodifiableList(fValues); 
<|del|> 
<|del|> 
<|del|> 
 sanitizeList(eventList, super::setEventList); 
 fValues.add(value); fLabel = null; 
 SWTBot wizardBot = SWTBotSiriusHelper.getShellBot("Pane Based"); 
 * Test the cancel on the first wizard. 
 String propOs = property.getOs() != null ? property.getOs().trim() : ALL_OS; 
<|del|> 
<|del|> 
 final int a = 32; // ' ' int e = 126; // '~' 
 public void testDetectModificationAlthoughSameSizeAndModificationtime() 
 public void testDetectModificationAlthoughSameSizeAndModificationtime() 
 public void testDetectModificationAlthoughSameSizeAndModificationtime() 
 // don't use mtime of the parent folder to detect file modification. 
 // don't use mtime of the parent folder to detect file modification. 
 public void testDetectModificationAlthoughSameSizeAndModificationtimeAndFileKey() 
 public void testDetectModificationAlthoughSameSizeAndModificationtimeAndFileKey() 
 // generator works differently. Then we have to search for more // consistent 
 updateStyleBits(image == null); 
 updateStyleBits(true); 
 for (int i = 0; i < entries.length; i++) { list.add(entries[i]); 
 for (int i = 0; i < entries.length; i++) { if(entries[i] != null) { fEntries.add(entries[i]); 
 index = fEntries.indexOf(sel.getFirstElement()); } for (int i = 0; i < entries.length; i++) { if (!fEntries.contains(entries[i])) { fEntries.add(index, entries[i]); 
 } 
 // add listeners if (fOrganizers != null) { for (int i = 0; i < fOrganizers.length; i++) { fOrganizers[i].addPropertyChangeListener(this); 
 for (int i = 0; i < fFilters.length; i++) { if (fFilters[i].equals(property)) { 
 for (int i=0; i<fBytes.length; i++) { 
 for (int i = 0; i < fToggleDetailPaneActions.length; i++) { fToggleDetailPaneActions[i].setChecked(fToggleDetailPaneActions[i].getOrientation().equals(orientation)); 
 for (int i = 0; i < items.length; i++) { IContributionItem iContributionItem = items[i]; 
 for (int i = 0; i < fBreakpoints.length; i++) { 
 IBreakpoint breakpoint = fBreakpoints[i]; 
 for (int i=0; i<fEditors.length; i++) { fEditors[i].dispose(); 
 * @author Eugen Neufeld <eneufeld@eclipsesource.com> * @since 1.22 
 return ""; 
 * @author Eugen Neufeld <eneufeld@eclipsesource.com> * @since 1.22 
 for (PackageVisibilityStatement stat : stats) { PackageBinding pb = stat.resolvedPackage; 
 this.declaredPackages.put(packageName, packageBinding.getIncarnation(this)); 
 ModuleBinding primaryModule = childPackage.enclosingModule; 
<|del|> 
 public static final String AUTHORS = "Authors"; //$NON-NLS-1$ 
 public static final String VERSION = "Version"; //$NON-NLS-1$ 
 String allAuthorsLabel = ""; //$NON-NLS-1$ 
 } catch (UnknownPropertyException e) { // nothing to do. If the property doesn't exist, we probably get an exception for nothing! } catch (NotRemoveableException e) { Activator.log.error(e); 
<|del|> 
 return image; 
 Image image = (Image) ((MUIElement) element).getTransientData().get( IPresentationEngine.OVERRIDE_ICON_IMAGE_KEY); 
 if (!exist) { 
 protected void showTab(MUIElement tabElement) { 
 try { DataInputStream input = new DataInputStream(new FileInputStream(f)); try { map.putAll(readOldFormatExtensionMappings(input)); } finally { input.close(); f.delete(); } 
 * @param character an upper case hex character 
<|del|> 
 private static final String TYPE_NAME = "local-selection-transfer-format" + System.currentTimeMillis(); //$NON-NLS-1$ ; 
 return Long.toString(value) + timeIntervalPrefixes[i]; 
 if (parent != null) { rv = parent + "."; 
<|del|> 
 createAdapterTypes(adapters); 
<|del|>
 protected final boolean firstParent; 
 public <T extends ITmfTreeDataProvider<? extends ITmfTreeDataModel>> boolean removeDataProvider(ITmfTrace trace, T provider) { return fInstances.remove(trace, provider); 
 private void checkCreateFBType(FB fb) { 
 public void createFBType(final FBType fbType) throws DeploymentException { setAttribute(getDevice(), "FBType", getTypes()); //$NON-NLS-1$ 
 if (fFormatterOptions == null) { 
 resultingEdits= rewrite.rewriteAST(); } else { resultingEdits= rewrite.rewriteAST(new Document(fCu.getSource()), fFormatterOptions); 
 @SuppressWarnings("rawtypes") 
 @SuppressWarnings("rawtypes") 
 setSelectionToWidget(Arrays.asList(treeSelection.getPaths()), reveal); 
 * IBM Corporation - initial API and implementation * Oakland Software (Francis Upton - francisu@ieee.org) * bug 197113 Project Explorer drag and drop selection not working properly 
 private void checkCreateFBType(FBType fbType) { 
 projectSelection.add(((AutomationSystem) element).getProject()); } else if (element instanceof IProject) { projectSelection.add((IProject) element); 
 // I have nothing of my own to reveal; only the next step to drill down into 
 private static Collection<LSBasedHyperlink> toHyperlinks(final IDocument document, final IRegion linkRegion, Either<List<? extends Location>, List<? extends LocationLink>> locations) { 
 if (index < getChildren().size()) { refEditPart = (EditPart) getChildren().get(index); 
 } } 
 private static boolean enableUriFragmentCache = false; 
 * but sometimes it is already known by the caller or it can be null (during drag'n'drop of element with 
 * @return a step-wise chain of operations to progressively reveal the {@code object} * in the given {@code scope}, or {@linkplain RevealStep#fail() a failed step} if none 
 * @return a step-wise chain of operations to progressively reveal the {@code object} * in the given {@code scope}, or {@linkplain RevealStep#fail() a failed step} if none 
 if (isDisposed()) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED); /* * Conversion formula comes from Cairo's _cairo_color_double_to_short() * and color_to_pixel() functions. See bug 549181 and 549101 for more info. */ 
 if (isDisposed()) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED); /* * Conversion formula comes from Cairo's _cairo_color_double_to_short() * and color_to_pixel() functions. See bug 549181 and 549101 for more info. */ 
 buf= new StringBuilder(); 
 StereotypeApplicationConflictTests.class, }) 
import java.util.HashMap; 
 private static URI getStereotypeURI(EObject stereotypeApplication) { 
 private static <K, L, V> V put(Map<K, Map<L, V>> mapOfMaps, K key1, L key2, V value) { 
 /** * @author Andrew M. Finkbeiner */ 
 /** * @author Andrew M. Finkbeiner */ 
 /** * @author Andrew M. Finkbeiner */ 
 * Enable or disable the ability to cache the computed values. The cache is cleared when this method is called to 
 protected static final String TEXT_LINE_SEPARATOR = "\n"; 
 private DescriptionDescriptor m_description; 
 private TableListener m_tableListener; private boolean m_isGrouping; private boolean m_isSorting; 
<|del|> 
<|del|> 
 private int m_httpStatus; private String m_errorCode; 
 private int m_httpStatus; private String m_errorCode; 
 public ErrorResponseBuilder withHttpStatus(int httpStatus) { m_httpStatus = httpStatus; 
 public ErrorResponseBuilder withErrorCode(int errorCode) { m_errorCode = String.valueOf(errorCode); 
 public ErrorResponseBuilder withErrorCode(String errorCode) { m_errorCode = errorCode; 
 } else if (newNameValue != null) { RefactoringUIPlugin.logErrorMessage(RefactoringUIMessages.RenameResourceHandler_ERROR_EXPECTED_STRING + newNameValue.getClass().getName()); 
 addPage(new RenameResourceRefactoringConfigurationPage(processor)); 
 RefactoringUIPlugin.logErrorMessage(NLS.bind(RefactoringUIMessages.RenameResourceHandler_ERROR_EXPECTED_STRING, newNameValue.getClass().getName())); 
 private class ValueCommentCellModifier implements ICellModifier { 
<|del|>
 AWorkbench.popup("Commit Branch Error!", "All blocking reviews must be completed before committing a new branch. Please complete all blocking reviews in order to continue."); 
<|del|> 
 isDarkTheme = (lpData[0] == 0); 
 @Deprecated 
 CloseResourceAction cra = new CloseResourceAction(() -> null); cra.selectionChanged(new StructuredSelection(project)); cra.run(); 
 return FileUtils.getFileAttributesBasic(this, path); 
 if (line != null) { // successfully parsed as a non-comment line // mark this line as a comment explicitly 
<|del|>
 private void add(String... searchStrings) { boolean hasStrings= false; if (searchStrings != null) { for (String searchString : searchStrings) { hasStrings|= insert(searchString); 
 // The algorithm has been modified to support both reporting all matches or only leftmost longest matches. 
<|del|> 
 // first match. Note that we _do_ have a match at least from this node itself. 
 MultiStringMatcher m = MultiStringMatcher.builder().add((String[]) null).build(); List<Match> matches = m.find("dddhiheddd", 0); assertEquals("Expected no match", 0, matches.size()); 
 // Results are ordered by offset. // We are searching for the leftmost so all remaining candidates do not matter. 
 public static final String PACKAGING = "eclipse-target-definition"; 
 FileUtils.delete(root, FileUtils.RECURSIVE | FileUtils.RETRY); 
 LOG.warn(MessageFormat.format( JGitText.get().skipNotAccessiblePath, file.getPath())); 
 LOG.warn(MessageFormat.format(JGitText.get().readPipeIsNotAllowed, command, dir)); 
 // ignore deltas with filtered resource if (delta != null && getSyncFileFilter(project).shouldIgnore(delta.getResource())) { 
 // ignore deltas with filtered resource if (delta != null && getSyncFileFilter(project).shouldIgnore(delta.getResource())) { 
 * internal data is not there. We do not support that and in such case 
 * internal data is not there. We do not support that and in such case 
 * Bug 550423: When non-XP-theme COMMCTL32.DLL gets loaded, undocumented * internal data is not there. We do not support that and is such case * GetWindowLongPtr function fails and return zero. 
 int count = (int)OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0); 
<|del|> 
<|del|>
 Assert.isNotNull(this.exportedTable, Messages.ExportAsTableConfigurationWizard_WeCantFoundTheTableToExport); 
 // ask "outer" object about field probably declared within return outerObject.getField(name, outer.signature()); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 assertThat(values, containsInAnyOrder(valueFor(CHILD_2, 2), valueFor(CHILD_3, 3))); 
 private static final String SAD_ENTRIES_MAPPING = "sad-entries-mapping"; 
 * Factory producing readers for IpSec plugin's data. 
 * Factory producing readers for IpSec plugin's data. 
 .newHashSet(InstanceIdentifier.create(Spd.class).child(SpdEntries.class)), new GenericInitListReader<>( IPSEC_STATE_ID.augmentation(IpsecStateSpdAugmentation.class).child(Spd.class), new IpsecStateSpdCustomizer(vppApi))); 
 this.ipsecSaDetailsReplyDumpManager = new DumpCacheManager.DumpCacheManagerBuilder<IpsecSaDetailsReplyDump, Void>() .withExecutor(new IpsecStateCustomizer.IpsecStateSaDetailsDumpExecutor(vppApi)) .acceptOnly(IpsecSaDetailsReplyDump.class) .build(); 
 final Optional<IpsecSaDetailsReplyDump> dumpSa = ipsecSaDetailsReplyDumpManager.getDump(id, ctx.getModificationCache()); 
 saBuilder.setSpi(Integer.toUnsignedLong(details.spi)) .setAntiReplayWindow(Long.valueOf(details.replayWindow).intValue()) .setAuthenticationAlgorithm(IkeIntegrityAlgorithmT.forValue(details.integAlg)) .setEncryptionAlgorithm(IkeEncryptionAlgorithmT.forValue(details.cryptoAlg)); 
 return getReplyForRead(jvpp.ipsecSaDump(dump).toCompletableFuture(), identifier); 
 // VPP doesn't support deletion of local key file 
<|del|> 
 entry.useAntiReplay = dataAfter.getAntiReplayWindow() > 0 ? BYTE_TRUE : BYTE_FALSE; 
 * Factory producing writers for IpSec plugin's data. 
 registry.subtreeAdd(Sets.newHashSet(InstanceIdentifier.create(SadEntries.class).child(SourceAddress.class), 
 new GenericWriter<>(IKE2_ID.child(Policy.class).child(Identity.class), new Ikev2PolicyIdentityCustomizer(vppApi))); 
 * Module class instantiating IpSec plugin components. 
<|del|> 
 Sets.newHashSet(IID.child(ConformAction.class), IID.child(ExceedAction.class), IID.child(ViolateAction.class)), new GenericListWriter<>(POLICER_IID, new PolicerCustomizer(vppApi, policerContext), new PolicerValidator(policerContext))); 
 * Copyright (c) 2019 PANTHEON.tech. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 this.statisticsManager = checkNotNull(statisticsManager, "Statistics Manager should not be null"); 
 LOG.debug("Sending InterfaceStatisticsDump request..."); 
 checkNotNull(bridgeDomainContext, "bridgeDomainContext should not be null"); 
 checkNotNull(bridgeDomainContext, "bridgeDomainContext should not be null"); 
 checkNotNull(disabledInterfacesManager, "disabledInterfacesManager should not be null"); 
 private void validateVxlan(final Vxlan data) { 
 public String getProjectName() { return mProjectName; 
 public String getProjectID() { return mProjectID; 
 public String getProjectPath() { return mProjectPath; 
<|del|> 
<|del|>
<|del|>
 this.controllerOptions = controller.getOptions(); 
<|del|> 
<|del|> 
<|del|> 
 mMatrix = MatrixHelper.createMatrix(data); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 System.loadLibrary("model-exporter-jni"); 
 * @param inputPath - path and name of the .dae file to process. Required. * @param outputPath - path (incl. name) to save the .dli and .bin files to. 
<|del|>
<|del|> 
 static void createPart(String id) { 
<|del|>
<|del|>
<|del|>
 * A widget for a property whose value can be presented as a Text box. 
<|del|> 
<|del|>
<|del|> 
 * Provides descriptions of a given list of resources. 
 * Return the list of resources. 
import org.eclipse.jface.viewers.ITreeContentProvider; 
 public void populate(ITreeContentProvider provider, PropertyProviderSelectionChangedListener listener) { 
<|del|> 
 receiver.register("Texture" + (index+1), new Property(this, "TextureArray", Property.Type.String, true, null, new ArrayElementSetter(index), String[].class)); 
 String string = ""; 
 token.login(password); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } catch (Exception e) { CMS.debug(method + "failed getting issuer from RevokeRequest:" + e.toString()); 
 new PasswordConverter(), 
<|del|> 
<|del|> 
 * a worker thread pool, which allows blocking operations inside the Future. 
 * @return A Handler with the Future which contains the post collection logic. 
<|del|> 
 private final Map<String, AtomicLong> qualityMap = new ConcurrentHashMap<>(); private final Map<String, AtomicLong> errorMap = new ConcurrentHashMap<>(); 
 public void registerQueueMetrics(AtomicInteger currentQueueSize, int queueSize) { 
 public void registerTotalMetrics(AsyncResult<CollectorJobResult> postResult) { 
<|del|> 
 return new CollectorJobResult(requestId, "test-src", "test-quality", "test-created", new JsonObject(), error); 
<|del|> 
 // sort cert chain from root to leaf certChain = CryptoUtil.sortCertificateChain(certChain); for (X509Certificate cert : certChain) { logger.debug("PKITrustManager: - " + cert.getSubjectDN()); 
 public void checkServerTrusted(X509Certificate[] certChain, String authType) throws CertificateException { 
 if ("rsa".equals(algorithm)) { 
 else if ("ecc".equals(algorithm)) { 
 } else { throw new Exception("Invalid algorithm: " + algorithm); } 
 lenOrCurve, "" + length, 
 content.putSingle("profileId", actualProfileId); 
<|del|> 
 String msg = ""; if (serial == null) { throw new EBaseException(method + "paramster serial cannot be null"); } 
 throw new PKIException("Failed to parse profile configuration", e); 
 Pattern.compile("^plugin-" + PLUGIN_NAME_PATTERN_STRING + "-[a-zA-Z]+$"); 
 PluginPermissionsUtil( 
 * scoped to. * @throws PermissionBackendException if failure consulting backend configuration. 
 // TODO(xchangcheng): implement for plugin defined project permissions. 
 new Description("average processing delay per updated change") 
 new Description("processing delay for a processing single batch of pushes") 
 Field.ofString("type", "type of push (create/replace, autoclose, normal)")); 
 if (!autoclosed.isEmpty()) { metrics.changes.record(ResultChangeIds.Key.AUTOCLOSED, autoclosed.size()); totalChanges += autoclosed.size(); } 
 if (testCheckerUpdate.forceInvalidConfig()) { 
 public abstract boolean forceInvalidConfig(); 
 } @Test public void getNonExistingCheckWithInvalidUuidFails() throws Exception { exception.expect(ResourceNotFoundException.class); exception.expectMessage("Not found: n0n-e#isting"); checksApiFactory.revision(patchSetId).id("n0n-e#isting").get(); } 
 ownerId = accountId; 
 Field.ofString("type", "type of push (create/replace, autoclose)")); 
 "Processing delay per push divided by the number of changes in said push. (Only includes pushes which contain changes.)") 
 private static ProjectAccessInput createAccessInput(String accessSection, String permissionName) { 
 public void isPluginPermissionReturnsTrueForValidName() { 
 public void isPluginPermissionReturnsFalseForInvalidName() { ImmutableList<String> inValidPluginPermissions = 
 public void isPluginPermissionReturnsFalseForInvalidName() { ImmutableList<String> inValidPluginPermissions = 
 public void setAccessAddPluginCapabilitySucceed() throws Exception { 
 jiraClient.addValueToField(itsServerInfo, issueKey, value, fieldId); // No value to return 
 input = new CheckInput(); 
 throws RestApiException, IOException, OrmException { if (input == null) { input = new CheckInput(); } 
 log.error("invalid value for {}; using default value {}", name, defaultValue); log.debug("Failed to retrieve integer value: {}", e.getMessage(), e); 
 log.info("[{}] Setting kafka property: {} = {}", subsectionName, propName, value); 
 log.error("invalid value for {}; using default value {}", name, defaultValue); log.debug("Failed to retrieve boolean value: {}", e.getMessage(), e); 
public class Module extends LifecycleModule { private static final Logger log = LoggerFactory.getLogger(Module.class); 
 listener().to(MultiSiteLogFile.class); 
<|del|> 
 LOGGER.debug("Already connected."); 
 log.debug("Invalidated cache {}", entry.getCacheName()); 
 log.debug("Invalidated cache {}[{}]", entry.getCacheName(), entry.getKey()); 
 msgLog.info("Consuming event: Header[{}] Body[{}]", event.getHeader(), event.getBody()); 
Copyright (C) 2019 The Android Open Source Project 
 private static String stripTrailingSlash(String name) { while (name.endsWith("/")) { name = name.substring(0, name.length() - 1); } 
 private static String strip(String name) { 
 @Test 
 @Test 
 "gerrit create-project --branch master --owner " + newGroupName + " " + newProjectName + ".git"); 
<|del|> 
<|del|> 
 bind(SharedRefDatabase.class).to(InMemoryDfsRefDatabase.class); 
 return refName.startsWith("refs/changes") && !refName.endsWith("/meta"); 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
<|del|> 
Copyright (C) 2019 The Android Open Source Project 
 * attributes of the new check. To create the check in the storage for real, {@link 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
<|del|> 
 @Inject 
<|del|> 
 Thread.sleep(2000L); 
 .containsAllOf(changeNotesRef, patchsetRef); 
import org.eclipse.jgit.revwalk.RevWalk; import org.junit.Before; 
 "Gerrit is still running on ReviewDb: please migrate to NoteDb " + "and then reload the multi-site plugin."); 
<|del|> 
 Stream.of(checkStates).forEach(listPendingChecks::addState); 
 Stream.of(checkStates).forEach(listPendingChecks::addState); 
import static com.googlesource.gerrit.plugins.its.jira.JiraConfig.PROJECT_CONFIG_PASSWORD_KEY; import static com.googlesource.gerrit.plugins.its.jira.JiraConfig.PROJECT_CONFIG_URL_KEY; import static com.googlesource.gerrit.plugins.its.jira.JiraConfig.PROJECT_CONFIG_USERNAME_KEY; 
 Ordering.natural().sortedCopy(result.errors).forEach(e -> logger.atSevere().log(e)); Ordering.natural().sortedCopy(result.warnings).forEach(w -> logger.atWarning().log(w)); 
 readFiles.put(Parser.combine(project, file), content); 
 // TODO: Check if an included file exists and that it has valid syntax. 
 Set<String> allFiles; // to detect recursive inclusion quickly 
 allFiles.add(combine(project, file)); 
 allFiles.remove(combine(currentProject(), currentFile())); 
 return allFiles.contains(combine(project, file)); 
 PushType pushType; 
 totalChanges = replaced.size() + created.size(); 
 .containsAllOf( changeNotesRef, patchsetRef); // 'refs/sequences/changes' not always updated thus not checked 
<|del|> 
 throw asRestApiException("Cannot retrieve check", e); 
 static <T extends Enum<T> & ListOption> EnumSet<T> fromBits(Class<T> clazz, int v) { EnumSet<T> r = EnumSet.noneOf(clazz); T[] values; 
 public boolean get(ChangeNotes notes, Optional<String> claimedOriginal) 
 return pureRevertCache.isPureRevert( notes.getProjectName(), ObjectId.fromString(notes.getCurrentPatchSet().getRevision().get()), claimedOriginalObjectId); 
 private static final String ID_CACHE = "pure_revert"; 
 * Returns {@code true} if {@code claimedRevert} is a pure (clean) revert of the change that is * referenced in {@link com.google.gerrit.reviewdb.client.Change#getRevertOf()}. 
 ObjectId.fromString(changeNotes.getCurrentPatchSet().getRevision().get())); 
 * @throws IOException if there was a problem with the storage layer 
 throw new BadRequestException("can't check against initial commit"); 
 return pureRevert.get(notes(), Optional.empty()); } catch (IOException | BadRequestException | ResourceConflictException e) { 
 public void serialization() { 
 static String getFileKey(String project, String file) { 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
<|del|> 
 /** * When deleting a Ref this temporary Ref Tombstone will be created and then cleaned-up at a later * stage by the garbage collection */ 
<|del|> 
 public boolean equals(Object other) { if (this == other) { 
 "Error trying to perform CAS at path %s", ZkRefInfoDAO.pathFor(projectName, newRef)); 
 ZkRefInfoDAO marshaller, 
 private final ZookeeperTestContainerSupport zookeeperContainer; 
 install(new ValidationModule(multiSiteConfig)); listener().toInstance(new ZookeeperStopAtShutdown(zookeeperContainer)); 
 default String aBranchRef() { return RefNames.REFS_HEADS + testBranch(); 
 ObjectId objectId = AN_OBJECT_ID_1; String refName = aBranchRef(); 
 marshaller.create(new ZkRefInfo(projectName, oldRef)); 
 inZk.get().equals(TombstoneRef.forRef(oldRef)); 
 final ObjectId objectId = readObjectIdAt(rootPath + "/" + OBJECT_ID_PATH); 
 @Named("ZkLockTimeout") Duration lockTimeout) { 
import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.PatchSet; 
<|del|> 
 testPatchSetId = result.getPatchSetId(); testChangeId = result.getChangeId(); 
<|del|> 
 public void disabledCheckerDoesNotBlockingSubmit() throws Exception { 
 public void multipleCheckerBlockingSubmit() throws Exception { CheckerUuid checkerUuid = newRequiredChecker().create(); 
 * "owners" found in lines control changed files in 'dir'. 
 * For an 'include' statement, parsed data is all appended to the given result parameter. 
 * The inclusion is skipped if the to be included file is already on the including file stack. 
 // containsExactly does not check order of elements. 
 configurePlugin("enforceLevel", "ENFORCE"); PushOneCommit.Result r = createChange("test message", "A/1/foo.c", "void main()\n"); 
 * referenced in {@link Change#getRevertOf()}. 
 ChangeNotes claimedOriginal = 
 @Test public void TestDummyRepoSetup() throws Exception { createTestRepositoryContent(); 
 PluginConfig pluginConfig = pluginConfigFactory.getFromProjectConfigWithInheritance(projectState, pluginName); 
 if (enforceLevel == EnforcementLevel.DISABLED) { this.logger .atInfo() .log( "OwnersFileRule was run for change %s but enforcement is disabled via project.config", Config.getChangeId(cd)); 
 OwnersDb db = Cache.getInstance(pluginConfigFactory, repoManager) .get(true, projectState, accounts, emails, repoManager, pluginConfigFactory, cd); 
 if (result >= 0) { sr.status = Status.OK; return ImmutableList.of(sr); 
 public void changeWithoutPermissions() throws Exception { 
 if (!exists(rootPath)) { return Optional.empty(); } 
 .setFallbackText("All required checks must pass") .setType("checks_pass") 
 .setFallbackText("All required checks must pass") .setType("checks_pass") 
<|del|> 
 Project.NameKey otherRepo = new Project.NameKey("All-Projects"); checkerOperations.checker(checkerUuid).forUpdate().repository(otherRepo).update(); 
 static byte[] writeObjectId(ObjectId value) throws IOException { 
 checkers.checkersOf(resource.getProject()).stream() 
 /** Backfills checks for relevant checkers with default when they don't exist yet. */ public abstract boolean backfillChecks(); 
 new DistributedAtomicValue(client, pathFor(projectName, oldRef, newRef), retryPolicy); 
 new DistributedAtomicValue(client, pathFor(projectName, oldRef, newRef), retryPolicy); 
 @Inject private AllProjectsName allProjects; 
<|del|> 
<|del|> 
<|del|> 
 checkerOperations.checker(checkerUuid).forUpdate().repository(allProjects).update(); 
 assertThat(changeInfo.submittable).isTrue(); assertThat(changeInfo.requirements).isEmpty(); 
 assertThat(changeInfo.submittable).isFalse(); assertThat(changeInfo.requirements).containsExactly(SUBMIT_REQUIREMENT_INFO); 
 @Before public void setUp() throws Exception { assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.ON); 
 getPostFilteredPendingChecks(cd.project(), cd.currentPatchSet().getId()) 
 check("patchSet()").that(patchSet).isNotNull(); 
 DynamicSet.bind(binder(), ChangeAttributeFactory.class) 
 @Test public void allBlockingConditionsConsidered() { assertThat(EnumSet.allOf(BlockingCondition.class)).containsExactly(STATE_NOT_PASSING); } 
<|del|> 
<|del|> 
 if (!opts.combined) { 
 checkKey.repository(), refUpdate, currentUser.map(user -> user.state()).orElse(null)); 
 public void updatingCheckStateUpdatesCache() throws Exception { 
 * can also implement a way to clear per user sessions. * * @return account ID. 
 /** * This is public so that plugins that implement a web session, * can also implement a way to clear per user sessions. */ 
<|del|> 
<|del|> 
 assertMessage(e, expectedMessageParts); 
 check("getType()").that(typeName(actual().getType())).isEqualTo(typeName(expectedType)); 
 public static Check newBackfilledCheck(Project.NameKey project, PatchSet ps, Checker checker) { return Check.builder(CheckKey.create(project, ps.getId(), checker.getUuid())) 
 checker .get() .queryMatchingChanges( retryHelper, queryBuilderProvider.get(), changeQueryProcessorProvider); CheckerUuid checkerUuid = checker.get().getUuid(); 
 Enums.getIfPresent(CheckState.class, value) .toJavaUtil() 
 this.checkerUuid = requireNonNull(checkerUuid, "checkerUuid"); 
 && servlet.matcher(((HttpServletRequest) req).getServletPath()).matches(); 
 check("trimmedMessages()").that(got).containsAtLeastElementsIn(expectedLines).inOrder(); 
 assertThat(checkersByRepositoryNotes.get(project)).containsExactly(checkerUuid); assertThat(getRefsMetaCheckersState()).isEqualTo(commitId); 
 assertThat(checkersByRepositoryNotes.get(project2)).isEmpty(); assertThat(getRefsMetaCheckersState()).isEqualTo(commitId); 
 public void noOpUpdate() throws Exception { 
 log.atWarning().withCause(e).log("Cannot check project access permission"); 
 private final Filter errorHandler; 
public final class RequestFailureException extends RuntimeException { 
 LocalDiskRepositoryManager localDiskRepositoryManager) { this.gitRepositoryManager = localDiskRepositoryManager; } public MultiSiteGitRepositoryManager(GitRepositoryManager gitRepositoryManager) { 
 bind(GitRepositoryManager.class).to(MultiSiteGitRepositoryManager.class); 
 bind(GitRepositoryManager.class).to(MultiSiteGitRepositoryManager.class); 
 doReturn(true).when(sharedRefDb).compareAndPut(A_TEST_PROJECT_NAME, oldRef, newRef); 
 @Assisted Repository repository) { super(new BaseRepositoryBuilder()); 
 return multiSiteRefDatabase; 
 private boolean quiet; 
<|del|> 
 return wrap(name, gitRepositoryManager.openRepository(name)); 
 return wrap(name, gitRepositoryManager.createRepository(name)); 
<|del|> 
<|del|> 
 this(new FileBasedConfig(sitePaths.etc_dir.resolve(MULTI_SITE_CONFIG).toFile(), FS.DETECTED)); 
 protected void configure() { bind(DestinationFactory.class).in(Scopes.SINGLETON); 
 "Cannot get rate limits for anonymous access from remote host ''{}''", req.getRemoteHost(), e); 
 logger.error("Failed to post heartbeat event: {}", e.getMessage(), e); 
 "%d %ss reindexed in %d msec (%d/sec), %d failed", 
 log.warn( "Change {} seems too old compared compared to the event timestamp (event-Ts={} >> change-Ts={})", id, indexEvent, changeTs); rescheduleIndex(id, maybeBody, retryCount++); 
 log.atSevere().log("Failed to process eviction request: %s", e.getMessage()); 
 "Failed to %s %s on %s [%d/%d]", action, key, destination, execCnt, maxTries); 
 log.atSevere().withCause(ie).log( 
 + " Only two members are supported. Members: %s", 
 log.atFine().log("Channel bound to %s", address.get()); 
 ImmutableList.of("refs/draft-comments/.*", "refs/changes/[0-9]+/[0-9]+/[0-9]+"); 
 private final Pattern servletPath = 
 if (!self.get().isIdentifiedUser()) { 
<|del|> 
 String refName = ref.getName(); return refName.startsWith("refs/draft-comments") || (refName.startsWith("refs/changes") && !refName.endsWith("/meta")); 
<|del|> 
<|del|> 
 return refName == null || refName.startsWith("refs/draft-comments") 
 new DistributedAtomicValue(client, pathFor(projectName, oldRef, newRef), retryPolicy); 
 assertThat(zookeeperContainer.readRefValueFromZk(A_TEST_PROJECT_NAME, ref)) .isEqualTo(ref.getObjectId()); 
 DispatchCommand( PermissionBackend permissionBackend, @Assisted Map<String, CommandProvider> all, DynamicSet<SshCommandPreExecutionFilter> commandFilters) { 
 throw new IllegalArgumentException("username " + username + " already in use"); 
 private List<Destination> allDestinations; 
 private List<Destination> allDestinations; 
<|del|> 
 RevWalk rw = new RevWalk(repo)) { 
 Ref nullRef = SharedRefDatabase.NULL_REF; 
 // This ref should be ignored even if newRef is null assertThat(zkSharedRefDatabase.compareAndPut(A_TEST_PROJECT_NAME, existingRef, nullRef)) 
 private List<ChangeData> executeIndexQueryWithRetry(Predicate<ChangeData> predicate) 
 return executeIndexQueryWithRetry(createQueryPredicate(checker)); 
 @Test public void verifyTooLongQuery() throws Exception { String query = CheckerTestData.longQueryWithSupportedOperators(5); assertThat(query).isEqualTo("file:foo file:foo file:foo file:foo file:foo"); CheckerQuery.clean(query); } 
 Future<?> future = executor.submit(evaluationTask); 
 private void addTaskListener(Future<?> future, EvaluationTask evaluationTask) { ListenableFuture<?> listenableFuture = JdkFutureAdapters.listenInPoolThread(future); 
 private void addTaskListener(Future<?> future, EvaluationTask evaluationTask) { ListenableFuture<?> listenableFuture = JdkFutureAdapters.listenInPoolThread(future); 
<|del|> 
 when(executor.submit(taskSamePathNotCompleted)).thenReturn(new CompletableFuture<>()); 
 /** Name of the access section. It could be a ref pattern or something else. */ 
 /** Name of the access section. It could be a ref pattern or something else. */ 
<|del|> 
Copyright (C) 2019 The Android Open Source Project 
 SuperManifestRefUpdatedListener.trimStack( 
 // Create normalUserGroup, containing user, and contextUserGroup, containing contextUser 
 // Create normalUserGroup, containing user, and contextUserGroup, containing contextUser 
 DynamicSet<SshExecuteCommandInterceptor> commandInterceptors, @Assisted Map<String, CommandProvider> all) { 
 String.format( "blocked by %s, contact gerrit administrators for more details", commandInterceptor.name())); 
 * @return whether or not this command with these arguments can be executed 
 for (SshExecuteCommandInterceptor commandInterceptor : commandInterceptors) { if (!commandInterceptor.accept(actualCommandName, args)) { throw new UnloggedFailure( 126, "blocked by " + commandInterceptor.name() + ", contact gerrit administrators for more details"); 
 * @return whether or not this command with this arguments can be executed 
<|del|> 
 public void stop() { if (scheduledCleanupTask != null) { scheduledCleanupTask.cancel(true); scheduledCleanupTask = null; } 
<|del|> 
 try (OpenRepo allUsersRepo = OpenRepo.open(repoManager, allUsersName)) { allUsersRepo.addUpdates(draftUpdates); 
 final AllUsersName allUsers; 
<|del|> 
 // Don't email if an administrator removed a password on behalf of the user. 
 deleteKeyFactory.create(user, "SSH").send(); 
 "Cannot send SSH key deletion message to {}", user.getAccount().getPreferredEmail(), e); 
<|del|> 
 private void validateBatchRefUpdateAndApply( 
 logger.atWarning().log("Failed to process batch update %s", e.getMessage()); 
 oldRefs.getOrDefault(cmd.getNewId(), sharedRefDb.NULL_REF), 
<|del|> 
 boolean isInSync; 
 throw new NoSuchElementException(errorMessage); 
 String errorMessage = "Failing batch executeWrapper in MultiSiteBatchRefUpdate"; logger.atWarning().withCause(e).log(errorMessage); 
 "Unable to create ref '%s', trying to create a new ref but there is a value " 
 } /** * Verify if the DB contains a value for the specific project and ref name * * @param projectName * @param refName * @return */ boolean exists(String projectName, String refName) throws Exception; 
 if (ignoreRefInSharedDb(MoreObjects.firstNonNull(oldRef.getName(), newRef.getName()))) { 
<|del|>
<|del|> 
 new ZkSharedRefDatabase(zookeeperContainer.getCurator(), new RetryNTimes(5, 30), 1000l); 
 // Don't email if an administrator removed a key on behalf of the user. 
 "Cannot send HttpPassword added or changed message to {}", user.getAccount().getPreferredEmail(), e); 
 /** ID of commit. */ 
 // directly, and instead use the public getter/setter that wraps an ObjectId. 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
 return abbreviateName(id, ABBREV_STR_LEN); 
 * @param n number of hex chars, 1 to 40. 
 * chars. * @throws IOException if an error occurs while looking for ambiguous objects. 
 * @param n minimum number of hex chars, 1 to 40. 
 * {@code n} chars. * @throws IOException if an error occurs while looking for ambiguous objects. 
 return "implicit merge of " + abbreviateName(commit); 
 // Recipe for creating ambiguous IDs courtesy of git core: // https://github.com/git/git/blob/df799f5d99ac51d4fc791d546de3f936088582fc/t/t1512-rev-parse-disambiguation.sh 
 return "implicit merge of " + abbreviateName(commit); 
 public Path ensureForBackend(LfsBackend backend) throws IOException { return getForBackend(backend, true); } 
 Path ensured = Files.createDirectories(Paths.get(dataDir)); 
 /** * Returns the name of the REST API handler that is in the stack trace of the caller of this * method. */ 
 firstNonNull(NoteDbUtil.guessRestApiHandler(), "Update NoteDb refs async"), false); 
 public void markCommentPublished(Comment c) { checkState(!delete.containsKey(key(c)), "comment already marked for deletion"); 
 boolean publishOnly = draftUpdates.values().stream().allMatch(ChangeDraftUpdate::canRunAsync); 
<|del|> 
<|del|> 
 public List<TopMenu.MenuEntry> topMenus() throws RestApiException { 
 protected void doIndex(String id, Optional<ChangeIndexEvent> indexEvent) { 
 colsProto .toBuilder() 
 logger.atSevere().log( 
 @Nullable ProjectState projectState, 
 private static final String NAME = "combined_check_state"; 
 Field.ofBoolean( "updated", "whether reloading resulted in updating the cached value")); 
 void recordReload(boolean updated, Duration elapsed) { reloadLatency.record(updated, elapsed.toNanos(), NANOSECONDS); reloadCount.incrementAndGet(updated); 
 metrics.recordReload(updated, sw.elapsed()); 
 CheckInput checkInput = new CheckInput(); checkInput.state = CheckState.FAILED; checksApiFactory.revision(psId).id(checkerUuid).update(checkInput); 
 expect(cd.project()).andReturn(Project.nameKey("My-Project")); expect(cd.getId()).andReturn(Change.id(1)); expect(cd.currentPatchSet()).andThrow(new StorageException("Fail for test")); 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
 private Change newChange() { 
<|del|> 
 * @param checkStateCount count of check states. 
 * @return the {@link CheckStateCount} of the given state map. 
 for (Map.Entry<CheckState, Boolean> checkStateAndRequiredState : statesAndRequired.entries()) { CheckState state = checkStateAndRequiredState.getKey(); 
 PatchSet.Id currentPathSetId; 
 /** * Check if a refName should be ignored by shared Ref-Db * * @param refName * @return true if ref should be ignored; false otherwise */ default boolean isRefToBeIgnoredBySharedRefDb(String refName) { 
 PRODUCTION, LibModuleLoader.loadModules(cfgInjector, LibModuleType.DB_MODULE)); 
/** Loadable module type for the different Gerrit injectors. */ 
 * Returns the module type for libModule loaded from <gerrit_site/lib> directory. 
 protected void doIndex(Account.Id id, Optional<IndexEvent> indexEvent) { 
 private static final double CHANGE_NUM_DOUBLE = CHANGE_NUM; 
 private final String ALL = ".*"; 
 existingOrDefaultRef.put( refName, EnforcePolicy.valueOf(refAndPolicy[1].trim().toUpperCase())); projectAndRefsEnforcements.put(projectName, existingOrDefaultRef); 
 Optional.ofNullable( Optional.ofNullable(PREDEF_ENFORCEMENTS.get(projectName).get(refName)) .orElseGet(() -> PREDEF_ENFORCEMENTS.get(projectName).get(ALL))) .orElseGet(() -> PREDEF_ENFORCEMENTS.get(projectName).get(refName)); 
 Optional.ofNullable( Optional.ofNullable(PREDEF_ENFORCEMENTS.get(projectName).get(refName)) .orElseGet(() -> PREDEF_ENFORCEMENTS.get(projectName).get(ALL))) .orElseGet(() -> PREDEF_ENFORCEMENTS.get(projectName).get(refName)); 
 boolean isUpToDate(String project, Ref ref) throws IOException; 
<|del|> 
<|del|> 
<|del|> 
 return readObjectId(valueInZk).equals(ref.getObjectId()); 
 public Locker lockRef(String project, Ref ref) throws IOException { 
 throw new SharedLockException(project, ref, e); 
 MultiSiteBatchRefUpdate create(String project, RefDatabase refDb); 
 batchRefUpdate, () -> batchRefUpdate.execute(walk, monitor, options)); 
 batchRefUpdate, () -> batchRefUpdate.execute(walk, monitor)); 
 @Assisted RefDatabase refDb) { 
<|del|> 
 return doExecuteRefUpdate(refUpdate, refUpdateFunction); } catch (SharedDbSplitBrainException e) { validationMetrics.incrementSplitBrain(); 
<|del|> 
 } 
 protected RefPair newRefPairFrom(RefUpdate refUpdate) throws IOException { return new RefPair(refDb.getRef(refUpdate.getName()), refUpdate.getRef()); 
 protected RefPair newRefPairFrom(RefUpdate refUpdate) throws IOException { return new RefPair(refDb.getRef(refUpdate.getName()), refUpdate.getRef()); 
 @Assisted RefDatabase refDb) { 
 @Assisted RefDatabase refDb) { 
 public RefUpdate.Result executeRefUpdate( RefUpdate refUpdate, NoParameterFunction<RefUpdate.Result> gitUpdateFun) 
 public RefUpdate.Result executeRefUpdate( RefUpdate refUpdate, NoParameterFunction<RefUpdate.Result> gitUpdateFun) 
 if (localRef != null) { isInSync = sharedRefDb.isUpToDate(projectName, localRef); 
@RunWith(MockitoJUnitRunner.class) @Ignore // The focus of this test suite is unclear and all tests are failing when the code is // working, and the other way around 
 updateSharedDbOrThrowExceptionFor(refPairForUpdate); 
 RestApiException thrown = assertThrows(errType, () -> branch(branch).create(in)); if (errMsg != null) { assertThat(thrown).hasMessageThat().contains(errMsg); } 
 ReviewInput postSubmitReview1 = new ReviewInput(); postSubmitReview1.label(P.getName(), P.getMax().getValue()); revision(r).review(postSubmitReview1); 
 data.put("staticResourcePath", sanitizedStaticPath); 
 Map<String, Object> data = new HashMap<>(); 
<|del|> 
 PatchSet.Builder builder = PatchSet.builder() .id(patchSetIdConverter.fromProto(proto.getId())) .groups( proto.hasGroups() ? PatchSet.splitGroups(proto.getGroups()) : ImmutableList.of()); 
 public void getBranchReturnsCorrectBranchForTwoDigitsVersions() throws Exception { 
 * delegate.doFilter(req, res, chain); 
 INCORRECT_OBJECT_TYPE(SC_BAD_REQUEST), 
 /** Assertion methods for Gitiles. */ 
 .to(CustomSharedRefEnforcementByProject.class) .in(Scopes.SINGLETON); 
 accountState.getUserName().isPresent() 
 return new FileExtensionPredicate(ext); 
<|del|> 
 // Cache hasn't yet populated during update. // TODO(xchangcheng): still initialize the cache early without doing in the submit rule. 
 if (args.getSchema().hasField(ChangeField.EXTENSION)) { if (ext.isEmpty() && IndexModule.getIndexType(cfg).equals(IndexType.ELASTICSEARCH)) { return new FileWithNoExtensionInElasticPredicate(); } 
 public MissingMandatoryPluginsException(Collection<String> pluginNames) { 
 private static String getMessage(Collection<String> pluginNames) { 
 throw new MissingMandatoryPluginsException(missingMandatory); 
<|del|> 
 return getIndexType(injector.getInstance(Key.get(Config.class, GerritServerConfig.class))); 
 return cfg != null ? cfg.getEnum("index", null, "type", IndexType.LUCENE) : IndexType.LUCENE; 
 protected ChangeQueryBuilder(Definition<ChangeData, ChangeQueryBuilder> def, Arguments args) { super(def, args.opFactories); 
 if (ext.isEmpty() && IndexModule.getIndexType(cfg).equals(IndexType.ELASTICSEARCH)) { return new FileWithNoExtensionInElasticPredicate(); 
 abandonIfMergeable = cfg.getBoolean(SECTION, null, KEY_ABANDON_IF_MERGEABLE, true); cleanupAccountPatchReview = cfg.getBoolean(SECTION, null, KEY_CLEANUP_ACCOUNT_PATCH_REVIEW, false); 
 ProjectConfig cachedProjectConfig2 = projectCache.checkedGet(key).getConfig(); assertThat(cachedProjectConfig2).isNotSameInstanceAs(projectConfig); assertThat(cachedProjectConfig2.getProject().getDescription()).isEmpty(); 
 return check("getSections()").that(config.getSections()); 
 * A marker to say a method/type/field is added or is increased to public solely because it is * called from inside a project or an organisation using Gerrit. 
 RunwayStatus requestRunway(PushOne op) { 
 DeleteKeySender.Factory deleteKeySenderFactory) { 
 private final AddKeySender.Factory addKeySenderFactory; private final DeleteKeySender.Factory deleteKeySenderFactory; 
 deleteKeySenderFactory .create(user, toRemove.stream().map(Fingerprint::toString).collect(toList())) 
 private final DeleteKeySender.Factory deleteKeySenderFactory; 
 DeleteKeySender create(IdentifiedUser user, List<String> gpgKeyFingerprints); 
 DeleteKeySender create(IdentifiedUser user, List<String> gpgKeyFingerprints); 
 this.gpgKeyFingerprints = Collections.emptyList(); 
 @Assisted List<String> gpgKeyFingerprints) { 
 this.gpgKeyFingerprints = gpgKeyFingerprints; 
 throw new IllegalStateException("key type is not SSH or GPG"); 
 public String getGpgKeyFingerprints() { if (!gpgKeyFingerprints.isEmpty()) { return Joiner.on("\n").join(gpgKeyFingerprints); 
 * Records a permission to be updated. 
 abstract Builder name(String name); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 @Test(expected = IllegalArgumentException.class) public void testGetIndexThreadPoolSizeWithInvalidSize() { globalPluginConfig.setString(INDEX_SECTION, null, THREAD_POOL_SIZE_KEY, INVALID_INT); getConfiguration().index().threadPoolSize(); } 
 Map<String, List<Event>> eventsByType = receiveEventsByType(droppedEventsQueue); assertThat(eventsByType).isNotEmpty(); 
<|del|> 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
 /** Starts a builder for allowing a permission. */ 
 * quota issues so that the user gets throttled). * * <p>Will not be called if the {@link #requestTokens(String, QuotaRequestContext, long)} call * returned {@link QuotaResponse.Status#NO_OP}. 
<|del|> 
 ui.message(String.format("... migrated %d users", i)); 
<|del|> 
 // Pop up to the top-level source folder by looking for WORKSPACE. 
 protected Builder addActions(Builder builder, Id c) { return builder.addAction(delete(OPEN_CHANGES, c)).addAction(delete(OPEN_CHANGES, c)); 
 private final boolean omitType; 
 private Integer getMajor() { return Integer.valueOf(version.split("\\.")[0]); 
<|del|> 
 checkLabelName(result.name()); 
 .containsExactly( "abandon", "group global:Registered-Users", "abandon", "group global:Project-Owners"); 
 expected ? "expected to notify" : "expected not to notify", type + ": " + users.emailToName(email)), fact("but notified", recipientMapToString(recipients, users::emailToName))); 
 + "If you are sure you wish to delete this project, re-run with the --yes-really-delete flag.\n\n", 
<|del|> 
 projectOperations.project(allUsers).getHead(RefNames.refsUsers(accountId)); 
<|del|> 
 projectOperations 
 .add(allowCapability(GlobalCapability.ACCESS_DATABASE).group(REGISTERED_USERS)) .update(); projectOperations .project(project) .forUpdate() 
 ProjectConfig newLocal = projectConfigFactory.create(localKey); 
 .add(block(PUSH).ref("refs/heads/*").group(ANONYMOUS_USERS)) .update(); projectOperations .project(localKey) .forUpdate() 
<|del|> 
 * <p>If the execution is synchronous or the results are known a priori, consider using {@link 
 resultsCallback = requireNonNull(r, "results can't be null"); 
 results = ImmutableList.copyOf(requireNonNull(r, "results can't be null")); 
 () -> allowCapability(QUERY_LIMIT).group(REGISTERED_USERS).range(1, 0).build()); 
class GsonParser { private final Gson gson; 
 abstract static class Result { static Result create(boolean isValid, ImmutableList<CommitValidationMessage> messages) { 
 abstract static class Result { static Result create(boolean isValid, ImmutableList<CommitValidationMessage> messages) { 
 abstract ImmutableList<CommitValidationMessage> messages(); 
 return new FileExtensionPredicate(ext); 
 throw new ResourceConflictException("checks are not supported on a change edit"); 
 Set<Entry<Account.Id, Timestamp>> accounts = scanAccounts(db, ui).entrySet(); gc(ui); 
 * default visibility checker should cover all common use cases. 
 /** * @param topoSort whether to use a more thorough reachability check * by sorting in topological order */ 
 public void setUp() throws Exception { /** * master (branch not visible) * * <p>commitC | commit2 commitB | | commit1 commitA <--- refs/tags/v0.1 \ / \ / baseCommit */ 
 // This behavior is likely a bug. A fix might not be easy as it might break syntax highlighting. // TODO: Fix this issue or remove the broken parameter (at least in the documentation). 
 public GsonParser(@EventGson Gson gson) { this.gson = gson; 
<|del|> 
 private String pluginName; /** All-Projects project.config contents. */ 
 * the same pattern signature, this method returns a single valid finding with the number of 
 /** Default value of timeTestMax configuration parameter for avoiding excessive backtracking. */ 
 metrics.configurationErrors.increment(allProjectsName.get()); metrics.errors.increment(); 
 pluginName, event.getChange().currentRevision, entry.getKey(), arr.error); metrics.addReviewerErrors.increment(); metrics.errors.increment(); 
 ? (RestApiException) e : new RestApiException("Cannot post review", e); 
<|del|> 
/** Configuration state for {@link CopyrightValidator} from All-Projects project.config file. */ 
 private Integer getMajor() { return Integer.valueOf(version.split("\\.")[0]); 
 loggingCtx.setPerformanceLogRecords(oldPerformanceLogRecords); 
 LoggingContext.getInstance().setPerformanceLogRecords(oldPerformanceLogRecords); 
 "refs/tags/master-tag", "refs/tags/tree-tag"); 
 "HEAD", psRef1, metaRef1, psRef3, metaRef3, "refs/heads/master", "refs/tags/master-tag"); // tree-tag is not visible because we don't look at trees reachable from // refs 
import com.google.gerrit.testing.ConfigSuite; 
 throws ResourceNotFoundException, ResourceConflictException, IOException, 
 + concat(ownerJson("pA@g", 0, 1, 0), " ]"); // The "owners:[...]" substring contains only owners from pA. 
 logger.warn("Unable to process event {} on project {}", event, event.getProjectName(), e); 
 handleGitReferenceUpdatedAsUser(event, new Account.Id(updaterAccountInfo._accountId)); } else { handleGitReferenceUpdatedAsServer(event); 
 loggingCtx.setMutablePerformanceLogRecords(mutablePerformanceLogRecords); 
 CopyrightReviewApi reviewApi) { 
 @Override public void stop() {} 
<|del|> 
<|del|> 
<|del|> 
 // DraftHandling.KEEP is ignored on publishing a comment. 
 return assertAbout(optionals()).that(optional); 
 return that(optional, StandardSubjectBuilder::that); 
 @Nullable private PluginConfig gerritConfig; @Nullable private CheckConfig checkConfig; 
 throw new CommitValidationException( pluginName + "plugin failed to read new project.config", e); 
 */ @Nullable 
<|del|> 
 try (RevWalk rw = new RevWalk(repo); TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), filename, rw.parseTree(objectId))) { 
 try (RevWalk rw = new RevWalk(repo); TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), filename, rw.parseTree(objectId))) { 
<|del|> 
 install(new ZkValidationModule(config)); 
<|del|> 
 public ZkValidationModule(Configuration cfg) { this.cfg = new ZookeeperConfig(cfg.getMultiSiteConfig()); 
 private final FileBasedConfig config; 
 @Inject private CommentValidator mockCommentValidator; @Inject private TestCommentUtil testCommentUtil; 
 @Inject private CommentValidator mockCommentValidator; @Inject private TestCommentUtil testCommentUtil; 
 CommentValidator mockCommentValidator = EasyMock.createMock(CommentValidator.class); bind(CommentValidator.class) .annotatedWith(Exports.named(mockCommentValidator.getClass())) .toInstance(mockCommentValidator); bind(CommentValidator.class).toInstance(mockCommentValidator); 
 PushOneCommit.Result r = createChange(); 
 log.warn( 
<|del|> 
<|del|> 
 public static ImmutableList<CommentValidationFailure> findInvalidComments( 
 throws PatchListNotAvailableException { 
 /** * Retrieves the next available sequence number. * * <p>This method is thread-safe. * * @return the next available sequence number */ 
 // Keep blocking until we verified that another thread can retrieve a sequence number // while we are blocking here. while (isBlocking.get()) { // do nothing } }; 
<|del|> 
 log.warn( 
 /** * Creates a LoggingContextAwareCallable that wraps the given {@link Callable}. * 
 assertThat(testCommentHelper.getPublishedComments(r.getChangeId())).isEmpty(); BadRequestException badRequestException = 
 switch (err.getErrorCode()) { case 1022: // ER_DUP_KEY case 1062: // ER_DUP_ENTRY case 1169: // ER_DUP_UNIQUE; 
<|del|> 
 cfg.getBoolean( KAFKA_SECTION, KAFKA_PUBLISHER_SUBSECTION, ENABLE_KEY, DEFAULT_BROKER_ENABLED); 
 static final String KAFKA_PROPERTY_PREFIX = "KafkaProp-"; 
<|del|> 
<|del|> 
<|del|> 
 public static final String KAFKA_CONFIG = "multi-site.config"; 
 public static final String KAFKA_CONFIG = "multi-site.config"; 
<|del|> 
 private Provider<Producer<String, String>> producerProvider; private KafkaConfiguration properties; 
<|del|> 
<|del|> 
 private final Supplier<Collection<Message>> replicationConfigValidation; private final Config multiSiteConfig; 
 patterns = Arrays.asList(cfg.get().getStringList(CACHE_SECTION, null, PATTERN_KEY)); 
 static final String ENABLE_KEY = "enabled"; static final String DEFAULT_KAFKA_BOOTSTRAP_SERVERS = "localhost:9092"; static final boolean DEFAULT_ENABLE_PROCESSING = true; 
 // Building the following: // rcMaster (c1 master master-tag) <-- rcBranch (c2 branch branch-tag) // \ \ // (c3_open) (c4_open) // 
 .update(); // rcMaster (c1 master) 
 * <p>TODO(hiesel): Instrument this heuristic and proof its value. 
 */ @VisibleForTesting 
 /** Returns a URL pointing to a section of the settings page. */ 
 producer = producerProvider.get(); LOGGER.info("Connection established."); 
 producer = new KafkaProducer<>(properties.kafkaPublisher()); 
 /** Skip diffstat computation */ SKIP_DIFFSTAT(23); 
 if (!has(SKIP_DIFFSTAT)) { 
 return new PermissionRange( permissionName, Math.max(voteMin, blockAllowMin), Math.min(voteMax, blockAllowMax)); 
 this.handle = validators.add("test-" + rejectType.name(), this); 
 abstract Builder<T> formatter(Function<T, String> formatter); 
 /** @return formatter to format field values. */ public abstract Function<T, String> formatter(); 
 logDebug( 
 public Context start(F1 fieldValue) { return new Context(this, fieldValue); 
 return new AutoValue_Field.Builder<E>().valueType(enumType).formatter(Enum::name).name(name); 
 Field.ofInteger("status", Metadata.Builder::httpStatus) 
 public static Field.Builder<Boolean> ofBoolean( String name, BiConsumer<Metadata.Builder, Boolean> metadataMapper) { 
 abstract Builder<T> metadataMapper(BiConsumer<Metadata.Builder, T> metadataMapper); 
 Field.ofEnum(Operation.class, "operation", Metadata.Builder::gitOperation).build(); 
 // The type of change ID which the user used to identify a change (e.g. numeric ID, triplet etc.). 
 // The value of the @Export annotation which was used to register a plugin extension. public abstract Optional<String> exportValue(); 
<|del|> 
 public abstract Builder authDomainName(@Nullable String authDomainName); 
 * <p>Metadata to provide additional context can be included by provided a {@link Metadata} * instance. 
 public abstract Optional<Metadata> metadata(); 
 succeeded = sharedRefDb.compareAndPut(projectName, refPair.compareRef, refPair.putValue); 
 RefPair current = getLatestLocalRef(p); return new RefPair(p.compareRef, current.putValue); 
 * <li>{@code SKIP_DIFFSTAT} is omitted to skip diffstat calculations. 
 private List<RefPair> compareAndGetLatestLocalRefs( 
 protected RefPair compareAndGetLatestLocalRef( 
<|del|> 
 .renderHtml(out)); 
 return RefNames.isNoteDbMetaRef(refName) || refName.startsWith(RefNames.REFS_SEQUENCES); 
 return RefNames.isNoteDbMetaRef(refName) || refName.startsWith(RefNames.REFS_SEQUENCES); 
 (latestRefPair.compareRef.getObjectId().equals(ObjectId.zeroId())) ? !sharedRefDb.exists(projectName, refName) : sharedRefDb.isUpToDate(projectName, latestRefPair.compareRef); 
 logger.atFinest().log("REST call failed: %d", statusCode); 
 if (changeData.size() != 1) { // no change found (size = 0) or changeId was ambiguous (size > 1) 
 * Type of the request, telling through which channel the request was coming in (see {@link * RequestType}). 
<|del|> 
 private boolean isOwner(Project.NameKey project) { 
 * <li>{@code SKIP_DIFFSTAT} is omitted to ensure diffstat calculations. 
 /** * Skip diffstat computation that compute the insertions field (number of lines inserted) and * deletions field (number of lines deleted) */ 
 * @param accounts may be either just a list of: account IDs, Full names, usernames, or emails. * Also could be a list of those: "Full name <email@example.com>" or "Full name (<ID>)" 
 * @param accounts may be either just a list of: account IDs, Full names, usernames, or emails. * Also could be a list of those: "Full name <email@example.com>" or "Full name (<ID>)" 
 .create(admin.newIdent(), testRepo, SUBJECT, FILE_NAME, "initial content\n", changeId) 
 .create(admin.newIdent(), testRepo, SUBJECT, FILE_NAME, "initial content\n", changeId) 
<|del|>
 } catch (Exception e) { 
<|del|> 
<|del|> 
 DynamicItem.itemOf(binder(), ReplicationPushFilter.class); 
 assertThat(autoReloadConfig.getDestinations(FilterType.ALL)).hasSize(1); 
Copyright (C) 2019 The Android Open Source Project 
 public static boolean isActive() { 
 repository, path, parseCommit(repository, objectId).getTree())) { 
public class QuotaGroupDefinitions { /** * Definition of repository size quota group. {@link QuotaEnforcer} implementations for repository * size quota have to act on requests with this group name. */ 
<|del|> 
<|del|> 
 this.retryWithTraceOnFailure = cfg.getBoolean("retry", "retryWithTraceOnFailure", false); 
 * <p>Metadata to provide additional context can be included by providing a {@link Metadata} 
 Field.ofEnum(ActionType.class, "action_type", Metadata.Builder::actionType).build(); 
<|del|> 
 * <p>If a user specifies an unknown option and this unknown option doesn't get accepted, the 
 boolean accept(String name, @Nullable String value); 
 // This field is only used for staleness detection which will discover the 
 // Therefore, defer to the currently configured All-Users name. 
 eventsStorage.persist(project.get(), ref, e.getURI(), getRemoteConfigName()); 
 public String persist(String project, String ref, URIish uri, String remote) { String json = getEventJson(project, ref, uri, remote); 
 public void delete(String project, String ref, URIish uri, String remote) { String eventKey = getEventKey(getEventJson(project, ref, uri, remote)); 
 logger.atWarning().withCause(e).log( "Account %s has invalid filter in project watch %s", accountId, key); 
 @VisibleForTesting 
 push("refs/for/master", PushOneCommit.SUBJECT, "one.txt", "One"); PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "two.txt", "Two"); 
<|del|> 
 * Filter that is invoked before list of remote ref updates is pushed to remote instance. * * <p>It can be used to filter out unwanted updates. 
 this.replicationQueue = replicationQueue; this.autoReloadExecutor = workQueue.createQueue(1, pluginName + "_auto-reload-config"); 
 private String soyTemplate(String name, SanitizedContent.ContentKind kind) { 
 private static final String LOG_NAME = "sharedref_log"; 
 public void logRefUpdate(String project, Ref currRef, ObjectId newRefValue) { 
 public void logProjectDelete(String project) { 
 sharedRefLogger.logProjectDelete(projectName); 
 succeeded = sharedRefDb.compareAndPut(projectName, getLatestLocalRef(refPair), refPair.putValue); 
 if (lowerCase) { 
 repLog.info("Replication {} was canceled", getURI()); 
 repLog.info("Replication {} was canceled while being executed", getURI()); 
 if (!ObjectId.zeroId().equals(newRefValue)) { try (Repository repository = gitRepositoryManager.openRepository(new Project.NameKey(project)); RevWalk walk = new RevWalk(repository)) { 
 this.type = Type.DELETE_PROJECT; 
 ConfigUtil.getTimeUnit(config, "gerrit", null, "sshConnectionTimeout", 2, MINUTES)); 
 throw new ConfigInvalidException( 
 && requestTypes().stream() .noneMatch(type -> type.equalsIgnoreCase(requestInfo.requestType()))) { 
<|del|> 
<|del|> 
<|del|> 
 @Inject private RequestScopeOperations requestScopeOperations; @Inject private ProjectOperations projectOperations; 
<|del|> 
<|del|> 
 public void rerunFinishedCheck() throws Exception { checkOperations.newCheck(checkKey).state(CheckState.SUCCESSFUL).upsert(); 
 CheckInfo info = checksApiFactory.revision(patchSetId).id(checkKey.checkerUuid()).rerun(); 
 throws RestApiException, IOException, ConfigInvalidException, PermissionBackendException { 
<|del|> 
 /** Description of the checker that produced this check */ public String checkerDescription; 
 /** Description of the checker that produced this check */ public String checkerDescription; 
 // - 32px for avatars next to names e.g. on the dashboard. This is also Gerrit's default. 
Copyright (C) 2019 The Android Open Source Project 
Copyright (C) 2019 The Android Open Source Project 
 private GitRepositoryManager gitRepositoryManagerMock; private Repository repositoryMock; private PermissionBackend permissionBackendMock; private PermissionBackend.WithUser withUserMock; private PermissionBackend.ForProject forProjectMock; 
 while (!isCallFinished.get()) { 
 private void setupGitRepoManagerMock() throws IOException { 
<|del|> 
<|del|> 
<|del|> 
 private final Provider<CurrentUser> self; private final PermissionBackend permissionBackend; private final AdministrateCheckersPermission permission; private final Checks checks; private final Provider<ChecksUpdate> checksUpdate; private final CheckJson.Factory checkJsonFactory; 
/** Loads cache values for the external ID cache using either a full or a partial reload. */ @Singleton 
 // is found within this number of parents, we fall back to reading everything from scratch. 
 config.getBoolean("cache", ExternalIdCacheImpl.CACHE_NAME, "enablePartialReloads", false); 
 private String projectControl; 
 * @param started Set the time the check started. Time can be reset to "null" if passed @code * new Timestamp(0) 
 // is found within this number of parents, we fall back to reading everything from scratch. 
 RevCommit currentCommit = rw.parseCommit(extIdRef.getObjectId()); 
 int i = 0; while ((parentWithCacheValue = rw.next()) != null && i++ < MAX_HISTORY_LOOKBACK) { 
<|del|> 
 return ObjectId.fromString(CharMatcher.is('/').removeFrom(path)); 
<|del|> 
 // Partial or full computation 
 sshdThreads = cfg.getInt("sshd", "threads", Math.max(4, 2 * cores)); 
 public void insert(Account.Builder account) throws IOException { 
 allUsersName.get() + ":" + RefNames.refsUsers(account.id()) + ":" + metaId; 
 private final Provider<ProjectCache> projectCacheProvider; 
 && Objects.equals(other.checkerDescription, checkerDescription); 
 * @param started Set the time the check started. Time can be reset to "null" if passed @code * new Timestamp(0) 
 * @param started Set the time the check started. Time can be reset to "null" if passed @code * new Timestamp(0) 
 * @param started Set the time the check started. Time can be reset to "null" if passed {@code * new Timestamp(0)} 
 Account persistedAccount = accounts.insert( Account.builder(id, TimeUtil.nowTs()).setFullName(name).setPreferredEmail(email)); 
 if (requireChangeId && changeIdFooters.isEmpty()) { 
 /** Reruns the check and returns the {@link CheckInfo} for the updated check. */ 
 @Override 
 @Inject private RequestScopeOperations requestScopeOperations; @Inject private ProjectOperations projectOperations; 
 checkOperations.newCheck(checkKey).state(CheckState.NOT_STARTED).upsert(); 
 public void rerunNotExistingCheckerThrowsError() throws Exception { 
 .add("checkerDescription", checkerDescription) 
<|del|> 
 @Test public void doesFullReloadWhenNoCacheStateIsFound() throws Exception { ObjectId head = insertExternalId(1, 1); assertThat(loader.load(head)).isEqualTo(allFromGit(head)); verify(externalIdReaderSpy, times(1)).all(head); } @Test 
 assertThat(timestamp).isEqualTo(TimeUtil.never()); 
 Iterables.getOnlyElement(queryProvider.get().byKey(new Change.Key(r.getChangeId()))); assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED); 
<|del|> 
 this(add); 
 assertThat(info.state).isEqualTo(CheckState.NOT_STARTED); 
 /** Wrapper class to stream rendered output to a {@link Writer}. */ 
 .setData(toHeaderSoyData(paginator, revision)), out); 
 public String renderHtml(String templateName, Map<String, ?> soyData) { 
 .setIj(ImmutableMap.of("staticUrls", staticUrls.build())); 
 // The requested value was not in the cache (hence, this loader was invoked). Therefore, try to // create this entry from a past value using the minimal amount of Git operations possible to // reduce latency. 
 // The requested value was not in the cache (hence, this loader was invoked). Therefore, try to // create this entry from a past value using the minimal amount of Git operations possible to // reduce latency. 
 private static AllExternalIds buildAllExternalIds( 
 private static AllUsersName ALL_USERS = new AllUsersName(AllUsersNameProvider.DEFAULT); 
 logger.atWarning().log("Expected an existing value for enum %s.", typeToken); 
 public void lowerCaseEnumValueIsTreatedAsUnset() { TestData data = gson.fromJson("{\"value\":\"one\"}", TestData.class); assertThat(data.value).isNull(); 
 Thread.sleep(100); if (retryCount++ > MAX_RETRY_COUNT) { fail("Waiting until call finished - maximum number of retires reached"); } 
<|del|> 
<|del|> 
 return getWatchedProjects.apply(rsrc); 
 Response<?> response = query.apply(TopLevelResource.INSTANCE); List<ChangeInfo> value = (List<ChangeInfo>) response.value(); return Response.ok(value); 
 public Response<?> apply(ProjectResource rsrc, Input input) { 
 Response<DashboardInfo> response = get.get().apply(target); response.value().isDefault = true; return response; 
 public Object apply(ProjectResource rsrc, Input input) throws IOException, RestApiException { 
<|del|> 
<|del|> 
 /** * Gerrit libModule for applying a ref-filter for outgoing replications. * * <p>It should be used only when an actual filter is defined, otherwise the default replication * plugin behaviour will be pushing all refs without any filtering. */ 
 public void shouldPushAllRefsWhenNoFiltersSetup() throws InterruptedException, IOException { shouldPushAllRefsWithDynamicItemFilter(null); } 
 public void shouldBlockReplicationUsingPushFilter() throws InterruptedException, IOException { 
 return Collections.emptyList(); 
 .newCommentFormatter(); 
 // Name of config parameters that can be defined in project.config or gerrit.config: 
 logger.atSevere().log("Project %s has empty %s", project, OWNERS_FILE_NAME); 
 * {@link ExternalIds}. 
<|del|> 
<|del|> 
 DynamicItem<SharedRefDatabase> sharedRefDbDynamicItem, SharedRefLogger sharedRefLogger) { this.sharedRefDbDynamicItem = sharedRefDbDynamicItem; 
 DynamicItem<SharedRefDatabase> sharedRefDbDynamicItem, SharedRefLogger sharedRefLogger) { this.sharedRefDbDynamicItem = sharedRefDbDynamicItem; 
<|del|> 
 public void contributorSectionIsUnsetIfNoContributorAgreementIsSet() throws Exception { 
 public void notifySectionIsUnsetIfNoNotificationsAreSet() throws Exception { 
 public void commentLinkSectionIsUnsetIfNoCommentLinksAreSet() throws Exception { 
 assertThat(submitRecords).isPresent(); 
 * SubmitRecord}. 
 Optional<SubmitRecord> submitRecord = rule.evaluate(r.getChange()); 
 Optional<SubmitRecord> submitRecord = rule.evaluate(r.getChange()); assertThat(submitRecord).isEmpty(); 
 assertThat(record).isPresent(); 
 assertThat(record).hasValue(expectedRecord); 
 assertThat(record).hasValue(expectedRecord); 
<|del|> 
<|del|> 
 Field.ofString(PUBLISHER_FAILURE_COUNTER, metadataMapper(PUBLISHER_FAILURE_COUNTER)) 
 private Field<String> field(String metadataKey, String description) { return Field.ofString( metadataKey, (metadataBuilder, fieldValue) -> metadataBuilder.addPluginMetadata(PluginMetadata.create(metadataKey, fieldValue))) .description(description) .build(); 
 } catch (Exception e) { 
 "Cannot handle message %s: [Exception: %s]", event.getHeader().getEventType()); subscriberMetrics.incrementSubscriberFailedToConsumeMessage(); 
 SubscriberMetrics subscriberMetrics) { 
 SubscriberMetrics subscriberMetrics) { 
 SubscriberMetrics subscriberMetrics) { 
 SubscriberMetrics subscriberMetrics) { 
 String replacement) { 
 boolean publish(String topic, String payload); 
 // This error should not be thrown since this case is filtered before reaching this code. // Also return a backfilled check for checkers that do not apply to the change. 
 // This error should not be thrown since this case is filtered before reaching this code. // Also return a backfilled check for checkers that do not apply to the change. 
 Project.NameKey otherProject = projectOperations.newProject().create(); 
 /** Factory for creating an {@link AdminApi} instance for a remote URI. */ 
 throw new ResourceConflictException( "base revision is missing from the destination branch: " + str); 
 private final Provider<KafkaEventSubscriber> subscriberProvider; private List<KafkaEventSubscriber> subscribers; 
 public void receiveAync(String topic, Consumer<SourceAwareEventWrapper> eventConsumer) { KafkaEventSubscriber subscriber = subscriberProvider.get(); subscribers.add(subscriber); 
 install(kafkaForwardedEventRouterModule); 
 public void receiveAync(String topic, Consumer<SourceAwareEventWrapper> eventConsumer) { apiDelegate.get().receiveAync(topic, eventConsumer); 
 synchronized (subscribers) { subscribers.add(subscriber); } 
<|del|> 
 @Override public StoredConfig getUserConfig() throws IOException, ConfigInvalidException { return oldSystemReader.getUserConfig(); } 
 private final ReplicationTasksStorage replicationTasksStorage; 
 ReplicationTasksStorage rts, 
 replicationTasksStorage.persist(project.get(), ref, e.getURI(), getRemoteConfigName()); 
 replicationTasksStorage.delete( 
 private final ReplicationTasksStorage replicationTasksStorage; 
 ReplicationTasksStorage rts) { 
 Set<String> tasksReplayed = new HashSet<>(); 
 PushOne task = getPendingPush(uri); if (task == null) { task = opFactory.create(project, uri); addRef(task, ref); task.addState(ref, state); 
 void notifyFinished(PushOne task) { 
 String taskJson = GSON.toJson(r) + "\n"; String taskKey = sha1(taskJson).name(); 
 String taskJson = GSON.toJson(r) + "\n"; String taskKey = sha1(taskJson).name(); 
 replicationTasksStorage.persist( new ReplicateRefUpdate(projectName, refName, uri, cfg.getRemoteConfigName())); 
 private void firePendingTasks() { 
 String eventKey = String.format("%s:%s", t.project, t.ref); if (!eventsReplayed.contains(eventKey)) { repLog.info("Firing pending task {}", eventKey); 
 public String persist(ReplicateRefUpdate r) { 
 logger.atWarning().withCause(e).log("Couldn't persist event %s", json); 
<|del|> 
 private Path pluginDataDir; 
 .collect(toList()); 
 ReplicationState(PushResultProcessing processing) { 
<|del|>
 public Optional<Change> getUpdatedChange() { return Optional.ofNullable(updatedChange); 
 try(Repository repository = repoManager.openRepository(key)) { RepositoryCache.close(repository); } 
 cleanJGitCache(key); 
 return currentConfig.getConfig().getBoolean("gerrit", "autoReload", false); 
 if (!(p.equals("/") && options.enableGwtUi())) { 
 public ReplicateRefUpdate(String project, String ref, URIish uri, String remote) { this.project = project; this.ref = ref; this.uri = uri.toASCIIString(); this.remote = remote; 
 Path file = refUpdates().resolve(eventKey); 
 logger.atFine().log("CREATE %s (%s:%s => %s)", file, r.project, r.ref, r.uri); Files.write(file, json.getBytes(UTF_8)); 
 Path file = refUpdates().resolve(taskKey); 
 Path file = refUpdates().resolve(taskKey); 
 logger.atFine().log("DELETE %s (%s:%s => %s)", file, r.project, r.ref, r.uri); Files.delete(file); 
import static com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS; import static com.google.gerrit.testutil.GerritJUnit.assertThrows; 
<|del|> 
 Repository sourceRepo = repoManager.openRepository(project)) { 
 "change %s of project %s unexpectedly had status %s after submit attempt", updatedChange.getId(), updatedChange.getProject(), updatedChange.getStatus()); logger.atWarning().log(msg); throw new RestApiException(msg); 
 waitUntil(() -> projectExists(new Project.NameKey(sourceProject + "replica.git"))); 
 waitUntil(() -> projectExists(new Project.NameKey(sourceProject + "replica.git"))); 
<|del|> 
<|del|> 
 private TestBroadCast mTestBroadCast; 
<|del|>
<|del|>
 PlatformConfig cfg = new PlatformConfig(ServiceType.IN_PROC, 
 private static RIHelper s_mRiHelperInstance = null; 
 * 8. onPostListener event handler 
<|del|>
 mPMHelper.clearAll(); 
<|del|> 
 * 2. queryParamsMap map with query paramter and value * 3. OnPutListener event handler 
 PlatformConfig cfg = new PlatformConfig(ServiceType.IN_PROC, 
 String HOST = "coap://192.168.1.2:5000"; 
<|del|>
 * // Copyright 2018 Intel Corporation All Rights Reserved. 
 * // Copyright 2018 Intel Corporation All Rights Reserved. 
 * // Copyright 2016-2018 Intel Corporation All Rights Reserved. 
 * // Copyright 2016-2018 Intel Corporation All Rights Reserved. 
 public static final String OCF_OIC_URI_PREFIX_MEDIA_CONTROL = "/ocf/mediaControl/"; public static final String UPNP_OIC_URI_PREFIX_MEDIA_CONTROL = "/upnp/mediaControl/"; 
 * // Copyright 2016-2018 Intel Corporation All Rights Reserved. 
 static public final String RESOURCE_TYPE = "oic.d.light"; static public final String DEVICE_RESOURCE_TYPE = "oic.wk.d"; 
 public void update(int brightness) { 
<|del|>
 OCMain.setDelayedCallback(stopObserve, 30); 
 // nextEvent and now are in microseconds long timeToWait = (nextEvent - now) * 1000; 
 int ret = OCMain.initPlatform("Android"); ret |= OCMain.addDevice("/oic/d", "oic.d.phone", "Kishen's Android Phone", "ocf.1.0.0", "ocf.res.1.0.0"); 
 OCMain.repSetInt(root, "a", 1); 
 System.out.println("inside ObtInitHandler.initilize()"); 
 if (0 > OCObt.discoverOwnedDevices(ownedDeviceHandler)) { 
 System.out.print("Enter resource type [" + (j + 1) + "]: "); 
 System.out.println("inside ObtInitHandler.initilize()"); 
<|del|> 
 long timeToWait = (NANOS_PER_SECOND / OCClock.OC_CLOCK_SECOND) * (nextEvent - now); 
 new PostLightRequestHandler(activity, light).handler(request, interfaces); 
<|del|> 
 // the factory presets handler must be set prior to calling systemInit(). // The systemInit() function will cause the factory presets handler to // be called if it is set. 
 // the factory presets handler must be set prior to calling systemInit(). // The systemInit() function will cause the factory presets handler to // be called if it is set. 
 System.out.println("Get Owned Device Name Handler:"); 
 System.out.println("Get Unowned Device Name Handler:"); 
 public boolean getBoolean() throws OcCborException { 
 public long getLong() throws OcCborException { 
 public double getDouble() throws OcCborException { 
<|del|> 
 public boolean getBoolean(String key) throws OcCborException { 
 public long getLong(String key) throws OcCborException { 
 public double getDouble(String key) throws OcCborException { 
 if ((nativeRep != null) && (OCRep.getCborErrno() == 0)) { 
 } refreshState(); 
<|del|> 
 int qsQuickPulldownValue = Settings.System.getInt( mContext.getContentResolver(), Settings.System.STATUS_BAR_QUICK_QS_PULLDOWN, 0); 
 View v = mInflater.inflate(R.layout.app_grid_item, null); 
 mShowIndicator = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HIDE_LOCKSCREEN_INDICATOR_DISPLAY, 0, UserHandle.USER_CURRENT) == 0; 
 Settings.System.QS_PANEL_BG_ALPHA, 221, 
 boolean locationDisabled = Settings.Secure.getInt(getActivity().getContentResolver(), 
 boolean disableIfMusicActive = getPrefs(context).getBoolean(EventServiceSettings.EVENT_MUSIC_ACTIVE, true); 
<|del|> 
 case MotionEvent.ACTION_CANCEL: 
private void initDimens() { public final int MAX_VISIBLE_ICONS_WHEN_DARK = getResources().getInteger(R.integer.config_maxVisibleNotificationIconsWhenDark); public final int MAX_STATIC_ICONS = getResources().getInteger(R.integer.config_maxVisibleNotificationIcons); 
 //public static final int MAX_VISIBLE_ICONS_WHEN_DARK = 5; //public static final int MAX_STATIC_ICONS = 4; 
 public int MAX_VISIBLE_ICONS_WHEN_DARK = 5; public int MAX_STATIC_ICONS = 4; 
 // Use the SystemUI context, so the toast gets themed properly. Toast.makeText(mSysUiContext, toastText, Toast.LENGTH_SHORT).show(); 
 log.info("provisionONT with device id : {} success : {}" + serialNumber, result); 
 log.info("createChassis with clli : {}" , request.getCLLI()); 
 // Get the uplink port Port uplinkPort = getUplinkPort(deviceService.getDevice(port.deviceId())); if (uplinkPort == null) { log.warn("No uplink port found for OLT device {}", port.deviceId()); 
<|del|>
 /** * {@inheritDoc} */ @Override protected boolean resolve() { return CapellaECrossReferenceAdapter.this.resolve(); 
 private static Map<String, String> filterNameExceptions; private Map<DiagramDescription, Set<String>> validFilterNames; 
 protected IsHumanCheckbox isHumanCheckbox; protected IsActorCheckbox isActorCheckbox; 
 if (isHumanCheckbox.isEnabled() && (isAnOE || isASystem || hasChildren)) { 
 if (isActorCheckbox.isEnabled() && (isInSALevel || isASystem || cannotBecameComponent || cannotBecameActor)) { 
 * Copyright (c) 2006, 2019 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2019 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2019 THALES GLOBAL SERVICES. 
<|del|> 